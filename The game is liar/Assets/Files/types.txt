// -------- {mscorlib(D:\Programs\2020.3.38f1\Editor\Data\MonoBleedingEdge\lib\mono\unityjit\mscorlib.dll)}: 2910 --------
//using System;
//using System.Runtime.InteropServices;

namespace Microsoft.Win32
{
    [ComVisible(True)]
    public static class Registry
    {
        public static readonly RegistryKey ClassesRoot;
        public static readonly RegistryKey CurrentConfig;
        public static readonly RegistryKey CurrentUser;
        [Obsolete("Use PerformanceData instead")]
        public static readonly RegistryKey DynData;
        public static readonly RegistryKey LocalMachine;
        public static readonly RegistryKey PerformanceData;
        public static readonly RegistryKey Users;

        public static void SetValue(string keyName, string valueName, object value);
        public static void SetValue(string keyName, string valueName, object value, RegistryValueKind valueKind);
        public static object GetValue(string keyName, string valueName, object defaultValue);
    }
}
//using System.Runtime.InteropServices;

namespace Microsoft.Win32
{
    [ComVisible(True)]
    public enum RegistryHive
    {
        ClassesRoot = -2147483648,
        CurrentConfig = -2147483643,
        CurrentUser = -2147483647,
        DynData = -2147483642,
        LocalMachine = -2147483646,
        PerformanceData = -2147483644,
        Users = -2147483645
    }
}
//using Microsoft.Win32.SafeHandles;
//using System;
//using System.Runtime.InteropServices;
//using System.Security.AccessControl;

namespace Microsoft.Win32
{
    [ComVisible(True)]
    public sealed class RegistryKey : MarshalByRefObject, IDisposable
    {
        public string Name { get; }
        public int SubKeyCount { get; }
        public int ValueCount { get; }
        [MonoTODO("Not implemented in Unix")]
        [ComVisible(False)]
        public SafeRegistryHandle Handle { get; }
        [MonoLimitation("View is ignored in Mono.")]
        [ComVisible(False)]
        public RegistryView View { get; }

        public void Dispose();
        public void Flush();
        public void Close();
        public void SetValue(string name, object value);
        [ComVisible(False)]
        public void SetValue(string name, object value, RegistryValueKind valueKind);
        public RegistryKey OpenSubKey(string name);
        public RegistryKey OpenSubKey(string name, bool writable);
        public object GetValue(string name);
        public object GetValue(string name, object defaultValue);
        [ComVisible(False)]
        public object GetValue(string name, object defaultValue, RegistryValueOptions options);
        [ComVisible(False)]
        public RegistryValueKind GetValueKind(string name);
        public RegistryKey CreateSubKey(string subkey);
        [MonoLimitation("permissionCheck is ignored in Mono")]
        [ComVisible(False)]
        public RegistryKey CreateSubKey(string subkey, RegistryKeyPermissionCheck permissionCheck);
        [ComVisible(False)]
        [MonoLimitation("permissionCheck and registrySecurity are ignored in Mono")]
        public RegistryKey CreateSubKey(string subkey, RegistryKeyPermissionCheck permissionCheck, RegistrySecurity registrySecurity);
        [MonoLimitation("permissionCheck is ignored in Mono")]
        [ComVisible(False)]
        public RegistryKey CreateSubKey(string subkey, RegistryKeyPermissionCheck permissionCheck, RegistryOptions options);
        [MonoLimitation("permissionCheck and registrySecurity are ignored in Mono")]
        [ComVisible(False)]
        public RegistryKey CreateSubKey(string subkey, RegistryKeyPermissionCheck permissionCheck, RegistryOptions registryOptions, RegistrySecurity registrySecurity);
        [ComVisible(False)]
        public RegistryKey CreateSubKey(string subkey, bool writable);
        [ComVisible(False)]
        public RegistryKey CreateSubKey(string subkey, bool writable, RegistryOptions options);
        public void DeleteSubKey(string subkey);
        public void DeleteSubKey(string subkey, bool throwOnMissingSubKey);
        public void DeleteSubKeyTree(string subkey);
        public void DeleteSubKeyTree(string subkey, bool throwOnMissingSubKey);
        public void DeleteValue(string name);
        public void DeleteValue(string name, bool throwOnMissingValue);
        public RegistrySecurity GetAccessControl();
        public RegistrySecurity GetAccessControl(AccessControlSections includeSections);
        public string[] GetSubKeyNames();
        public string[] GetValueNames();
        [ComVisible(False)]
        [MonoTODO("Not implemented on unix")]
        public static RegistryKey FromHandle(SafeRegistryHandle handle);
        [ComVisible(False)]
        [MonoTODO("Not implemented on unix")]
        public static RegistryKey FromHandle(SafeRegistryHandle handle, RegistryView view);
        [MonoTODO("Not implemented on unix")]
        public static RegistryKey OpenRemoteBaseKey(RegistryHive hKey, string machineName);
        [ComVisible(False)]
        [MonoTODO("Not implemented on unix")]
        public static RegistryKey OpenRemoteBaseKey(RegistryHive hKey, string machineName, RegistryView view);
        [MonoLimitation("View is ignored in Mono")]
        [ComVisible(False)]
        public static RegistryKey OpenBaseKey(RegistryHive hKey, RegistryView view);
        [ComVisible(False)]
        public RegistryKey OpenSubKey(string name, RegistryKeyPermissionCheck permissionCheck);
        [MonoLimitation("rights are ignored in Mono")]
        [ComVisible(False)]
        public RegistryKey OpenSubKey(string name, RegistryRights rights);
        [ComVisible(False)]
        [MonoLimitation("rights are ignored in Mono")]
        public RegistryKey OpenSubKey(string name, RegistryKeyPermissionCheck permissionCheck, RegistryRights rights);
        public void SetAccessControl(RegistrySecurity registrySecurity);
        public override string ToString();
    }
}
namespace Microsoft.Win32
{
    public enum RegistryKeyPermissionCheck
    {
        Default = 0,
        ReadSubTree = 1,
        ReadWriteSubTree = 2
    }
}
//using System;

namespace Microsoft.Win32
{
    [Flags]
    public enum RegistryOptions
    {
        None = 0,
        Volatile = 1
    }
}
//using System.Runtime.InteropServices;

namespace Microsoft.Win32
{
    [ComVisible(True)]
    public enum RegistryValueKind
    {
        Unknown = 0,
        String = 1,
        ExpandString = 2,
        Binary = 3,
        DWord = 4,
        MultiString = 7,
        QWord = 11,
        None = -1
    }
}
//using System;

namespace Microsoft.Win32
{
    [Flags]
    public enum RegistryValueOptions
    {
        None = 0,
        DoNotExpandEnvironmentNames = 1
    }
}
namespace Microsoft.Win32
{
    public enum RegistryView
    {
        Default = 0,
        Registry64 = 256,
        Registry32 = 512
    }
}
//using System;
//using System.Security;

namespace Microsoft.Win32.SafeHandles
{
    [SecurityCritical]
    public sealed class SafeFileHandle : SafeHandleZeroOrMinusOneIsInvalid
    {
        public SafeFileHandle(IntPtr preexistingHandle, bool ownsHandle);

        [SecurityCritical]
        protected override bool ReleaseHandle();
    }
}
//using System;
//using System.Security;

namespace Microsoft.Win32.SafeHandles
{
    [SecurityCritical]
    public sealed class SafeRegistryHandle : SafeHandleZeroOrMinusOneIsInvalid
    {
        [SecurityCritical]
        public SafeRegistryHandle(IntPtr preexistingHandle, bool ownsHandle);

        [SecurityCritical]
        protected override bool ReleaseHandle();
    }
}
//using System;
//using System.Runtime.ConstrainedExecution;
//using System.Security;

namespace Microsoft.Win32.SafeHandles
{
    [SecurityCritical]
    public sealed class SafeWaitHandle : SafeHandleZeroOrMinusOneIsInvalid
    {
        [ReliabilityContract(WillNotCorruptState, MayFail)]
        public SafeWaitHandle(IntPtr existingHandle, bool ownsHandle);

        [SecurityCritical]
        protected override bool ReleaseHandle();
    }
}
//using System.Runtime.ConstrainedExecution;
//using System.Runtime.InteropServices;
//using System.Security;

namespace Microsoft.Win32.SafeHandles
{
    [SecurityCritical]
    public abstract class SafeHandleZeroOrMinusOneIsInvalid : SafeHandle
    {
        [ReliabilityContract(WillNotCorruptState, MayFail)]
        protected SafeHandleZeroOrMinusOneIsInvalid(bool ownsHandle);

        public override bool IsInvalid { get; }
    }
}
//using System.Runtime.ConstrainedExecution;
//using System.Runtime.InteropServices;
//using System.Security;

namespace Microsoft.Win32.SafeHandles
{
    [SecurityCritical]
    public abstract class SafeHandleMinusOneIsInvalid : SafeHandle
    {
        [ReliabilityContract(WillNotCorruptState, MayFail)]
        protected SafeHandleMinusOneIsInvalid(bool ownsHandle);

        public override bool IsInvalid { get; }
    }
}
//using System.Runtime.ConstrainedExecution;
//using System.Runtime.InteropServices;
//using System.Security;

namespace Microsoft.Win32.SafeHandles
{
    [SecurityCritical]
    public abstract class CriticalHandleZeroOrMinusOneIsInvalid : CriticalHandle
    {
        [ReliabilityContract(WillNotCorruptState, MayFail)]
        protected CriticalHandleZeroOrMinusOneIsInvalid();

        public override bool IsInvalid { get; }
    }
}
//using System.Runtime.ConstrainedExecution;
//using System.Runtime.InteropServices;
//using System.Security;

namespace Microsoft.Win32.SafeHandles
{
    [SecurityCritical]
    public abstract class CriticalHandleMinusOneIsInvalid : CriticalHandle
    {
        [ReliabilityContract(WillNotCorruptState, MayFail)]
        protected CriticalHandleMinusOneIsInvalid();

        public override bool IsInvalid { get; }
    }
}
//using System;
//using System.Runtime.InteropServices;
//using System.Security;

namespace Microsoft.Win32.SafeHandles
{
    [SecurityCritical]
    public sealed class SafeAccessTokenHandle : SafeHandle
    {
        public SafeAccessTokenHandle(IntPtr handle);

        public static SafeAccessTokenHandle InvalidHandle { get; }
        public override bool IsInvalid { get; }

        [SecurityCritical]
        protected override bool ReleaseHandle();
    }
}
//using System.Buffers;
//using System.Diagnostics;

namespace System
{
    [DebuggerTypeProxy(typeof(MemoryDebugView<>))]
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    public readonly struct Memory<T>
    {
        public Memory(T[] array);
        public Memory(T[] array, int start, int length);

        public static Memory<T> Empty { get; }
        public int Length { get; }
        public bool IsEmpty { get; }
        public Span<T> Span { get; }

        public Memory<T> Slice(int start);
        public Memory<T> Slice(int start, int length);
        public MemoryHandle Retain(bool pin = False);
        public bool TryGetArray(out ArraySegment<T> arraySegment);
        public T[] ToArray();
        public override bool Equals(object obj);
        public bool Equals(Memory<T> other);
        public override int GetHashCode();

        public static implicit operator Memory<T>(T[] array);
        public static implicit operator Memory<T>(ArraySegment<T> arraySegment);
        public static implicit operator ReadOnlyMemory<T>(Memory<T> memory);
    }
}
//using System.Buffers;
//using System.Diagnostics;

namespace System
{
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    [DebuggerTypeProxy(typeof(MemoryDebugView<>))]
    public readonly struct ReadOnlyMemory<T>
    {
        public ReadOnlyMemory(T[] array);
        public ReadOnlyMemory(T[] array, int start, int length);

        public static ReadOnlyMemory<T> Empty { get; }
        public int Length { get; }
        public bool IsEmpty { get; }
        public ReadOnlySpan<T> Span { get; }

        public ReadOnlyMemory<T> Slice(int start);
        public ReadOnlyMemory<T> Slice(int start, int length);
        public MemoryHandle Retain(bool pin = False);
        public bool DangerousTryGetArray(out ArraySegment<T> arraySegment);
        public T[] ToArray();
        public override bool Equals(object obj);
        public bool Equals(ReadOnlyMemory<T> other);
        public override int GetHashCode();

        public static implicit operator ReadOnlyMemory<T>(T[] array);
        public static implicit operator ReadOnlyMemory<T>(ArraySegment<T> arraySegment);
    }
}
//using System.Diagnostics;
//using System.Reflection;

namespace System
{
    [Obsolete("Types with embedded references are not supported in this version of your compiler.", True)]
    [DebuggerTypeProxy(typeof(SpanDebugView<>))]
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    [DefaultMember("Item")]
    public readonly ref struct ReadOnlySpan<T>
    {
        public ReadOnlySpan(T[] array);
        public ReadOnlySpan(T[] array, int start, int length);
        public ReadOnlySpan(void* pointer, int length);

        public T this[int index] { get; }
        public int Length { get; }
        public bool IsEmpty { get; }
        public static ReadOnlySpan<T> Empty { get; }

        public static ReadOnlySpan<T> DangerousCreate(object obj, ref T objectData, int length);
        public void CopyTo(Span<T> destination);
        public bool TryCopyTo(Span<T> destination);
        [Obsolete("Equals() on Span will always throw an exception. Use == instead.")]
        public override bool Equals(object obj);
        [Obsolete("GetHashCode() on Span will always throw an exception.")]
        public override int GetHashCode();
        public ReadOnlySpan<T> Slice(int start);
        public ReadOnlySpan<T> Slice(int start, int length);
        public T[] ToArray();
        public ref T DangerousGetPinnableReference();

        public static bool operator ==(ReadOnlySpan<T> left, ReadOnlySpan<T> right);
        public static bool operator !=(ReadOnlySpan<T> left, ReadOnlySpan<T> right);

        public static implicit operator ReadOnlySpan<T>(T[] array);
        public static implicit operator ReadOnlySpan<T>(ArraySegment<T> arraySegment);
    }
}
//using System.Diagnostics;
//using System.Reflection;

namespace System
{
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    [DebuggerTypeProxy(typeof(SpanDebugView<>))]
    [DefaultMember("Item")]
    [Obsolete("Types with embedded references are not supported in this version of your compiler.", True)]
    public readonly ref struct Span<T>
    {
        public Span(T[] array);
        public Span(T[] array, int start, int length);
        public Span(void* pointer, int length);

        public ref T this[int index] { get; }
        public int Length { get; }
        public bool IsEmpty { get; }
        public static Span<T> Empty { get; }

        public static Span<T> DangerousCreate(object obj, ref T objectData, int length);
        public void Clear();
        public void Fill(T value);
        public void CopyTo(Span<T> destination);
        public bool TryCopyTo(Span<T> destination);
        [Obsolete("Equals() on Span will always throw an exception. Use == instead.")]
        public override bool Equals(object obj);
        [Obsolete("GetHashCode() on Span will always throw an exception.")]
        public override int GetHashCode();
        public Span<T> Slice(int start);
        public Span<T> Slice(int start, int length);
        public T[] ToArray();
        public ref T DangerousGetPinnableReference();

        public static bool operator ==(Span<T> left, Span<T> right);
        public static bool operator !=(Span<T> left, Span<T> right);

        public static implicit operator Span<T>(T[] array);
        public static implicit operator Span<T>(ArraySegment<T> arraySegment);
        public static implicit operator ReadOnlySpan<T>(Span<T> span);
    }
}
namespace System
{
    public static class SpanExtensions
    {
        public static Span<byte> AsBytes<T>(this Span<T> source) where T : struct;
        public static ReadOnlySpan<byte> AsBytes<T>(this ReadOnlySpan<T> source) where T : struct;
        public static ReadOnlySpan<char> AsReadOnlySpan(this string text);
        public static Span<TTo> NonPortableCast<TFrom, TTo>(this Span<TFrom> source) where TFrom : struct where TTo : struct;
        public static ReadOnlySpan<TTo> NonPortableCast<TFrom, TTo>(this ReadOnlySpan<TFrom> source) where TFrom : struct where TTo : struct;
        public static int IndexOf<T>(this Span<T> span, T value) where T : IEquatable<T>, struct;
        public static int IndexOf(this Span<byte> span, byte value);
        public static int IndexOf<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>, struct;
        public static int IndexOf(this Span<byte> span, ReadOnlySpan<byte> value);
        public static bool SequenceEqual<T>(this Span<T> first, ReadOnlySpan<T> second) where T : IEquatable<T>, struct;
        public static bool SequenceEqual(this Span<byte> first, ReadOnlySpan<byte> second);
        public static int IndexOf<T>(this ReadOnlySpan<T> span, T value) where T : IEquatable<T>, struct;
        public static int IndexOf(this ReadOnlySpan<byte> span, byte value);
        public static int IndexOf<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>, struct;
        public static int IndexOf(this ReadOnlySpan<byte> span, ReadOnlySpan<byte> value);
        public static int IndexOfAny(this Span<byte> span, byte value0, byte value1);
        public static int IndexOfAny(this Span<byte> span, byte value0, byte value1, byte value2);
        public static int IndexOfAny(this Span<byte> span, ReadOnlySpan<byte> values);
        public static int IndexOfAny(this ReadOnlySpan<byte> span, byte value0, byte value1);
        public static int IndexOfAny(this ReadOnlySpan<byte> span, byte value0, byte value1, byte value2);
        public static int IndexOfAny(this ReadOnlySpan<byte> span, ReadOnlySpan<byte> values);
        public static bool SequenceEqual<T>(this ReadOnlySpan<T> first, ReadOnlySpan<T> second) where T : IEquatable<T>, struct;
        public static bool SequenceEqual(this ReadOnlySpan<byte> first, ReadOnlySpan<byte> second);
        public static bool StartsWith(this Span<byte> span, ReadOnlySpan<byte> value);
        public static bool StartsWith<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>, struct;
        public static bool StartsWith(this ReadOnlySpan<byte> span, ReadOnlySpan<byte> value);
        public static bool StartsWith<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>, struct;
        public static Span<T> AsSpan<T>(this T[] array);
        public static Span<T> AsSpan<T>(this ArraySegment<T> arraySegment);
        public static ReadOnlySpan<T> AsReadOnlySpan<T>(this T[] array);
        public static ReadOnlySpan<T> AsReadOnlySpan<T>(this ArraySegment<T> arraySegment);
        public static void CopyTo<T>(this T[] array, Span<T> destination);
    }
}
namespace System
{
    public static class TupleExtensions
    {
        public static void Deconstruct<T1>(this Tuple<T1> value, out T1 item1);
        public static void Deconstruct<T1, T2>(this Tuple<T1, T2> value, out T1 item1, out T2 item2);
        public static void Deconstruct<T1, T2, T3>(this Tuple<T1, T2, T3> value, out T1 item1, out T2 item2, out T3 item3);
        public static void Deconstruct<T1, T2, T3, T4>(this Tuple<T1, T2, T3, T4> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4);
        public static void Deconstruct<T1, T2, T3, T4, T5>(this Tuple<T1, T2, T3, T4, T5> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5);
        public static void Deconstruct<T1, T2, T3, T4, T5, T6>(this Tuple<T1, T2, T3, T4, T5, T6> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6);
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7>(this Tuple<T1, T2, T3, T4, T5, T6, T7> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7);
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8>(this Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8);
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9>(this Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9);
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10);
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10, T11>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10, out T11 item11);
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10, T11, T12>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10, out T11 item11, out T12 item12);
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10, T11, T12, T13>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10, out T11 item11, out T12 item12, out T13 item13);
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10, T11, T12, T13, T14>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10, out T11 item11, out T12 item12, out T13 item13, out T14 item14);
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10, T11, T12, T13, T14, Tuple<T15>>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10, out T11 item11, out T12 item12, out T13 item13, out T14 item14, out T15 item15);
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(this Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10, T11, T12, T13, T14, Tuple<T15, T16>>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10, out T11 item11, out T12 item12, out T13 item13, out T14 item14, out T15 item15, out T16 item16);
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>(this Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10, T11, T12, T13, T14, Tuple<T15, T16, T17>>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10, out T11 item11, out T12 item12, out T13 item13, out T14 item14, out T15 item15, out T16 item16, out T17 item17);
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>(this Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10, T11, T12, T13, T14, Tuple<T15, T16, T17, T18>>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10, out T11 item11, out T12 item12, out T13 item13, out T14 item14, out T15 item15, out T16 item16, out T17 item17, out T18 item18);
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>(this Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10, T11, T12, T13, T14, Tuple<T15, T16, T17, T18, T19>>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10, out T11 item11, out T12 item12, out T13 item13, out T14 item14, out T15 item15, out T16 item16, out T17 item17, out T18 item18, out T19 item19);
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>(this Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10, T11, T12, T13, T14, Tuple<T15, T16, T17, T18, T19, T20>>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10, out T11 item11, out T12 item12, out T13 item13, out T14 item14, out T15 item15, out T16 item16, out T17 item17, out T18 item18, out T19 item19, out T20 item20);
        public static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>(this Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10, T11, T12, T13, T14, Tuple<T15, T16, T17, T18, T19, T20, T21>>> value, out T1 item1, out T2 item2, out T3 item3, out T4 item4, out T5 item5, out T6 item6, out T7 item7, out T8 item8, out T9 item9, out T10 item10, out T11 item11, out T12 item12, out T13 item13, out T14 item14, out T15 item15, out T16 item16, out T17 item17, out T18 item18, out T19 item19, out T20 item20, out T21 item21);
        public static (T1) ToValueTuple<T1>(this Tuple<T1> value);
        public static (T1, T2) ToValueTuple<T1, T2>(this Tuple<T1, T2> value);
        public static (T1, T2, T3) ToValueTuple<T1, T2, T3>(this Tuple<T1, T2, T3> value);
        public static (T1, T2, T3, T4) ToValueTuple<T1, T2, T3, T4>(this Tuple<T1, T2, T3, T4> value);
        public static (T1, T2, T3, T4, T5) ToValueTuple<T1, T2, T3, T4, T5>(this Tuple<T1, T2, T3, T4, T5> value);
        public static (T1, T2, T3, T4, T5, T6) ToValueTuple<T1, T2, T3, T4, T5, T6>(this Tuple<T1, T2, T3, T4, T5, T6> value);
        public static (T1, T2, T3, T4, T5, T6, T7) ToValueTuple<T1, T2, T3, T4, T5, T6, T7>(this Tuple<T1, T2, T3, T4, T5, T6, T7> value);
        public static (T1, T2, T3, T4, T5, T6, T7, (T8)) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8>(this Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8>> value);
        public static (T1, T2, T3, T4, T5, T6, T7, (T8, T9)) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9>(this Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9>> value);
        public static (T1, T2, T3, T4, T5, T6, T7, (T8, T9, T10)) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10>> value);
        public static (T1, T2, T3, T4, T5, T6, T7, (T8, T9, T10, T11)) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10, T11>> value);
        public static (T1, T2, T3, T4, T5, T6, T7, (T8, T9, T10, T11, T12)) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10, T11, T12>> value);
        public static (T1, T2, T3, T4, T5, T6, T7, (T8, T9, T10, T11, T12, T13)) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10, T11, T12, T13>> value);
        public static (T1, T2, T3, T4, T5, T6, T7, (T8, T9, T10, T11, T12, T13, T14)) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10, T11, T12, T13, T14>> value);
        public static (T1, T2, T3, T4, T5, T6, T7, (T8, T9, T10, T11, T12, T13, T14, (T15))) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10, T11, T12, T13, T14, Tuple<T15>>> value);
        public static (T1, T2, T3, T4, T5, T6, T7, (T8, T9, T10, T11, T12, T13, T14, (T15, T16))) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(this Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10, T11, T12, T13, T14, Tuple<T15, T16>>> value);
        public static (T1, T2, T3, T4, T5, T6, T7, (T8, T9, T10, T11, T12, T13, T14, (T15, T16, T17))) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>(this Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10, T11, T12, T13, T14, Tuple<T15, T16, T17>>> value);
        public static (T1, T2, T3, T4, T5, T6, T7, (T8, T9, T10, T11, T12, T13, T14, (T15, T16, T17, T18))) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>(this Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10, T11, T12, T13, T14, Tuple<T15, T16, T17, T18>>> value);
        public static (T1, T2, T3, T4, T5, T6, T7, (T8, T9, T10, T11, T12, T13, T14, (T15, T16, T17, T18, T19))) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>(this Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10, T11, T12, T13, T14, Tuple<T15, T16, T17, T18, T19>>> value);
        public static (T1, T2, T3, T4, T5, T6, T7, (T8, T9, T10, T11, T12, T13, T14, (T15, T16, T17, T18, T19, T20))) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>(this Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10, T11, T12, T13, T14, Tuple<T15, T16, T17, T18, T19, T20>>> value);
        public static (T1, T2, T3, T4, T5, T6, T7, (T8, T9, T10, T11, T12, T13, T14, (T15, T16, T17, T18, T19, T20, T21))) ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>(this Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10, T11, T12, T13, T14, Tuple<T15, T16, T17, T18, T19, T20, T21>>> value);
        public static Tuple<T1> ToTuple<T1>(this (T1) value);
        public static Tuple<T1, T2> ToTuple<T1, T2>(this (T1, T2) value);
        public static Tuple<T1, T2, T3> ToTuple<T1, T2, T3>(this (T1, T2, T3) value);
        public static Tuple<T1, T2, T3, T4> ToTuple<T1, T2, T3, T4>(this (T1, T2, T3, T4) value);
        public static Tuple<T1, T2, T3, T4, T5> ToTuple<T1, T2, T3, T4, T5>(this (T1, T2, T3, T4, T5) value);
        public static Tuple<T1, T2, T3, T4, T5, T6> ToTuple<T1, T2, T3, T4, T5, T6>(this (T1, T2, T3, T4, T5, T6) value);
        public static Tuple<T1, T2, T3, T4, T5, T6, T7> ToTuple<T1, T2, T3, T4, T5, T6, T7>(this (T1, T2, T3, T4, T5, T6, T7) value);
        public static Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8>(this (T1, T2, T3, T4, T5, T6, T7, (T8)) value);
        public static Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9>(this (T1, T2, T3, T4, T5, T6, T7, (T8, T9)) value);
        public static Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this (T1, T2, T3, T4, T5, T6, T7, (T8, T9, T10)) value);
        public static Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10, T11>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this (T1, T2, T3, T4, T5, T6, T7, (T8, T9, T10, T11)) value);
        public static Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10, T11, T12>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this (T1, T2, T3, T4, T5, T6, T7, (T8, T9, T10, T11, T12)) value);
        public static Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10, T11, T12, T13>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this (T1, T2, T3, T4, T5, T6, T7, (T8, T9, T10, T11, T12, T13)) value);
        public static Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10, T11, T12, T13, T14>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this (T1, T2, T3, T4, T5, T6, T7, (T8, T9, T10, T11, T12, T13, T14)) value);
        public static Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10, T11, T12, T13, T14, Tuple<T15>>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this (T1, T2, T3, T4, T5, T6, T7, (T8, T9, T10, T11, T12, T13, T14, (T15))) value);
        public static Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10, T11, T12, T13, T14, Tuple<T15, T16>>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(this (T1, T2, T3, T4, T5, T6, T7, (T8, T9, T10, T11, T12, T13, T14, (T15, T16))) value);
        public static Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10, T11, T12, T13, T14, Tuple<T15, T16, T17>>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>(this (T1, T2, T3, T4, T5, T6, T7, (T8, T9, T10, T11, T12, T13, T14, (T15, T16, T17))) value);
        public static Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10, T11, T12, T13, T14, Tuple<T15, T16, T17, T18>>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>(this (T1, T2, T3, T4, T5, T6, T7, (T8, T9, T10, T11, T12, T13, T14, (T15, T16, T17, T18))) value);
        public static Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10, T11, T12, T13, T14, Tuple<T15, T16, T17, T18, T19>>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>(this (T1, T2, T3, T4, T5, T6, T7, (T8, T9, T10, T11, T12, T13, T14, (T15, T16, T17, T18, T19))) value);
        public static Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10, T11, T12, T13, T14, Tuple<T15, T16, T17, T18, T19, T20>>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>(this (T1, T2, T3, T4, T5, T6, T7, (T8, T9, T10, T11, T12, T13, T14, (T15, T16, T17, T18, T19, T20))) value);
        public static Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8, T9, T10, T11, T12, T13, T14, Tuple<T15, T16, T17, T18, T19, T20, T21>>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>(this (T1, T2, T3, T4, T5, T6, T7, (T8, T9, T10, T11, T12, T13, T14, (T15, T16, T17, T18, T19, T20, T21))) value);
    }
}
//using System.Collections;
//using System.Runtime.CompilerServices;

namespace System
{
    public struct ValueTuple : ITuple, IComparable, IComparable<ValueTuple>, IValueTupleInternal, IStructuralComparable, IEquatable<ValueTuple>, IStructuralEquatable
    {
        public override bool Equals(object obj);
        public bool Equals(ValueTuple other);
        public int CompareTo(ValueTuple other);
        public override int GetHashCode();
        public override string ToString();
        public static ValueTuple Create();
        public static (T1) Create<T1>(T1 item1);
        public static (T1, T2) Create<T1, T2>(T1 item1, T2 item2);
        public static (T1, T2, T3) Create<T1, T2, T3>(T1 item1, T2 item2, T3 item3);
        public static (T1, T2, T3, T4) Create<T1, T2, T3, T4>(T1 item1, T2 item2, T3 item3, T4 item4);
        public static (T1, T2, T3, T4, T5) Create<T1, T2, T3, T4, T5>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
        public static (T1, T2, T3, T4, T5, T6) Create<T1, T2, T3, T4, T5, T6>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
        public static (T1, T2, T3, T4, T5, T6, T7) Create<T1, T2, T3, T4, T5, T6, T7>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
        public static (T1, T2, T3, T4, T5, T6, T7, (T8)) Create<T1, T2, T3, T4, T5, T6, T7, T8>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8);
    }
}
//using System.Collections;
//using System.Runtime.CompilerServices;

namespace System
{
    public struct ValueTuple<T1> : ITuple, IComparable, IComparable<(T1)>, IValueTupleInternal, IStructuralComparable, IEquatable<(T1)>, IStructuralEquatable
    {
        public T1 Item1;

        public ValueTuple(T1 item1);

        public override bool Equals(object obj);
        public bool Equals((T1) other);
        public int CompareTo((T1) other);
        public override int GetHashCode();
        public override string ToString();
    }
}
//using System.Collections;
//using System.Runtime.CompilerServices;

namespace System
{
    public struct ValueTuple<T1, T2> : ITuple, IComparable, IComparable<(T1, T2)>, IValueTupleInternal, IStructuralComparable, IEquatable<(T1, T2)>, IStructuralEquatable
    {
        public T1 Item1;
        public T2 Item2;

        public ValueTuple(T1 item1, T2 item2);

        public override bool Equals(object obj);
        public bool Equals((T1, T2) other);
        public int CompareTo((T1, T2) other);
        public override int GetHashCode();
        public override string ToString();
    }
}
//using System.Collections;
//using System.Runtime.CompilerServices;

namespace System
{
    public struct ValueTuple<T1, T2, T3> : ITuple, IComparable, IComparable<(T1, T2, T3)>, IValueTupleInternal, IStructuralComparable, IEquatable<(T1, T2, T3)>, IStructuralEquatable
    {
        public T1 Item1;
        public T2 Item2;
        public T3 Item3;

        public ValueTuple(T1 item1, T2 item2, T3 item3);

        public override bool Equals(object obj);
        public bool Equals((T1, T2, T3) other);
        public int CompareTo((T1, T2, T3) other);
        public override int GetHashCode();
        public override string ToString();
    }
}
//using System.Collections;
//using System.Runtime.CompilerServices;

namespace System
{
    public struct ValueTuple<T1, T2, T3, T4> : ITuple, IComparable, IComparable<(T1, T2, T3, T4)>, IValueTupleInternal, IStructuralComparable, IEquatable<(T1, T2, T3, T4)>, IStructuralEquatable
    {
        public T1 Item1;
        public T2 Item2;
        public T3 Item3;
        public T4 Item4;

        public ValueTuple(T1 item1, T2 item2, T3 item3, T4 item4);

        public override bool Equals(object obj);
        public bool Equals((T1, T2, T3, T4) other);
        public int CompareTo((T1, T2, T3, T4) other);
        public override int GetHashCode();
        public override string ToString();
    }
}
//using System.Collections;
//using System.Runtime.CompilerServices;

namespace System
{
    public struct ValueTuple<T1, T2, T3, T4, T5> : ITuple, IComparable, IComparable<(T1, T2, T3, T4, T5)>, IValueTupleInternal, IStructuralComparable, IEquatable<(T1, T2, T3, T4, T5)>, IStructuralEquatable
    {
        public T1 Item1;
        public T2 Item2;
        public T3 Item3;
        public T4 Item4;
        public T5 Item5;

        public ValueTuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);

        public override bool Equals(object obj);
        public bool Equals((T1, T2, T3, T4, T5) other);
        public int CompareTo((T1, T2, T3, T4, T5) other);
        public override int GetHashCode();
        public override string ToString();
    }
}
//using System.Collections;
//using System.Runtime.CompilerServices;

namespace System
{
    public struct ValueTuple<T1, T2, T3, T4, T5, T6> : ITuple, IComparable, IComparable<(T1, T2, T3, T4, T5, T6)>, IValueTupleInternal, IStructuralComparable, IEquatable<(T1, T2, T3, T4, T5, T6)>, IStructuralEquatable
    {
        public T1 Item1;
        public T2 Item2;
        public T3 Item3;
        public T4 Item4;
        public T5 Item5;
        public T6 Item6;

        public ValueTuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);

        public override bool Equals(object obj);
        public bool Equals((T1, T2, T3, T4, T5, T6) other);
        public int CompareTo((T1, T2, T3, T4, T5, T6) other);
        public override int GetHashCode();
        public override string ToString();
    }
}
//using System.Collections;
//using System.Runtime.CompilerServices;

namespace System
{
    public struct ValueTuple<T1, T2, T3, T4, T5, T6, T7> : ITuple, IComparable, IComparable<(T1, T2, T3, T4, T5, T6, T7)>, IValueTupleInternal, IStructuralComparable, IEquatable<(T1, T2, T3, T4, T5, T6, T7)>, IStructuralEquatable
    {
        public T1 Item1;
        public T2 Item2;
        public T3 Item3;
        public T4 Item4;
        public T5 Item5;
        public T6 Item6;
        public T7 Item7;

        public ValueTuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);

        public override bool Equals(object obj);
        public bool Equals((T1, T2, T3, T4, T5, T6, T7) other);
        public int CompareTo((T1, T2, T3, T4, T5, T6, T7) other);
        public override int GetHashCode();
        public override string ToString();
    }
}
//using System.Collections;
//using System.Runtime.CompilerServices;

namespace System
{
    public struct ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest> : ITuple, IComparable, IComparable<(T1, T2, T3, T4, T5, T6, T7, TRest)>, IValueTupleInternal, IStructuralComparable, IEquatable<(T1, T2, T3, T4, T5, T6, T7, TRest)>, IStructuralEquatable where TRest : struct
    {
        public T1 Item1;
        public T2 Item2;
        public T3 Item3;
        public T4 Item4;
        public T5 Item5;
        public T6 Item6;
        public T7 Item7;
        public TRest Rest;

        public ValueTuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);

        public override bool Equals(object obj);
        public bool Equals((T1, T2, T3, T4, T5, T6, T7, TRest) other);
        public int CompareTo((T1, T2, T3, T4, T5, T6, T7, TRest) other);
        public override int GetHashCode();
        public override string ToString();
    }
}
//using System.Collections;
//using System.Collections.Generic;
//using System.Collections.ObjectModel;
//using System.Runtime.ConstrainedExecution;

namespace System
{
    public abstract class Array : ICloneable, IEnumerable, IList, IStructuralComparable, IStructuralEquatable, ICollection
    {
        public long LongLength { get; }
        public bool IsFixedSize { get; }
        public bool IsReadOnly { get; }
        public bool IsSynchronized { get; }
        public object SyncRoot { get; }
        public int Length { get; }
        public int Rank { get; }

        public static Array CreateInstance(Type elementType, params long[] lengths);
        public static ReadOnlyCollection<T> AsReadOnly<T>(T[] array);
        public static void Resize<T>(ref T[] array, int newSize);
        public void CopyTo(Array array, int index);
        public object Clone();
        public static int BinarySearch(Array array, object value);
        public static TOutput[] ConvertAll<TInput, TOutput>(TInput[] array, Converter<TInput, TOutput> converter);
        public static void Copy(Array sourceArray, Array destinationArray, long length);
        public static void Copy(Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);
        public void CopyTo(Array array, long index);
        public static void ForEach<T>(T[] array, Action<T> action);
        public long GetLongLength(int dimension);
        public object GetValue(long index);
        public object GetValue(long index1, long index2);
        public object GetValue(long index1, long index2, long index3);
        public object GetValue(params long[] indices);
        public static int BinarySearch(Array array, int index, int length, object value);
        public static int BinarySearch(Array array, object value, IComparer comparer);
        public static int BinarySearch(Array array, int index, int length, object value, IComparer comparer);
        public static int BinarySearch<T>(T[] array, T value);
        public static int BinarySearch<T>(T[] array, T value, IComparer<T> comparer);
        public static int BinarySearch<T>(T[] array, int index, int length, T value);
        public static int BinarySearch<T>(T[] array, int index, int length, T value, IComparer<T> comparer);
        public static int IndexOf(Array array, object value);
        public static int IndexOf(Array array, object value, int startIndex);
        public static int IndexOf(Array array, object value, int startIndex, int count);
        public static int IndexOf<T>(T[] array, T value);
        public static int IndexOf<T>(T[] array, T value, int startIndex);
        public static int IndexOf<T>(T[] array, T value, int startIndex, int count);
        public static int LastIndexOf(Array array, object value);
        public static int LastIndexOf(Array array, object value, int startIndex);
        public static int LastIndexOf(Array array, object value, int startIndex, int count);
        public static int LastIndexOf<T>(T[] array, T value);
        public static int LastIndexOf<T>(T[] array, T value, int startIndex);
        public static int LastIndexOf<T>(T[] array, T value, int startIndex, int count);
        public static void Reverse(Array array);
        public static void Reverse(Array array, int index, int length);
        public static void Reverse<T>(T[] array);
        public static void Reverse<T>(T[] array, int index, int length);
        public void SetValue(object value, long index);
        public void SetValue(object value, long index1, long index2);
        public void SetValue(object value, long index1, long index2, long index3);
        public void SetValue(object value, params long[] indices);
        public static void Sort(Array array);
        public static void Sort(Array array, int index, int length);
        public static void Sort(Array array, IComparer comparer);
        public static void Sort(Array array, int index, int length, IComparer comparer);
        public static void Sort(Array keys, Array items);
        public static void Sort(Array keys, Array items, IComparer comparer);
        public static void Sort(Array keys, Array items, int index, int length);
        public static void Sort(Array keys, Array items, int index, int length, IComparer comparer);
        public static void Sort<T>(T[] array);
        public static void Sort<T>(T[] array, int index, int length);
        public static void Sort<T>(T[] array, IComparer<T> comparer);
        public static void Sort<T>(T[] array, int index, int length, IComparer<T> comparer);
        public static void Sort<T>(T[] array, Comparison<T> comparison);
        public static void Sort<TKey, TValue>(TKey[] keys, TValue[] items);
        public static void Sort<TKey, TValue>(TKey[] keys, TValue[] items, int index, int length);
        public static void Sort<TKey, TValue>(TKey[] keys, TValue[] items, IComparer<TKey> comparer);
        public static void Sort<TKey, TValue>(TKey[] keys, TValue[] items, int index, int length, IComparer<TKey> comparer);
        public static bool Exists<T>(T[] array, Predicate<T> match);
        public static void Fill<T>(T[] array, T value);
        public static void Fill<T>(T[] array, T value, int startIndex, int count);
        public static T Find<T>(T[] array, Predicate<T> match);
        public static T[] FindAll<T>(T[] array, Predicate<T> match);
        public static int FindIndex<T>(T[] array, Predicate<T> match);
        public static int FindIndex<T>(T[] array, int startIndex, Predicate<T> match);
        public static int FindIndex<T>(T[] array, int startIndex, int count, Predicate<T> match);
        public static T FindLast<T>(T[] array, Predicate<T> match);
        public static int FindLastIndex<T>(T[] array, Predicate<T> match);
        public static int FindLastIndex<T>(T[] array, int startIndex, Predicate<T> match);
        public static int FindLastIndex<T>(T[] array, int startIndex, int count, Predicate<T> match);
        public static bool TrueForAll<T>(T[] array, Predicate<T> match);
        public IEnumerator GetEnumerator();
        public int GetLength(int dimension);
        [ReliabilityContract(WillNotCorruptState, Success)]
        public int GetLowerBound(int dimension);
        public object GetValue(params int[] indices);
        public void SetValue(object value, params int[] indices);
        [ReliabilityContract(WillNotCorruptState, Success)]
        public int GetUpperBound(int dimension);
        public object GetValue(int index);
        public object GetValue(int index1, int index2);
        public object GetValue(int index1, int index2, int index3);
        public void SetValue(object value, int index);
        public void SetValue(object value, int index1, int index2);
        public void SetValue(object value, int index1, int index2, int index3);
        public static Array CreateInstance(Type elementType, int length);
        public static Array CreateInstance(Type elementType, int length1, int length2);
        public static Array CreateInstance(Type elementType, int length1, int length2, int length3);
        public static Array CreateInstance(Type elementType, params int[] lengths);
        public static Array CreateInstance(Type elementType, int[] lengths, int[] lowerBounds);
        [ReliabilityContract(WillNotCorruptState, Success)]
        public static void Clear(Array array, int index, int length);
        [ReliabilityContract(MayCorruptInstance, MayFail)]
        public static void Copy(Array sourceArray, Array destinationArray, int length);
        [ReliabilityContract(MayCorruptInstance, MayFail)]
        public static void Copy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
        [ReliabilityContract(WillNotCorruptState, Success)]
        public static void ConstrainedCopy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
        public static T[] Empty<T>();
        public void Initialize();
    }
}
namespace System
{
    public static class Tuple
    {
        public static Tuple<T1> Create<T1>(T1 item1);
        public static Tuple<T1, T2> Create<T1, T2>(T1 item1, T2 item2);
        public static Tuple<T1, T2, T3> Create<T1, T2, T3>(T1 item1, T2 item2, T3 item3);
        public static Tuple<T1, T2, T3, T4> Create<T1, T2, T3, T4>(T1 item1, T2 item2, T3 item3, T4 item4);
        public static Tuple<T1, T2, T3, T4, T5> Create<T1, T2, T3, T4, T5>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
        public static Tuple<T1, T2, T3, T4, T5, T6> Create<T1, T2, T3, T4, T5, T6>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
        public static Tuple<T1, T2, T3, T4, T5, T6, T7> Create<T1, T2, T3, T4, T5, T6, T7>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
        public static Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8>> Create<T1, T2, T3, T4, T5, T6, T7, T8>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8);
    }
}
//using System.Collections;
//using System.Runtime.CompilerServices;

namespace System
{
    public class Tuple<T1> : ITuple, ITupleInternal, IComparable, IStructuralComparable, IStructuralEquatable
    {
        public Tuple(T1 item1);

        public T1 Item1 { get; }

        public override bool Equals(object obj);
        public override int GetHashCode();
        public override string ToString();
    }
}
//using System.Collections;
//using System.Runtime.CompilerServices;

namespace System
{
    public class Tuple<T1, T2> : ITuple, ITupleInternal, IComparable, IStructuralComparable, IStructuralEquatable
    {
        public Tuple(T1 item1, T2 item2);

        public T1 Item1 { get; }
        public T2 Item2 { get; }

        public override bool Equals(object obj);
        public override int GetHashCode();
        public override string ToString();
    }
}
//using System.Collections;
//using System.Runtime.CompilerServices;

namespace System
{
    public class Tuple<T1, T2, T3> : ITuple, ITupleInternal, IComparable, IStructuralComparable, IStructuralEquatable
    {
        public Tuple(T1 item1, T2 item2, T3 item3);

        public T1 Item1 { get; }
        public T2 Item2 { get; }
        public T3 Item3 { get; }

        public override bool Equals(object obj);
        public override int GetHashCode();
        public override string ToString();
    }
}
//using System.Collections;
//using System.Runtime.CompilerServices;

namespace System
{
    public class Tuple<T1, T2, T3, T4> : ITuple, ITupleInternal, IComparable, IStructuralComparable, IStructuralEquatable
    {
        public Tuple(T1 item1, T2 item2, T3 item3, T4 item4);

        public T1 Item1 { get; }
        public T2 Item2 { get; }
        public T3 Item3 { get; }
        public T4 Item4 { get; }

        public override bool Equals(object obj);
        public override int GetHashCode();
        public override string ToString();
    }
}
//using System.Collections;
//using System.Runtime.CompilerServices;

namespace System
{
    public class Tuple<T1, T2, T3, T4, T5> : ITuple, ITupleInternal, IComparable, IStructuralComparable, IStructuralEquatable
    {
        public Tuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);

        public T1 Item1 { get; }
        public T2 Item2 { get; }
        public T3 Item3 { get; }
        public T4 Item4 { get; }
        public T5 Item5 { get; }

        public override bool Equals(object obj);
        public override int GetHashCode();
        public override string ToString();
    }
}
//using System.Collections;
//using System.Runtime.CompilerServices;

namespace System
{
    public class Tuple<T1, T2, T3, T4, T5, T6> : ITuple, ITupleInternal, IComparable, IStructuralComparable, IStructuralEquatable
    {
        public Tuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);

        public T1 Item1 { get; }
        public T2 Item2 { get; }
        public T3 Item3 { get; }
        public T4 Item4 { get; }
        public T5 Item5 { get; }
        public T6 Item6 { get; }

        public override bool Equals(object obj);
        public override int GetHashCode();
        public override string ToString();
    }
}
//using System.Collections;
//using System.Runtime.CompilerServices;

namespace System
{
    public class Tuple<T1, T2, T3, T4, T5, T6, T7> : ITuple, ITupleInternal, IComparable, IStructuralComparable, IStructuralEquatable
    {
        public Tuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);

        public T1 Item1 { get; }
        public T2 Item2 { get; }
        public T3 Item3 { get; }
        public T4 Item4 { get; }
        public T5 Item5 { get; }
        public T6 Item6 { get; }
        public T7 Item7 { get; }

        public override bool Equals(object obj);
        public override int GetHashCode();
        public override string ToString();
    }
}
//using System.Collections;
//using System.Runtime.CompilerServices;

namespace System
{
    public class Tuple<T1, T2, T3, T4, T5, T6, T7, TRest> : ITuple, ITupleInternal, IComparable, IStructuralComparable, IStructuralEquatable
    {
        public Tuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);

        public T1 Item1 { get; }
        public T2 Item2 { get; }
        public T3 Item3 { get; }
        public T4 Item4 { get; }
        public T5 Item5 { get; }
        public T6 Item6 { get; }
        public T7 Item7 { get; }
        public TRest Rest { get; }

        public override bool Equals(object obj);
        public override int GetHashCode();
        public override string ToString();
    }
}
//using System.Collections.Generic;
//using System.Collections.ObjectModel;
//using System.Diagnostics;
//using System.Runtime.Serialization;
//using System.Security;

namespace System
{
    [DebuggerDisplay("Count = {InnerExceptionCount}")]
    public class AggregateException : Exception
    {
        public AggregateException();
        public AggregateException(string message);
        public AggregateException(string message, Exception innerException);
        public AggregateException(IEnumerable<Exception> innerExceptions);
        public AggregateException(params Exception[] innerExceptions);
        public AggregateException(string message, IEnumerable<Exception> innerExceptions);
        public AggregateException(string message, params Exception[] innerExceptions);
        [SecurityCritical]
        protected AggregateException(SerializationInfo info, StreamingContext context);

        public ReadOnlyCollection<Exception> InnerExceptions { get; }

        [SecurityCritical]
        public override void GetObjectData(SerializationInfo info, StreamingContext context);
        public override Exception GetBaseException();
        public void Handle(Func<Exception, bool> predicate);
        public AggregateException Flatten();
        public override string ToString();
    }
}
namespace System
{
    public static class AppContext
    {
        public static string BaseDirectory { get; }
        public static string TargetFrameworkName { get; }

        public static object GetData(string name);
        public static bool TryGetSwitch(string switchName, out bool isEnabled);
        public static void SetSwitch(string switchName, bool isEnabled);
    }
}
namespace System
{
    public abstract class FormattableString : IFormattable
    {
        protected FormattableString();

        public abstract string Format { get; }
        public abstract int ArgumentCount { get; }

        public abstract object[] GetArguments();
        public abstract object GetArgument(int index);
        public abstract string ToString(IFormatProvider formatProvider);
        public static string Invariant(FormattableString formattable);
        public override string ToString();
    }
}
//using System.Diagnostics;
//using System.Runtime.InteropServices;
//using System.Threading;

namespace System
{
    [DebuggerDisplay("ThreadSafetyMode={Mode}, IsValueCreated={IsValueCreated}, IsValueFaulted={IsValueFaulted}, Value={ValueForDebugDisplay}")]
    [DebuggerTypeProxy(typeof(System_LazyDebugView<>))]
    [ComVisible(False)]
    public class Lazy<T>
    {
        public Lazy();
        public Lazy(Func<T> valueFactory);
        public Lazy(bool isThreadSafe);
        public Lazy(LazyThreadSafetyMode mode);
        public Lazy(Func<T> valueFactory, bool isThreadSafe);
        public Lazy(Func<T> valueFactory, LazyThreadSafetyMode mode);

        public bool IsValueCreated { get; }
        [DebuggerBrowsable(Never)]
        public T Value { get; }

        public override string ToString();
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public sealed class LocalDataStoreSlot
    {
        ~LocalDataStoreSlot();
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System
{
    [ComVisible(True)]
    public class AccessViolationException : SystemException
    {
        public AccessViolationException();
        public AccessViolationException(string message);
        public AccessViolationException(string message, Exception innerException);
        protected AccessViolationException(SerializationInfo info, StreamingContext context);
    }
}
namespace System
{
    public delegate void Action<T>(T obj);
}
//using System.Runtime.CompilerServices;

namespace System
{
    [TypeForwardedFrom("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")]
    public delegate void Action();
}
//using System.Runtime.CompilerServices;

namespace System
{
    [TypeForwardedFrom("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")]
    public delegate void Action<T1, T2>(T1 arg1, T2 arg2);
}
//using System.Runtime.CompilerServices;

namespace System
{
    [TypeForwardedFrom("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")]
    public delegate void Action<T1, T2, T3>(T1 arg1, T2 arg2, T3 arg3);
}
//using System.Runtime.CompilerServices;

namespace System
{
    [TypeForwardedFrom("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")]
    public delegate void Action<T1, T2, T3, T4>(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
}
//using System.Runtime.CompilerServices;

namespace System
{
    [TypeForwardedFrom("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")]
    public delegate TResult Func<TResult>();
}
//using System.Runtime.CompilerServices;

namespace System
{
    [TypeForwardedFrom("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")]
    public delegate TResult Func<T, TResult>(T arg);
}
//using System.Runtime.CompilerServices;

namespace System
{
    [TypeForwardedFrom("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")]
    public delegate TResult Func<T1, T2, TResult>(T1 arg1, T2 arg2);
}
//using System.Runtime.CompilerServices;

namespace System
{
    [TypeForwardedFrom("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")]
    public delegate TResult Func<T1, T2, T3, TResult>(T1 arg1, T2 arg2, T3 arg3);
}
//using System.Runtime.CompilerServices;

namespace System
{
    [TypeForwardedFrom("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")]
    public delegate TResult Func<T1, T2, T3, T4, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
}
namespace System
{
    public delegate void Action<T1, T2, T3, T4, T5>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
}
namespace System
{
    public delegate void Action<T1, T2, T3, T4, T5, T6>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
}
namespace System
{
    public delegate void Action<T1, T2, T3, T4, T5, T6, T7>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
}
namespace System
{
    public delegate void Action<T1, T2, T3, T4, T5, T6, T7, T8>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
}
namespace System
{
    public delegate TResult Func<T1, T2, T3, T4, T5, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
}
namespace System
{
    public delegate TResult Func<T1, T2, T3, T4, T5, T6, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
}
namespace System
{
    public delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
}
namespace System
{
    public delegate TResult Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
}
namespace System
{
    public delegate int Comparison<T>(T x, T y);
}
namespace System
{
    public delegate TOutput Converter<TInput, TOutput>(TInput input);
}
namespace System
{
    public delegate bool Predicate<T>(T obj);
}
//using System.Configuration.Assemblies;
//using System.Globalization;
//using System.Reflection;
//using System.Runtime.InteropServices;
//using System.Runtime.Remoting;
//using System.Security;
//using System.Security.Policy;

namespace System
{
    [ClassInterface(None)]
    [ComVisible(True)]
    [ComDefaultInterface(typeof(_Activator))]
    public sealed class Activator : _Activator
    {
        public static object CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture);
        [SecuritySafeCritical]
        public static object CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes);
        public static object CreateInstance(Type type, params object[] args);
        public static object CreateInstance(Type type, object[] args, object[] activationAttributes);
        public static object CreateInstance(Type type);
        [SecuritySafeCritical]
        public static ObjectHandle CreateInstance(string assemblyName, string typeName);
        [SecuritySafeCritical]
        public static ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes);
        public static object CreateInstance(Type type, bool nonPublic);
        public static T CreateInstance<T>();
        public static ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName);
        public static ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes);
        [SecuritySafeCritical]
        [Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
        public static ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes, Evidence securityInfo);
        [SecuritySafeCritical]
        public static ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes);
        [Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
        public static ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes, Evidence securityInfo);
        public static ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes);
        [SecurityCritical]
        public static ObjectHandle CreateInstance(AppDomain domain, string assemblyName, string typeName);
        [SecurityCritical]
        [Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
        public static ObjectHandle CreateInstance(AppDomain domain, string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes, Evidence securityAttributes);
        [SecurityCritical]
        public static ObjectHandle CreateInstance(AppDomain domain, string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes);
        [SecurityCritical]
        public static ObjectHandle CreateInstanceFrom(AppDomain domain, string assemblyFile, string typeName);
        [Obsolete("Methods which use Evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
        [SecurityCritical]
        public static ObjectHandle CreateInstanceFrom(AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes, Evidence securityAttributes);
        [SecurityCritical]
        public static ObjectHandle CreateInstanceFrom(AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes);
        public static ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName);
        public static ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName, byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
        [SecurityCritical]
        public static object GetObject(Type type, string url);
        [SecurityCritical]
        public static object GetObject(Type type, string url, object state);
        [SecuritySafeCritical]
        public static ObjectHandle CreateInstance(ActivationContext activationContext);
        [SecuritySafeCritical]
        public static ObjectHandle CreateInstance(ActivationContext activationContext, string[] activationCustomData);
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public enum LoaderOptimization
    {
        NotSpecified = 0,
        SingleDomain = 1,
        MultiDomain = 2,
        MultiDomainHost = 3,
        [Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")]
        DomainMask = 3,
        [Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")]
        DisallowBindings = 4
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    [AttributeUsage(Method)]
    public sealed class LoaderOptimizationAttribute : Attribute
    {
        public LoaderOptimizationAttribute(byte value);
        public LoaderOptimizationAttribute(LoaderOptimization value);

        public LoaderOptimization Value { get; }
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System
{
    [ComVisible(True)]
    public class AppDomainUnloadedException : SystemException
    {
        public AppDomainUnloadedException();
        public AppDomainUnloadedException(string message);
        public AppDomainUnloadedException(string message, Exception innerException);
        protected AppDomainUnloadedException(SerializationInfo info, StreamingContext context);
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System
{
    [ComVisible(True)]
    public class ApplicationException : Exception
    {
        public ApplicationException();
        public ApplicationException(string message);
        public ApplicationException(string message, Exception innerException);
        protected ApplicationException(SerializationInfo info, StreamingContext context);
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public sealed class ApplicationId
    {
        public ApplicationId(byte[] publicKeyToken, string name, Version version, string processorArchitecture, string culture);

        public byte[] PublicKeyToken { get; }
        public string Name { get; }
        public Version Version { get; }
        public string ProcessorArchitecture { get; }
        public string Culture { get; }

        public ApplicationId Copy();
        public override string ToString();
        public override bool Equals(object o);
        public override int GetHashCode();
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;
//using System.Security;

namespace System
{
    [ComVisible(True)]
    public class ArgumentException : SystemException
    {
        public ArgumentException();
        public ArgumentException(string message);
        public ArgumentException(string message, Exception innerException);
        public ArgumentException(string message, string paramName, Exception innerException);
        public ArgumentException(string message, string paramName);
        protected ArgumentException(SerializationInfo info, StreamingContext context);

        public override string Message { get; }
        public virtual string ParamName { get; }

        [SecurityCritical]
        public override void GetObjectData(SerializationInfo info, StreamingContext context);
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;
//using System.Security;

namespace System
{
    [ComVisible(True)]
    public class ArgumentNullException : ArgumentException
    {
        public ArgumentNullException();
        public ArgumentNullException(string paramName);
        public ArgumentNullException(string message, Exception innerException);
        public ArgumentNullException(string paramName, string message);
        [SecurityCritical]
        protected ArgumentNullException(SerializationInfo info, StreamingContext context);
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;
//using System.Security;

namespace System
{
    [ComVisible(True)]
    public class ArgumentOutOfRangeException : ArgumentException
    {
        public ArgumentOutOfRangeException();
        public ArgumentOutOfRangeException(string paramName);
        public ArgumentOutOfRangeException(string paramName, string message);
        public ArgumentOutOfRangeException(string message, Exception innerException);
        public ArgumentOutOfRangeException(string paramName, object actualValue, string message);
        protected ArgumentOutOfRangeException(SerializationInfo info, StreamingContext context);

        public override string Message { get; }
        public virtual object ActualValue { get; }

        [SecurityCritical]
        public override void GetObjectData(SerializationInfo info, StreamingContext context);
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System
{
    [ComVisible(True)]
    public class ArithmeticException : SystemException
    {
        public ArithmeticException();
        public ArithmeticException(string message);
        public ArithmeticException(string message, Exception innerException);
        protected ArithmeticException(SerializationInfo info, StreamingContext context);
    }
}
//using System.Collections;
//using System.Collections.Generic;

namespace System
{
    public struct ArraySegment<T> : IEnumerable, IList<T>, IReadOnlyCollection<T>, IReadOnlyList<T>, ICollection<T>, IEnumerable<T>
    {
        public ArraySegment(T[] array);
        public ArraySegment(T[] array, int offset, int count);

        public T[] Array { get; }
        public int Offset { get; }
        public int Count { get; }

        public override int GetHashCode();
        public override bool Equals(object obj);
        public bool Equals(ArraySegment<T> obj);

        public static bool operator ==(ArraySegment<T> a, ArraySegment<T> b);
        public static bool operator !=(ArraySegment<T> a, ArraySegment<T> b);
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System
{
    [ComVisible(True)]
    public class ArrayTypeMismatchException : SystemException
    {
        public ArrayTypeMismatchException();
        public ArrayTypeMismatchException(string message);
        public ArrayTypeMismatchException(string message, Exception innerException);
        protected ArrayTypeMismatchException(SerializationInfo info, StreamingContext context);
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public delegate void AsyncCallback(IAsyncResult ar);
}
//using System.Reflection;
//using System.Runtime.InteropServices;
//using System.Security;

namespace System
{
    [AttributeUsage(All, Inherited = True, AllowMultiple = False)]
    [ComVisible(True)]
    [ClassInterface(None)]
    [ComDefaultInterface(typeof(_Attribute))]
    public abstract class Attribute : _Attribute
    {
        protected Attribute();

        public virtual object TypeId { get; }

        public static Attribute[] GetCustomAttributes(MemberInfo element, Type type);
        public static Attribute[] GetCustomAttributes(MemberInfo element, Type type, bool inherit);
        public static Attribute[] GetCustomAttributes(MemberInfo element);
        public static Attribute[] GetCustomAttributes(MemberInfo element, bool inherit);
        public static bool IsDefined(MemberInfo element, Type attributeType);
        public static bool IsDefined(MemberInfo element, Type attributeType, bool inherit);
        public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType);
        public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType, bool inherit);
        public static Attribute[] GetCustomAttributes(ParameterInfo element);
        public static Attribute[] GetCustomAttributes(ParameterInfo element, Type attributeType);
        public static Attribute[] GetCustomAttributes(ParameterInfo element, Type attributeType, bool inherit);
        public static Attribute[] GetCustomAttributes(ParameterInfo element, bool inherit);
        public static bool IsDefined(ParameterInfo element, Type attributeType);
        public static bool IsDefined(ParameterInfo element, Type attributeType, bool inherit);
        public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType);
        public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType, bool inherit);
        public static Attribute[] GetCustomAttributes(Module element, Type attributeType);
        public static Attribute[] GetCustomAttributes(Module element);
        public static Attribute[] GetCustomAttributes(Module element, bool inherit);
        public static Attribute[] GetCustomAttributes(Module element, Type attributeType, bool inherit);
        public static bool IsDefined(Module element, Type attributeType);
        public static bool IsDefined(Module element, Type attributeType, bool inherit);
        public static Attribute GetCustomAttribute(Module element, Type attributeType);
        public static Attribute GetCustomAttribute(Module element, Type attributeType, bool inherit);
        public static Attribute[] GetCustomAttributes(Assembly element, Type attributeType);
        public static Attribute[] GetCustomAttributes(Assembly element, Type attributeType, bool inherit);
        public static Attribute[] GetCustomAttributes(Assembly element);
        public static Attribute[] GetCustomAttributes(Assembly element, bool inherit);
        public static bool IsDefined(Assembly element, Type attributeType);
        public static bool IsDefined(Assembly element, Type attributeType, bool inherit);
        public static Attribute GetCustomAttribute(Assembly element, Type attributeType);
        public static Attribute GetCustomAttribute(Assembly element, Type attributeType, bool inherit);
        [SecuritySafeCritical]
        public override bool Equals(object obj);
        [SecuritySafeCritical]
        public override int GetHashCode();
        public virtual bool Match(object obj);
        public virtual bool IsDefaultAttribute();
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [Flags]
    [ComVisible(True)]
    public enum AttributeTargets
    {
        Assembly = 1,
        Module = 2,
        Class = 4,
        Struct = 8,
        Enum = 16,
        Constructor = 32,
        Method = 64,
        Property = 128,
        Field = 256,
        Event = 512,
        Interface = 1024,
        Parameter = 2048,
        Delegate = 4096,
        ReturnValue = 8192,
        GenericParameter = 16384,
        All = 32767
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [AttributeUsage(Class, Inherited = True)]
    [ComVisible(True)]
    public sealed class AttributeUsageAttribute : Attribute
    {
        public AttributeUsageAttribute(AttributeTargets validOn);

        public AttributeTargets ValidOn { get; }
        public bool AllowMultiple { get; set; }
        public bool Inherited { get; set; }
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;
//using System.Security;

namespace System
{
    [ComVisible(True)]
    public class BadImageFormatException : SystemException
    {
        public BadImageFormatException();
        public BadImageFormatException(string message);
        public BadImageFormatException(string message, Exception inner);
        public BadImageFormatException(string message, string fileName);
        public BadImageFormatException(string message, string fileName, Exception inner);
        protected BadImageFormatException(SerializationInfo info, StreamingContext context);

        public override string Message { get; }
        public string FileName { get; }
        public string FusionLog { get; }

        public override string ToString();
        [SecurityCritical]
        public override void GetObjectData(SerializationInfo info, StreamingContext context);
    }
}
//using System.Security;

namespace System
{
    public static class BitConverter
    {
        public static readonly bool IsLittleEndian;

        public static byte[] GetBytes(bool value);
        public static byte[] GetBytes(char value);
        [SecuritySafeCritical]
        public static byte[] GetBytes(short value);
        [SecuritySafeCritical]
        public static byte[] GetBytes(int value);
        [SecuritySafeCritical]
        public static byte[] GetBytes(long value);
        [CLSCompliant(False)]
        public static byte[] GetBytes(ushort value);
        [CLSCompliant(False)]
        public static byte[] GetBytes(uint value);
        [CLSCompliant(False)]
        public static byte[] GetBytes(ulong value);
        [SecuritySafeCritical]
        public static byte[] GetBytes(float value);
        [SecuritySafeCritical]
        public static byte[] GetBytes(double value);
        public static char ToChar(byte[] value, int startIndex);
        [SecuritySafeCritical]
        public static short ToInt16(byte[] value, int startIndex);
        [SecuritySafeCritical]
        public static int ToInt32(byte[] value, int startIndex);
        [SecuritySafeCritical]
        public static long ToInt64(byte[] value, int startIndex);
        [CLSCompliant(False)]
        public static ushort ToUInt16(byte[] value, int startIndex);
        [CLSCompliant(False)]
        public static uint ToUInt32(byte[] value, int startIndex);
        [CLSCompliant(False)]
        public static ulong ToUInt64(byte[] value, int startIndex);
        [SecuritySafeCritical]
        public static float ToSingle(byte[] value, int startIndex);
        [SecuritySafeCritical]
        public static double ToDouble(byte[] value, int startIndex);
        public static string ToString(byte[] value, int startIndex, int length);
        public static string ToString(byte[] value);
        public static string ToString(byte[] value, int startIndex);
        public static bool ToBoolean(byte[] value, int startIndex);
        [SecuritySafeCritical]
        public static long DoubleToInt64Bits(double value);
        [SecuritySafeCritical]
        public static double Int64BitsToDouble(long value);
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public struct Boolean : IComparable, IComparable<bool>, IConvertible, IEquatable<bool>
    {
        public static readonly string TrueString;
        public static readonly string FalseString;

        public override int GetHashCode();
        public override string ToString();
        public string ToString(IFormatProvider provider);
        public override bool Equals(object obj);
        public bool Equals(bool obj);
        public int CompareTo(object obj);
        public int CompareTo(bool value);
        public static bool Parse(string value);
        public static bool TryParse(string value, out bool result);
        public TypeCode GetTypeCode();
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public static class Buffer
    {
        public static int ByteLength(Array array);
        public static byte GetByte(Array array, int index);
        public static void SetByte(Array array, int index, byte value);
        public static void BlockCopy(Array src, int srcOffset, Array dst, int dstOffset, int count);
        [CLSCompliant(False)]
        public static void MemoryCopy(void* source, void* destination, long destinationSizeInBytes, long sourceBytesToCopy);
        [CLSCompliant(False)]
        public static void MemoryCopy(void* source, void* destination, ulong destinationSizeInBytes, ulong sourceBytesToCopy);
    }
}
//using System.Globalization;
//using System.Runtime.InteropServices;
//using System.Security;

namespace System
{
    [ComVisible(True)]
    public struct Byte : IComparable, IComparable<byte>, IConvertible, IEquatable<byte>, IFormattable
    {
        public const byte MaxValue = 255;
        public const byte MinValue = 0;

        public int CompareTo(object value);
        public int CompareTo(byte value);
        public override bool Equals(object obj);
        public bool Equals(byte obj);
        public override int GetHashCode();
        public static byte Parse(string s);
        public static byte Parse(string s, NumberStyles style);
        public static byte Parse(string s, IFormatProvider provider);
        public static byte Parse(string s, NumberStyles style, IFormatProvider provider);
        public static bool TryParse(string s, out byte result);
        public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out byte result);
        [SecuritySafeCritical]
        public override string ToString();
        [SecuritySafeCritical]
        public string ToString(string format);
        [SecuritySafeCritical]
        public string ToString(IFormatProvider provider);
        [SecuritySafeCritical]
        public string ToString(string format, IFormatProvider provider);
        public TypeCode GetTypeCode();
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System
{
    [ComVisible(True)]
    public class CannotUnloadAppDomainException : SystemException
    {
        public CannotUnloadAppDomainException();
        public CannotUnloadAppDomainException(string message);
        public CannotUnloadAppDomainException(string message, Exception innerException);
        protected CannotUnloadAppDomainException(SerializationInfo info, StreamingContext context);
    }
}
//using System.Globalization;
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public struct Char : IComparable, IComparable<char>, IConvertible, IEquatable<char>
    {
        public const char MaxValue = '';
        public const char MinValue = '\0';

        public override int GetHashCode();
        public override bool Equals(object obj);
        public bool Equals(char obj);
        public int CompareTo(object value);
        public int CompareTo(char value);
        public override string ToString();
        public string ToString(IFormatProvider provider);
        public static string ToString(char c);
        public static char Parse(string s);
        public static bool TryParse(string s, out char result);
        public static bool IsDigit(char c);
        public static bool IsLetter(char c);
        public static bool IsWhiteSpace(char c);
        public static bool IsUpper(char c);
        public static bool IsLower(char c);
        public static bool IsPunctuation(char c);
        public static bool IsLetterOrDigit(char c);
        public static char ToUpper(char c, CultureInfo culture);
        public static char ToUpper(char c);
        public static char ToUpperInvariant(char c);
        public static char ToLower(char c, CultureInfo culture);
        public static char ToLower(char c);
        public static char ToLowerInvariant(char c);
        public TypeCode GetTypeCode();
        public static bool IsControl(char c);
        public static bool IsControl(string s, int index);
        public static bool IsDigit(string s, int index);
        public static bool IsLetter(string s, int index);
        public static bool IsLetterOrDigit(string s, int index);
        public static bool IsLower(string s, int index);
        public static bool IsNumber(char c);
        public static bool IsNumber(string s, int index);
        public static bool IsPunctuation(string s, int index);
        public static bool IsSeparator(char c);
        public static bool IsSeparator(string s, int index);
        public static bool IsSurrogate(char c);
        public static bool IsSurrogate(string s, int index);
        public static bool IsSymbol(char c);
        public static bool IsSymbol(string s, int index);
        public static bool IsUpper(string s, int index);
        public static bool IsWhiteSpace(string s, int index);
        public static UnicodeCategory GetUnicodeCategory(char c);
        public static UnicodeCategory GetUnicodeCategory(string s, int index);
        public static double GetNumericValue(char c);
        public static double GetNumericValue(string s, int index);
        public static bool IsHighSurrogate(char c);
        public static bool IsHighSurrogate(string s, int index);
        public static bool IsLowSurrogate(char c);
        public static bool IsLowSurrogate(string s, int index);
        public static bool IsSurrogatePair(string s, int index);
        public static bool IsSurrogatePair(char highSurrogate, char lowSurrogate);
        public static string ConvertFromUtf32(int utf32);
        public static int ConvertToUtf32(char highSurrogate, char lowSurrogate);
        public static int ConvertToUtf32(string s, int index);
    }
}
//using System.Collections;
//using System.Collections.Generic;
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public sealed class CharEnumerator : IEnumerator<char>, ICloneable, IEnumerator, IDisposable
    {
        public char Current { get; }

        public object Clone();
        public bool MoveNext();
        public void Dispose();
        public void Reset();
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    [AttributeUsage(All, Inherited = True, AllowMultiple = False)]
    public sealed class CLSCompliantAttribute : Attribute
    {
        public CLSCompliantAttribute(bool isCompliant);

        public bool IsCompliant { get; }
    }
}
namespace System
{
    public delegate void ConsoleCancelEventHandler(object sender, ConsoleCancelEventArgs e);
}
namespace System
{
    public sealed class ConsoleCancelEventArgs : EventArgs
    {
        public bool Cancel { get; set; }
        public ConsoleSpecialKey SpecialKey { get; }
    }
}
namespace System
{
    public enum ConsoleColor
    {
        Black = 0,
        DarkBlue = 1,
        DarkGreen = 2,
        DarkCyan = 3,
        DarkRed = 4,
        DarkMagenta = 5,
        DarkYellow = 6,
        Gray = 7,
        DarkGray = 8,
        Blue = 9,
        Green = 10,
        Cyan = 11,
        Red = 12,
        Magenta = 13,
        Yellow = 14,
        White = 15
    }
}
namespace System
{
    public enum ConsoleKey
    {
        Backspace = 8,
        Tab = 9,
        Clear = 12,
        Enter = 13,
        Pause = 19,
        Escape = 27,
        Spacebar = 32,
        PageUp = 33,
        PageDown = 34,
        End = 35,
        Home = 36,
        LeftArrow = 37,
        UpArrow = 38,
        RightArrow = 39,
        DownArrow = 40,
        Select = 41,
        Print = 42,
        Execute = 43,
        PrintScreen = 44,
        Insert = 45,
        Delete = 46,
        Help = 47,
        D0 = 48,
        D1 = 49,
        D2 = 50,
        D3 = 51,
        D4 = 52,
        D5 = 53,
        D6 = 54,
        D7 = 55,
        D8 = 56,
        D9 = 57,
        A = 65,
        B = 66,
        C = 67,
        D = 68,
        E = 69,
        F = 70,
        G = 71,
        H = 72,
        I = 73,
        J = 74,
        K = 75,
        L = 76,
        M = 77,
        N = 78,
        O = 79,
        P = 80,
        Q = 81,
        R = 82,
        S = 83,
        T = 84,
        U = 85,
        V = 86,
        W = 87,
        X = 88,
        Y = 89,
        Z = 90,
        LeftWindows = 91,
        RightWindows = 92,
        Applications = 93,
        Sleep = 95,
        NumPad0 = 96,
        NumPad1 = 97,
        NumPad2 = 98,
        NumPad3 = 99,
        NumPad4 = 100,
        NumPad5 = 101,
        NumPad6 = 102,
        NumPad7 = 103,
        NumPad8 = 104,
        NumPad9 = 105,
        Multiply = 106,
        Add = 107,
        Separator = 108,
        Subtract = 109,
        Decimal = 110,
        Divide = 111,
        F1 = 112,
        F2 = 113,
        F3 = 114,
        F4 = 115,
        F5 = 116,
        F6 = 117,
        F7 = 118,
        F8 = 119,
        F9 = 120,
        F10 = 121,
        F11 = 122,
        F12 = 123,
        F13 = 124,
        F14 = 125,
        F15 = 126,
        F16 = 127,
        F17 = 128,
        F18 = 129,
        F19 = 130,
        F20 = 131,
        F21 = 132,
        F22 = 133,
        F23 = 134,
        F24 = 135,
        BrowserBack = 166,
        BrowserForward = 167,
        BrowserRefresh = 168,
        BrowserStop = 169,
        BrowserSearch = 170,
        BrowserFavorites = 171,
        BrowserHome = 172,
        VolumeMute = 173,
        VolumeDown = 174,
        VolumeUp = 175,
        MediaNext = 176,
        MediaPrevious = 177,
        MediaStop = 178,
        MediaPlay = 179,
        LaunchMail = 180,
        LaunchMediaSelect = 181,
        LaunchApp1 = 182,
        LaunchApp2 = 183,
        Oem1 = 186,
        OemPlus = 187,
        OemComma = 188,
        OemMinus = 189,
        OemPeriod = 190,
        Oem2 = 191,
        Oem3 = 192,
        Oem4 = 219,
        Oem5 = 220,
        Oem6 = 221,
        Oem7 = 222,
        Oem8 = 223,
        Oem102 = 226,
        Process = 229,
        Packet = 231,
        Attention = 246,
        CrSel = 247,
        ExSel = 248,
        EraseEndOfFile = 249,
        Play = 250,
        Zoom = 251,
        NoName = 252,
        Pa1 = 253,
        OemClear = 254
    }
}
namespace System
{
    public struct ConsoleKeyInfo
    {
        public ConsoleKeyInfo(char keyChar, ConsoleKey key, bool shift, bool alt, bool control);

        public char KeyChar { get; }
        public ConsoleKey Key { get; }
        public ConsoleModifiers Modifiers { get; }

        public override bool Equals(object value);
        public bool Equals(ConsoleKeyInfo obj);
        public override int GetHashCode();

        public static bool operator ==(ConsoleKeyInfo a, ConsoleKeyInfo b);
        public static bool operator !=(ConsoleKeyInfo a, ConsoleKeyInfo b);
    }
}
namespace System
{
    [Flags]
    public enum ConsoleModifiers
    {
        Alt = 1,
        Shift = 2,
        Control = 4
    }
}
namespace System
{
    public enum ConsoleSpecialKey
    {
        ControlC = 0,
        ControlBreak = 1
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public abstract class ContextBoundObject : MarshalByRefObject
    {
        protected ContextBoundObject();
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System
{
    [ComVisible(True)]
    public class ContextMarshalException : SystemException
    {
        public ContextMarshalException();
        public ContextMarshalException(string message);
        public ContextMarshalException(string message, Exception inner);
        protected ContextMarshalException(SerializationInfo info, StreamingContext context);
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    [AttributeUsage(Field, Inherited = False)]
    public class ContextStaticAttribute : Attribute
    {
        public ContextStaticAttribute();
    }
}
namespace System
{
    [Flags]
    public enum Base64FormattingOptions
    {
        None = 0,
        InsertLineBreaks = 1
    }
}
//using System.Runtime.InteropServices;
//using System.Security;

namespace System
{
    public static class Convert
    {
        public static readonly object DBNull;

        public static TypeCode GetTypeCode(object value);
        public static bool IsDBNull(object value);
        public static object ChangeType(object value, TypeCode typeCode);
        public static object ChangeType(object value, TypeCode typeCode, IFormatProvider provider);
        public static object ChangeType(object value, Type conversionType);
        public static object ChangeType(object value, Type conversionType, IFormatProvider provider);
        public static bool ToBoolean(object value);
        public static bool ToBoolean(object value, IFormatProvider provider);
        public static bool ToBoolean(bool value);
        [CLSCompliant(False)]
        public static bool ToBoolean(sbyte value);
        public static bool ToBoolean(char value);
        public static bool ToBoolean(byte value);
        public static bool ToBoolean(short value);
        [CLSCompliant(False)]
        public static bool ToBoolean(ushort value);
        public static bool ToBoolean(int value);
        [CLSCompliant(False)]
        public static bool ToBoolean(uint value);
        public static bool ToBoolean(long value);
        [CLSCompliant(False)]
        public static bool ToBoolean(ulong value);
        public static bool ToBoolean(string value);
        public static bool ToBoolean(string value, IFormatProvider provider);
        public static bool ToBoolean(float value);
        public static bool ToBoolean(double value);
        public static bool ToBoolean(decimal value);
        public static bool ToBoolean(DateTime value);
        public static char ToChar(object value);
        public static char ToChar(object value, IFormatProvider provider);
        public static char ToChar(bool value);
        public static char ToChar(char value);
        [CLSCompliant(False)]
        public static char ToChar(sbyte value);
        public static char ToChar(byte value);
        public static char ToChar(short value);
        [CLSCompliant(False)]
        public static char ToChar(ushort value);
        public static char ToChar(int value);
        [CLSCompliant(False)]
        public static char ToChar(uint value);
        public static char ToChar(long value);
        [CLSCompliant(False)]
        public static char ToChar(ulong value);
        public static char ToChar(string value);
        public static char ToChar(string value, IFormatProvider provider);
        public static char ToChar(float value);
        public static char ToChar(double value);
        public static char ToChar(decimal value);
        public static char ToChar(DateTime value);
        [CLSCompliant(False)]
        public static sbyte ToSByte(object value);
        [CLSCompliant(False)]
        public static sbyte ToSByte(object value, IFormatProvider provider);
        [CLSCompliant(False)]
        public static sbyte ToSByte(bool value);
        [CLSCompliant(False)]
        public static sbyte ToSByte(sbyte value);
        [CLSCompliant(False)]
        public static sbyte ToSByte(char value);
        [CLSCompliant(False)]
        public static sbyte ToSByte(byte value);
        [CLSCompliant(False)]
        public static sbyte ToSByte(short value);
        [CLSCompliant(False)]
        public static sbyte ToSByte(ushort value);
        [CLSCompliant(False)]
        public static sbyte ToSByte(int value);
        [CLSCompliant(False)]
        public static sbyte ToSByte(uint value);
        [CLSCompliant(False)]
        public static sbyte ToSByte(long value);
        [CLSCompliant(False)]
        public static sbyte ToSByte(ulong value);
        [CLSCompliant(False)]
        public static sbyte ToSByte(float value);
        [CLSCompliant(False)]
        public static sbyte ToSByte(double value);
        [CLSCompliant(False)]
        public static sbyte ToSByte(decimal value);
        [CLSCompliant(False)]
        public static sbyte ToSByte(string value);
        [CLSCompliant(False)]
        public static sbyte ToSByte(string value, IFormatProvider provider);
        [CLSCompliant(False)]
        public static sbyte ToSByte(DateTime value);
        public static byte ToByte(object value);
        public static byte ToByte(object value, IFormatProvider provider);
        public static byte ToByte(bool value);
        public static byte ToByte(byte value);
        public static byte ToByte(char value);
        [CLSCompliant(False)]
        public static byte ToByte(sbyte value);
        public static byte ToByte(short value);
        [CLSCompliant(False)]
        public static byte ToByte(ushort value);
        public static byte ToByte(int value);
        [CLSCompliant(False)]
        public static byte ToByte(uint value);
        public static byte ToByte(long value);
        [CLSCompliant(False)]
        public static byte ToByte(ulong value);
        public static byte ToByte(float value);
        public static byte ToByte(double value);
        public static byte ToByte(decimal value);
        public static byte ToByte(string value);
        public static byte ToByte(string value, IFormatProvider provider);
        public static byte ToByte(DateTime value);
        public static short ToInt16(object value);
        public static short ToInt16(object value, IFormatProvider provider);
        public static short ToInt16(bool value);
        public static short ToInt16(char value);
        [CLSCompliant(False)]
        public static short ToInt16(sbyte value);
        public static short ToInt16(byte value);
        [CLSCompliant(False)]
        public static short ToInt16(ushort value);
        public static short ToInt16(int value);
        [CLSCompliant(False)]
        public static short ToInt16(uint value);
        public static short ToInt16(short value);
        public static short ToInt16(long value);
        [CLSCompliant(False)]
        public static short ToInt16(ulong value);
        public static short ToInt16(float value);
        public static short ToInt16(double value);
        public static short ToInt16(decimal value);
        public static short ToInt16(string value);
        public static short ToInt16(string value, IFormatProvider provider);
        public static short ToInt16(DateTime value);
        [CLSCompliant(False)]
        public static ushort ToUInt16(object value);
        [CLSCompliant(False)]
        public static ushort ToUInt16(object value, IFormatProvider provider);
        [CLSCompliant(False)]
        public static ushort ToUInt16(bool value);
        [CLSCompliant(False)]
        public static ushort ToUInt16(char value);
        [CLSCompliant(False)]
        public static ushort ToUInt16(sbyte value);
        [CLSCompliant(False)]
        public static ushort ToUInt16(byte value);
        [CLSCompliant(False)]
        public static ushort ToUInt16(short value);
        [CLSCompliant(False)]
        public static ushort ToUInt16(int value);
        [CLSCompliant(False)]
        public static ushort ToUInt16(ushort value);
        [CLSCompliant(False)]
        public static ushort ToUInt16(uint value);
        [CLSCompliant(False)]
        public static ushort ToUInt16(long value);
        [CLSCompliant(False)]
        public static ushort ToUInt16(ulong value);
        [CLSCompliant(False)]
        public static ushort ToUInt16(float value);
        [CLSCompliant(False)]
        public static ushort ToUInt16(double value);
        [CLSCompliant(False)]
        public static ushort ToUInt16(decimal value);
        [CLSCompliant(False)]
        public static ushort ToUInt16(string value);
        [CLSCompliant(False)]
        public static ushort ToUInt16(string value, IFormatProvider provider);
        [CLSCompliant(False)]
        public static ushort ToUInt16(DateTime value);
        public static int ToInt32(object value);
        public static int ToInt32(object value, IFormatProvider provider);
        public static int ToInt32(bool value);
        public static int ToInt32(char value);
        [CLSCompliant(False)]
        public static int ToInt32(sbyte value);
        public static int ToInt32(byte value);
        public static int ToInt32(short value);
        [CLSCompliant(False)]
        public static int ToInt32(ushort value);
        [CLSCompliant(False)]
        public static int ToInt32(uint value);
        public static int ToInt32(int value);
        public static int ToInt32(long value);
        [CLSCompliant(False)]
        public static int ToInt32(ulong value);
        public static int ToInt32(float value);
        public static int ToInt32(double value);
        [SecuritySafeCritical]
        public static int ToInt32(decimal value);
        public static int ToInt32(string value);
        public static int ToInt32(string value, IFormatProvider provider);
        public static int ToInt32(DateTime value);
        [CLSCompliant(False)]
        public static uint ToUInt32(object value);
        [CLSCompliant(False)]
        public static uint ToUInt32(object value, IFormatProvider provider);
        [CLSCompliant(False)]
        public static uint ToUInt32(bool value);
        [CLSCompliant(False)]
        public static uint ToUInt32(char value);
        [CLSCompliant(False)]
        public static uint ToUInt32(sbyte value);
        [CLSCompliant(False)]
        public static uint ToUInt32(byte value);
        [CLSCompliant(False)]
        public static uint ToUInt32(short value);
        [CLSCompliant(False)]
        public static uint ToUInt32(ushort value);
        [CLSCompliant(False)]
        public static uint ToUInt32(int value);
        [CLSCompliant(False)]
        public static uint ToUInt32(uint value);
        [CLSCompliant(False)]
        public static uint ToUInt32(long value);
        [CLSCompliant(False)]
        public static uint ToUInt32(ulong value);
        [CLSCompliant(False)]
        public static uint ToUInt32(float value);
        [CLSCompliant(False)]
        public static uint ToUInt32(double value);
        [CLSCompliant(False)]
        public static uint ToUInt32(decimal value);
        [CLSCompliant(False)]
        public static uint ToUInt32(string value);
        [CLSCompliant(False)]
        public static uint ToUInt32(string value, IFormatProvider provider);
        [CLSCompliant(False)]
        public static uint ToUInt32(DateTime value);
        public static long ToInt64(object value);
        public static long ToInt64(object value, IFormatProvider provider);
        public static long ToInt64(bool value);
        public static long ToInt64(char value);
        [CLSCompliant(False)]
        public static long ToInt64(sbyte value);
        public static long ToInt64(byte value);
        public static long ToInt64(short value);
        [CLSCompliant(False)]
        public static long ToInt64(ushort value);
        public static long ToInt64(int value);
        [CLSCompliant(False)]
        public static long ToInt64(uint value);
        [CLSCompliant(False)]
        public static long ToInt64(ulong value);
        public static long ToInt64(long value);
        public static long ToInt64(float value);
        public static long ToInt64(double value);
        public static long ToInt64(decimal value);
        public static long ToInt64(string value);
        public static long ToInt64(string value, IFormatProvider provider);
        public static long ToInt64(DateTime value);
        [CLSCompliant(False)]
        public static ulong ToUInt64(object value);
        [CLSCompliant(False)]
        public static ulong ToUInt64(object value, IFormatProvider provider);
        [CLSCompliant(False)]
        public static ulong ToUInt64(bool value);
        [CLSCompliant(False)]
        public static ulong ToUInt64(char value);
        [CLSCompliant(False)]
        public static ulong ToUInt64(sbyte value);
        [CLSCompliant(False)]
        public static ulong ToUInt64(byte value);
        [CLSCompliant(False)]
        public static ulong ToUInt64(short value);
        [CLSCompliant(False)]
        public static ulong ToUInt64(ushort value);
        [CLSCompliant(False)]
        public static ulong ToUInt64(int value);
        [CLSCompliant(False)]
        public static ulong ToUInt64(uint value);
        [CLSCompliant(False)]
        public static ulong ToUInt64(long value);
        [CLSCompliant(False)]
        public static ulong ToUInt64(ulong value);
        [CLSCompliant(False)]
        public static ulong ToUInt64(float value);
        [CLSCompliant(False)]
        public static ulong ToUInt64(double value);
        [CLSCompliant(False)]
        public static ulong ToUInt64(decimal value);
        [CLSCompliant(False)]
        public static ulong ToUInt64(string value);
        [CLSCompliant(False)]
        public static ulong ToUInt64(string value, IFormatProvider provider);
        [CLSCompliant(False)]
        public static ulong ToUInt64(DateTime value);
        public static float ToSingle(object value);
        public static float ToSingle(object value, IFormatProvider provider);
        [CLSCompliant(False)]
        public static float ToSingle(sbyte value);
        public static float ToSingle(byte value);
        public static float ToSingle(char value);
        public static float ToSingle(short value);
        [CLSCompliant(False)]
        public static float ToSingle(ushort value);
        public static float ToSingle(int value);
        [CLSCompliant(False)]
        public static float ToSingle(uint value);
        public static float ToSingle(long value);
        [CLSCompliant(False)]
        public static float ToSingle(ulong value);
        public static float ToSingle(float value);
        public static float ToSingle(double value);
        public static float ToSingle(decimal value);
        public static float ToSingle(string value);
        public static float ToSingle(string value, IFormatProvider provider);
        public static float ToSingle(bool value);
        public static float ToSingle(DateTime value);
        public static double ToDouble(object value);
        public static double ToDouble(object value, IFormatProvider provider);
        [CLSCompliant(False)]
        public static double ToDouble(sbyte value);
        public static double ToDouble(byte value);
        public static double ToDouble(short value);
        public static double ToDouble(char value);
        [CLSCompliant(False)]
        public static double ToDouble(ushort value);
        public static double ToDouble(int value);
        [CLSCompliant(False)]
        public static double ToDouble(uint value);
        public static double ToDouble(long value);
        [CLSCompliant(False)]
        public static double ToDouble(ulong value);
        public static double ToDouble(float value);
        public static double ToDouble(double value);
        public static double ToDouble(decimal value);
        public static double ToDouble(string value);
        public static double ToDouble(string value, IFormatProvider provider);
        public static double ToDouble(bool value);
        public static double ToDouble(DateTime value);
        public static decimal ToDecimal(object value);
        public static decimal ToDecimal(object value, IFormatProvider provider);
        [CLSCompliant(False)]
        public static decimal ToDecimal(sbyte value);
        public static decimal ToDecimal(byte value);
        public static decimal ToDecimal(char value);
        public static decimal ToDecimal(short value);
        [CLSCompliant(False)]
        public static decimal ToDecimal(ushort value);
        public static decimal ToDecimal(int value);
        [CLSCompliant(False)]
        public static decimal ToDecimal(uint value);
        public static decimal ToDecimal(long value);
        [CLSCompliant(False)]
        public static decimal ToDecimal(ulong value);
        public static decimal ToDecimal(float value);
        public static decimal ToDecimal(double value);
        public static decimal ToDecimal(string value);
        public static decimal ToDecimal(string value, IFormatProvider provider);
        public static decimal ToDecimal(decimal value);
        public static decimal ToDecimal(bool value);
        public static decimal ToDecimal(DateTime value);
        public static DateTime ToDateTime(DateTime value);
        public static DateTime ToDateTime(object value);
        public static DateTime ToDateTime(object value, IFormatProvider provider);
        public static DateTime ToDateTime(string value);
        public static DateTime ToDateTime(string value, IFormatProvider provider);
        [CLSCompliant(False)]
        public static DateTime ToDateTime(sbyte value);
        public static DateTime ToDateTime(byte value);
        public static DateTime ToDateTime(short value);
        [CLSCompliant(False)]
        public static DateTime ToDateTime(ushort value);
        public static DateTime ToDateTime(int value);
        [CLSCompliant(False)]
        public static DateTime ToDateTime(uint value);
        public static DateTime ToDateTime(long value);
        [CLSCompliant(False)]
        public static DateTime ToDateTime(ulong value);
        public static DateTime ToDateTime(bool value);
        public static DateTime ToDateTime(char value);
        public static DateTime ToDateTime(float value);
        public static DateTime ToDateTime(double value);
        public static DateTime ToDateTime(decimal value);
        public static string ToString(object value);
        public static string ToString(object value, IFormatProvider provider);
        public static string ToString(bool value);
        public static string ToString(bool value, IFormatProvider provider);
        public static string ToString(char value);
        public static string ToString(char value, IFormatProvider provider);
        [CLSCompliant(False)]
        public static string ToString(sbyte value);
        [CLSCompliant(False)]
        public static string ToString(sbyte value, IFormatProvider provider);
        public static string ToString(byte value);
        public static string ToString(byte value, IFormatProvider provider);
        public static string ToString(short value);
        public static string ToString(short value, IFormatProvider provider);
        [CLSCompliant(False)]
        public static string ToString(ushort value);
        [CLSCompliant(False)]
        public static string ToString(ushort value, IFormatProvider provider);
        public static string ToString(int value);
        public static string ToString(int value, IFormatProvider provider);
        [CLSCompliant(False)]
        public static string ToString(uint value);
        [CLSCompliant(False)]
        public static string ToString(uint value, IFormatProvider provider);
        public static string ToString(long value);
        public static string ToString(long value, IFormatProvider provider);
        [CLSCompliant(False)]
        public static string ToString(ulong value);
        [CLSCompliant(False)]
        public static string ToString(ulong value, IFormatProvider provider);
        public static string ToString(float value);
        public static string ToString(float value, IFormatProvider provider);
        public static string ToString(double value);
        public static string ToString(double value, IFormatProvider provider);
        public static string ToString(decimal value);
        public static string ToString(decimal value, IFormatProvider provider);
        public static string ToString(DateTime value);
        public static string ToString(DateTime value, IFormatProvider provider);
        public static string ToString(string value);
        public static string ToString(string value, IFormatProvider provider);
        public static byte ToByte(string value, int fromBase);
        [CLSCompliant(False)]
        public static sbyte ToSByte(string value, int fromBase);
        public static short ToInt16(string value, int fromBase);
        [CLSCompliant(False)]
        public static ushort ToUInt16(string value, int fromBase);
        public static int ToInt32(string value, int fromBase);
        [CLSCompliant(False)]
        public static uint ToUInt32(string value, int fromBase);
        public static long ToInt64(string value, int fromBase);
        [CLSCompliant(False)]
        public static ulong ToUInt64(string value, int fromBase);
        [SecuritySafeCritical]
        public static string ToString(byte value, int toBase);
        [SecuritySafeCritical]
        public static string ToString(short value, int toBase);
        [SecuritySafeCritical]
        public static string ToString(int value, int toBase);
        [SecuritySafeCritical]
        public static string ToString(long value, int toBase);
        public static string ToBase64String(byte[] inArray);
        [ComVisible(False)]
        public static string ToBase64String(byte[] inArray, Base64FormattingOptions options);
        public static string ToBase64String(byte[] inArray, int offset, int length);
        [ComVisible(False)]
        [SecuritySafeCritical]
        public static string ToBase64String(byte[] inArray, int offset, int length, Base64FormattingOptions options);
        public static int ToBase64CharArray(byte[] inArray, int offsetIn, int length, char[] outArray, int offsetOut);
        [ComVisible(False)]
        [SecuritySafeCritical]
        public static int ToBase64CharArray(byte[] inArray, int offsetIn, int length, char[] outArray, int offsetOut, Base64FormattingOptions options);
        [SecuritySafeCritical]
        public static byte[] FromBase64String(string s);
        [SecuritySafeCritical]
        public static byte[] FromBase64CharArray(char[] inArray, int offset, int length);
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public sealed class DataMisalignedException : SystemException
    {
        public DataMisalignedException();
        public DataMisalignedException(string message);
        public DataMisalignedException(string message, Exception innerException);
    }
}
//using System.Globalization;
//using System.Runtime.Serialization;

namespace System
{
    public struct DateTime : IComparable, IComparable<DateTime>, IConvertible, IEquatable<DateTime>, ISerializable, IFormattable
    {
        public static readonly DateTime MinValue;
        public static readonly DateTime MaxValue;

        public DateTime(long ticks);
        public DateTime(long ticks, DateTimeKind kind);
        public DateTime(int year, int month, int day);
        public DateTime(int year, int month, int day, Calendar calendar);
        public DateTime(int year, int month, int day, int hour, int minute, int second);
        public DateTime(int year, int month, int day, int hour, int minute, int second, DateTimeKind kind);
        public DateTime(int year, int month, int day, int hour, int minute, int second, Calendar calendar);
        public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);
        public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, DateTimeKind kind);
        public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar);
        public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar, DateTimeKind kind);

        public DateTime Date { get; }
        public int Day { get; }
        public DayOfWeek DayOfWeek { get; }
        public int DayOfYear { get; }
        public int Hour { get; }
        public DateTimeKind Kind { get; }
        public int Millisecond { get; }
        public int Minute { get; }
        public int Month { get; }
        public static DateTime Now { get; }
        public static DateTime UtcNow { get; }
        public int Second { get; }
        public long Ticks { get; }
        public TimeSpan TimeOfDay { get; }
        public static DateTime Today { get; }
        public int Year { get; }

        public DateTime Add(TimeSpan value);
        public DateTime AddDays(double value);
        public DateTime AddHours(double value);
        public DateTime AddMilliseconds(double value);
        public DateTime AddMinutes(double value);
        public DateTime AddMonths(int months);
        public DateTime AddSeconds(double value);
        public DateTime AddTicks(long value);
        public DateTime AddYears(int value);
        public static int Compare(DateTime t1, DateTime t2);
        public int CompareTo(object value);
        public int CompareTo(DateTime value);
        public static int DaysInMonth(int year, int month);
        public override bool Equals(object value);
        public bool Equals(DateTime value);
        public static bool Equals(DateTime t1, DateTime t2);
        public static DateTime FromBinary(long dateData);
        public static DateTime FromFileTime(long fileTime);
        public static DateTime FromFileTimeUtc(long fileTime);
        public static DateTime FromOADate(double d);
        public bool IsDaylightSavingTime();
        public static DateTime SpecifyKind(DateTime value, DateTimeKind kind);
        public long ToBinary();
        public override int GetHashCode();
        public static bool IsLeapYear(int year);
        public static DateTime Parse(string s);
        public static DateTime Parse(string s, IFormatProvider provider);
        public static DateTime Parse(string s, IFormatProvider provider, DateTimeStyles styles);
        public static DateTime ParseExact(string s, string format, IFormatProvider provider);
        public static DateTime ParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style);
        public static DateTime ParseExact(string s, string[] formats, IFormatProvider provider, DateTimeStyles style);
        public TimeSpan Subtract(DateTime value);
        public DateTime Subtract(TimeSpan value);
        public double ToOADate();
        public long ToFileTime();
        public long ToFileTimeUtc();
        public DateTime ToLocalTime();
        public string ToLongDateString();
        public string ToLongTimeString();
        public string ToShortDateString();
        public string ToShortTimeString();
        public override string ToString();
        public string ToString(string format);
        public string ToString(IFormatProvider provider);
        public string ToString(string format, IFormatProvider provider);
        public DateTime ToUniversalTime();
        public static bool TryParse(string s, out DateTime result);
        public static bool TryParse(string s, IFormatProvider provider, DateTimeStyles styles, out DateTime result);
        public static bool TryParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style, out DateTime result);
        public static bool TryParseExact(string s, string[] formats, IFormatProvider provider, DateTimeStyles style, out DateTime result);
        public string[] GetDateTimeFormats();
        public string[] GetDateTimeFormats(IFormatProvider provider);
        public string[] GetDateTimeFormats(char format);
        public string[] GetDateTimeFormats(char format, IFormatProvider provider);
        public TypeCode GetTypeCode();

        public static DateTime operator +(DateTime d, TimeSpan t);
        public static DateTime operator -(DateTime d, TimeSpan t);
        public static TimeSpan operator -(DateTime d1, DateTime d2);
        public static bool operator ==(DateTime d1, DateTime d2);
        public static bool operator !=(DateTime d1, DateTime d2);
        public static bool operator <(DateTime t1, DateTime t2);
        public static bool operator <=(DateTime t1, DateTime t2);
        public static bool operator >(DateTime t1, DateTime t2);
        public static bool operator >=(DateTime t1, DateTime t2);
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public enum DateTimeKind
    {
        Unspecified = 0,
        Utc = 1,
        Local = 2
    }
}
//using System.Globalization;
//using System.Runtime.Serialization;

namespace System
{
    public struct DateTimeOffset : IComparable, IComparable<DateTimeOffset>, IDeserializationCallback, IEquatable<DateTimeOffset>, ISerializable, IFormattable
    {
        public static readonly DateTimeOffset MinValue;
        public static readonly DateTimeOffset MaxValue;

        public DateTimeOffset(long ticks, TimeSpan offset);
        public DateTimeOffset(DateTime dateTime);
        public DateTimeOffset(DateTime dateTime, TimeSpan offset);
        public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, TimeSpan offset);
        public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, TimeSpan offset);
        public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar, TimeSpan offset);

        public static DateTimeOffset Now { get; }
        public static DateTimeOffset UtcNow { get; }
        public DateTime DateTime { get; }
        public DateTime UtcDateTime { get; }
        public DateTime LocalDateTime { get; }
        public DateTime Date { get; }
        public int Day { get; }
        public DayOfWeek DayOfWeek { get; }
        public int DayOfYear { get; }
        public int Hour { get; }
        public int Millisecond { get; }
        public int Minute { get; }
        public int Month { get; }
        public TimeSpan Offset { get; }
        public int Second { get; }
        public long Ticks { get; }
        public long UtcTicks { get; }
        public TimeSpan TimeOfDay { get; }
        public int Year { get; }

        public DateTimeOffset ToOffset(TimeSpan offset);
        public DateTimeOffset Add(TimeSpan timeSpan);
        public DateTimeOffset AddDays(double days);
        public DateTimeOffset AddHours(double hours);
        public DateTimeOffset AddMilliseconds(double milliseconds);
        public DateTimeOffset AddMinutes(double minutes);
        public DateTimeOffset AddMonths(int months);
        public DateTimeOffset AddSeconds(double seconds);
        public DateTimeOffset AddTicks(long ticks);
        public DateTimeOffset AddYears(int years);
        public static int Compare(DateTimeOffset first, DateTimeOffset second);
        public int CompareTo(DateTimeOffset other);
        public override bool Equals(object obj);
        public bool Equals(DateTimeOffset other);
        public bool EqualsExact(DateTimeOffset other);
        public static bool Equals(DateTimeOffset first, DateTimeOffset second);
        public static DateTimeOffset FromFileTime(long fileTime);
        public static DateTimeOffset FromUnixTimeSeconds(long seconds);
        public static DateTimeOffset FromUnixTimeMilliseconds(long milliseconds);
        public override int GetHashCode();
        public static DateTimeOffset Parse(string input);
        public static DateTimeOffset Parse(string input, IFormatProvider formatProvider);
        public static DateTimeOffset Parse(string input, IFormatProvider formatProvider, DateTimeStyles styles);
        public static DateTimeOffset ParseExact(string input, string format, IFormatProvider formatProvider);
        public static DateTimeOffset ParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles);
        public static DateTimeOffset ParseExact(string input, string[] formats, IFormatProvider formatProvider, DateTimeStyles styles);
        public TimeSpan Subtract(DateTimeOffset value);
        public DateTimeOffset Subtract(TimeSpan value);
        public long ToFileTime();
        public long ToUnixTimeSeconds();
        public long ToUnixTimeMilliseconds();
        public DateTimeOffset ToLocalTime();
        public override string ToString();
        public string ToString(string format);
        public string ToString(IFormatProvider formatProvider);
        public string ToString(string format, IFormatProvider formatProvider);
        public DateTimeOffset ToUniversalTime();
        public static bool TryParse(string input, out DateTimeOffset result);
        public static bool TryParse(string input, IFormatProvider formatProvider, DateTimeStyles styles, out DateTimeOffset result);
        public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles, out DateTimeOffset result);
        public static bool TryParseExact(string input, string[] formats, IFormatProvider formatProvider, DateTimeStyles styles, out DateTimeOffset result);

        public static DateTimeOffset operator +(DateTimeOffset dateTimeOffset, TimeSpan timeSpan);
        public static DateTimeOffset operator -(DateTimeOffset dateTimeOffset, TimeSpan timeSpan);
        public static TimeSpan operator -(DateTimeOffset left, DateTimeOffset right);
        public static bool operator ==(DateTimeOffset left, DateTimeOffset right);
        public static bool operator !=(DateTimeOffset left, DateTimeOffset right);
        public static bool operator <(DateTimeOffset left, DateTimeOffset right);
        public static bool operator <=(DateTimeOffset left, DateTimeOffset right);
        public static bool operator >(DateTimeOffset left, DateTimeOffset right);
        public static bool operator >=(DateTimeOffset left, DateTimeOffset right);

        public static implicit operator DateTimeOffset(DateTime dateTime);
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public enum DayOfWeek
    {
        Sunday = 0,
        Monday = 1,
        Tuesday = 2,
        Wednesday = 3,
        Thursday = 4,
        Friday = 5,
        Saturday = 6
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;
//using System.Security;

namespace System
{
    [ComVisible(True)]
    public sealed class DBNull : IConvertible, ISerializable
    {
        public static readonly DBNull Value;

        [SecurityCritical]
        public void GetObjectData(SerializationInfo info, StreamingContext context);
        public override string ToString();
        public string ToString(IFormatProvider provider);
        public TypeCode GetTypeCode();
    }
}
//using System.Globalization;
//using System.Runtime.ConstrainedExecution;
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;
//using System.Security;

namespace System
{
    [ComVisible(True)]
    public struct Decimal : IComparable, IComparable<decimal>, IConvertible, IDeserializationCallback, IEquatable<decimal>, IFormattable
    {
        public const decimal Zero = 0;
        public const decimal One = 1;
        public const decimal MinusOne = -1;
        public const decimal MaxValue = 79228162514264337593543950335;
        public const decimal MinValue = -79228162514264337593543950335;

        public Decimal(int value);
        [CLSCompliant(False)]
        public Decimal(uint value);
        public Decimal(long value);
        [CLSCompliant(False)]
        public Decimal(ulong value);
        [SecuritySafeCritical]
        public Decimal(float value);
        [SecuritySafeCritical]
        public Decimal(double value);
        public Decimal(int[] bits);
        public Decimal(int lo, int mid, int hi, bool isNegative, byte scale);

        public static long ToOACurrency(decimal value);
        public static decimal FromOACurrency(long cy);
        [SecuritySafeCritical]
        public static decimal Add(decimal d1, decimal d2);
        public static decimal Ceiling(decimal d);
        [SecuritySafeCritical]
        [ReliabilityContract(WillNotCorruptState, Success)]
        public static int Compare(decimal d1, decimal d2);
        [SecuritySafeCritical]
        public int CompareTo(object value);
        [SecuritySafeCritical]
        public int CompareTo(decimal value);
        [SecuritySafeCritical]
        public static decimal Divide(decimal d1, decimal d2);
        [SecuritySafeCritical]
        public override bool Equals(object value);
        [SecuritySafeCritical]
        public bool Equals(decimal value);
        [SecuritySafeCritical]
        public override int GetHashCode();
        [SecuritySafeCritical]
        public static bool Equals(decimal d1, decimal d2);
        [SecuritySafeCritical]
        public static decimal Floor(decimal d);
        [SecuritySafeCritical]
        public override string ToString();
        [SecuritySafeCritical]
        public string ToString(string format);
        [SecuritySafeCritical]
        public string ToString(IFormatProvider provider);
        [SecuritySafeCritical]
        public string ToString(string format, IFormatProvider provider);
        public static decimal Parse(string s);
        public static decimal Parse(string s, NumberStyles style);
        public static decimal Parse(string s, IFormatProvider provider);
        public static decimal Parse(string s, NumberStyles style, IFormatProvider provider);
        public static bool TryParse(string s, out decimal result);
        public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out decimal result);
        public static int[] GetBits(decimal d);
        public static decimal Remainder(decimal d1, decimal d2);
        [SecuritySafeCritical]
        public static decimal Multiply(decimal d1, decimal d2);
        public static decimal Negate(decimal d);
        public static decimal Round(decimal d);
        [SecuritySafeCritical]
        public static decimal Round(decimal d, int decimals);
        public static decimal Round(decimal d, MidpointRounding mode);
        [SecuritySafeCritical]
        public static decimal Round(decimal d, int decimals, MidpointRounding mode);
        [SecuritySafeCritical]
        public static decimal Subtract(decimal d1, decimal d2);
        public static byte ToByte(decimal value);
        [CLSCompliant(False)]
        public static sbyte ToSByte(decimal value);
        public static short ToInt16(decimal value);
        [SecuritySafeCritical]
        public static double ToDouble(decimal d);
        [SecuritySafeCritical]
        public static int ToInt32(decimal d);
        [SecuritySafeCritical]
        public static long ToInt64(decimal d);
        [CLSCompliant(False)]
        public static ushort ToUInt16(decimal value);
        [CLSCompliant(False)]
        [SecuritySafeCritical]
        public static uint ToUInt32(decimal d);
        [CLSCompliant(False)]
        [SecuritySafeCritical]
        public static ulong ToUInt64(decimal d);
        [SecuritySafeCritical]
        public static float ToSingle(decimal d);
        [SecuritySafeCritical]
        public static decimal Truncate(decimal d);
        public TypeCode GetTypeCode();

        public static decimal operator +(decimal d);
        public static decimal operator -(decimal d);
        public static decimal operator ++(decimal d);
        public static decimal operator --(decimal d);
        [SecuritySafeCritical]
        public static decimal operator +(decimal d1, decimal d2);
        [SecuritySafeCritical]
        public static decimal operator -(decimal d1, decimal d2);
        [SecuritySafeCritical]
        public static decimal operator *(decimal d1, decimal d2);
        [SecuritySafeCritical]
        public static decimal operator /(decimal d1, decimal d2);
        public static decimal operator %(decimal d1, decimal d2);
        [SecuritySafeCritical]
        public static bool operator ==(decimal d1, decimal d2);
        [SecuritySafeCritical]
        public static bool operator !=(decimal d1, decimal d2);
        [SecuritySafeCritical]
        public static bool operator <(decimal d1, decimal d2);
        [SecuritySafeCritical]
        public static bool operator <=(decimal d1, decimal d2);
        [SecuritySafeCritical]
        public static bool operator >(decimal d1, decimal d2);
        [SecuritySafeCritical]
        public static bool operator >=(decimal d1, decimal d2);

        public static implicit operator decimal(byte value);
        [CLSCompliant(False)]
        public static implicit operator decimal(sbyte value);
        public static implicit operator decimal(short value);
        [CLSCompliant(False)]
        public static implicit operator decimal(ushort value);
        public static implicit operator decimal(char value);
        public static implicit operator decimal(int value);
        [CLSCompliant(False)]
        public static implicit operator decimal(uint value);
        public static implicit operator decimal(long value);
        [CLSCompliant(False)]
        public static implicit operator decimal(ulong value);
        public static explicit operator decimal(float value);
        public static explicit operator decimal(double value);
        public static explicit operator byte(decimal value);
        [CLSCompliant(False)]
        public static explicit operator sbyte(decimal value);
        public static explicit operator char(decimal value);
        public static explicit operator short(decimal value);
        [CLSCompliant(False)]
        public static explicit operator ushort(decimal value);
        public static explicit operator int(decimal value);
        [CLSCompliant(False)]
        public static explicit operator uint(decimal value);
        public static explicit operator long(decimal value);
        [CLSCompliant(False)]
        public static explicit operator ulong(decimal value);
        public static explicit operator float(decimal value);
        public static explicit operator double(decimal value);
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System
{
    [ComVisible(True)]
    public class DivideByZeroException : ArithmeticException
    {
        public DivideByZeroException();
        public DivideByZeroException(string message);
        public DivideByZeroException(string message, Exception innerException);
        protected DivideByZeroException(SerializationInfo info, StreamingContext context);
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System
{
    [ComVisible(True)]
    public class DllNotFoundException : TypeLoadException
    {
        public DllNotFoundException();
        public DllNotFoundException(string message);
        public DllNotFoundException(string message, Exception inner);
        protected DllNotFoundException(SerializationInfo info, StreamingContext context);
    }
}
//using System.Globalization;
//using System.Runtime.ConstrainedExecution;
//using System.Runtime.InteropServices;
//using System.Security;

namespace System
{
    [ComVisible(True)]
    public struct Double : IComparable, IComparable<double>, IConvertible, IEquatable<double>, IFormattable
    {
        public const double MinValue = -1.79769313486232E+308;
        public const double MaxValue = 1.79769313486232E+308;
        public const double Epsilon = 4.94065645841247E-324;
        public const double NegativeInfinity = -Infinity;
        public const double PositiveInfinity = Infinity;
        public const double NaN = NaN;

        [SecuritySafeCritical]
        public static bool IsInfinity(double d);
        public static bool IsPositiveInfinity(double d);
        public static bool IsNegativeInfinity(double d);
        [ReliabilityContract(WillNotCorruptState, Success)]
        [SecuritySafeCritical]
        public static bool IsNaN(double d);
        public static bool IsFinite(double d);
        public int CompareTo(object value);
        public int CompareTo(double value);
        public override bool Equals(object obj);
        public bool Equals(double obj);
        [SecuritySafeCritical]
        public override int GetHashCode();
        [SecuritySafeCritical]
        public override string ToString();
        [SecuritySafeCritical]
        public string ToString(string format);
        [SecuritySafeCritical]
        public string ToString(IFormatProvider provider);
        [SecuritySafeCritical]
        public string ToString(string format, IFormatProvider provider);
        public static double Parse(string s);
        public static double Parse(string s, NumberStyles style);
        public static double Parse(string s, IFormatProvider provider);
        public static double Parse(string s, NumberStyles style, IFormatProvider provider);
        public static bool TryParse(string s, out double result);
        public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out double result);
        public TypeCode GetTypeCode();

        public static bool operator ==(double left, double right);
        public static bool operator !=(double left, double right);
        public static bool operator <(double left, double right);
        public static bool operator >(double left, double right);
        public static bool operator <=(double left, double right);
        public static bool operator >=(double left, double right);
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System
{
    [ComVisible(True)]
    public class DuplicateWaitObjectException : ArgumentException
    {
        public DuplicateWaitObjectException();
        public DuplicateWaitObjectException(string parameterName);
        public DuplicateWaitObjectException(string parameterName, string message);
        public DuplicateWaitObjectException(string message, Exception innerException);
        protected DuplicateWaitObjectException(SerializationInfo info, StreamingContext context);
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System
{
    [ComVisible(True)]
    public class EntryPointNotFoundException : TypeLoadException
    {
        public EntryPointNotFoundException();
        public EntryPointNotFoundException(string message);
        public EntryPointNotFoundException(string message, Exception inner);
        protected EntryPointNotFoundException(SerializationInfo info, StreamingContext context);
    }
}
//using System.Runtime.InteropServices;
//using System.Security;

namespace System
{
    [ComVisible(True)]
    public abstract class Enum : ValueType, IComparable, IConvertible, IFormattable
    {
        protected Enum();

        public static bool TryParse<TEnum>(string value, out TEnum result) where TEnum : struct;
        public static bool TryParse<TEnum>(string value, bool ignoreCase, out TEnum result) where TEnum : struct;
        [ComVisible(True)]
        public static object Parse(Type enumType, string value);
        [ComVisible(True)]
        public static object Parse(Type enumType, string value, bool ignoreCase);
        [ComVisible(True)]
        public static Type GetUnderlyingType(Type enumType);
        [ComVisible(True)]
        public static Array GetValues(Type enumType);
        [ComVisible(True)]
        public static string GetName(Type enumType, object value);
        [ComVisible(True)]
        public static string[] GetNames(Type enumType);
        [ComVisible(True)]
        public static object ToObject(Type enumType, object value);
        [ComVisible(True)]
        public static bool IsDefined(Type enumType, object value);
        [ComVisible(True)]
        public static string Format(Type enumType, object value, string format);
        public override bool Equals(object obj);
        [SecuritySafeCritical]
        public override int GetHashCode();
        public override string ToString();
        [Obsolete("The provider argument is not used. Please use ToString(String).")]
        public string ToString(string format, IFormatProvider provider);
        [SecuritySafeCritical]
        public int CompareTo(object target);
        public string ToString(string format);
        [Obsolete("The provider argument is not used. Please use ToString().")]
        public string ToString(IFormatProvider provider);
        [SecuritySafeCritical]
        public bool HasFlag(Enum flag);
        public TypeCode GetTypeCode();
        [CLSCompliant(False)]
        [ComVisible(True)]
        [SecuritySafeCritical]
        public static object ToObject(Type enumType, sbyte value);
        [ComVisible(True)]
        [SecuritySafeCritical]
        public static object ToObject(Type enumType, short value);
        [ComVisible(True)]
        [SecuritySafeCritical]
        public static object ToObject(Type enumType, int value);
        [SecuritySafeCritical]
        [ComVisible(True)]
        public static object ToObject(Type enumType, byte value);
        [CLSCompliant(False)]
        [ComVisible(True)]
        [SecuritySafeCritical]
        public static object ToObject(Type enumType, ushort value);
        [CLSCompliant(False)]
        [ComVisible(True)]
        [SecuritySafeCritical]
        public static object ToObject(Type enumType, uint value);
        [ComVisible(True)]
        [SecuritySafeCritical]
        public static object ToObject(Type enumType, long value);
        [ComVisible(True)]
        [SecuritySafeCritical]
        [CLSCompliant(False)]
        public static object ToObject(Type enumType, ulong value);
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public class EventArgs
    {
        public static readonly EventArgs Empty;

        public EventArgs();
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public delegate void EventHandler(object sender, EventArgs e);
}
namespace System
{
    public delegate void EventHandler<TEventArgs>(object sender, TEventArgs e);
}
//using System.Collections;
//using System.Reflection;
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;
//using System.Security;

namespace System
{
    [ClassInterface(None)]
    [ComDefaultInterface(typeof(_Exception))]
    [ComVisible(True)]
    public class Exception : _Exception, ISerializable
    {
        public Exception();
        public Exception(string message);
        public Exception(string message, Exception innerException);
        [SecuritySafeCritical]
        protected Exception(SerializationInfo info, StreamingContext context);

        public virtual string Message { get; }
        public virtual IDictionary Data { get; }
        public Exception InnerException { get; }
        public MethodBase TargetSite { get; }
        public virtual string StackTrace { get; }
        public virtual string HelpLink { get; set; }
        public virtual string Source { get; set; }
        public int HResult { get; protected set; }

        protected event EventHandler<SafeSerializationEventArgs> SerializeObjectState;

        public virtual Exception GetBaseException();
        public override string ToString();
        [SecurityCritical]
        public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
        public Type GetType();
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [Obsolete("This type previously indicated an unspecified fatal error in the runtime. The runtime no longer raises this exception so this type is obsolete.")]
    [ComVisible(True)]
    public sealed class ExecutionEngineException : SystemException
    {
        public ExecutionEngineException();
        public ExecutionEngineException(string message);
        public ExecutionEngineException(string message, Exception innerException);
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System
{
    [ComVisible(True)]
    public class FieldAccessException : MemberAccessException
    {
        public FieldAccessException();
        public FieldAccessException(string message);
        public FieldAccessException(string message, Exception inner);
        protected FieldAccessException(SerializationInfo info, StreamingContext context);
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [AttributeUsage(Enum, Inherited = False)]
    [ComVisible(True)]
    public class FlagsAttribute : Attribute
    {
        public FlagsAttribute();
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System
{
    [ComVisible(True)]
    public class FormatException : SystemException
    {
        public FormatException();
        public FormatException(string message);
        public FormatException(string message, Exception innerException);
        protected FormatException(SerializationInfo info, StreamingContext context);
    }
}
namespace System
{
    public enum GCCollectionMode
    {
        Default = 0,
        Forced = 1,
        Optimized = 2
    }
}
namespace System
{
    public enum GCNotificationStatus
    {
        Succeeded = 0,
        Failed = 1,
        Canceled = 2,
        Timeout = 3,
        NotApplicable = 4
    }
}
//using System.Runtime.ConstrainedExecution;
//using System.Security;

namespace System
{
    public static class GC
    {
        public static int MaxGeneration { get; }

        [SecurityCritical]
        public static void AddMemoryPressure(long bytesAllocated);
        [SecurityCritical]
        public static void RemoveMemoryPressure(long bytesAllocated);
        [SecuritySafeCritical]
        public static int GetGeneration(object obj);
        public static void Collect(int generation);
        [SecuritySafeCritical]
        public static void Collect();
        [SecuritySafeCritical]
        public static void Collect(int generation, GCCollectionMode mode);
        [SecuritySafeCritical]
        public static void Collect(int generation, GCCollectionMode mode, bool blocking);
        [SecuritySafeCritical]
        public static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);
        [ReliabilityContract(WillNotCorruptState, Success)]
        [SecuritySafeCritical]
        public static int CollectionCount(int generation);
        [ReliabilityContract(WillNotCorruptState, Success)]
        public static void KeepAlive(object obj);
        [SecuritySafeCritical]
        public static int GetGeneration(WeakReference wo);
        public static void WaitForPendingFinalizers();
        [SecuritySafeCritical]
        [ReliabilityContract(WillNotCorruptState, Success)]
        public static void SuppressFinalize(object obj);
        [SecuritySafeCritical]
        public static void ReRegisterForFinalize(object obj);
        public static long GetTotalMemory(bool forceFullCollection);
        [SecurityCritical]
        public static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);
        [SecurityCritical]
        public static void CancelFullGCNotification();
        [SecurityCritical]
        public static GCNotificationStatus WaitForFullGCApproach();
        [SecurityCritical]
        public static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);
        [SecurityCritical]
        public static GCNotificationStatus WaitForFullGCComplete();
        [SecurityCritical]
        public static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);
        [SecurityCritical]
        public static bool TryStartNoGCRegion(long totalSize);
        [SecurityCritical]
        public static bool TryStartNoGCRegion(long totalSize, long lohSize);
        [SecurityCritical]
        public static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);
        [SecurityCritical]
        public static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);
        [SecurityCritical]
        public static void EndNoGCRegion();
    }
}
//using System.Runtime.InteropServices;
//using System.Security;

namespace System
{
    [ComVisible(True)]
    public struct Guid : IComparable, IComparable<Guid>, IEquatable<Guid>, IFormattable
    {
        public static readonly Guid Empty;

        public Guid(byte[] b);
        [CLSCompliant(False)]
        public Guid(uint a, ushort b, ushort c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
        public Guid(int a, short b, short c, byte[] d);
        public Guid(int a, short b, short c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
        public Guid(string g);

        public static Guid Parse(string input);
        public static bool TryParse(string input, out Guid result);
        public static Guid ParseExact(string input, string format);
        public static bool TryParseExact(string input, string format, out Guid result);
        public byte[] ToByteArray();
        public override string ToString();
        public override int GetHashCode();
        public override bool Equals(object o);
        public bool Equals(Guid g);
        public int CompareTo(object value);
        public int CompareTo(Guid value);
        public string ToString(string format);
        [SecuritySafeCritical]
        public string ToString(string format, IFormatProvider provider);
        public static Guid NewGuid();

        public static bool operator ==(Guid a, Guid b);
        public static bool operator !=(Guid a, Guid b);
    }
}
//using System.Globalization;
//using System.Reflection;
//using System.Reflection.Emit;
//using System.Runtime.InteropServices;
//using System.Runtime.Remoting;
//using System.Security;
//using System.Security.Policy;
//using System.Security.Principal;

namespace System
{
    [CLSCompliant(False)]
    [InterfaceType(InterfaceIsIUnknown)]
    [ComVisible(True)]
    [Guid("05F696DC-2B29-3663-AD8B-C4389CF2A713")]
    public interface _AppDomain
    {
        string FriendlyName { get; }
        string BaseDirectory { get; }
        string RelativeSearchPath { get; }
        bool ShadowCopyFiles { get; }
        string DynamicDirectory { get; }
        Evidence Evidence { get; }

        event EventHandler DomainUnload;
        event AssemblyLoadEventHandler AssemblyLoad;
        event EventHandler ProcessExit;
        event ResolveEventHandler TypeResolve;
        event ResolveEventHandler ResourceResolve;
        event ResolveEventHandler AssemblyResolve;
        event UnhandledExceptionEventHandler UnhandledException;

        void GetTypeInfoCount(out uint pcTInfo);
        void GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
        void GetIDsOfNames(in Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
        void Invoke(uint dispIdMember, in Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
        string ToString();
        bool Equals(object other);
        int GetHashCode();
        Type GetType();
        [SecurityCritical]
        object InitializeLifetimeService();
        [SecurityCritical]
        object GetLifetimeService();
        AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access);
        AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir);
        AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, Evidence evidence);
        AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions);
        AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence);
        AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions);
        AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions);
        AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions);
        AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions, bool isSynchronized);
        ObjectHandle CreateInstance(string assemblyName, string typeName);
        ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName);
        ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes);
        ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes);
        ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes, Evidence securityAttributes);
        ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes, Evidence securityAttributes);
        Assembly Load(AssemblyName assemblyRef);
        Assembly Load(string assemblyString);
        Assembly Load(byte[] rawAssembly);
        Assembly Load(byte[] rawAssembly, byte[] rawSymbolStore);
        Assembly Load(byte[] rawAssembly, byte[] rawSymbolStore, Evidence securityEvidence);
        Assembly Load(AssemblyName assemblyRef, Evidence assemblySecurity);
        Assembly Load(string assemblyString, Evidence assemblySecurity);
        int ExecuteAssembly(string assemblyFile, Evidence assemblySecurity);
        int ExecuteAssembly(string assemblyFile);
        int ExecuteAssembly(string assemblyFile, Evidence assemblySecurity, string[] args);
        Assembly[] GetAssemblies();
        [SecurityCritical]
        void AppendPrivatePath(string path);
        [SecurityCritical]
        void ClearPrivatePath();
        [SecurityCritical]
        void SetShadowCopyPath(string s);
        [SecurityCritical]
        void ClearShadowCopyPath();
        [SecurityCritical]
        void SetCachePath(string s);
        [SecurityCritical]
        void SetData(string name, object data);
        object GetData(string name);
        void DoCallBack(CrossAppDomainDelegate theDelegate);
        [SecurityCritical]
        void SetAppDomainPolicy(PolicyLevel domainPolicy);
        void SetPrincipalPolicy(PrincipalPolicy policy);
        void SetThreadPrincipal(IPrincipal principal);
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    [Guid("27FFF232-A7A8-40dd-8D4A-734AD59FCD41")]
    [InterfaceType(InterfaceIsIUnknown)]
    public interface IAppDomainSetup
    {
        string ApplicationBase { get; set; }
        string ApplicationName { get; set; }
        string CachePath { get; set; }
        string ConfigurationFile { get; set; }
        string DynamicBase { get; set; }
        string LicenseFile { get; set; }
        string PrivateBinPath { get; set; }
        string PrivateBinPathProbe { get; set; }
        string ShadowCopyDirectories { get; set; }
        string ShadowCopyFiles { get; set; }
    }
}
//using System.Runtime.InteropServices;
//using System.Threading;

namespace System
{
    [ComVisible(True)]
    public interface IAsyncResult
    {
        bool IsCompleted { get; }
        WaitHandle AsyncWaitHandle { get; }
        object AsyncState { get; }
        bool CompletedSynchronously { get; }
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public interface ICloneable
    {
        object Clone();
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public interface IComparable
    {
        int CompareTo(object obj);
    }
}
namespace System
{
    public interface IComparable<T>
    {
        int CompareTo(T other);
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [CLSCompliant(False)]
    [ComVisible(True)]
    public interface IConvertible
    {
        TypeCode GetTypeCode();
        bool ToBoolean(IFormatProvider provider);
        char ToChar(IFormatProvider provider);
        sbyte ToSByte(IFormatProvider provider);
        byte ToByte(IFormatProvider provider);
        short ToInt16(IFormatProvider provider);
        ushort ToUInt16(IFormatProvider provider);
        int ToInt32(IFormatProvider provider);
        uint ToUInt32(IFormatProvider provider);
        long ToInt64(IFormatProvider provider);
        ulong ToUInt64(IFormatProvider provider);
        float ToSingle(IFormatProvider provider);
        double ToDouble(IFormatProvider provider);
        decimal ToDecimal(IFormatProvider provider);
        DateTime ToDateTime(IFormatProvider provider);
        string ToString(IFormatProvider provider);
        object ToType(Type conversionType, IFormatProvider provider);
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public interface ICustomFormatter
    {
        string Format(string format, object arg, IFormatProvider formatProvider);
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public interface IDisposable
    {
        void Dispose();
    }
}
namespace System
{
    public interface IEquatable<T>
    {
        bool Equals(T other);
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public interface IFormatProvider
    {
        object GetFormat(Type formatType);
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public interface IFormattable
    {
        string ToString(string format, IFormatProvider formatProvider);
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public sealed class IndexOutOfRangeException : SystemException
    {
        public IndexOutOfRangeException();
        public IndexOutOfRangeException(string message);
        public IndexOutOfRangeException(string message, Exception innerException);
    }
}
namespace System
{
    public sealed class InsufficientExecutionStackException : SystemException
    {
        public InsufficientExecutionStackException();
        public InsufficientExecutionStackException(string message);
        public InsufficientExecutionStackException(string message, Exception innerException);
    }
}
namespace System
{
    public sealed class InsufficientMemoryException : OutOfMemoryException
    {
        public InsufficientMemoryException();
        public InsufficientMemoryException(string message);
        public InsufficientMemoryException(string message, Exception innerException);
    }
}
//using System.Globalization;
//using System.Runtime.InteropServices;
//using System.Security;

namespace System
{
    [ComVisible(True)]
    public struct Int16 : IComparable, IComparable<short>, IConvertible, IEquatable<short>, IFormattable
    {
        public const short MaxValue = 32767;
        public const short MinValue = -32768;

        public int CompareTo(object value);
        public int CompareTo(short value);
        public override bool Equals(object obj);
        public bool Equals(short obj);
        public override int GetHashCode();
        [SecuritySafeCritical]
        public override string ToString();
        [SecuritySafeCritical]
        public string ToString(IFormatProvider provider);
        public string ToString(string format);
        public string ToString(string format, IFormatProvider provider);
        public static short Parse(string s);
        public static short Parse(string s, NumberStyles style);
        public static short Parse(string s, IFormatProvider provider);
        public static short Parse(string s, NumberStyles style, IFormatProvider provider);
        public static bool TryParse(string s, out short result);
        public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out short result);
        public TypeCode GetTypeCode();
    }
}
//using System.Globalization;
//using System.Runtime.InteropServices;
//using System.Security;

namespace System
{
    [ComVisible(True)]
    public struct Int32 : IComparable, IComparable<int>, IConvertible, IEquatable<int>, IFormattable
    {
        public const int MaxValue = 2147483647;
        public const int MinValue = -2147483648;

        public int CompareTo(object value);
        public int CompareTo(int value);
        public override bool Equals(object obj);
        public bool Equals(int obj);
        public override int GetHashCode();
        [SecuritySafeCritical]
        public override string ToString();
        [SecuritySafeCritical]
        public string ToString(string format);
        [SecuritySafeCritical]
        public string ToString(IFormatProvider provider);
        [SecuritySafeCritical]
        public string ToString(string format, IFormatProvider provider);
        public static int Parse(string s);
        public static int Parse(string s, NumberStyles style);
        public static int Parse(string s, IFormatProvider provider);
        public static int Parse(string s, NumberStyles style, IFormatProvider provider);
        public static bool TryParse(string s, out int result);
        public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out int result);
        public TypeCode GetTypeCode();
    }
}
//using System.Globalization;
//using System.Runtime.InteropServices;
//using System.Security;

namespace System
{
    [ComVisible(True)]
    public struct Int64 : IComparable, IComparable<long>, IConvertible, IEquatable<long>, IFormattable
    {
        public const long MaxValue = 9223372036854775807;
        public const long MinValue = -9223372036854775808;

        public int CompareTo(object value);
        public int CompareTo(long value);
        public override bool Equals(object obj);
        public bool Equals(long obj);
        public override int GetHashCode();
        [SecuritySafeCritical]
        public override string ToString();
        [SecuritySafeCritical]
        public string ToString(IFormatProvider provider);
        [SecuritySafeCritical]
        public string ToString(string format);
        [SecuritySafeCritical]
        public string ToString(string format, IFormatProvider provider);
        public static long Parse(string s);
        public static long Parse(string s, NumberStyles style);
        public static long Parse(string s, IFormatProvider provider);
        public static long Parse(string s, NumberStyles style, IFormatProvider provider);
        public static bool TryParse(string s, out long result);
        public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out long result);
        public TypeCode GetTypeCode();
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System
{
    [ComVisible(True)]
    public class InvalidCastException : SystemException
    {
        public InvalidCastException();
        public InvalidCastException(string message);
        public InvalidCastException(string message, Exception innerException);
        protected InvalidCastException(SerializationInfo info, StreamingContext context);
        public InvalidCastException(string message, int errorCode);
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System
{
    [ComVisible(True)]
    public class InvalidOperationException : SystemException
    {
        public InvalidOperationException();
        public InvalidOperationException(string message);
        public InvalidOperationException(string message, Exception innerException);
        protected InvalidOperationException(SerializationInfo info, StreamingContext context);
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public sealed class InvalidProgramException : SystemException
    {
        public InvalidProgramException();
        public InvalidProgramException(string message);
        public InvalidProgramException(string message, Exception inner);
    }
}
//using System.Runtime.CompilerServices;
//using System.Runtime.Serialization;

namespace System
{
    [TypeForwardedFrom("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")]
    public class InvalidTimeZoneException : Exception
    {
        public InvalidTimeZoneException(string message);
        public InvalidTimeZoneException(string message, Exception innerException);
        protected InvalidTimeZoneException(SerializationInfo info, StreamingContext context);
        public InvalidTimeZoneException();
    }
}
namespace System
{
    public interface IObservable<T>
    {
        IDisposable Subscribe(IObserver<T> observer);
    }
}
namespace System
{
    public interface IObserver<T>
    {
        void OnNext(T value);
        void OnError(Exception error);
        void OnCompleted();
    }
}
namespace System
{
    public interface IProgress<T>
    {
        void Report(T value);
    }
}
namespace System
{
    public interface IServiceProvider
    {
        object GetService(Type serviceType);
    }
}
//using System.Runtime.ConstrainedExecution;
//using System.Security;

namespace System
{
    public static class Math
    {
        public const double PI = 3.14159265358979;
        public const double E = 2.71828182845905;

        [SecuritySafeCritical]
        public static double Acos(double d);
        [SecuritySafeCritical]
        public static double Asin(double d);
        [SecuritySafeCritical]
        public static double Atan(double d);
        [SecuritySafeCritical]
        public static double Atan2(double y, double x);
        public static decimal Ceiling(decimal d);
        [SecuritySafeCritical]
        public static double Ceiling(double a);
        [SecuritySafeCritical]
        public static double Cos(double d);
        [SecuritySafeCritical]
        public static double Cosh(double value);
        public static decimal Floor(decimal d);
        [SecuritySafeCritical]
        public static double Floor(double d);
        [SecuritySafeCritical]
        public static double Sin(double a);
        [SecuritySafeCritical]
        public static double Tan(double a);
        [SecuritySafeCritical]
        public static double Sinh(double value);
        [SecuritySafeCritical]
        public static double Tanh(double value);
        [SecuritySafeCritical]
        public static double Round(double a);
        public static double Round(double value, int digits);
        public static double Round(double value, MidpointRounding mode);
        public static double Round(double value, int digits, MidpointRounding mode);
        public static decimal Round(decimal d);
        public static decimal Round(decimal d, int decimals);
        public static decimal Round(decimal d, MidpointRounding mode);
        public static decimal Round(decimal d, int decimals, MidpointRounding mode);
        public static decimal Truncate(decimal d);
        public static double Truncate(double d);
        [SecuritySafeCritical]
        [ReliabilityContract(WillNotCorruptState, Success)]
        public static double Sqrt(double d);
        [SecuritySafeCritical]
        public static double Log(double d);
        [SecuritySafeCritical]
        public static double Log10(double d);
        [SecuritySafeCritical]
        public static double Exp(double d);
        [SecuritySafeCritical]
        public static double Pow(double x, double y);
        public static double IEEERemainder(double x, double y);
        [CLSCompliant(False)]
        public static sbyte Abs(sbyte value);
        public static short Abs(short value);
        public static int Abs(int value);
        public static long Abs(long value);
        [SecuritySafeCritical]
        public static float Abs(float value);
        [SecuritySafeCritical]
        public static double Abs(double value);
        public static decimal Abs(decimal value);
        [ReliabilityContract(WillNotCorruptState, Success)]
        [CLSCompliant(False)]
        public static sbyte Max(sbyte val1, sbyte val2);
        [ReliabilityContract(WillNotCorruptState, Success)]
        public static byte Max(byte val1, byte val2);
        [ReliabilityContract(WillNotCorruptState, Success)]
        public static short Max(short val1, short val2);
        [CLSCompliant(False)]
        [ReliabilityContract(WillNotCorruptState, Success)]
        public static ushort Max(ushort val1, ushort val2);
        [ReliabilityContract(WillNotCorruptState, Success)]
        public static int Max(int val1, int val2);
        [CLSCompliant(False)]
        [ReliabilityContract(WillNotCorruptState, Success)]
        public static uint Max(uint val1, uint val2);
        [ReliabilityContract(WillNotCorruptState, Success)]
        public static long Max(long val1, long val2);
        [CLSCompliant(False)]
        [ReliabilityContract(WillNotCorruptState, Success)]
        public static ulong Max(ulong val1, ulong val2);
        [ReliabilityContract(WillNotCorruptState, Success)]
        public static float Max(float val1, float val2);
        [ReliabilityContract(WillNotCorruptState, Success)]
        public static double Max(double val1, double val2);
        [ReliabilityContract(WillNotCorruptState, Success)]
        public static decimal Max(decimal val1, decimal val2);
        [CLSCompliant(False)]
        [ReliabilityContract(WillNotCorruptState, Success)]
        public static sbyte Min(sbyte val1, sbyte val2);
        [ReliabilityContract(WillNotCorruptState, Success)]
        public static byte Min(byte val1, byte val2);
        [ReliabilityContract(WillNotCorruptState, Success)]
        public static short Min(short val1, short val2);
        [CLSCompliant(False)]
        [ReliabilityContract(WillNotCorruptState, Success)]
        public static ushort Min(ushort val1, ushort val2);
        [ReliabilityContract(WillNotCorruptState, Success)]
        public static int Min(int val1, int val2);
        [ReliabilityContract(WillNotCorruptState, Success)]
        [CLSCompliant(False)]
        public static uint Min(uint val1, uint val2);
        [ReliabilityContract(WillNotCorruptState, Success)]
        public static long Min(long val1, long val2);
        [ReliabilityContract(WillNotCorruptState, Success)]
        [CLSCompliant(False)]
        public static ulong Min(ulong val1, ulong val2);
        [ReliabilityContract(WillNotCorruptState, Success)]
        public static float Min(float val1, float val2);
        [ReliabilityContract(WillNotCorruptState, Success)]
        public static double Min(double val1, double val2);
        [ReliabilityContract(WillNotCorruptState, Success)]
        public static decimal Min(decimal val1, decimal val2);
        public static double Log(double a, double newBase);
        [CLSCompliant(False)]
        public static int Sign(sbyte value);
        public static int Sign(short value);
        public static int Sign(int value);
        public static int Sign(long value);
        public static int Sign(float value);
        public static int Sign(double value);
        public static int Sign(decimal value);
        public static long BigMul(int a, int b);
        public static int DivRem(int a, int b, out int result);
        public static long DivRem(long a, long b, out long result);
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System
{
    [ComVisible(True)]
    public class MemberAccessException : SystemException
    {
        public MemberAccessException();
        public MemberAccessException(string message);
        public MemberAccessException(string message, Exception inner);
        protected MemberAccessException(SerializationInfo info, StreamingContext context);
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System
{
    [ComVisible(True)]
    public class MethodAccessException : MemberAccessException
    {
        public MethodAccessException();
        public MethodAccessException(string message);
        public MethodAccessException(string message, Exception inner);
        protected MethodAccessException(SerializationInfo info, StreamingContext context);
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public enum MidpointRounding
    {
        ToEven = 0,
        AwayFromZero = 1
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System
{
    [ComVisible(True)]
    public class MissingFieldException : MissingMemberException
    {
        public MissingFieldException();
        public MissingFieldException(string message);
        public MissingFieldException(string message, Exception inner);
        protected MissingFieldException(SerializationInfo info, StreamingContext context);
        public MissingFieldException(string className, string fieldName);

        public override string Message { get; }
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;
//using System.Security;

namespace System
{
    [ComVisible(True)]
    public class MissingMemberException : MemberAccessException
    {
        protected string ClassName;
        protected string MemberName;
        protected byte[] Signature;

        public MissingMemberException();
        public MissingMemberException(string message);
        public MissingMemberException(string message, Exception inner);
        protected MissingMemberException(SerializationInfo info, StreamingContext context);
        public MissingMemberException(string className, string memberName);

        public override string Message { get; }

        [SecurityCritical]
        public override void GetObjectData(SerializationInfo info, StreamingContext context);
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System
{
    [ComVisible(True)]
    public class MissingMethodException : MissingMemberException
    {
        public MissingMethodException();
        public MissingMethodException(string message);
        public MissingMethodException(string message, Exception inner);
        protected MissingMethodException(SerializationInfo info, StreamingContext context);
        public MissingMethodException(string className, string methodName);

        public override string Message { get; }
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public sealed class MulticastNotSupportedException : SystemException
    {
        public MulticastNotSupportedException();
        public MulticastNotSupportedException(string message);
        public MulticastNotSupportedException(string message, Exception inner);
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [AttributeUsage(Field, Inherited = False)]
    [ComVisible(True)]
    public sealed class NonSerializedAttribute : Attribute
    {
        public NonSerializedAttribute();
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;
//using System.Security;

namespace System
{
    [ComVisible(True)]
    public class NotFiniteNumberException : ArithmeticException
    {
        public NotFiniteNumberException();
        public NotFiniteNumberException(double offendingNumber);
        public NotFiniteNumberException(string message);
        public NotFiniteNumberException(string message, double offendingNumber);
        public NotFiniteNumberException(string message, Exception innerException);
        public NotFiniteNumberException(string message, double offendingNumber, Exception innerException);
        protected NotFiniteNumberException(SerializationInfo info, StreamingContext context);

        public double OffendingNumber { get; }

        [SecurityCritical]
        public override void GetObjectData(SerializationInfo info, StreamingContext context);
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System
{
    [ComVisible(True)]
    public class NotImplementedException : SystemException
    {
        public NotImplementedException();
        public NotImplementedException(string message);
        public NotImplementedException(string message, Exception inner);
        protected NotImplementedException(SerializationInfo info, StreamingContext context);
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System
{
    [ComVisible(True)]
    public class NotSupportedException : SystemException
    {
        public NotSupportedException();
        public NotSupportedException(string message);
        public NotSupportedException(string message, Exception innerException);
        protected NotSupportedException(SerializationInfo info, StreamingContext context);
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System
{
    [ComVisible(True)]
    public class NullReferenceException : SystemException
    {
        public NullReferenceException();
        public NullReferenceException(string message);
        public NullReferenceException(string message, Exception innerException);
        protected NullReferenceException(SerializationInfo info, StreamingContext context);
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;
//using System.Security;

namespace System
{
    [ComVisible(True)]
    public class ObjectDisposedException : InvalidOperationException
    {
        public ObjectDisposedException(string objectName);
        public ObjectDisposedException(string objectName, string message);
        public ObjectDisposedException(string message, Exception innerException);
        protected ObjectDisposedException(SerializationInfo info, StreamingContext context);

        public override string Message { get; }
        public string ObjectName { get; }

        [SecurityCritical]
        public override void GetObjectData(SerializationInfo info, StreamingContext context);
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    [AttributeUsage(Class, Struct, Enum, Constructor, Method, Property, Field, Event, Interface, Delegate, Inherited = False)]
    public sealed class ObsoleteAttribute : Attribute
    {
        public ObsoleteAttribute();
        public ObsoleteAttribute(string message);
        public ObsoleteAttribute(string message, bool error);

        public string Message { get; }
        public bool IsError { get; }
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;
//using System.Threading;

namespace System
{
    [ComVisible(True)]
    public class OperationCanceledException : SystemException
    {
        public OperationCanceledException();
        public OperationCanceledException(string message);
        public OperationCanceledException(string message, Exception innerException);
        public OperationCanceledException(CancellationToken token);
        public OperationCanceledException(string message, CancellationToken token);
        public OperationCanceledException(string message, Exception innerException, CancellationToken token);
        protected OperationCanceledException(SerializationInfo info, StreamingContext context);

        public CancellationToken CancellationToken { get; }
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System
{
    [ComVisible(True)]
    public class OutOfMemoryException : SystemException
    {
        public OutOfMemoryException();
        public OutOfMemoryException(string message);
        public OutOfMemoryException(string message, Exception innerException);
        protected OutOfMemoryException(SerializationInfo info, StreamingContext context);
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System
{
    [ComVisible(True)]
    public class OverflowException : ArithmeticException
    {
        public OverflowException();
        public OverflowException(string message);
        public OverflowException(string message, Exception innerException);
        protected OverflowException(SerializationInfo info, StreamingContext context);
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [AttributeUsage(Parameter, Inherited = True, AllowMultiple = False)]
    [ComVisible(True)]
    public sealed class ParamArrayAttribute : Attribute
    {
        public ParamArrayAttribute();
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System
{
    [ComVisible(True)]
    public class PlatformNotSupportedException : NotSupportedException
    {
        public PlatformNotSupportedException();
        public PlatformNotSupportedException(string message);
        public PlatformNotSupportedException(string message, Exception inner);
        protected PlatformNotSupportedException(SerializationInfo info, StreamingContext context);
    }
}
namespace System
{
    public class Progress<T> : IProgress<T>
    {
        public Progress();
        public Progress(Action<T> handler);

        public event EventHandler<T> ProgressChanged;

        protected virtual void OnReport(T value);
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public class Random
    {
        public Random();
        public Random(int Seed);

        protected virtual double Sample();
        public virtual int Next();
        public virtual int Next(int minValue, int maxValue);
        public virtual int Next(int maxValue);
        public virtual double NextDouble();
        public virtual void NextBytes(byte[] buffer);
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System
{
    [ComVisible(True)]
    public class RankException : SystemException
    {
        public RankException();
        public RankException(string message);
        public RankException(string message, Exception innerException);
        protected RankException(SerializationInfo info, StreamingContext context);
    }
}
//using System.Globalization;
//using System.Runtime.InteropServices;
//using System.Security;

namespace System
{
    [CLSCompliant(False)]
    [ComVisible(True)]
    public struct SByte : IComparable, IComparable<sbyte>, IConvertible, IEquatable<sbyte>, IFormattable
    {
        public const sbyte MaxValue = 127;
        public const sbyte MinValue = -128;

        public int CompareTo(object obj);
        public int CompareTo(sbyte value);
        public override bool Equals(object obj);
        public bool Equals(sbyte obj);
        public override int GetHashCode();
        [SecuritySafeCritical]
        public override string ToString();
        [SecuritySafeCritical]
        public string ToString(IFormatProvider provider);
        public string ToString(string format);
        public string ToString(string format, IFormatProvider provider);
        [CLSCompliant(False)]
        public static sbyte Parse(string s);
        [CLSCompliant(False)]
        public static sbyte Parse(string s, NumberStyles style);
        [CLSCompliant(False)]
        public static sbyte Parse(string s, IFormatProvider provider);
        [CLSCompliant(False)]
        public static sbyte Parse(string s, NumberStyles style, IFormatProvider provider);
        [CLSCompliant(False)]
        public static bool TryParse(string s, out sbyte result);
        [CLSCompliant(False)]
        public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out sbyte result);
        public TypeCode GetTypeCode();
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    [AttributeUsage(Class, Struct, Enum, Delegate, Inherited = False)]
    public sealed class SerializableAttribute : Attribute
    {
        public SerializableAttribute();
    }
}
//using System.Globalization;
//using System.Runtime.ConstrainedExecution;
//using System.Runtime.InteropServices;
//using System.Security;

namespace System
{
    [ComVisible(True)]
    public struct Single : IComparable, IComparable<float>, IConvertible, IEquatable<float>, IFormattable
    {
        public const float MinValue = -3.402823E+38;
        public const float Epsilon = 1.401298E-45;
        public const float MaxValue = 3.402823E+38;
        public const float PositiveInfinity = InfinityF;
        public const float NegativeInfinity = -InfinityF;
        public const float NaN = NaNF;

        [SecuritySafeCritical]
        public static bool IsInfinity(float f);
        [SecuritySafeCritical]
        public static bool IsPositiveInfinity(float f);
        [SecuritySafeCritical]
        public static bool IsNegativeInfinity(float f);
        [ReliabilityContract(WillNotCorruptState, Success)]
        [SecuritySafeCritical]
        public static bool IsNaN(float f);
        public static bool IsFinite(float f);
        public int CompareTo(object value);
        public int CompareTo(float value);
        public override bool Equals(object obj);
        public bool Equals(float obj);
        [SecuritySafeCritical]
        public override int GetHashCode();
        [SecuritySafeCritical]
        public override string ToString();
        [SecuritySafeCritical]
        public string ToString(IFormatProvider provider);
        [SecuritySafeCritical]
        public string ToString(string format);
        [SecuritySafeCritical]
        public string ToString(string format, IFormatProvider provider);
        public static float Parse(string s);
        public static float Parse(string s, NumberStyles style);
        public static float Parse(string s, IFormatProvider provider);
        public static float Parse(string s, NumberStyles style, IFormatProvider provider);
        public static bool TryParse(string s, out float result);
        public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out float result);
        public TypeCode GetTypeCode();

        public static bool operator ==(float left, float right);
        public static bool operator !=(float left, float right);
        public static bool operator <(float left, float right);
        public static bool operator >(float left, float right);
        public static bool operator <=(float left, float right);
        public static bool operator >=(float left, float right);
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public sealed class StackOverflowException : SystemException
    {
        public StackOverflowException();
        public StackOverflowException(string message);
        public StackOverflowException(string message, Exception innerException);
    }
}
//using System.Collections;
//using System.Collections.Generic;
//using System.Globalization;
//using System.Reflection;
//using System.Runtime.ConstrainedExecution;
//using System.Runtime.InteropServices;
//using System.Security;
//using System.Text;

namespace System
{
    [ComVisible(True)]
    [DefaultMember("Chars")]
    public sealed class String : ICloneable, IEnumerable, IComparable, IComparable<string>, IConvertible, IEquatable<string>, IEnumerable<char>
    {
        public static readonly string Empty;

        [CLSCompliant(False)]
        [SecurityCritical]
        public String(char* value);
        [SecurityCritical]
        [CLSCompliant(False)]
        public String(char* value, int startIndex, int length);
        [CLSCompliant(False)]
        [SecurityCritical]
        public String(sbyte* value);
        [SecurityCritical]
        [CLSCompliant(False)]
        public String(sbyte* value, int startIndex, int length);
        [CLSCompliant(False)]
        [SecurityCritical]
        public String(sbyte* value, int startIndex, int length, Encoding enc);
        [SecuritySafeCritical]
        public String(char[] value, int startIndex, int length);
        [SecuritySafeCritical]
        public String(char[] value);
        [SecuritySafeCritical]
        public String(char c, int count);

        public char this[int index] { get; }
        public int Length { get; }

        public static string Join(string separator, params string[] value);
        [ComVisible(False)]
        public static string Join(string separator, params object[] values);
        [ComVisible(False)]
        public static string Join<T>(string separator, IEnumerable<T> values);
        [ComVisible(False)]
        public static string Join(string separator, IEnumerable<string> values);
        [SecuritySafeCritical]
        public static string Join(string separator, string[] value, int startIndex, int count);
        [ReliabilityContract(WillNotCorruptState, MayFail)]
        public override bool Equals(object obj);
        [ReliabilityContract(WillNotCorruptState, MayFail)]
        public bool Equals(string value);
        [SecuritySafeCritical]
        public bool Equals(string value, StringComparison comparisonType);
        public static bool Equals(string a, string b);
        [SecuritySafeCritical]
        public static bool Equals(string a, string b, StringComparison comparisonType);
        [SecuritySafeCritical]
        public void CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count);
        [SecuritySafeCritical]
        public char[] ToCharArray();
        [SecuritySafeCritical]
        public char[] ToCharArray(int startIndex, int length);
        public static bool IsNullOrEmpty(string value);
        public static bool IsNullOrWhiteSpace(string value);
        [SecuritySafeCritical]
        [ReliabilityContract(WillNotCorruptState, MayFail)]
        public override int GetHashCode();
        public string[] Split(params char[] separator);
        public string[] Split(char[] separator, int count);
        [ComVisible(False)]
        public string[] Split(char[] separator, StringSplitOptions options);
        [ComVisible(False)]
        public string[] Split(char[] separator, int count, StringSplitOptions options);
        [ComVisible(False)]
        public string[] Split(string[] separator, StringSplitOptions options);
        [ComVisible(False)]
        public string[] Split(string[] separator, int count, StringSplitOptions options);
        public string Substring(int startIndex);
        [SecuritySafeCritical]
        public string Substring(int startIndex, int length);
        public string Trim(params char[] trimChars);
        public string TrimStart(params char[] trimChars);
        public string TrimEnd(params char[] trimChars);
        public bool IsNormalized();
        [SecuritySafeCritical]
        public bool IsNormalized(NormalizationForm normalizationForm);
        public string Normalize();
        [SecuritySafeCritical]
        public string Normalize(NormalizationForm normalizationForm);
        public static int Compare(string strA, string strB);
        public static int Compare(string strA, string strB, bool ignoreCase);
        [SecuritySafeCritical]
        public static int Compare(string strA, string strB, StringComparison comparisonType);
        public static int Compare(string strA, string strB, CultureInfo culture, CompareOptions options);
        public static int Compare(string strA, string strB, bool ignoreCase, CultureInfo culture);
        public static int Compare(string strA, int indexA, string strB, int indexB, int length);
        public static int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);
        public static int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, CultureInfo culture);
        public static int Compare(string strA, int indexA, string strB, int indexB, int length, CultureInfo culture, CompareOptions options);
        [SecuritySafeCritical]
        public static int Compare(string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);
        public int CompareTo(object value);
        public int CompareTo(string strB);
        public static int CompareOrdinal(string strA, string strB);
        [SecuritySafeCritical]
        public static int CompareOrdinal(string strA, int indexA, string strB, int indexB, int length);
        public bool Contains(string value);
        public bool EndsWith(string value);
        [SecuritySafeCritical]
        [ComVisible(False)]
        public bool EndsWith(string value, StringComparison comparisonType);
        public bool EndsWith(string value, bool ignoreCase, CultureInfo culture);
        public int IndexOf(char value);
        public int IndexOf(char value, int startIndex);
        public int IndexOfAny(char[] anyOf);
        public int IndexOfAny(char[] anyOf, int startIndex);
        public int IndexOf(string value);
        public int IndexOf(string value, int startIndex);
        public int IndexOf(string value, int startIndex, int count);
        public int IndexOf(string value, StringComparison comparisonType);
        public int IndexOf(string value, int startIndex, StringComparison comparisonType);
        [SecuritySafeCritical]
        public int IndexOf(string value, int startIndex, int count, StringComparison comparisonType);
        public int LastIndexOf(char value);
        public int LastIndexOf(char value, int startIndex);
        public int LastIndexOfAny(char[] anyOf);
        public int LastIndexOfAny(char[] anyOf, int startIndex);
        public int LastIndexOf(string value);
        public int LastIndexOf(string value, int startIndex);
        public int LastIndexOf(string value, int startIndex, int count);
        public int LastIndexOf(string value, StringComparison comparisonType);
        public int LastIndexOf(string value, int startIndex, StringComparison comparisonType);
        [SecuritySafeCritical]
        public int LastIndexOf(string value, int startIndex, int count, StringComparison comparisonType);
        public string PadLeft(int totalWidth);
        public string PadLeft(int totalWidth, char paddingChar);
        public string PadRight(int totalWidth);
        public string PadRight(int totalWidth, char paddingChar);
        public bool StartsWith(string value);
        [SecuritySafeCritical]
        [ComVisible(False)]
        public bool StartsWith(string value, StringComparison comparisonType);
        public bool StartsWith(string value, bool ignoreCase, CultureInfo culture);
        public string ToLower();
        public string ToLower(CultureInfo culture);
        public string ToLowerInvariant();
        public string ToUpper();
        public string ToUpper(CultureInfo culture);
        public string ToUpperInvariant();
        public override string ToString();
        public string ToString(IFormatProvider provider);
        public object Clone();
        public string Trim();
        [SecuritySafeCritical]
        public string Insert(int startIndex, string value);
        public string Replace(char oldChar, char newChar);
        public string Replace(string oldValue, string newValue);
        [SecuritySafeCritical]
        public string Remove(int startIndex, int count);
        public string Remove(int startIndex);
        public static string Format(string format, object arg0);
        public static string Format(string format, object arg0, object arg1);
        public static string Format(string format, object arg0, object arg1, object arg2);
        public static string Format(string format, params object[] args);
        public static string Format(IFormatProvider provider, string format, object arg0);
        public static string Format(IFormatProvider provider, string format, object arg0, object arg1);
        public static string Format(IFormatProvider provider, string format, object arg0, object arg1, object arg2);
        public static string Format(IFormatProvider provider, string format, params object[] args);
        [SecuritySafeCritical]
        public static string Copy(string str);
        public static string Concat(object arg0);
        public static string Concat(object arg0, object arg1);
        public static string Concat(object arg0, object arg1, object arg2);
        [CLSCompliant(False)]
        public static string Concat(object arg0, object arg1, object arg2, object arg3);
        public static string Concat(params object[] args);
        [ComVisible(False)]
        public static string Concat<T>(IEnumerable<T> values);
        [ComVisible(False)]
        public static string Concat(IEnumerable<string> values);
        [SecuritySafeCritical]
        public static string Concat(string str0, string str1);
        [SecuritySafeCritical]
        public static string Concat(string str0, string str1, string str2);
        [SecuritySafeCritical]
        public static string Concat(string str0, string str1, string str2, string str3);
        public static string Concat(params string[] values);
        [SecuritySafeCritical]
        public static string Intern(string str);
        [SecuritySafeCritical]
        public static string IsInterned(string str);
        public TypeCode GetTypeCode();
        public CharEnumerator GetEnumerator();
        public int IndexOf(char value, int startIndex, int count);
        public int IndexOfAny(char[] anyOf, int startIndex, int count);
        public int LastIndexOf(char value, int startIndex, int count);
        public int LastIndexOfAny(char[] anyOf, int startIndex, int count);

        public static bool operator ==(string a, string b);
        public static bool operator !=(string a, string b);
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [Flags]
    [ComVisible(False)]
    public enum StringSplitOptions
    {
        None = 0,
        RemoveEmptyEntries = 1
    }
}
//using System.Collections;
//using System.Collections.Generic;
//using System.Globalization;
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public abstract class StringComparer : IEqualityComparer<string>, IEqualityComparer, IComparer<string>, IComparer
    {
        protected StringComparer();

        public static StringComparer InvariantCulture { get; }
        public static StringComparer InvariantCultureIgnoreCase { get; }
        public static StringComparer CurrentCulture { get; }
        public static StringComparer CurrentCultureIgnoreCase { get; }
        public static StringComparer Ordinal { get; }
        public static StringComparer OrdinalIgnoreCase { get; }

        public static StringComparer Create(CultureInfo culture, bool ignoreCase);
        public int Compare(object x, object y);
        public bool Equals(object x, object y);
        public int GetHashCode(object obj);
        public abstract int Compare(string x, string y);
        public abstract bool Equals(string x, string y);
        public abstract int GetHashCode(string obj);
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System
{
    [ComVisible(True)]
    public class SystemException : Exception
    {
        public SystemException();
        public SystemException(string message);
        public SystemException(string message, Exception innerException);
        protected SystemException(SerializationInfo info, StreamingContext context);
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [AttributeUsage(Method)]
    [ComVisible(True)]
    public sealed class STAThreadAttribute : Attribute
    {
        public STAThreadAttribute();
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [AttributeUsage(Method)]
    [ComVisible(True)]
    public sealed class MTAThreadAttribute : Attribute
    {
        public MTAThreadAttribute();
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [AttributeUsage(Field, Inherited = False)]
    [ComVisible(True)]
    public class ThreadStaticAttribute : Attribute
    {
        public ThreadStaticAttribute();
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System
{
    [ComVisible(True)]
    public class TimeoutException : SystemException
    {
        public TimeoutException();
        public TimeoutException(string message);
        public TimeoutException(string message, Exception innerException);
        protected TimeoutException(SerializationInfo info, StreamingContext context);
    }
}
//using System.Globalization;
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public struct TimeSpan : IComparable, IComparable<TimeSpan>, IEquatable<TimeSpan>, IFormattable
    {
        public const long TicksPerMillisecond = 10000;
        public const long TicksPerSecond = 10000000;
        public const long TicksPerMinute = 600000000;
        public const long TicksPerHour = 36000000000;
        public const long TicksPerDay = 864000000000;
        public static readonly TimeSpan Zero;
        public static readonly TimeSpan MaxValue;
        public static readonly TimeSpan MinValue;

        public TimeSpan(long ticks);
        public TimeSpan(int hours, int minutes, int seconds);
        public TimeSpan(int days, int hours, int minutes, int seconds);
        public TimeSpan(int days, int hours, int minutes, int seconds, int milliseconds);

        public long Ticks { get; }
        public int Days { get; }
        public int Hours { get; }
        public int Milliseconds { get; }
        public int Minutes { get; }
        public int Seconds { get; }
        public double TotalDays { get; }
        public double TotalHours { get; }
        public double TotalMilliseconds { get; }
        public double TotalMinutes { get; }
        public double TotalSeconds { get; }

        public TimeSpan Add(TimeSpan ts);
        public static int Compare(TimeSpan t1, TimeSpan t2);
        public int CompareTo(object value);
        public int CompareTo(TimeSpan value);
        public static TimeSpan FromDays(double value);
        public TimeSpan Duration();
        public override bool Equals(object value);
        public bool Equals(TimeSpan obj);
        public static bool Equals(TimeSpan t1, TimeSpan t2);
        public override int GetHashCode();
        public static TimeSpan FromHours(double value);
        public static TimeSpan FromMilliseconds(double value);
        public static TimeSpan FromMinutes(double value);
        public TimeSpan Negate();
        public static TimeSpan FromSeconds(double value);
        public TimeSpan Subtract(TimeSpan ts);
        public static TimeSpan FromTicks(long value);
        public static TimeSpan Parse(string s);
        public static TimeSpan Parse(string input, IFormatProvider formatProvider);
        public static TimeSpan ParseExact(string input, string format, IFormatProvider formatProvider);
        public static TimeSpan ParseExact(string input, string[] formats, IFormatProvider formatProvider);
        public static TimeSpan ParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles);
        public static TimeSpan ParseExact(string input, string[] formats, IFormatProvider formatProvider, TimeSpanStyles styles);
        public static bool TryParse(string s, out TimeSpan result);
        public static bool TryParse(string input, IFormatProvider formatProvider, out TimeSpan result);
        public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, out TimeSpan result);
        public static bool TryParseExact(string input, string[] formats, IFormatProvider formatProvider, out TimeSpan result);
        public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles, out TimeSpan result);
        public static bool TryParseExact(string input, string[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, out TimeSpan result);
        public override string ToString();
        public string ToString(string format);
        public string ToString(string format, IFormatProvider formatProvider);

        public static TimeSpan operator -(TimeSpan t);
        public static TimeSpan operator -(TimeSpan t1, TimeSpan t2);
        public static TimeSpan operator +(TimeSpan t);
        public static TimeSpan operator +(TimeSpan t1, TimeSpan t2);
        public static bool operator ==(TimeSpan t1, TimeSpan t2);
        public static bool operator !=(TimeSpan t1, TimeSpan t2);
        public static bool operator <(TimeSpan t1, TimeSpan t2);
        public static bool operator <=(TimeSpan t1, TimeSpan t2);
        public static bool operator >(TimeSpan t1, TimeSpan t2);
        public static bool operator >=(TimeSpan t1, TimeSpan t2);
    }
}
//using System.Collections.ObjectModel;
//using System.Runtime.CompilerServices;
//using System.Runtime.Serialization;

namespace System
{
    [TypeForwardedFrom("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")]
    public sealed class TimeZoneInfo : IDeserializationCallback, IEquatable<TimeZoneInfo>, ISerializable
    {
        public TimeSpan BaseUtcOffset { get; }
        public string DaylightName { get; }
        public string DisplayName { get; }
        public string Id { get; }
        public static TimeZoneInfo Local { get; }
        public string StandardName { get; }
        public bool SupportsDaylightSavingTime { get; }
        public static TimeZoneInfo Utc { get; }

        public static TimeZoneInfo FromSerializedString(string source);
        public string ToSerializedString();
        public static void ClearCachedData();
        public static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo destinationTimeZone);
        public static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfo destinationTimeZone);
        public static DateTimeOffset ConvertTime(DateTimeOffset dateTimeOffset, TimeZoneInfo destinationTimeZone);
        public static DateTime ConvertTimeBySystemTimeZoneId(DateTime dateTime, string destinationTimeZoneId);
        public static DateTime ConvertTimeBySystemTimeZoneId(DateTime dateTime, string sourceTimeZoneId, string destinationTimeZoneId);
        public static DateTimeOffset ConvertTimeBySystemTimeZoneId(DateTimeOffset dateTimeOffset, string destinationTimeZoneId);
        public static DateTime ConvertTimeFromUtc(DateTime dateTime, TimeZoneInfo destinationTimeZone);
        public static DateTime ConvertTimeToUtc(DateTime dateTime);
        public static DateTime ConvertTimeToUtc(DateTime dateTime, TimeZoneInfo sourceTimeZone);
        public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName);
        public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules);
        public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime);
        public override bool Equals(object obj);
        public bool Equals(TimeZoneInfo other);
        public static TimeZoneInfo FindSystemTimeZoneById(string id);
        public AdjustmentRule[] GetAdjustmentRules();
        public TimeSpan[] GetAmbiguousTimeOffsets(DateTime dateTime);
        public TimeSpan[] GetAmbiguousTimeOffsets(DateTimeOffset dateTimeOffset);
        public override int GetHashCode();
        public static ReadOnlyCollection<TimeZoneInfo> GetSystemTimeZones();
        public TimeSpan GetUtcOffset(DateTime dateTime);
        public TimeSpan GetUtcOffset(DateTimeOffset dateTimeOffset);
        public bool HasSameRules(TimeZoneInfo other);
        public bool IsAmbiguousTime(DateTime dateTime);
        public bool IsAmbiguousTime(DateTimeOffset dateTimeOffset);
        public bool IsDaylightSavingTime(DateTime dateTime);
        public bool IsDaylightSavingTime(DateTimeOffset dateTimeOffset);
        public bool IsInvalidTime(DateTime dateTime);
        public override string ToString();

        [TypeForwardedFrom("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")]
        public sealed class AdjustmentRule : IDeserializationCallback, IEquatable<AdjustmentRule>, ISerializable
        {
            public DateTime DateStart { get; }
            public DateTime DateEnd { get; }
            public TimeSpan DaylightDelta { get; }
            public TransitionTime DaylightTransitionStart { get; }
            public TransitionTime DaylightTransitionEnd { get; }

            public bool Equals(AdjustmentRule other);
            public override int GetHashCode();
            public static AdjustmentRule CreateAdjustmentRule(DateTime dateStart, DateTime dateEnd, TimeSpan daylightDelta, TransitionTime daylightTransitionStart, TransitionTime daylightTransitionEnd);
        }
        [TypeForwardedFrom("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")]
        public struct TransitionTime : IDeserializationCallback, IEquatable<TransitionTime>, ISerializable
        {
            public DateTime TimeOfDay { get; }
            public int Month { get; }
            public int Week { get; }
            public int Day { get; }
            public DayOfWeek DayOfWeek { get; }
            public bool IsFixedDateRule { get; }

            public override bool Equals(object obj);
            public bool Equals(TransitionTime other);
            public override int GetHashCode();
            public static TransitionTime CreateFixedDateRule(DateTime timeOfDay, int month, int day);
            public static TransitionTime CreateFloatingDateRule(DateTime timeOfDay, int month, int week, DayOfWeek dayOfWeek);

            public static bool operator ==(TransitionTime t1, TransitionTime t2);
            public static bool operator !=(TransitionTime t1, TransitionTime t2);
        }
    }
}
//using System.Runtime.CompilerServices;
//using System.Runtime.Serialization;

namespace System
{
    [TypeForwardedFrom("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")]
    public class TimeZoneNotFoundException : Exception
    {
        public TimeZoneNotFoundException(string message);
        public TimeZoneNotFoundException(string message, Exception innerException);
        protected TimeZoneNotFoundException(SerializationInfo info, StreamingContext context);
        public TimeZoneNotFoundException();
    }
}
//using System.Diagnostics;
//using System.Globalization;
//using System.Reflection;
//using System.Runtime.InteropServices;
//using System.Security;

namespace System
{
    [ComVisible(True)]
    [ClassInterface(None)]
    [ComDefaultInterface(typeof(_Type))]
    public abstract class Type : MemberInfo, IReflect, _Type
    {
        public static readonly MemberFilter FilterAttribute;
        public static readonly MemberFilter FilterName;
        public static readonly MemberFilter FilterNameIgnoreCase;
        public static readonly object Missing;
        public static readonly char Delimiter;
        public static readonly Type[] EmptyTypes;

        protected Type();

        public override MemberTypes MemberType { get; }
        public override Type DeclaringType { get; }
        public virtual MethodBase DeclaringMethod { get; }
        public override Type ReflectedType { get; }
        public virtual StructLayoutAttribute StructLayoutAttribute { get; }
        public abstract Guid GUID { get; }
        public static Binder DefaultBinder { get; }
        public override Module Module { get; }
        public abstract Assembly Assembly { get; }
        public virtual RuntimeTypeHandle TypeHandle { get; }
        public abstract string FullName { get; }
        public abstract string Namespace { get; }
        public abstract string AssemblyQualifiedName { get; }
        public abstract Type BaseType { get; }
        [ComVisible(True)]
        public ConstructorInfo TypeInitializer { get; }
        public bool IsNested { get; }
        public TypeAttributes Attributes { get; }
        public virtual GenericParameterAttributes GenericParameterAttributes { get; }
        public bool IsVisible { get; }
        public bool IsNotPublic { get; }
        public bool IsPublic { get; }
        public bool IsNestedPublic { get; }
        public bool IsNestedPrivate { get; }
        public bool IsNestedFamily { get; }
        public bool IsNestedAssembly { get; }
        public bool IsNestedFamANDAssem { get; }
        public bool IsNestedFamORAssem { get; }
        public bool IsAutoLayout { get; }
        public bool IsLayoutSequential { get; }
        public bool IsExplicitLayout { get; }
        public bool IsClass { get; }
        public bool IsInterface { get; }
        public bool IsValueType { get; }
        public bool IsAbstract { get; }
        public bool IsSealed { get; }
        public virtual bool IsEnum { get; }
        public bool IsSpecialName { get; }
        public bool IsImport { get; }
        public virtual bool IsSerializable { get; }
        public bool IsAnsiClass { get; }
        public bool IsUnicodeClass { get; }
        public bool IsAutoClass { get; }
        public bool IsArray { get; }
        public virtual bool IsGenericType { get; }
        public virtual bool IsGenericTypeDefinition { get; }
        public virtual bool IsConstructedGenericType { get; }
        public virtual bool IsGenericParameter { get; }
        public virtual int GenericParameterPosition { get; }
        public virtual bool ContainsGenericParameters { get; }
        public bool IsByRef { get; }
        public bool IsPointer { get; }
        public bool IsPrimitive { get; }
        public bool IsCOMObject { get; }
        public bool HasElementType { get; }
        public bool IsContextful { get; }
        public bool IsMarshalByRef { get; }
        public virtual Type[] GenericTypeArguments { get; }
        public virtual bool IsSecurityCritical { get; }
        public virtual bool IsSecuritySafeCritical { get; }
        public virtual bool IsSecurityTransparent { get; }
        public abstract Type UnderlyingSystemType { get; }
        public virtual bool IsSZArray { get; }

        public static Type GetType(string typeName, Func<AssemblyName, Assembly> assemblyResolver, Func<Assembly, string, bool, Type> typeResolver);
        public static Type GetType(string typeName, Func<AssemblyName, Assembly> assemblyResolver, Func<Assembly, string, bool, Type> typeResolver, bool throwOnError);
        public static Type GetType(string typeName, Func<AssemblyName, Assembly> assemblyResolver, Func<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase);
        public virtual Type MakePointerType();
        public virtual Type MakeByRefType();
        public virtual Type MakeArrayType();
        public virtual Type MakeArrayType(int rank);
        [SecurityCritical]
        public static Type GetTypeFromProgID(string progID);
        [SecurityCritical]
        public static Type GetTypeFromProgID(string progID, bool throwOnError);
        [SecurityCritical]
        public static Type GetTypeFromProgID(string progID, string server);
        [SecurityCritical]
        public static Type GetTypeFromProgID(string progID, string server, bool throwOnError);
        [SecuritySafeCritical]
        public static Type GetTypeFromCLSID(Guid clsid);
        [SecuritySafeCritical]
        public static Type GetTypeFromCLSID(Guid clsid, bool throwOnError);
        [SecuritySafeCritical]
        public static Type GetTypeFromCLSID(Guid clsid, string server);
        [SecuritySafeCritical]
        public static Type GetTypeFromCLSID(Guid clsid, string server, bool throwOnError);
        public static TypeCode GetTypeCode(Type type);
        protected virtual TypeCode GetTypeCodeImpl();
        public abstract object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters);
        [DebuggerHidden]
        [DebuggerStepThrough]
        public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, CultureInfo culture);
        [DebuggerStepThrough]
        [DebuggerHidden]
        public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args);
        public static RuntimeTypeHandle GetTypeHandle(object o);
        public virtual int GetArrayRank();
        [ComVisible(True)]
        public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
        [ComVisible(True)]
        public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
        [ComVisible(True)]
        public ConstructorInfo GetConstructor(Type[] types);
        protected abstract ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
        [ComVisible(True)]
        public ConstructorInfo[] GetConstructors();
        [ComVisible(True)]
        public abstract ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
        public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
        public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
        public MethodInfo GetMethod(string name, Type[] types, ParameterModifier[] modifiers);
        public MethodInfo GetMethod(string name, Type[] types);
        public MethodInfo GetMethod(string name, BindingFlags bindingAttr);
        public MethodInfo GetMethod(string name);
        protected abstract MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
        public MethodInfo[] GetMethods();
        public abstract MethodInfo[] GetMethods(BindingFlags bindingAttr);
        public abstract FieldInfo GetField(string name, BindingFlags bindingAttr);
        public FieldInfo GetField(string name);
        public FieldInfo[] GetFields();
        public abstract FieldInfo[] GetFields(BindingFlags bindingAttr);
        public Type GetInterface(string name);
        public abstract Type GetInterface(string name, bool ignoreCase);
        public abstract Type[] GetInterfaces();
        public virtual Type[] FindInterfaces(TypeFilter filter, object filterCriteria);
        public EventInfo GetEvent(string name);
        public abstract EventInfo GetEvent(string name, BindingFlags bindingAttr);
        public virtual EventInfo[] GetEvents();
        public abstract EventInfo[] GetEvents(BindingFlags bindingAttr);
        public PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
        public PropertyInfo GetProperty(string name, Type returnType, Type[] types, ParameterModifier[] modifiers);
        public PropertyInfo GetProperty(string name, BindingFlags bindingAttr);
        public PropertyInfo GetProperty(string name, Type returnType, Type[] types);
        public PropertyInfo GetProperty(string name, Type[] types);
        public PropertyInfo GetProperty(string name, Type returnType);
        public PropertyInfo GetProperty(string name);
        protected abstract PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
        public abstract PropertyInfo[] GetProperties(BindingFlags bindingAttr);
        public PropertyInfo[] GetProperties();
        public Type[] GetNestedTypes();
        public abstract Type[] GetNestedTypes(BindingFlags bindingAttr);
        public Type GetNestedType(string name);
        public abstract Type GetNestedType(string name, BindingFlags bindingAttr);
        public MemberInfo[] GetMember(string name);
        public virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
        public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
        public MemberInfo[] GetMembers();
        public abstract MemberInfo[] GetMembers(BindingFlags bindingAttr);
        public virtual MemberInfo[] GetDefaultMembers();
        public virtual MemberInfo[] FindMembers(MemberTypes memberType, BindingFlags bindingAttr, MemberFilter filter, object filterCriteria);
        public virtual Type[] GetGenericParameterConstraints();
        protected virtual bool IsValueTypeImpl();
        protected abstract TypeAttributes GetAttributeFlagsImpl();
        protected abstract bool IsArrayImpl();
        protected abstract bool IsByRefImpl();
        protected abstract bool IsPointerImpl();
        protected abstract bool IsPrimitiveImpl();
        protected abstract bool IsCOMObjectImpl();
        public virtual Type MakeGenericType(params Type[] typeArguments);
        protected virtual bool IsContextfulImpl();
        protected virtual bool IsMarshalByRefImpl();
        public abstract Type GetElementType();
        public virtual Type[] GetGenericArguments();
        public virtual Type GetGenericTypeDefinition();
        protected abstract bool HasElementTypeImpl();
        public virtual string[] GetEnumNames();
        public virtual Array GetEnumValues();
        public virtual Type GetEnumUnderlyingType();
        public virtual bool IsEnumDefined(object value);
        public virtual string GetEnumName(object value);
        [ComVisible(True)]
        public virtual bool IsSubclassOf(Type c);
        public virtual bool IsInstanceOfType(object o);
        public virtual bool IsAssignableFrom(Type c);
        public virtual bool IsEquivalentTo(Type other);
        public override string ToString();
        public static Type[] GetTypeArray(object[] args);
        public override bool Equals(object o);
        public virtual bool Equals(Type o);
        public override int GetHashCode();
        [ComVisible(True)]
        public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
        public Type GetType();
        public static Type GetType(string typeName);
        public static Type GetType(string typeName, bool throwOnError);
        public static Type GetType(string typeName, bool throwOnError, bool ignoreCase);
        public static Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase);
        public static Type GetTypeFromHandle(RuntimeTypeHandle handle);

        public static bool operator ==(Type left, Type right);
        public static bool operator !=(Type left, Type right);
    }
}
//using System.Runtime.Serialization;

namespace System
{
    public class TypeAccessException : TypeLoadException
    {
        public TypeAccessException();
        public TypeAccessException(string message);
        public TypeAccessException(string message, Exception inner);
        protected TypeAccessException(SerializationInfo info, StreamingContext context);
    }
}
//using System.Reflection;
//using System.Runtime.InteropServices;
//using System.Security;

namespace System
{
    [CLSCompliant(False)]
    [ComVisible(True)]
    public struct TypedReference
    {
        [CLSCompliant(False)]
        [SecurityCritical]
        public static TypedReference MakeTypedReference(object target, FieldInfo[] flds);
        public override int GetHashCode();
        public override bool Equals(object o);
        [SecuritySafeCritical]
        public static object ToObject(TypedReference value);
        public static Type GetTargetType(TypedReference value);
        public static RuntimeTypeHandle TargetTypeToken(TypedReference value);
        [SecuritySafeCritical]
        [CLSCompliant(False)]
        public static void SetTypedReference(TypedReference target, object value);
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;
//using System.Security;

namespace System
{
    [ComVisible(True)]
    public sealed class TypeInitializationException : SystemException
    {
        public TypeInitializationException(string fullTypeName, Exception innerException);

        public string TypeName { get; }

        [SecurityCritical]
        public override void GetObjectData(SerializationInfo info, StreamingContext context);
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;
//using System.Security;

namespace System
{
    [ComVisible(True)]
    public class TypeLoadException : SystemException
    {
        public TypeLoadException();
        public TypeLoadException(string message);
        public TypeLoadException(string message, Exception inner);
        protected TypeLoadException(SerializationInfo info, StreamingContext context);

        public override string Message { get; }
        public string TypeName { get; }

        [SecurityCritical]
        public override void GetObjectData(SerializationInfo info, StreamingContext context);
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System
{
    [ComVisible(True)]
    public class TypeUnloadedException : SystemException
    {
        public TypeUnloadedException();
        public TypeUnloadedException(string message);
        public TypeUnloadedException(string message, Exception innerException);
        protected TypeUnloadedException(SerializationInfo info, StreamingContext context);
    }
}
//using System.Globalization;
//using System.Runtime.InteropServices;
//using System.Security;

namespace System
{
    [ComVisible(True)]
    [CLSCompliant(False)]
    public struct UInt16 : IComparable, IComparable<ushort>, IConvertible, IEquatable<ushort>, IFormattable
    {
        public const ushort MaxValue = 65535;
        public const ushort MinValue = 0;

        public int CompareTo(object value);
        public int CompareTo(ushort value);
        public override bool Equals(object obj);
        public bool Equals(ushort obj);
        public override int GetHashCode();
        [SecuritySafeCritical]
        public override string ToString();
        [SecuritySafeCritical]
        public string ToString(IFormatProvider provider);
        [SecuritySafeCritical]
        public string ToString(string format);
        [SecuritySafeCritical]
        public string ToString(string format, IFormatProvider provider);
        [CLSCompliant(False)]
        public static ushort Parse(string s);
        [CLSCompliant(False)]
        public static ushort Parse(string s, NumberStyles style);
        [CLSCompliant(False)]
        public static ushort Parse(string s, IFormatProvider provider);
        [CLSCompliant(False)]
        public static ushort Parse(string s, NumberStyles style, IFormatProvider provider);
        [CLSCompliant(False)]
        public static bool TryParse(string s, out ushort result);
        [CLSCompliant(False)]
        public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out ushort result);
        public TypeCode GetTypeCode();
    }
}
//using System.Globalization;
//using System.Runtime.InteropServices;
//using System.Security;

namespace System
{
    [CLSCompliant(False)]
    [ComVisible(True)]
    public struct UInt32 : IComparable, IComparable<uint>, IConvertible, IEquatable<uint>, IFormattable
    {
        public const uint MaxValue = 4294967295;
        public const uint MinValue = 0;

        public int CompareTo(object value);
        public int CompareTo(uint value);
        public override bool Equals(object obj);
        public bool Equals(uint obj);
        public override int GetHashCode();
        [SecuritySafeCritical]
        public override string ToString();
        [SecuritySafeCritical]
        public string ToString(IFormatProvider provider);
        [SecuritySafeCritical]
        public string ToString(string format);
        [SecuritySafeCritical]
        public string ToString(string format, IFormatProvider provider);
        [CLSCompliant(False)]
        public static uint Parse(string s);
        [CLSCompliant(False)]
        public static uint Parse(string s, NumberStyles style);
        [CLSCompliant(False)]
        public static uint Parse(string s, IFormatProvider provider);
        [CLSCompliant(False)]
        public static uint Parse(string s, NumberStyles style, IFormatProvider provider);
        [CLSCompliant(False)]
        public static bool TryParse(string s, out uint result);
        [CLSCompliant(False)]
        public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out uint result);
        public TypeCode GetTypeCode();
    }
}
//using System.Globalization;
//using System.Runtime.InteropServices;
//using System.Security;

namespace System
{
    [ComVisible(True)]
    [CLSCompliant(False)]
    public struct UInt64 : IComparable, IComparable<ulong>, IConvertible, IEquatable<ulong>, IFormattable
    {
        public const ulong MaxValue = 18446744073709551615;
        public const ulong MinValue = 0;

        public int CompareTo(object value);
        public int CompareTo(ulong value);
        public override bool Equals(object obj);
        public bool Equals(ulong obj);
        public override int GetHashCode();
        [SecuritySafeCritical]
        public override string ToString();
        [SecuritySafeCritical]
        public string ToString(IFormatProvider provider);
        [SecuritySafeCritical]
        public string ToString(string format);
        [SecuritySafeCritical]
        public string ToString(string format, IFormatProvider provider);
        [CLSCompliant(False)]
        public static ulong Parse(string s);
        [CLSCompliant(False)]
        public static ulong Parse(string s, NumberStyles style);
        [CLSCompliant(False)]
        public static ulong Parse(string s, IFormatProvider provider);
        [CLSCompliant(False)]
        public static ulong Parse(string s, NumberStyles style, IFormatProvider provider);
        [CLSCompliant(False)]
        public static bool TryParse(string s, out ulong result);
        [CLSCompliant(False)]
        public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out ulong result);
        public TypeCode GetTypeCode();
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System
{
    [ComVisible(True)]
    public class UnauthorizedAccessException : SystemException
    {
        public UnauthorizedAccessException();
        public UnauthorizedAccessException(string message);
        public UnauthorizedAccessException(string message, Exception inner);
        protected UnauthorizedAccessException(SerializationInfo info, StreamingContext context);
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public class UnhandledExceptionEventArgs : EventArgs
    {
        public UnhandledExceptionEventArgs(object exception, bool isTerminating);

        public object ExceptionObject { get; }
        public bool IsTerminating { get; }
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public delegate void UnhandledExceptionEventHandler(object sender, UnhandledExceptionEventArgs e);
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public sealed class Version : ICloneable, IComparable, IComparable<Version>, IEquatable<Version>
    {
        public Version(int major, int minor, int build, int revision);
        public Version(int major, int minor, int build);
        public Version(int major, int minor);
        public Version(string version);
        public Version();

        public int Major { get; }
        public int Minor { get; }
        public int Build { get; }
        public int Revision { get; }
        public short MajorRevision { get; }
        public short MinorRevision { get; }

        public object Clone();
        public int CompareTo(object version);
        public int CompareTo(Version value);
        public override bool Equals(object obj);
        public bool Equals(Version obj);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(int fieldCount);
        public static Version Parse(string input);
        public static bool TryParse(string input, out Version result);

        public static bool operator ==(Version v1, Version v2);
        public static bool operator !=(Version v1, Version v2);
        public static bool operator <(Version v1, Version v2);
        public static bool operator <=(Version v1, Version v2);
        public static bool operator >(Version v1, Version v2);
        public static bool operator >=(Version v1, Version v2);
    }
}
//using System.Collections.Generic;
//using System.Configuration.Assemblies;
//using System.Globalization;
//using System.Reflection;
//using System.Reflection.Emit;
//using System.Runtime.ConstrainedExecution;
//using System.Runtime.ExceptionServices;
//using System.Runtime.InteropServices;
//using System.Runtime.Remoting;
//using System.Security;
//using System.Security.Policy;
//using System.Security.Principal;

namespace System
{
    [ClassInterface(None)]
    [ComDefaultInterface(typeof(_AppDomain))]
    [ComVisible(True)]
    public sealed class AppDomain : MarshalByRefObject, IEvidenceFactory, _AppDomain
    {
        public AppDomainSetup SetupInformation { get; }
        [MonoTODO]
        public ApplicationTrust ApplicationTrust { get; }
        public string BaseDirectory { get; }
        public string RelativeSearchPath { get; }
        public string DynamicDirectory { get; }
        public bool ShadowCopyFiles { get; }
        public string FriendlyName { get; }
        public Evidence Evidence { get; }
        public PermissionSet PermissionSet { get; }
        public static AppDomain CurrentDomain { get; }
        [MonoTODO]
        public bool IsHomogenous { get; }
        [MonoTODO]
        public bool IsFullyTrusted { get; }
        public AppDomainManager DomainManager { get; }
        public ActivationContext ActivationContext { get; }
        public ApplicationIdentity ApplicationIdentity { get; }
        public int Id { get; }
        [MonoTODO("Currently always returns false")]
        public static bool MonitoringIsEnabled { get; set; }
        [MonoTODO]
        public long MonitoringSurvivedMemorySize { get; }
        [MonoTODO]
        public static long MonitoringSurvivedProcessMemorySize { get; }
        [MonoTODO]
        public long MonitoringTotalAllocatedMemorySize { get; }
        [MonoTODO]
        public TimeSpan MonitoringTotalProcessorTime { get; }

        public event AssemblyLoadEventHandler AssemblyLoad;
        public event ResolveEventHandler AssemblyResolve;
        public event EventHandler DomainUnload;
        public event EventHandler ProcessExit;
        public event ResolveEventHandler ResourceResolve;
        public event ResolveEventHandler TypeResolve;
        public event UnhandledExceptionEventHandler UnhandledException;
        public event EventHandler<FirstChanceExceptionEventArgs> FirstChanceException;
        public event ResolveEventHandler ReflectionOnlyAssemblyResolve;

        [SecurityCritical]
        [Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")]
        public void AppendPrivatePath(string path);
        [SecurityCritical]
        [Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")]
        public void ClearPrivatePath();
        [SecurityCritical]
        [Obsolete("Use AppDomainSetup.ShadowCopyDirectories")]
        public void ClearShadowCopyPath();
        public ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName);
        public ObjectHandle CreateComInstanceFrom(string assemblyFile, string typeName, byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
        public ObjectHandle CreateInstance(string assemblyName, string typeName);
        public ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes);
        [Obsolete("Use an overload that does not take an Evidence parameter")]
        public ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes, Evidence securityAttributes);
        public object CreateInstanceAndUnwrap(string assemblyName, string typeName);
        public object CreateInstanceAndUnwrap(string assemblyName, string typeName, object[] activationAttributes);
        [Obsolete("Use an overload that does not take an Evidence parameter")]
        public object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes, Evidence securityAttributes);
        public ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes);
        public object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes);
        public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes);
        public object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes);
        public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName);
        public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes);
        [Obsolete("Use an overload that does not take an Evidence parameter")]
        public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes, Evidence securityAttributes);
        public object CreateInstanceFromAndUnwrap(string assemblyName, string typeName);
        public object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, object[] activationAttributes);
        [Obsolete("Use an overload that does not take an Evidence parameter")]
        public object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes, Evidence securityAttributes);
        [SecuritySafeCritical]
        public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access);
        [SecuritySafeCritical]
        [Obsolete("Declarative security for assembly level is no longer enforced")]
        public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, Evidence evidence);
        [SecuritySafeCritical]
        public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir);
        [SecuritySafeCritical]
        [Obsolete("Declarative security for assembly level is no longer enforced")]
        public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence);
        [SecuritySafeCritical]
        [Obsolete("Declarative security for assembly level is no longer enforced")]
        public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions);
        [Obsolete("Declarative security for assembly level is no longer enforced")]
        [SecuritySafeCritical]
        public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions);
        [Obsolete("Declarative security for assembly level is no longer enforced")]
        [SecuritySafeCritical]
        public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions);
        [Obsolete("Declarative security for assembly level is no longer enforced")]
        [SecuritySafeCritical]
        public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions);
        [SecuritySafeCritical]
        [Obsolete("Declarative security for assembly level is no longer enforced")]
        public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions, bool isSynchronized);
        [Obsolete("Declarative security for assembly level is no longer enforced")]
        public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions, bool isSynchronized, IEnumerable<CustomAttributeBuilder> assemblyAttributes);
        public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, IEnumerable<CustomAttributeBuilder> assemblyAttributes);
        public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, bool isSynchronized, IEnumerable<CustomAttributeBuilder> assemblyAttributes);
        [MonoLimitation("The argument securityContextSource is ignored")]
        public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, IEnumerable<CustomAttributeBuilder> assemblyAttributes, SecurityContextSource securityContextSource);
        public void DoCallBack(CrossAppDomainDelegate callBackDelegate);
        public int ExecuteAssembly(string assemblyFile);
        [Obsolete("Use an overload that does not take an Evidence parameter")]
        public int ExecuteAssembly(string assemblyFile, Evidence assemblySecurity);
        [Obsolete("Use an overload that does not take an Evidence parameter")]
        public int ExecuteAssembly(string assemblyFile, Evidence assemblySecurity, string[] args);
        [Obsolete("Use an overload that does not take an Evidence parameter")]
        public int ExecuteAssembly(string assemblyFile, Evidence assemblySecurity, string[] args, byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
        public int ExecuteAssembly(string assemblyFile, string[] args);
        public int ExecuteAssembly(string assemblyFile, string[] args, byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
        public Assembly[] GetAssemblies();
        [SecuritySafeCritical]
        public object GetData(string name);
        public Type GetType();
        [SecurityCritical]
        public override object InitializeLifetimeService();
        [SecuritySafeCritical]
        public Assembly Load(AssemblyName assemblyRef);
        [Obsolete("Use an overload that does not take an Evidence parameter")]
        [SecuritySafeCritical]
        public Assembly Load(AssemblyName assemblyRef, Evidence assemblySecurity);
        [SecuritySafeCritical]
        public Assembly Load(string assemblyString);
        [Obsolete("Use an overload that does not take an Evidence parameter")]
        [SecuritySafeCritical]
        public Assembly Load(string assemblyString, Evidence assemblySecurity);
        [SecuritySafeCritical]
        public Assembly Load(byte[] rawAssembly);
        [SecuritySafeCritical]
        public Assembly Load(byte[] rawAssembly, byte[] rawSymbolStore);
        [SecuritySafeCritical]
        [Obsolete("Use an overload that does not take an Evidence parameter")]
        public Assembly Load(byte[] rawAssembly, byte[] rawSymbolStore, Evidence securityEvidence);
        [SecurityCritical]
        [Obsolete("AppDomain policy levels are obsolete")]
        public void SetAppDomainPolicy(PolicyLevel domainPolicy);
        [SecurityCritical]
        [Obsolete("Use AppDomainSetup.SetCachePath")]
        public void SetCachePath(string path);
        [SecuritySafeCritical]
        public void SetPrincipalPolicy(PrincipalPolicy policy);
        [Obsolete("Use AppDomainSetup.ShadowCopyFiles")]
        public void SetShadowCopyFiles();
        [Obsolete("Use AppDomainSetup.ShadowCopyDirectories")]
        [SecurityCritical]
        public void SetShadowCopyPath(string path);
        [SecuritySafeCritical]
        public void SetThreadPrincipal(IPrincipal principal);
        public static AppDomain CreateDomain(string friendlyName);
        public static AppDomain CreateDomain(string friendlyName, Evidence securityInfo);
        [MonoLimitation("Currently it does not allow the setup in the other domain")]
        public static AppDomain CreateDomain(string friendlyName, Evidence securityInfo, AppDomainSetup info);
        public static AppDomain CreateDomain(string friendlyName, Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);
        public static AppDomain CreateDomain(string friendlyName, Evidence securityInfo, AppDomainSetup info, PermissionSet grantSet, params StrongName[] fullTrustAssemblies);
        public bool IsFinalizingForUnload();
        [ReliabilityContract(MayCorruptAppDomain, MayFail)]
        public static void Unload(AppDomain domain);
        [SecurityCritical]
        public void SetData(string name, object data);
        [MonoLimitation("The permission field is ignored")]
        public void SetData(string name, object data, IPermission permission);
        [Obsolete("Use AppDomainSetup.DynamicBase")]
        public void SetDynamicBase(string path);
        [Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.'")]
        public static int GetCurrentThreadId();
        [SecuritySafeCritical]
        public override string ToString();
        [ComVisible(False)]
        [MonoTODO("This routine only returns the parameter currently")]
        public string ApplyPolicy(string assemblyName);
        public static AppDomain CreateDomain(string friendlyName, Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);
        public int ExecuteAssemblyByName(string assemblyName);
        [Obsolete("Use an overload that does not take an Evidence parameter")]
        public int ExecuteAssemblyByName(string assemblyName, Evidence assemblySecurity);
        [Obsolete("Use an overload that does not take an Evidence parameter")]
        public int ExecuteAssemblyByName(string assemblyName, Evidence assemblySecurity, params string[] args);
        [Obsolete("Use an overload that does not take an Evidence parameter")]
        public int ExecuteAssemblyByName(AssemblyName assemblyName, Evidence assemblySecurity, params string[] args);
        public int ExecuteAssemblyByName(string assemblyName, params string[] args);
        public int ExecuteAssemblyByName(AssemblyName assemblyName, params string[] args);
        public bool IsDefaultAppDomain();
        public Assembly[] ReflectionOnlyGetAssemblies();
        public bool? IsCompatibilitySwitchSet(string value);
    }
}
//using System.Collections;
//using System.Runtime.InteropServices;
//using System.Security;

namespace System
{
    [ComVisible(True)]
    public static class Environment
    {
        public static string CommandLine { get; }
        public static string CurrentDirectory { get; set; }
        public static int CurrentManagedThreadId { get; }
        public static int ExitCode { get; set; }
        public static bool HasShutdownStarted { get; }
        public static string MachineName { get; }
        public static string NewLine { get; }
        public static OperatingSystem OSVersion { get; }
        public static string StackTrace { get; }
        public static string SystemDirectory { get; }
        public static int TickCount { get; }
        public static string UserDomainName { get; }
        [MonoTODO("Currently always returns false, regardless of interactive state")]
        public static bool UserInteractive { get; }
        public static string UserName { get; }
        public static Version Version { get; }
        [MonoTODO("Currently always returns zero")]
        public static long WorkingSet { get; }
        public static bool Is64BitOperatingSystem { get; }
        public static int SystemPageSize { get; }
        public static bool Is64BitProcess { get; }
        public static int ProcessorCount { get; }

        public static void Exit(int exitCode);
        public static string ExpandEnvironmentVariables(string name);
        public static string[] GetCommandLineArgs();
        public static string GetEnvironmentVariable(string variable);
        public static IDictionary GetEnvironmentVariables();
        public static string GetFolderPath(SpecialFolder folder);
        public static string GetFolderPath(SpecialFolder folder, SpecialFolderOption option);
        public static string[] GetLogicalDrives();
        public static string GetEnvironmentVariable(string variable, EnvironmentVariableTarget target);
        public static IDictionary GetEnvironmentVariables(EnvironmentVariableTarget target);
        public static void SetEnvironmentVariable(string variable, string value);
        public static void SetEnvironmentVariable(string variable, string value, EnvironmentVariableTarget target);
        public static void FailFast(string message);
        [SecurityCritical]
        public static void FailFast(string message, Exception exception);

        [ComVisible(True)]
        public enum SpecialFolder
        {
            MyDocuments = 5,
            Desktop = 0,
            MyComputer = 17,
            Programs = 2,
            Personal = 5,
            Favorites = 6,
            Startup = 7,
            Recent = 8,
            SendTo = 9,
            StartMenu = 11,
            MyMusic = 13,
            DesktopDirectory = 16,
            Templates = 21,
            ApplicationData = 26,
            LocalApplicationData = 28,
            InternetCache = 32,
            Cookies = 33,
            History = 34,
            CommonApplicationData = 35,
            System = 37,
            ProgramFiles = 38,
            MyPictures = 39,
            CommonProgramFiles = 43,
            MyVideos = 14,
            NetworkShortcuts = 19,
            Fonts = 20,
            CommonStartMenu = 22,
            CommonPrograms = 23,
            CommonStartup = 24,
            CommonDesktopDirectory = 25,
            PrinterShortcuts = 27,
            Windows = 36,
            UserProfile = 40,
            SystemX86 = 41,
            ProgramFilesX86 = 42,
            CommonProgramFilesX86 = 44,
            CommonTemplates = 45,
            CommonDocuments = 46,
            CommonAdminTools = 47,
            AdminTools = 48,
            CommonMusic = 53,
            CommonPictures = 54,
            CommonVideos = 55,
            Resources = 56,
            LocalizedResources = 57,
            CommonOemLinks = 58,
            CDBurning = 59
        }
        public enum SpecialFolderOption
        {
            None = 0,
            DoNotVerify = 16384,
            Create = 32768
        }
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System
{
    [ComVisible(False)]
    public sealed class ActivationContext : IDisposable, ISerializable
    {
        ~ActivationContext();

        public ContextForm Form { get; }
        public ApplicationIdentity Identity { get; }
        public byte[] ApplicationManifestBytes { get; }
        public byte[] DeploymentManifestBytes { get; }

        [MonoTODO("Missing validation")]
        public static ActivationContext CreatePartialActivationContext(ApplicationIdentity identity);
        [MonoTODO("Missing validation")]
        public static ActivationContext CreatePartialActivationContext(ApplicationIdentity identity, string[] manifestPaths);
        public void Dispose();

        public enum ContextForm
        {
            Loose = 0,
            StoreBounded = 1
        }
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public delegate void AppDomainInitializer(string[] args);
}
//using System.Reflection;
//using System.Runtime.Hosting;
//using System.Runtime.InteropServices;
//using System.Security;
//using System.Security.Policy;
//using System.Threading;

namespace System
{
    [ComVisible(True)]
    public class AppDomainManager : MarshalByRefObject
    {
        public AppDomainManager();

        public virtual ApplicationActivator ApplicationActivator { get; }
        public virtual Assembly EntryAssembly { get; }
        [MonoTODO]
        public virtual HostExecutionContextManager HostExecutionContextManager { get; }
        public virtual HostSecurityManager HostSecurityManager { get; }
        public AppDomainManagerInitializationOptions InitializationFlags { get; set; }

        public virtual AppDomain CreateDomain(string friendlyName, Evidence securityInfo, AppDomainSetup appDomainInfo);
        public virtual void InitializeNewDomain(AppDomainSetup appDomainInfo);
        public virtual bool CheckSecuritySettings(SecurityState state);
        protected static AppDomain CreateDomainHelper(string friendlyName, Evidence securityInfo, AppDomainSetup appDomainInfo);
    }
}
//using System.Collections.Generic;
//using System.Runtime.Hosting;
//using System.Runtime.InteropServices;
//using System.Security;
//using System.Security.Policy;

namespace System
{
    [ClassInterface(None)]
    [ComVisible(True)]
    public sealed class AppDomainSetup : IAppDomainSetup
    {
        public AppDomainSetup();
        public AppDomainSetup(ActivationArguments activationArguments);
        public AppDomainSetup(ActivationContext activationContext);

        public string ApplicationBase { get; set; }
        public string ApplicationName { get; set; }
        public string CachePath { get; set; }
        public string ConfigurationFile { get; set; }
        public bool DisallowPublisherPolicy { get; set; }
        public string DynamicBase { get; set; }
        public string LicenseFile { get; set; }
        [MonoLimitation("In Mono this is controlled by the --share-code flag")]
        public LoaderOptimization LoaderOptimization { get; set; }
        public string PrivateBinPath { get; set; }
        public string PrivateBinPathProbe { get; set; }
        public string ShadowCopyDirectories { get; set; }
        public string ShadowCopyFiles { get; set; }
        public bool DisallowBindingRedirects { get; set; }
        public bool DisallowCodeDownload { get; set; }
        public string TargetFrameworkName { get; set; }
        public ActivationArguments ActivationArguments { get; set; }
        [MonoLimitation("it needs to be invoked within the created domain")]
        public AppDomainInitializer AppDomainInitializer { get; set; }
        [MonoLimitation("it needs to be used to invoke the initializer within the created domain")]
        public string[] AppDomainInitializerArguments { get; set; }
        [MonoNotSupported("This property exists but not considered.")]
        public ApplicationTrust ApplicationTrust { get; set; }
        [MonoNotSupported("This property exists but not considered.")]
        public bool DisallowApplicationBaseProbing { get; set; }
        public string AppDomainManagerAssembly { get; set; }
        public string AppDomainManagerType { get; set; }
        public string[] PartialTrustVisibleAssemblies { get; set; }
        public bool SandboxInterop { get; set; }

        [MonoNotSupported("This method exists but not considered.")]
        public byte[] GetConfigurationBytes();
        [MonoNotSupported("This method exists but not considered.")]
        public void SetConfigurationBytes(byte[] value);
        [MonoTODO("not implemented, does not throw because it's used in testing moonlight")]
        public void SetCompatibilitySwitches(IEnumerable<string> switches);
        [SecurityCritical]
        public void SetNativeFunction(string functionName, int functionVersion, IntPtr functionPointer);
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System
{
    [ComVisible(False)]
    public sealed class ApplicationIdentity : ISerializable
    {
        public ApplicationIdentity(string applicationIdentityFullName);

        public string CodeBase { get; }
        public string FullName { get; }

        public override string ToString();
    }
}
namespace System
{
    public struct ArgIterator
    {
        public ArgIterator(RuntimeArgumentHandle arglist);
        [CLSCompliant(False)]
        public ArgIterator(RuntimeArgumentHandle arglist, void* ptr);

        public void End();
        public override bool Equals(object o);
        public override int GetHashCode();
        [CLSCompliant(False)]
        public TypedReference GetNextArg();
        [CLSCompliant(False)]
        public TypedReference GetNextArg(RuntimeTypeHandle rth);
        public RuntimeTypeHandle GetNextArgType();
        public int GetRemainingCount();
    }
}
//using System.Reflection;
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public class AssemblyLoadEventArgs : EventArgs
    {
        public AssemblyLoadEventArgs(Assembly loadedAssembly);

        public Assembly LoadedAssembly { get; }
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public delegate void AssemblyLoadEventHandler(object sender, AssemblyLoadEventArgs args);
}
//using System.IO;
//using System.Text;

namespace System
{
    public static class Console
    {
        public static TextWriter Error { get; }
        public static TextWriter Out { get; }
        public static TextReader In { get; }
        public static Encoding InputEncoding { get; set; }
        public static Encoding OutputEncoding { get; set; }
        public static ConsoleColor BackgroundColor { get; set; }
        public static int BufferHeight { get; set; }
        public static int BufferWidth { get; set; }
        [MonoLimitation("Implemented only on Windows")]
        public static bool CapsLock { get; }
        public static int CursorLeft { get; set; }
        public static int CursorTop { get; set; }
        public static int CursorSize { get; set; }
        public static bool CursorVisible { get; set; }
        public static ConsoleColor ForegroundColor { get; set; }
        public static bool KeyAvailable { get; }
        public static int LargestWindowHeight { get; }
        public static int LargestWindowWidth { get; }
        [MonoLimitation("Only works on windows")]
        public static bool NumberLock { get; }
        public static string Title { get; set; }
        public static bool TreatControlCAsInput { get; set; }
        [MonoLimitation("Only works on windows")]
        public static int WindowHeight { get; set; }
        [MonoLimitation("Only works on windows")]
        public static int WindowLeft { get; set; }
        [MonoLimitation("Only works on windows")]
        public static int WindowTop { get; set; }
        [MonoLimitation("Only works on windows")]
        public static int WindowWidth { get; set; }
        public static bool IsErrorRedirected { get; }
        public static bool IsOutputRedirected { get; }
        public static bool IsInputRedirected { get; }

        public static event ConsoleCancelEventHandler CancelKeyPress;

        public static Stream OpenStandardError();
        public static Stream OpenStandardError(int bufferSize);
        public static Stream OpenStandardInput();
        public static Stream OpenStandardInput(int bufferSize);
        public static Stream OpenStandardOutput();
        public static Stream OpenStandardOutput(int bufferSize);
        public static void SetError(TextWriter newError);
        public static void SetIn(TextReader newIn);
        public static void SetOut(TextWriter newOut);
        public static void Write(bool value);
        public static void Write(char value);
        public static void Write(char[] buffer);
        public static void Write(decimal value);
        public static void Write(double value);
        public static void Write(int value);
        public static void Write(long value);
        public static void Write(object value);
        public static void Write(float value);
        public static void Write(string value);
        [CLSCompliant(False)]
        public static void Write(uint value);
        [CLSCompliant(False)]
        public static void Write(ulong value);
        public static void Write(string format, object arg0);
        public static void Write(string format, params object[] arg);
        public static void Write(char[] buffer, int index, int count);
        public static void Write(string format, object arg0, object arg1);
        public static void Write(string format, object arg0, object arg1, object arg2);
        [CLSCompliant(False)]
        public static void Write(string format, object arg0, object arg1, object arg2, object arg3);
        public static void WriteLine();
        public static void WriteLine(bool value);
        public static void WriteLine(char value);
        public static void WriteLine(char[] buffer);
        public static void WriteLine(decimal value);
        public static void WriteLine(double value);
        public static void WriteLine(int value);
        public static void WriteLine(long value);
        public static void WriteLine(object value);
        public static void WriteLine(float value);
        public static void WriteLine(string value);
        [CLSCompliant(False)]
        public static void WriteLine(uint value);
        [CLSCompliant(False)]
        public static void WriteLine(ulong value);
        public static void WriteLine(string format, object arg0);
        public static void WriteLine(string format, params object[] arg);
        public static void WriteLine(char[] buffer, int index, int count);
        public static void WriteLine(string format, object arg0, object arg1);
        public static void WriteLine(string format, object arg0, object arg1, object arg2);
        [CLSCompliant(False)]
        public static void WriteLine(string format, object arg0, object arg1, object arg2, object arg3);
        public static int Read();
        public static string ReadLine();
        public static void Beep();
        public static void Beep(int frequency, int duration);
        public static void Clear();
        [MonoLimitation("Implemented only on Windows")]
        public static void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop);
        [MonoLimitation("Implemented only on Windows")]
        public static void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor);
        public static ConsoleKeyInfo ReadKey();
        public static ConsoleKeyInfo ReadKey(bool intercept);
        public static void ResetColor();
        [MonoLimitation("Only works on windows")]
        public static void SetBufferSize(int width, int height);
        public static void SetCursorPosition(int left, int top);
        public static void SetWindowPosition(int left, int top);
        public static void SetWindowSize(int width, int height);
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public delegate void CrossAppDomainDelegate();
}
//using System.Reflection;
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;
//using System.Security;

namespace System
{
    [ComVisible(True)]
    [ClassInterface(AutoDual)]
    public abstract class Delegate : ICloneable, ISerializable
    {
        protected Delegate(object target, string method);
        protected Delegate(Type target, string method);

        public MethodInfo Method { get; }
        public object Target { get; }

        public static Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method, bool throwOnBindFailure);
        public static Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method);
        public static Delegate CreateDelegate(Type type, MethodInfo method, bool throwOnBindFailure);
        public static Delegate CreateDelegate(Type type, MethodInfo method);
        public static Delegate CreateDelegate(Type type, object target, string method);
        public static Delegate CreateDelegate(Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);
        public static Delegate CreateDelegate(Type type, Type target, string method);
        public static Delegate CreateDelegate(Type type, Type target, string method, bool ignoreCase);
        public static Delegate CreateDelegate(Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);
        public static Delegate CreateDelegate(Type type, object target, string method, bool ignoreCase);
        public object DynamicInvoke(params object[] args);
        protected virtual object DynamicInvokeImpl(object[] args);
        public virtual object Clone();
        public override bool Equals(object obj);
        public override int GetHashCode();
        protected virtual MethodInfo GetMethodImpl();
        [SecurityCritical]
        public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
        public virtual Delegate[] GetInvocationList();
        public static Delegate Combine(Delegate a, Delegate b);
        [ComVisible(True)]
        public static Delegate Combine(params Delegate[] delegates);
        protected virtual Delegate CombineImpl(Delegate d);
        public static Delegate Remove(Delegate source, Delegate value);
        protected virtual Delegate RemoveImpl(Delegate d);
        public static Delegate RemoveAll(Delegate source, Delegate value);

        public static bool operator ==(Delegate d1, Delegate d2);
        public static bool operator !=(Delegate d1, Delegate d2);
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [Flags]
    [ComVisible(True)]
    public enum AppDomainManagerInitializationOptions
    {
        None = 0,
        RegisterWithHost = 1
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public enum EnvironmentVariableTarget
    {
        Process = 0,
        User = 1,
        Machine = 2
    }
}
//using System.Runtime.ConstrainedExecution;
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System
{
    [ComVisible(True)]
    public struct IntPtr : ISerializable
    {
        public static readonly IntPtr Zero;

        [ReliabilityContract(MayCorruptInstance, MayFail)]
        public IntPtr(int value);
        [ReliabilityContract(MayCorruptInstance, MayFail)]
        public IntPtr(long value);
        [ReliabilityContract(MayCorruptInstance, MayFail)]
        [CLSCompliant(False)]
        public IntPtr(void* value);

        public static int Size { get; }

        public override bool Equals(object obj);
        public override int GetHashCode();
        [ReliabilityContract(WillNotCorruptState, Success)]
        public int ToInt32();
        [ReliabilityContract(WillNotCorruptState, Success)]
        public long ToInt64();
        [CLSCompliant(False)]
        [ReliabilityContract(WillNotCorruptState, Success)]
        public void* ToPointer();
        public override string ToString();
        public string ToString(string format);
        [ReliabilityContract(MayCorruptInstance, MayFail)]
        public static IntPtr Add(IntPtr pointer, int offset);
        [ReliabilityContract(MayCorruptInstance, MayFail)]
        public static IntPtr Subtract(IntPtr pointer, int offset);

        [ReliabilityContract(WillNotCorruptState, Success)]
        public static bool operator ==(IntPtr value1, IntPtr value2);
        [ReliabilityContract(WillNotCorruptState, Success)]
        public static bool operator !=(IntPtr value1, IntPtr value2);
        [ReliabilityContract(MayCorruptInstance, MayFail)]
        public static IntPtr operator +(IntPtr pointer, int offset);
        [ReliabilityContract(MayCorruptInstance, MayFail)]
        public static IntPtr operator -(IntPtr pointer, int offset);

        [ReliabilityContract(MayCorruptInstance, MayFail)]
        public static explicit operator IntPtr(int value);
        [ReliabilityContract(MayCorruptInstance, MayFail)]
        public static explicit operator IntPtr(long value);
        [ReliabilityContract(MayCorruptInstance, MayFail)]
        [CLSCompliant(False)]
        public static explicit operator IntPtr(void* value);
        public static explicit operator int(IntPtr value);
        public static explicit operator long(IntPtr value);
        [CLSCompliant(False)]
        public static explicit operator void*(IntPtr value);
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Remoting;

namespace System
{
    [ComVisible(True)]
    public abstract class MarshalByRefObject
    {
        protected MarshalByRefObject();

        public virtual ObjRef CreateObjRef(Type requestedType);
        public object GetLifetimeService();
        public virtual object InitializeLifetimeService();
        protected MarshalByRefObject MemberwiseClone(bool cloneIdentity);
    }
}
//using System.Runtime.ConstrainedExecution;
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public struct ModuleHandle
    {
        public static readonly ModuleHandle EmptyHandle;

        public int MDStreamVersion { get; }

        public RuntimeFieldHandle ResolveFieldHandle(int fieldToken);
        public RuntimeMethodHandle ResolveMethodHandle(int methodToken);
        public RuntimeTypeHandle ResolveTypeHandle(int typeToken);
        public RuntimeTypeHandle ResolveTypeHandle(int typeToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
        public RuntimeMethodHandle ResolveMethodHandle(int methodToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
        public RuntimeFieldHandle ResolveFieldHandle(int fieldToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
        public RuntimeFieldHandle GetRuntimeFieldHandleFromMetadataToken(int fieldToken);
        public RuntimeMethodHandle GetRuntimeMethodHandleFromMetadataToken(int methodToken);
        public RuntimeTypeHandle GetRuntimeTypeHandleFromMetadataToken(int typeToken);
        [ReliabilityContract(WillNotCorruptState, Success)]
        public override bool Equals(object obj);
        [ReliabilityContract(WillNotCorruptState, Success)]
        public bool Equals(ModuleHandle handle);
        public override int GetHashCode();

        public static bool operator ==(ModuleHandle left, ModuleHandle right);
        public static bool operator !=(ModuleHandle left, ModuleHandle right);
    }
}
//using System.Reflection;
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;
//using System.Security;

namespace System
{
    [ComVisible(True)]
    public abstract class MulticastDelegate : Delegate
    {
        protected MulticastDelegate(object target, string method);
        protected MulticastDelegate(Type target, string method);

        [SecurityCritical]
        public override void GetObjectData(SerializationInfo info, StreamingContext context);
        protected sealed override object DynamicInvokeImpl(object[] args);
        public sealed override bool Equals(object obj);
        public sealed override int GetHashCode();
        protected override MethodInfo GetMethodImpl();
        public sealed override Delegate[] GetInvocationList();
        protected sealed override Delegate CombineImpl(Delegate follow);
        protected sealed override Delegate RemoveImpl(Delegate value);

        public static bool operator ==(MulticastDelegate d1, MulticastDelegate d2);
        public static bool operator !=(MulticastDelegate d1, MulticastDelegate d2);
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public static class Nullable
    {
        public static int Compare<T>(T? n1, T? n2) where T : struct;
        public static bool Equals<T>(T? n1, T? n2) where T : struct;
        public static Type GetUnderlyingType(Type nullableType);
    }
}
//using System.Diagnostics;

namespace System
{
    [DebuggerStepThrough]
    public struct Nullable<T> where T : struct
    {
        public Nullable(T value);

        public bool HasValue { get; }
        public T Value { get; }

        public override bool Equals(object other);
        public override int GetHashCode();
        public T GetValueOrDefault();
        public T GetValueOrDefault(T defaultValue);
        public override string ToString();

        public static implicit operator T?(T value);
        public static explicit operator T(T? value);
    }
}
//using System.Runtime.ConstrainedExecution;
//using System.Runtime.InteropServices;

namespace System
{
    [ClassInterface(AutoDual)]
    [ComVisible(True)]
    public class Object
    {
        [ReliabilityContract(WillNotCorruptState, MayFail)]
        public Object();

        [ReliabilityContract(WillNotCorruptState, Success)]
        protected virtual void Finalize();

        public virtual bool Equals(object obj);
        public static bool Equals(object objA, object objB);
        public virtual int GetHashCode();
        public Type GetType();
        protected object MemberwiseClone();
        public virtual string ToString();
        [ReliabilityContract(WillNotCorruptState, Success)]
        public static bool ReferenceEquals(object objA, object objB);
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;
//using System.Security;

namespace System
{
    [ComVisible(True)]
    public sealed class OperatingSystem : ICloneable, ISerializable
    {
        public OperatingSystem(PlatformID platform, Version version);

        public PlatformID Platform { get; }
        public Version Version { get; }
        public string ServicePack { get; }
        public string VersionString { get; }

        public object Clone();
        [SecurityCritical]
        public void GetObjectData(SerializationInfo info, StreamingContext context);
        public override string ToString();
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public enum PlatformID
    {
        Win32S = 0,
        Win32Windows = 1,
        Win32NT = 2,
        WinCE = 3,
        Unix = 4,
        Xbox = 5,
        MacOSX = 6
    }
}
//using System.Reflection;
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public class ResolveEventArgs : EventArgs
    {
        public ResolveEventArgs(string name);
        public ResolveEventArgs(string name, Assembly requestingAssembly);

        public string Name { get; }
        public Assembly RequestingAssembly { get; }
    }
}
//using System.Reflection;
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public delegate Assembly ResolveEventHandler(object sender, ResolveEventArgs args);
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public struct RuntimeArgumentHandle
    {
    }
}
//using System.Runtime.ConstrainedExecution;
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;
//using System.Security;

namespace System
{
    [ComVisible(True)]
    public struct RuntimeFieldHandle : ISerializable
    {
        public IntPtr Value { get; }

        [SecurityCritical]
        public void GetObjectData(SerializationInfo info, StreamingContext context);
        [ReliabilityContract(WillNotCorruptState, Success)]
        public override bool Equals(object obj);
        [ReliabilityContract(WillNotCorruptState, Success)]
        public bool Equals(RuntimeFieldHandle handle);
        public override int GetHashCode();

        public static bool operator ==(RuntimeFieldHandle left, RuntimeFieldHandle right);
        public static bool operator !=(RuntimeFieldHandle left, RuntimeFieldHandle right);
    }
}
//using System.Runtime.ConstrainedExecution;
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;
//using System.Security;

namespace System
{
    [ComVisible(True)]
    public struct RuntimeMethodHandle : ISerializable
    {
        public IntPtr Value { get; }

        [SecurityCritical]
        public void GetObjectData(SerializationInfo info, StreamingContext context);
        public IntPtr GetFunctionPointer();
        [ReliabilityContract(WillNotCorruptState, Success)]
        public override bool Equals(object obj);
        [ReliabilityContract(WillNotCorruptState, Success)]
        public bool Equals(RuntimeMethodHandle handle);
        public override int GetHashCode();

        public static bool operator ==(RuntimeMethodHandle left, RuntimeMethodHandle right);
        public static bool operator !=(RuntimeMethodHandle left, RuntimeMethodHandle right);
    }
}
//using System.Runtime.ConstrainedExecution;
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;
//using System.Security;

namespace System
{
    [ComVisible(True)]
    public struct RuntimeTypeHandle : ISerializable
    {
        public IntPtr Value { get; }

        [SecurityCritical]
        public void GetObjectData(SerializationInfo info, StreamingContext context);
        [ReliabilityContract(WillNotCorruptState, Success)]
        public override bool Equals(object obj);
        [ReliabilityContract(WillNotCorruptState, Success)]
        public bool Equals(RuntimeTypeHandle handle);
        public override int GetHashCode();
        [ReliabilityContract(WillNotCorruptState, Success)]
        [CLSCompliant(False)]
        public ModuleHandle GetModuleHandle();

        public static bool operator ==(RuntimeTypeHandle left, object right);
        public static bool operator !=(RuntimeTypeHandle left, object right);
        public static bool operator ==(object left, RuntimeTypeHandle right);
        public static bool operator !=(object left, RuntimeTypeHandle right);
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public enum StringComparison
    {
        CurrentCulture = 0,
        CurrentCultureIgnoreCase = 1,
        InvariantCulture = 2,
        InvariantCultureIgnoreCase = 3,
        Ordinal = 4,
        OrdinalIgnoreCase = 5
    }
}
//using System.Globalization;
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public abstract class TimeZone
    {
        protected TimeZone();

        public static TimeZone CurrentTimeZone { get; }
        public abstract string DaylightName { get; }
        public abstract string StandardName { get; }

        public abstract DaylightTime GetDaylightChanges(int year);
        public abstract TimeSpan GetUtcOffset(DateTime time);
        public virtual bool IsDaylightSavingTime(DateTime time);
        public static bool IsDaylightSavingTime(DateTime time, DaylightTime daylightTimes);
        public virtual DateTime ToLocalTime(DateTime time);
        public virtual DateTime ToUniversalTime(DateTime time);
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public enum TypeCode
    {
        Empty = 0,
        Object = 1,
        DBNull = 2,
        Boolean = 3,
        Char = 4,
        SByte = 5,
        Byte = 6,
        Int16 = 7,
        UInt16 = 8,
        Int32 = 9,
        UInt32 = 10,
        Int64 = 11,
        UInt64 = 12,
        Single = 13,
        Double = 14,
        Decimal = 15,
        DateTime = 16,
        String = 18
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System
{
    [CLSCompliant(False)]
    [ComVisible(True)]
    public struct UIntPtr : ISerializable
    {
        public static readonly UIntPtr Zero;

        public UIntPtr(ulong value);
        public UIntPtr(uint value);
        [CLSCompliant(False)]
        public UIntPtr(void* value);

        public static int Size { get; }

        public override bool Equals(object obj);
        public override int GetHashCode();
        public uint ToUInt32();
        public ulong ToUInt64();
        [CLSCompliant(False)]
        public void* ToPointer();
        public override string ToString();
        public static UIntPtr Add(UIntPtr pointer, int offset);
        public static UIntPtr Subtract(UIntPtr pointer, int offset);

        public static bool operator ==(UIntPtr value1, UIntPtr value2);
        public static bool operator !=(UIntPtr value1, UIntPtr value2);
        public static UIntPtr operator +(UIntPtr pointer, int offset);
        public static UIntPtr operator -(UIntPtr pointer, int offset);

        public static explicit operator ulong(UIntPtr value);
        public static explicit operator uint(UIntPtr value);
        public static explicit operator UIntPtr(ulong value);
        [CLSCompliant(False)]
        public static explicit operator UIntPtr(void* value);
        [CLSCompliant(False)]
        public static explicit operator void*(UIntPtr value);
        public static explicit operator UIntPtr(uint value);
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public abstract class ValueType
    {
        protected ValueType();

        public override bool Equals(object obj);
        public override int GetHashCode();
        public override string ToString();
    }
}
//using System.Runtime.InteropServices;

namespace System
{
    [ComVisible(True)]
    public struct Void
    {
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;
//using System.Security;

namespace System
{
    [ComVisible(True)]
    public class WeakReference : ISerializable
    {
        public WeakReference(object target);
        public WeakReference(object target, bool trackResurrection);
        protected WeakReference(SerializationInfo info, StreamingContext context);

        ~WeakReference();

        public virtual bool IsAlive { get; }
        public virtual object Target { get; set; }
        public virtual bool TrackResurrection { get; }

        [SecurityCritical]
        public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    }
}
//using System.Runtime.Serialization;
//using System.Security;

namespace System
{
    public sealed class WeakReference<T> : ISerializable where T : class
    {
        public WeakReference(T target);
        public WeakReference(T target, bool trackResurrection);

        ~WeakReference();

        [SecurityCritical]
        public void GetObjectData(SerializationInfo info, StreamingContext context);
        public void SetTarget(T target);
        public bool TryGetTarget(out T target);
    }
}
//using System.Runtime.InteropServices;

namespace System.Deployment.Internal
{
    [ComVisible(False)]
    public static class InternalActivationContextHelper
    {
        [MonoTODO]
        public static object GetActivationContextData(ActivationContext appInfo);
        [MonoTODO]
        public static object GetApplicationComponentManifest(ActivationContext appInfo);
        [MonoTODO("2.0 SP1 member")]
        public static byte[] GetApplicationManifestBytes(ActivationContext appInfo);
        [MonoTODO]
        public static object GetDeploymentComponentManifest(ActivationContext appInfo);
        [MonoTODO("2.0 SP1 member")]
        public static byte[] GetDeploymentManifestBytes(ActivationContext appInfo);
        [MonoTODO]
        public static bool IsFirstRun(ActivationContext appInfo);
        [MonoTODO]
        public static void PrepareForExecution(ActivationContext appInfo);
    }
}
//using System.Runtime.InteropServices;

namespace System.Deployment.Internal
{
    [ComVisible(False)]
    public static class InternalApplicationIdentityHelper
    {
        [MonoTODO]
        public static object GetInternalAppId(ApplicationIdentity id);
    }
}
//using System.Runtime.InteropServices;

namespace System.Configuration.Assemblies
{
    [Obsolete]
    [ComVisible(True)]
    public struct AssemblyHash : ICloneable
    {
        [Obsolete]
        public static readonly AssemblyHash Empty;

        [Obsolete]
        public AssemblyHash(AssemblyHashAlgorithm algorithm, byte[] value);
        [Obsolete]
        public AssemblyHash(byte[] value);

        [Obsolete]
        public AssemblyHashAlgorithm Algorithm { get; set; }

        [Obsolete]
        public object Clone();
        [Obsolete]
        public byte[] GetValue();
        [Obsolete]
        public void SetValue(byte[] value);
    }
}
//using System.Runtime.InteropServices;

namespace System.Configuration.Assemblies
{
    [ComVisible(True)]
    public enum AssemblyHashAlgorithm
    {
        None = 0,
        MD5 = 32771,
        SHA1 = 32772,
        SHA256 = 32780,
        SHA384 = 32781,
        SHA512 = 32782
    }
}
//using System.Runtime.InteropServices;

namespace System.Configuration.Assemblies
{
    [ComVisible(True)]
    public enum AssemblyVersionCompatibility
    {
        SameMachine = 1,
        SameProcess = 2,
        SameDomain = 3
    }
}
//using System.Runtime.InteropServices;
//using System.Security;

namespace System.Text
{
    [ComVisible(True)]
    public class ASCIIEncoding : Encoding
    {
        public ASCIIEncoding();

        [ComVisible(False)]
        public override bool IsSingleByte { get; }

        [SecuritySafeCritical]
        public override int GetByteCount(char[] chars, int index, int count);
        [SecuritySafeCritical]
        public override int GetByteCount(string chars);
        [SecurityCritical]
        [CLSCompliant(False)]
        [ComVisible(False)]
        public override int GetByteCount(char* chars, int count);
        [SecuritySafeCritical]
        public override int GetBytes(string chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
        [SecuritySafeCritical]
        public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
        [CLSCompliant(False)]
        [ComVisible(False)]
        [SecurityCritical]
        public override int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
        [SecuritySafeCritical]
        public override int GetCharCount(byte[] bytes, int index, int count);
        [CLSCompliant(False)]
        [SecurityCritical]
        [ComVisible(False)]
        public override int GetCharCount(byte* bytes, int count);
        [SecuritySafeCritical]
        public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
        [ComVisible(False)]
        [SecurityCritical]
        [CLSCompliant(False)]
        public override int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
        [SecuritySafeCritical]
        public override string GetString(byte[] bytes, int byteIndex, int byteCount);
        public override int GetMaxByteCount(int charCount);
        public override int GetMaxCharCount(int byteCount);
        [ComVisible(False)]
        public override Decoder GetDecoder();
        [ComVisible(False)]
        public override Encoder GetEncoder();
    }
}
//using System.Runtime.InteropServices;
//using System.Security;

namespace System.Text
{
    [ComVisible(True)]
    public abstract class Decoder
    {
        protected Decoder();

        [ComVisible(False)]
        public DecoderFallback Fallback { get; set; }
        [ComVisible(False)]
        public DecoderFallbackBuffer FallbackBuffer { get; }

        [ComVisible(False)]
        public virtual void Reset();
        public abstract int GetCharCount(byte[] bytes, int index, int count);
        [ComVisible(False)]
        public virtual int GetCharCount(byte[] bytes, int index, int count, bool flush);
        [ComVisible(False)]
        [SecurityCritical]
        [CLSCompliant(False)]
        public virtual int GetCharCount(byte* bytes, int count, bool flush);
        public abstract int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
        public virtual int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, bool flush);
        [CLSCompliant(False)]
        [SecurityCritical]
        [ComVisible(False)]
        public virtual int GetChars(byte* bytes, int byteCount, char* chars, int charCount, bool flush);
        [ComVisible(False)]
        public virtual void Convert(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, int charCount, bool flush, out int bytesUsed, out int charsUsed, out bool completed);
        [SecurityCritical]
        [CLSCompliant(False)]
        [ComVisible(False)]
        public virtual void Convert(byte* bytes, int byteCount, char* chars, int charCount, bool flush, out int bytesUsed, out int charsUsed, out bool completed);
    }
}
namespace System.Text
{
    public sealed class DecoderExceptionFallback : DecoderFallback
    {
        public DecoderExceptionFallback();

        public override int MaxCharCount { get; }

        public override DecoderFallbackBuffer CreateFallbackBuffer();
        public override bool Equals(object value);
        public override int GetHashCode();
    }
}
namespace System.Text
{
    public sealed class DecoderExceptionFallbackBuffer : DecoderFallbackBuffer
    {
        public DecoderExceptionFallbackBuffer();

        public override int Remaining { get; }

        public override bool Fallback(byte[] bytesUnknown, int index);
        public override char GetNextChar();
        public override bool MovePrevious();
    }
}
namespace System.Text
{
    public sealed class DecoderFallbackException : ArgumentException
    {
        public DecoderFallbackException();
        public DecoderFallbackException(string message);
        public DecoderFallbackException(string message, Exception innerException);
        public DecoderFallbackException(string message, byte[] bytesUnknown, int index);

        public byte[] BytesUnknown { get; }
        public int Index { get; }
    }
}
namespace System.Text
{
    public abstract class DecoderFallback
    {
        protected DecoderFallback();

        public static DecoderFallback ReplacementFallback { get; }
        public static DecoderFallback ExceptionFallback { get; }
        public abstract int MaxCharCount { get; }

        public abstract DecoderFallbackBuffer CreateFallbackBuffer();
    }
}
namespace System.Text
{
    public abstract class DecoderFallbackBuffer
    {
        protected DecoderFallbackBuffer();

        public abstract int Remaining { get; }

        public abstract bool Fallback(byte[] bytesUnknown, int index);
        public abstract char GetNextChar();
        public abstract bool MovePrevious();
        public virtual void Reset();
    }
}
namespace System.Text
{
    public sealed class DecoderReplacementFallback : DecoderFallback
    {
        public DecoderReplacementFallback();
        public DecoderReplacementFallback(string replacement);

        public string DefaultString { get; }
        public override int MaxCharCount { get; }

        public override DecoderFallbackBuffer CreateFallbackBuffer();
        public override bool Equals(object value);
        public override int GetHashCode();
    }
}
//using System.Security;

namespace System.Text
{
    public sealed class DecoderReplacementFallbackBuffer : DecoderFallbackBuffer
    {
        public DecoderReplacementFallbackBuffer(DecoderReplacementFallback fallback);

        public override int Remaining { get; }

        public override bool Fallback(byte[] bytesUnknown, int index);
        public override char GetNextChar();
        public override bool MovePrevious();
        [SecuritySafeCritical]
        public override void Reset();
    }
}
//using System.Runtime.InteropServices;
//using System.Security;

namespace System.Text
{
    [ComVisible(True)]
    public abstract class Encoder
    {
        protected Encoder();

        [ComVisible(False)]
        public EncoderFallback Fallback { get; set; }
        [ComVisible(False)]
        public EncoderFallbackBuffer FallbackBuffer { get; }

        [ComVisible(False)]
        public virtual void Reset();
        public abstract int GetByteCount(char[] chars, int index, int count, bool flush);
        [SecurityCritical]
        [CLSCompliant(False)]
        [ComVisible(False)]
        public virtual int GetByteCount(char* chars, int count, bool flush);
        public abstract int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, bool flush);
        [ComVisible(False)]
        [CLSCompliant(False)]
        [SecurityCritical]
        public virtual int GetBytes(char* chars, int charCount, byte* bytes, int byteCount, bool flush);
        [ComVisible(False)]
        public virtual void Convert(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, int byteCount, bool flush, out int charsUsed, out int bytesUsed, out bool completed);
        [CLSCompliant(False)]
        [SecurityCritical]
        [ComVisible(False)]
        public virtual void Convert(char* chars, int charCount, byte* bytes, int byteCount, bool flush, out int charsUsed, out int bytesUsed, out bool completed);
    }
}
namespace System.Text
{
    public sealed class EncoderExceptionFallback : EncoderFallback
    {
        public EncoderExceptionFallback();

        public override int MaxCharCount { get; }

        public override EncoderFallbackBuffer CreateFallbackBuffer();
        public override bool Equals(object value);
        public override int GetHashCode();
    }
}
namespace System.Text
{
    public sealed class EncoderExceptionFallbackBuffer : EncoderFallbackBuffer
    {
        public EncoderExceptionFallbackBuffer();

        public override int Remaining { get; }

        public override bool Fallback(char charUnknown, int index);
        public override bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
        public override char GetNextChar();
        public override bool MovePrevious();
    }
}
namespace System.Text
{
    public sealed class EncoderFallbackException : ArgumentException
    {
        public EncoderFallbackException();
        public EncoderFallbackException(string message);
        public EncoderFallbackException(string message, Exception innerException);

        public char CharUnknown { get; }
        public char CharUnknownHigh { get; }
        public char CharUnknownLow { get; }
        public int Index { get; }

        public bool IsUnknownSurrogate();
    }
}
namespace System.Text
{
    public abstract class EncoderFallback
    {
        protected EncoderFallback();

        public static EncoderFallback ReplacementFallback { get; }
        public static EncoderFallback ExceptionFallback { get; }
        public abstract int MaxCharCount { get; }

        public abstract EncoderFallbackBuffer CreateFallbackBuffer();
    }
}
namespace System.Text
{
    public abstract class EncoderFallbackBuffer
    {
        protected EncoderFallbackBuffer();

        public abstract int Remaining { get; }

        public abstract bool Fallback(char charUnknown, int index);
        public abstract bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
        public abstract char GetNextChar();
        public abstract bool MovePrevious();
        public virtual void Reset();
    }
}
namespace System.Text
{
    public sealed class EncoderReplacementFallback : EncoderFallback
    {
        public EncoderReplacementFallback();
        public EncoderReplacementFallback(string replacement);

        public string DefaultString { get; }
        public override int MaxCharCount { get; }

        public override EncoderFallbackBuffer CreateFallbackBuffer();
        public override bool Equals(object value);
        public override int GetHashCode();
    }
}
//using System.Security;

namespace System.Text
{
    public sealed class EncoderReplacementFallbackBuffer : EncoderFallbackBuffer
    {
        public EncoderReplacementFallbackBuffer(EncoderReplacementFallback fallback);

        public override int Remaining { get; }

        public override bool Fallback(char charUnknown, int index);
        public override bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
        public override char GetNextChar();
        public override bool MovePrevious();
        [SecuritySafeCritical]
        public override void Reset();
    }
}
//using System.Runtime.InteropServices;
//using System.Security;

namespace System.Text
{
    [ComVisible(True)]
    public abstract class Encoding : ICloneable
    {
        protected Encoding();
        protected Encoding(int codePage);
        protected Encoding(int codePage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);

        public virtual string BodyName { get; }
        public virtual string EncodingName { get; }
        public virtual string HeaderName { get; }
        public virtual string WebName { get; }
        public virtual int WindowsCodePage { get; }
        public virtual bool IsBrowserDisplay { get; }
        public virtual bool IsBrowserSave { get; }
        public virtual bool IsMailNewsDisplay { get; }
        public virtual bool IsMailNewsSave { get; }
        [ComVisible(False)]
        public virtual bool IsSingleByte { get; }
        [ComVisible(False)]
        public EncoderFallback EncoderFallback { get; set; }
        [ComVisible(False)]
        public DecoderFallback DecoderFallback { get; set; }
        [ComVisible(False)]
        public bool IsReadOnly { get; }
        public static Encoding ASCII { get; }
        public virtual int CodePage { get; }
        public static Encoding Default { get; }
        public static Encoding Unicode { get; }
        public static Encoding BigEndianUnicode { get; }
        public static Encoding UTF7 { get; }
        public static Encoding UTF8 { get; }
        public static Encoding UTF32 { get; }

        public static byte[] Convert(Encoding srcEncoding, Encoding dstEncoding, byte[] bytes);
        public static byte[] Convert(Encoding srcEncoding, Encoding dstEncoding, byte[] bytes, int index, int count);
        [SecurityCritical]
        public static void RegisterProvider(EncodingProvider provider);
        [SecuritySafeCritical]
        public static Encoding GetEncoding(int codepage);
        public static Encoding GetEncoding(int codepage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
        public static Encoding GetEncoding(string name);
        public static Encoding GetEncoding(string name, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
        public static EncodingInfo[] GetEncodings();
        public virtual byte[] GetPreamble();
        [ComVisible(False)]
        public virtual object Clone();
        public virtual int GetByteCount(char[] chars);
        public virtual int GetByteCount(string s);
        public abstract int GetByteCount(char[] chars, int index, int count);
        [SecurityCritical]
        [ComVisible(False)]
        [CLSCompliant(False)]
        public virtual int GetByteCount(char* chars, int count);
        public virtual byte[] GetBytes(char[] chars);
        public virtual byte[] GetBytes(char[] chars, int index, int count);
        public abstract int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
        public virtual byte[] GetBytes(string s);
        public virtual int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex);
        [ComVisible(False)]
        [SecurityCritical]
        [CLSCompliant(False)]
        public virtual int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
        public virtual int GetCharCount(byte[] bytes);
        public abstract int GetCharCount(byte[] bytes, int index, int count);
        [CLSCompliant(False)]
        [ComVisible(False)]
        [SecurityCritical]
        public virtual int GetCharCount(byte* bytes, int count);
        public virtual char[] GetChars(byte[] bytes);
        public virtual char[] GetChars(byte[] bytes, int index, int count);
        public abstract int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
        [ComVisible(False)]
        [CLSCompliant(False)]
        [SecurityCritical]
        public virtual int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
        [CLSCompliant(False)]
        [SecurityCritical]
        [ComVisible(False)]
        public string GetString(byte* bytes, int byteCount);
        [ComVisible(False)]
        public bool IsAlwaysNormalized();
        [ComVisible(False)]
        public virtual bool IsAlwaysNormalized(NormalizationForm form);
        public virtual Decoder GetDecoder();
        public virtual Encoder GetEncoder();
        public abstract int GetMaxByteCount(int charCount);
        public abstract int GetMaxCharCount(int byteCount);
        public virtual string GetString(byte[] bytes);
        public virtual string GetString(byte[] bytes, int index, int count);
        public override bool Equals(object value);
        public override int GetHashCode();
    }
}
namespace System.Text
{
    public sealed class EncodingInfo
    {
        public int CodePage { get; }
        public string Name { get; }
        public string DisplayName { get; }

        public Encoding GetEncoding();
        public override bool Equals(object value);
        public override int GetHashCode();
    }
}
//using System.Runtime.InteropServices;

namespace System.Text
{
    [ComVisible(True)]
    public abstract class EncodingProvider
    {
        public EncodingProvider();

        public abstract Encoding GetEncoding(string name);
        public abstract Encoding GetEncoding(int codepage);
        public virtual Encoding GetEncoding(string name, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
        public virtual Encoding GetEncoding(int codepage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    }
}
//using System.Reflection;
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;
//using System.Security;

namespace System.Text
{
    [DefaultMember("Chars")]
    [ComVisible(True)]
    public sealed class StringBuilder : ISerializable
    {
        public StringBuilder();
        public StringBuilder(int capacity);
        public StringBuilder(string value);
        public StringBuilder(string value, int capacity);
        [SecuritySafeCritical]
        public StringBuilder(string value, int startIndex, int length, int capacity);
        public StringBuilder(int capacity, int maxCapacity);

        public char this[int index] { get; set; }
        public int Capacity { get; set; }
        public int MaxCapacity { get; }
        public int Length { get; set; }

        public int EnsureCapacity(int capacity);
        [SecuritySafeCritical]
        public override string ToString();
        [SecuritySafeCritical]
        public string ToString(int startIndex, int length);
        public StringBuilder Clear();
        public StringBuilder Append(char value, int repeatCount);
        [SecuritySafeCritical]
        public StringBuilder Append(char[] value, int startIndex, int charCount);
        [SecuritySafeCritical]
        public StringBuilder Append(string value);
        [SecuritySafeCritical]
        public StringBuilder Append(string value, int startIndex, int count);
        [ComVisible(False)]
        public StringBuilder AppendLine();
        [ComVisible(False)]
        public StringBuilder AppendLine(string value);
        [ComVisible(False)]
        [SecuritySafeCritical]
        public void CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count);
        [SecuritySafeCritical]
        public StringBuilder Insert(int index, string value, int count);
        public StringBuilder Remove(int startIndex, int length);
        public StringBuilder Append(bool value);
        [CLSCompliant(False)]
        public StringBuilder Append(sbyte value);
        public StringBuilder Append(byte value);
        public StringBuilder Append(char value);
        public StringBuilder Append(short value);
        public StringBuilder Append(int value);
        public StringBuilder Append(long value);
        public StringBuilder Append(float value);
        public StringBuilder Append(double value);
        public StringBuilder Append(decimal value);
        [CLSCompliant(False)]
        public StringBuilder Append(ushort value);
        [CLSCompliant(False)]
        public StringBuilder Append(uint value);
        [CLSCompliant(False)]
        public StringBuilder Append(ulong value);
        public StringBuilder Append(object value);
        [SecuritySafeCritical]
        public StringBuilder Append(char[] value);
        [SecuritySafeCritical]
        public StringBuilder Insert(int index, string value);
        public StringBuilder Insert(int index, bool value);
        [CLSCompliant(False)]
        public StringBuilder Insert(int index, sbyte value);
        public StringBuilder Insert(int index, byte value);
        public StringBuilder Insert(int index, short value);
        [SecuritySafeCritical]
        public StringBuilder Insert(int index, char value);
        public StringBuilder Insert(int index, char[] value);
        [SecuritySafeCritical]
        public StringBuilder Insert(int index, char[] value, int startIndex, int charCount);
        public StringBuilder Insert(int index, int value);
        public StringBuilder Insert(int index, long value);
        public StringBuilder Insert(int index, float value);
        public StringBuilder Insert(int index, double value);
        public StringBuilder Insert(int index, decimal value);
        [CLSCompliant(False)]
        public StringBuilder Insert(int index, ushort value);
        [CLSCompliant(False)]
        public StringBuilder Insert(int index, uint value);
        [CLSCompliant(False)]
        public StringBuilder Insert(int index, ulong value);
        public StringBuilder Insert(int index, object value);
        public StringBuilder AppendFormat(string format, object arg0);
        public StringBuilder AppendFormat(string format, object arg0, object arg1);
        public StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2);
        public StringBuilder AppendFormat(string format, params object[] args);
        public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0);
        public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0, object arg1);
        public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0, object arg1, object arg2);
        public StringBuilder AppendFormat(IFormatProvider provider, string format, params object[] args);
        public StringBuilder Replace(string oldValue, string newValue);
        public bool Equals(StringBuilder sb);
        public StringBuilder Replace(string oldValue, string newValue, int startIndex, int count);
        public StringBuilder Replace(char oldChar, char newChar);
        public StringBuilder Replace(char oldChar, char newChar, int startIndex, int count);
        [CLSCompliant(False)]
        [SecurityCritical]
        public StringBuilder Append(char* value, int valueCount);
    }
}
//using System.Runtime.InteropServices;
//using System.Security;

namespace System.Text
{
    [ComVisible(True)]
    public class UnicodeEncoding : Encoding
    {
        public const int CharSize = 2;

        public UnicodeEncoding();
        public UnicodeEncoding(bool bigEndian, bool byteOrderMark);
        public UnicodeEncoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);

        [SecuritySafeCritical]
        public override int GetByteCount(char[] chars, int index, int count);
        [SecuritySafeCritical]
        public override int GetByteCount(string s);
        [SecurityCritical]
        [CLSCompliant(False)]
        [ComVisible(False)]
        public override int GetByteCount(char* chars, int count);
        [SecuritySafeCritical]
        public override int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex);
        [SecuritySafeCritical]
        public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
        [ComVisible(False)]
        [SecurityCritical]
        [CLSCompliant(False)]
        public override int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
        [SecuritySafeCritical]
        public override int GetCharCount(byte[] bytes, int index, int count);
        [SecurityCritical]
        [CLSCompliant(False)]
        [ComVisible(False)]
        public override int GetCharCount(byte* bytes, int count);
        [SecuritySafeCritical]
        public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
        [SecurityCritical]
        [CLSCompliant(False)]
        [ComVisible(False)]
        public override int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
        [ComVisible(False)]
        [SecuritySafeCritical]
        public override string GetString(byte[] bytes, int index, int count);
        [ComVisible(False)]
        public override Encoder GetEncoder();
        public override System.Text.Decoder GetDecoder();
        public override byte[] GetPreamble();
        public override int GetMaxByteCount(int charCount);
        public override int GetMaxCharCount(int byteCount);
        public override bool Equals(object value);
        public override int GetHashCode();
    }
}
//using System.Security;

namespace System.Text
{
    public sealed class UTF32Encoding : Encoding
    {
        public UTF32Encoding();
        public UTF32Encoding(bool bigEndian, bool byteOrderMark);
        public UTF32Encoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters);

        [SecuritySafeCritical]
        public override int GetByteCount(char[] chars, int index, int count);
        [SecuritySafeCritical]
        public override int GetByteCount(string s);
        [SecurityCritical]
        [CLSCompliant(False)]
        public override int GetByteCount(char* chars, int count);
        [SecuritySafeCritical]
        public override int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex);
        [SecuritySafeCritical]
        public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
        [CLSCompliant(False)]
        [SecurityCritical]
        public override int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
        [SecuritySafeCritical]
        public override int GetCharCount(byte[] bytes, int index, int count);
        [CLSCompliant(False)]
        [SecurityCritical]
        public override int GetCharCount(byte* bytes, int count);
        [SecuritySafeCritical]
        public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
        [SecurityCritical]
        [CLSCompliant(False)]
        public override int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
        [SecuritySafeCritical]
        public override string GetString(byte[] bytes, int index, int count);
        public override Decoder GetDecoder();
        public override Encoder GetEncoder();
        public override int GetMaxByteCount(int charCount);
        public override int GetMaxCharCount(int byteCount);
        public override byte[] GetPreamble();
        public override bool Equals(object value);
        public override int GetHashCode();
    }
}
//using System.Runtime.InteropServices;
//using System.Security;

namespace System.Text
{
    [ComVisible(True)]
    public class UTF7Encoding : Encoding
    {
        public UTF7Encoding();
        public UTF7Encoding(bool allowOptionals);

        [ComVisible(False)]
        public override bool Equals(object value);
        [ComVisible(False)]
        public override int GetHashCode();
        [SecuritySafeCritical]
        public override int GetByteCount(char[] chars, int index, int count);
        [SecuritySafeCritical]
        [ComVisible(False)]
        public override int GetByteCount(string s);
        [ComVisible(False)]
        [SecurityCritical]
        [CLSCompliant(False)]
        public override int GetByteCount(char* chars, int count);
        [ComVisible(False)]
        [SecuritySafeCritical]
        public override int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex);
        [SecuritySafeCritical]
        public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
        [SecurityCritical]
        [CLSCompliant(False)]
        [ComVisible(False)]
        public override int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
        [SecuritySafeCritical]
        public override int GetCharCount(byte[] bytes, int index, int count);
        [SecurityCritical]
        [CLSCompliant(False)]
        [ComVisible(False)]
        public override int GetCharCount(byte* bytes, int count);
        [SecuritySafeCritical]
        public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
        [ComVisible(False)]
        [SecurityCritical]
        [CLSCompliant(False)]
        public override int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
        [ComVisible(False)]
        [SecuritySafeCritical]
        public override string GetString(byte[] bytes, int index, int count);
        public override System.Text.Decoder GetDecoder();
        public override System.Text.Encoder GetEncoder();
        public override int GetMaxByteCount(int charCount);
        public override int GetMaxCharCount(int byteCount);
    }
}
//using System.Runtime.InteropServices;
//using System.Security;

namespace System.Text
{
    [ComVisible(True)]
    public class UTF8Encoding : Encoding
    {
        public UTF8Encoding();
        public UTF8Encoding(bool encoderShouldEmitUTF8Identifier);
        public UTF8Encoding(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes);

        [SecuritySafeCritical]
        public override int GetByteCount(char[] chars, int index, int count);
        [SecuritySafeCritical]
        public override int GetByteCount(string chars);
        [CLSCompliant(False)]
        [ComVisible(False)]
        [SecurityCritical]
        public override int GetByteCount(char* chars, int count);
        [SecuritySafeCritical]
        public override int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex);
        [SecuritySafeCritical]
        public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
        [SecurityCritical]
        [CLSCompliant(False)]
        [ComVisible(False)]
        public override int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
        [SecuritySafeCritical]
        public override int GetCharCount(byte[] bytes, int index, int count);
        [CLSCompliant(False)]
        [SecurityCritical]
        [ComVisible(False)]
        public override int GetCharCount(byte* bytes, int count);
        [SecuritySafeCritical]
        public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
        [SecurityCritical]
        [CLSCompliant(False)]
        [ComVisible(False)]
        public override int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
        [SecuritySafeCritical]
        [ComVisible(False)]
        public override string GetString(byte[] bytes, int index, int count);
        public override Decoder GetDecoder();
        public override Encoder GetEncoder();
        public override int GetMaxByteCount(int charCount);
        public override int GetMaxCharCount(int byteCount);
        public override byte[] GetPreamble();
        public override bool Equals(object value);
        public override int GetHashCode();
    }
}
//using System.Runtime.InteropServices;

namespace System.Text
{
    [ComVisible(True)]
    public enum NormalizationForm
    {
        FormC = 1,
        FormD = 2,
        FormKC = 5,
        FormKD = 6
    }
}
//using System.Collections;
//using System.Runtime.InteropServices;

namespace System.Resources
{
    [ComVisible(True)]
    public interface IResourceReader : IEnumerable, IDisposable
    {
        void Close();
        IDictionaryEnumerator GetEnumerator();
    }
}
//using System.Runtime.InteropServices;

namespace System.Resources
{
    [ComVisible(True)]
    public interface IResourceWriter : IDisposable
    {
        void AddResource(string name, string value);
        void AddResource(string name, object value);
        void AddResource(string name, byte[] value);
        void Close();
        void Generate();
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System.Resources
{
    [ComVisible(True)]
    public class MissingManifestResourceException : SystemException
    {
        public MissingManifestResourceException();
        public MissingManifestResourceException(string message);
        public MissingManifestResourceException(string message, Exception inner);
        protected MissingManifestResourceException(SerializationInfo info, StreamingContext context);
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System.Resources
{
    [ComVisible(True)]
    public class MissingSatelliteAssemblyException : SystemException
    {
        public MissingSatelliteAssemblyException();
        public MissingSatelliteAssemblyException(string message);
        public MissingSatelliteAssemblyException(string message, string cultureName);
        public MissingSatelliteAssemblyException(string message, Exception inner);
        protected MissingSatelliteAssemblyException(SerializationInfo info, StreamingContext context);

        public string CultureName { get; }
    }
}
//using System.Runtime.InteropServices;

namespace System.Resources
{
    [ComVisible(True)]
    [AttributeUsage(Assembly, AllowMultiple = False)]
    public sealed class NeutralResourcesLanguageAttribute : Attribute
    {
        public NeutralResourcesLanguageAttribute(string cultureName);
        public NeutralResourcesLanguageAttribute(string cultureName, UltimateResourceFallbackLocation location);

        public string CultureName { get; }
        public UltimateResourceFallbackLocation Location { get; }
    }
}
//using System.Collections;
//using System.Globalization;
//using System.IO;
//using System.Reflection;
//using System.Runtime.InteropServices;
//using System.Security;

namespace System.Resources
{
    [ComVisible(True)]
    public class ResourceManager
    {
        protected string BaseNameField;
        [Obsolete("call InternalGetResourceSet instead")]
        protected Hashtable ResourceSets;
        protected Assembly MainAssembly;
        public static readonly int MagicNumber;
        public static readonly int HeaderVersionNumber;

        protected ResourceManager();
        public ResourceManager(string baseName, Assembly assembly);
        public ResourceManager(string baseName, Assembly assembly, Type usingResourceSet);
        public ResourceManager(Type resourceSource);

        public virtual string BaseName { get; }
        public virtual bool IgnoreCase { get; set; }
        public virtual Type ResourceSetType { get; }
        protected UltimateResourceFallbackLocation FallbackLocation { get; set; }

        public virtual void ReleaseAllResources();
        public static ResourceManager CreateFileBasedResourceManager(string baseName, string resourceDir, Type usingResourceSet);
        protected virtual string GetResourceFileName(CultureInfo culture);
        [SecuritySafeCritical]
        public virtual ResourceSet GetResourceSet(CultureInfo culture, bool createIfNotExists, bool tryParents);
        [SecuritySafeCritical]
        protected virtual ResourceSet InternalGetResourceSet(CultureInfo culture, bool createIfNotExists, bool tryParents);
        protected static Version GetSatelliteContractVersion(Assembly a);
        [SecuritySafeCritical]
        protected static CultureInfo GetNeutralResourcesLanguage(Assembly a);
        public virtual string GetString(string name);
        public virtual string GetString(string name, CultureInfo culture);
        public virtual object GetObject(string name);
        public virtual object GetObject(string name, CultureInfo culture);
        [ComVisible(False)]
        public UnmanagedMemoryStream GetStream(string name);
        [ComVisible(False)]
        public UnmanagedMemoryStream GetStream(string name, CultureInfo culture);
    }
}
//using System.Collections;
//using System.IO;
//using System.Runtime.InteropServices;
//using System.Security;

namespace System.Resources
{
    [ComVisible(True)]
    public sealed class ResourceReader : IEnumerable, IDisposable, IResourceReader
    {
        [SecuritySafeCritical]
        public ResourceReader(string fileName);
        [SecurityCritical]
        public ResourceReader(Stream stream);

        public void Close();
        public void Dispose();
        public IDictionaryEnumerator GetEnumerator();
        public void GetResourceData(string resourceName, out string resourceType, out byte[] resourceData);
    }
}
//using System.Collections;
//using System.IO;
//using System.Runtime.InteropServices;
//using System.Security;

namespace System.Resources
{
    [ComVisible(True)]
    public class ResourceSet : IEnumerable, IDisposable
    {
        protected IResourceReader Reader;
        protected Hashtable Table;

        protected ResourceSet();
        public ResourceSet(string fileName);
        [SecurityCritical]
        public ResourceSet(Stream stream);
        public ResourceSet(IResourceReader reader);

        public virtual void Close();
        protected virtual void Dispose(bool disposing);
        public void Dispose();
        public virtual Type GetDefaultReader();
        public virtual Type GetDefaultWriter();
        [ComVisible(False)]
        public virtual IDictionaryEnumerator GetEnumerator();
        public virtual string GetString(string name);
        public virtual string GetString(string name, bool ignoreCase);
        public virtual object GetObject(string name);
        public virtual object GetObject(string name, bool ignoreCase);
        protected virtual void ReadResources();
    }
}
//using System.IO;
//using System.Runtime.InteropServices;
//using System.Security;

namespace System.Resources
{
    [ComVisible(True)]
    public sealed class ResourceWriter : IDisposable, IResourceWriter
    {
        public ResourceWriter(string fileName);
        public ResourceWriter(Stream stream);

        public Func<Type, string> TypeNameConverter { get; set; }

        public void AddResource(string name, string value);
        public void AddResource(string name, object value);
        public void AddResource(string name, Stream value);
        public void AddResource(string name, Stream value, bool closeAfterWrite);
        public void AddResource(string name, byte[] value);
        public void AddResourceData(string name, string typeName, byte[] serializedData);
        public void Close();
        public void Dispose();
        [SecuritySafeCritical]
        public void Generate();
    }
}
//using System.Runtime.InteropServices;

namespace System.Resources
{
    [AttributeUsage(Assembly, AllowMultiple = False)]
    [ComVisible(True)]
    public sealed class SatelliteContractVersionAttribute : Attribute
    {
        public SatelliteContractVersionAttribute(string version);

        public string Version { get; }
    }
}
//using System.Runtime.InteropServices;

namespace System.Resources
{
    [ComVisible(True)]
    public enum UltimateResourceFallbackLocation
    {
        MainAssembly = 0,
        Satellite = 1
    }
}
//using System.Collections.Generic;

namespace System.Reflection
{
    public static class CustomAttributeExtensions
    {
        public static Attribute GetCustomAttribute(this Assembly element, Type attributeType);
        public static Attribute GetCustomAttribute(this Module element, Type attributeType);
        public static Attribute GetCustomAttribute(this MemberInfo element, Type attributeType);
        public static Attribute GetCustomAttribute(this ParameterInfo element, Type attributeType);
        public static T GetCustomAttribute<T>(this Assembly element) where T : Attribute;
        public static T GetCustomAttribute<T>(this Module element) where T : Attribute;
        public static T GetCustomAttribute<T>(this MemberInfo element) where T : Attribute;
        public static T GetCustomAttribute<T>(this ParameterInfo element) where T : Attribute;
        public static Attribute GetCustomAttribute(this MemberInfo element, Type attributeType, bool inherit);
        public static Attribute GetCustomAttribute(this ParameterInfo element, Type attributeType, bool inherit);
        public static T GetCustomAttribute<T>(this MemberInfo element, bool inherit) where T : Attribute;
        public static T GetCustomAttribute<T>(this ParameterInfo element, bool inherit) where T : Attribute;
        public static IEnumerable<Attribute> GetCustomAttributes(this Assembly element);
        public static IEnumerable<Attribute> GetCustomAttributes(this Module element);
        public static IEnumerable<Attribute> GetCustomAttributes(this MemberInfo element);
        public static IEnumerable<Attribute> GetCustomAttributes(this ParameterInfo element);
        public static IEnumerable<Attribute> GetCustomAttributes(this MemberInfo element, bool inherit);
        public static IEnumerable<Attribute> GetCustomAttributes(this ParameterInfo element, bool inherit);
        public static IEnumerable<Attribute> GetCustomAttributes(this Assembly element, Type attributeType);
        public static IEnumerable<Attribute> GetCustomAttributes(this Module element, Type attributeType);
        public static IEnumerable<Attribute> GetCustomAttributes(this MemberInfo element, Type attributeType);
        public static IEnumerable<Attribute> GetCustomAttributes(this ParameterInfo element, Type attributeType);
        public static IEnumerable<T> GetCustomAttributes<T>(this Assembly element) where T : Attribute;
        public static IEnumerable<T> GetCustomAttributes<T>(this Module element) where T : Attribute;
        public static IEnumerable<T> GetCustomAttributes<T>(this MemberInfo element) where T : Attribute;
        public static IEnumerable<T> GetCustomAttributes<T>(this ParameterInfo element) where T : Attribute;
        public static IEnumerable<Attribute> GetCustomAttributes(this MemberInfo element, Type attributeType, bool inherit);
        public static IEnumerable<Attribute> GetCustomAttributes(this ParameterInfo element, Type attributeType, bool inherit);
        public static IEnumerable<T> GetCustomAttributes<T>(this MemberInfo element, bool inherit) where T : Attribute;
        public static IEnumerable<T> GetCustomAttributes<T>(this ParameterInfo element, bool inherit) where T : Attribute;
        public static bool IsDefined(this Assembly element, Type attributeType);
        public static bool IsDefined(this Module element, Type attributeType);
        public static bool IsDefined(this MemberInfo element, Type attributeType);
        public static bool IsDefined(this ParameterInfo element, Type attributeType);
        public static bool IsDefined(this MemberInfo element, Type attributeType, bool inherit);
        public static bool IsDefined(this ParameterInfo element, Type attributeType, bool inherit);
    }
}
//using System.Collections.Generic;

namespace System.Reflection
{
    public static class RuntimeReflectionExtensions
    {
        public static IEnumerable<PropertyInfo> GetRuntimeProperties(this Type type);
        public static IEnumerable<EventInfo> GetRuntimeEvents(this Type type);
        public static IEnumerable<MethodInfo> GetRuntimeMethods(this Type type);
        public static IEnumerable<FieldInfo> GetRuntimeFields(this Type type);
        public static PropertyInfo GetRuntimeProperty(this Type type, string name);
        public static EventInfo GetRuntimeEvent(this Type type, string name);
        public static MethodInfo GetRuntimeMethod(this Type type, string name, Type[] parameters);
        public static FieldInfo GetRuntimeField(this Type type, string name);
        public static MethodInfo GetRuntimeBaseDefinition(this MethodInfo method);
        public static InterfaceMapping GetRuntimeInterfaceMap(this TypeInfo typeInfo, Type interfaceType);
        public static MethodInfo GetMethodInfo(this Delegate del);
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [ComVisible(True)]
    public sealed class AmbiguousMatchException : SystemException
    {
        public AmbiguousMatchException();
        public AmbiguousMatchException(string message);
        public AmbiguousMatchException(string message, Exception inner);
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [AttributeUsage(Assembly, Inherited = False)]
    [ComVisible(True)]
    public sealed class AssemblyCopyrightAttribute : Attribute
    {
        public AssemblyCopyrightAttribute(string copyright);

        public string Copyright { get; }
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [AttributeUsage(Assembly, Inherited = False)]
    [ComVisible(True)]
    public sealed class AssemblyTrademarkAttribute : Attribute
    {
        public AssemblyTrademarkAttribute(string trademark);

        public string Trademark { get; }
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [AttributeUsage(Assembly, Inherited = False)]
    [ComVisible(True)]
    public sealed class AssemblyProductAttribute : Attribute
    {
        public AssemblyProductAttribute(string product);

        public string Product { get; }
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [AttributeUsage(Assembly, Inherited = False)]
    [ComVisible(True)]
    public sealed class AssemblyCompanyAttribute : Attribute
    {
        public AssemblyCompanyAttribute(string company);

        public string Company { get; }
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [AttributeUsage(Assembly, Inherited = False)]
    [ComVisible(True)]
    public sealed class AssemblyDescriptionAttribute : Attribute
    {
        public AssemblyDescriptionAttribute(string description);

        public string Description { get; }
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [AttributeUsage(Assembly, Inherited = False)]
    [ComVisible(True)]
    public sealed class AssemblyTitleAttribute : Attribute
    {
        public AssemblyTitleAttribute(string title);

        public string Title { get; }
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [ComVisible(True)]
    [AttributeUsage(Assembly, Inherited = False)]
    public sealed class AssemblyConfigurationAttribute : Attribute
    {
        public AssemblyConfigurationAttribute(string configuration);

        public string Configuration { get; }
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [AttributeUsage(Assembly, Inherited = False)]
    [ComVisible(True)]
    public sealed class AssemblyDefaultAliasAttribute : Attribute
    {
        public AssemblyDefaultAliasAttribute(string defaultAlias);

        public string DefaultAlias { get; }
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [ComVisible(True)]
    [AttributeUsage(Assembly, Inherited = False)]
    public sealed class AssemblyInformationalVersionAttribute : Attribute
    {
        public AssemblyInformationalVersionAttribute(string informationalVersion);

        public string InformationalVersion { get; }
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [AttributeUsage(Assembly, Inherited = False)]
    [ComVisible(True)]
    public sealed class AssemblyFileVersionAttribute : Attribute
    {
        public AssemblyFileVersionAttribute(string version);

        public string Version { get; }
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [AttributeUsage(Assembly, Inherited = False)]
    [ComVisible(True)]
    public sealed class AssemblyCultureAttribute : Attribute
    {
        public AssemblyCultureAttribute(string culture);

        public string Culture { get; }
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [AttributeUsage(Assembly, Inherited = False)]
    [ComVisible(True)]
    public sealed class AssemblyVersionAttribute : Attribute
    {
        public AssemblyVersionAttribute(string version);

        public string Version { get; }
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [AttributeUsage(Assembly, Inherited = False)]
    [ComVisible(True)]
    public sealed class AssemblyKeyFileAttribute : Attribute
    {
        public AssemblyKeyFileAttribute(string keyFile);

        public string KeyFile { get; }
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [AttributeUsage(Assembly, Inherited = False)]
    [ComVisible(True)]
    public sealed class AssemblyDelaySignAttribute : Attribute
    {
        public AssemblyDelaySignAttribute(bool delaySign);

        public bool DelaySign { get; }
    }
}
//using System.Configuration.Assemblies;
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [AttributeUsage(Assembly, Inherited = False)]
    [ComVisible(True)]
    public sealed class AssemblyAlgorithmIdAttribute : Attribute
    {
        public AssemblyAlgorithmIdAttribute(AssemblyHashAlgorithm algorithmId);
        [CLSCompliant(False)]
        public AssemblyAlgorithmIdAttribute(uint algorithmId);

        [CLSCompliant(False)]
        public uint AlgorithmId { get; }
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [AttributeUsage(Assembly, Inherited = False)]
    [ComVisible(True)]
    public sealed class AssemblyFlagsAttribute : Attribute
    {
        [Obsolete("This constructor has been deprecated. Please use AssemblyFlagsAttribute(AssemblyNameFlags) instead. http://go.microsoft.com/fwlink/?linkid=14202")]
        [CLSCompliant(False)]
        public AssemblyFlagsAttribute(uint flags);
        [Obsolete("This constructor has been deprecated. Please use AssemblyFlagsAttribute(AssemblyNameFlags) instead. http://go.microsoft.com/fwlink/?linkid=14202")]
        public AssemblyFlagsAttribute(int assemblyFlags);
        public AssemblyFlagsAttribute(AssemblyNameFlags assemblyFlags);

        [CLSCompliant(False)]
        [Obsolete("This property has been deprecated. Please use AssemblyFlags instead. http://go.microsoft.com/fwlink/?linkid=14202")]
        public uint Flags { get; }
        public int AssemblyFlags { get; }
    }
}
namespace System.Reflection
{
    [AttributeUsage(Assembly, AllowMultiple = True, Inherited = False)]
    public sealed class AssemblyMetadataAttribute : Attribute
    {
        public AssemblyMetadataAttribute(string key, string value);

        public string Key { get; }
        public string Value { get; }
    }
}
namespace System.Reflection
{
    [AttributeUsage(Assembly, Inherited = False, AllowMultiple = False)]
    public sealed class AssemblySignatureKeyAttribute : Attribute
    {
        public AssemblySignatureKeyAttribute(string publicKey, string countersignature);

        public string PublicKey { get; }
        public string Countersignature { get; }
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [ComVisible(True)]
    [AttributeUsage(Assembly, Inherited = False)]
    public sealed class AssemblyKeyNameAttribute : Attribute
    {
        public AssemblyKeyNameAttribute(string keyName);

        public string KeyName { get; }
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [ComVisible(True)]
    [Flags]
    public enum AssemblyNameFlags
    {
        None = 0,
        PublicKey = 1,
        EnableJITcompileOptimizer = 16384,
        EnableJITcompileTracking = 32768,
        Retargetable = 256
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [ComVisible(False)]
    public enum AssemblyContentType
    {
        Default = 0,
        WindowsRuntime = 1
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [ComVisible(True)]
    public enum ProcessorArchitecture
    {
        None = 0,
        MSIL = 1,
        X86 = 2,
        IA64 = 3,
        Amd64 = 4,
        Arm = 5
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [ComVisible(True)]
    public class AssemblyNameProxy : MarshalByRefObject
    {
        public AssemblyNameProxy();

        public AssemblyName GetAssemblyName(string assemblyFile);
    }
}
//using System.Globalization;
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [ClassInterface(AutoDual)]
    [ComVisible(True)]
    public abstract class Binder
    {
        protected Binder();

        public abstract MethodBase BindToMethod(BindingFlags bindingAttr, MethodBase[] match, ref object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] names, out object state);
        public abstract FieldInfo BindToField(BindingFlags bindingAttr, FieldInfo[] match, object value, CultureInfo culture);
        public abstract MethodBase SelectMethod(BindingFlags bindingAttr, MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
        public abstract PropertyInfo SelectProperty(BindingFlags bindingAttr, PropertyInfo[] match, Type returnType, Type[] indexes, ParameterModifier[] modifiers);
        public abstract object ChangeType(object value, Type type, CultureInfo culture);
        public abstract void ReorderArgumentArray(ref object[] args, object state);
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [Flags]
    [ComVisible(True)]
    public enum BindingFlags
    {
        Default = 0,
        IgnoreCase = 1,
        DeclaredOnly = 2,
        Instance = 4,
        Static = 8,
        Public = 16,
        NonPublic = 32,
        FlattenHierarchy = 64,
        InvokeMethod = 256,
        CreateInstance = 512,
        GetField = 1024,
        SetField = 2048,
        GetProperty = 4096,
        SetProperty = 8192,
        PutDispProperty = 16384,
        PutRefDispProperty = 32768,
        ExactBinding = 65536,
        SuppressChangeType = 131072,
        OptionalParamBinding = 262144,
        IgnoreReturn = 16777216
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [Flags]
    [ComVisible(True)]
    public enum CallingConventions
    {
        Standard = 1,
        VarArgs = 2,
        Any = 3,
        HasThis = 32,
        ExplicitThis = 64
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [AttributeUsage(Class, Struct, Interface)]
    [ComVisible(True)]
    public sealed class DefaultMemberAttribute : Attribute
    {
        public DefaultMemberAttribute(string memberName);

        public string MemberName { get; }
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [ComVisible(True)]
    [Flags]
    public enum EventAttributes
    {
        None = 0,
        SpecialName = 512,
        ReservedMask = 1024,
        RTSpecialName = 1024
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [ComVisible(True)]
    [Flags]
    public enum FieldAttributes
    {
        FieldAccessMask = 7,
        PrivateScope = 0,
        Private = 1,
        FamANDAssem = 2,
        Assembly = 3,
        Family = 4,
        FamORAssem = 5,
        Public = 6,
        Static = 16,
        InitOnly = 32,
        Literal = 64,
        NotSerialized = 128,
        SpecialName = 512,
        PinvokeImpl = 8192,
        ReservedMask = 38144,
        RTSpecialName = 1024,
        HasFieldMarshal = 4096,
        HasDefault = 32768,
        HasFieldRVA = 256
    }
}
namespace System.Reflection
{
    [Flags]
    public enum GenericParameterAttributes
    {
        None = 0,
        VarianceMask = 3,
        Covariant = 1,
        Contravariant = 2,
        SpecialConstraintMask = 28,
        ReferenceTypeConstraint = 4,
        NotNullableValueTypeConstraint = 8,
        DefaultConstructorConstraint = 16
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [ComVisible(True)]
    public interface ICustomAttributeProvider
    {
        object[] GetCustomAttributes(Type attributeType, bool inherit);
        object[] GetCustomAttributes(bool inherit);
        bool IsDefined(Type attributeType, bool inherit);
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [ComVisible(True)]
    public struct InterfaceMapping
    {
        [ComVisible(True)]
        public Type TargetType;
        [ComVisible(True)]
        public Type InterfaceType;
        [ComVisible(True)]
        public MethodInfo[] TargetMethods;
        [ComVisible(True)]
        public MethodInfo[] InterfaceMethods;
    }
}
namespace System.Reflection
{
    public static class IntrospectionExtensions
    {
        public static TypeInfo GetTypeInfo(this Type type);
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System.Reflection
{
    [ComVisible(True)]
    public class InvalidFilterCriteriaException : ApplicationException
    {
        public InvalidFilterCriteriaException();
        public InvalidFilterCriteriaException(string message);
        public InvalidFilterCriteriaException(string message, Exception inner);
        protected InvalidFilterCriteriaException(SerializationInfo info, StreamingContext context);
    }
}
//using System.Globalization;
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [ComVisible(True)]
    [Guid("AFBF15E5-C37C-11d2-B88E-00A0C9B471B8")]
    public interface IReflect
    {
        Type UnderlyingSystemType { get; }

        MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
        MethodInfo GetMethod(string name, BindingFlags bindingAttr);
        MethodInfo[] GetMethods(BindingFlags bindingAttr);
        FieldInfo GetField(string name, BindingFlags bindingAttr);
        FieldInfo[] GetFields(BindingFlags bindingAttr);
        PropertyInfo GetProperty(string name, BindingFlags bindingAttr);
        PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
        PropertyInfo[] GetProperties(BindingFlags bindingAttr);
        MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
        MemberInfo[] GetMembers(BindingFlags bindingAttr);
        object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters);
    }
}
namespace System.Reflection
{
    public interface IReflectableType
    {
        TypeInfo GetTypeInfo();
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [ComVisible(True)]
    public class ManifestResourceInfo
    {
        public ManifestResourceInfo(Assembly containingAssembly, string containingFileName, ResourceLocation resourceLocation);

        public virtual Assembly ReferencedAssembly { get; }
        public virtual string FileName { get; }
        public virtual ResourceLocation ResourceLocation { get; }
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [Flags]
    [ComVisible(True)]
    public enum ResourceLocation
    {
        Embedded = 1,
        ContainedInAnotherAssembly = 2,
        ContainedInManifestFile = 4
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [ComVisible(True)]
    public delegate bool MemberFilter(MemberInfo m, object filterCriteria);
}
//using System.Collections.Generic;
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [ComVisible(True)]
    [ClassInterface(None)]
    [ComDefaultInterface(typeof(_MemberInfo))]
    public abstract class MemberInfo : ICustomAttributeProvider, _MemberInfo
    {
        protected MemberInfo();

        public abstract MemberTypes MemberType { get; }
        public abstract string Name { get; }
        public abstract Type DeclaringType { get; }
        public abstract Type ReflectedType { get; }
        public virtual IEnumerable<CustomAttributeData> CustomAttributes { get; }
        public virtual int MetadataToken { get; }
        public virtual Module Module { get; }

        public abstract object[] GetCustomAttributes(bool inherit);
        public abstract object[] GetCustomAttributes(Type attributeType, bool inherit);
        public abstract bool IsDefined(Type attributeType, bool inherit);
        public virtual IList<CustomAttributeData> GetCustomAttributesData();
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static bool operator ==(MemberInfo left, MemberInfo right);
        public static bool operator !=(MemberInfo left, MemberInfo right);
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [ComVisible(True)]
    [Flags]
    public enum MemberTypes
    {
        Constructor = 1,
        Event = 2,
        Field = 4,
        Method = 8,
        Property = 16,
        TypeInfo = 32,
        Custom = 64,
        NestedType = 128,
        All = 191
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [ComVisible(True)]
    [Flags]
    public enum MethodAttributes
    {
        MemberAccessMask = 7,
        PrivateScope = 0,
        Private = 1,
        FamANDAssem = 2,
        Assembly = 3,
        Family = 4,
        FamORAssem = 5,
        Public = 6,
        Static = 16,
        Final = 32,
        Virtual = 64,
        HideBySig = 128,
        CheckAccessOnOverride = 512,
        VtableLayoutMask = 256,
        ReuseSlot = 0,
        NewSlot = 256,
        Abstract = 1024,
        SpecialName = 2048,
        PinvokeImpl = 8192,
        UnmanagedExport = 8,
        RTSpecialName = 4096,
        ReservedMask = 53248,
        HasSecurity = 16384,
        RequireSecObject = 32768
    }
}
//using System.Diagnostics;
//using System.Globalization;
//using System.Runtime.InteropServices;
//using System.Security;

namespace System.Reflection
{
    [ClassInterface(None)]
    [ComVisible(True)]
    [ComDefaultInterface(typeof(_MethodBase))]
    public abstract class MethodBase : MemberInfo, _MethodBase
    {
        protected MethodBase();

        public virtual MethodImplAttributes MethodImplementationFlags { get; }
        public abstract RuntimeMethodHandle MethodHandle { get; }
        public abstract MethodAttributes Attributes { get; }
        public virtual CallingConventions CallingConvention { get; }
        public virtual bool IsGenericMethodDefinition { get; }
        public virtual bool ContainsGenericParameters { get; }
        public virtual bool IsGenericMethod { get; }
        public virtual bool IsSecurityCritical { get; }
        public virtual bool IsSecuritySafeCritical { get; }
        public virtual bool IsSecurityTransparent { get; }
        public bool IsPublic { get; }
        public bool IsPrivate { get; }
        public bool IsFamily { get; }
        public bool IsAssembly { get; }
        public bool IsFamilyAndAssembly { get; }
        public bool IsFamilyOrAssembly { get; }
        public bool IsStatic { get; }
        public bool IsFinal { get; }
        public bool IsVirtual { get; }
        public bool IsHideBySig { get; }
        public bool IsAbstract { get; }
        public bool IsSpecialName { get; }
        [ComVisible(True)]
        public bool IsConstructor { get; }

        public static MethodBase GetMethodFromHandle(RuntimeMethodHandle handle);
        [ComVisible(False)]
        public static MethodBase GetMethodFromHandle(RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);
        public static MethodBase GetCurrentMethod();
        public override bool Equals(object obj);
        public override int GetHashCode();
        public abstract ParameterInfo[] GetParameters();
        public abstract MethodImplAttributes GetMethodImplementationFlags();
        public abstract object Invoke(object obj, BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture);
        [ComVisible(True)]
        public virtual Type[] GetGenericArguments();
        [DebuggerHidden]
        [DebuggerStepThrough]
        public object Invoke(object obj, object[] parameters);
        [SecuritySafeCritical]
        public virtual MethodBody GetMethodBody();

        public static bool operator ==(MethodBase left, MethodBase right);
        public static bool operator !=(MethodBase left, MethodBase right);
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [Flags]
    [ComVisible(True)]
    public enum ExceptionHandlingClauseOptions
    {
        Clause = 0,
        Filter = 1,
        Finally = 2,
        Fault = 4
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [ComVisible(True)]
    public enum MethodImplAttributes
    {
        CodeTypeMask = 3,
        IL = 0,
        Native = 1,
        OPTIL = 2,
        Runtime = 3,
        ManagedMask = 4,
        Unmanaged = 4,
        Managed = 0,
        ForwardRef = 16,
        PreserveSig = 128,
        InternalCall = 4096,
        Synchronized = 32,
        NoInlining = 8,
        [ComVisible(False)]
        AggressiveInlining = 256,
        NoOptimization = 64,
        MaxMethodImplVal = 65535
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [ComDefaultInterface(typeof(_MethodInfo))]
    [ComVisible(True)]
    [ClassInterface(None)]
    public abstract class MethodInfo : MethodBase, _MethodInfo
    {
        protected MethodInfo();

        public override MemberTypes MemberType { get; }
        public virtual Type ReturnType { get; }
        public virtual ParameterInfo ReturnParameter { get; }
        public abstract ICustomAttributeProvider ReturnTypeCustomAttributes { get; }

        public override bool Equals(object obj);
        public override int GetHashCode();
        public abstract MethodInfo GetBaseDefinition();
        [ComVisible(True)]
        public override Type[] GetGenericArguments();
        [ComVisible(True)]
        public virtual MethodInfo GetGenericMethodDefinition();
        public virtual MethodInfo MakeGenericMethod(params Type[] typeArguments);
        public virtual Delegate CreateDelegate(Type delegateType);
        public virtual Delegate CreateDelegate(Type delegateType, object target);

        public static bool operator ==(MethodInfo left, MethodInfo right);
        public static bool operator !=(MethodInfo left, MethodInfo right);
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System.Reflection
{
    [ComVisible(True)]
    public sealed class Missing : ISerializable
    {
        public static readonly Missing Value;
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [AttributeUsage(Assembly, AllowMultiple = False, Inherited = False)]
    [ComVisible(True)]
    public sealed class ObfuscateAssemblyAttribute : Attribute
    {
        public ObfuscateAssemblyAttribute(bool assemblyIsPrivate);

        public bool AssemblyIsPrivate { get; }
        public bool StripAfterObfuscation { get; set; }
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [AttributeUsage(Assembly, Class, Struct, Enum, Method, Property, Field, Event, Interface, Parameter, Delegate, AllowMultiple = True, Inherited = False)]
    [ComVisible(True)]
    public sealed class ObfuscationAttribute : Attribute
    {
        public ObfuscationAttribute();

        public bool StripAfterObfuscation { get; set; }
        public bool Exclude { get; set; }
        public bool ApplyToMembers { get; set; }
        public string Feature { get; set; }
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [ComVisible(True)]
    [Flags]
    public enum ParameterAttributes
    {
        None = 0,
        In = 1,
        Out = 2,
        Lcid = 4,
        Retval = 8,
        Optional = 16,
        ReservedMask = 61440,
        HasDefault = 4096,
        HasFieldMarshal = 8192,
        Reserved3 = 16384,
        Reserved4 = 32768
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [DefaultMember("Item")]
    [ComVisible(True)]
    public struct ParameterModifier
    {
        public ParameterModifier(int parameterCount);

        public bool this[int index] { get; set; }
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;
//using System.Security;

namespace System.Reflection
{
    [ComVisible(True)]
    [CLSCompliant(False)]
    public sealed class Pointer : ISerializable
    {
        [SecurityCritical]
        public static object Box(void* ptr, Type type);
        [SecurityCritical]
        public static void* Unbox(object ptr);
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [ComVisible(True)]
    [Flags]
    public enum PropertyAttributes
    {
        None = 0,
        SpecialName = 512,
        ReservedMask = 62464,
        RTSpecialName = 1024,
        HasDefault = 4096,
        Reserved2 = 8192,
        Reserved3 = 16384,
        Reserved4 = 32768
    }
}
namespace System.Reflection
{
    public abstract class ReflectionContext
    {
        protected ReflectionContext();

        public abstract Assembly MapAssembly(Assembly assembly);
        public abstract TypeInfo MapType(TypeInfo type);
        public virtual TypeInfo GetTypeForObject(object value);
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;
//using System.Security;

namespace System.Reflection
{
    [ComVisible(True)]
    public sealed class ReflectionTypeLoadException : SystemException
    {
        public ReflectionTypeLoadException(Type[] classes, Exception[] exceptions);
        public ReflectionTypeLoadException(Type[] classes, Exception[] exceptions, string message);

        public Type[] Types { get; }
        public Exception[] LoaderExceptions { get; }

        [SecurityCritical]
        public override void GetObjectData(SerializationInfo info, StreamingContext context);
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [ComVisible(True)]
    [Flags]
    public enum ResourceAttributes
    {
        Public = 1,
        Private = 2
    }
}
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;

namespace System.Reflection
{
    [ComVisible(True)]
    public class TargetException : ApplicationException
    {
        public TargetException();
        public TargetException(string message);
        public TargetException(string message, Exception inner);
        protected TargetException(SerializationInfo info, StreamingContext context);
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [ComVisible(True)]
    public sealed class TargetInvocationException : ApplicationException
    {
        public TargetInvocationException(Exception inner);
        public TargetInvocationException(string message, Exception inner);
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [ComVisible(True)]
    public sealed class TargetParameterCountException : ApplicationException
    {
        public TargetParameterCountException();
        public TargetParameterCountException(string message);
        public TargetParameterCountException(string message, Exception inner);
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [Flags]
    [ComVisible(True)]
    public enum TypeAttributes
    {
        VisibilityMask = 7,
        NotPublic = 0,
        Public = 1,
        NestedPublic = 2,
        NestedPrivate = 3,
        NestedFamily = 4,
        NestedAssembly = 5,
        NestedFamANDAssem = 6,
        NestedFamORAssem = 7,
        LayoutMask = 24,
        AutoLayout = 0,
        SequentialLayout = 8,
        ExplicitLayout = 16,
        ClassSemanticsMask = 32,
        Class = 0,
        Interface = 32,
        Abstract = 128,
        Sealed = 256,
        SpecialName = 1024,
        Import = 4096,
        Serializable = 8192,
        [ComVisible(False)]
        WindowsRuntime = 16384,
        StringFormatMask = 196608,
        AnsiClass = 0,
        UnicodeClass = 65536,
        AutoClass = 131072,
        CustomFormatClass = 196608,
        CustomFormatMask = 12582912,
        BeforeFieldInit = 1048576,
        ReservedMask = 264192,
        RTSpecialName = 2048,
        HasSecurity = 262144
    }
}
//using System.Globalization;
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [ComVisible(True)]
    public class TypeDelegator : TypeInfo
    {
        protected Type typeImpl;

        protected TypeDelegator();
        public TypeDelegator(Type delegatingType);

        public override Guid GUID { get; }
        public override int MetadataToken { get; }
        public override Module Module { get; }
        public override Assembly Assembly { get; }
        public override RuntimeTypeHandle TypeHandle { get; }
        public override string Name { get; }
        public override string FullName { get; }
        public override string Namespace { get; }
        public override string AssemblyQualifiedName { get; }
        public override Type BaseType { get; }
        public override bool IsConstructedGenericType { get; }
        public override Type UnderlyingSystemType { get; }
        public override bool IsSZArray { get; }

        public override bool IsAssignableFrom(TypeInfo typeInfo);
        public override object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters);
        protected override ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
        [ComVisible(True)]
        public override ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
        protected override MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
        public override MethodInfo[] GetMethods(BindingFlags bindingAttr);
        public override FieldInfo GetField(string name, BindingFlags bindingAttr);
        public override FieldInfo[] GetFields(BindingFlags bindingAttr);
        public override Type GetInterface(string name, bool ignoreCase);
        public override Type[] GetInterfaces();
        public override EventInfo GetEvent(string name, BindingFlags bindingAttr);
        public override EventInfo[] GetEvents();
        protected override PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
        public override PropertyInfo[] GetProperties(BindingFlags bindingAttr);
        public override EventInfo[] GetEvents(BindingFlags bindingAttr);
        public override Type[] GetNestedTypes(BindingFlags bindingAttr);
        public override Type GetNestedType(string name, BindingFlags bindingAttr);
        public override MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
        public override MemberInfo[] GetMembers(BindingFlags bindingAttr);
        protected override TypeAttributes GetAttributeFlagsImpl();
        protected override bool IsArrayImpl();
        protected override bool IsPrimitiveImpl();
        protected override bool IsByRefImpl();
        protected override bool IsPointerImpl();
        protected override bool IsValueTypeImpl();
        protected override bool IsCOMObjectImpl();
        public override Type GetElementType();
        protected override bool HasElementTypeImpl();
        public override object[] GetCustomAttributes(bool inherit);
        public override object[] GetCustomAttributes(Type attributeType, bool inherit);
        public override bool IsDefined(Type attributeType, bool inherit);
        [ComVisible(True)]
        public override InterfaceMapping GetInterfaceMap(Type interfaceType);
    }
}
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [ComVisible(True)]
    public delegate bool TypeFilter(Type m, object filterCriteria);
}
//using System.Collections.Generic;
//using System.Runtime.CompilerServices;
//using System.Runtime.InteropServices;

namespace System.Reflection
{
    [ComVisible(True)]
    public abstract class TypeInfo : Type, IReflectableType
    {
        public virtual Type[] GenericTypeParameters { get; }
        public virtual IEnumerable<ConstructorInfo> DeclaredConstructors { get; }
        public virtual IEnumerable<EventInfo> DeclaredEvents { get; }
        public virtual IEnumerable<FieldInfo> DeclaredFields { get; }
        public virtual IEnumerable<MemberInfo> DeclaredMembers { get; }
        public virtual IEnumerable<MethodInfo> DeclaredMethods { get; }
        public virtual IEnumerable<TypeInfo> DeclaredNestedTypes { get; }
        public virtual IEnumerable<PropertyInfo> DeclaredProperties { get; }
        public virtual IEnumerable<Type> ImplementedInterfaces { get; }

        public virtual Type AsType();
        public virtual bool IsAssignableFrom(TypeInfo typeInfo);
        public virtual EventInfo GetDeclaredEvent(string name);
        public virtual FieldInfo GetDeclaredField(string name);
        public virtual MethodInfo GetDeclaredMethod(string name);
        [IteratorStateMachine(typeof(<GetDeclaredMethods>d__9))]
        public virtual IEnumerable<MethodInfo> GetDeclaredMethods(string name);
        public virtual TypeInfo GetDeclaredNestedType(string name);
        public virtual PropertyInfo GetDeclaredProperty(string name);
    }
}
//using System.Collections.Generic;
//using System.Configuration.Assemblies;
//using System.Globalization;
//using System.IO;
//using System.Runtime.InteropServices;
//using System.Runtime.Serialization;
//using System.Security;
//using System.Security.Policy;

namespace System.Reflection
{
    [ComDefaultInterface(typeof(_Assembly))]
    [ClassInterface(None)]
    [ComVisible(True)]
    public abstract class Assembly : IEvidenceFactory, _Assembly, ICustomAttributeProvider, ISerializable
    {
        protected Assembly();

        public virtual string CodeBase { get; }
        public virtual string EscapedCodeBase { get; }
        public virtual string FullName { get; }
        public virtual MethodInfo EntryPoint { get; }
        public virtual Evidence Evidence { get; }
        public virtual string Location { get; }
        [ComVisible(False)]
        public virtual string ImageRuntimeVersion { get; }
        [ComVisible(False)]
        [MonoTODO("Currently it always returns zero")]
        public virtual long HostContext { get; }
        [ComVisible(False)]
        public virtual bool ReflectionOnly { get; }
        public virtual PermissionSet PermissionSet { get; }
        public virtual SecurityRuleSet SecurityRuleSet { get; }
        [MonoTODO]
        public bool IsFullyTrusted { get; }
        public virtual Module ManifestModule { get; }
        public virtual bool GlobalAssemblyCache { get; }
        public virtual bool IsDynamic { get; }
        public virtual IEnumerable<TypeInfo> DefinedTypes { get; }
        public virtual IEnumerable<Type> ExportedTypes { get; }
        public virtual IEnumerable<Module> Modules { get; }
        public virtual IEnumerable<CustomAttributeData> CustomAttributes { get; }

        public virtual event ModuleResolveEventHandler ModuleResolve;

        [SecurityCritical]
        public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
        public virtual bool IsDefined(Type attributeType, bool inherit);
        public virtual object[] GetCustomAttributes(bool inherit);
        public virtual object[] GetCustomAttributes(Type attributeType, bool inherit);
        public virtual FileStream[] GetFiles();
        public virtual FileStream[] GetFiles(bool getResourceModules);
        public virtual FileStream GetFile(string name);
        public virtual Stream GetManifestResourceStream(string name);
        public virtual Stream GetManifestResourceStream(Type type, string name);
        public virtual Type[] GetTypes();
        public virtual Type[] GetExportedTypes();
        public virtual Type GetType(string name, bool throwOnError);
        public virtual Type GetType(string name);
        public virtual AssemblyName GetName(bool copiedName);
        public virtual AssemblyName GetName();
        public override string ToString();
        public static string CreateQualifiedName(string assemblyName, string typeName);
        public static Assembly GetAssembly(Type type);
        public static Assembly GetEntryAssembly();
        public static Assembly LoadFrom(string assemblyFile);
        [Obsolete]
        public static Assembly LoadFrom(string assemblyFile, Evidence securityEvidence);
        [Obsolete]
        [MonoTODO("This overload is not currently implemented")]
        public static Assembly LoadFrom(string assemblyFile, Evidence securityEvidence, byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
        [MonoTODO]
        public static Assembly LoadFrom(string assemblyFile, byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
        public static Assembly UnsafeLoadFrom(string assemblyFile);
        [Obsolete]
        public static Assembly LoadFile(string path, Evidence securityEvidence);
        public static Assembly LoadFile(string path);
        public static Assembly Load(string assemblyString);
        [Obsolete]
        public static Assembly Load(string assemblyString, Evidence assemblySecurity);
        public static Assembly Load(AssemblyName assemblyRef);
        [Obsolete]
        public static Assembly Load(AssemblyName assemblyRef, Evidence assemblySecurity);
        public static Assembly Load(byte[] rawAssembly);
        public static Assembly Load(byte[] rawAssembly, byte[] rawSymbolStore);
        [Obsolete]
        public static Assembly Load(byte[] rawAssembly, byte[] rawSymbolStore, Evidence securityEvidence);
        [MonoLimitation("Argument securityContextSource is ignored")]
        public static Assembly Load(byte[] rawAssembly, byte[] rawSymbolStore, SecurityContextSource securityContextSource);
        public static Assembly ReflectionOnlyLoad(byte[] rawAssembly);
        public static Assembly ReflectionOnlyLoad(string assemblyString);
        public static Assembly ReflectionOnlyLoadFrom(string assemblyFile);
        [Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")]
        public static Assembly LoadWithPartialName(string partialName);
        [MonoTODO("Not implemented")]
        public Module LoadModule(string moduleName, byte[] rawModule);
        [MonoTODO("Not implemented")]
        public virtual Module LoadModule(string moduleName, byte[] rawModule, byte[] rawSymbolStore);
        [Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")]
        public static Assembly LoadWithPartialName(string partialName, Evidence securityEvidence);
        public object CreateInstance(string typeName);
        public object CreateInstance(string typeName, bool ignoreCase);
        public virtual object CreateInstance(string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes);
        public Module[] GetLoadedModules();
        public Module[] GetModules();
        public virtual string[] GetManifestResourceNames();
        public static Assembly GetExecutingAssembly();
        public static Assembly GetCallingAssembly();
        public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
        public override int GetHashCode();
        public override bool Equals(object o);
        public virtual IList<CustomAttributeData> GetCustomAttributesData();
        public virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
        public virtual Module GetModule(string name);
        public virtual AssemblyName[] GetReferencedAssemblies();
        public virtual Module[] GetModules(bool getResourceModules);
        [MonoTODO("Always returns the same as GetModules")]
        public virtual Module[] GetLoadedModules(bool getResourceModules);
        public virtual Assembly GetSatelliteAssembly(CultureInfo culture);
        public virtual Assembly GetSatelliteAssembly(CultureInfo culture, Version version);

        public static bool operator ==(Assembly left, Assembly right);
        public static bool operator !=(Assembly left, Assembly right);
    }
}
