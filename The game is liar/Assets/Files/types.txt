-------- {UnityEngine(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.dll)}:   67 --------
-------- {UnityEngine.AIModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.AIModule.dll)}:   33 --------
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.AI
{
    [MovedFrom("UnityEngine")]
    public enum NavMeshPathStatus
    {
        PathComplete = 0,
        PathPartial = 1,
        PathInvalid = 2
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.AI
{
    [MovedFrom("UnityEngine")]
    [NativeHeader("Modules/AI/NavMeshPath.bindings.h")]
    public sealed class NavMeshPath
    {
        public NavMeshPath();

        ~NavMeshPath();

        public Vector3[] corners { get; }
        public NavMeshPathStatus status { get; }

        [FreeFunction("NavMeshPathScriptBindings::GetCornersNonAlloc", HasExplicitThis = True)]
        public int GetCornersNonAlloc(out Vector3[] results);
        public void ClearCorners();
    }
}
using System.Collections.Generic;
using UnityEngine.Bindings;

namespace UnityEngine.AI
{
    [StaticAccessor("NavMeshBuilderBindings", DoubleColon)]
    [NativeHeader("Modules/AI/Builder/NavMeshBuilder.bindings.h")]
    public static class NavMeshBuilder
    {
        public static void CollectSources(Bounds includedWorldBounds, int includedLayerMask, NavMeshCollectGeometry geometry, int defaultArea, List<NavMeshBuildMarkup> markups, List<NavMeshBuildSource> results);
        public static void CollectSources(Transform root, int includedLayerMask, NavMeshCollectGeometry geometry, int defaultArea, List<NavMeshBuildMarkup> markups, List<NavMeshBuildSource> results);
        public static NavMeshData BuildNavMeshData(NavMeshBuildSettings buildSettings, List<NavMeshBuildSource> sources, Bounds localBounds, Vector3 position, Quaternion rotation);
        public static bool UpdateNavMeshData(NavMeshData data, NavMeshBuildSettings buildSettings, List<NavMeshBuildSource> sources, Bounds localBounds);
        public static AsyncOperation UpdateNavMeshDataAsync(NavMeshData data, NavMeshBuildSettings buildSettings, List<NavMeshBuildSource> sources, Bounds localBounds);
        [NativeMethod("Purge")]
        [StaticAccessor("GetNavMeshManager().GetNavMeshBuildManager()", Arrow)]
        [NativeHeader("Modules/AI/NavMeshManager.h")]
        public static void Cancel(NavMeshData data);
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.AI
{
    [MovedFrom("UnityEngine")]
    public enum ObstacleAvoidanceType
    {
        NoObstacleAvoidance = 0,
        LowQualityObstacleAvoidance = 1,
        MedQualityObstacleAvoidance = 2,
        GoodQualityObstacleAvoidance = 3,
        HighQualityObstacleAvoidance = 4
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.AI
{
    [NativeHeader("Modules/AI/NavMesh/NavMesh.bindings.h")]
    [NativeHeader("Modules/AI/Components/NavMeshAgent.bindings.h")]
    [MovedFrom("UnityEngine")]
    public sealed class NavMeshAgent : Behaviour
    {
        public NavMeshAgent();

        public Vector3 destination { get; set; }
        public float stoppingDistance { get; set; }
        public Vector3 velocity { get; set; }
        [NativeProperty("Position")]
        public Vector3 nextPosition { get; set; }
        public Vector3 steeringTarget { get; }
        public Vector3 desiredVelocity { get; }
        public float remainingDistance { get; }
        public float baseOffset { get; set; }
        public bool isOnOffMeshLink { get; }
        public OffMeshLinkData currentOffMeshLinkData { get; }
        public OffMeshLinkData nextOffMeshLinkData { get; }
        public bool autoTraverseOffMeshLink { get; set; }
        public bool autoBraking { get; set; }
        public bool autoRepath { get; set; }
        public bool hasPath { get; }
        public bool pathPending { get; }
        public bool isPathStale { get; }
        public NavMeshPathStatus pathStatus { get; }
        [NativeProperty("EndPositionOfCurrentPath")]
        public Vector3 pathEndPosition { get; }
        public bool isStopped { get; set; }
        public NavMeshPath path { get; set; }
        public Object navMeshOwner { get; }
        public int agentTypeID { get; set; }
        [Obsolete("Use areaMask instead.")]
        public int walkableMask { get; set; }
        public int areaMask { get; set; }
        public float speed { get; set; }
        public float angularSpeed { get; set; }
        public float acceleration { get; set; }
        public bool updatePosition { get; set; }
        public bool updateRotation { get; set; }
        public bool updateUpAxis { get; set; }
        public float radius { get; set; }
        public float height { get; set; }
        public ObstacleAvoidanceType obstacleAvoidanceType { get; set; }
        public int avoidancePriority { get; set; }
        public bool isOnNavMesh { get; }

        public bool SetDestination(Vector3 target);
        public void ActivateCurrentOffMeshLink(bool activated);
        public void CompleteOffMeshLink();
        public bool Warp(Vector3 newPosition);
        public void Move(Vector3 offset);
        [Obsolete("Set isStopped to true instead.")]
        public void Stop();
        [Obsolete("Set isStopped to true instead.")]
        public void Stop(bool stopUpdates);
        [Obsolete("Set isStopped to false instead.")]
        public void Resume();
        public void ResetPath();
        public bool SetPath([NotNull("ArgumentNullException")] NavMeshPath path);
        [NativeName("DistanceToEdge")]
        public bool FindClosestEdge(out NavMeshHit hit);
        public bool Raycast(Vector3 targetPosition, out NavMeshHit hit);
        public bool CalculatePath(Vector3 targetPosition, NavMeshPath path);
        public bool SamplePathPosition(int areaMask, float maxDistance, out NavMeshHit hit);
        [NativeMethod("SetAreaCost")]
        [Obsolete("Use SetAreaCost instead.")]
        public void SetLayerCost(int layer, float cost);
        [NativeMethod("GetAreaCost")]
        [Obsolete("Use GetAreaCost instead.")]
        public float GetLayerCost(int layer);
        public void SetAreaCost(int areaIndex, float areaCost);
        public float GetAreaCost(int areaIndex);
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.AI
{
    [MovedFrom("UnityEngine")]
    public enum NavMeshObstacleShape
    {
        Capsule = 0,
        Box = 1
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.AI
{
    [MovedFrom("UnityEngine")]
    [NativeHeader("Modules/AI/Components/NavMeshObstacle.bindings.h")]
    public sealed class NavMeshObstacle : Behaviour
    {
        public NavMeshObstacle();

        public float height { get; set; }
        public float radius { get; set; }
        public Vector3 velocity { get; set; }
        public bool carving { get; set; }
        public bool carveOnlyStationary { get; set; }
        [NativeProperty("MoveThreshold")]
        public float carvingMoveThreshold { get; set; }
        [NativeProperty("TimeToStationary")]
        public float carvingTimeToStationary { get; set; }
        public NavMeshObstacleShape shape { get; set; }
        public Vector3 center { get; set; }
        public Vector3 size { get; set; }
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.AI
{
    [MovedFrom("UnityEngine")]
    public enum OffMeshLinkType
    {
        LinkTypeManual = 0,
        LinkTypeDropDown = 1,
        LinkTypeJumpAcross = 2
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.AI
{
    [MovedFrom("UnityEngine")]
    [NativeHeader("Modules/AI/Components/OffMeshLink.bindings.h")]
    public struct OffMeshLinkData
    {
        public bool valid { get; }
        public bool activated { get; }
        public OffMeshLinkType linkType { get; }
        public Vector3 startPos { get; }
        public Vector3 endPos { get; }
        public OffMeshLink offMeshLink { get; }
    }
}
using System;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.AI
{
    [MovedFrom("UnityEngine")]
    public sealed class OffMeshLink : Behaviour
    {
        public OffMeshLink();

        public bool activated { get; set; }
        public bool occupied { get; }
        public float costOverride { get; set; }
        public bool biDirectional { get; set; }
        [Obsolete("Use area instead.")]
        public int navMeshLayer { get; set; }
        public int area { get; set; }
        public bool autoUpdatePositions { get; set; }
        public Transform startTransform { get; set; }
        public Transform endTransform { get; set; }

        public void UpdatePositions();
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.AI
{
    [MovedFrom("UnityEngine")]
    public struct NavMeshHit
    {
        public Vector3 position { get; set; }
        public Vector3 normal { get; set; }
        public float distance { get; set; }
        public int mask { get; set; }
        public bool hit { get; set; }
    }
}
using System;
using UnityEngine.Scripting;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.AI
{
    [UsedByNativeCode]
    [MovedFrom("UnityEngine")]
    public struct NavMeshTriangulation
    {
        public Vector3[] vertices;
        public int[] indices;
        public int[] areas;

        [Obsolete("Use areas instead.")]
        public int[] layers { get; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.AI
{
    [NativeHeader("Modules/AI/NavMesh/NavMesh.bindings.h")]
    public sealed class NavMeshData : Object
    {
        public NavMeshData();
        public NavMeshData(int agentTypeID);

        public Bounds sourceBounds { get; }
        public Vector3 position { get; set; }
        public Quaternion rotation { get; set; }
    }
}
namespace UnityEngine.AI
{
    public struct NavMeshDataInstance
    {
        public bool valid { get; }
        public Object owner { get; set; }

        public void Remove();
    }
}
namespace UnityEngine.AI
{
    public struct NavMeshLinkData
    {
        public Vector3 startPosition { get; set; }
        public Vector3 endPosition { get; set; }
        public float costModifier { get; set; }
        public bool bidirectional { get; set; }
        public float width { get; set; }
        public int area { get; set; }
        public int agentTypeID { get; set; }
    }
}
namespace UnityEngine.AI
{
    public struct NavMeshLinkInstance
    {
        public bool valid { get; }
        public Object owner { get; set; }

        public void Remove();
    }
}
namespace UnityEngine.AI
{
    public struct NavMeshQueryFilter
    {
        public int areaMask { get; set; }
        public int agentTypeID { get; set; }

        public float GetAreaCost(int areaIndex);
        public void SetAreaCost(int areaIndex, float cost);
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.AI
{
    [StaticAccessor("NavMeshBindings", DoubleColon)]
    [MovedFrom("UnityEngine")]
    [NativeHeader("Modules/AI/NavMeshManager.h")]
    [NativeHeader("Modules/AI/NavMesh/NavMesh.bindings.h")]
    public static class NavMesh
    {
        public const int AllAreas = -1;
        public static OnNavMeshPreUpdate onPreUpdate;

        [StaticAccessor("GetNavMeshManager()")]
        public static float avoidancePredictionTime { get; set; }
        [StaticAccessor("GetNavMeshManager()")]
        public static int pathfindingIterationsPerFrame { get; set; }

        public static bool Raycast(Vector3 sourcePosition, Vector3 targetPosition, out NavMeshHit hit, int areaMask);
        public static bool CalculatePath(Vector3 sourcePosition, Vector3 targetPosition, int areaMask, NavMeshPath path);
        public static bool FindClosestEdge(Vector3 sourcePosition, out NavMeshHit hit, int areaMask);
        public static bool SamplePosition(Vector3 sourcePosition, out NavMeshHit hit, float maxDistance, int areaMask);
        [Obsolete("Use SetAreaCost instead.")]
        [StaticAccessor("GetNavMeshProjectSettings()")]
        [NativeName("SetAreaCost")]
        public static void SetLayerCost(int layer, float cost);
        [Obsolete("Use GetAreaCost instead.")]
        [StaticAccessor("GetNavMeshProjectSettings()")]
        [NativeName("GetAreaCost")]
        public static float GetLayerCost(int layer);
        [Obsolete("Use GetAreaFromName instead.")]
        [NativeName("GetAreaFromName")]
        [StaticAccessor("GetNavMeshProjectSettings()")]
        public static int GetNavMeshLayerFromName(string layerName);
        [NativeName("SetAreaCost")]
        [StaticAccessor("GetNavMeshProjectSettings()")]
        public static void SetAreaCost(int areaIndex, float cost);
        [StaticAccessor("GetNavMeshProjectSettings()")]
        [NativeName("GetAreaCost")]
        public static float GetAreaCost(int areaIndex);
        [StaticAccessor("GetNavMeshProjectSettings()")]
        [NativeName("GetAreaFromName")]
        public static int GetAreaFromName(string areaName);
        public static NavMeshTriangulation CalculateTriangulation();
        [Obsolete("use NavMesh.CalculateTriangulation() instead.")]
        public static void Triangulate(out Vector3[] vertices, out int[] indices);
        [Obsolete("AddOffMeshLinks has no effect and is deprecated.")]
        public static void AddOffMeshLinks();
        [Obsolete("RestoreNavMesh has no effect and is deprecated.")]
        public static void RestoreNavMesh();
        public static NavMeshDataInstance AddNavMeshData(NavMeshData navMeshData);
        public static NavMeshDataInstance AddNavMeshData(NavMeshData navMeshData, Vector3 position, Quaternion rotation);
        public static void RemoveNavMeshData(NavMeshDataInstance handle);
        public static NavMeshLinkInstance AddLink(NavMeshLinkData link);
        public static NavMeshLinkInstance AddLink(NavMeshLinkData link, Vector3 position, Quaternion rotation);
        public static void RemoveLink(NavMeshLinkInstance handle);
        public static bool SamplePosition(Vector3 sourcePosition, out NavMeshHit hit, float maxDistance, NavMeshQueryFilter filter);
        public static bool FindClosestEdge(Vector3 sourcePosition, out NavMeshHit hit, NavMeshQueryFilter filter);
        public static bool Raycast(Vector3 sourcePosition, Vector3 targetPosition, out NavMeshHit hit, NavMeshQueryFilter filter);
        public static bool CalculatePath(Vector3 sourcePosition, Vector3 targetPosition, NavMeshQueryFilter filter, NavMeshPath path);
        [StaticAccessor("GetNavMeshProjectSettings()")]
        public static NavMeshBuildSettings CreateSettings();
        [StaticAccessor("GetNavMeshProjectSettings()")]
        public static void RemoveSettings(int agentTypeID);
        public static NavMeshBuildSettings GetSettingsByID(int agentTypeID);
        [StaticAccessor("GetNavMeshProjectSettings()")]
        public static int GetSettingsCount();
        public static NavMeshBuildSettings GetSettingsByIndex(int index);
        public static string GetSettingsNameFromID(int agentTypeID);
        [NativeName("CleanupAfterCarving")]
        [StaticAccessor("GetNavMeshManager()")]
        public static void RemoveAllNavMeshData();

        public delegate void OnNavMeshPreUpdate();
    }
}
using System;

namespace UnityEngine.AI
{
    [Flags]
    public enum NavMeshBuildDebugFlags
    {
        None = 0,
        InputGeometry = 1,
        Voxels = 2,
        Regions = 4,
        RawContours = 8,
        SimplifiedContours = 16,
        PolygonMeshes = 32,
        PolygonMeshesDetail = 64,
        All = 127
    }
}
namespace UnityEngine.AI
{
    public enum NavMeshBuildSourceShape
    {
        Mesh = 0,
        Terrain = 1,
        Box = 2,
        Sphere = 3,
        Capsule = 4,
        ModifierBox = 5
    }
}
namespace UnityEngine.AI
{
    public enum NavMeshCollectGeometry
    {
        RenderMeshes = 0,
        PhysicsColliders = 1
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.AI
{
    [NativeHeader("Modules/AI/Public/NavMeshBindingTypes.h")]
    [UsedByNativeCode]
    public struct NavMeshBuildSource
    {
        public Matrix4x4 transform { get; set; }
        public Vector3 size { get; set; }
        public NavMeshBuildSourceShape shape { get; set; }
        public int area { get; set; }
        public Object sourceObject { get; set; }
        public Component component { get; set; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.AI
{
    [NativeHeader("Modules/AI/Public/NavMeshBindingTypes.h")]
    public struct NavMeshBuildMarkup
    {
        public bool overrideArea { get; set; }
        public int area { get; set; }
        public bool ignoreFromBuild { get; set; }
        public Transform root { get; set; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.AI
{
    [NativeHeader("Modules/AI/Public/NavMeshBuildSettings.h")]
    public struct NavMeshBuildSettings
    {
        public int agentTypeID { get; set; }
        public float agentRadius { get; set; }
        public float agentHeight { get; set; }
        public float agentSlope { get; set; }
        public float agentClimb { get; set; }
        public float minRegionArea { get; set; }
        public bool overrideVoxelSize { get; set; }
        public float voxelSize { get; set; }
        public bool overrideTileSize { get; set; }
        public int tileSize { get; set; }
        public uint maxJobWorkers { get; set; }
        public bool preserveTilesOutsideBounds { get; set; }
        public NavMeshBuildDebugSettings debug { get; set; }

        public string[] ValidationReport(Bounds buildBounds);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.AI
{
    [NativeHeader("Modules/AI/Public/NavMeshBuildDebugSettings.h")]
    public struct NavMeshBuildDebugSettings
    {
        public NavMeshBuildDebugFlags flags { get; set; }
    }
}
using System;

namespace UnityEngine.Experimental.AI
{
    public struct PolygonId : IEquatable<PolygonId>
    {
        public bool IsNull();
        public override int GetHashCode();
        public bool Equals(PolygonId rhs);
        public override bool Equals(object obj);

        public static bool operator ==(PolygonId x, PolygonId y);
        public static bool operator !=(PolygonId x, PolygonId y);
    }
}
namespace UnityEngine.Experimental.AI
{
    public struct NavMeshLocation
    {
        public PolygonId polygon { get; }
        public Vector3 position { get; }
    }
}
using System;

namespace UnityEngine.Experimental.AI
{
    [Flags]
    public enum PathQueryStatus
    {
        Failure = -2147483648,
        Success = 1073741824,
        InProgress = 536870912,
        StatusDetailMask = 16777215,
        WrongMagic = 1,
        WrongVersion = 2,
        OutOfMemory = 4,
        InvalidParam = 8,
        BufferTooSmall = 16,
        OutOfNodes = 32,
        PartialResult = 64
    }
}
namespace UnityEngine.Experimental.AI
{
    public enum NavMeshPolyTypes
    {
        Ground = 0,
        OffMeshConnection = 1
    }
}
using Unity.Jobs;
using UnityEngine.Bindings;

namespace UnityEngine.Experimental.AI
{
    [StaticAccessor("NavMeshWorldBindings", DoubleColon)]
    public struct NavMeshWorld
    {
        public bool IsValid();
        public static NavMeshWorld GetDefaultWorld();
        public void AddDependency(JobHandle job);
    }
}
using System;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine.AI;
using UnityEngine.Bindings;

namespace UnityEngine.Experimental.AI
{
    [StaticAccessor("NavMeshQueryBindings", DoubleColon)]
    [NativeHeader("Runtime/Math/Matrix4x4.h")]
    [NativeHeader("Modules/AI/Public/NavMeshBindingTypes.h")]
    [NativeHeader("Modules/AI/NavMeshExperimental.bindings.h")]
    [NativeContainer]
    public struct NavMeshQuery : IDisposable
    {
        public NavMeshQuery(NavMeshWorld world, Allocator allocator, int pathNodePoolSize = 0);

        public void Dispose();
        public PathQueryStatus BeginFindPath(NavMeshLocation start, NavMeshLocation end, int areaMask = -1, NativeArray<float> costs = null);
        public PathQueryStatus UpdateFindPath(int iterations, out int iterationsPerformed);
        public PathQueryStatus EndFindPath(out int pathSize);
        public int GetPathResult(NativeSlice<PolygonId> path);
        public bool IsValid(PolygonId polygon);
        public bool IsValid(NavMeshLocation location);
        public int GetAgentTypeIdForPolygon(PolygonId polygon);
        public NavMeshLocation CreateLocation(Vector3 position, PolygonId polygon);
        public NavMeshLocation MapLocation(Vector3 position, Vector3 extents, int agentTypeID, int areaMask = -1);
        public void MoveLocations(NativeSlice<NavMeshLocation> locations, NativeSlice<Vector3> targets, NativeSlice<int> areaMasks);
        public void MoveLocationsInSameAreas(NativeSlice<NavMeshLocation> locations, NativeSlice<Vector3> targets, int areaMask = -1);
        public NavMeshLocation MoveLocation(NavMeshLocation location, Vector3 target, int areaMask = -1);
        public bool GetPortalPoints(PolygonId polygon, PolygonId neighbourPolygon, out Vector3 left, out Vector3 right);
        public Matrix4x4 PolygonLocalToWorldMatrix(PolygonId polygon);
        public Matrix4x4 PolygonWorldToLocalMatrix(PolygonId polygon);
        public NavMeshPolyTypes GetPolygonType(PolygonId polygon);
        public PathQueryStatus Raycast(out NavMeshHit hit, NavMeshLocation start, Vector3 targetPosition, int areaMask = -1, NativeArray<float> costs = null);
        public PathQueryStatus Raycast(out NavMeshHit hit, NativeSlice<PolygonId> path, out int pathCount, NavMeshLocation start, Vector3 targetPosition, int areaMask = -1, NativeArray<float> costs = null);
        public PathQueryStatus GetEdgesAndNeighbors(PolygonId node, NativeSlice<Vector3> edgeVertices, NativeSlice<PolygonId> neighbors, NativeSlice<byte> edgeIndices, out int verticesCount, out int neighborsCount);
    }
}
-------- {UnityEngine.ARModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.ARModule.dll)}:    2 --------
-------- {UnityEngine.AccessibilityModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.AccessibilityModule.dll)}:    2 --------
using UnityEngine.Scripting;

namespace UnityEngine.Accessibility
{
    [UsedByNativeCode]
    public static class VisionUtility
    {
        public static int GetColorBlindSafePalette(Color[] palette, float minimumLuminance, float maximumLuminance);
    }
}
-------- {UnityEngine.AndroidJNIModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.AndroidJNIModule.dll)}:   26 --------
namespace UnityEngine
{
    public delegate void AndroidJavaRunnable();
}
using System;

namespace UnityEngine
{
    public sealed class AndroidJavaException : Exception
    {
        public override string StackTrace { get; }
    }
}
namespace UnityEngine
{
    public class AndroidJavaProxy
    {
        public readonly AndroidJavaClass javaInterface;

        public AndroidJavaProxy(string javaInterface);
        public AndroidJavaProxy(AndroidJavaClass javaInterface);

        ~AndroidJavaProxy();

        public virtual AndroidJavaObject Invoke(string methodName, object[] args);
        public virtual AndroidJavaObject Invoke(string methodName, AndroidJavaObject[] javaArgs);
        public virtual bool equals(AndroidJavaObject obj);
        public virtual int hashCode();
        public virtual string toString();
    }
}
using System;

namespace UnityEngine
{
    public class AndroidJavaObject : IDisposable
    {
        public AndroidJavaObject(string className, string[] args);
        public AndroidJavaObject(string className, AndroidJavaObject[] args);
        public AndroidJavaObject(string className, AndroidJavaClass[] args);
        public AndroidJavaObject(string className, AndroidJavaProxy[] args);
        public AndroidJavaObject(string className, AndroidJavaRunnable[] args);
        public AndroidJavaObject(string className, params object[] args);

        ~AndroidJavaObject();

        public void Dispose();
        public void Call<T>(string methodName, T[] args);
        public void Call(string methodName, params object[] args);
        public void CallStatic<T>(string methodName, T[] args);
        public void CallStatic(string methodName, params object[] args);
        public FieldType Get<FieldType>(string fieldName);
        public void Set<FieldType>(string fieldName, FieldType val);
        public FieldType GetStatic<FieldType>(string fieldName);
        public void SetStatic<FieldType>(string fieldName, FieldType val);
        public IntPtr GetRawObject();
        public IntPtr GetRawClass();
        public ReturnType Call<ReturnType, T>(string methodName, T[] args);
        public ReturnType Call<ReturnType>(string methodName, params object[] args);
        public ReturnType CallStatic<ReturnType, T>(string methodName, T[] args);
        public ReturnType CallStatic<ReturnType>(string methodName, params object[] args);
        protected void DebugPrint(string msg);
        protected void DebugPrint(string call, string methodName, string signature, object[] args);
        protected virtual void Dispose(bool disposing);
        protected void _Call(string methodName, params object[] args);
        protected ReturnType _Call<ReturnType>(string methodName, params object[] args);
        protected FieldType _Get<FieldType>(string fieldName);
        protected void _Set<FieldType>(string fieldName, FieldType val);
        protected void _CallStatic(string methodName, params object[] args);
        protected ReturnType _CallStatic<ReturnType>(string methodName, params object[] args);
        protected FieldType _GetStatic<FieldType>(string fieldName);
        protected void _SetStatic<FieldType>(string fieldName, FieldType val);
        protected IntPtr _GetRawObject();
        protected IntPtr _GetRawClass();
    }
}
namespace UnityEngine
{
    public class AndroidJavaClass : AndroidJavaObject
    {
        public AndroidJavaClass(string className);
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeType(Custom, "ScriptingJvalue")]
    public struct jvalue
    {
        public bool z;
        public sbyte b;
        public char c;
        public short s;
        public int i;
        public long j;
        public float f;
        public double d;
        public IntPtr l;
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Internal;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    [NativeHeader("Modules/AndroidJNI/Public/AndroidJNIBindingsHelpers.h")]
    [NativeConditional("PLATFORM_ANDROID")]
    [StaticAccessor("AndroidJNIBindingsHelpers", DoubleColon)]
    public static class AndroidJNIHelper
    {
        public static bool debug { get; set; }

        public static IntPtr GetConstructorID(IntPtr javaClass);
        public static IntPtr GetConstructorID(IntPtr javaClass, [DefaultValue("")] string signature);
        public static IntPtr GetMethodID(IntPtr javaClass, string methodName);
        public static IntPtr GetMethodID(IntPtr javaClass, string methodName, [DefaultValue("")] string signature);
        public static IntPtr GetMethodID(IntPtr javaClass, string methodName, [DefaultValue("")] string signature, [DefaultValue("false")] bool isStatic);
        public static IntPtr GetFieldID(IntPtr javaClass, string fieldName);
        public static IntPtr GetFieldID(IntPtr javaClass, string fieldName, [DefaultValue("")] string signature);
        public static IntPtr GetFieldID(IntPtr javaClass, string fieldName, [DefaultValue("")] string signature, [DefaultValue("false")] bool isStatic);
        public static IntPtr CreateJavaRunnable(AndroidJavaRunnable jrunnable);
        public static IntPtr CreateJavaProxy(AndroidJavaProxy proxy);
        public static IntPtr ConvertToJNIArray(Array array);
        public static jvalue[] CreateJNIArgArray(object[] args);
        public static void DeleteJNIArgArray(object[] args, jvalue[] jniArgs);
        public static IntPtr GetConstructorID(IntPtr jclass, object[] args);
        public static IntPtr GetMethodID(IntPtr jclass, string methodName, object[] args, bool isStatic);
        public static string GetSignature(object obj);
        public static string GetSignature(object[] args);
        public static ArrayType ConvertFromJNIArray<ArrayType>(IntPtr array);
        public static IntPtr GetMethodID<ReturnType>(IntPtr jclass, string methodName, object[] args, bool isStatic);
        public static IntPtr GetFieldID<FieldType>(IntPtr jclass, string fieldName, bool isStatic);
        public static string GetSignature<ReturnType>(object[] args);
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeConditional("PLATFORM_ANDROID")]
    [NativeHeader("Modules/AndroidJNI/Public/AndroidJNIBindingsHelpers.h")]
    [StaticAccessor("AndroidJNIBindingsHelpers", DoubleColon)]
    public static class AndroidJNI
    {
        [ThreadSafe]
        public static int AttachCurrentThread();
        [ThreadSafe]
        public static int DetachCurrentThread();
        [ThreadSafe]
        public static int GetVersion();
        [ThreadSafe]
        public static IntPtr FindClass(string name);
        [ThreadSafe]
        public static IntPtr FromReflectedMethod(IntPtr refMethod);
        [ThreadSafe]
        public static IntPtr FromReflectedField(IntPtr refField);
        [ThreadSafe]
        public static IntPtr ToReflectedMethod(IntPtr clazz, IntPtr methodID, bool isStatic);
        [ThreadSafe]
        public static IntPtr ToReflectedField(IntPtr clazz, IntPtr fieldID, bool isStatic);
        [ThreadSafe]
        public static IntPtr GetSuperclass(IntPtr clazz);
        [ThreadSafe]
        public static bool IsAssignableFrom(IntPtr clazz1, IntPtr clazz2);
        [ThreadSafe]
        public static int Throw(IntPtr obj);
        [ThreadSafe]
        public static int ThrowNew(IntPtr clazz, string message);
        [ThreadSafe]
        public static IntPtr ExceptionOccurred();
        [ThreadSafe]
        public static void ExceptionDescribe();
        [ThreadSafe]
        public static void ExceptionClear();
        [ThreadSafe]
        public static void FatalError(string message);
        [ThreadSafe]
        public static int PushLocalFrame(int capacity);
        [ThreadSafe]
        public static IntPtr PopLocalFrame(IntPtr ptr);
        [ThreadSafe]
        public static IntPtr NewGlobalRef(IntPtr obj);
        [ThreadSafe]
        public static void DeleteGlobalRef(IntPtr obj);
        [ThreadSafe]
        public static IntPtr NewWeakGlobalRef(IntPtr obj);
        [ThreadSafe]
        public static void DeleteWeakGlobalRef(IntPtr obj);
        [ThreadSafe]
        public static IntPtr NewLocalRef(IntPtr obj);
        [ThreadSafe]
        public static void DeleteLocalRef(IntPtr obj);
        [ThreadSafe]
        public static bool IsSameObject(IntPtr obj1, IntPtr obj2);
        [ThreadSafe]
        public static int EnsureLocalCapacity(int capacity);
        [ThreadSafe]
        public static IntPtr AllocObject(IntPtr clazz);
        [ThreadSafe]
        public static IntPtr NewObject(IntPtr clazz, IntPtr methodID, jvalue[] args);
        [ThreadSafe]
        public static IntPtr GetObjectClass(IntPtr obj);
        [ThreadSafe]
        public static bool IsInstanceOf(IntPtr obj, IntPtr clazz);
        [ThreadSafe]
        public static IntPtr GetMethodID(IntPtr clazz, string name, string sig);
        [ThreadSafe]
        public static IntPtr GetFieldID(IntPtr clazz, string name, string sig);
        [ThreadSafe]
        public static IntPtr GetStaticMethodID(IntPtr clazz, string name, string sig);
        [ThreadSafe]
        public static IntPtr GetStaticFieldID(IntPtr clazz, string name, string sig);
        public static IntPtr NewString(string chars);
        [ThreadSafe]
        public static IntPtr NewString(char[] chars);
        [ThreadSafe]
        public static IntPtr NewStringUTF(string bytes);
        [ThreadSafe]
        public static string GetStringChars(IntPtr str);
        [ThreadSafe]
        public static int GetStringLength(IntPtr str);
        [ThreadSafe]
        public static int GetStringUTFLength(IntPtr str);
        [ThreadSafe]
        public static string GetStringUTFChars(IntPtr str);
        [ThreadSafe]
        public static string CallStringMethod(IntPtr obj, IntPtr methodID, jvalue[] args);
        [ThreadSafe]
        public static IntPtr CallObjectMethod(IntPtr obj, IntPtr methodID, jvalue[] args);
        [ThreadSafe]
        public static int CallIntMethod(IntPtr obj, IntPtr methodID, jvalue[] args);
        [ThreadSafe]
        public static bool CallBooleanMethod(IntPtr obj, IntPtr methodID, jvalue[] args);
        [ThreadSafe]
        public static short CallShortMethod(IntPtr obj, IntPtr methodID, jvalue[] args);
        [Obsolete("AndroidJNI.CallByteMethod is obsolete. Use AndroidJNI.CallSByteMethod method instead")]
        public static byte CallByteMethod(IntPtr obj, IntPtr methodID, jvalue[] args);
        [ThreadSafe]
        public static sbyte CallSByteMethod(IntPtr obj, IntPtr methodID, jvalue[] args);
        [ThreadSafe]
        public static char CallCharMethod(IntPtr obj, IntPtr methodID, jvalue[] args);
        [ThreadSafe]
        public static float CallFloatMethod(IntPtr obj, IntPtr methodID, jvalue[] args);
        [ThreadSafe]
        public static double CallDoubleMethod(IntPtr obj, IntPtr methodID, jvalue[] args);
        [ThreadSafe]
        public static long CallLongMethod(IntPtr obj, IntPtr methodID, jvalue[] args);
        [ThreadSafe]
        public static void CallVoidMethod(IntPtr obj, IntPtr methodID, jvalue[] args);
        [ThreadSafe]
        public static string GetStringField(IntPtr obj, IntPtr fieldID);
        [ThreadSafe]
        public static IntPtr GetObjectField(IntPtr obj, IntPtr fieldID);
        [ThreadSafe]
        public static bool GetBooleanField(IntPtr obj, IntPtr fieldID);
        [Obsolete("AndroidJNI.GetByteField is obsolete. Use AndroidJNI.GetSByteField method instead")]
        public static byte GetByteField(IntPtr obj, IntPtr fieldID);
        [ThreadSafe]
        public static sbyte GetSByteField(IntPtr obj, IntPtr fieldID);
        [ThreadSafe]
        public static char GetCharField(IntPtr obj, IntPtr fieldID);
        [ThreadSafe]
        public static short GetShortField(IntPtr obj, IntPtr fieldID);
        [ThreadSafe]
        public static int GetIntField(IntPtr obj, IntPtr fieldID);
        [ThreadSafe]
        public static long GetLongField(IntPtr obj, IntPtr fieldID);
        [ThreadSafe]
        public static float GetFloatField(IntPtr obj, IntPtr fieldID);
        [ThreadSafe]
        public static double GetDoubleField(IntPtr obj, IntPtr fieldID);
        [ThreadSafe]
        public static void SetStringField(IntPtr obj, IntPtr fieldID, string val);
        [ThreadSafe]
        public static void SetObjectField(IntPtr obj, IntPtr fieldID, IntPtr val);
        [ThreadSafe]
        public static void SetBooleanField(IntPtr obj, IntPtr fieldID, bool val);
        [Obsolete("AndroidJNI.SetByteField is obsolete. Use AndroidJNI.SetSByteField method instead")]
        public static void SetByteField(IntPtr obj, IntPtr fieldID, byte val);
        [ThreadSafe]
        public static void SetSByteField(IntPtr obj, IntPtr fieldID, sbyte val);
        [ThreadSafe]
        public static void SetCharField(IntPtr obj, IntPtr fieldID, char val);
        [ThreadSafe]
        public static void SetShortField(IntPtr obj, IntPtr fieldID, short val);
        [ThreadSafe]
        public static void SetIntField(IntPtr obj, IntPtr fieldID, int val);
        [ThreadSafe]
        public static void SetLongField(IntPtr obj, IntPtr fieldID, long val);
        [ThreadSafe]
        public static void SetFloatField(IntPtr obj, IntPtr fieldID, float val);
        [ThreadSafe]
        public static void SetDoubleField(IntPtr obj, IntPtr fieldID, double val);
        [ThreadSafe]
        public static string CallStaticStringMethod(IntPtr clazz, IntPtr methodID, jvalue[] args);
        [ThreadSafe]
        public static IntPtr CallStaticObjectMethod(IntPtr clazz, IntPtr methodID, jvalue[] args);
        [ThreadSafe]
        public static int CallStaticIntMethod(IntPtr clazz, IntPtr methodID, jvalue[] args);
        [ThreadSafe]
        public static bool CallStaticBooleanMethod(IntPtr clazz, IntPtr methodID, jvalue[] args);
        [ThreadSafe]
        public static short CallStaticShortMethod(IntPtr clazz, IntPtr methodID, jvalue[] args);
        [Obsolete("AndroidJNI.CallStaticByteMethod is obsolete. Use AndroidJNI.CallStaticSByteMethod method instead")]
        public static byte CallStaticByteMethod(IntPtr clazz, IntPtr methodID, jvalue[] args);
        [ThreadSafe]
        public static sbyte CallStaticSByteMethod(IntPtr clazz, IntPtr methodID, jvalue[] args);
        [ThreadSafe]
        public static char CallStaticCharMethod(IntPtr clazz, IntPtr methodID, jvalue[] args);
        [ThreadSafe]
        public static float CallStaticFloatMethod(IntPtr clazz, IntPtr methodID, jvalue[] args);
        [ThreadSafe]
        public static double CallStaticDoubleMethod(IntPtr clazz, IntPtr methodID, jvalue[] args);
        [ThreadSafe]
        public static long CallStaticLongMethod(IntPtr clazz, IntPtr methodID, jvalue[] args);
        [ThreadSafe]
        public static void CallStaticVoidMethod(IntPtr clazz, IntPtr methodID, jvalue[] args);
        [ThreadSafe]
        public static string GetStaticStringField(IntPtr clazz, IntPtr fieldID);
        [ThreadSafe]
        public static IntPtr GetStaticObjectField(IntPtr clazz, IntPtr fieldID);
        [ThreadSafe]
        public static bool GetStaticBooleanField(IntPtr clazz, IntPtr fieldID);
        [Obsolete("AndroidJNI.GetStaticByteField is obsolete. Use AndroidJNI.GetStaticSByteField method instead")]
        public static byte GetStaticByteField(IntPtr clazz, IntPtr fieldID);
        [ThreadSafe]
        public static sbyte GetStaticSByteField(IntPtr clazz, IntPtr fieldID);
        [ThreadSafe]
        public static char GetStaticCharField(IntPtr clazz, IntPtr fieldID);
        [ThreadSafe]
        public static short GetStaticShortField(IntPtr clazz, IntPtr fieldID);
        [ThreadSafe]
        public static int GetStaticIntField(IntPtr clazz, IntPtr fieldID);
        [ThreadSafe]
        public static long GetStaticLongField(IntPtr clazz, IntPtr fieldID);
        [ThreadSafe]
        public static float GetStaticFloatField(IntPtr clazz, IntPtr fieldID);
        [ThreadSafe]
        public static double GetStaticDoubleField(IntPtr clazz, IntPtr fieldID);
        [ThreadSafe]
        public static void SetStaticStringField(IntPtr clazz, IntPtr fieldID, string val);
        [ThreadSafe]
        public static void SetStaticObjectField(IntPtr clazz, IntPtr fieldID, IntPtr val);
        [ThreadSafe]
        public static void SetStaticBooleanField(IntPtr clazz, IntPtr fieldID, bool val);
        [Obsolete("AndroidJNI.SetStaticByteField is obsolete. Use AndroidJNI.SetStaticSByteField method instead")]
        public static void SetStaticByteField(IntPtr clazz, IntPtr fieldID, byte val);
        [ThreadSafe]
        public static void SetStaticSByteField(IntPtr clazz, IntPtr fieldID, sbyte val);
        [ThreadSafe]
        public static void SetStaticCharField(IntPtr clazz, IntPtr fieldID, char val);
        [ThreadSafe]
        public static void SetStaticShortField(IntPtr clazz, IntPtr fieldID, short val);
        [ThreadSafe]
        public static void SetStaticIntField(IntPtr clazz, IntPtr fieldID, int val);
        [ThreadSafe]
        public static void SetStaticLongField(IntPtr clazz, IntPtr fieldID, long val);
        [ThreadSafe]
        public static void SetStaticFloatField(IntPtr clazz, IntPtr fieldID, float val);
        [ThreadSafe]
        public static void SetStaticDoubleField(IntPtr clazz, IntPtr fieldID, double val);
        [ThreadSafe]
        public static IntPtr ToBooleanArray(bool[] array);
        [Obsolete("AndroidJNI.ToByteArray is obsolete. Use AndroidJNI.ToSByteArray method instead")]
        [ThreadSafe]
        public static IntPtr ToByteArray(byte[] array);
        [ThreadSafe]
        public static IntPtr ToSByteArray(sbyte[] array);
        [ThreadSafe]
        public static IntPtr ToCharArray(char[] array);
        [ThreadSafe]
        public static IntPtr ToShortArray(short[] array);
        [ThreadSafe]
        public static IntPtr ToIntArray(int[] array);
        [ThreadSafe]
        public static IntPtr ToLongArray(long[] array);
        [ThreadSafe]
        public static IntPtr ToFloatArray(float[] array);
        [ThreadSafe]
        public static IntPtr ToDoubleArray(double[] array);
        [ThreadSafe]
        public static IntPtr ToObjectArray(IntPtr[] array, IntPtr arrayClass);
        public static IntPtr ToObjectArray(IntPtr[] array);
        [ThreadSafe]
        public static bool[] FromBooleanArray(IntPtr array);
        [ThreadSafe]
        [Obsolete("AndroidJNI.FromByteArray is obsolete. Use AndroidJNI.FromSByteArray method instead")]
        public static byte[] FromByteArray(IntPtr array);
        [ThreadSafe]
        public static sbyte[] FromSByteArray(IntPtr array);
        [ThreadSafe]
        public static char[] FromCharArray(IntPtr array);
        [ThreadSafe]
        public static short[] FromShortArray(IntPtr array);
        [ThreadSafe]
        public static int[] FromIntArray(IntPtr array);
        [ThreadSafe]
        public static long[] FromLongArray(IntPtr array);
        [ThreadSafe]
        public static float[] FromFloatArray(IntPtr array);
        [ThreadSafe]
        public static double[] FromDoubleArray(IntPtr array);
        [ThreadSafe]
        public static IntPtr[] FromObjectArray(IntPtr array);
        [ThreadSafe]
        public static int GetArrayLength(IntPtr array);
        [ThreadSafe]
        public static IntPtr NewBooleanArray(int size);
        [Obsolete("AndroidJNI.NewByteArray is obsolete. Use AndroidJNI.NewSByteArray method instead")]
        public static IntPtr NewByteArray(int size);
        [ThreadSafe]
        public static IntPtr NewSByteArray(int size);
        [ThreadSafe]
        public static IntPtr NewCharArray(int size);
        [ThreadSafe]
        public static IntPtr NewShortArray(int size);
        [ThreadSafe]
        public static IntPtr NewIntArray(int size);
        [ThreadSafe]
        public static IntPtr NewLongArray(int size);
        [ThreadSafe]
        public static IntPtr NewFloatArray(int size);
        [ThreadSafe]
        public static IntPtr NewDoubleArray(int size);
        [ThreadSafe]
        public static IntPtr NewObjectArray(int size, IntPtr clazz, IntPtr obj);
        [ThreadSafe]
        public static bool GetBooleanArrayElement(IntPtr array, int index);
        [Obsolete("AndroidJNI.GetByteArrayElement is obsolete. Use AndroidJNI.GetSByteArrayElement method instead")]
        public static byte GetByteArrayElement(IntPtr array, int index);
        [ThreadSafe]
        public static sbyte GetSByteArrayElement(IntPtr array, int index);
        [ThreadSafe]
        public static char GetCharArrayElement(IntPtr array, int index);
        [ThreadSafe]
        public static short GetShortArrayElement(IntPtr array, int index);
        [ThreadSafe]
        public static int GetIntArrayElement(IntPtr array, int index);
        [ThreadSafe]
        public static long GetLongArrayElement(IntPtr array, int index);
        [ThreadSafe]
        public static float GetFloatArrayElement(IntPtr array, int index);
        [ThreadSafe]
        public static double GetDoubleArrayElement(IntPtr array, int index);
        [ThreadSafe]
        public static IntPtr GetObjectArrayElement(IntPtr array, int index);
        [Obsolete("AndroidJNI.SetBooleanArrayElement(IntPtr, int, byte) is obsolete. Use AndroidJNI.SetBooleanArrayElement(IntPtr, int, bool) method instead")]
        public static void SetBooleanArrayElement(IntPtr array, int index, byte val);
        [ThreadSafe]
        public static void SetBooleanArrayElement(IntPtr array, int index, bool val);
        [Obsolete("AndroidJNI.SetByteArrayElement is obsolete. Use AndroidJNI.SetSByteArrayElement method instead")]
        public static void SetByteArrayElement(IntPtr array, int index, sbyte val);
        [ThreadSafe]
        public static void SetSByteArrayElement(IntPtr array, int index, sbyte val);
        [ThreadSafe]
        public static void SetCharArrayElement(IntPtr array, int index, char val);
        [ThreadSafe]
        public static void SetShortArrayElement(IntPtr array, int index, short val);
        [ThreadSafe]
        public static void SetIntArrayElement(IntPtr array, int index, int val);
        [ThreadSafe]
        public static void SetLongArrayElement(IntPtr array, int index, long val);
        [ThreadSafe]
        public static void SetFloatArrayElement(IntPtr array, int index, float val);
        [ThreadSafe]
        public static void SetDoubleArrayElement(IntPtr array, int index, double val);
        [ThreadSafe]
        public static void SetObjectArrayElement(IntPtr array, int index, IntPtr obj);
    }
}
namespace UnityEngine.Android
{
    public enum AndroidAssetPackStatus
    {
        Unknown = 0,
        Pending = 1,
        Downloading = 2,
        Transferring = 3,
        Completed = 4,
        Failed = 5,
        Canceled = 6,
        WaitingForWifi = 7,
        NotInstalled = 8
    }
}
namespace UnityEngine.Android
{
    public enum AndroidAssetPackError
    {
        NoError = 0,
        AppUnavailable = -1,
        PackUnavailable = -2,
        InvalidRequest = -3,
        DownloadNotFound = -4,
        ApiNotAvailable = -5,
        NetworkError = -6,
        AccessDenied = -7,
        InsufficientStorage = -10,
        PlayStoreNotFound = -11,
        NetworkUnrestricted = -12,
        AppNotOwned = -13,
        InternalError = -100
    }
}
namespace UnityEngine.Android
{
    public class AndroidAssetPackInfo
    {
        public string name { get; }
        public AndroidAssetPackStatus status { get; }
        public ulong size { get; }
        public ulong bytesDownloaded { get; }
        public float transferProgress { get; }
        public AndroidAssetPackError error { get; }
    }
}
namespace UnityEngine.Android
{
    public class AndroidAssetPackState
    {
        public string name { get; }
        public AndroidAssetPackStatus status { get; }
        public AndroidAssetPackError error { get; }
    }
}
namespace UnityEngine.Android
{
    public class AndroidAssetPackUseMobileDataRequestResult
    {
        public bool allowed { get; }
    }
}
namespace UnityEngine.Android
{
    public class DownloadAssetPackAsyncOperation : CustomYieldInstruction
    {
        public override bool keepWaiting { get; }
        public bool isDone { get; }
        public float progress { get; }
        public string[] downloadedAssetPacks { get; }
        public string[] downloadFailedAssetPacks { get; }
    }
}
namespace UnityEngine.Android
{
    public class GetAssetPackStateAsyncOperation : CustomYieldInstruction
    {
        public override bool keepWaiting { get; }
        public bool isDone { get; }
        public ulong size { get; }
        public AndroidAssetPackState[] states { get; }
    }
}
namespace UnityEngine.Android
{
    public class RequestToUseMobileDataAsyncOperation : CustomYieldInstruction
    {
        public override bool keepWaiting { get; }
        public bool isDone { get; }
        public AndroidAssetPackUseMobileDataRequestResult result { get; }
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEngine.Android
{
    [StaticAccessor("AndroidAssetPacksBindingsHelpers", DoubleColon)]
    [NativeHeader("Modules/AndroidJNI/Public/AndroidAssetPacksBindingsHelpers.h")]
    public static class AndroidAssetPacks
    {
        public static bool coreUnityAssetPacksDownloaded { get; }

        public static string[] GetCoreUnityAssetPackNames();
        public static void GetAssetPackStateAsync(string[] assetPackNames, Action<ulong, AndroidAssetPackState[]> callback);
        public static GetAssetPackStateAsyncOperation GetAssetPackStateAsync(string[] assetPackNames);
        public static void DownloadAssetPackAsync(string[] assetPackNames, Action<AndroidAssetPackInfo> callback);
        public static DownloadAssetPackAsyncOperation DownloadAssetPackAsync(string[] assetPackNames);
        public static void RequestToUseMobileDataAsync(Action<AndroidAssetPackUseMobileDataRequestResult> callback);
        public static RequestToUseMobileDataAsyncOperation RequestToUseMobileDataAsync();
        public static string GetAssetPackPath(string assetPackName);
        public static void CancelAssetPackDownload(string[] assetPackNames);
        public static void RemoveAssetPack(string assetPackName);
    }
}
namespace UnityEngine.Android
{
    public enum AndroidHardwareType
    {
        Generic = 0,
        ChromeOS = 1
    }
}
namespace UnityEngine.Android
{
    public class AndroidDevice
    {
        public AndroidDevice();

        public static AndroidHardwareType hardwareType { get; }

        public static void SetSustainedPerformanceMode(bool enabled);
    }
}
using System;

namespace UnityEngine.Android
{
    public class PermissionCallbacks : AndroidJavaProxy
    {
        public PermissionCallbacks();

        public event Action<string> PermissionGranted;
        public event Action<string> PermissionDenied;
        public event Action<string> PermissionDeniedAndDontAskAgain;
    }
}
namespace UnityEngine.Android
{
    public struct Permission
    {
        public const string Camera = "android.permission.CAMERA";
        public const string Microphone = "android.permission.RECORD_AUDIO";
        public const string FineLocation = "android.permission.ACCESS_FINE_LOCATION";
        public const string CoarseLocation = "android.permission.ACCESS_COARSE_LOCATION";
        public const string ExternalStorageRead = "android.permission.READ_EXTERNAL_STORAGE";
        public const string ExternalStorageWrite = "android.permission.WRITE_EXTERNAL_STORAGE";

        public static bool HasUserAuthorizedPermission(string permission);
        public static void RequestUserPermission(string permission);
        public static void RequestUserPermissions(string[] permissions);
        public static void RequestUserPermission(string permission, PermissionCallbacks callbacks);
        public static void RequestUserPermissions(string[] permissions, PermissionCallbacks callbacks);
    }
}
-------- {UnityEngine.AnimationModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.AnimationModule.dll)}:  114 --------
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [EditorBrowsable(Never)]
    [Obsolete("Use AnimatorClipInfo instead (UnityUpgradable) -> AnimatorClipInfo", True)]
    public struct AnimationInfo
    {
        public AnimationClip clip { get; }
        public float weight { get; }
    }
}
using System;
using System.Collections.Generic;
using System.ComponentModel;
using UnityEngine.Bindings;
using UnityEngine.Internal;
using UnityEngine.Playables;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    [NativeHeader("Modules/Animation/ScriptBindings/AnimatorControllerParameter.bindings.h")]
    [NativeHeader("Modules/Animation/ScriptBindings/Animator.bindings.h")]
    [NativeHeader("Modules/Animation/Animator.h")]
    public class Animator : Behaviour
    {
        public Animator();

        public bool isOptimizable { get; }
        public bool isHuman { get; }
        public bool hasRootMotion { get; }
        public float humanScale { get; }
        public bool isInitialized { get; }
        public Vector3 deltaPosition { get; }
        public Quaternion deltaRotation { get; }
        public Vector3 velocity { get; }
        public Vector3 angularVelocity { get; }
        public Vector3 rootPosition { get; set; }
        public Quaternion rootRotation { get; set; }
        public bool applyRootMotion { get; set; }
        [Obsolete("Animator.linearVelocityBlending is no longer used and has been deprecated.")]
        public bool linearVelocityBlending { get; set; }
        [Obsolete("Animator.animatePhysics has been deprecated. Use Animator.updateMode instead.")]
        public bool animatePhysics { get; set; }
        public AnimatorUpdateMode updateMode { get; set; }
        public bool hasTransformHierarchy { get; }
        public float gravityWeight { get; }
        public Vector3 bodyPosition { get; set; }
        public Quaternion bodyRotation { get; set; }
        public bool stabilizeFeet { get; set; }
        public int layerCount { get; }
        public AnimatorControllerParameter[] parameters { get; }
        public int parameterCount { get; }
        public float feetPivotActive { get; set; }
        public float pivotWeight { get; }
        public Vector3 pivotPosition { get; }
        public bool isMatchingTarget { get; }
        public float speed { get; set; }
        public Vector3 targetPosition { get; }
        public Quaternion targetRotation { get; }
        public AnimatorCullingMode cullingMode { get; set; }
        public float playbackTime { get; set; }
        public float recorderStartTime { get; set; }
        public float recorderStopTime { get; set; }
        public AnimatorRecorderMode recorderMode { get; }
        public RuntimeAnimatorController runtimeAnimatorController { get; set; }
        public bool hasBoundPlayables { get; }
        public Avatar avatar { get; set; }
        public PlayableGraph playableGraph { get; }
        public bool layersAffectMassCenter { get; set; }
        public float leftFeetBottomHeight { get; }
        public float rightFeetBottomHeight { get; }
        public bool logWarnings { get; set; }
        public bool fireEvents { get; set; }
        public bool keepAnimatorControllerStateOnDisable { get; set; }

        [EditorBrowsable(Never)]
        [Obsolete("GetCurrentAnimationClipState is obsolete. Use GetCurrentAnimatorClipInfo instead (UnityUpgradable) -> GetCurrentAnimatorClipInfo(*)", True)]
        public AnimationInfo[] GetCurrentAnimationClipState(int layerIndex);
        [Obsolete("GetNextAnimationClipState is obsolete. Use GetNextAnimatorClipInfo instead (UnityUpgradable) -> GetNextAnimatorClipInfo(*)", True)]
        [EditorBrowsable(Never)]
        public AnimationInfo[] GetNextAnimationClipState(int layerIndex);
        [EditorBrowsable(Never)]
        [Obsolete("Stop is obsolete. Use Animator.enabled = false instead", True)]
        public void Stop();
        public float GetFloat(string name);
        public float GetFloat(int id);
        public void SetFloat(string name, float value);
        public void SetFloat(string name, float value, float dampTime, float deltaTime);
        public void SetFloat(int id, float value);
        public void SetFloat(int id, float value, float dampTime, float deltaTime);
        public bool GetBool(string name);
        public bool GetBool(int id);
        public void SetBool(string name, bool value);
        public void SetBool(int id, bool value);
        public int GetInteger(string name);
        public int GetInteger(int id);
        public void SetInteger(string name, int value);
        public void SetInteger(int id, int value);
        public void SetTrigger(string name);
        public void SetTrigger(int id);
        public void ResetTrigger(string name);
        public void ResetTrigger(int id);
        public bool IsParameterControlledByCurve(string name);
        public bool IsParameterControlledByCurve(int id);
        public Vector3 GetIKPosition(AvatarIKGoal goal);
        public void SetIKPosition(AvatarIKGoal goal, Vector3 goalPosition);
        public Quaternion GetIKRotation(AvatarIKGoal goal);
        public void SetIKRotation(AvatarIKGoal goal, Quaternion goalRotation);
        public float GetIKPositionWeight(AvatarIKGoal goal);
        public void SetIKPositionWeight(AvatarIKGoal goal, float value);
        public float GetIKRotationWeight(AvatarIKGoal goal);
        public void SetIKRotationWeight(AvatarIKGoal goal, float value);
        public Vector3 GetIKHintPosition(AvatarIKHint hint);
        public void SetIKHintPosition(AvatarIKHint hint, Vector3 hintPosition);
        public float GetIKHintPositionWeight(AvatarIKHint hint);
        public void SetIKHintPositionWeight(AvatarIKHint hint, float value);
        public void SetLookAtPosition(Vector3 lookAtPosition);
        public void SetLookAtWeight(float weight);
        public void SetLookAtWeight(float weight, float bodyWeight);
        public void SetLookAtWeight(float weight, float bodyWeight, float headWeight);
        public void SetLookAtWeight(float weight, float bodyWeight, float headWeight, float eyesWeight);
        public void SetLookAtWeight(float weight, [UnityEngine.Internal.DefaultValue("0.0f")] float bodyWeight, [UnityEngine.Internal.DefaultValue("1.0f")] float headWeight, [UnityEngine.Internal.DefaultValue("0.0f")] float eyesWeight, [UnityEngine.Internal.DefaultValue("0.5f")] float clampWeight);
        public void SetBoneLocalRotation(HumanBodyBones humanBoneId, Quaternion rotation);
        public T GetBehaviour<T>() where T : StateMachineBehaviour;
        public T[] GetBehaviours<T>() where T : StateMachineBehaviour;
        public StateMachineBehaviour[] GetBehaviours(int fullPathHash, int layerIndex);
        public string GetLayerName(int layerIndex);
        public int GetLayerIndex(string layerName);
        public float GetLayerWeight(int layerIndex);
        public void SetLayerWeight(int layerIndex, float weight);
        public AnimatorStateInfo GetCurrentAnimatorStateInfo(int layerIndex);
        public AnimatorStateInfo GetNextAnimatorStateInfo(int layerIndex);
        public AnimatorTransitionInfo GetAnimatorTransitionInfo(int layerIndex);
        public int GetCurrentAnimatorClipInfoCount(int layerIndex);
        public int GetNextAnimatorClipInfoCount(int layerIndex);
        [FreeFunction(Name = "AnimatorBindings::GetCurrentAnimatorClipInfo", HasExplicitThis = True)]
        public AnimatorClipInfo[] GetCurrentAnimatorClipInfo(int layerIndex);
        [FreeFunction(Name = "AnimatorBindings::GetNextAnimatorClipInfo", HasExplicitThis = True)]
        public AnimatorClipInfo[] GetNextAnimatorClipInfo(int layerIndex);
        public void GetCurrentAnimatorClipInfo(int layerIndex, List<AnimatorClipInfo> clips);
        public void GetNextAnimatorClipInfo(int layerIndex, List<AnimatorClipInfo> clips);
        public bool IsInTransition(int layerIndex);
        public AnimatorControllerParameter GetParameter(int index);
        public void MatchTarget(Vector3 matchPosition, Quaternion matchRotation, AvatarTarget targetBodyPart, MatchTargetWeightMask weightMask, float startNormalizedTime);
        public void MatchTarget(Vector3 matchPosition, Quaternion matchRotation, AvatarTarget targetBodyPart, MatchTargetWeightMask weightMask, float startNormalizedTime, [UnityEngine.Internal.DefaultValue("1")] float targetNormalizedTime);
        public void MatchTarget(Vector3 matchPosition, Quaternion matchRotation, AvatarTarget targetBodyPart, MatchTargetWeightMask weightMask, float startNormalizedTime, [UnityEngine.Internal.DefaultValue("1")] float targetNormalizedTime, [UnityEngine.Internal.DefaultValue("true")] bool completeMatch);
        public void InterruptMatchTarget();
        public void InterruptMatchTarget([UnityEngine.Internal.DefaultValue("true")] bool completeMatch);
        [Obsolete("ForceStateNormalizedTime is deprecated. Please use Play or CrossFade instead.")]
        public void ForceStateNormalizedTime(float normalizedTime);
        public void CrossFadeInFixedTime(string stateName, float fixedTransitionDuration);
        public void CrossFadeInFixedTime(string stateName, float fixedTransitionDuration, int layer);
        public void CrossFadeInFixedTime(string stateName, float fixedTransitionDuration, int layer, float fixedTimeOffset);
        public void CrossFadeInFixedTime(string stateName, float fixedTransitionDuration, [UnityEngine.Internal.DefaultValue("-1")] int layer, [UnityEngine.Internal.DefaultValue("0.0f")] float fixedTimeOffset, [UnityEngine.Internal.DefaultValue("0.0f")] float normalizedTransitionTime);
        public void CrossFadeInFixedTime(int stateHashName, float fixedTransitionDuration, int layer, float fixedTimeOffset);
        public void CrossFadeInFixedTime(int stateHashName, float fixedTransitionDuration, int layer);
        public void CrossFadeInFixedTime(int stateHashName, float fixedTransitionDuration);
        [FreeFunction(Name = "AnimatorBindings::CrossFadeInFixedTime", HasExplicitThis = True)]
        public void CrossFadeInFixedTime(int stateHashName, float fixedTransitionDuration, [UnityEngine.Internal.DefaultValue("-1")] int layer, [UnityEngine.Internal.DefaultValue("0.0f")] float fixedTimeOffset, [UnityEngine.Internal.DefaultValue("0.0f")] float normalizedTransitionTime);
        [FreeFunction(Name = "AnimatorBindings::WriteDefaultValues", HasExplicitThis = True)]
        public void WriteDefaultValues();
        public void CrossFade(string stateName, float normalizedTransitionDuration, int layer, float normalizedTimeOffset);
        public void CrossFade(string stateName, float normalizedTransitionDuration, int layer);
        public void CrossFade(string stateName, float normalizedTransitionDuration);
        public void CrossFade(string stateName, float normalizedTransitionDuration, [UnityEngine.Internal.DefaultValue("-1")] int layer, [UnityEngine.Internal.DefaultValue("float.NegativeInfinity")] float normalizedTimeOffset, [UnityEngine.Internal.DefaultValue("0.0f")] float normalizedTransitionTime);
        [FreeFunction(Name = "AnimatorBindings::CrossFade", HasExplicitThis = True)]
        public void CrossFade(int stateHashName, float normalizedTransitionDuration, [UnityEngine.Internal.DefaultValue("-1")] int layer, [UnityEngine.Internal.DefaultValue("0.0f")] float normalizedTimeOffset, [UnityEngine.Internal.DefaultValue("0.0f")] float normalizedTransitionTime);
        public void CrossFade(int stateHashName, float normalizedTransitionDuration, int layer, float normalizedTimeOffset);
        public void CrossFade(int stateHashName, float normalizedTransitionDuration, int layer);
        public void CrossFade(int stateHashName, float normalizedTransitionDuration);
        public void PlayInFixedTime(string stateName, int layer);
        public void PlayInFixedTime(string stateName);
        public void PlayInFixedTime(string stateName, [UnityEngine.Internal.DefaultValue("-1")] int layer, [UnityEngine.Internal.DefaultValue("float.NegativeInfinity")] float fixedTime);
        [FreeFunction(Name = "AnimatorBindings::PlayInFixedTime", HasExplicitThis = True)]
        public void PlayInFixedTime(int stateNameHash, [UnityEngine.Internal.DefaultValue("-1")] int layer, [UnityEngine.Internal.DefaultValue("float.NegativeInfinity")] float fixedTime);
        public void PlayInFixedTime(int stateNameHash, int layer);
        public void PlayInFixedTime(int stateNameHash);
        public void Play(string stateName, int layer);
        public void Play(string stateName);
        public void Play(string stateName, [UnityEngine.Internal.DefaultValue("-1")] int layer, [UnityEngine.Internal.DefaultValue("float.NegativeInfinity")] float normalizedTime);
        [FreeFunction(Name = "AnimatorBindings::Play", HasExplicitThis = True)]
        public void Play(int stateNameHash, [UnityEngine.Internal.DefaultValue("-1")] int layer, [UnityEngine.Internal.DefaultValue("float.NegativeInfinity")] float normalizedTime);
        public void Play(int stateNameHash, int layer);
        public void Play(int stateNameHash);
        public void SetTarget(AvatarTarget targetIndex, float targetNormalizedTime);
        [EditorBrowsable(Never)]
        [Obsolete("Use mask and layers to control subset of transfroms in a skeleton.", True)]
        public bool IsControlled(Transform transform);
        public Transform GetBoneTransform(HumanBodyBones humanBoneId);
        public void StartPlayback();
        public void StopPlayback();
        public void StartRecording(int frameCount);
        public void StopRecording();
        public bool HasState(int layerIndex, int stateID);
        [NativeMethod(Name = "ScriptingStringToCRC32", IsThreadSafe = True)]
        public static int StringToHash(string name);
        [NativeMethod("UpdateWithDelta")]
        public void Update(float deltaTime);
        public void Rebind();
        public void ApplyBuiltinRootMotion();
        [Obsolete("GetVector is deprecated.")]
        public Vector3 GetVector(string name);
        [Obsolete("GetVector is deprecated.")]
        public Vector3 GetVector(int id);
        [Obsolete("SetVector is deprecated.")]
        public void SetVector(string name, Vector3 value);
        [Obsolete("SetVector is deprecated.")]
        public void SetVector(int id, Vector3 value);
        [Obsolete("GetQuaternion is deprecated.")]
        public Quaternion GetQuaternion(string name);
        [Obsolete("GetQuaternion is deprecated.")]
        public Quaternion GetQuaternion(int id);
        [Obsolete("SetQuaternion is deprecated.")]
        public void SetQuaternion(string name, Quaternion value);
        [Obsolete("SetQuaternion is deprecated.")]
        public void SetQuaternion(int id, Quaternion value);
    }
}
using System.Collections.Generic;

namespace UnityEngine
{
    public interface IAnimationClipSource
    {
        void GetAnimationClips(List<AnimationClip> results);
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [AttributeUsage(Class, AllowMultiple = False)]
    [RequiredByNativeCode]
    public sealed class SharedBetweenAnimatorsAttribute : Attribute
    {
        public SharedBetweenAnimatorsAttribute();
    }
}
using UnityEngine.Animations;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [RequiredByNativeCode]
    public abstract class StateMachineBehaviour : ScriptableObject
    {
        protected StateMachineBehaviour();

        public virtual void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex);
        public virtual void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex);
        public virtual void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex);
        public virtual void OnStateMove(Animator animator, AnimatorStateInfo stateInfo, int layerIndex);
        public virtual void OnStateIK(Animator animator, AnimatorStateInfo stateInfo, int layerIndex);
        public virtual void OnStateMachineEnter(Animator animator, int stateMachinePathHash);
        public virtual void OnStateMachineExit(Animator animator, int stateMachinePathHash);
        public virtual void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex, AnimatorControllerPlayable controller);
        public virtual void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex, AnimatorControllerPlayable controller);
        public virtual void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex, AnimatorControllerPlayable controller);
        public virtual void OnStateMove(Animator animator, AnimatorStateInfo stateInfo, int layerIndex, AnimatorControllerPlayable controller);
        public virtual void OnStateIK(Animator animator, AnimatorStateInfo stateInfo, int layerIndex, AnimatorControllerPlayable controller);
        public virtual void OnStateMachineEnter(Animator animator, int stateMachinePathHash, AnimatorControllerPlayable controller);
        public virtual void OnStateMachineExit(Animator animator, int stateMachinePathHash, AnimatorControllerPlayable controller);
    }
}
namespace UnityEngine
{
    public enum PlayMode
    {
        StopSameLayer = 0,
        StopAll = 4
    }
}
namespace UnityEngine
{
    public enum QueueMode
    {
        CompleteOthers = 0,
        PlayNow = 2
    }
}
namespace UnityEngine
{
    public enum AnimationBlendMode
    {
        Blend = 0,
        Additive = 1
    }
}
namespace UnityEngine
{
    public enum AnimationPlayMode
    {
        Stop = 0,
        Queue = 1,
        Mix = 2
    }
}
using System;

namespace UnityEngine
{
    public enum AnimationCullingType
    {
        AlwaysAnimate = 0,
        BasedOnRenderers = 1,
        [Obsolete("Enum member AnimatorCullingMode.BasedOnClipBounds has been deprecated. Use AnimationCullingType.AlwaysAnimate or AnimationCullingType.BasedOnRenderers instead")]
        BasedOnClipBounds = 2,
        [Obsolete("Enum member AnimatorCullingMode.BasedOnUserBounds has been deprecated. Use AnimationCullingType.AlwaysAnimate or AnimationCullingType.BasedOnRenderers instead")]
        BasedOnUserBounds = 3
    }
}
using System;
using System.Collections;
using System.Reflection;
using UnityEngine.Bindings;
using UnityEngine.Internal;

namespace UnityEngine
{
    [NativeHeader("Modules/Animation/Animation.h")]
    [DefaultMember("Item")]
    public sealed class Animation : Behaviour, IEnumerable
    {
        public Animation();

        public AnimationState this[string name] { get; }
        public AnimationClip clip { get; set; }
        public bool playAutomatically { get; set; }
        public WrapMode wrapMode { get; set; }
        public bool isPlaying { get; }
        public bool animatePhysics { get; set; }
        [Obsolete("Use cullingType instead")]
        public bool animateOnlyIfVisible { get; set; }
        public AnimationCullingType cullingType { get; set; }
        public Bounds localBounds { get; set; }

        public void Stop();
        public void Stop(string name);
        public void Rewind();
        public void Rewind(string name);
        public void Sample();
        public bool IsPlaying(string name);
        [ExcludeFromDocs]
        public bool Play();
        public bool Play([DefaultValue("PlayMode.StopSameLayer")] PlayMode mode);
        [ExcludeFromDocs]
        public bool Play(string animation);
        public bool Play(string animation, [DefaultValue("PlayMode.StopSameLayer")] PlayMode mode);
        [ExcludeFromDocs]
        public void CrossFade(string animation);
        [ExcludeFromDocs]
        public void CrossFade(string animation, float fadeLength);
        public void CrossFade(string animation, [DefaultValue("0.3F")] float fadeLength, [DefaultValue("PlayMode.StopSameLayer")] PlayMode mode);
        [ExcludeFromDocs]
        public void Blend(string animation);
        [ExcludeFromDocs]
        public void Blend(string animation, float targetWeight);
        public void Blend(string animation, [DefaultValue("1.0F")] float targetWeight, [DefaultValue("0.3F")] float fadeLength);
        [ExcludeFromDocs]
        public AnimationState CrossFadeQueued(string animation);
        [ExcludeFromDocs]
        public AnimationState CrossFadeQueued(string animation, float fadeLength);
        [ExcludeFromDocs]
        public AnimationState CrossFadeQueued(string animation, float fadeLength, QueueMode queue);
        [FreeFunction("AnimationBindings::CrossFadeQueuedImpl", HasExplicitThis = True)]
        public AnimationState CrossFadeQueued(string animation, [DefaultValue("0.3F")] float fadeLength, [DefaultValue("QueueMode.CompleteOthers")] QueueMode queue, [DefaultValue("PlayMode.StopSameLayer")] PlayMode mode);
        [ExcludeFromDocs]
        public AnimationState PlayQueued(string animation);
        [ExcludeFromDocs]
        public AnimationState PlayQueued(string animation, QueueMode queue);
        [FreeFunction("AnimationBindings::PlayQueuedImpl", HasExplicitThis = True)]
        public AnimationState PlayQueued(string animation, [DefaultValue("QueueMode.CompleteOthers")] QueueMode queue, [DefaultValue("PlayMode.StopSameLayer")] PlayMode mode);
        public void AddClip(AnimationClip clip, string newName);
        [ExcludeFromDocs]
        public void AddClip(AnimationClip clip, string newName, int firstFrame, int lastFrame);
        public void AddClip([NotNull("NullExceptionObject")] AnimationClip clip, string newName, int firstFrame, int lastFrame, [DefaultValue("false")] bool addLoopFrame);
        public void RemoveClip([NotNull("NullExceptionObject")] AnimationClip clip);
        public void RemoveClip(string clipName);
        public int GetClipCount();
        [Obsolete("use PlayMode instead of AnimationPlayMode.")]
        public bool Play(AnimationPlayMode mode);
        [Obsolete("use PlayMode instead of AnimationPlayMode.")]
        public bool Play(string animation, AnimationPlayMode mode);
        public void SyncLayer(int layer);
        public IEnumerator GetEnumerator();
        public AnimationClip GetClip(string name);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Internal;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Modules/Animation/AnimationState.h")]
    [UsedByNativeCode]
    public sealed class AnimationState : TrackedReference
    {
        public AnimationState();

        public bool enabled { get; set; }
        public float weight { get; set; }
        public WrapMode wrapMode { get; set; }
        public float time { get; set; }
        public float normalizedTime { get; set; }
        public float speed { get; set; }
        public float normalizedSpeed { get; set; }
        public float length { get; }
        public int layer { get; set; }
        public AnimationClip clip { get; }
        public string name { get; set; }
        public AnimationBlendMode blendMode { get; set; }

        [ExcludeFromDocs]
        public void AddMixingTransform(Transform mix);
        public void AddMixingTransform([NotNull("NullExceptionObject")] Transform mix, [DefaultValue("true")] bool recursive);
        public void RemoveMixingTransform([NotNull("NullExceptionObject")] Transform mix);
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [RequiredByNativeCode]
    public sealed class AnimationEvent
    {
        public AnimationEvent();

        [Obsolete("Use stringParameter instead")]
        public string data { get; set; }
        public string stringParameter { get; set; }
        public float floatParameter { get; set; }
        public int intParameter { get; set; }
        public Object objectReferenceParameter { get; set; }
        public string functionName { get; set; }
        public float time { get; set; }
        public SendMessageOptions messageOptions { get; set; }
        public bool isFiredByLegacy { get; }
        public bool isFiredByAnimator { get; }
        public AnimationState animationState { get; }
        public AnimatorStateInfo animatorStateInfo { get; }
        public AnimatorClipInfo animatorClipInfo { get; }
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeType("Modules/Animation/AnimationClip.h")]
    [NativeHeader("Modules/Animation/ScriptBindings/AnimationClip.bindings.h")]
    public sealed class AnimationClip : Motion
    {
        public AnimationClip();

        [NativeProperty("Length", False, Function)]
        public float length { get; }
        [NativeProperty("SampleRate", False, Function)]
        public float frameRate { get; set; }
        [NativeProperty("WrapMode", False, Function)]
        public WrapMode wrapMode { get; set; }
        [NativeProperty("Bounds", False, Function)]
        public Bounds localBounds { get; set; }
        public bool legacy { get; set; }
        public bool humanMotion { get; }
        public bool empty { get; }
        public bool hasGenericRootTransform { get; }
        public bool hasMotionFloatCurves { get; }
        public bool hasMotionCurves { get; }
        public bool hasRootCurves { get; }
        public AnimationEvent[] events { get; set; }

        public void SampleAnimation(GameObject go, float time);
        [FreeFunction("AnimationClipBindings::Internal_SetCurve", HasExplicitThis = True)]
        public void SetCurve([NotNull("ArgumentNullException")] string relativePath, [NotNull("ArgumentNullException")] Type type, [NotNull("ArgumentNullException")] string propertyName, AnimationCurve curve);
        public void EnsureQuaternionContinuity();
        public void ClearCurves();
        public void AddEvent(AnimationEvent evt);
    }
}
namespace UnityEngine
{
    public enum AvatarTarget
    {
        Root = 0,
        Body = 1,
        LeftFoot = 2,
        RightFoot = 3,
        LeftHand = 4,
        RightHand = 5
    }
}
namespace UnityEngine
{
    public enum AvatarIKGoal
    {
        LeftFoot = 0,
        RightFoot = 1,
        LeftHand = 2,
        RightHand = 3
    }
}
namespace UnityEngine
{
    public enum AvatarIKHint
    {
        LeftKnee = 0,
        RightKnee = 1,
        LeftElbow = 2,
        RightElbow = 3
    }
}
namespace UnityEngine
{
    public enum AnimatorControllerParameterType
    {
        Float = 1,
        Int = 3,
        Bool = 4,
        Trigger = 9
    }
}
namespace UnityEngine
{
    public enum AnimatorRecorderMode
    {
        Offline = 0,
        Playback = 1,
        Record = 2
    }
}
namespace UnityEngine
{
    public enum DurationUnit
    {
        Fixed = 0,
        Normalized = 1
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    public enum AnimatorCullingMode
    {
        AlwaysAnimate = 0,
        CullUpdateTransforms = 1,
        CullCompletely = 2,
        [Obsolete("Enum member AnimatorCullingMode.BasedOnRenderers has been deprecated. Use AnimatorCullingMode.CullUpdateTransforms instead. (UnityUpgradable) -> CullUpdateTransforms", True)]
        [EditorBrowsable(Never)]
        BasedOnRenderers = 1
    }
}
namespace UnityEngine
{
    public enum AnimatorUpdateMode
    {
        Normal = 0,
        AnimatePhysics = 1,
        UnscaledTime = 2
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    [NativeHeader("Modules/Animation/ScriptBindings/Animation.bindings.h")]
    [NativeHeader("Modules/Animation/AnimatorInfo.h")]
    public struct AnimatorClipInfo
    {
        public AnimationClip clip { get; }
        public float weight { get; }
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Modules/Animation/AnimatorInfo.h")]
    [RequiredByNativeCode]
    public struct AnimatorStateInfo
    {
        public int fullPathHash { get; }
        [Obsolete("AnimatorStateInfo.nameHash has been deprecated. Use AnimatorStateInfo.fullPathHash instead.")]
        public int nameHash { get; }
        public int shortNameHash { get; }
        public float normalizedTime { get; }
        public float length { get; }
        public float speed { get; }
        public float speedMultiplier { get; }
        public int tagHash { get; }
        public bool loop { get; }

        public bool IsName(string name);
        public bool IsTag(string tag);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [RequiredByNativeCode]
    [NativeHeader("Modules/Animation/AnimatorInfo.h")]
    public struct AnimatorTransitionInfo
    {
        public int fullPathHash { get; }
        public int nameHash { get; }
        public int userNameHash { get; }
        public DurationUnit durationUnit { get; }
        public float duration { get; }
        public float normalizedTime { get; }
        public bool anyState { get; }

        public bool IsName(string name);
        public bool IsUserName(string name);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Animation/Animator.h")]
    public struct MatchTargetWeightMask
    {
        public MatchTargetWeightMask(Vector3 positionXYZWeight, float rotationWeight);

        public Vector3 positionXYZWeight { get; set; }
        public float rotationWeight { get; set; }
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Modules/Animation/ScriptBindings/AnimatorControllerParameter.bindings.h")]
    [NativeHeader("Modules/Animation/AnimatorControllerParameter.h")]
    [NativeAsStruct]
    [UsedByNativeCode]
    [NativeType(Custom, "MonoAnimatorControllerParameter")]
    public class AnimatorControllerParameter
    {
        public AnimatorControllerParameter();

        public string name { get; set; }
        public int nameHash { get; }
        public AnimatorControllerParameterType type { get; set; }
        public float defaultFloat { get; set; }
        public int defaultInt { get; set; }
        public bool defaultBool { get; set; }

        public override bool Equals(object o);
        public override int GetHashCode();
    }
}
using System;

namespace UnityEngine
{
    [Obsolete("This class is not used anymore. See AnimatorOverrideController.GetOverrides() and AnimatorOverrideController.ApplyOverrides()")]
    public class AnimationClipPair
    {
        public AnimationClip originalClip;
        public AnimationClip overrideClip;

        public AnimationClipPair();
    }
}
using System;
using System.Collections.Generic;
using System.Reflection;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Modules/Animation/AnimatorOverrideController.h")]
    [NativeHeader("Modules/Animation/ScriptBindings/Animation.bindings.h")]
    [UsedByNativeCode]
    [DefaultMember("Item")]
    public class AnimatorOverrideController : RuntimeAnimatorController
    {
        public AnimatorOverrideController();
        public AnimatorOverrideController(RuntimeAnimatorController controller);

        public AnimationClip this[string name] { get; set; }
        public AnimationClip this[AnimationClip clip] { get; set; }
        public RuntimeAnimatorController runtimeAnimatorController { get; set; }
        public int overridesCount { get; }
        [Obsolete("AnimatorOverrideController.clips property is deprecated. Use AnimatorOverrideController.GetOverrides and AnimatorOverrideController.ApplyOverrides instead.")]
        public AnimationClipPair[] clips { get; set; }

        public void GetOverrides(List<KeyValuePair<AnimationClip, AnimationClip>> overrides);
        public void ApplyOverrides(IList<KeyValuePair<AnimationClip, AnimationClip>> overrides);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Animation/OptimizeTransformHierarchy.h")]
    public class AnimatorUtility
    {
        public AnimatorUtility();

        [FreeFunction]
        public static void OptimizeTransformHierarchy([NotNull("NullExceptionObject")] GameObject go, string[] exposedTransforms);
        [FreeFunction]
        public static void DeoptimizeTransformHierarchy([NotNull("NullExceptionObject")] GameObject go);
    }
}
namespace UnityEngine
{
    public enum BodyDof
    {
        SpineFrontBack = 0,
        SpineLeftRight = 1,
        SpineRollLeftRight = 2,
        ChestFrontBack = 3,
        ChestLeftRight = 4,
        ChestRollLeftRight = 5,
        UpperChestFrontBack = 6,
        UpperChestLeftRight = 7,
        UpperChestRollLeftRight = 8,
        LastBodyDof = 9
    }
}
namespace UnityEngine
{
    public enum HeadDof
    {
        NeckFrontBack = 0,
        NeckLeftRight = 1,
        NeckRollLeftRight = 2,
        HeadFrontBack = 3,
        HeadLeftRight = 4,
        HeadRollLeftRight = 5,
        LeftEyeDownUp = 6,
        LeftEyeInOut = 7,
        RightEyeDownUp = 8,
        RightEyeInOut = 9,
        JawDownUp = 10,
        JawLeftRight = 11,
        LastHeadDof = 12
    }
}
namespace UnityEngine
{
    public enum LegDof
    {
        UpperLegFrontBack = 0,
        UpperLegInOut = 1,
        UpperLegRollInOut = 2,
        LegCloseOpen = 3,
        LegRollInOut = 4,
        FootCloseOpen = 5,
        FootInOut = 6,
        ToesUpDown = 7,
        LastLegDof = 8
    }
}
namespace UnityEngine
{
    public enum ArmDof
    {
        ShoulderDownUp = 0,
        ShoulderFrontBack = 1,
        ArmDownUp = 2,
        ArmFrontBack = 3,
        ArmRollInOut = 4,
        ForeArmCloseOpen = 5,
        ForeArmRollInOut = 6,
        HandDownUp = 7,
        HandInOut = 8,
        LastArmDof = 9
    }
}
namespace UnityEngine
{
    public enum FingerDof
    {
        ProximalDownUp = 0,
        ProximalInOut = 1,
        IntermediateCloseOpen = 2,
        DistalCloseOpen = 3,
        LastFingerDof = 4
    }
}
namespace UnityEngine
{
    public enum HumanPartDof
    {
        Body = 0,
        Head = 1,
        LeftLeg = 2,
        RightLeg = 3,
        LeftArm = 4,
        RightArm = 5,
        LeftThumb = 6,
        LeftIndex = 7,
        LeftMiddle = 8,
        LeftRing = 9,
        LeftLittle = 10,
        RightThumb = 11,
        RightIndex = 12,
        RightMiddle = 13,
        RightRing = 14,
        RightLittle = 15,
        LastHumanPartDof = 16
    }
}
namespace UnityEngine
{
    public enum HumanBodyBones
    {
        Hips = 0,
        LeftUpperLeg = 1,
        RightUpperLeg = 2,
        LeftLowerLeg = 3,
        RightLowerLeg = 4,
        LeftFoot = 5,
        RightFoot = 6,
        Spine = 7,
        Chest = 8,
        UpperChest = 54,
        Neck = 9,
        Head = 10,
        LeftShoulder = 11,
        RightShoulder = 12,
        LeftUpperArm = 13,
        RightUpperArm = 14,
        LeftLowerArm = 15,
        RightLowerArm = 16,
        LeftHand = 17,
        RightHand = 18,
        LeftToes = 19,
        RightToes = 20,
        LeftEye = 21,
        RightEye = 22,
        Jaw = 23,
        LeftThumbProximal = 24,
        LeftThumbIntermediate = 25,
        LeftThumbDistal = 26,
        LeftIndexProximal = 27,
        LeftIndexIntermediate = 28,
        LeftIndexDistal = 29,
        LeftMiddleProximal = 30,
        LeftMiddleIntermediate = 31,
        LeftMiddleDistal = 32,
        LeftRingProximal = 33,
        LeftRingIntermediate = 34,
        LeftRingDistal = 35,
        LeftLittleProximal = 36,
        LeftLittleIntermediate = 37,
        LeftLittleDistal = 38,
        RightThumbProximal = 39,
        RightThumbIntermediate = 40,
        RightThumbDistal = 41,
        RightIndexProximal = 42,
        RightIndexIntermediate = 43,
        RightIndexDistal = 44,
        RightMiddleProximal = 45,
        RightMiddleIntermediate = 46,
        RightMiddleDistal = 47,
        RightRingProximal = 48,
        RightRingIntermediate = 49,
        RightRingDistal = 50,
        RightLittleProximal = 51,
        RightLittleIntermediate = 52,
        RightLittleDistal = 53,
        LastBone = 55
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    [NativeHeader("Modules/Animation/Avatar.h")]
    public class Avatar : Object
    {
        public bool isValid { get; }
        public bool isHuman { get; }
        public HumanDescription humanDescription { get; }
    }
}
using System;
using System.ComponentModel;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Modules/Animation/HumanDescription.h")]
    [RequiredByNativeCode]
    [NativeType(Custom, "MonoSkeletonBone")]
    public struct SkeletonBone
    {
        [NativeName("m_Name")]
        public string name;
        [NativeName("m_Position")]
        public Vector3 position;
        [NativeName("m_Rotation")]
        public Quaternion rotation;
        [NativeName("m_Scale")]
        public Vector3 scale;

        [Obsolete("transformModified is no longer used and has been deprecated.", True)]
        [EditorBrowsable(Never)]
        public int transformModified { get; set; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Animation/ScriptBindings/AvatarBuilder.bindings.h")]
    [NativeHeader("Modules/Animation/HumanDescription.h")]
    [NativeType(Custom, "MonoHumanLimit")]
    public struct HumanLimit
    {
        public bool useDefaultValues { get; set; }
        public Vector3 min { get; set; }
        public Vector3 max { get; set; }
        public Vector3 center { get; set; }
        public float axisLength { get; set; }
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Modules/Animation/HumanDescription.h")]
    [RequiredByNativeCode]
    [NativeType(Custom, "MonoHumanBone")]
    public struct HumanBone
    {
        [NativeName("m_Limit")]
        public HumanLimit limit;

        public string boneName { get; set; }
        public string humanName { get; set; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Animation/ScriptBindings/AvatarBuilder.bindings.h")]
    [NativeHeader("Modules/Animation/HumanDescription.h")]
    public struct HumanDescription
    {
        [NativeName("m_Human")]
        public HumanBone[] human;
        [NativeName("m_Skeleton")]
        public SkeletonBone[] skeleton;

        public float upperArmTwist { get; set; }
        public float lowerArmTwist { get; set; }
        public float upperLegTwist { get; set; }
        public float lowerLegTwist { get; set; }
        public float armStretch { get; set; }
        public float legStretch { get; set; }
        public float feetSpacing { get; set; }
        public bool hasTranslationDoF { get; set; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Animation/ScriptBindings/AvatarBuilder.bindings.h")]
    public class AvatarBuilder
    {
        public AvatarBuilder();

        public static Avatar BuildHumanAvatar(GameObject go, HumanDescription humanDescription);
        [FreeFunction("AvatarBuilderBindings::BuildGenericAvatar")]
        public static Avatar BuildGenericAvatar([NotNull("ArgumentNullException")] GameObject go, [NotNull("ArgumentNullException")] string rootMotionTransformName);
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine
{
    [MovedFrom(True, "UnityEditor.Animations", "UnityEditor", null)]
    public enum AvatarMaskBodyPart
    {
        Root = 0,
        Body = 1,
        Head = 2,
        LeftLeg = 3,
        RightLeg = 4,
        LeftArm = 5,
        RightArm = 6,
        LeftFingers = 7,
        RightFingers = 8,
        LeftFootIK = 9,
        RightFootIK = 10,
        LeftHandIK = 11,
        RightHandIK = 12,
        LastBodyPart = 13
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Internal;
using UnityEngine.Scripting;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine
{
    [UsedByNativeCode]
    [NativeHeader("Modules/Animation/ScriptBindings/Animation.bindings.h")]
    [NativeHeader("Modules/Animation/AvatarMask.h")]
    [MovedFrom(True, "UnityEditor.Animations", "UnityEditor", null)]
    public sealed class AvatarMask : Object
    {
        public AvatarMask();

        [Obsolete("AvatarMask.humanoidBodyPartCount is deprecated, use AvatarMaskBodyPart.LastBodyPart instead.")]
        public int humanoidBodyPartCount { get; }
        public int transformCount { get; set; }

        [NativeMethod("GetBodyPart")]
        public bool GetHumanoidBodyPartActive(AvatarMaskBodyPart index);
        [NativeMethod("SetBodyPart")]
        public void SetHumanoidBodyPartActive(AvatarMaskBodyPart index, bool value);
        public void AddTransformPath(Transform transform);
        public void AddTransformPath([NotNull("ArgumentNullException")] Transform transform, [DefaultValue("true")] bool recursive);
        public void RemoveTransformPath(Transform transform);
        public void RemoveTransformPath([NotNull("ArgumentNullException")] Transform transform, [DefaultValue("true")] bool recursive);
        public string GetTransformPath(int index);
        public void SetTransformPath(int index, string path);
        public bool GetTransformActive(int index);
        public void SetTransformActive(int index, bool value);
    }
}
namespace UnityEngine
{
    public struct HumanPose
    {
        public Vector3 bodyPosition;
        public Quaternion bodyRotation;
        public float[] muscles;
    }
}
using System;
using Unity.Collections;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Animation/ScriptBindings/Animation.bindings.h")]
    [NativeHeader("Modules/Animation/HumanPoseHandler.h")]
    public class HumanPoseHandler : IDisposable
    {
        public HumanPoseHandler(Avatar avatar, Transform root);
        public HumanPoseHandler(Avatar avatar, string[] jointPaths);

        public void Dispose();
        public void GetHumanPose(ref HumanPose humanPose);
        public void SetHumanPose(ref HumanPose humanPose);
        public void GetInternalHumanPose(ref HumanPose humanPose);
        public void SetInternalHumanPose(ref HumanPose humanPose);
        public void GetInternalAvatarPose(NativeArray<float> avatarPose);
        public void SetInternalAvatarPose(NativeArray<float> avatarPose);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Animation/HumanTrait.h")]
    public class HumanTrait
    {
        public HumanTrait();

        public static int MuscleCount { get; }
        public static string[] MuscleName { get; }
        public static int BoneCount { get; }
        public static string[] BoneName { get; }
        public static int RequiredBoneCount { get; }

        public static int MuscleFromBone(int i, int dofIndex);
        public static int BoneFromMuscle(int i);
        public static bool RequiredBone(int i);
        public static float GetMuscleDefaultMin(int i);
        public static float GetMuscleDefaultMax(int i);
        public static float GetBoneDefaultHierarchyMass(int i);
        public static int GetParentBone(int i);
    }
}
using System;
using System.ComponentModel;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Animation/Motion.h")]
    public class Motion : Object
    {
        protected Motion();

        public float averageDuration { get; }
        public float averageAngularSpeed { get; }
        public Vector3 averageSpeed { get; }
        public float apparentSpeed { get; }
        public bool isLooping { get; }
        public bool legacy { get; }
        public bool isHumanMotion { get; }
        [Obsolete("isAnimatorMotion is not supported anymore, please use !legacy instead.", True)]
        [EditorBrowsable(Never)]
        public bool isAnimatorMotion { get; }

        [EditorBrowsable(Never)]
        [Obsolete("ValidateIfRetargetable is not supported anymore, please use isHumanMotion instead.", True)]
        public bool ValidateIfRetargetable(bool val);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Modules/Animation/RuntimeAnimatorController.h")]
    [UsedByNativeCode]
    [ExcludeFromObjectFactory]
    public class RuntimeAnimatorController : Object
    {
        protected RuntimeAnimatorController();

        public AnimationClip[] animationClips { get; }
    }
}
namespace UnityEngine.Experimental.Animations
{
    public enum AnimationStreamSource
    {
        DefaultValues = 0,
        PreviousInputs = 1
    }
}
using UnityEngine.Animations;
using UnityEngine.Bindings;

namespace UnityEngine.Experimental.Animations
{
    [StaticAccessor("AnimationPlayableOutputExtensionsBindings", DoubleColon)]
    [NativeHeader("Modules/Animation/ScriptBindings/AnimationPlayableOutputExtensions.bindings.h")]
    [NativeHeader("Modules/Animation/AnimatorDefines.h")]
    public static class AnimationPlayableOutputExtensions
    {
        public static AnimationStreamSource GetAnimationStreamSource(this AnimationPlayableOutput output);
        public static void SetAnimationStreamSource(this AnimationPlayableOutput output, AnimationStreamSource streamSource);
        public static ushort GetSortingOrder(this AnimationPlayableOutput output);
        public static void SetSortingOrder(this AnimationPlayableOutput output, ushort sortingOrder);
    }
}
using UnityEngine.Animations;

namespace UnityEngine.Playables
{
    public static class AnimationPlayableUtilities
    {
        public static void Play(Animator animator, Playable playable, PlayableGraph graph);
        public static AnimationClipPlayable PlayClip(Animator animator, AnimationClip clip, out PlayableGraph graph);
        public static AnimationMixerPlayable PlayMixer(Animator animator, int inputCount, out PlayableGraph graph);
        public static AnimationLayerMixerPlayable PlayLayerMixer(Animator animator, int inputCount, out PlayableGraph graph);
        public static AnimatorControllerPlayable PlayAnimatorController(Animator animator, RuntimeAnimatorController controller, out PlayableGraph graph);
    }
}
using UnityEngine.Playables;

namespace UnityEngine.Animations
{
    public static class AnimationPlayableBinding
    {
        public static PlayableBinding Create(string name, Object key);
    }
}
using Unity.Jobs.LowLevel.Unsafe;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Animations
{
    [MovedFrom("UnityEngine.Experimental.Animations")]
    [JobProducerType(typeof(ProcessAnimationJobStruct<>))]
    public interface IAnimationJob
    {
        void ProcessAnimation(AnimationStream stream);
        void ProcessRootMotion(AnimationStream stream);
    }
}
using UnityEngine.Playables;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Animations
{
    [MovedFrom("UnityEngine.Experimental.Animations")]
    public interface IAnimationJobPlayable : IPlayable
    {
        T GetJobData<T>() where T : IAnimationJob, struct;
        void SetJobData<T>(T jobData) where T : IAnimationJob, struct;
    }
}
using UnityEngine.Playables;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Animations
{
    [MovedFrom("UnityEngine.Experimental.Animations")]
    public interface IAnimationWindowPreview
    {
        void StartPreview();
        void StopPreview();
        void UpdatePreviewGraph(PlayableGraph graph);
        Playable BuildPreviewGraph(PlayableGraph graph, Playable inputPlayable);
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine.Animations
{
    [RequiredByNativeCode]
    [AttributeUsage(Class, Field)]
    public class NotKeyableAttribute : Attribute
    {
        public NotKeyableAttribute();
    }
}
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Animations
{
    [UsedByNativeCode]
    [NativeHeader("Modules/Animation/Constraints/Constraint.bindings.h")]
    [RequireComponent(typeof(Transform))]
    [NativeHeader("Modules/Animation/Constraints/AimConstraint.h")]
    public sealed class AimConstraint : Behaviour, IConstraint, IConstraintInternal
    {
        public float weight { get; set; }
        public bool constraintActive { get; set; }
        public bool locked { get; set; }
        public Vector3 rotationAtRest { get; set; }
        public Vector3 rotationOffset { get; set; }
        public Axis rotationAxis { get; set; }
        public Vector3 aimVector { get; set; }
        public Vector3 upVector { get; set; }
        public Vector3 worldUpVector { get; set; }
        public Transform worldUpObject { get; set; }
        public WorldUpType worldUpType { get; set; }
        public int sourceCount { get; }

        [FreeFunction(Name = "ConstraintBindings::GetSources", HasExplicitThis = True)]
        public void GetSources([NotNull("ArgumentNullException")] List<ConstraintSource> sources);
        public void SetSources(List<ConstraintSource> sources);
        public int AddSource(ConstraintSource source);
        public void RemoveSource(int index);
        public ConstraintSource GetSource(int index);
        public void SetSource(int index, ConstraintSource source);

        public enum WorldUpType
        {
            SceneUp = 0,
            ObjectUp = 1,
            ObjectRotationUp = 2,
            Vector = 3,
            None = 4
        }
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Playables;
using UnityEngine.Scripting;

namespace UnityEngine.Animations
{
    [RequiredByNativeCode]
    [StaticAccessor("AnimationClipPlayableBindings", DoubleColon)]
    [NativeHeader("Modules/Animation/ScriptBindings/AnimationClipPlayable.bindings.h")]
    [NativeHeader("Modules/Animation/Director/AnimationClipPlayable.h")]
    public struct AnimationClipPlayable : IEquatable<AnimationClipPlayable>, IPlayable
    {
        public static AnimationClipPlayable Create(PlayableGraph graph, AnimationClip clip);
        public PlayableHandle GetHandle();
        public bool Equals(AnimationClipPlayable other);
        public AnimationClip GetAnimationClip();
        public bool GetApplyFootIK();
        public void SetApplyFootIK(bool value);
        public bool GetApplyPlayableIK();
        public void SetApplyPlayableIK(bool value);

        public static implicit operator Playable(AnimationClipPlayable playable);
        public static explicit operator AnimationClipPlayable(Playable playable);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Animations
{
    [RequiredByNativeCode]
    [MovedFrom("UnityEngine.Experimental.Animations")]
    [NativeHeader("Modules/Animation/ScriptBindings/AnimationHumanStream.bindings.h")]
    [NativeHeader("Modules/Animation/Director/AnimationHumanStream.h")]
    public struct AnimationHumanStream
    {
        public bool isValid { get; }
        public float humanScale { get; }
        public float leftFootHeight { get; }
        public float rightFootHeight { get; }
        public Vector3 bodyLocalPosition { get; set; }
        public Quaternion bodyLocalRotation { get; set; }
        public Vector3 bodyPosition { get; set; }
        public Quaternion bodyRotation { get; set; }
        public Vector3 leftFootVelocity { get; }
        public Vector3 rightFootVelocity { get; }

        public float GetMuscle(MuscleHandle muscle);
        public void SetMuscle(MuscleHandle muscle, float value);
        public void ResetToStancePose();
        public Vector3 GetGoalPositionFromPose(AvatarIKGoal index);
        public Quaternion GetGoalRotationFromPose(AvatarIKGoal index);
        public Vector3 GetGoalLocalPosition(AvatarIKGoal index);
        public void SetGoalLocalPosition(AvatarIKGoal index, Vector3 pos);
        public Quaternion GetGoalLocalRotation(AvatarIKGoal index);
        public void SetGoalLocalRotation(AvatarIKGoal index, Quaternion rot);
        public Vector3 GetGoalPosition(AvatarIKGoal index);
        public void SetGoalPosition(AvatarIKGoal index, Vector3 pos);
        public Quaternion GetGoalRotation(AvatarIKGoal index);
        public void SetGoalRotation(AvatarIKGoal index, Quaternion rot);
        public void SetGoalWeightPosition(AvatarIKGoal index, float value);
        public void SetGoalWeightRotation(AvatarIKGoal index, float value);
        public float GetGoalWeightPosition(AvatarIKGoal index);
        public float GetGoalWeightRotation(AvatarIKGoal index);
        public Vector3 GetHintPosition(AvatarIKHint index);
        public void SetHintPosition(AvatarIKHint index, Vector3 pos);
        public void SetHintWeightPosition(AvatarIKHint index, float value);
        public float GetHintWeightPosition(AvatarIKHint index);
        public void SetLookAtPosition(Vector3 lookAtPosition);
        public void SetLookAtClampWeight(float weight);
        public void SetLookAtBodyWeight(float weight);
        public void SetLookAtHeadWeight(float weight);
        public void SetLookAtEyesWeight(float weight);
        public void SolveIK();
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Playables;
using UnityEngine.Scripting;

namespace UnityEngine.Animations
{
    [NativeHeader("Modules/Animation/ScriptBindings/AnimationLayerMixerPlayable.bindings.h")]
    [NativeHeader("Modules/Animation/Director/AnimationLayerMixerPlayable.h")]
    [NativeHeader("Runtime/Director/Core/HPlayable.h")]
    [StaticAccessor("AnimationLayerMixerPlayableBindings", DoubleColon)]
    [RequiredByNativeCode]
    public struct AnimationLayerMixerPlayable : IEquatable<AnimationLayerMixerPlayable>, IPlayable
    {
        public static AnimationLayerMixerPlayable Null { get; }

        public static AnimationLayerMixerPlayable Create(PlayableGraph graph, int inputCount = 0);
        public PlayableHandle GetHandle();
        public bool Equals(AnimationLayerMixerPlayable other);
        public bool IsLayerAdditive(uint layerIndex);
        public void SetLayerAdditive(uint layerIndex, bool value);
        public void SetLayerMaskFromAvatarMask(uint layerIndex, AvatarMask mask);

        public static implicit operator Playable(AnimationLayerMixerPlayable playable);
        public static explicit operator AnimationLayerMixerPlayable(Playable playable);
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Playables;
using UnityEngine.Scripting;

namespace UnityEngine.Animations
{
    [StaticAccessor("AnimationMixerPlayableBindings", DoubleColon)]
    [NativeHeader("Modules/Animation/ScriptBindings/AnimationMixerPlayable.bindings.h")]
    [RequiredByNativeCode]
    [NativeHeader("Runtime/Director/Core/HPlayable.h")]
    [NativeHeader("Modules/Animation/Director/AnimationMixerPlayable.h")]
    public struct AnimationMixerPlayable : IEquatable<AnimationMixerPlayable>, IPlayable
    {
        public static AnimationMixerPlayable Null { get; }

        public static AnimationMixerPlayable Create(PlayableGraph graph, int inputCount = 0, bool normalizeWeights = False);
        public PlayableHandle GetHandle();
        public bool Equals(AnimationMixerPlayable other);

        public static implicit operator Playable(AnimationMixerPlayable playable);
        public static explicit operator AnimationMixerPlayable(Playable playable);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Playables;

namespace UnityEngine.Animations
{
    [NativeHeader("Modules/Animation/AnimationClip.h")]
    [NativeHeader("Runtime/Director/Core/HPlayable.h")]
    [NativeHeader("Modules/Animation/Director/AnimationPlayableExtensions.h")]
    public static class AnimationPlayableExtensions
    {
        public static void SetAnimatedProperties<U>(this U playable, AnimationClip clip) where U : IPlayable, struct;
    }
}
using UnityEngine.Bindings;
using UnityEngine.Playables;
using UnityEngine.Scripting;

namespace UnityEngine.Animations
{
    [RequiredByNativeCode]
    [StaticAccessor("AnimationPlayableOutputBindings", DoubleColon)]
    [NativeHeader("Runtime/Director/Core/HPlayableOutput.h")]
    [NativeHeader("Runtime/Director/Core/HPlayableGraph.h")]
    [NativeHeader("Modules/Animation/Animator.h")]
    [NativeHeader("Modules/Animation/Director/AnimationPlayableOutput.h")]
    [NativeHeader("Modules/Animation/ScriptBindings/AnimationPlayableOutput.bindings.h")]
    public struct AnimationPlayableOutput : IPlayableOutput
    {
        public static AnimationPlayableOutput Null { get; }

        public static AnimationPlayableOutput Create(PlayableGraph graph, string name, Animator target);
        public PlayableOutputHandle GetHandle();
        public Animator GetTarget();
        public void SetTarget(Animator value);

        public static implicit operator PlayableOutput(AnimationPlayableOutput output);
        public static explicit operator AnimationPlayableOutput(PlayableOutput output);
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Playables;
using UnityEngine.Scripting;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Animations
{
    [MovedFrom("UnityEngine.Experimental.Animations")]
    [RequiredByNativeCode]
    [StaticAccessor("AnimationScriptPlayableBindings", DoubleColon)]
    [NativeHeader("Runtime/Director/Core/HPlayableGraph.h")]
    [NativeHeader("Modules/Animation/ScriptBindings/AnimationScriptPlayable.bindings.h")]
    [NativeHeader("Runtime/Director/Core/HPlayable.h")]
    public struct AnimationScriptPlayable : IEquatable<AnimationScriptPlayable>, IPlayable, IAnimationJobPlayable
    {
        public static AnimationScriptPlayable Null { get; }

        public static AnimationScriptPlayable Create<T>(PlayableGraph graph, T jobData, int inputCount = 0) where T : IAnimationJob, struct;
        public PlayableHandle GetHandle();
        public T GetJobData<T>() where T : IAnimationJob, struct;
        public void SetJobData<T>(T jobData) where T : IAnimationJob, struct;
        public bool Equals(AnimationScriptPlayable other);
        public void SetProcessInputs(bool value);
        public bool GetProcessInputs();

        public static implicit operator Playable(AnimationScriptPlayable playable);
        public static explicit operator AnimationScriptPlayable(Playable playable);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Animations
{
    [MovedFrom("UnityEngine.Experimental.Animations")]
    [RequiredByNativeCode]
    [NativeHeader("Modules/Animation/Director/AnimationStream.h")]
    [NativeHeader("Modules/Animation/ScriptBindings/AnimationStream.bindings.h")]
    public struct AnimationStream
    {
        public bool isValid { get; }
        public float deltaTime { get; }
        public Vector3 velocity { get; set; }
        public Vector3 angularVelocity { get; set; }
        public Vector3 rootMotionPosition { get; }
        public Quaternion rootMotionRotation { get; }
        public bool isHumanStream { get; }
        public int inputStreamCount { get; }

        public AnimationHumanStream AsHuman();
        public AnimationStream GetInputStream(int index);
        public float GetInputWeight(int index);
        public void CopyAnimationStreamMotion(AnimationStream animationStream);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Animations
{
    [NativeHeader("Modules/Animation/ScriptBindings/AnimationStreamHandles.bindings.h")]
    [MovedFrom("UnityEngine.Experimental.Animations")]
    [NativeHeader("Modules/Animation/Director/AnimationStreamHandles.h")]
    public struct TransformStreamHandle
    {
        public bool IsValid(AnimationStream stream);
        public void Resolve(AnimationStream stream);
        public bool IsResolved(AnimationStream stream);
        public Vector3 GetPosition(AnimationStream stream);
        public void SetPosition(AnimationStream stream, Vector3 position);
        public Quaternion GetRotation(AnimationStream stream);
        public void SetRotation(AnimationStream stream, Quaternion rotation);
        public Vector3 GetLocalPosition(AnimationStream stream);
        public void SetLocalPosition(AnimationStream stream, Vector3 position);
        public Quaternion GetLocalRotation(AnimationStream stream);
        public void SetLocalRotation(AnimationStream stream, Quaternion rotation);
        public Vector3 GetLocalScale(AnimationStream stream);
        public void SetLocalScale(AnimationStream stream, Vector3 scale);
        public bool GetPositionReadMask(AnimationStream stream);
        public bool GetRotationReadMask(AnimationStream stream);
        public bool GetScaleReadMask(AnimationStream stream);
        public void GetLocalTRS(AnimationStream stream, out Vector3 position, out Quaternion rotation, out Vector3 scale);
        public void SetLocalTRS(AnimationStream stream, Vector3 position, Quaternion rotation, Vector3 scale, bool useMask);
        public void GetGlobalTR(AnimationStream stream, out Vector3 position, out Quaternion rotation);
        public void SetGlobalTR(AnimationStream stream, Vector3 position, Quaternion rotation, bool useMask);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Animations
{
    [MovedFrom("UnityEngine.Experimental.Animations")]
    [NativeHeader("Modules/Animation/Director/AnimationStreamHandles.h")]
    public struct PropertyStreamHandle
    {
        public bool IsValid(AnimationStream stream);
        public void Resolve(AnimationStream stream);
        public bool IsResolved(AnimationStream stream);
        public float GetFloat(AnimationStream stream);
        public void SetFloat(AnimationStream stream, float value);
        public int GetInt(AnimationStream stream);
        public void SetInt(AnimationStream stream, int value);
        public bool GetBool(AnimationStream stream);
        public void SetBool(AnimationStream stream, bool value);
        public bool GetReadMask(AnimationStream stream);
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Animations
{
    [MovedFrom("UnityEngine.Experimental.Animations")]
    [NativeHeader("Modules/Animation/ScriptBindings/AnimationStreamHandles.bindings.h")]
    [NativeHeader("Modules/Animation/Director/AnimationSceneHandles.h")]
    public struct TransformSceneHandle
    {
        public bool IsValid(AnimationStream stream);
        public Vector3 GetPosition(AnimationStream stream);
        [Obsolete("SceneHandle is now read-only; it was problematic with the engine multithreading and determinism", True)]
        public void SetPosition(AnimationStream stream, Vector3 position);
        public Vector3 GetLocalPosition(AnimationStream stream);
        [Obsolete("SceneHandle is now read-only; it was problematic with the engine multithreading and determinism", True)]
        public void SetLocalPosition(AnimationStream stream, Vector3 position);
        public Quaternion GetRotation(AnimationStream stream);
        [Obsolete("SceneHandle is now read-only; it was problematic with the engine multithreading and determinism", True)]
        public void SetRotation(AnimationStream stream, Quaternion rotation);
        public Quaternion GetLocalRotation(AnimationStream stream);
        [Obsolete("SceneHandle is now read-only; it was problematic with the engine multithreading and determinism", True)]
        public void SetLocalRotation(AnimationStream stream, Quaternion rotation);
        public Vector3 GetLocalScale(AnimationStream stream);
        public void GetLocalTRS(AnimationStream stream, out Vector3 position, out Quaternion rotation, out Vector3 scale);
        public void GetGlobalTR(AnimationStream stream, out Vector3 position, out Quaternion rotation);
        [Obsolete("SceneHandle is now read-only; it was problematic with the engine multithreading and determinism", True)]
        public void SetLocalScale(AnimationStream stream, Vector3 scale);
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Animations
{
    [NativeHeader("Modules/Animation/Director/AnimationSceneHandles.h")]
    [MovedFrom("UnityEngine.Experimental.Animations")]
    public struct PropertySceneHandle
    {
        public bool IsValid(AnimationStream stream);
        public void Resolve(AnimationStream stream);
        public bool IsResolved(AnimationStream stream);
        public float GetFloat(AnimationStream stream);
        [Obsolete("SceneHandle is now read-only; it was problematic with the engine multithreading and determinism", True)]
        public void SetFloat(AnimationStream stream, float value);
        public int GetInt(AnimationStream stream);
        [Obsolete("SceneHandle is now read-only; it was problematic with the engine multithreading and determinism", True)]
        public void SetInt(AnimationStream stream, int value);
        public bool GetBool(AnimationStream stream);
        [Obsolete("SceneHandle is now read-only; it was problematic with the engine multithreading and determinism", True)]
        public void SetBool(AnimationStream stream, bool value);
    }
}
using Unity.Collections;
using UnityEngine.Bindings;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Animations
{
    [MovedFrom("UnityEngine.Experimental.Animations")]
    [NativeHeader("Modules/Animation/ScriptBindings/AnimationStreamHandles.bindings.h")]
    public static class AnimationSceneHandleUtility
    {
        public static void ReadInts(AnimationStream stream, NativeArray<PropertySceneHandle> handles, NativeArray<int> buffer);
        public static void ReadFloats(AnimationStream stream, NativeArray<PropertySceneHandle> handles, NativeArray<float> buffer);
    }
}
using Unity.Collections;
using UnityEngine.Bindings;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Animations
{
    [MovedFrom("UnityEngine.Experimental.Animations")]
    [NativeHeader("Modules/Animation/ScriptBindings/AnimationStreamHandles.bindings.h")]
    public static class AnimationStreamHandleUtility
    {
        public static void WriteInts(AnimationStream stream, NativeArray<PropertyStreamHandle> handles, NativeArray<int> buffer, bool useMask);
        public static void WriteFloats(AnimationStream stream, NativeArray<PropertyStreamHandle> handles, NativeArray<float> buffer, bool useMask);
        public static void ReadInts(AnimationStream stream, NativeArray<PropertyStreamHandle> handles, NativeArray<int> buffer);
        public static void ReadFloats(AnimationStream stream, NativeArray<PropertyStreamHandle> handles, NativeArray<float> buffer);
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Internal;
using UnityEngine.Playables;
using UnityEngine.Scripting;

namespace UnityEngine.Animations
{
    [StaticAccessor("AnimatorControllerPlayableBindings", DoubleColon)]
    [NativeHeader("Modules/Animation/AnimatorInfo.h")]
    [NativeHeader("Modules/Animation/RuntimeAnimatorController.h")]
    [RequiredByNativeCode]
    [NativeHeader("Modules/Animation/Director/AnimatorControllerPlayable.h")]
    [NativeHeader("Modules/Animation/ScriptBindings/Animator.bindings.h")]
    [NativeHeader("Modules/Animation/ScriptBindings/AnimatorControllerPlayable.bindings.h")]
    public struct AnimatorControllerPlayable : IEquatable<AnimatorControllerPlayable>, IPlayable
    {
        public static AnimatorControllerPlayable Null { get; }

        public static AnimatorControllerPlayable Create(PlayableGraph graph, RuntimeAnimatorController controller);
        public PlayableHandle GetHandle();
        public void SetHandle(PlayableHandle handle);
        public bool Equals(AnimatorControllerPlayable other);
        public float GetFloat(string name);
        public float GetFloat(int id);
        public void SetFloat(string name, float value);
        public void SetFloat(int id, float value);
        public bool GetBool(string name);
        public bool GetBool(int id);
        public void SetBool(string name, bool value);
        public void SetBool(int id, bool value);
        public int GetInteger(string name);
        public int GetInteger(int id);
        public void SetInteger(string name, int value);
        public void SetInteger(int id, int value);
        public void SetTrigger(string name);
        public void SetTrigger(int id);
        public void ResetTrigger(string name);
        public void ResetTrigger(int id);
        public bool IsParameterControlledByCurve(string name);
        public bool IsParameterControlledByCurve(int id);
        public int GetLayerCount();
        public string GetLayerName(int layerIndex);
        public int GetLayerIndex(string layerName);
        public float GetLayerWeight(int layerIndex);
        public void SetLayerWeight(int layerIndex, float weight);
        public AnimatorStateInfo GetCurrentAnimatorStateInfo(int layerIndex);
        public AnimatorStateInfo GetNextAnimatorStateInfo(int layerIndex);
        public AnimatorTransitionInfo GetAnimatorTransitionInfo(int layerIndex);
        public AnimatorClipInfo[] GetCurrentAnimatorClipInfo(int layerIndex);
        public void GetCurrentAnimatorClipInfo(int layerIndex, List<AnimatorClipInfo> clips);
        public void GetNextAnimatorClipInfo(int layerIndex, List<AnimatorClipInfo> clips);
        public int GetCurrentAnimatorClipInfoCount(int layerIndex);
        public int GetNextAnimatorClipInfoCount(int layerIndex);
        public AnimatorClipInfo[] GetNextAnimatorClipInfo(int layerIndex);
        public bool IsInTransition(int layerIndex);
        public int GetParameterCount();
        public AnimatorControllerParameter GetParameter(int index);
        public void CrossFadeInFixedTime(string stateName, float transitionDuration);
        public void CrossFadeInFixedTime(string stateName, float transitionDuration, int layer);
        public void CrossFadeInFixedTime(string stateName, float transitionDuration, [DefaultValue("-1")] int layer, [DefaultValue("0.0f")] float fixedTime);
        public void CrossFadeInFixedTime(int stateNameHash, float transitionDuration);
        public void CrossFadeInFixedTime(int stateNameHash, float transitionDuration, int layer);
        public void CrossFadeInFixedTime(int stateNameHash, float transitionDuration, [DefaultValue("-1")] int layer, [DefaultValue("0.0f")] float fixedTime);
        public void CrossFade(string stateName, float transitionDuration);
        public void CrossFade(string stateName, float transitionDuration, int layer);
        public void CrossFade(string stateName, float transitionDuration, [DefaultValue("-1")] int layer, [DefaultValue("float.NegativeInfinity")] float normalizedTime);
        public void CrossFade(int stateNameHash, float transitionDuration);
        public void CrossFade(int stateNameHash, float transitionDuration, int layer);
        public void CrossFade(int stateNameHash, float transitionDuration, [DefaultValue("-1")] int layer, [DefaultValue("float.NegativeInfinity")] float normalizedTime);
        public void PlayInFixedTime(string stateName);
        public void PlayInFixedTime(string stateName, int layer);
        public void PlayInFixedTime(string stateName, [DefaultValue("-1")] int layer, [DefaultValue("float.NegativeInfinity")] float fixedTime);
        public void PlayInFixedTime(int stateNameHash);
        public void PlayInFixedTime(int stateNameHash, int layer);
        public void PlayInFixedTime(int stateNameHash, [DefaultValue("-1")] int layer, [DefaultValue("float.NegativeInfinity")] float fixedTime);
        public void Play(string stateName);
        public void Play(string stateName, int layer);
        public void Play(string stateName, [DefaultValue("-1")] int layer, [DefaultValue("float.NegativeInfinity")] float normalizedTime);
        public void Play(int stateNameHash);
        public void Play(int stateNameHash, int layer);
        public void Play(int stateNameHash, [DefaultValue("-1")] int layer, [DefaultValue("float.NegativeInfinity")] float normalizedTime);
        public bool HasState(int layerIndex, int stateID);

        public static implicit operator Playable(AnimatorControllerPlayable playable);
        public static explicit operator AnimatorControllerPlayable(Playable playable);
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Animations
{
    [MovedFrom("UnityEngine.Experimental.Animations")]
    public enum CustomStreamPropertyType
    {
        Float = 5,
        Bool = 6,
        Int = 10
    }
}
using System;
using Unity.Jobs;
using UnityEngine.Bindings;
using UnityEngine.Internal;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Animations
{
    [StaticAccessor("AnimatorJobExtensionsBindings", DoubleColon)]
    [NativeHeader("Modules/Animation/Director/AnimationSceneHandles.h")]
    [NativeHeader("Modules/Animation/Director/AnimationStream.h")]
    [NativeHeader("Modules/Animation/Animator.h")]
    [NativeHeader("Modules/Animation/ScriptBindings/AnimatorJobExtensions.bindings.h")]
    [MovedFrom("UnityEngine.Experimental.Animations")]
    [NativeHeader("Modules/Animation/Director/AnimationStreamHandles.h")]
    public static class AnimatorJobExtensions
    {
        public static void AddJobDependency(this Animator animator, JobHandle jobHandle);
        public static TransformStreamHandle BindStreamTransform(this Animator animator, Transform transform);
        public static PropertyStreamHandle BindStreamProperty(this Animator animator, Transform transform, Type type, string property);
        public static PropertyStreamHandle BindCustomStreamProperty(this Animator animator, string property, CustomStreamPropertyType type);
        public static PropertyStreamHandle BindStreamProperty(this Animator animator, Transform transform, Type type, string property, [DefaultValue("false")] bool isObjectReference);
        public static TransformSceneHandle BindSceneTransform(this Animator animator, Transform transform);
        public static PropertySceneHandle BindSceneProperty(this Animator animator, Transform transform, Type type, string property);
        public static PropertySceneHandle BindSceneProperty(this Animator animator, Transform transform, Type type, string property, [DefaultValue("false")] bool isObjectReference);
        public static bool OpenAnimationStream(this Animator animator, ref AnimationStream stream);
        public static void CloseAnimationStream(this Animator animator, ref AnimationStream stream);
        public static void ResolveAllStreamHandles(this Animator animator);
        public static void ResolveAllSceneHandles(this Animator animator);
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEngine.Animations
{
    [NativeType("Modules/Animation/Constraints/ConstraintEnums.h")]
    [Flags]
    public enum Axis
    {
        None = 0,
        X = 1,
        Y = 2,
        Z = 4
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Animations
{
    [UsedByNativeCode]
    [NativeHeader("Modules/Animation/Constraints/Constraint.bindings.h")]
    [NativeType(CodegenOptions = Custom, Header = "Modules/Animation/Constraints/ConstraintSource.h", IntermediateScriptingStructName = "MonoConstraintSource")]
    public struct ConstraintSource
    {
        public Transform sourceTransform { get; set; }
        public float weight { get; set; }
    }
}
using System.Collections.Generic;

namespace UnityEngine.Animations
{
    public interface IConstraint
    {
        float weight { get; set; }
        bool constraintActive { get; set; }
        bool locked { get; set; }
        int sourceCount { get; }

        int AddSource(ConstraintSource source);
        void RemoveSource(int index);
        ConstraintSource GetSource(int index);
        void SetSource(int index, ConstraintSource source);
        void GetSources(List<ConstraintSource> sources);
        void SetSources(List<ConstraintSource> sources);
    }
}
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Animations
{
    [UsedByNativeCode]
    [NativeHeader("Modules/Animation/Constraints/PositionConstraint.h")]
    [RequireComponent(typeof(Transform))]
    [NativeHeader("Modules/Animation/Constraints/Constraint.bindings.h")]
    public sealed class PositionConstraint : Behaviour, IConstraint, IConstraintInternal
    {
        public float weight { get; set; }
        public Vector3 translationAtRest { get; set; }
        public Vector3 translationOffset { get; set; }
        public Axis translationAxis { get; set; }
        public bool constraintActive { get; set; }
        public bool locked { get; set; }
        public int sourceCount { get; }

        [FreeFunction(Name = "ConstraintBindings::GetSources", HasExplicitThis = True)]
        public void GetSources([NotNull("ArgumentNullException")] List<ConstraintSource> sources);
        public void SetSources(List<ConstraintSource> sources);
        public int AddSource(ConstraintSource source);
        public void RemoveSource(int index);
        public ConstraintSource GetSource(int index);
        public void SetSource(int index, ConstraintSource source);
    }
}
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Animations
{
    [UsedByNativeCode]
    [NativeHeader("Modules/Animation/Constraints/RotationConstraint.h")]
    [NativeHeader("Modules/Animation/Constraints/Constraint.bindings.h")]
    [RequireComponent(typeof(Transform))]
    public sealed class RotationConstraint : Behaviour, IConstraint, IConstraintInternal
    {
        public float weight { get; set; }
        public Vector3 rotationAtRest { get; set; }
        public Vector3 rotationOffset { get; set; }
        public Axis rotationAxis { get; set; }
        public bool constraintActive { get; set; }
        public bool locked { get; set; }
        public int sourceCount { get; }

        [FreeFunction(Name = "ConstraintBindings::GetSources", HasExplicitThis = True)]
        public void GetSources([NotNull("ArgumentNullException")] List<ConstraintSource> sources);
        public void SetSources(List<ConstraintSource> sources);
        public int AddSource(ConstraintSource source);
        public void RemoveSource(int index);
        public ConstraintSource GetSource(int index);
        public void SetSource(int index, ConstraintSource source);
    }
}
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Animations
{
    [UsedByNativeCode]
    [RequireComponent(typeof(Transform))]
    [NativeHeader("Modules/Animation/Constraints/ScaleConstraint.h")]
    [NativeHeader("Modules/Animation/Constraints/Constraint.bindings.h")]
    public sealed class ScaleConstraint : Behaviour, IConstraint, IConstraintInternal
    {
        public float weight { get; set; }
        public Vector3 scaleAtRest { get; set; }
        public Vector3 scaleOffset { get; set; }
        public Axis scalingAxis { get; set; }
        public bool constraintActive { get; set; }
        public bool locked { get; set; }
        public int sourceCount { get; }

        [FreeFunction(Name = "ConstraintBindings::GetSources", HasExplicitThis = True)]
        public void GetSources([NotNull("ArgumentNullException")] List<ConstraintSource> sources);
        public void SetSources(List<ConstraintSource> sources);
        public int AddSource(ConstraintSource source);
        public void RemoveSource(int index);
        public ConstraintSource GetSource(int index);
        public void SetSource(int index, ConstraintSource source);
    }
}
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Animations
{
    [NativeHeader("Modules/Animation/Constraints/Constraint.bindings.h")]
    [NativeHeader("Modules/Animation/Constraints/LookAtConstraint.h")]
    [RequireComponent(typeof(Transform))]
    [UsedByNativeCode]
    public sealed class LookAtConstraint : Behaviour, IConstraint, IConstraintInternal
    {
        public float weight { get; set; }
        public float roll { get; set; }
        public bool constraintActive { get; set; }
        public bool locked { get; set; }
        public Vector3 rotationAtRest { get; set; }
        public Vector3 rotationOffset { get; set; }
        public Transform worldUpObject { get; set; }
        public bool useUpObject { get; set; }
        public int sourceCount { get; }

        [FreeFunction(Name = "ConstraintBindings::GetSources", HasExplicitThis = True)]
        public void GetSources([NotNull("ArgumentNullException")] List<ConstraintSource> sources);
        public void SetSources(List<ConstraintSource> sources);
        public int AddSource(ConstraintSource source);
        public void RemoveSource(int index);
        public ConstraintSource GetSource(int index);
        public void SetSource(int index, ConstraintSource source);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Animations
{
    [NativeHeader("Modules/Animation/MuscleHandle.h")]
    [NativeHeader("Modules/Animation/Animator.h")]
    [MovedFrom("UnityEngine.Experimental.Animations")]
    public struct MuscleHandle
    {
        public MuscleHandle(BodyDof bodyDof);
        public MuscleHandle(HeadDof headDof);
        public MuscleHandle(HumanPartDof partDof, LegDof legDof);
        public MuscleHandle(HumanPartDof partDof, ArmDof armDof);
        public MuscleHandle(HumanPartDof partDof, FingerDof fingerDof);

        public HumanPartDof humanPartDof { get; }
        public int dof { get; }
        public string name { get; }
        public static int muscleHandleCount { get; }

        public static void GetMuscleHandles([NotNull("ArgumentNullException")] out MuscleHandle[] muscleHandles);
    }
}
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Animations
{
    [NativeHeader("Modules/Animation/Constraints/ParentConstraint.h")]
    [NativeHeader("Modules/Animation/Constraints/Constraint.bindings.h")]
    [RequireComponent(typeof(Transform))]
    [UsedByNativeCode]
    public sealed class ParentConstraint : Behaviour, IConstraint, IConstraintInternal
    {
        public float weight { get; set; }
        public bool constraintActive { get; set; }
        public bool locked { get; set; }
        public int sourceCount { get; }
        public Vector3 translationAtRest { get; set; }
        public Vector3 rotationAtRest { get; set; }
        public Vector3[] translationOffsets { get; set; }
        public Vector3[] rotationOffsets { get; set; }
        public Axis translationAxis { get; set; }
        public Axis rotationAxis { get; set; }

        public Vector3 GetTranslationOffset(int index);
        public void SetTranslationOffset(int index, Vector3 value);
        public Vector3 GetRotationOffset(int index);
        public void SetRotationOffset(int index, Vector3 value);
        [FreeFunction(Name = "ConstraintBindings::GetSources", HasExplicitThis = True)]
        public void GetSources([NotNull("ArgumentNullException")] List<ConstraintSource> sources);
        public void SetSources(List<ConstraintSource> sources);
        public int AddSource(ConstraintSource source);
        public void RemoveSource(int index);
        public ConstraintSource GetSource(int index);
        public void SetSource(int index, ConstraintSource source);
    }
}
using System;
using UnityEngine;

namespace UnityEditorInternal
{
    [NativeClass(null)]
    [Obsolete("Transition is obsolete. Use UnityEditor.Animations.AnimatorTransition instead (UnityUpgradable) -> UnityEditor.Animations.AnimatorTransition", True)]
    public class Transition : UnityEngine.Object
    {
        public Transition();
    }
}
using System;
using UnityEngine;

namespace UnityEditorInternal
{
    [Obsolete("StateMachine is obsolete. Use UnityEditor.Animations.AnimatorStateMachine instead (UnityUpgradable) -> UnityEditor.Animations.AnimatorStateMachine", True)]
    [NativeClass(null)]
    public class StateMachine : UnityEngine.Object
    {
        public StateMachine();

        public State defaultState { get; set; }
        public Vector3 anyStatePosition { get; set; }
        public Vector3 parentStateMachinePosition { get; set; }

        public State GetState(int index);
        public State AddState(string stateName);
        public StateMachine GetStateMachine(int index);
        public StateMachine AddStateMachine(string stateMachineName);
        public Transition AddTransition(State src, State dst);
        public Transition AddAnyStateTransition(State dst);
        public Vector3 GetStateMachinePosition(int i);
        public Transition[] GetTransitionsFromState(State srcState);
    }
}
using System;
using UnityEngine;

namespace UnityEditorInternal
{
    [NativeClass(null)]
    [Obsolete("State is obsolete. Use UnityEditor.Animations.AnimatorState instead (UnityUpgradable) -> UnityEditor.Animations.AnimatorState", True)]
    public class State : UnityEngine.Object
    {
        public State();

        public string uniqueName { get; }
        public int uniqueNameHash { get; }
        public float speed { get; set; }
        public bool mirror { get; set; }
        public bool iKOnFeet { get; set; }
        public string tag { get; set; }

        public Motion GetMotion();
        public Motion GetMotion(AnimatorControllerLayer layer);
        public BlendTree CreateBlendTree();
        public BlendTree CreateBlendTree(AnimatorControllerLayer layer);
    }
}
using System;
using UnityEngine;

namespace UnityEditorInternal
{
    [NativeClass(null)]
    [Obsolete("AnimatorController is obsolete. Use UnityEditor.Animations.AnimatorController instead (UnityUpgradable) -> UnityEditor.Animations.AnimatorController", True)]
    public class AnimatorController : RuntimeAnimatorController
    {
        public AnimatorController();
    }
}
using System;
using UnityEngine;

namespace UnityEditorInternal
{
    [NativeClass(null)]
    [Obsolete("BlendTree is obsolete. Use UnityEditor.Animations.BlendTree instead (UnityUpgradable) -> UnityEditor.Animations.BlendTree", True)]
    public class BlendTree : Motion
    {
        public BlendTree();
    }
}
using System;

namespace UnityEditorInternal
{
    [Obsolete("AnimatorControllerLayer is obsolete. Use UnityEditor.Animations.AnimatorControllerLayer instead (UnityUpgradable) -> UnityEditor.Animations.AnimatorControllerLayer", True)]
    public class AnimatorControllerLayer
    {
        public AnimatorControllerLayer();
    }
}
using System;

namespace UnityEditorInternal
{
    [Obsolete("AnimatorControllerParameter is obsolete. Use UnityEngine.AnimatorControllerParameter instead (UnityUpgradable) -> [UnityEngine] UnityEngine.AnimatorControllerParameter", True)]
    public class AnimatorControllerParameter
    {
        public AnimatorControllerParameter();
    }
}
using System;

namespace UnityEditorInternal
{
    [Obsolete("AnimatorControllerParameterType is obsolete. Use UnityEngine.AnimatorControllerParameterType instead (UnityUpgradable) -> [UnityEngine] UnityEngine.AnimatorControllerParameterType", True)]
    public enum AnimatorControllerParameterType
    {
        Float = -1,
        Int = -1,
        Bool = -1,
        Trigger = -1
    }
}
using System;

namespace UnityEditorInternal
{
    [Obsolete("AnimatorLayerBlendingMode is obsolete. Use UnityEditor.Animations.AnimatorLayerBlendingMode instead (UnityUpgradable) -> UnityEditor.Animations.AnimatorLayerBlendingMode", True)]
    public enum AnimatorLayerBlendingMode
    {
        Override = -1,
        Additive = -1
    }
}
-------- {UnityEngine.AssetBundleModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.AssetBundleModule.dll)}:   10 --------
namespace UnityEngine
{
    public enum AssetBundleLoadResult
    {
        Success = 0,
        Cancelled = 1,
        NotMatchingCrc = 2,
        FailedCache = 3,
        NotValidAssetBundle = 4,
        NoSerializedData = 5,
        NotCompatible = 6,
        AlreadyLoaded = 7,
        FailedRead = 8,
        FailedDecompression = 9,
        FailedWrite = 10,
        FailedDeleteRecompressionTarget = 11,
        RecompressionTargetIsLoaded = 12,
        RecompressionTargetExistsButNotArchive = 13
    }
}
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using UnityEngine.Bindings;
using UnityEngineInternal;

namespace UnityEngine
{
    [NativeHeader("Modules/AssetBundle/Public/AssetBundleLoadFromMemoryAsyncOperation.h")]
    [NativeHeader("Modules/AssetBundle/Public/AssetBundleLoadFromManagedStreamAsyncOperation.h")]
    [NativeHeader("Modules/AssetBundle/Public/AssetBundleLoadAssetOperation.h")]
    [NativeHeader("Runtime/Scripting/ScriptingExportUtility.h")]
    [NativeHeader("Runtime/Scripting/ScriptingObjectWithIntPtrField.h")]
    [NativeHeader("Runtime/Scripting/ScriptingUtility.h")]
    [NativeHeader("AssetBundleScriptingClasses.h")]
    [NativeHeader("Modules/AssetBundle/Public/AssetBundleSaveAndLoadHelper.h")]
    [NativeHeader("Modules/AssetBundle/Public/AssetBundleUtility.h")]
    [NativeHeader("Modules/AssetBundle/Public/AssetBundleLoadAssetUtility.h")]
    [ExcludeFromPreset]
    [NativeHeader("Modules/AssetBundle/Public/AssetBundleLoadFromFileAsyncOperation.h")]
    public class AssetBundle : Object
    {
        [Obsolete("mainAsset has been made obsolete. Please use the new AssetBundle build system introduced in 5.0 and check BuildAssetBundles documentation for details.")]
        public Object mainAsset { get; }
        public bool isStreamedSceneAssetBundle { get; }
        public static uint memoryBudgetKB { get; set; }

        [FreeFunction("UnloadAllAssetBundles")]
        public static void UnloadAllAssetBundles(bool unloadAllObjects);
        public static IEnumerable<AssetBundle> GetAllLoadedAssetBundles();
        public static AssetBundleCreateRequest LoadFromFileAsync(string path);
        public static AssetBundleCreateRequest LoadFromFileAsync(string path, uint crc);
        public static AssetBundleCreateRequest LoadFromFileAsync(string path, uint crc, ulong offset);
        public static AssetBundle LoadFromFile(string path);
        public static AssetBundle LoadFromFile(string path, uint crc);
        public static AssetBundle LoadFromFile(string path, uint crc, ulong offset);
        public static AssetBundleCreateRequest LoadFromMemoryAsync(byte[] binary);
        public static AssetBundleCreateRequest LoadFromMemoryAsync(byte[] binary, uint crc);
        public static AssetBundle LoadFromMemory(byte[] binary);
        public static AssetBundle LoadFromMemory(byte[] binary, uint crc);
        public static AssetBundleCreateRequest LoadFromStreamAsync(Stream stream, uint crc, uint managedReadBufferSize);
        public static AssetBundleCreateRequest LoadFromStreamAsync(Stream stream, uint crc);
        public static AssetBundleCreateRequest LoadFromStreamAsync(Stream stream);
        public static AssetBundle LoadFromStream(Stream stream, uint crc, uint managedReadBufferSize);
        public static AssetBundle LoadFromStream(Stream stream, uint crc);
        public static AssetBundle LoadFromStream(Stream stream);
        [NativeMethod("Contains")]
        public bool Contains(string name);
        [Obsolete("Method Load has been deprecated. Script updater cannot update it as the loading behaviour has changed. Please use LoadAsset instead and check the documentation for details.", True)]
        [EditorBrowsable(Never)]
        public Object Load(string name);
        [Obsolete("Method Load has been deprecated. Script updater cannot update it as the loading behaviour has changed. Please use LoadAsset instead and check the documentation for details.", True)]
        [EditorBrowsable(Never)]
        public Object Load<T>(string name);
        [EditorBrowsable(Never)]
        [Obsolete("Method LoadAll has been deprecated. Script updater cannot update it as the loading behaviour has changed. Please use LoadAllAssets instead and check the documentation for details.", True)]
        public Object[] LoadAll();
        [EditorBrowsable(Never)]
        [Obsolete("Method LoadAll has been deprecated. Script updater cannot update it as the loading behaviour has changed. Please use LoadAllAssets instead and check the documentation for details.", True)]
        public T[] LoadAll<T>() where T : Object;
        public Object LoadAsset(string name);
        public T LoadAsset<T>(string name) where T : Object;
        [TypeInferenceRule(TypeReferencedBySecondArgument)]
        public Object LoadAsset(string name, Type type);
        public AssetBundleRequest LoadAssetAsync(string name);
        public AssetBundleRequest LoadAssetAsync<T>(string name);
        public AssetBundleRequest LoadAssetAsync(string name, Type type);
        public Object[] LoadAssetWithSubAssets(string name);
        public T[] LoadAssetWithSubAssets<T>(string name) where T : Object;
        public Object[] LoadAssetWithSubAssets(string name, Type type);
        public AssetBundleRequest LoadAssetWithSubAssetsAsync(string name);
        public AssetBundleRequest LoadAssetWithSubAssetsAsync<T>(string name);
        public AssetBundleRequest LoadAssetWithSubAssetsAsync(string name, Type type);
        public Object[] LoadAllAssets();
        public T[] LoadAllAssets<T>() where T : Object;
        public Object[] LoadAllAssets(Type type);
        public AssetBundleRequest LoadAllAssetsAsync();
        public AssetBundleRequest LoadAllAssetsAsync<T>();
        public AssetBundleRequest LoadAllAssetsAsync(Type type);
        [Obsolete("This method is deprecated.Use GetAllAssetNames() instead.", False)]
        public string[] AllAssetNames();
        [NativeMethod("Unload")]
        public void Unload(bool unloadAllLoadedObjects);
        [NativeMethod("GetAllAssetNames")]
        public string[] GetAllAssetNames();
        [NativeMethod("GetAllScenePaths")]
        public string[] GetAllScenePaths();
        public static AssetBundleRecompressOperation RecompressAssetBundleAsync(string inputPath, string outputPath, BuildCompression method, uint expectedCRC = 0, ThreadPriority priority = Low);
        [EditorBrowsable(Never)]
        [Obsolete("Method CreateFromFile has been renamed to LoadFromFile (UnityUpgradable) -> LoadFromFile(*)", True)]
        public static AssetBundle CreateFromFile(string path);
        [EditorBrowsable(Never)]
        [Obsolete("Method CreateFromMemory has been renamed to LoadFromMemoryAsync (UnityUpgradable) -> LoadFromMemoryAsync(*)", True)]
        public static AssetBundleCreateRequest CreateFromMemory(byte[] binary);
        [EditorBrowsable(Never)]
        [Obsolete("Method CreateFromMemoryImmediate has been renamed to LoadFromMemory (UnityUpgradable) -> LoadFromMemory(*)", True)]
        public static AssetBundle CreateFromMemoryImmediate(byte[] binary);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [RequiredByNativeCode]
    [NativeHeader("Modules/AssetBundle/Public/AssetBundleLoadFromAsyncOperation.h")]
    public class AssetBundleCreateRequest : AsyncOperation
    {
        public AssetBundleCreateRequest();

        public AssetBundle assetBundle { get; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/AssetBundle/Public/AssetBundleManifest.h")]
    public class AssetBundleManifest : Object
    {
        [NativeMethod("GetAllAssetBundles")]
        public string[] GetAllAssetBundles();
        [NativeMethod("GetAllAssetBundlesWithVariant")]
        public string[] GetAllAssetBundlesWithVariant();
        [NativeMethod("GetAssetBundleHash")]
        public Hash128 GetAssetBundleHash(string assetBundleName);
        [NativeMethod("GetDirectDependencies")]
        public string[] GetDirectDependencies(string assetBundleName);
        [NativeMethod("GetAllDependencies")]
        public string[] GetAllDependencies(string assetBundleName);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Modules/AssetBundle/Public/AssetBundleRecompressOperation.h")]
    [RequiredByNativeCode]
    public class AssetBundleRecompressOperation : AsyncOperation
    {
        public AssetBundleRecompressOperation();

        public string humanReadableResult { get; }
        public string inputPath { get; }
        public string outputPath { get; }
        public AssetBundleLoadResult result { get; }
        public bool success { get; }
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [RequiredByNativeCode]
    [NativeHeader("Modules/AssetBundle/Public/AssetBundleLoadAssetOperation.h")]
    public class AssetBundleRequest : ResourceRequest
    {
        public AssetBundleRequest();

        public Object asset { get; }
        public Object[] allAssets { get; }

        [NativeMethod("GetLoadedAsset")]
        protected override Object GetResult();
    }
}
namespace UnityEngine
{
    public enum CompressionType
    {
        None = 0,
        Lzma = 1,
        Lz4 = 2,
        Lz4HC = 3
    }
}
namespace UnityEngine
{
    public enum CompressionLevel
    {
        None = 0,
        Fastest = 1,
        Fast = 2,
        Normal = 3,
        High = 4,
        Maximum = 5
    }
}
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    public struct BuildCompression
    {
        public static readonly BuildCompression Uncompressed;
        public static readonly BuildCompression LZ4;
        public static readonly BuildCompression LZMA;
        public static readonly BuildCompression UncompressedRuntime;
        public static readonly BuildCompression LZ4Runtime;

        public CompressionType compression { get; }
        public CompressionLevel level { get; }
        public uint blockSize { get; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Experimental.AssetBundlePatching
{
    [NativeHeader("Modules/AssetBundle/Public/AssetBundlePatching.h")]
    public static class AssetBundleUtility
    {
        [FreeFunction]
        public static void PatchAssetBundles(AssetBundle[] bundles, string[] filenames);
    }
}
-------- {UnityEngine.AudioModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.AudioModule.dll)}:   50 --------
using System;
using System.ComponentModel;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [StaticAccessor("GetAudioManager()", Dot)]
    [NativeHeader("Modules/Audio/Public/ScriptBindings/Audio.bindings.h")]
    public sealed class AudioSettings
    {
        public AudioSettings();

        [Obsolete("AudioSettings.driverCaps is obsolete. Use driverCapabilities instead (UnityUpgradable) -> driverCapabilities", True)]
        [EditorBrowsable(Never)]
        public static AudioSpeakerMode driverCaps { get; }
        public static AudioSpeakerMode driverCapabilities { get; }
        public static AudioSpeakerMode speakerMode { get; set; }
        public static double dspTime { get; }
        public static int outputSampleRate { get; set; }

        public static event AudioConfigurationChangeHandler OnAudioConfigurationChanged;

        [NativeMethod(Name = "AudioSettings::GetDSPBufferSize", IsFreeFunction = True)]
        public static void GetDSPBufferSize(out int bufferLength, out int numBuffers);
        [Obsolete("AudioSettings.SetDSPBufferSize is deprecated and has been replaced by audio project settings and the AudioSettings.GetConfiguration/AudioSettings.Reset API.")]
        public static void SetDSPBufferSize(int bufferLength, int numBuffers);
        [NativeMethod(Name = "AudioSettings::GetSpatializerNames", IsFreeFunction = True)]
        public static string[] GetSpatializerPluginNames();
        [NativeName("GetCurrentSpatializerDefinitionName")]
        public static string GetSpatializerPluginName();
        public static void SetSpatializerPluginName(string pluginName);
        public static AudioConfiguration GetConfiguration();
        public static bool Reset(AudioConfiguration config);

        public delegate void AudioConfigurationChangeHandler(bool deviceWasChanged);
        public static class Mobile
        {
            public static bool muteState { get; }
            public static bool stopAudioOutputOnMute { get; set; }
            public static bool audioOutputStarted { get; }

            public static event Action<bool> OnMuteStateChanged;

            public static void StartAudioOutput();
            public static void StopAudioOutput();
        }
    }
}
using System;
using System.ComponentModel;
using UnityEngine.Audio;
using UnityEngine.Bindings;
using UnityEngine.Internal;

namespace UnityEngine
{
    [RequireComponent(typeof(Transform))]
    [StaticAccessor("AudioSourceBindings", DoubleColon)]
    public sealed class AudioSource : AudioBehaviour
    {
        public AudioSource();

        [EditorBrowsable(Never)]
        [Obsolete("AudioSource.panLevel has been deprecated. Use AudioSource.spatialBlend instead (UnityUpgradable) -> spatialBlend", True)]
        public float panLevel { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("AudioSource.pan has been deprecated. Use AudioSource.panStereo instead (UnityUpgradable) -> panStereo", True)]
        public float pan { get; set; }
        public float volume { get; set; }
        public float pitch { get; set; }
        [NativeProperty("SecPosition")]
        public float time { get; set; }
        [NativeProperty("SamplePosition")]
        public int timeSamples { get; set; }
        [NativeProperty("AudioClip")]
        public AudioClip clip { get; set; }
        public AudioMixerGroup outputAudioMixerGroup { get; set; }
        [NativeConditional("PLATFORM_SUPPORTS_GAMEPAD_AUDIO")]
        public GamepadSpeakerOutputType gamepadSpeakerOutputType { get; set; }
        public bool isPlaying { get; }
        public bool isVirtual { get; }
        public bool loop { get; set; }
        public bool ignoreListenerVolume { get; set; }
        public bool playOnAwake { get; set; }
        public bool ignoreListenerPause { get; set; }
        public AudioVelocityUpdateMode velocityUpdateMode { get; set; }
        [NativeProperty("StereoPan")]
        public float panStereo { get; set; }
        [NativeProperty("SpatialBlendMix")]
        public float spatialBlend { get; set; }
        public bool spatialize { get; set; }
        public bool spatializePostEffects { get; set; }
        public float reverbZoneMix { get; set; }
        public bool bypassEffects { get; set; }
        public bool bypassListenerEffects { get; set; }
        public bool bypassReverbZones { get; set; }
        public float dopplerLevel { get; set; }
        public float spread { get; set; }
        public int priority { get; set; }
        public bool mute { get; set; }
        public float minDistance { get; set; }
        public float maxDistance { get; set; }
        public AudioRolloffMode rolloffMode { get; set; }
        [Obsolete("minVolume is not supported anymore. Use min-, maxDistance and rolloffMode instead.", True)]
        public float minVolume { get; set; }
        [Obsolete("maxVolume is not supported anymore. Use min-, maxDistance and rolloffMode instead.", True)]
        public float maxVolume { get; set; }
        [Obsolete("rolloffFactor is not supported anymore. Use min-, maxDistance and rolloffMode instead.", True)]
        public float rolloffFactor { get; set; }

        [NativeConditional("PLATFORM_SUPPORTS_GAMEPAD_AUDIO")]
        [NativeMethod(Name = "AudioSourceBindings::PlayOnGamepad", HasExplicitThis = True, ThrowsException = True)]
        public bool PlayOnGamepad(int slot);
        [NativeConditional("PLATFORM_SUPPORTS_GAMEPAD_AUDIO")]
        [NativeMethod(Name = "AudioSourceBindings::DisableGamepadOutput", HasExplicitThis = True)]
        public bool DisableGamepadOutput();
        [NativeConditional("PLATFORM_SUPPORTS_GAMEPAD_AUDIO")]
        [NativeMethod(Name = "AudioSourceBindings::SetGamepadSpeakerMixLevel", HasExplicitThis = True, ThrowsException = True)]
        public bool SetGamepadSpeakerMixLevel(int slot, int mixLevel);
        [NativeConditional("PLATFORM_SUPPORTS_GAMEPAD_AUDIO")]
        [NativeMethod(Name = "AudioSourceBindings::SetGamepadSpeakerMixLevelDefault", HasExplicitThis = True, ThrowsException = True)]
        public bool SetGamepadSpeakerMixLevelDefault(int slot);
        [NativeConditional("PLATFORM_SUPPORTS_GAMEPAD_AUDIO")]
        [NativeMethod(Name = "AudioSourceBindings::SetGamepadSpeakerRestrictedAudio", HasExplicitThis = True, ThrowsException = True)]
        public bool SetGamepadSpeakerRestrictedAudio(int slot, bool restricted);
        [NativeConditional("PLATFORM_SUPPORTS_GAMEPAD_AUDIO")]
        [NativeMethod(Name = "GamepadSpeakerSupportsOutputType", HasExplicitThis = False)]
        public static bool GamepadSpeakerSupportsOutputType(GamepadSpeakerOutputType outputType);
        [ExcludeFromDocs]
        public void Play();
        public void Play([UnityEngine.Internal.DefaultValue("0")] ulong delay);
        public void PlayDelayed(float delay);
        public void PlayScheduled(double time);
        [ExcludeFromDocs]
        public void PlayOneShot(AudioClip clip);
        public void PlayOneShot(AudioClip clip, [UnityEngine.Internal.DefaultValue("1.0F")] float volumeScale);
        public void SetScheduledStartTime(double time);
        public void SetScheduledEndTime(double time);
        public void Stop();
        public void Pause();
        public void UnPause();
        [ExcludeFromDocs]
        public static void PlayClipAtPoint(AudioClip clip, Vector3 position);
        public static void PlayClipAtPoint(AudioClip clip, Vector3 position, [UnityEngine.Internal.DefaultValue("1.0F")] float volume);
        public void SetCustomCurve(AudioSourceCurveType type, AnimationCurve curve);
        public AnimationCurve GetCustomCurve(AudioSourceCurveType type);
        [Obsolete("GetOutputData returning a float[] is deprecated, use GetOutputData and pass a pre allocated array instead.")]
        public float[] GetOutputData(int numSamples, int channel);
        public void GetOutputData(float[] samples, int channel);
        [Obsolete("GetSpectrumData returning a float[] is deprecated, use GetSpectrumData and pass a pre allocated array instead.")]
        public float[] GetSpectrumData(int numSamples, int channel, FFTWindow window);
        public void GetSpectrumData(float[] samples, int channel, FFTWindow window);
        public bool SetSpatializerFloat(int index, float value);
        public bool GetSpatializerFloat(int index, out float value);
        public bool GetAmbisonicDecoderFloat(int index, out float value);
        public bool SetAmbisonicDecoderFloat(int index, float value);
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [RequireComponent(typeof(AudioBehaviour))]
    public sealed class AudioLowPassFilter : Behaviour
    {
        public AudioLowPassFilter();

        [EditorBrowsable(Never)]
        [Obsolete("AudioLowPassFilter.lowpassResonaceQ is obsolete. Use lowpassResonanceQ instead (UnityUpgradable) -> lowpassResonanceQ", True)]
        public float lowpassResonaceQ { get; set; }
        public AnimationCurve customCutoffCurve { get; set; }
        public float cutoffFrequency { get; set; }
        public float lowpassResonanceQ { get; set; }
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [RequireComponent(typeof(AudioBehaviour))]
    public sealed class AudioHighPassFilter : Behaviour
    {
        public AudioHighPassFilter();

        [Obsolete("AudioHighPassFilter.highpassResonaceQ is obsolete. Use highpassResonanceQ instead (UnityUpgradable) -> highpassResonanceQ", True)]
        [EditorBrowsable(Never)]
        public float highpassResonaceQ { get; set; }
        public float cutoffFrequency { get; set; }
        public float highpassResonanceQ { get; set; }
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [RequireComponent(typeof(AudioBehaviour))]
    public sealed class AudioReverbFilter : Behaviour
    {
        public AudioReverbFilter();

        [Obsolete("AudioReverbFilter.lFReference is obsolete. Use lfReference instead (UnityUpgradable) -> lfReference", True)]
        [EditorBrowsable(Never)]
        public float lFReference { get; set; }
        public AudioReverbPreset reverbPreset { get; set; }
        public float dryLevel { get; set; }
        public float room { get; set; }
        public float roomHF { get; set; }
        [Obsolete("Warning! roomRolloffFactor is no longer supported.")]
        public float roomRolloffFactor { get; set; }
        public float decayTime { get; set; }
        public float decayHFRatio { get; set; }
        public float reflectionsLevel { get; set; }
        public float reflectionsDelay { get; set; }
        public float reverbLevel { get; set; }
        public float reverbDelay { get; set; }
        public float diffusion { get; set; }
        public float density { get; set; }
        public float hfReference { get; set; }
        public float roomLF { get; set; }
        public float lfReference { get; set; }
    }
}
using System;

namespace UnityEngine
{
    public enum AudioSpeakerMode
    {
        [Obsolete("Raw speaker mode is not supported. Do not use.", True)]
        Raw = 0,
        Mono = 1,
        Stereo = 2,
        Quad = 3,
        Surround = 4,
        Mode5point1 = 5,
        Mode7point1 = 6,
        Prologic = 7
    }
}
namespace UnityEngine
{
    public enum AudioDataLoadState
    {
        Unloaded = 0,
        Loading = 1,
        Loaded = 2,
        Failed = 3
    }
}
namespace UnityEngine
{
    public struct AudioConfiguration
    {
        public AudioSpeakerMode speakerMode;
        public int dspBufferSize;
        public int sampleRate;
        public int numRealVoices;
        public int numVirtualVoices;
    }
}
namespace UnityEngine
{
    public enum AudioCompressionFormat
    {
        PCM = 0,
        Vorbis = 1,
        ADPCM = 2,
        MP3 = 3,
        VAG = 4,
        HEVAG = 5,
        XMA = 6,
        AAC = 7,
        GCADPCM = 8,
        ATRAC9 = 9
    }
}
namespace UnityEngine
{
    public enum AudioClipLoadType
    {
        DecompressOnLoad = 0,
        CompressedInMemory = 1,
        Streaming = 2
    }
}
namespace UnityEngine
{
    public enum AudioVelocityUpdateMode
    {
        Auto = 0,
        Fixed = 1,
        Dynamic = 2
    }
}
namespace UnityEngine
{
    public enum FFTWindow
    {
        Rectangular = 0,
        Triangle = 1,
        Hamming = 2,
        Hanning = 3,
        Blackman = 4,
        BlackmanHarris = 5
    }
}
namespace UnityEngine
{
    public enum AudioRolloffMode
    {
        Logarithmic = 0,
        Linear = 1,
        Custom = 2
    }
}
namespace UnityEngine
{
    public enum AudioSourceCurveType
    {
        CustomRolloff = 0,
        SpatialBlend = 1,
        ReverbZoneMix = 2,
        Spread = 3
    }
}
namespace UnityEngine
{
    public enum GamepadSpeakerOutputType
    {
        Speaker = 0,
        Vibration = 1
    }
}
namespace UnityEngine
{
    public enum AudioReverbPreset
    {
        Off = 0,
        Generic = 1,
        PaddedCell = 2,
        Room = 3,
        Bathroom = 4,
        Livingroom = 5,
        Stoneroom = 6,
        Auditorium = 7,
        Concerthall = 8,
        Cave = 9,
        Arena = 10,
        Hangar = 11,
        CarpetedHallway = 12,
        Hallway = 13,
        StoneCorridor = 14,
        Alley = 15,
        Forest = 16,
        City = 17,
        Mountains = 18,
        Quarry = 19,
        Plain = 20,
        ParkingLot = 21,
        SewerPipe = 22,
        Underwater = 23,
        Drugged = 24,
        Dizzy = 25,
        Psychotic = 26,
        User = 27
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Audio/Public/ScriptBindings/Audio.bindings.h")]
    [StaticAccessor("AudioClipBindings", DoubleColon)]
    public sealed class AudioClip : Object
    {
        [NativeProperty("LengthSec")]
        public float length { get; }
        [NativeProperty("SampleCount")]
        public int samples { get; }
        [NativeProperty("ChannelCount")]
        public int channels { get; }
        public int frequency { get; }
        [Obsolete("Use AudioClip.loadState instead to get more detailed information about the loading process.")]
        public bool isReadyToPlay { get; }
        public AudioClipLoadType loadType { get; }
        public bool preloadAudioData { get; }
        public bool ambisonic { get; }
        public bool loadInBackground { get; }
        public AudioDataLoadState loadState { get; }

        public bool LoadAudioData();
        public bool UnloadAudioData();
        public bool GetData(float[] data, int offsetSamples);
        public bool SetData(float[] data, int offsetSamples);
        [Obsolete("The _3D argument of AudioClip is deprecated. Use the spatialBlend property of AudioSource instead to morph between 2D and 3D playback.")]
        public static AudioClip Create(string name, int lengthSamples, int channels, int frequency, bool _3D, bool stream);
        [Obsolete("The _3D argument of AudioClip is deprecated. Use the spatialBlend property of AudioSource instead to morph between 2D and 3D playback.")]
        public static AudioClip Create(string name, int lengthSamples, int channels, int frequency, bool _3D, bool stream, PCMReaderCallback pcmreadercallback);
        [Obsolete("The _3D argument of AudioClip is deprecated. Use the spatialBlend property of AudioSource instead to morph between 2D and 3D playback.")]
        public static AudioClip Create(string name, int lengthSamples, int channels, int frequency, bool _3D, bool stream, PCMReaderCallback pcmreadercallback, PCMSetPositionCallback pcmsetpositioncallback);
        public static AudioClip Create(string name, int lengthSamples, int channels, int frequency, bool stream);
        public static AudioClip Create(string name, int lengthSamples, int channels, int frequency, bool stream, PCMReaderCallback pcmreadercallback);
        public static AudioClip Create(string name, int lengthSamples, int channels, int frequency, bool stream, PCMReaderCallback pcmreadercallback, PCMSetPositionCallback pcmsetpositioncallback);

        public delegate void PCMReaderCallback(float[] data);
        public delegate void PCMSetPositionCallback(int position);
    }
}
namespace UnityEngine
{
    public class AudioBehaviour : Behaviour
    {
        public AudioBehaviour();
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [RequireComponent(typeof(Transform))]
    [StaticAccessor("AudioListenerBindings", DoubleColon)]
    public sealed class AudioListener : AudioBehaviour
    {
        public AudioListener();

        public static float volume { get; set; }
        [NativeProperty("ListenerPause")]
        public static bool pause { get; set; }
        public AudioVelocityUpdateMode velocityUpdateMode { get; set; }

        [Obsolete("GetOutputData returning a float[] is deprecated, use GetOutputData and pass a pre allocated array instead.")]
        public static float[] GetOutputData(int numSamples, int channel);
        public static void GetOutputData(float[] samples, int channel);
        [Obsolete("GetSpectrumData returning a float[] is deprecated, use GetSpectrumData and pass a pre allocated array instead.")]
        public static float[] GetSpectrumData(int numSamples, int channel, FFTWindow window);
        public static void GetSpectrumData(float[] samples, int channel, FFTWindow window);
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Audio/Public/AudioReverbZone.h")]
    [RequireComponent(typeof(Transform))]
    public sealed class AudioReverbZone : Behaviour
    {
        public AudioReverbZone();

        public float minDistance { get; set; }
        public float maxDistance { get; set; }
        public AudioReverbPreset reverbPreset { get; set; }
        public int room { get; set; }
        public int roomHF { get; set; }
        public int roomLF { get; set; }
        public float decayTime { get; set; }
        public float decayHFRatio { get; set; }
        public int reflections { get; set; }
        public float reflectionsDelay { get; set; }
        public int reverb { get; set; }
        public float reverbDelay { get; set; }
        public float HFReference { get; set; }
        public float LFReference { get; set; }
        [Obsolete("Warning! roomRolloffFactor is no longer supported.")]
        public float roomRolloffFactor { get; set; }
        public float diffusion { get; set; }
        public float density { get; set; }
    }
}
namespace UnityEngine
{
    [RequireComponent(typeof(AudioBehaviour))]
    public sealed class AudioDistortionFilter : Behaviour
    {
        public AudioDistortionFilter();

        public float distortionLevel { get; set; }
    }
}
namespace UnityEngine
{
    [RequireComponent(typeof(AudioBehaviour))]
    public sealed class AudioEchoFilter : Behaviour
    {
        public AudioEchoFilter();

        public float delay { get; set; }
        public float decayRatio { get; set; }
        public float dryMix { get; set; }
        public float wetMix { get; set; }
    }
}
using System;

namespace UnityEngine
{
    [RequireComponent(typeof(AudioBehaviour))]
    public sealed class AudioChorusFilter : Behaviour
    {
        public AudioChorusFilter();

        public float dryMix { get; set; }
        public float wetMix1 { get; set; }
        public float wetMix2 { get; set; }
        public float wetMix3 { get; set; }
        public float delay { get; set; }
        public float rate { get; set; }
        public float depth { get; set; }
        [Obsolete("Warning! Feedback is deprecated. This property does nothing.")]
        public float feedback { get; set; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [StaticAccessor("GetAudioManager()", Dot)]
    public sealed class Microphone
    {
        public Microphone();

        public static string[] devices { get; }

        public static AudioClip Start(string deviceName, bool loop, int lengthSec, int frequency);
        public static void End(string deviceName);
        public static bool IsRecording(string deviceName);
        public static int GetPosition(string deviceName);
        public static void GetDeviceCaps(string deviceName, out int minFreq, out int maxFreq);
    }
}
using Unity.Collections;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeType(Header = "Modules/Audio/Public/ScriptBindings/AudioRenderer.bindings.h")]
    public class AudioRenderer
    {
        public AudioRenderer();

        public static bool Start();
        public static bool Stop();
        public static int GetSampleCountForCaptureFrame();
        public static bool Render(NativeArray<float> buffer);
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [EditorBrowsable(Never)]
    [Obsolete("MovieTexture is removed. Use VideoPlayer instead.", True)]
    [ExcludeFromObjectFactory]
    [ExcludeFromPreset]
    public sealed class MovieTexture : Texture
    {
        [Obsolete("MovieTexture is removed. Use VideoPlayer instead.", True)]
        public AudioClip audioClip { get; }
        [Obsolete("MovieTexture is removed. Use VideoPlayer instead.", True)]
        public bool loop { get; set; }
        [Obsolete("MovieTexture is removed. Use VideoPlayer instead.", True)]
        public bool isPlaying { get; }
        [Obsolete("MovieTexture is removed. Use VideoPlayer instead.", True)]
        public bool isReadyToPlay { get; }
        [Obsolete("MovieTexture is removed. Use VideoPlayer instead.", True)]
        public float duration { get; }

        [Obsolete("MovieTexture is removed. Use VideoPlayer instead.", True)]
        public void Play();
        [Obsolete("MovieTexture is removed. Use VideoPlayer instead.", True)]
        public void Stop();
        [Obsolete("MovieTexture is removed. Use VideoPlayer instead.", True)]
        public void Pause();
    }
}
namespace UnityEngine
{
    public enum WebCamFlags
    {
        FrontFacing = 1,
        AutoFocusPointSupported = 2
    }
}
namespace UnityEngine
{
    public enum WebCamKind
    {
        WideAngle = 1,
        Telephoto = 2,
        ColorAndDepth = 3,
        UltraWideAngle = 4
    }
}
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    public struct WebCamDevice
    {
        public string name { get; }
        public bool isFrontFacing { get; }
        public WebCamKind kind { get; }
        public string depthCameraName { get; }
        public bool isAutoFocusPointSupported { get; }
        public Resolution[] availableResolutions { get; }
    }
}
using UnityEngine.Bindings;
using UnityEngine.Internal;

namespace UnityEngine
{
    [NativeHeader("AudioScriptingClasses.h")]
    [NativeHeader("Runtime/Video/ScriptBindings/WebCamTexture.bindings.h")]
    [NativeHeader("Runtime/Video/BaseWebCamTexture.h")]
    public sealed class WebCamTexture : Texture
    {
        public WebCamTexture(string deviceName, int requestedWidth, int requestedHeight, int requestedFPS);
        public WebCamTexture(string deviceName, int requestedWidth, int requestedHeight);
        public WebCamTexture(string deviceName);
        public WebCamTexture(int requestedWidth, int requestedHeight, int requestedFPS);
        public WebCamTexture(int requestedWidth, int requestedHeight);
        public WebCamTexture();

        public static WebCamDevice[] devices { get; }
        public bool isPlaying { get; }
        [NativeName("Device")]
        public string deviceName { get; set; }
        public float requestedFPS { get; set; }
        public int requestedWidth { get; set; }
        public int requestedHeight { get; set; }
        public int videoRotationAngle { get; }
        public bool videoVerticallyMirrored { get; }
        public bool didUpdateThisFrame { get; }
        public Vector2? autoFocusPoint { get; set; }
        public bool isDepth { get; }

        public void Play();
        public void Pause();
        public void Stop();
        public Color GetPixel(int x, int y);
        public Color[] GetPixels();
        [FreeFunction("WebCamTextureBindings::Internal_GetPixels", HasExplicitThis = True)]
        public Color[] GetPixels(int x, int y, int blockWidth, int blockHeight);
        [ExcludeFromDocs]
        public Color32[] GetPixels32();
        [FreeFunction("WebCamTextureBindings::Internal_GetPixels32", HasExplicitThis = True)]
        public Color32[] GetPixels32([DefaultValue("null")] Color32[] colors);
    }
}
using System;
using System.ComponentModel;
using UnityEngine.Bindings;
using UnityEngine.Playables;
using UnityEngine.Scripting;

namespace UnityEngine.Audio
{
    [RequiredByNativeCode]
    [NativeHeader("Runtime/Director/Core/HPlayable.h")]
    [NativeHeader("Modules/Audio/Public/Director/AudioClipPlayable.h")]
    [NativeHeader("Modules/Audio/Public/ScriptBindings/AudioClipPlayable.bindings.h")]
    [StaticAccessor("AudioClipPlayableBindings", DoubleColon)]
    public struct AudioClipPlayable : IEquatable<AudioClipPlayable>, IPlayable
    {
        public static AudioClipPlayable Create(PlayableGraph graph, AudioClip clip, bool looping);
        public PlayableHandle GetHandle();
        public bool Equals(AudioClipPlayable other);
        public AudioClip GetClip();
        public void SetClip(AudioClip value);
        public bool GetLooped();
        public void SetLooped(bool value);
        [Obsolete("IsPlaying() has been deprecated. Use IsChannelPlaying() instead (UnityUpgradable) -> IsChannelPlaying()", True)]
        [EditorBrowsable(Never)]
        public bool IsPlaying();
        public bool IsChannelPlaying();
        public double GetStartDelay();
        public double GetPauseDelay();
        public void Seek(double startTime, double startDelay);
        public void Seek(double startTime, double startDelay, [DefaultValue("0")] double duration);

        public static implicit operator Playable(AudioClipPlayable playable);
        public static explicit operator AudioClipPlayable(Playable playable);
    }
}
namespace UnityEngine.Audio
{
    public enum AudioMixerUpdateMode
    {
        Normal = 0,
        UnscaledTime = 1
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Audio
{
    [ExcludeFromObjectFactory]
    [ExcludeFromPreset]
    [NativeHeader("Modules/Audio/Public/ScriptBindings/AudioMixer.bindings.h")]
    [NativeHeader("Modules/Audio/Public/AudioMixer.h")]
    public class AudioMixer : Object
    {
        [NativeProperty]
        public AudioMixerGroup outputAudioMixerGroup { get; set; }
        [NativeProperty]
        public AudioMixerUpdateMode updateMode { get; set; }

        [NativeMethod("FindSnapshotFromName")]
        public AudioMixerSnapshot FindSnapshot(string name);
        [NativeMethod("AudioMixerBindings::FindMatchingGroups", IsFreeFunction = True, HasExplicitThis = True)]
        public AudioMixerGroup[] FindMatchingGroups(string subPath);
        [NativeMethod("AudioMixerBindings::TransitionToSnapshots", IsFreeFunction = True, HasExplicitThis = True, ThrowsException = True)]
        public void TransitionToSnapshots(AudioMixerSnapshot[] snapshots, float[] weights, float timeToReach);
        [NativeMethod]
        public bool SetFloat(string name, float value);
        [NativeMethod]
        public bool ClearFloat(string name);
        [NativeMethod]
        public bool GetFloat(string name, out float value);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Internal;

namespace UnityEngine.Audio
{
    [NativeHeader("Modules/Audio/Public/AudioMixerGroup.h")]
    public class AudioMixerGroup : Object, ISubAssetNotDuplicatable
    {
        [NativeProperty]
        public AudioMixer audioMixer { get; }
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Playables;
using UnityEngine.Scripting;

namespace UnityEngine.Audio
{
    [NativeHeader("Runtime/Director/Core/HPlayable.h")]
    [RequiredByNativeCode]
    [NativeHeader("Modules/Audio/Public/ScriptBindings/AudioMixerPlayable.bindings.h")]
    [NativeHeader("Modules/Audio/Public/Director/AudioMixerPlayable.h")]
    [StaticAccessor("AudioMixerPlayableBindings", DoubleColon)]
    public struct AudioMixerPlayable : IEquatable<AudioMixerPlayable>, IPlayable
    {
        public static AudioMixerPlayable Create(PlayableGraph graph, int inputCount = 0, bool normalizeInputVolumes = False);
        public PlayableHandle GetHandle();
        public bool Equals(AudioMixerPlayable other);

        public static implicit operator Playable(AudioMixerPlayable playable);
        public static explicit operator AudioMixerPlayable(Playable playable);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Internal;

namespace UnityEngine.Audio
{
    [NativeHeader("Modules/Audio/Public/AudioMixerSnapshot.h")]
    public class AudioMixerSnapshot : Object, ISubAssetNotDuplicatable
    {
        [NativeProperty]
        public AudioMixer audioMixer { get; }

        public void TransitionTo(float timeToReach);
    }
}
using UnityEngine.Playables;

namespace UnityEngine.Audio
{
    public static class AudioPlayableBinding
    {
        public static PlayableBinding Create(string name, Object key);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Playables;
using UnityEngine.Scripting;

namespace UnityEngine.Audio
{
    [NativeHeader("Modules/Audio/Public/ScriptBindings/AudioPlayableOutput.bindings.h")]
    [RequiredByNativeCode]
    [NativeHeader("Modules/Audio/Public/Director/AudioPlayableOutput.h")]
    [StaticAccessor("AudioPlayableOutputBindings", DoubleColon)]
    [NativeHeader("Modules/Audio/Public/AudioSource.h")]
    public struct AudioPlayableOutput : IPlayableOutput
    {
        public static AudioPlayableOutput Null { get; }

        public static AudioPlayableOutput Create(PlayableGraph graph, string name, AudioSource target);
        public PlayableOutputHandle GetHandle();
        public AudioSource GetTarget();
        public void SetTarget(AudioSource value);
        public bool GetEvaluateOnSeek();
        public void SetEvaluateOnSeek(bool value);

        public static implicit operator PlayableOutput(AudioPlayableOutput output);
        public static explicit operator AudioPlayableOutput(PlayableOutput output);
    }
}
using System;
using System.Runtime.InteropServices;
using Unity.Collections;
using UnityEngine.Bindings;

namespace UnityEngine.Experimental.Audio
{
    [NativeType(Header = "Modules/Audio/Public/ScriptBindings/AudioSampleProvider.bindings.h")]
    [StaticAccessor("AudioSampleProviderBindings", DoubleColon)]
    public class AudioSampleProvider : IDisposable
    {
        ~AudioSampleProvider();

        public uint id { get; }
        public ushort trackIndex { get; }
        public Object owner { get; }
        public bool valid { get; }
        public ushort channelCount { get; }
        public uint sampleRate { get; }
        public uint maxSampleFrameCount { get; }
        public uint availableSampleFrameCount { get; }
        public uint freeSampleFrameCount { get; }
        public uint freeSampleFrameCountLowThreshold { get; set; }
        public bool enableSampleFramesAvailableEvents { get; set; }
        public bool enableSilencePadding { get; set; }
        public static ConsumeSampleFramesNativeFunction consumeSampleFramesNativeFunction { get; }

        public event SampleFramesHandler sampleFramesAvailable;
        public event SampleFramesHandler sampleFramesOverflow;

        public void Dispose();
        public uint ConsumeSampleFrames(NativeArray<float> sampleFrames);
        public void SetSampleFramesAvailableNativeHandler(SampleFramesEventNativeFunction handler, IntPtr userData);
        public void ClearSampleFramesAvailableNativeHandler();
        public void SetSampleFramesOverflowNativeHandler(SampleFramesEventNativeFunction handler, IntPtr userData);
        public void ClearSampleFramesOverflowNativeHandler();

        [UnmanagedFunctionPointer(Cdecl)]
        public delegate uint ConsumeSampleFramesNativeFunction(uint providerId, IntPtr interleavedSampleFrames, uint sampleFrameCount);
        public delegate void SampleFramesHandler(AudioSampleProvider provider, uint sampleFrameCount);
        [UnmanagedFunctionPointer(Cdecl)]
        public delegate void SampleFramesEventNativeFunction(IntPtr userData, uint providerId, uint sampleFrameCount);
    }
}
-------- {UnityEngine.ClothModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.ClothModule.dll)}:    4 --------
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Modules/Cloth/Cloth.h")]
    [UsedByNativeCode]
    public struct ClothSphereColliderPair
    {
        public ClothSphereColliderPair(SphereCollider a);
        public ClothSphereColliderPair(SphereCollider a, SphereCollider b);

        public SphereCollider first { get; set; }
        public SphereCollider second { get; set; }
    }
}
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    public struct ClothSkinningCoefficient
    {
        public float maxDistance;
        public float collisionSphereDistance;
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Internal;

namespace UnityEngine
{
    [RequireComponent(typeof(Transform), typeof(SkinnedMeshRenderer))]
    [NativeHeader("Modules/Cloth/Cloth.h")]
    [NativeClass("Unity::Cloth")]
    public sealed class Cloth : Component
    {
        public Cloth();

        public Vector3[] vertices { get; }
        public Vector3[] normals { get; }
        public ClothSkinningCoefficient[] coefficients { get; set; }
        public CapsuleCollider[] capsuleColliders { get; set; }
        public ClothSphereColliderPair[] sphereColliders { get; set; }
        public float sleepThreshold { get; set; }
        public float bendingStiffness { get; set; }
        public float stretchingStiffness { get; set; }
        public float damping { get; set; }
        public Vector3 externalAcceleration { get; set; }
        public Vector3 randomAcceleration { get; set; }
        public bool useGravity { get; set; }
        public bool enabled { get; set; }
        public float friction { get; set; }
        public float collisionMassScale { get; set; }
        public bool enableContinuousCollision { get; set; }
        public float useVirtualParticles { get; set; }
        public float worldVelocityScale { get; set; }
        public float worldAccelerationScale { get; set; }
        public float clothSolverFrequency { get; set; }
        [Obsolete("Parameter solverFrequency is obsolete and no longer supported. Please use clothSolverFrequency instead.")]
        public bool solverFrequency { get; set; }
        public bool useTethers { get; set; }
        public float stiffnessFrequency { get; set; }
        public float selfCollisionDistance { get; set; }
        public float selfCollisionStiffness { get; set; }
        [Obsolete("useContinuousCollision is no longer supported, use enableContinuousCollision instead")]
        public float useContinuousCollision { get; set; }
        [Obsolete("Deprecated.Cloth.selfCollisions is no longer supported since Unity 5.0.", True)]
        public bool selfCollision { get; }

        public void ClearTransformMotion();
        public void GetSelfAndInterCollisionIndices([NotNull("ArgumentNullException")] List<uint> indices);
        public void SetSelfAndInterCollisionIndices([NotNull("ArgumentNullException")] List<uint> indices);
        public void GetVirtualParticleIndices([NotNull("ArgumentNullException")] List<uint> indicesOutList);
        public void SetVirtualParticleIndices([NotNull("ArgumentNullException")] List<uint> indicesIn);
        public void GetVirtualParticleWeights([NotNull("ArgumentNullException")] List<Vector3> weightsOutList);
        public void SetVirtualParticleWeights([NotNull("ArgumentNullException")] List<Vector3> weights);
        public void SetEnabledFading(bool enabled, float interpolationTime);
        [ExcludeFromDocs]
        public void SetEnabledFading(bool enabled);
    }
}
-------- {UnityEngine.ClusterInputModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.ClusterInputModule.dll)}:    1 --------
namespace UnityEngine
{
    public enum ClusterInputType
    {
        Button = 0,
        Axis = 1,
        Tracker = 2,
        CustomProvidedInput = 3
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeConditional("ENABLE_CLUSTERINPUT")]
    [NativeHeader("Modules/ClusterInput/ClusterInput.h")]
    public class ClusterInput
    {
        public ClusterInput();

        public static float GetAxis(string name);
        public static bool GetButton(string name);
        [NativeConditional("ENABLE_CLUSTERINPUT", "Vector3f(0.0f, 0.0f, 0.0f)")]
        public static Vector3 GetTrackerPosition(string name);
        [NativeConditional("ENABLE_CLUSTERINPUT", "Quartenion::identity")]
        public static Quaternion GetTrackerRotation(string name);
        public static void SetAxis(string name, float value);
        public static void SetButton(string name, bool value);
        public static void SetTrackerPosition(string name, Vector3 value);
        public static void SetTrackerRotation(string name, Quaternion value);
        public static bool AddInput(string name, string deviceName, string serverUrl, int index, ClusterInputType type);
        public static bool EditInput(string name, string deviceName, string serverUrl, int index, ClusterInputType type);
        public static bool CheckConnectionToServer(string name);
    }
}
-------- {UnityEngine.ClusterRendererModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.ClusterRendererModule.dll)}:    1 --------
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/ClusterRenderer/ClusterNetwork.h")]
    public class ClusterNetwork
    {
        public ClusterNetwork();

        public static bool isMasterOfCluster { get; }
        public static bool isDisconnected { get; }
        public static int nodeIndex { get; set; }
    }
}
using Unity.Collections;
using UnityEngine.Bindings;
using UnityEngine.Internal;

namespace UnityEngine
{
    [ExcludeFromDocs]
    [NativeHeader("Modules/ClusterRenderer/ClusterSerialization.h")]
    public static class ClusterSerialization
    {
        public static int SaveTimeManagerState(NativeArray<byte> buffer);
        public static bool RestoreTimeManagerState(NativeArray<byte> buffer);
        public static int SaveInputManagerState(NativeArray<byte> buffer);
        public static bool RestoreInputManagerState(NativeArray<byte> buffer);
        public static int SaveClusterInputState(NativeArray<byte> buffer);
        public static bool RestoreClusterInputState(NativeArray<byte> buffer);
    }
}
-------- {UnityEngine.CoreModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.CoreModule.dll)}: 1209 --------
using System;

namespace AOT
{
    [AttributeUsage(Method)]
    public class MonoPInvokeCallbackAttribute : Attribute
    {
        public MonoPInvokeCallbackAttribute(Type type);
    }
}
using System;

namespace UnityEditor.Experimental
{
    public class RenderSettings
    {
        public RenderSettings();

        [Obsolete("Use UnityEngine.Experimental.GlobalIllumination.useRadianceAmbientProbe instead. (UnityUpgradable) -> UnityEngine.Experimental.GlobalIllumination.RenderSettings.useRadianceAmbientProbe", True)]
        public static bool useRadianceAmbientProbe { get; set; }
    }
}
namespace UnityEngineInternal
{
    public enum GITextureType
    {
        Charting = 0,
        Albedo = 1,
        Emissive = 2,
        Irradiance = 3,
        Directionality = 4,
        Baked = 5,
        BakedDirectional = 6,
        InputWorkspace = 7,
        BakedShadowMask = 8,
        BakedAlbedo = 9,
        BakedEmissive = 10,
        BakedCharting = 11,
        BakedTexelValidity = 12,
        BakedUVOverlap = 13,
        BakedLightmapCulling = 14
    }
}
using UnityEngine.Bindings;

namespace UnityEngineInternal
{
    [NativeHeader("Runtime/Export/GI/GIDebugVisualisation.bindings.h")]
    public static class GIDebugVisualisation
    {
        public static bool cycleMode { get; }
        public static bool pauseCycleMode { get; }
        public static GITextureType texType { get; set; }

        [FreeFunction]
        public static void ResetRuntimeInputTextures();
        [FreeFunction]
        public static void PlayCycleMode();
        [FreeFunction]
        public static void PauseCycleMode();
        [FreeFunction]
        public static void StopCycleMode();
        [FreeFunction]
        public static void CycleSkipSystems(int skip);
        [FreeFunction]
        public static void CycleSkipInstances(int skip);
    }
}
namespace UnityEngineInternal
{
    public enum MemorylessMode
    {
        Unused = 0,
        Forced = 1,
        Automatic = 2
    }
}
using UnityEngine.Bindings;

namespace UnityEngineInternal
{
    [NativeHeader("Runtime/Misc/PlayerSettings.h")]
    public class MemorylessManager
    {
        public MemorylessManager();

        public static MemorylessMode depthMemorylessMode { get; set; }
    }
}
using Unity.IL2CPP.CompilerServices;

namespace UnityEngineInternal
{
    [Il2CppEagerStaticClassConstruction]
    public struct MathfInternal
    {
        public static float FloatMinNormal;
        public static float FloatMinDenormal;
        public static bool IsFlushToZeroEnabled;
    }
}
using System;
using UnityEngine;

namespace UnityEngineInternal
{
    public sealed class APIUpdaterRuntimeServices
    {
        public APIUpdaterRuntimeServices();

        [Obsolete("AddComponent(string) has been deprecated. Use GameObject.AddComponent<T>() / GameObject.AddComponent(Type) instead.\nAPI Updater could not automatically update the original call to AddComponent(string name), because it was unable to resolve the type specified in parameter 'name'.\nInstead, this call has been replaced with a call to APIUpdaterRuntimeServices.AddComponent() so you can try to test your game in the editor.\nIn order to be able to build the game, replace this call (APIUpdaterRuntimeServices.AddComponent()) with a call to GameObject.AddComponent<T>() / GameObject.AddComponent(Type).")]
        public static Component AddComponent(GameObject go, string sourceInfo, string name);
    }
}
namespace UnityEngineInternal
{
    public enum TypeInferenceRules
    {
        TypeReferencedByFirstArgument = 0,
        TypeReferencedBySecondArgument = 1,
        ArrayOfTypeReferencedByFirstArgument = 2,
        TypeOfFirstArgument = 3
    }
}
using System;

namespace UnityEngineInternal
{
    [AttributeUsage(Method)]
    public class TypeInferenceRuleAttribute : Attribute
    {
        public TypeInferenceRuleAttribute(TypeInferenceRules rule);
        public TypeInferenceRuleAttribute(string rule);

        public override string ToString();
    }
}
using System.Collections;

namespace UnityEngineInternal
{
    public class GenericStack : Stack
    {
        public GenericStack();
    }
}
using UnityEngine;
using UnityEngine.Scripting;

namespace Unity.Profiling
{
    [UsedByNativeCode]
    public readonly struct ProfilerCategory
    {
        public ProfilerCategory(string categoryName);

        public string Name { get; }
        public Color32 Color { get; }
        public static ProfilerCategory Render { get; }
        public static ProfilerCategory Scripts { get; }
        public static ProfilerCategory Gui { get; }
        public static ProfilerCategory Physics { get; }
        public static ProfilerCategory Animation { get; }
        public static ProfilerCategory Ai { get; }
        public static ProfilerCategory Audio { get; }
        public static ProfilerCategory Video { get; }
        public static ProfilerCategory Particles { get; }
        public static ProfilerCategory Lighting { get; }
        public static ProfilerCategory Network { get; }
        public static ProfilerCategory Loading { get; }
        public static ProfilerCategory Vr { get; }
        public static ProfilerCategory Input { get; }
        public static ProfilerCategory Memory { get; }
        public static ProfilerCategory VirtualTexturing { get; }
        public static ProfilerCategory Internal { get; }

        public override string ToString();

        public static implicit operator ushort(ProfilerCategory category);
    }
}
using System;

namespace Unity.Profiling
{
    [Flags]
    public enum ProfilerCategoryFlags
    {
        None = 0,
        Builtin = 1
    }
}
using JetBrains.Annotations;
using System;
using System.Diagnostics;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace Unity.Profiling
{
    [UsedByNativeCode]
    [NativeHeader("Runtime/Profiler/ScriptBindings/ProfilerMarker.bindings.h")]
    public struct ProfilerMarker
    {
        public ProfilerMarker(string name);
        public ProfilerMarker(char* name, int nameLen);
        public ProfilerMarker(ProfilerCategory category, string name);
        public ProfilerMarker(ProfilerCategory category, char* name, int nameLen);

        public IntPtr Handle { get; }

        [Pure]
        [Conditional("ENABLE_PROFILER")]
        public void Begin();
        [Conditional("ENABLE_PROFILER")]
        public void Begin(UnityEngine.Object contextUnityObject);
        [Pure]
        [Conditional("ENABLE_PROFILER")]
        public void End();
        [Pure]
        public AutoScope Auto();

        [UsedByNativeCode]
        public struct AutoScope : IDisposable
        {
            public void Dispose();
        }
    }
}
namespace Unity.Profiling
{
    public enum ProfilerFlowEventType
    {
        Begin = 0,
        ParallelNext = 1,
        End = 2,
        Next = 3
    }
}
namespace Unity.Profiling
{
    public enum ProfilerMarkerDataUnit
    {
        Undefined = 0,
        TimeNanoseconds = 1,
        Bytes = 2,
        Count = 3,
        Percent = 4,
        FrequencyHz = 5
    }
}
using System;

namespace Unity.Profiling
{
    [Flags]
    public enum ProfilerCounterOptions
    {
        None = 0,
        FlushOnEndOfFrame = 2,
        ResetToZeroOnFlush = 4
    }
}
using System;

namespace Unity.Profiling
{
    [Flags]
    public enum ProfilerRecorderOptions
    {
        None = 0,
        StartImmediately = 1,
        KeepAliveDuringDomainReload = 2,
        CollectOnlyOnCurrentThread = 4,
        WrapAroundWhenCapacityReached = 8,
        SumAllSamplesInFrame = 16,
        Default = 24
    }
}
using System.Diagnostics;
using UnityEngine.Scripting;

namespace Unity.Profiling
{
    [DebuggerDisplay("Value = {Value}; Count = {Count}")]
    [UsedByNativeCode]
    public struct ProfilerRecorderSample
    {
        public long Value { get; }
        public long Count { get; }
    }
}
using System;
using System.Collections.Generic;
using System.Diagnostics;
using Unity.Profiling.LowLevel;
using Unity.Profiling.LowLevel.Unsafe;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace Unity.Profiling
{
    [NativeHeader("Runtime/Profiler/ScriptBindings/ProfilerRecorder.bindings.h")]
    [UsedByNativeCode]
    [DebuggerDisplay("Count = {Count}")]
    [DebuggerTypeProxy(typeof(ProfilerRecorderDebugView))]
    public struct ProfilerRecorder : IDisposable
    {
        public ProfilerRecorder(string statName, int capacity = 1, ProfilerRecorderOptions options = Default);
        public ProfilerRecorder(string categoryName, string statName, int capacity = 1, ProfilerRecorderOptions options = Default);
        public ProfilerRecorder(ProfilerCategory category, string statName, int capacity = 1, ProfilerRecorderOptions options = Default);
        public ProfilerRecorder(ProfilerCategory category, char* statName, int statNameLen, int capacity = 1, ProfilerRecorderOptions options = Default);
        public ProfilerRecorder(ProfilerMarker marker, int capacity = 1, ProfilerRecorderOptions options = Default);
        public ProfilerRecorder(ProfilerRecorderHandle statHandle, int capacity = 1, ProfilerRecorderOptions options = Default);

        public bool Valid { get; }
        public ProfilerMarkerDataType DataType { get; }
        public ProfilerMarkerDataUnit UnitType { get; }
        public long CurrentValue { get; }
        public double CurrentValueAsDouble { get; }
        public long LastValue { get; }
        public double LastValueAsDouble { get; }
        public int Capacity { get; }
        public int Count { get; }
        public bool IsRunning { get; }
        public bool WrappedAround { get; }

        public static ProfilerRecorder StartNew(ProfilerCategory category, string statName, int capacity = 1, ProfilerRecorderOptions options = Default);
        public static ProfilerRecorder StartNew(ProfilerMarker marker, int capacity = 1, ProfilerRecorderOptions options = Default);
        public void Start();
        public void Stop();
        public void Reset();
        public ProfilerRecorderSample GetSample(int index);
        public void CopyTo(List<ProfilerRecorderSample> outSamples, bool reset = False);
        public int CopyTo(ProfilerRecorderSample* dest, int destSize, bool reset = False);
        public ProfilerRecorderSample[] ToArray();
        public void Dispose();
    }
}
using System;

namespace Unity.Profiling.LowLevel
{
    [Flags]
    public enum MarkerFlags
    {
        Default = 0,
        Script = 2,
        ScriptInvoke = 32,
        ScriptDeepProfiler = 64,
        AvailabilityEditor = 4,
        Warning = 16,
        Counter = 128
    }
}
namespace Unity.Profiling.LowLevel
{
    public enum ProfilerMarkerDataType
    {
        Int32 = 2,
        UInt32 = 3,
        Int64 = 4,
        UInt64 = 5,
        Float = 6,
        Double = 7,
        String16 = 9,
        Blob8 = 11
    }
}
using UnityEngine.Scripting;

namespace Unity.Profiling.LowLevel.Unsafe
{
    [UsedByNativeCode]
    public readonly struct ProfilerRecorderDescription
    {
        public ProfilerCategory Category { get; }
        public MarkerFlags Flags { get; }
        public ProfilerMarkerDataType DataType { get; }
        public ProfilerMarkerDataUnit UnitType { get; }
        public int NameUtf8Len { get; }
        public byte* NameUtf8 { get; }
        public string Name { get; }
    }
}
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace Unity.Profiling.LowLevel.Unsafe
{
    [UsedByNativeCode]
    public readonly struct ProfilerRecorderHandle
    {
        public bool Valid { get; }

        public static ProfilerRecorderDescription GetDescription(ProfilerRecorderHandle handle);
        [NativeMethod(IsThreadSafe = True, ThrowsException = True)]
        public static void GetAvailable(List<ProfilerRecorderHandle> outRecorderHandleList);
    }
}
namespace Unity.Profiling.LowLevel.Unsafe
{
    public struct ProfilerMarkerData
    {
        public byte Type;
        public uint Size;
        public void* Ptr;
    }
}
using UnityEngine;

namespace Unity.Profiling.LowLevel.Unsafe
{
    public readonly struct ProfilerCategoryDescription
    {
        public readonly ushort Id;
        public readonly Color32 Color;
        public readonly int NameUtf8Len;
        public readonly byte* NameUtf8;

        public string Name { get; }
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace Unity.Profiling.LowLevel.Unsafe
{
    [NativeHeader("Runtime/Profiler/ScriptBindings/ProfilerMarker.bindings.h")]
    [UsedByNativeCode]
    public static class ProfilerUnsafeUtility
    {
        public const ushort CategoryRender = 0;
        public const ushort CategoryScripts = 1;
        public const ushort CategoryGUI = 4;
        public const ushort CategoryPhysics = 5;
        public const ushort CategoryAnimation = 6;
        public const ushort CategoryAi = 7;
        public const ushort CategoryAudio = 8;
        public const ushort CategoryVideo = 11;
        public const ushort CategoryParticles = 12;
        public const ushort CategoryLighting = 13;
        [Obsolete("CategoryLightning has been renamed. Use CategoryLighting instead (UnityUpgradable) -> CategoryLighting", False)]
        public const ushort CategoryLightning = 13;
        public const ushort CategoryNetwork = 14;
        public const ushort CategoryLoading = 15;
        public const ushort CategoryOther = 16;
        public const ushort CategoryVr = 22;
        public const ushort CategoryAllocation = 23;
        public const ushort CategoryInternal = 24;
        public const ushort CategoryInput = 30;
        public const ushort CategoryVirtualTexturing = 31;

        public static long Timestamp { get; }
        public static TimestampConversionRatio TimestampToNanosecondsConversionRatio { get; }

        public static ushort GetCategoryByName(char* name, int nameLen);
        [ThreadSafe]
        public static ProfilerCategoryDescription GetCategoryDescription(ushort categoryId);
        [ThreadSafe]
        public static IntPtr CreateMarker(string name, ushort categoryId, MarkerFlags flags, int metadataCount);
        public static IntPtr CreateMarker(char* name, int nameLen, ushort categoryId, MarkerFlags flags, int metadataCount);
        [ThreadSafe]
        public static void SetMarkerMetadata(IntPtr markerPtr, int index, string name, byte type, byte unit);
        public static void SetMarkerMetadata(IntPtr markerPtr, int index, char* name, int nameLen, byte type, byte unit);
        [ThreadSafe]
        public static void BeginSample(IntPtr markerPtr);
        [ThreadSafe]
        public static void BeginSampleWithMetadata(IntPtr markerPtr, int metadataCount, void* metadata);
        [ThreadSafe]
        public static void EndSample(IntPtr markerPtr);
        [ThreadSafe]
        public static void SingleSampleWithMetadata(IntPtr markerPtr, int metadataCount, void* metadata);
        [ThreadSafe]
        public static void* CreateCounterValue(out IntPtr counterPtr, string name, ushort categoryId, MarkerFlags flags, byte dataType, byte dataUnit, int dataSize, ProfilerCounterOptions counterOptions);
        public static void* CreateCounterValue(out IntPtr counterPtr, char* name, int nameLen, ushort categoryId, MarkerFlags flags, byte dataType, byte dataUnit, int dataSize, ProfilerCounterOptions counterOptions);
        [ThreadSafe]
        public static void FlushCounterValue(void* counterValuePtr);
        [ThreadSafe]
        public static uint CreateFlow(ushort categoryId);
        [ThreadSafe]
        public static void FlowEvent(uint flowId, ProfilerFlowEventType flowEventType);

        public struct TimestampConversionRatio
        {
            public long Numerator;
            public long Denominator;
        }
    }
}
using Unity.Jobs.LowLevel.Unsafe;

namespace Unity.Jobs
{
    [JobProducerType(typeof(IJobExtensions.JobStruct<>))]
    public interface IJob
    {
        void Execute();
    }
}
namespace Unity.Jobs
{
    public static class IJobExtensions
    {
        public static JobHandle Schedule<T>(this T jobData, JobHandle dependsOn = null) where T : IJob, struct;
        public static void Run<T>(this T jobData) where T : IJob, struct;
    }
}
using Unity.Jobs.LowLevel.Unsafe;

namespace Unity.Jobs
{
    [JobProducerType(typeof(IJobForExtensions.ForJobStruct<>))]
    public interface IJobFor
    {
        void Execute(int index);
    }
}
namespace Unity.Jobs
{
    public static class IJobForExtensions
    {
        public static JobHandle Schedule<T>(this T jobData, int arrayLength, JobHandle dependency) where T : IJobFor, struct;
        public static JobHandle ScheduleParallel<T>(this T jobData, int arrayLength, int innerloopBatchCount, JobHandle dependency) where T : IJobFor, struct;
        public static void Run<T>(this T jobData, int arrayLength) where T : IJobFor, struct;
    }
}
using Unity.Jobs.LowLevel.Unsafe;

namespace Unity.Jobs
{
    [JobProducerType(typeof(IJobParallelForExtensions.ParallelForJobStruct<>))]
    public interface IJobParallelFor
    {
        void Execute(int index);
    }
}
namespace Unity.Jobs
{
    public static class IJobParallelForExtensions
    {
        public static JobHandle Schedule<T>(this T jobData, int arrayLength, int innerloopBatchCount, JobHandle dependsOn = null) where T : IJobParallelFor, struct;
        public static void Run<T>(this T jobData, int arrayLength) where T : IJobParallelFor, struct;
    }
}
using Unity.Collections;
using UnityEngine.Bindings;

namespace Unity.Jobs
{
    [NativeType(Header = "Runtime/Jobs/ScriptBindings/JobsBindings.h")]
    public struct JobHandle
    {
        public bool IsCompleted { get; }

        public void Complete();
        public static void CompleteAll(ref JobHandle job0, ref JobHandle job1);
        public static void CompleteAll(ref JobHandle job0, ref JobHandle job1, ref JobHandle job2);
        public static void CompleteAll(NativeArray<JobHandle> jobs);
        [NativeMethod(IsFreeFunction = True)]
        public static void ScheduleBatchedJobs();
        public static JobHandle CombineDependencies(JobHandle job0, JobHandle job1);
        public static JobHandle CombineDependencies(JobHandle job0, JobHandle job1, JobHandle job2);
        public static JobHandle CombineDependencies(NativeArray<JobHandle> jobs);
        public static JobHandle CombineDependencies(NativeSlice<JobHandle> jobs);
        [NativeMethod(IsFreeFunction = True)]
        public static bool CheckFenceIsDependencyOrDidSyncFence(JobHandle jobHandle, JobHandle dependsOn);
    }
}
using Unity.Collections;

namespace Unity.Jobs.LowLevel.Unsafe
{
    public struct BatchQueryJob<CommandT, ResultT> where CommandT : struct where ResultT : struct
    {
        public BatchQueryJob(NativeArray<CommandT> commands, NativeArray<ResultT> results);
    }
}
using System;

namespace Unity.Jobs.LowLevel.Unsafe
{
    public struct BatchQueryJobStruct<T> where T : struct
    {
        public static IntPtr Initialize();
    }
}
namespace Unity.Jobs.LowLevel.Unsafe
{
    public static class JobHandleUnsafeUtility
    {
        public static JobHandle CombineDependencies(JobHandle* jobs, int count);
    }
}
using System;

namespace Unity.Jobs.LowLevel.Unsafe
{
    [AttributeUsage(Interface)]
    public sealed class JobProducerTypeAttribute : Attribute
    {
        public JobProducerTypeAttribute(Type producerType);

        public Type ProducerType { get; }
    }
}
namespace Unity.Jobs.LowLevel.Unsafe
{
    public struct JobRanges
    {
        public int TotalIterationCount;
    }
}
using System;

namespace Unity.Jobs.LowLevel.Unsafe
{
    public enum ScheduleMode
    {
        Run = 0,
        [Obsolete("Batched is obsolete, use Parallel or Single depending on job type. (UnityUpgradable) -> Parallel", False)]
        Batched = 1,
        Parallel = 1,
        Single = 2
    }
}
using System;

namespace Unity.Jobs.LowLevel.Unsafe
{
    [Obsolete("Reflection data is now universal between job types. The parameter can be removed.", False)]
    public enum JobType
    {
        Single = 0,
        ParallelFor = 1
    }
}
using System;
using System.Diagnostics;
using UnityEngine.Bindings;

namespace Unity.Jobs.LowLevel.Unsafe
{
    [NativeType(Header = "Runtime/Jobs/ScriptBindings/JobsBindings.h")]
    [NativeHeader("Runtime/Jobs/JobSystem.h")]
    public static class JobsUtility
    {
        public const int MaxJobThreadCount = 128;
        public const int CacheLineSize = 64;

        public static bool IsExecutingJob { get; }
        public static bool JobDebuggerEnabled { get; set; }
        public static bool JobCompilerEnabled { get; set; }
        public static int JobWorkerMaximumCount { get; }
        public static int JobWorkerCount { get; set; }

        public static void GetJobRange(ref JobRanges ranges, int jobIndex, out int beginIndex, out int endIndex);
        [NativeMethod(IsFreeFunction = True, IsThreadSafe = True)]
        public static bool GetWorkStealingRange(ref JobRanges ranges, int jobIndex, out int beginIndex, out int endIndex);
        [FreeFunction("ScheduleManagedJob", ThrowsException = True)]
        public static JobHandle Schedule(ref JobScheduleParameters parameters);
        [FreeFunction("ScheduleManagedJobParallelFor", ThrowsException = True)]
        public static JobHandle ScheduleParallelFor(ref JobScheduleParameters parameters, int arrayLength, int innerloopBatchCount);
        [FreeFunction("ScheduleManagedJobParallelForDeferArraySize", ThrowsException = True)]
        public static JobHandle ScheduleParallelForDeferArraySize(ref JobScheduleParameters parameters, int innerloopBatchCount, void* listData, void* listDataAtomicSafetyHandle);
        [FreeFunction("ScheduleManagedJobParallelForTransform", ThrowsException = True)]
        public static JobHandle ScheduleParallelForTransform(ref JobScheduleParameters parameters, IntPtr transfromAccesssArray);
        [FreeFunction("ScheduleManagedJobParallelForTransformReadOnly", ThrowsException = True)]
        public static JobHandle ScheduleParallelForTransformReadOnly(ref JobScheduleParameters parameters, IntPtr transfromAccesssArray, int innerloopBatchCount);
        [NativeMethod(IsThreadSafe = True, IsFreeFunction = True)]
        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        public static void PatchBufferMinMaxRanges(IntPtr bufferRangePatchData, void* jobdata, int startIndex, int rangeSize);
        [Obsolete("JobType is obsolete. The parameter should be removed. (UnityUpgradable) -> !1")]
        public static IntPtr CreateJobReflectionData(Type type, JobType jobType, object managedJobFunction0, object managedJobFunction1 = null, object managedJobFunction2 = null);
        public static IntPtr CreateJobReflectionData(Type type, object managedJobFunction0, object managedJobFunction1 = null, object managedJobFunction2 = null);
        [Obsolete("JobType is obsolete. The parameter should be removed. (UnityUpgradable) -> !2")]
        public static IntPtr CreateJobReflectionData(Type wrapperJobType, Type userJobType, JobType jobType, object managedJobFunction0);
        public static IntPtr CreateJobReflectionData(Type wrapperJobType, Type userJobType, object managedJobFunction0);
        [FreeFunction("JobSystem::ResetJobQueueWorkerThreadCount")]
        public static void ResetJobWorkerCount();

        public struct JobScheduleParameters
        {
            public JobHandle Dependency;
            public int ScheduleMode;
            public IntPtr ReflectionData;
            public IntPtr JobDataPtr;

            public JobScheduleParameters(void* i_jobData, IntPtr i_reflectionData, JobHandle i_dependency, ScheduleMode i_scheduleMode);
        }
    }
}
namespace Unity.Rendering.HybridV2
{
    public struct DOTSInstancingCbuffer
    {
        public int NameID;
        public int CbufferIndex;
        public int SizeBytes;
    }
}
namespace Unity.Rendering.HybridV2
{
    public enum DOTSInstancingPropertyType
    {
        Unknown = 0,
        Float = 1,
        Half = 2,
        Int = 3,
        Short = 4,
        Uint = 5,
        Bool = 6,
        Struct = 7
    }
}
namespace Unity.Rendering.HybridV2
{
    public struct DOTSInstancingProperty
    {
        public int MetadataNameID;
        public int ConstantNameID;
        public int CbufferIndex;
        public int MetadataOffset;
        public int SizeBytes;
        public DOTSInstancingPropertyType ConstantType;
        public int Cols;
        public int Rows;
    }
}
using Unity.Collections;
using UnityEngine;
using UnityEngine.Bindings;

namespace Unity.Rendering.HybridV2
{
    public class HybridV2ShaderReflection
    {
        public HybridV2ShaderReflection();

        [FreeFunction("Shader::GetDOTSReflectionVersionNumber")]
        public static uint GetDOTSReflectionVersionNumber();
        public static NativeArray<DOTSInstancingCbuffer> GetDOTSInstancingCbuffers(Shader shader);
        public static NativeArray<DOTSInstancingProperty> GetDOTSInstancingProperties(Shader shader);
    }
}
namespace Unity.IO.LowLevel.Unsafe
{
    public struct ReadCommand
    {
        public void* Buffer;
        public long Offset;
        public long Size;
    }
}
using UnityEngine.Scripting;

namespace Unity.IO.LowLevel.Unsafe
{
    [RequiredByNativeCode]
    public enum FileState
    {
        Absent = 0,
        Exists = 1
    }
}
namespace Unity.IO.LowLevel.Unsafe
{
    public struct FileInfoResult
    {
        public long FileSize;
        public FileState FileState;
    }
}
namespace Unity.IO.LowLevel.Unsafe
{
    public enum AssetLoadingSubsystem
    {
        Other = 0,
        Texture = 1,
        VirtualTexture = 2,
        Mesh = 3,
        Audio = 4,
        Scripts = 5,
        EntitiesScene = 6,
        EntitiesStreamBinaryReader = 7,
        FileInfo = 8
    }
}
namespace Unity.IO.LowLevel.Unsafe
{
    public enum ReadStatus
    {
        Complete = 0,
        InProgress = 1,
        Failed = 2,
        Truncated = 4
    }
}
using UnityEngine.Scripting;

namespace Unity.IO.LowLevel.Unsafe
{
    [RequiredByNativeCode]
    public enum Priority
    {
        PriorityLow = 0,
        PriorityHigh = 1
    }
}
using System;
using Unity.Jobs;

namespace Unity.IO.LowLevel.Unsafe
{
    public struct ReadHandle : IDisposable
    {
        public JobHandle JobHandle { get; }
        public ReadStatus Status { get; }

        public bool IsValid();
        public void Dispose();
        public long GetBytesRead();
    }
}
using UnityEngine.Bindings;

namespace Unity.IO.LowLevel.Unsafe
{
    [NativeHeader("Runtime/File/AsyncReadManagerManagedApi.h")]
    public static class AsyncReadManager
    {
        public static ReadHandle Read(string filename, ReadCommand* readCmds, uint readCmdCount, string assetName = "", ulong typeID = 0, AssetLoadingSubsystem subsystem = Scripts);
        public static ReadHandle GetFileInfo(string filename, FileInfoResult* result);
    }
}
using UnityEngine.Bindings;

namespace Unity.IO.LowLevel.Unsafe
{
    [NativeHeader("Runtime/File/AsyncReadManagerMetrics.h")]
    public enum ProcessingState
    {
        Unknown = 0,
        InQueue = 1,
        Reading = 2,
        Completed = 3,
        Failed = 4,
        Canceled = 5
    }
}
namespace Unity.IO.LowLevel.Unsafe
{
    public enum FileReadType
    {
        Sync = 0,
        Async = 1
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace Unity.IO.LowLevel.Unsafe
{
    [NativeConditional("ENABLE_PROFILER")]
    [RequiredByNativeCode]
    public struct AsyncReadManagerRequestMetric
    {
        [NativeName("assetName")]
        public string AssetName { get; }
        [NativeName("fileName")]
        public string FileName { get; }
        [NativeName("offsetBytes")]
        public ulong OffsetBytes { get; }
        [NativeName("sizeBytes")]
        public ulong SizeBytes { get; }
        [NativeName("assetTypeId")]
        public ulong AssetTypeId { get; }
        [NativeName("currentBytesRead")]
        public ulong CurrentBytesRead { get; }
        [NativeName("batchReadCount")]
        public uint BatchReadCount { get; }
        [NativeName("isBatchRead")]
        public bool IsBatchRead { get; }
        [NativeName("state")]
        public ProcessingState State { get; }
        [NativeName("readType")]
        public FileReadType ReadType { get; }
        [NativeName("priorityLevel")]
        public Priority PriorityLevel { get; }
        [NativeName("subsystem")]
        public AssetLoadingSubsystem Subsystem { get; }
        [NativeName("requestTimeMicroseconds")]
        public double RequestTimeMicroseconds { get; }
        [NativeName("timeInQueueMicroseconds")]
        public double TimeInQueueMicroseconds { get; }
        [NativeName("totalTimeMicroseconds")]
        public double TotalTimeMicroseconds { get; }
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.Bindings;

namespace Unity.IO.LowLevel.Unsafe
{
    [NativeConditional("ENABLE_PROFILER")]
    public static class AsyncReadManagerMetrics
    {
        [FreeFunction("AreMetricsEnabled_Internal")]
        public static bool IsEnabled();
        public static void ClearCompletedMetrics();
        public static AsyncReadManagerRequestMetric[] GetMetrics(AsyncReadManagerMetricsFilters filters, Flags flags);
        public static void GetMetrics(List<AsyncReadManagerRequestMetric> outMetrics, AsyncReadManagerMetricsFilters filters, Flags flags);
        public static AsyncReadManagerRequestMetric[] GetMetrics(Flags flags);
        public static void GetMetrics(List<AsyncReadManagerRequestMetric> outMetrics, Flags flags);
        [FreeFunction("GetAsyncReadManagerMetrics()->StartCollecting")]
        public static void StartCollectingMetrics();
        [FreeFunction("GetAsyncReadManagerMetrics()->StopCollecting")]
        public static void StopCollectingMetrics();
        public static AsyncReadManagerSummaryMetrics GetCurrentSummaryMetrics(Flags flags);
        public static AsyncReadManagerSummaryMetrics GetCurrentSummaryMetrics(AsyncReadManagerMetricsFilters metricsFilters, Flags flags);
        public static AsyncReadManagerSummaryMetrics GetSummaryOfMetrics(AsyncReadManagerRequestMetric[] metrics);
        public static AsyncReadManagerSummaryMetrics GetSummaryOfMetrics(List<AsyncReadManagerRequestMetric> metrics);
        public static AsyncReadManagerSummaryMetrics GetSummaryOfMetrics(AsyncReadManagerRequestMetric[] metrics, AsyncReadManagerMetricsFilters metricsFilters);
        public static AsyncReadManagerSummaryMetrics GetSummaryOfMetrics(List<AsyncReadManagerRequestMetric> metrics, AsyncReadManagerMetricsFilters metricsFilters);
        [FreeFunction("GetAsyncReadManagerMetrics()->GetTotalSizeNonASRMReadsBytes")]
        [ThreadSafe]
        public static ulong GetTotalSizeOfNonASRMReadsBytes(bool emptyAfterRead);

        [Flags]
        public enum Flags
        {
            None = 0,
            ClearOnRead = 1
        }
    }
}
using UnityEngine.Bindings;

namespace Unity.IO.LowLevel.Unsafe
{
    [NativeAsStruct]
    [NativeConditional("ENABLE_PROFILER")]
    public class AsyncReadManagerSummaryMetrics
    {
        public AsyncReadManagerSummaryMetrics();

        [NativeName("totalBytesRead")]
        public ulong TotalBytesRead { get; }
        [NativeName("averageBandwidthMBPerSecond")]
        public float AverageBandwidthMBPerSecond { get; }
        [NativeName("averageReadSizeInBytes")]
        public float AverageReadSizeInBytes { get; }
        [NativeName("averageWaitTimeMicroseconds")]
        public float AverageWaitTimeMicroseconds { get; }
        [NativeName("averageReadTimeMicroseconds")]
        public float AverageReadTimeMicroseconds { get; }
        [NativeName("averageTotalRequestTimeMicroseconds")]
        public float AverageTotalRequestTimeMicroseconds { get; }
        [NativeName("averageThroughputMBPerSecond")]
        public float AverageThroughputMBPerSecond { get; }
        [NativeName("longestWaitTimeMicroseconds")]
        public float LongestWaitTimeMicroseconds { get; }
        [NativeName("longestReadTimeMicroseconds")]
        public float LongestReadTimeMicroseconds { get; }
        [NativeName("longestReadAssetType")]
        public ulong LongestReadAssetType { get; }
        [NativeName("longestWaitAssetType")]
        public ulong LongestWaitAssetType { get; }
        [NativeName("longestReadSubsystem")]
        public AssetLoadingSubsystem LongestReadSubsystem { get; }
        [NativeName("longestWaitSubsystem")]
        public AssetLoadingSubsystem LongestWaitSubsystem { get; }
        [NativeName("numberOfInProgressRequests")]
        public int NumberOfInProgressRequests { get; }
        [NativeName("numberOfCompletedRequests")]
        public int NumberOfCompletedRequests { get; }
        [NativeName("numberOfFailedRequests")]
        public int NumberOfFailedRequests { get; }
        [NativeName("numberOfWaitingRequests")]
        public int NumberOfWaitingRequests { get; }
        [NativeName("numberOfCanceledRequests")]
        public int NumberOfCanceledRequests { get; }
        [NativeName("totalNumberOfRequests")]
        public int TotalNumberOfRequests { get; }
        [NativeName("numberOfCachedReads")]
        public int NumberOfCachedReads { get; }
        [NativeName("numberOfAsyncReads")]
        public int NumberOfAsyncReads { get; }
        [NativeName("numberOfSyncReads")]
        public int NumberOfSyncReads { get; }
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace Unity.IO.LowLevel.Unsafe
{
    [NativeConditional("ENABLE_PROFILER")]
    [NativeAsStruct]
    [RequiredByNativeCode]
    public class AsyncReadManagerMetricsFilters
    {
        public AsyncReadManagerMetricsFilters();
        public AsyncReadManagerMetricsFilters(ulong typeID);
        public AsyncReadManagerMetricsFilters(ProcessingState state);
        public AsyncReadManagerMetricsFilters(FileReadType readType);
        public AsyncReadManagerMetricsFilters(Priority priorityLevel);
        public AsyncReadManagerMetricsFilters(AssetLoadingSubsystem subsystem);
        public AsyncReadManagerMetricsFilters(ulong[] typeIDs);
        public AsyncReadManagerMetricsFilters(ProcessingState[] states);
        public AsyncReadManagerMetricsFilters(FileReadType[] readTypes);
        public AsyncReadManagerMetricsFilters(Priority[] priorityLevels);
        public AsyncReadManagerMetricsFilters(AssetLoadingSubsystem[] subsystems);
        public AsyncReadManagerMetricsFilters(ulong[] typeIDs, ProcessingState[] states, FileReadType[] readTypes, Priority[] priorityLevels, AssetLoadingSubsystem[] subsystems);

        public void SetTypeIDFilter(ulong[] _typeIDs);
        public void SetStateFilter(ProcessingState[] _states);
        public void SetReadTypeFilter(FileReadType[] _readTypes);
        public void SetPriorityFilter(Priority[] _priorityLevels);
        public void SetSubsystemFilter(AssetLoadingSubsystem[] _subsystems);
        public void SetTypeIDFilter(ulong _typeID);
        public void SetStateFilter(ProcessingState _state);
        public void SetReadTypeFilter(FileReadType _readType);
        public void SetPriorityFilter(Priority _priorityLevel);
        public void SetSubsystemFilter(AssetLoadingSubsystem _subsystem);
        public void RemoveTypeIDFilter();
        public void RemoveStateFilter();
        public void RemoveReadTypeFilter();
        public void RemovePriorityFilter();
        public void RemoveSubsystemFilter();
        public void ClearFilters();
    }
}
using UnityEngine.Bindings;

namespace Unity.IO.LowLevel.Unsafe
{
    [NativeHeader("Runtime/VirtualFileSystem/VirtualFileSystem.h")]
    public static class VirtualFileSystem
    {
        [FreeFunction(IsThreadSafe = True)]
        public static bool GetLocalFileSystemName(string vfsFileName, out string localFileName, out ulong localFileOffset, out ulong localFileSize);
    }
}
using System;
using UnityEngine.Scripting;

namespace Unity.Collections
{
    [RequiredByNativeCode]
    [AttributeUsage(Field, Parameter, ReturnValue)]
    public sealed class ReadOnlyAttribute : Attribute
    {
        public ReadOnlyAttribute();
    }
}
using System;
using UnityEngine.Scripting;

namespace Unity.Collections
{
    [AttributeUsage(Field, Parameter, ReturnValue)]
    [RequiredByNativeCode]
    public sealed class WriteOnlyAttribute : Attribute
    {
        public WriteOnlyAttribute();
    }
}
using System;
using UnityEngine.Scripting;

namespace Unity.Collections
{
    [AttributeUsage(Field)]
    [RequiredByNativeCode]
    public sealed class DeallocateOnJobCompletionAttribute : Attribute
    {
        public DeallocateOnJobCompletionAttribute();
    }
}
using System;
using UnityEngine.Scripting;

namespace Unity.Collections
{
    [AttributeUsage(Field)]
    [RequiredByNativeCode]
    public sealed class NativeFixedLengthAttribute : Attribute
    {
        public int FixedLength;

        public NativeFixedLengthAttribute(int fixedLength);
    }
}
using System;
using UnityEngine.Scripting;

namespace Unity.Collections
{
    [RequiredByNativeCode]
    [AttributeUsage(Field)]
    public sealed class NativeMatchesParallelForLengthAttribute : Attribute
    {
        public NativeMatchesParallelForLengthAttribute();
    }
}
using System;
using UnityEngine.Scripting;

namespace Unity.Collections
{
    [AttributeUsage(Field)]
    [RequiredByNativeCode]
    public sealed class NativeDisableParallelForRestrictionAttribute : Attribute
    {
        public NativeDisableParallelForRestrictionAttribute();
    }
}
using UnityEngine.Scripting;

namespace Unity.Collections
{
    [UsedByNativeCode]
    public enum Allocator
    {
        Invalid = 0,
        None = 1,
        Temp = 2,
        TempJob = 3,
        Persistent = 4,
        AudioKernel = 5
    }
}
namespace Unity.Collections
{
    public enum NativeLeakDetectionMode
    {
        EnabledWithStackTrace = 3,
        Enabled = 2,
        Disabled = 1
    }
}
namespace Unity.Collections
{
    public static class NativeLeakDetection
    {
        public static NativeLeakDetectionMode Mode { get; set; }
    }
}
namespace Unity.Collections
{
    public enum NativeArrayOptions
    {
        UninitializedMemory = 0,
        ClearMemory = 1
    }
}
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using UnityEngine.Internal;

namespace Unity.Collections
{
    [NativeContainerSupportsMinMaxWriteRestriction]
    [NativeContainerSupportsDeferredConvertListToArray]
    [DebuggerTypeProxy(typeof(NativeArrayDebugView<>))]
    [NativeContainerSupportsDeallocateOnJobCompletion]
    [DefaultMember("Item")]
    [NativeContainer]
    [DebuggerDisplay("Length = {Length}")]
    public struct NativeArray<T> : IEnumerable, IDisposable, IEquatable<NativeArray<T>>, IEnumerable<T> where T : struct
    {
        public NativeArray(int length, Allocator allocator, NativeArrayOptions options = ClearMemory);
        public NativeArray(T[] array, Allocator allocator);
        public NativeArray(NativeArray<T> array, Allocator allocator);

        public T this[int index] { get; set; }
        public int Length { get; }
        public bool IsCreated { get; }

        [WriteAccessRequired]
        public void Dispose();
        public JobHandle Dispose(JobHandle inputDeps);
        [WriteAccessRequired]
        public void CopyFrom(T[] array);
        [WriteAccessRequired]
        public void CopyFrom(NativeArray<T> array);
        public void CopyTo(T[] array);
        public void CopyTo(NativeArray<T> array);
        public T[] ToArray();
        public Enumerator GetEnumerator();
        public bool Equals(NativeArray<T> other);
        public override bool Equals(object obj);
        public override int GetHashCode();
        public static void Copy(NativeArray<T> src, NativeArray<T> dst);
        public static void Copy(ReadOnly src, NativeArray<T> dst);
        public static void Copy(T[] src, NativeArray<T> dst);
        public static void Copy(NativeArray<T> src, T[] dst);
        public static void Copy(ReadOnly src, T[] dst);
        public static void Copy(NativeArray<T> src, NativeArray<T> dst, int length);
        public static void Copy(ReadOnly src, NativeArray<T> dst, int length);
        public static void Copy(T[] src, NativeArray<T> dst, int length);
        public static void Copy(NativeArray<T> src, T[] dst, int length);
        public static void Copy(ReadOnly src, T[] dst, int length);
        public static void Copy(NativeArray<T> src, int srcIndex, NativeArray<T> dst, int dstIndex, int length);
        public static void Copy(ReadOnly src, int srcIndex, NativeArray<T> dst, int dstIndex, int length);
        public static void Copy(T[] src, int srcIndex, NativeArray<T> dst, int dstIndex, int length);
        public static void Copy(NativeArray<T> src, int srcIndex, T[] dst, int dstIndex, int length);
        public static void Copy(ReadOnly src, int srcIndex, T[] dst, int dstIndex, int length);
        public U ReinterpretLoad<U>(int sourceIndex) where U : struct;
        public void ReinterpretStore<U>(int destIndex, U data) where U : struct;
        public NativeArray<U> Reinterpret<U>() where U : struct;
        public NativeArray<U> Reinterpret<U>(int expectedTypeSize) where U : struct;
        public NativeArray<T> GetSubArray(int start, int length);
        public ReadOnly AsReadOnly();

        public static bool operator ==(NativeArray<T> left, NativeArray<T> right);
        public static bool operator !=(NativeArray<T> left, NativeArray<T> right);

        [ExcludeFromDocs]
        public struct Enumerator : IEnumerator<T>, IEnumerator, IDisposable
        {
            public Enumerator(ref NativeArray<T> array);

            public T Current { get; }

            public void Dispose();
            public bool MoveNext();
            public void Reset();
        }
        [NativeContainerIsReadOnly]
        [DebuggerTypeProxy(typeof(NativeArrayReadOnlyDebugView<>))]
        [DebuggerDisplay("Length = {Length}")]
        [NativeContainer]
        [DefaultMember("Item")]
        public struct ReadOnly
        {
            public T this[int index] { get; }
            public int Length { get; }
            public bool IsCreated { get; }

            public void CopyTo(T[] array);
            public void CopyTo(NativeArray<T> array);
            public T[] ToArray();
            public NativeArray<U>.ReadOnly Reinterpret<U>() where U : struct;
        }
    }
}
namespace Unity.Collections
{
    public static class NativeSliceExtensions
    {
        public static NativeSlice<T> Slice<T>(this NativeArray<T> thisArray) where T : struct;
        public static NativeSlice<T> Slice<T>(this NativeArray<T> thisArray, int start) where T : struct;
        public static NativeSlice<T> Slice<T>(this NativeArray<T> thisArray, int start, int length) where T : struct;
        public static NativeSlice<T> Slice<T>(this NativeSlice<T> thisSlice) where T : struct;
        public static NativeSlice<T> Slice<T>(this NativeSlice<T> thisSlice, int start) where T : struct;
        public static NativeSlice<T> Slice<T>(this NativeSlice<T> thisSlice, int start, int length) where T : struct;
    }
}
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine.Internal;

namespace Unity.Collections
{
    [DefaultMember("Item")]
    [NativeContainerSupportsMinMaxWriteRestriction]
    [NativeContainer]
    [DebuggerTypeProxy(typeof(NativeSliceDebugView<>))]
    [DebuggerDisplay("Length = {Length}")]
    public struct NativeSlice<T> : IEnumerable, IEquatable<NativeSlice<T>>, IEnumerable<T> where T : struct
    {
        public NativeSlice(NativeSlice<T> slice, int start);
        public NativeSlice(NativeSlice<T> slice, int start, int length);
        public NativeSlice(NativeArray<T> array);
        public NativeSlice(NativeArray<T> array, int start);
        public NativeSlice(NativeArray<T> array, int start, int length);

        public T this[int index] { get; set; }
        public int Stride { get; }
        public int Length { get; }

        public NativeSlice<U> SliceConvert<U>() where U : struct;
        public NativeSlice<U> SliceWithStride<U>(int offset) where U : struct;
        public NativeSlice<U> SliceWithStride<U>() where U : struct;
        [WriteAccessRequired]
        public void CopyFrom(NativeSlice<T> slice);
        [WriteAccessRequired]
        public void CopyFrom(T[] array);
        public void CopyTo(NativeArray<T> array);
        public void CopyTo(T[] array);
        public T[] ToArray();
        public Enumerator GetEnumerator();
        public bool Equals(NativeSlice<T> other);
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static bool operator ==(NativeSlice<T> left, NativeSlice<T> right);
        public static bool operator !=(NativeSlice<T> left, NativeSlice<T> right);

        public static implicit operator NativeSlice<T>(NativeArray<T> array);

        [ExcludeFromDocs]
        public struct Enumerator : IEnumerator<T>, IEnumerator, IDisposable
        {
            public Enumerator(ref NativeSlice<T> array);

            public T Current { get; }

            public void Dispose();
            public bool MoveNext();
            public void Reset();
        }
    }
}
using System;
using UnityEngine.Scripting;

namespace Unity.Collections.LowLevel.Unsafe
{
    [RequiredByNativeCode]
    [AttributeUsage(Struct)]
    public sealed class NativeContainerAttribute : Attribute
    {
        public NativeContainerAttribute();
    }
}
using System;
using UnityEngine.Scripting;

namespace Unity.Collections.LowLevel.Unsafe
{
    [RequiredByNativeCode]
    [AttributeUsage(Struct)]
    public sealed class NativeContainerIsReadOnlyAttribute : Attribute
    {
        public NativeContainerIsReadOnlyAttribute();
    }
}
using System;
using UnityEngine.Scripting;

namespace Unity.Collections.LowLevel.Unsafe
{
    [AttributeUsage(Struct)]
    [RequiredByNativeCode]
    public sealed class NativeContainerIsAtomicWriteOnlyAttribute : Attribute
    {
        public NativeContainerIsAtomicWriteOnlyAttribute();
    }
}
using System;
using UnityEngine.Scripting;

namespace Unity.Collections.LowLevel.Unsafe
{
    [AttributeUsage(Struct)]
    [RequiredByNativeCode]
    public sealed class NativeContainerSupportsMinMaxWriteRestrictionAttribute : Attribute
    {
        public NativeContainerSupportsMinMaxWriteRestrictionAttribute();
    }
}
using System;
using UnityEngine.Scripting;

namespace Unity.Collections.LowLevel.Unsafe
{
    [RequiredByNativeCode]
    [AttributeUsage(Struct)]
    public sealed class NativeContainerSupportsDeallocateOnJobCompletionAttribute : Attribute
    {
        public NativeContainerSupportsDeallocateOnJobCompletionAttribute();
    }
}
using System;
using UnityEngine.Scripting;

namespace Unity.Collections.LowLevel.Unsafe
{
    [RequiredByNativeCode]
    [AttributeUsage(Struct)]
    public sealed class NativeContainerSupportsDeferredConvertListToArray : Attribute
    {
        public NativeContainerSupportsDeferredConvertListToArray();
    }
}
using System;
using UnityEngine.Scripting;

namespace Unity.Collections.LowLevel.Unsafe
{
    [RequiredByNativeCode]
    [AttributeUsage(Field)]
    public sealed class NativeSetThreadIndexAttribute : Attribute
    {
        public NativeSetThreadIndexAttribute();
    }
}
using System;
using UnityEngine.Scripting;

namespace Unity.Collections.LowLevel.Unsafe
{
    [RequiredByNativeCode]
    [AttributeUsage(Struct)]
    [Obsolete("Use NativeSetThreadIndexAttribute instead")]
    public sealed class NativeContainerNeedsThreadIndexAttribute : Attribute
    {
        public NativeContainerNeedsThreadIndexAttribute();
    }
}
using System;

namespace Unity.Collections.LowLevel.Unsafe
{
    [AttributeUsage(Method, Property)]
    public class WriteAccessRequiredAttribute : Attribute
    {
        public WriteAccessRequiredAttribute();
    }
}
using System;
using UnityEngine.Scripting;

namespace Unity.Collections.LowLevel.Unsafe
{
    [AttributeUsage(Field)]
    [RequiredByNativeCode]
    public sealed class NativeDisableUnsafePtrRestrictionAttribute : Attribute
    {
        public NativeDisableUnsafePtrRestrictionAttribute();
    }
}
using System;
using UnityEngine.Scripting;

namespace Unity.Collections.LowLevel.Unsafe
{
    [AttributeUsage(Field)]
    [RequiredByNativeCode]
    public sealed class NativeDisableContainerSafetyRestrictionAttribute : Attribute
    {
        public NativeDisableContainerSafetyRestrictionAttribute();
    }
}
using System;
using UnityEngine.Scripting;

namespace Unity.Collections.LowLevel.Unsafe
{
    [RequiredByNativeCode]
    [AttributeUsage(Field)]
    public sealed class NativeSetClassTypeToNullOnScheduleAttribute : Attribute
    {
        public NativeSetClassTypeToNullOnScheduleAttribute();
    }
}
namespace Unity.Collections.LowLevel.Unsafe
{
    public enum EnforceJobResult
    {
        AllJobsAlreadySynced = 0,
        DidSyncRunningJobs = 1,
        HandleWasAlreadyDeallocated = 2
    }
}
namespace Unity.Collections.LowLevel.Unsafe
{
    public enum AtomicSafetyErrorType
    {
        Deallocated = 0,
        DeallocatedFromJob = 1,
        NotAllocatedFromJob = 2
    }
}
using System;
using System.Diagnostics;
using Unity.Jobs;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace Unity.Collections.LowLevel.Unsafe
{
    [NativeHeader("Runtime/Jobs/JobsDebugger.h")]
    [UsedByNativeCode]
    [NativeHeader("Runtime/Jobs/AtomicSafetyHandle.h")]
    public struct AtomicSafetyHandle
    {
        [ThreadSafe]
        public static AtomicSafetyHandle Create();
        [ThreadSafe]
        public static AtomicSafetyHandle GetTempUnsafePtrSliceHandle();
        [ThreadSafe]
        public static AtomicSafetyHandle GetTempMemoryHandle();
        [ThreadSafe]
        public static bool IsTempMemoryHandle(AtomicSafetyHandle handle);
        [ThreadSafe]
        public static void Release(AtomicSafetyHandle handle);
        [ThreadSafe]
        public static bool IsDefaultValue(in AtomicSafetyHandle handle);
        [ThreadSafe]
        public static void PrepareUndisposable(ref AtomicSafetyHandle handle);
        [ThreadSafe]
        public static void UseSecondaryVersion(ref AtomicSafetyHandle handle);
        [ThreadSafe]
        public static void SetAllowSecondaryVersionWriting(AtomicSafetyHandle handle, bool allowWriting);
        [ThreadSafe]
        public static void SetBumpSecondaryVersionOnScheduleWrite(AtomicSafetyHandle handle, bool value);
        [NativeMethod(IsThreadSafe = True, IsFreeFunction = True)]
        public static void SetAllowReadOrWriteAccess(AtomicSafetyHandle handle, bool allowReadWriteAccess);
        [NativeMethod(IsThreadSafe = True, IsFreeFunction = True)]
        public static bool GetAllowReadOrWriteAccess(AtomicSafetyHandle handle);
        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        [ThreadSafe(ThrowsException = True)]
        public static void CheckWriteAndBumpSecondaryVersion(AtomicSafetyHandle handle);
        [ThreadSafe]
        public static EnforceJobResult EnforceAllBufferJobsHaveCompleted(AtomicSafetyHandle handle);
        [ThreadSafe]
        public static EnforceJobResult EnforceAllBufferJobsHaveCompletedAndRelease(AtomicSafetyHandle handle);
        [ThreadSafe]
        public static EnforceJobResult EnforceAllBufferJobsHaveCompletedAndDisableReadWrite(AtomicSafetyHandle handle);
        [ThreadSafe(ThrowsException = True)]
        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        public static void CheckDeallocateAndThrow(AtomicSafetyHandle handle);
        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        [ThreadSafe(ThrowsException = True)]
        public static void CheckGetSecondaryDataPointerAndThrow(AtomicSafetyHandle handle);
        [ThreadSafe]
        public static int GetReaderArray(AtomicSafetyHandle handle, int maxCount, IntPtr output);
        [ThreadSafe]
        public static JobHandle GetWriter(AtomicSafetyHandle handle);
        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        public static void CheckReadAndThrow(AtomicSafetyHandle handle);
        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        public static void CheckWriteAndThrow(AtomicSafetyHandle handle);
        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        public static void ValidateNonDefaultHandle(in AtomicSafetyHandle handle);
        public static bool IsValidNonDefaultHandle(in AtomicSafetyHandle handle);
        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        public static void CheckExistsAndThrow(in AtomicSafetyHandle handle);
        public static bool IsHandleValid(in AtomicSafetyHandle handle);
        [ThreadSafe]
        public static string GetReaderName(AtomicSafetyHandle handle, int readerIndex);
        [ThreadSafe]
        public static string GetWriterName(AtomicSafetyHandle handle);
        [ThreadSafe]
        public static int NewStaticSafetyId(byte* ownerTypeNameBytes, int byteCount);
        public static int NewStaticSafetyId<T>();
        [ThreadSafe]
        [NativeThrows]
        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        public static void SetCustomErrorMessage(int staticSafetyId, AtomicSafetyErrorType errorType, byte* messageBytes, int byteCount);
        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        public static void SetStaticSafetyId(ref AtomicSafetyHandle handle, int staticSafetyId);
    }
}
using Unity.Burst;

namespace Unity.Collections.LowLevel.Unsafe
{
    public sealed class DisposeSentinel
    {
        ~DisposeSentinel();

        public static void Dispose(ref AtomicSafetyHandle safety, ref DisposeSentinel sentinel);
        public static void Create(out AtomicSafetyHandle safety, out DisposeSentinel sentinel, int callSiteStackDepth, Allocator allocator);
        [BurstDiscard]
        public static void Clear(ref DisposeSentinel sentinel);
    }
}
namespace Unity.Collections.LowLevel.Unsafe
{
    public static class NativeArrayUnsafeUtility
    {
        public static AtomicSafetyHandle GetAtomicSafetyHandle<T>(NativeArray<T> array) where T : struct;
        public static void SetAtomicSafetyHandle<T>(ref NativeArray<T> array, AtomicSafetyHandle safety) where T : struct;
        public static NativeArray<T> ConvertExistingDataToNativeArray<T>(void* dataPointer, int length, Allocator allocator) where T : struct;
        public static void* GetUnsafePtr<T>(this NativeArray<T> nativeArray) where T : struct;
        public static void* GetUnsafeReadOnlyPtr<T>(this NativeArray<T> nativeArray) where T : struct;
        public static void* GetUnsafeReadOnlyPtr<T>(this NativeArray<T>.ReadOnly nativeArray) where T : struct;
        public static void* GetUnsafeBufferPointerWithoutChecks<T>(NativeArray<T> nativeArray) where T : struct;
    }
}
namespace Unity.Collections.LowLevel.Unsafe
{
    public static class NativeSliceUnsafeUtility
    {
        public static AtomicSafetyHandle GetAtomicSafetyHandle<T>(NativeSlice<T> slice) where T : struct;
        public static void SetAtomicSafetyHandle<T>(ref NativeSlice<T> slice, AtomicSafetyHandle safety) where T : struct;
        public static NativeSlice<T> ConvertExistingDataToNativeSlice<T>(void* dataPointer, int stride, int length) where T : struct;
        public static void* GetUnsafePtr<T>(this NativeSlice<T> nativeSlice) where T : struct;
        public static void* GetUnsafeReadOnlyPtr<T>(this NativeSlice<T> nativeSlice) where T : struct;
    }
}
using System;
using System.Reflection;
using UnityEngine.Bindings;

namespace Unity.Collections.LowLevel.Unsafe
{
    [NativeHeader("Runtime/Export/Unsafe/UnsafeUtility.bindings.h")]
    [StaticAccessor("UnsafeUtility", DoubleColon)]
    public static class UnsafeUtility
    {
        public static int GetFieldOffset(FieldInfo field);
        public static void* PinGCObjectAndGetAddress(object target, out ulong gcHandle);
        public static void* PinGCArrayAndGetDataAddress(Array target, out ulong gcHandle);
        [ThreadSafe]
        public static void ReleaseGCObject(ulong gcHandle);
        [ThreadSafe(ThrowsException = True)]
        public static void CopyObjectAddressToPtr(object target, void* dstPtr);
        public static bool IsBlittable<T>() where T : struct;
        [ThreadSafe(ThrowsException = True)]
        public static void* Malloc(long size, int alignment, Allocator allocator);
        [ThreadSafe(ThrowsException = True)]
        public static void Free(void* memory, Allocator allocator);
        public static bool IsValidAllocator(Allocator allocator);
        [ThreadSafe(ThrowsException = True)]
        public static void MemCpy(void* destination, void* source, long size);
        [ThreadSafe(ThrowsException = True)]
        public static void MemCpyReplicate(void* destination, void* source, int size, int count);
        [ThreadSafe(ThrowsException = True)]
        public static void MemCpyStride(void* destination, int destinationStride, void* source, int sourceStride, int elementSize, int count);
        [ThreadSafe(ThrowsException = True)]
        public static void MemMove(void* destination, void* source, long size);
        [ThreadSafe(ThrowsException = True)]
        public static void MemSet(void* destination, byte value, long size);
        public static void MemClear(void* destination, long size);
        [ThreadSafe(ThrowsException = True)]
        public static int MemCmp(void* ptr1, void* ptr2, long size);
        [ThreadSafe]
        public static int SizeOf(Type type);
        [ThreadSafe]
        public static bool IsBlittable(Type type);
        [ThreadSafe]
        public static bool IsUnmanaged(Type type);
        [ThreadSafe]
        public static bool IsValidNativeContainerElementType(Type type);
        public static bool IsUnmanaged<T>();
        public static bool IsValidNativeContainerElementType<T>();
        public static int AlignOf<T>() where T : struct;
        public static void CopyPtrToStructure<T>(void* ptr, out T output) where T : struct;
        public static void CopyStructureToPtr<T>(ref T input, void* ptr) where T : struct;
        public static T ReadArrayElement<T>(void* source, int index);
        public static T ReadArrayElementWithStride<T>(void* source, int index, int stride);
        public static void WriteArrayElement<T>(void* destination, int index, T value);
        public static void WriteArrayElementWithStride<T>(void* destination, int index, int stride, T value);
        public static void* AddressOf<T>(ref T output) where T : struct;
        public static int SizeOf<T>() where T : struct;
        public static ref T As<U, T>(ref U from);
        public static ref T AsRef<T>(void* ptr) where T : struct;
        public static ref T ArrayElementAsRef<T>(void* ptr, int index) where T : struct;
        public static int EnumToInt<T>(T enumValue) where T : IConvertible, struct;
        public static bool EnumEquals<T>(T lhs, T rhs) where T : IConvertible, struct;
    }
}
using System;

namespace Unity.Burst
{
    [AttributeUsage(Method, Property)]
    public class BurstDiscardAttribute : Attribute
    {
        public BurstDiscardAttribute();
    }
}
using System;

namespace JetBrains.Annotations
{
    [AttributeUsage(Class, Method, Property, Field, Event, Interface, Parameter, Delegate, GenericParameter)]
    public sealed class CanBeNullAttribute : Attribute
    {
        public CanBeNullAttribute();
    }
}
using System;

namespace JetBrains.Annotations
{
    [AttributeUsage(Class, Method, Property, Field, Event, Interface, Parameter, Delegate, GenericParameter)]
    public sealed class NotNullAttribute : Attribute
    {
        public NotNullAttribute();
    }
}
using System;

namespace JetBrains.Annotations
{
    [AttributeUsage(Method, Property, Field, Parameter, Delegate)]
    public sealed class ItemNotNullAttribute : Attribute
    {
        public ItemNotNullAttribute();
    }
}
using System;

namespace JetBrains.Annotations
{
    [AttributeUsage(Method, Property, Field, Parameter, Delegate)]
    public sealed class ItemCanBeNullAttribute : Attribute
    {
        public ItemCanBeNullAttribute();
    }
}
using System;

namespace JetBrains.Annotations
{
    [AttributeUsage(Constructor, Method, Property, Delegate)]
    public sealed class StringFormatMethodAttribute : Attribute
    {
        public StringFormatMethodAttribute([NotNull] string formatParameterName);

        [NotNull]
        public string FormatParameterName { get; }
    }
}
using System;

namespace JetBrains.Annotations
{
    [AttributeUsage(Property, Field, Parameter, AllowMultiple = True)]
    public sealed class ValueProviderAttribute : Attribute
    {
        public ValueProviderAttribute([NotNull] string name);

        [NotNull]
        public string Name { get; }
    }
}
using System;

namespace JetBrains.Annotations
{
    [AttributeUsage(Parameter)]
    public sealed class InvokerParameterNameAttribute : Attribute
    {
        public InvokerParameterNameAttribute();
    }
}
using System;

namespace JetBrains.Annotations
{
    [AttributeUsage(Method)]
    public sealed class NotifyPropertyChangedInvocatorAttribute : Attribute
    {
        public NotifyPropertyChangedInvocatorAttribute();
        public NotifyPropertyChangedInvocatorAttribute([NotNull] string parameterName);

        [CanBeNull]
        public string ParameterName { get; }
    }
}
using System;

namespace JetBrains.Annotations
{
    [AttributeUsage(Method, AllowMultiple = True)]
    public sealed class ContractAnnotationAttribute : Attribute
    {
        public ContractAnnotationAttribute([NotNull] string contract);
        public ContractAnnotationAttribute([NotNull] string contract, bool forceFullStates);

        [NotNull]
        public string Contract { get; }
        public bool ForceFullStates { get; }
    }
}
using System;

namespace JetBrains.Annotations
{
    [AttributeUsage(All)]
    public sealed class LocalizationRequiredAttribute : Attribute
    {
        public LocalizationRequiredAttribute();
        public LocalizationRequiredAttribute(bool required);

        public bool Required { get; }
    }
}
using System;

namespace JetBrains.Annotations
{
    [AttributeUsage(Class, Struct, Interface)]
    public sealed class CannotApplyEqualityOperatorAttribute : Attribute
    {
        public CannotApplyEqualityOperatorAttribute();
    }
}
using System;

namespace JetBrains.Annotations
{
    [AttributeUsage(Class, AllowMultiple = True)]
    [BaseTypeRequired(typeof(Attribute))]
    public sealed class BaseTypeRequiredAttribute : Attribute
    {
        public BaseTypeRequiredAttribute([NotNull] Type baseType);

        [NotNull]
        public Type BaseType { get; }
    }
}
using System;

namespace JetBrains.Annotations
{
    [AttributeUsage(All, Inherited = False)]
    public sealed class UsedImplicitlyAttribute : Attribute
    {
        public UsedImplicitlyAttribute();
        public UsedImplicitlyAttribute(ImplicitUseKindFlags useKindFlags);
        public UsedImplicitlyAttribute(ImplicitUseTargetFlags targetFlags);
        public UsedImplicitlyAttribute(ImplicitUseKindFlags useKindFlags, ImplicitUseTargetFlags targetFlags);

        public ImplicitUseKindFlags UseKindFlags { get; }
        public ImplicitUseTargetFlags TargetFlags { get; }
    }
}
using System;

namespace JetBrains.Annotations
{
    [AttributeUsage(Class, Parameter, GenericParameter)]
    public sealed class MeansImplicitUseAttribute : Attribute
    {
        public MeansImplicitUseAttribute();
        public MeansImplicitUseAttribute(ImplicitUseKindFlags useKindFlags);
        public MeansImplicitUseAttribute(ImplicitUseTargetFlags targetFlags);
        public MeansImplicitUseAttribute(ImplicitUseKindFlags useKindFlags, ImplicitUseTargetFlags targetFlags);

        [UsedImplicitly]
        public ImplicitUseKindFlags UseKindFlags { get; }
        [UsedImplicitly]
        public ImplicitUseTargetFlags TargetFlags { get; }
    }
}
using System;

namespace JetBrains.Annotations
{
    [Flags]
    public enum ImplicitUseKindFlags
    {
        Default = 7,
        Access = 1,
        Assign = 2,
        InstantiatedWithFixedConstructorSignature = 4,
        InstantiatedNoFixedConstructorSignature = 8
    }
}
using System;

namespace JetBrains.Annotations
{
    [Flags]
    public enum ImplicitUseTargetFlags
    {
        Default = 1,
        Itself = 1,
        Members = 2,
        WithMembers = 3
    }
}
using System;

namespace JetBrains.Annotations
{
    [MeansImplicitUse(WithMembers)]
    [AttributeUsage(All, Inherited = False)]
    public sealed class PublicAPIAttribute : Attribute
    {
        public PublicAPIAttribute();
        public PublicAPIAttribute([NotNull] string comment);

        [CanBeNull]
        public string Comment { get; }
    }
}
using System;

namespace JetBrains.Annotations
{
    [AttributeUsage(Parameter)]
    public sealed class InstantHandleAttribute : Attribute
    {
        public InstantHandleAttribute();
    }
}
using System;

namespace JetBrains.Annotations
{
    [AttributeUsage(Method)]
    public sealed class PureAttribute : Attribute
    {
        public PureAttribute();
    }
}
using System;

namespace JetBrains.Annotations
{
    [AttributeUsage(Method)]
    public sealed class MustUseReturnValueAttribute : Attribute
    {
        public MustUseReturnValueAttribute();
        public MustUseReturnValueAttribute([NotNull] string justification);

        [CanBeNull]
        public string Justification { get; }
    }
}
using System;

namespace JetBrains.Annotations
{
    [AttributeUsage(Class, Struct, Method, Property, Field, Interface, Parameter, GenericParameter)]
    public sealed class ProvidesContextAttribute : Attribute
    {
        public ProvidesContextAttribute();
    }
}
using System;

namespace JetBrains.Annotations
{
    [AttributeUsage(Parameter)]
    public sealed class PathReferenceAttribute : Attribute
    {
        public PathReferenceAttribute();
        public PathReferenceAttribute([PathReference][NotNull] string basePath);

        [CanBeNull]
        public string BasePath { get; }
    }
}
using System;

namespace JetBrains.Annotations
{
    [AttributeUsage(Method)]
    public sealed class SourceTemplateAttribute : Attribute
    {
        public SourceTemplateAttribute();
    }
}
using System;

namespace JetBrains.Annotations
{
    [AttributeUsage(Method, Parameter, AllowMultiple = True)]
    public sealed class MacroAttribute : Attribute
    {
        public MacroAttribute();

        [CanBeNull]
        public string Expression { get; set; }
        public int Editable { get; set; }
        [CanBeNull]
        public string Target { get; set; }
    }
}
using System;

namespace JetBrains.Annotations
{
    [AttributeUsage(Constructor, Method, Property)]
    public sealed class CollectionAccessAttribute : Attribute
    {
        public CollectionAccessAttribute(CollectionAccessType collectionAccessType);

        public CollectionAccessType CollectionAccessType { get; }
    }
}
using System;

namespace JetBrains.Annotations
{
    [Flags]
    public enum CollectionAccessType
    {
        None = 0,
        Read = 1,
        ModifyExistingContent = 2,
        UpdatedContent = 6
    }
}
using System;

namespace JetBrains.Annotations
{
    [AttributeUsage(Method)]
    public sealed class AssertionMethodAttribute : Attribute
    {
        public AssertionMethodAttribute();
    }
}
using System;

namespace JetBrains.Annotations
{
    [AttributeUsage(Parameter)]
    public sealed class AssertionConditionAttribute : Attribute
    {
        public AssertionConditionAttribute(AssertionConditionType conditionType);

        public AssertionConditionType ConditionType { get; }
    }
}
namespace JetBrains.Annotations
{
    public enum AssertionConditionType
    {
        IS_TRUE = 0,
        IS_FALSE = 1,
        IS_NULL = 2,
        IS_NOT_NULL = 3
    }
}
using System;

namespace JetBrains.Annotations
{
    [Obsolete("Use [ContractAnnotation('=> halt')] instead")]
    [AttributeUsage(Method)]
    public sealed class TerminatesProgramAttribute : Attribute
    {
        public TerminatesProgramAttribute();
    }
}
using System;

namespace JetBrains.Annotations
{
    [AttributeUsage(Method)]
    public sealed class LinqTunnelAttribute : Attribute
    {
        public LinqTunnelAttribute();
    }
}
using System;

namespace JetBrains.Annotations
{
    [AttributeUsage(Parameter)]
    public sealed class NoEnumerationAttribute : Attribute
    {
        public NoEnumerationAttribute();
    }
}
using System;

namespace JetBrains.Annotations
{
    [AttributeUsage(Parameter)]
    public sealed class RegexPatternAttribute : Attribute
    {
        public RegexPatternAttribute();
    }
}
using System;

namespace JetBrains.Annotations
{
    [AttributeUsage(Class, Struct, Enum, Interface)]
    public sealed class NoReorderAttribute : Attribute
    {
        public NoReorderAttribute();
    }
}
namespace UnityEngine
{
    public enum SendMessageOptions
    {
        RequireReceiver = 0,
        DontRequireReceiver = 1
    }
}
namespace UnityEngine
{
    public enum PrimitiveType
    {
        Sphere = 0,
        Capsule = 1,
        Cylinder = 2,
        Cube = 3,
        Plane = 4,
        Quad = 5
    }
}
namespace UnityEngine
{
    public enum Space
    {
        World = 0,
        Self = 1
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    public enum RuntimePlatform
    {
        OSXEditor = 0,
        OSXPlayer = 1,
        WindowsPlayer = 2,
        [Obsolete("WebPlayer export is no longer supported in Unity 5.4+.", True)]
        OSXWebPlayer = 3,
        [Obsolete("Dashboard widget on Mac OS X export is no longer supported in Unity 5.4+.", True)]
        OSXDashboardPlayer = 4,
        [Obsolete("WebPlayer export is no longer supported in Unity 5.4+.", True)]
        WindowsWebPlayer = 5,
        WindowsEditor = 7,
        IPhonePlayer = 8,
        [Obsolete("Xbox360 export is no longer supported in Unity 5.5+.")]
        XBOX360 = 10,
        [Obsolete("PS3 export is no longer supported in Unity >=5.5.")]
        PS3 = 9,
        Android = 11,
        [Obsolete("NaCl export is no longer supported in Unity 5.0+.")]
        NaCl = 12,
        [Obsolete("FlashPlayer export is no longer supported in Unity 5.0+.")]
        FlashPlayer = 15,
        LinuxPlayer = 13,
        LinuxEditor = 16,
        WebGLPlayer = 17,
        [Obsolete("Use WSAPlayerX86 instead")]
        MetroPlayerX86 = 18,
        WSAPlayerX86 = 18,
        [Obsolete("Use WSAPlayerX64 instead")]
        MetroPlayerX64 = 19,
        WSAPlayerX64 = 19,
        [Obsolete("Use WSAPlayerARM instead")]
        MetroPlayerARM = 20,
        WSAPlayerARM = 20,
        [Obsolete("Windows Phone 8 was removed in 5.3")]
        WP8Player = 21,
        [Obsolete("BB10Player export is no longer supported in Unity 5.4+.")]
        [EditorBrowsable(Never)]
        BB10Player = 22,
        [Obsolete("BlackBerryPlayer export is no longer supported in Unity 5.4+.")]
        BlackBerryPlayer = 22,
        [Obsolete("TizenPlayer export is no longer supported in Unity 2017.3+.")]
        TizenPlayer = 23,
        [Obsolete("PSP2 is no longer supported as of Unity 2018.3")]
        PSP2 = 24,
        PS4 = 25,
        [Obsolete("PSM export is no longer supported in Unity >= 5.3")]
        PSM = 26,
        XboxOne = 27,
        [Obsolete("SamsungTVPlayer export is no longer supported in Unity 2017.3+.")]
        SamsungTVPlayer = 28,
        [Obsolete("Wii U is no longer supported in Unity 2018.1+.")]
        WiiU = 30,
        tvOS = 31,
        Switch = 32,
        Lumin = 33,
        Stadia = 34,
        CloudRendering = 35,
        [Obsolete("GameCoreScarlett is deprecated, please use GameCoreXboxSeries (UnityUpgradable) -> GameCoreXboxSeries", False)]
        GameCoreScarlett = -1,
        GameCoreXboxSeries = 36,
        GameCoreXboxOne = 37,
        PS5 = 38
    }
}
using System;

namespace UnityEngine
{
    public enum SystemLanguage
    {
        Afrikaans = 0,
        Arabic = 1,
        Basque = 2,
        Belarusian = 3,
        Bulgarian = 4,
        Catalan = 5,
        Chinese = 6,
        Czech = 7,
        Danish = 8,
        Dutch = 9,
        English = 10,
        Estonian = 11,
        Faroese = 12,
        Finnish = 13,
        French = 14,
        German = 15,
        Greek = 16,
        Hebrew = 17,
        [Obsolete("Use SystemLanguage.Hungarian instead (UnityUpgradable) -> Hungarian", True)]
        Hugarian = 18,
        Icelandic = 19,
        Indonesian = 20,
        Italian = 21,
        Japanese = 22,
        Korean = 23,
        Latvian = 24,
        Lithuanian = 25,
        Norwegian = 26,
        Polish = 27,
        Portuguese = 28,
        Romanian = 29,
        Russian = 30,
        SerboCroatian = 31,
        Slovak = 32,
        Slovenian = 33,
        Spanish = 34,
        Swedish = 35,
        Thai = 36,
        Turkish = 37,
        Ukrainian = 38,
        Vietnamese = 39,
        ChineseSimplified = 40,
        ChineseTraditional = 41,
        Unknown = 42,
        Hungarian = 18
    }
}
namespace UnityEngine
{
    public enum LogType
    {
        Error = 0,
        Assert = 1,
        Warning = 2,
        Log = 3,
        Exception = 4
    }
}
namespace UnityEngine
{
    public enum LogOption
    {
        None = 0,
        NoStacktrace = 1
    }
}
namespace UnityEngine
{
    public enum ThreadPriority
    {
        Low = 0,
        BelowNormal = 1,
        Normal = 2,
        High = 4
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/BaseClasses/TagManager.h")]
    public struct SortingLayer
    {
        public int id { get; }
        public string name { get; }
        public int value { get; }
        public static SortingLayer[] layers { get; }

        [FreeFunction("GetTagManager().GetSortingLayerValueFromUniqueID")]
        public static int GetLayerValueFromID(int id);
        [FreeFunction("GetTagManager().GetSortingLayerValueFromName")]
        public static int GetLayerValueFromName(string name);
        [FreeFunction("GetTagManager().GetSortingLayerUniqueIDFromName")]
        public static int NameToID(string name);
        [FreeFunction("GetTagManager().GetSortingLayerNameFromUniqueID")]
        public static string IDToName(int id);
        [FreeFunction("GetTagManager().IsSortingLayerUniqueIDValid")]
        public static bool IsValid(int id);
    }
}
namespace UnityEngine
{
    public enum WeightedMode
    {
        None = 0,
        In = 1,
        Out = 2,
        Both = 3
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [RequiredByNativeCode]
    public struct Keyframe
    {
        public Keyframe(float time, float value);
        public Keyframe(float time, float value, float inTangent, float outTangent);
        public Keyframe(float time, float value, float inTangent, float outTangent, float inWeight, float outWeight);

        public float time { get; set; }
        public float value { get; set; }
        public float inTangent { get; set; }
        public float outTangent { get; set; }
        public float inWeight { get; set; }
        public float outWeight { get; set; }
        public WeightedMode weightedMode { get; set; }
        [Obsolete("Use AnimationUtility.SetKeyLeftTangentMode, AnimationUtility.SetKeyRightTangentMode, AnimationUtility.GetKeyLeftTangentMode or AnimationUtility.GetKeyRightTangentMode instead.")]
        public int tangentMode { get; set; }
    }
}
namespace UnityEngine
{
    public enum WrapMode
    {
        Once = 1,
        Loop = 2,
        PingPong = 4,
        Default = 0,
        ClampForever = 8,
        Clamp = 1
    }
}
using System;
using System.Reflection;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [RequiredByNativeCode]
    [NativeHeader("Runtime/Math/AnimationCurve.bindings.h")]
    [DefaultMember("Item")]
    public class AnimationCurve : IEquatable<AnimationCurve>
    {
        public AnimationCurve(params Keyframe[] keys);
        [RequiredByNativeCode]
        public AnimationCurve();

        ~AnimationCurve();

        public Keyframe this[int index] { get; }
        public Keyframe[] keys { get; set; }
        public int length { get; }
        public WrapMode preWrapMode { get; set; }
        public WrapMode postWrapMode { get; set; }

        [ThreadSafe]
        public float Evaluate(float time);
        [FreeFunction("AnimationCurveBindings::AddKeySmoothTangents", HasExplicitThis = True, IsThreadSafe = True)]
        public int AddKey(float time, float value);
        public int AddKey(Keyframe key);
        [FreeFunction("AnimationCurveBindings::MoveKey", HasExplicitThis = True, IsThreadSafe = True)]
        [NativeThrows]
        public int MoveKey(int index, Keyframe key);
        [NativeThrows]
        [FreeFunction("AnimationCurveBindings::RemoveKey", HasExplicitThis = True, IsThreadSafe = True)]
        public void RemoveKey(int index);
        [NativeThrows]
        [FreeFunction("AnimationCurveBindings::SmoothTangents", HasExplicitThis = True, IsThreadSafe = True)]
        public void SmoothTangents(int index, float weight);
        public static AnimationCurve Constant(float timeStart, float timeEnd, float value);
        public static AnimationCurve Linear(float timeStart, float valueStart, float timeEnd, float valueEnd);
        public static AnimationCurve EaseInOut(float timeStart, float valueStart, float timeEnd, float valueEnd);
        public override bool Equals(object o);
        public bool Equals(AnimationCurve other);
        public override int GetHashCode();
    }
}
using System;
using System.ComponentModel;
using UnityEngine.Bindings;
using UnityEngine.Events;

namespace UnityEngine
{
    [NativeHeader("Runtime/Utilities/URLUtility.h")]
    [NativeHeader("Runtime/BaseClasses/IsPlaying.h")]
    [NativeHeader("Runtime/Export/Application/Application.bindings.h")]
    [NativeHeader("Runtime/Logging/LogSystem.h")]
    [NativeHeader("Runtime/Application/ApplicationInfo.h")]
    [NativeHeader("Runtime/Application/AdsIdHandler.h")]
    [NativeHeader("Runtime/Utilities/Argv.h")]
    [NativeHeader("Runtime/Misc/BuildSettings.h")]
    [NativeHeader("Runtime/Input/GetInput.h")]
    [NativeHeader("Runtime/PreloadManager/LoadSceneOperation.h")]
    [NativeHeader("Runtime/File/ApplicationSpecificPersistentDataPath.h")]
    [NativeHeader("Runtime/Input/TargetFrameRate.h")]
    [NativeHeader("Runtime/Network/NetworkUtility.h")]
    [NativeHeader("Runtime/PreloadManager/PreloadManager.h")]
    [NativeHeader("Runtime/Misc/PlayerSettings.h")]
    [NativeHeader("Runtime/Misc/SystemInfo.h")]
    [NativeHeader("Runtime/Input/InputManager.h")]
    [NativeHeader("Runtime/Misc/Player.h")]
    public class Application
    {
        public Application();

        [Obsolete("This property is deprecated, please use LoadLevelAsync to detect if a specific scene is currently loading.")]
        public static bool isLoadingLevel { get; }
        [Obsolete("Streaming was a Unity Web Player feature, and is removed. This property is deprecated and always returns 0.")]
        public static int streamedBytes { get; }
        [Obsolete("Application.webSecurityEnabled is no longer supported, since the Unity Web Player is no longer supported by Unity", True)]
        [EditorBrowsable(Never)]
        public static bool webSecurityEnabled { get; }
        public static bool isPlaying { get; }
        public static bool isFocused { get; }
        public static string buildGUID { get; }
        public static bool runInBackground { get; set; }
        public static bool isBatchMode { get; }
        public static string dataPath { get; }
        public static string streamingAssetsPath { get; }
        public static string persistentDataPath { get; }
        public static string temporaryCachePath { get; }
        public static string absoluteURL { get; }
        public static string unityVersion { get; }
        public static string version { get; }
        public static string installerName { get; }
        public static string identifier { get; }
        public static ApplicationInstallMode installMode { get; }
        public static ApplicationSandboxType sandboxType { get; }
        public static string productName { get; }
        public static string companyName { get; }
        public static string cloudProjectId { get; }
        public static int targetFrameRate { get; set; }
        [Obsolete("Use SetStackTraceLogType/GetStackTraceLogType instead")]
        public static StackTraceLogType stackTraceLogType { get; set; }
        public static string consoleLogPath { get; }
        public static ThreadPriority backgroundLoadingPriority { get; set; }
        public static bool genuine { get; }
        public static bool genuineCheckAvailable { get; }
        [Obsolete("This property is deprecated, please use SplashScreen.isFinished instead")]
        public static bool isShowingSplashScreen { get; }
        public static RuntimePlatform platform { get; }
        public static bool isMobilePlatform { get; }
        public static bool isConsolePlatform { get; }
        public static SystemLanguage systemLanguage { get; }
        public static NetworkReachability internetReachability { get; }
        [Obsolete("use Application.isEditor instead")]
        public static bool isPlayer { get; }
        [Obsolete("Use SceneManager.sceneCountInBuildSettings")]
        public static int levelCount { get; }
        [Obsolete("Use SceneManager to determine what scenes have been loaded")]
        public static int loadedLevel { get; }
        [Obsolete("Use SceneManager to determine what scenes have been loaded")]
        public static string loadedLevelName { get; }
        public static bool isEditor { get; }

        public static event LowMemoryCallback lowMemory;
        public static event LogCallback logMessageReceived;
        public static event LogCallback logMessageReceivedThreaded;
        public static event UnityAction onBeforeRender;
        public static event Action<bool> focusChanged;
        public static event Action<string> deepLinkActivated;
        public static event Func<bool> wantsToQuit;
        public static event Action quitting;
        public static event Action unloading;

        [FreeFunction("GetInputManager().QuitApplication")]
        public static void Quit(int exitCode);
        public static void Quit();
        [FreeFunction("GetInputManager().CancelQuitApplication")]
        [Obsolete("CancelQuit is deprecated. Use the wantsToQuit event instead.")]
        public static void CancelQuit();
        [FreeFunction("Application_Bindings::Unload")]
        public static void Unload();
        [Obsolete("Streaming was a Unity Web Player feature, and is removed. This function is deprecated and always returns 1.0 for valid level indices.")]
        public static float GetStreamProgressForLevel(int levelIndex);
        [Obsolete("Streaming was a Unity Web Player feature, and is removed. This function is deprecated and always returns 1.0.")]
        public static float GetStreamProgressForLevel(string levelName);
        public static bool CanStreamedLevelBeLoaded(int levelIndex);
        [FreeFunction("Application_Bindings::CanStreamedLevelBeLoaded")]
        public static bool CanStreamedLevelBeLoaded(string levelName);
        [FreeFunction]
        public static bool IsPlaying([NotNull("NullExceptionObject")] Object obj);
        [FreeFunction("GetBuildSettings().GetBuildTags")]
        public static string[] GetBuildTags();
        [FreeFunction("GetBuildSettings().SetBuildTags")]
        public static void SetBuildTags(string[] buildTags);
        [FreeFunction("GetBuildSettings().GetHasPROVersion")]
        public static bool HasProLicense();
        [Obsolete("Application.ExternalEval is deprecated. See https://docs.unity3d.com/Manual/webgl-interactingwithbrowserscripting.html for alternatives.")]
        public static void ExternalEval(string script);
        [FreeFunction("GetAdsIdHandler().RequestAdsIdAsync")]
        public static bool RequestAdvertisingIdentifierAsync(AdvertisingIdentifierCallback delegateMethod);
        [FreeFunction("OpenURL")]
        public static void OpenURL(string url);
        [Obsolete("Use UnityEngine.Diagnostics.Utils.ForceCrash")]
        public static void ForceCrash(int mode);
        [FreeFunction("GetStackTraceLogType")]
        public static StackTraceLogType GetStackTraceLogType(LogType logType);
        [FreeFunction("SetStackTraceLogType")]
        public static void SetStackTraceLogType(LogType logType, StackTraceLogType stackTraceType);
        [FreeFunction("Application_Bindings::RequestUserAuthorization")]
        public static AsyncOperation RequestUserAuthorization(UserAuthorization mode);
        [FreeFunction("Application_Bindings::HasUserAuthorization")]
        public static bool HasUserAuthorization(UserAuthorization mode);
        [Obsolete("Application.ExternalCall is deprecated. See https://docs.unity3d.com/Manual/webgl-interactingwithbrowserscripting.html for alternatives.")]
        public static void ExternalCall(string functionName, params object[] args);
        [Obsolete("Use Object.DontDestroyOnLoad instead")]
        public static void DontDestroyOnLoad(Object o);
        [Obsolete("Application.CaptureScreenshot is obsolete. Use ScreenCapture.CaptureScreenshot instead (UnityUpgradable) -> [UnityEngine] UnityEngine.ScreenCapture.CaptureScreenshot(*)", True)]
        public static void CaptureScreenshot(string filename, int superSize);
        [Obsolete("Application.CaptureScreenshot is obsolete. Use ScreenCapture.CaptureScreenshot instead (UnityUpgradable) -> [UnityEngine] UnityEngine.ScreenCapture.CaptureScreenshot(*)", True)]
        public static void CaptureScreenshot(string filename);
        [Obsolete("Application.RegisterLogCallback is deprecated. Use Application.logMessageReceived instead.")]
        public static void RegisterLogCallback(LogCallback handler);
        [Obsolete("Application.RegisterLogCallbackThreaded is deprecated. Use Application.logMessageReceivedThreaded instead.")]
        public static void RegisterLogCallbackThreaded(LogCallback handler);
        [Obsolete("Use SceneManager.LoadScene")]
        public static void LoadLevel(int index);
        [Obsolete("Use SceneManager.LoadScene")]
        public static void LoadLevel(string name);
        [Obsolete("Use SceneManager.LoadScene")]
        public static void LoadLevelAdditive(int index);
        [Obsolete("Use SceneManager.LoadScene")]
        public static void LoadLevelAdditive(string name);
        [Obsolete("Use SceneManager.LoadSceneAsync")]
        public static AsyncOperation LoadLevelAsync(int index);
        [Obsolete("Use SceneManager.LoadSceneAsync")]
        public static AsyncOperation LoadLevelAsync(string levelName);
        [Obsolete("Use SceneManager.LoadSceneAsync")]
        public static AsyncOperation LoadLevelAdditiveAsync(int index);
        [Obsolete("Use SceneManager.LoadSceneAsync")]
        public static AsyncOperation LoadLevelAdditiveAsync(string levelName);
        [Obsolete("Use SceneManager.UnloadScene")]
        public static bool UnloadLevel(int index);
        [Obsolete("Use SceneManager.UnloadScene")]
        public static bool UnloadLevel(string scenePath);

        public delegate void AdvertisingIdentifierCallback(string advertisingId, bool trackingEnabled, string errorMsg);
        public delegate void LowMemoryCallback();
        public delegate void LogCallback(string condition, string stackTrace, LogType type);
    }
}
namespace UnityEngine
{
    public enum StackTraceLogType
    {
        None = 0,
        ScriptOnly = 1,
        Full = 2
    }
}
namespace UnityEngine
{
    public enum NetworkReachability
    {
        NotReachable = 0,
        ReachableViaCarrierDataNetwork = 1,
        ReachableViaLocalAreaNetwork = 2
    }
}
namespace UnityEngine
{
    public enum UserAuthorization
    {
        WebCam = 1,
        Microphone = 2
    }
}
namespace UnityEngine
{
    public enum ApplicationInstallMode
    {
        Unknown = 0,
        Store = 1,
        DeveloperBuild = 2,
        Adhoc = 3,
        Enterprise = 4,
        Editor = 5
    }
}
namespace UnityEngine
{
    public enum ApplicationSandboxType
    {
        Unknown = 0,
        NotSandboxed = 1,
        Sandboxed = 2,
        SandboxBroken = 3
    }
}
namespace UnityEngine
{
    public enum AudioType
    {
        UNKNOWN = 0,
        ACC = 1,
        AIFF = 2,
        IT = 10,
        MOD = 12,
        MPEG = 13,
        OGGVORBIS = 14,
        S3M = 17,
        WAV = 20,
        XM = 21,
        XMA = 22,
        VAG = 23,
        AUDIOQUEUE = 24
    }
}
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    public struct CachedAssetBundle
    {
        public CachedAssetBundle(string name, Hash128 hash);

        public string name { get; set; }
        public Hash128 hash { get; set; }
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Misc/Cache.h")]
    [StaticAccessor("CacheWrapper", DoubleColon)]
    public struct Cache : IEquatable<Cache>
    {
        public bool valid { get; }
        public bool ready { get; }
        public bool readOnly { get; }
        public string path { get; }
        public int index { get; }
        public long spaceFree { get; }
        public long maximumAvailableStorageSpace { get; set; }
        public long spaceOccupied { get; }
        public int expirationDelay { get; set; }

        public override int GetHashCode();
        public override bool Equals(object other);
        public bool Equals(Cache other);
        public bool ClearCache();
        public bool ClearCache(int expiration);

        public static bool operator ==(Cache lhs, Cache rhs);
        public static bool operator !=(Cache lhs, Cache rhs);
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [Obsolete("This struct is not for public use.")]
    [UsedByNativeCode]
    public struct CacheIndex
    {
        public string name;
        public int bytesUsed;
        public int expires;
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Misc/CachingManager.h")]
    [StaticAccessor("GetCachingManager()", Dot)]
    public sealed class Caching
    {
        public Caching();

        public static bool compressionEnabled { get; set; }
        public static bool ready { get; }
        [Obsolete("Please use use Cache.spaceOccupied to get used bytes per cache.")]
        public static int spaceUsed { get; }
        [Obsolete("This property is only used for the current cache, use Cache.spaceOccupied to get used bytes per cache.")]
        public static long spaceOccupied { get; }
        [Obsolete("Please use use Cache.spaceOccupied to get used bytes per cache.")]
        public static int spaceAvailable { get; }
        [Obsolete("This property is only used for the current cache, use Cache.spaceFree to get unused bytes per cache.")]
        public static long spaceFree { get; }
        [Obsolete("This property is only used for the current cache, use Cache.maximumAvailableStorageSpace to access the maximum available storage space per cache.")]
        [StaticAccessor("GetCachingManager().GetCurrentCache()", Dot)]
        public static long maximumAvailableDiskSpace { get; set; }
        [StaticAccessor("GetCachingManager().GetCurrentCache()", Dot)]
        [Obsolete("This property is only used for the current cache, use Cache.expirationDelay to access the expiration delay per cache.")]
        public static int expirationDelay { get; set; }
        public static int cacheCount { get; }
        [StaticAccessor("CachingManagerWrapper", DoubleColon)]
        public static Cache defaultCache { get; }
        [StaticAccessor("CachingManagerWrapper", DoubleColon)]
        public static Cache currentCacheForWriting { get; set; }

        public static bool ClearCache();
        public static bool ClearCache(int expiration);
        public static bool ClearCachedVersion(string assetBundleName, Hash128 hash);
        public static bool ClearOtherCachedVersions(string assetBundleName, Hash128 hash);
        public static bool ClearAllCachedVersions(string assetBundleName);
        public static void GetCachedVersions(string assetBundleName, List<Hash128> outCachedVersions);
        [Obsolete("Please use IsVersionCached with Hash128 instead.")]
        public static bool IsVersionCached(string url, int version);
        public static bool IsVersionCached(string url, Hash128 hash);
        public static bool IsVersionCached(CachedAssetBundle cachedBundle);
        [Obsolete("Please use MarkAsUsed with Hash128 instead.")]
        public static bool MarkAsUsed(string url, int version);
        public static bool MarkAsUsed(string url, Hash128 hash);
        public static bool MarkAsUsed(CachedAssetBundle cachedBundle);
        [Obsolete("Please use SetNoBackupFlag with Hash128 instead.")]
        public static void SetNoBackupFlag(string url, int version);
        public static void SetNoBackupFlag(string url, Hash128 hash);
        public static void SetNoBackupFlag(CachedAssetBundle cachedBundle);
        [Obsolete("Please use ResetNoBackupFlag with Hash128 instead.")]
        public static void ResetNoBackupFlag(string url, int version);
        public static void ResetNoBackupFlag(string url, Hash128 hash);
        public static void ResetNoBackupFlag(CachedAssetBundle cachedBundle);
        [Obsolete("This function is obsolete and will always return -1. Use IsVersionCached instead.")]
        public static int GetVersionFromCache(string url);
        public static Cache AddCache(string cachePath);
        [StaticAccessor("CachingManagerWrapper", DoubleColon)]
        [NativeThrows]
        [NativeName("Caching_GetCacheHandleAt")]
        public static Cache GetCacheAt(int cacheIndex);
        [NativeThrows]
        [StaticAccessor("CachingManagerWrapper", DoubleColon)]
        [NativeName("Caching_GetCacheHandleByPath")]
        public static Cache GetCacheByPath(string cachePath);
        public static void GetAllCachePaths(List<string> cachePaths);
        [StaticAccessor("CachingManagerWrapper", DoubleColon)]
        [NativeName("Caching_RemoveCacheByHandle")]
        [NativeThrows]
        public static bool RemoveCache(Cache cache);
        [StaticAccessor("CachingManagerWrapper", DoubleColon)]
        [NativeName("Caching_MoveCacheBeforeByHandle")]
        [NativeThrows]
        public static void MoveCacheBefore(Cache src, Cache dst);
        [NativeName("Caching_MoveCacheAfterByHandle")]
        [NativeThrows]
        [StaticAccessor("CachingManagerWrapper", DoubleColon)]
        public static void MoveCacheAfter(Cache src, Cache dst);
        [Obsolete("This function is obsolete. Please use ClearCache.  (UnityUpgradable) -> ClearCache()")]
        public static bool CleanCache();
    }
}
using System;
using System.Collections.Generic;
using System.ComponentModel;
using UnityEngine.Bindings;
using UnityEngine.Rendering;
using UnityEngine.SceneManagement;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [RequireComponent(typeof(Transform))]
    [NativeHeader("Runtime/Graphics/RenderTexture.h")]
    [NativeHeader("Runtime/GfxDevice/GfxDeviceTypes.h")]
    [NativeHeader("Runtime/Camera/Camera.h")]
    [NativeHeader("Runtime/Shaders/Shader.h")]
    [NativeHeader("Runtime/Camera/RenderManager.h")]
    [UsedByNativeCode]
    [NativeHeader("Runtime/Misc/GameObjectUtility.h")]
    [NativeHeader("Runtime/Graphics/CommandBuffer/RenderingCommandBuffer.h")]
    public sealed class Camera : Behaviour
    {
        public static CameraCallback onPreCull;
        public static CameraCallback onPreRender;
        public static CameraCallback onPostRender;

        public Camera();

        [NativeProperty("Near")]
        public float nearClipPlane { get; set; }
        [NativeProperty("Far")]
        public float farClipPlane { get; set; }
        [NativeProperty("VerticalFieldOfView")]
        public float fieldOfView { get; set; }
        public RenderingPath renderingPath { get; set; }
        public RenderingPath actualRenderingPath { get; }
        public bool allowHDR { get; set; }
        public bool allowMSAA { get; set; }
        public bool allowDynamicResolution { get; set; }
        [NativeProperty("ForceIntoRT")]
        public bool forceIntoRenderTexture { get; set; }
        public float orthographicSize { get; set; }
        public bool orthographic { get; set; }
        public OpaqueSortMode opaqueSortMode { get; set; }
        public TransparencySortMode transparencySortMode { get; set; }
        public Vector3 transparencySortAxis { get; set; }
        public float depth { get; set; }
        public float aspect { get; set; }
        public Vector3 velocity { get; }
        public int cullingMask { get; set; }
        public int eventMask { get; set; }
        public bool layerCullSpherical { get; set; }
        public CameraType cameraType { get; set; }
        [NativeConditional("UNITY_EDITOR")]
        public ulong overrideSceneCullingMask { get; set; }
        public float[] layerCullDistances { get; set; }
        public bool useOcclusionCulling { get; set; }
        public Matrix4x4 cullingMatrix { get; set; }
        public Color backgroundColor { get; set; }
        public CameraClearFlags clearFlags { get; set; }
        public DepthTextureMode depthTextureMode { get; set; }
        public bool clearStencilAfterLightingPass { get; set; }
        public bool usePhysicalProperties { get; set; }
        public Vector2 sensorSize { get; set; }
        public Vector2 lensShift { get; set; }
        public float focalLength { get; set; }
        public GateFitMode gateFit { get; set; }
        [NativeProperty("NormalizedViewportRect")]
        public Rect rect { get; set; }
        [NativeProperty("ScreenViewportRect")]
        public Rect pixelRect { get; set; }
        public int pixelWidth { get; }
        public int pixelHeight { get; }
        public int scaledPixelWidth { get; }
        public int scaledPixelHeight { get; }
        public RenderTexture targetTexture { get; set; }
        public RenderTexture activeTexture { get; }
        public int targetDisplay { get; set; }
        public Matrix4x4 cameraToWorldMatrix { get; }
        public Matrix4x4 worldToCameraMatrix { get; set; }
        public Matrix4x4 projectionMatrix { get; set; }
        public Matrix4x4 nonJitteredProjectionMatrix { get; set; }
        [NativeProperty("UseJitteredProjectionMatrixForTransparent")]
        public bool useJitteredProjectionMatrixForTransparentRendering { get; set; }
        public Matrix4x4 previousViewProjectionMatrix { get; }
        public static Camera main { get; }
        public static Camera current { get; }
        public Scene scene { get; set; }
        public bool stereoEnabled { get; }
        public float stereoSeparation { get; set; }
        public float stereoConvergence { get; set; }
        public bool areVRStereoViewMatricesWithinSingleCullTolerance { get; }
        public StereoTargetEyeMask stereoTargetEye { get; set; }
        public MonoOrStereoscopicEye stereoActiveEye { get; }
        public static int allCamerasCount { get; }
        public static Camera[] allCameras { get; }
        public int commandBufferCount { get; }
        [EditorBrowsable(Never)]
        [Obsolete("Property isOrthoGraphic has been deprecated. Use orthographic (UnityUpgradable) -> orthographic", True)]
        public bool isOrthoGraphic { get; set; }
        [Obsolete("Property mainCamera has been deprecated. Use Camera.main instead (UnityUpgradable) -> main", True)]
        [EditorBrowsable(Never)]
        public static Camera mainCamera { get; }
        [Obsolete("Property near has been deprecated. Use Camera.nearClipPlane instead (UnityUpgradable) -> UnityEngine.Camera.nearClipPlane", False)]
        [EditorBrowsable(Never)]
        public float near { get; set; }
        [Obsolete("Property far has been deprecated. Use Camera.farClipPlane instead (UnityUpgradable) -> UnityEngine.Camera.farClipPlane", False)]
        [EditorBrowsable(Never)]
        public float far { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("Property fov has been deprecated. Use Camera.fieldOfView instead (UnityUpgradable) -> UnityEngine.Camera.fieldOfView", False)]
        public float fov { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("Property hdr has been deprecated. Use Camera.allowHDR instead (UnityUpgradable) -> UnityEngine.Camera.allowHDR", False)]
        public bool hdr { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("Property stereoMirrorMode is no longer supported. Please use single pass stereo rendering instead.", True)]
        public bool stereoMirrorMode { get; set; }

        public void Reset();
        public void ResetTransparencySortSettings();
        public void ResetAspect();
        public void ResetCullingMatrix();
        public void SetReplacementShader(Shader shader, string replacementTag);
        public void ResetReplacementShader();
        public float GetGateFittedFieldOfView();
        public Vector2 GetGateFittedLensShift();
        public void SetTargetBuffers(RenderBuffer colorBuffer, RenderBuffer depthBuffer);
        public void SetTargetBuffers(RenderBuffer[] colorBuffer, RenderBuffer depthBuffer);
        public void ResetWorldToCameraMatrix();
        public void ResetProjectionMatrix();
        [FreeFunction("CameraScripting::CalculateObliqueMatrix", HasExplicitThis = True)]
        public Matrix4x4 CalculateObliqueMatrix(Vector4 clipPlane);
        public Vector3 WorldToScreenPoint(Vector3 position, MonoOrStereoscopicEye eye);
        public Vector3 WorldToViewportPoint(Vector3 position, MonoOrStereoscopicEye eye);
        public Vector3 ViewportToWorldPoint(Vector3 position, MonoOrStereoscopicEye eye);
        public Vector3 ScreenToWorldPoint(Vector3 position, MonoOrStereoscopicEye eye);
        public Vector3 WorldToScreenPoint(Vector3 position);
        public Vector3 WorldToViewportPoint(Vector3 position);
        public Vector3 ViewportToWorldPoint(Vector3 position);
        public Vector3 ScreenToWorldPoint(Vector3 position);
        public Vector3 ScreenToViewportPoint(Vector3 position);
        public Vector3 ViewportToScreenPoint(Vector3 position);
        public Ray ViewportPointToRay(Vector3 pos, MonoOrStereoscopicEye eye);
        public Ray ViewportPointToRay(Vector3 pos);
        public Ray ScreenPointToRay(Vector3 pos, MonoOrStereoscopicEye eye);
        public Ray ScreenPointToRay(Vector3 pos);
        public void CalculateFrustumCorners(Rect viewport, float z, MonoOrStereoscopicEye eye, Vector3[] outCorners);
        public static void CalculateProjectionMatrixFromPhysicalProperties(out Matrix4x4 output, float focalLength, Vector2 sensorSize, Vector2 lensShift, float nearClip, float farClip, GateFitParameters gateFitParameters = null);
        [NativeName("FocalLengthToFieldOfView_Safe")]
        public static float FocalLengthToFieldOfView(float focalLength, float sensorSize);
        [NativeName("FieldOfViewToFocalLength_Safe")]
        public static float FieldOfViewToFocalLength(float fieldOfView, float sensorSize);
        [NativeName("HorizontalToVerticalFieldOfView_Safe")]
        public static float HorizontalToVerticalFieldOfView(float horizontalFieldOfView, float aspectRatio);
        public static float VerticalToHorizontalFieldOfView(float verticalFieldOfView, float aspectRatio);
        public Matrix4x4 GetStereoNonJitteredProjectionMatrix(StereoscopicEye eye);
        [FreeFunction("CameraScripting::GetStereoViewMatrix", HasExplicitThis = True)]
        public Matrix4x4 GetStereoViewMatrix(StereoscopicEye eye);
        public void CopyStereoDeviceProjectionMatrixToNonJittered(StereoscopicEye eye);
        [FreeFunction("CameraScripting::GetStereoProjectionMatrix", HasExplicitThis = True)]
        public Matrix4x4 GetStereoProjectionMatrix(StereoscopicEye eye);
        public void SetStereoProjectionMatrix(StereoscopicEye eye, Matrix4x4 matrix);
        public void ResetStereoProjectionMatrices();
        public void SetStereoViewMatrix(StereoscopicEye eye, Matrix4x4 matrix);
        public void ResetStereoViewMatrices();
        public static int GetAllCameras(Camera[] cameras);
        public bool RenderToCubemap(Cubemap cubemap, int faceMask);
        public bool RenderToCubemap(Cubemap cubemap);
        public bool RenderToCubemap(RenderTexture cubemap, int faceMask);
        public bool RenderToCubemap(RenderTexture cubemap);
        public bool RenderToCubemap(RenderTexture cubemap, int faceMask, MonoOrStereoscopicEye stereoEye);
        [FreeFunction("CameraScripting::Render", HasExplicitThis = True)]
        public void Render();
        [FreeFunction("CameraScripting::RenderWithShader", HasExplicitThis = True)]
        public void RenderWithShader(Shader shader, string replacementTag);
        [FreeFunction("CameraScripting::RenderDontRestore", HasExplicitThis = True)]
        public void RenderDontRestore();
        public void SubmitRenderRequests(List<RenderRequest> renderRequests);
        [FreeFunction("CameraScripting::SetupCurrent")]
        public static void SetupCurrent(Camera cur);
        [FreeFunction("CameraScripting::CopyFrom", HasExplicitThis = True)]
        public void CopyFrom(Camera other);
        public void RemoveCommandBuffers(CameraEvent evt);
        public void RemoveAllCommandBuffers();
        public void AddCommandBuffer(CameraEvent evt, CommandBuffer buffer);
        public void AddCommandBufferAsync(CameraEvent evt, CommandBuffer buffer, ComputeQueueType queueType);
        public void RemoveCommandBuffer(CameraEvent evt, CommandBuffer buffer);
        [FreeFunction("CameraScripting::GetCommandBuffers", HasExplicitThis = True)]
        public CommandBuffer[] GetCommandBuffers(CameraEvent evt);
        public bool TryGetCullingParameters(out ScriptableCullingParameters cullingParameters);
        public bool TryGetCullingParameters(bool stereoAware, out ScriptableCullingParameters cullingParameters);
        [EditorBrowsable(Never)]
        [Obsolete("Camera.GetScreenWidth has been deprecated. Use Screen.width instead (UnityUpgradable) -> System.Int32 Screen.width", True)]
        public float GetScreenWidth();
        [Obsolete("Camera.GetScreenHeight has been deprecated. Use Screen.height instead (UnityUpgradable) -> System.Int32 Screen.height", True)]
        [EditorBrowsable(Never)]
        public float GetScreenHeight();
        [EditorBrowsable(Never)]
        [Obsolete("Camera.DoClear has been deprecated (UnityUpgradable).", True)]
        public void DoClear();
        [EditorBrowsable(Never)]
        [Obsolete("Camera.ResetFieldOfView has been deprecated in Unity 5.6 and will be removed in the future. Please replace it by explicitly setting the camera's FOV to 60 degrees.", False)]
        public void ResetFieldOfView();
        [EditorBrowsable(Never)]
        [Obsolete("Camera.SetStereoViewMatrices has been deprecated. Use SetStereoViewMatrix(StereoscopicEye eye) instead.", False)]
        public void SetStereoViewMatrices(Matrix4x4 leftMatrix, Matrix4x4 rightMatrix);
        [Obsolete("Camera.SetStereoProjectionMatrices has been deprecated. Use SetStereoProjectionMatrix(StereoscopicEye eye) instead.", False)]
        [EditorBrowsable(Never)]
        public void SetStereoProjectionMatrices(Matrix4x4 leftMatrix, Matrix4x4 rightMatrix);
        [Obsolete("Camera.GetStereoViewMatrices has been deprecated. Use GetStereoViewMatrix(StereoscopicEye eye) instead.", False)]
        [EditorBrowsable(Never)]
        public Matrix4x4[] GetStereoViewMatrices();
        [EditorBrowsable(Never)]
        [Obsolete("Camera.GetStereoProjectionMatrices has been deprecated. Use GetStereoProjectionMatrix(StereoscopicEye eye) instead.", False)]
        public Matrix4x4[] GetStereoProjectionMatrices();

        public enum GateFitMode
        {
            Vertical = 1,
            Horizontal = 2,
            Fill = 3,
            Overscan = 4,
            None = 0
        }
        public enum FieldOfViewAxis
        {
            Vertical = 0,
            Horizontal = 1
        }
        public struct GateFitParameters
        {
            public GateFitParameters(GateFitMode mode, float aspect);

            public GateFitMode mode { get; set; }
            public float aspect { get; set; }
        }
        public enum StereoscopicEye
        {
            Left = 0,
            Right = 1
        }
        public enum MonoOrStereoscopicEye
        {
            Left = 0,
            Right = 1,
            Mono = 2
        }
        public enum RenderRequestMode
        {
            None = 0,
            ObjectId = 1,
            Depth = 2,
            VertexNormal = 3,
            WorldPosition = 4,
            EntityId = 5,
            BaseColor = 6,
            SpecularColor = 7,
            Metallic = 8,
            Emission = 9,
            Normal = 10,
            Smoothness = 11,
            Occlusion = 12,
            DiffuseColor = 13
        }
        public enum RenderRequestOutputSpace
        {
            ScreenSpace = -1,
            UV0 = 0,
            UV1 = 1,
            UV2 = 2,
            UV3 = 3,
            UV4 = 4,
            UV5 = 5,
            UV6 = 6,
            UV7 = 7,
            UV8 = 8
        }
        public struct RenderRequest
        {
            public RenderRequest(RenderRequestMode mode, RenderTexture rt);
            public RenderRequest(RenderRequestMode mode, RenderRequestOutputSpace space, RenderTexture rt);

            public bool isValid { get; }
            public RenderRequestMode mode { get; }
            public RenderTexture result { get; }
            public RenderRequestOutputSpace outputSpace { get; }
        }
        public delegate void CameraCallback(Camera cam);
    }
}
namespace UnityEngine
{
    public struct BoundingSphere
    {
        public Vector3 position;
        public float radius;

        public BoundingSphere(Vector3 pos, float rad);
        public BoundingSphere(Vector4 packedSphere);
    }
}
namespace UnityEngine
{
    public struct CullingGroupEvent
    {
        public int index { get; }
        public bool isVisible { get; }
        public bool wasVisible { get; }
        public bool hasBecomeVisible { get; }
        public bool hasBecomeInvisible { get; }
        public int currentDistance { get; }
        public int previousDistance { get; }
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Export/Camera/CullingGroup.bindings.h")]
    public class CullingGroup : IDisposable
    {
        public CullingGroup();

        ~CullingGroup();

        public StateChanged onStateChanged { get; set; }
        public bool enabled { get; set; }
        public Camera targetCamera { get; set; }

        public void Dispose();
        public void SetBoundingSpheres(BoundingSphere[] array);
        public void SetBoundingSphereCount(int count);
        public void EraseSwapBack(int index);
        public static void EraseSwapBack<T>(int index, T[] myArray, ref int size);
        public int QueryIndices(bool visible, int[] result, int firstIndex);
        public int QueryIndices(int distanceIndex, int[] result, int firstIndex);
        public int QueryIndices(bool visible, int distanceIndex, int[] result, int firstIndex);
        [FreeFunction("CullingGroup_Bindings::IsVisible", HasExplicitThis = True)]
        [NativeThrows]
        public bool IsVisible(int index);
        [FreeFunction("CullingGroup_Bindings::GetDistance", HasExplicitThis = True)]
        [NativeThrows]
        public int GetDistance(int index);
        [FreeFunction("CullingGroup_Bindings::SetBoundingDistances", HasExplicitThis = True)]
        public void SetBoundingDistances(float[] distances);
        public void SetDistanceReferencePoint(Vector3 point);
        public void SetDistanceReferencePoint(Transform transform);

        public delegate void StateChanged(CullingGroupEvent sphere);
    }
}
namespace UnityEngine
{
    [RequireComponent(typeof(Camera))]
    public class FlareLayer : Behaviour
    {
    }
}
using System;
using System.ComponentModel;
using UnityEngine.Bindings;
using UnityEngine.Internal;
using UnityEngine.Rendering;

namespace UnityEngine
{
    [NativeHeader("Runtime/Camera/ReflectionProbes.h")]
    public sealed class ReflectionProbe : Behaviour
    {
        public ReflectionProbe();

        [Obsolete("type property has been deprecated. Starting with Unity 5.4, the only supported reflection probe type is Cube.", True)]
        [NativeName("ProbeType")]
        [EditorBrowsable(Never)]
        public ReflectionProbeType type { get; set; }
        [NativeName("BoxSize")]
        public Vector3 size { get; set; }
        [NativeName("BoxOffset")]
        public Vector3 center { get; set; }
        [NativeName("Near")]
        public float nearClipPlane { get; set; }
        [NativeName("Far")]
        public float farClipPlane { get; set; }
        [NativeName("IntensityMultiplier")]
        public float intensity { get; set; }
        [NativeName("GlobalAABB")]
        public Bounds bounds { get; }
        [NativeName("HDR")]
        public bool hdr { get; set; }
        [NativeName("RenderDynamicObjects")]
        public bool renderDynamicObjects { get; set; }
        public float shadowDistance { get; set; }
        public int resolution { get; set; }
        public int cullingMask { get; set; }
        public ReflectionProbeClearFlags clearFlags { get; set; }
        public Color backgroundColor { get; set; }
        public float blendDistance { get; set; }
        public bool boxProjection { get; set; }
        public ReflectionProbeMode mode { get; set; }
        public int importance { get; set; }
        public ReflectionProbeRefreshMode refreshMode { get; set; }
        public ReflectionProbeTimeSlicingMode timeSlicingMode { get; set; }
        public Texture bakedTexture { get; set; }
        public Texture customBakedTexture { get; set; }
        public RenderTexture realtimeTexture { get; set; }
        public Texture texture { get; }
        public Vector4 textureHDRDecodeValues { get; }
        [StaticAccessor("GetReflectionProbes()")]
        public static int minBakedCubemapResolution { get; }
        [StaticAccessor("GetReflectionProbes()")]
        public static int maxBakedCubemapResolution { get; }
        [StaticAccessor("GetReflectionProbes()")]
        public static Vector4 defaultTextureHDRDecodeValues { get; }
        [StaticAccessor("GetReflectionProbes()")]
        public static Texture defaultTexture { get; }

        public static event Action<ReflectionProbe, ReflectionProbeEvent> reflectionProbeChanged;
        public static event Action<Cubemap> defaultReflectionSet;

        public void Reset();
        public int RenderProbe();
        public int RenderProbe([UnityEngine.Internal.DefaultValue("null")] RenderTexture targetTexture);
        public bool IsFinishedRendering(int renderId);
        [NativeHeader("Runtime/Camera/CubemapGPUUtility.h")]
        [FreeFunction("CubemapGPUBlend")]
        public static bool BlendCubemap(Texture src, Texture dst, float blend, RenderTexture target);

        public enum ReflectionProbeEvent
        {
            ReflectionProbeAdded = 0,
            ReflectionProbeRemoved = 1
        }
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Export/CrashReport/CrashReport.bindings.h")]
    public sealed class CrashReport
    {
        public readonly DateTime time;
        public readonly string text;

        public static CrashReport[] reports { get; }
        public static CrashReport lastReport { get; }

        public static void RemoveAll();
        public void Remove();
    }
}
using System;
using System.ComponentModel;
using System.Diagnostics;
using UnityEngine.Bindings;
using UnityEngine.Internal;

namespace UnityEngine
{
    [NativeHeader("Runtime/Export/Debug/Debug.bindings.h")]
    public class Debug
    {
        public Debug();

        public static ILogger unityLogger { get; }
        public static bool developerConsoleVisible { get; set; }
        [StaticAccessor("GetBuildSettings()", Dot)]
        [NativeProperty(TargetType = Field)]
        public static bool isDebugBuild { get; }
        [Obsolete("Debug.logger is obsolete. Please use Debug.unityLogger instead (UnityUpgradable) -> unityLogger")]
        [EditorBrowsable(Never)]
        public static ILogger logger { get; }

        [ExcludeFromDocs]
        public static void DrawLine(Vector3 start, Vector3 end, Color color, float duration);
        [ExcludeFromDocs]
        public static void DrawLine(Vector3 start, Vector3 end, Color color);
        [ExcludeFromDocs]
        public static void DrawLine(Vector3 start, Vector3 end);
        [FreeFunction("DebugDrawLine", IsThreadSafe = True)]
        public static void DrawLine(Vector3 start, Vector3 end, [UnityEngine.Internal.DefaultValue("Color.white")] Color color, [UnityEngine.Internal.DefaultValue("0.0f")] float duration, [UnityEngine.Internal.DefaultValue("true")] bool depthTest);
        [ExcludeFromDocs]
        public static void DrawRay(Vector3 start, Vector3 dir, Color color, float duration);
        [ExcludeFromDocs]
        public static void DrawRay(Vector3 start, Vector3 dir, Color color);
        [ExcludeFromDocs]
        public static void DrawRay(Vector3 start, Vector3 dir);
        public static void DrawRay(Vector3 start, Vector3 dir, [UnityEngine.Internal.DefaultValue("Color.white")] Color color, [UnityEngine.Internal.DefaultValue("0.0f")] float duration, [UnityEngine.Internal.DefaultValue("true")] bool depthTest);
        [FreeFunction("PauseEditor")]
        public static void Break();
        public static void DebugBreak();
        [ThreadSafe]
        public static int ExtractStackTraceNoAlloc(byte* buffer, int bufferMax, string projectFolder);
        public static void Log(object message);
        public static void Log(object message, Object context);
        public static void LogFormat(string format, params object[] args);
        public static void LogFormat(Object context, string format, params object[] args);
        public static void LogFormat(LogType logType, LogOption logOptions, Object context, string format, params object[] args);
        public static void LogError(object message);
        public static void LogError(object message, Object context);
        public static void LogErrorFormat(string format, params object[] args);
        public static void LogErrorFormat(Object context, string format, params object[] args);
        public static void ClearDeveloperConsole();
        public static void LogException(Exception exception);
        public static void LogException(Exception exception, Object context);
        public static void LogWarning(object message);
        public static void LogWarning(object message, Object context);
        public static void LogWarningFormat(string format, params object[] args);
        public static void LogWarningFormat(Object context, string format, params object[] args);
        [Conditional("UNITY_ASSERTIONS")]
        public static void Assert(bool condition);
        [Conditional("UNITY_ASSERTIONS")]
        public static void Assert(bool condition, Object context);
        [Conditional("UNITY_ASSERTIONS")]
        public static void Assert(bool condition, object message);
        [Conditional("UNITY_ASSERTIONS")]
        public static void Assert(bool condition, string message);
        [Conditional("UNITY_ASSERTIONS")]
        public static void Assert(bool condition, object message, Object context);
        [Conditional("UNITY_ASSERTIONS")]
        public static void Assert(bool condition, string message, Object context);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AssertFormat(bool condition, string format, params object[] args);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AssertFormat(bool condition, Object context, string format, params object[] args);
        [Conditional("UNITY_ASSERTIONS")]
        public static void LogAssertion(object message);
        [Conditional("UNITY_ASSERTIONS")]
        public static void LogAssertion(object message, Object context);
        [Conditional("UNITY_ASSERTIONS")]
        public static void LogAssertionFormat(string format, params object[] args);
        [Conditional("UNITY_ASSERTIONS")]
        public static void LogAssertionFormat(Object context, string format, params object[] args);
        [Conditional("UNITY_ASSERTIONS")]
        [EditorBrowsable(Never)]
        [Obsolete("Assert(bool, string, params object[]) is obsolete. Use AssertFormat(bool, string, params object[]) (UnityUpgradable) -> AssertFormat(*)", True)]
        public static void Assert(bool condition, string format, params object[] args);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Utilities/PropertyName.h")]
    [NativeHeader("Runtime/Director/Core/ExposedPropertyTable.bindings.h")]
    public struct ExposedPropertyResolver
    {
    }
}
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode(Name = "ExposedReference")]
    public struct ExposedReference<T> where T : Object
    {
        [SerializeField]
        public PropertyName exposedName;
        [SerializeField]
        public Object defaultValue;

        public T Resolve(IExposedPropertyTable resolver);
    }
}
namespace UnityEngine
{
    public interface IExposedPropertyTable
    {
        void SetReferenceValue(PropertyName id, Object value);
        Object GetReferenceValue(PropertyName id, out bool idValid);
        void ClearReferenceValue(PropertyName id);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Export/ETW/EventProvider.bindings.h")]
    public sealed class EventProvider
    {
        public EventProvider();

        [FreeFunction("EventProvider_Bindings::WriteCustomEvent")]
        public static void WriteCustomEvent(int value, string text);
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Runtime/Math/MathScripting.h")]
    [NativeClass("AABB")]
    [NativeHeader("Runtime/Geometry/AABB.h")]
    [NativeHeader("Runtime/Geometry/Ray.h")]
    [NativeType(Header = "Runtime/Geometry/AABB.h")]
    [NativeHeader("Runtime/Geometry/Intersection.h")]
    [RequiredByNativeCode(Optional = True, GenerateProxy = True)]
    public struct Bounds : IEquatable<Bounds>, IFormattable
    {
        public Bounds(Vector3 center, Vector3 size);

        public Vector3 center { get; set; }
        public Vector3 size { get; set; }
        public Vector3 extents { get; set; }
        public Vector3 min { get; set; }
        public Vector3 max { get; set; }

        public override int GetHashCode();
        public override bool Equals(object other);
        public bool Equals(Bounds other);
        public void SetMinMax(Vector3 min, Vector3 max);
        public void Encapsulate(Vector3 point);
        public void Encapsulate(Bounds bounds);
        public void Expand(float amount);
        public void Expand(Vector3 amount);
        public bool Intersects(Bounds bounds);
        public bool IntersectRay(Ray ray);
        public bool IntersectRay(Ray ray, out float distance);
        public override string ToString();
        public string ToString(string format);
        public string ToString(string format, IFormatProvider formatProvider);
        [NativeMethod("IsInside", IsThreadSafe = True)]
        public bool Contains(Vector3 point);
        [FreeFunction("BoundsScripting::SqrDistance", HasExplicitThis = True, IsThreadSafe = True)]
        public float SqrDistance(Vector3 point);
        [FreeFunction("BoundsScripting::ClosestPoint", HasExplicitThis = True, IsThreadSafe = True)]
        public Vector3 ClosestPoint(Vector3 point);

        public static bool operator ==(Bounds lhs, Bounds rhs);
        public static bool operator !=(Bounds lhs, Bounds rhs);
    }
}
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    public struct BoundsInt : IEquatable<BoundsInt>, IFormattable
    {
        public BoundsInt(int xMin, int yMin, int zMin, int sizeX, int sizeY, int sizeZ);
        public BoundsInt(Vector3Int position, Vector3Int size);

        public int x { get; set; }
        public int y { get; set; }
        public int z { get; set; }
        public Vector3 center { get; }
        public Vector3Int min { get; set; }
        public Vector3Int max { get; set; }
        public int xMin { get; set; }
        public int yMin { get; set; }
        public int zMin { get; set; }
        public int xMax { get; set; }
        public int yMax { get; set; }
        public int zMax { get; set; }
        public Vector3Int position { get; set; }
        public Vector3Int size { get; set; }
        public PositionEnumerator allPositionsWithin { get; }

        public void SetMinMax(Vector3Int minPosition, Vector3Int maxPosition);
        public void ClampToBounds(BoundsInt bounds);
        public bool Contains(Vector3Int position);
        public override string ToString();
        public string ToString(string format);
        public string ToString(string format, IFormatProvider formatProvider);
        public override bool Equals(object other);
        public bool Equals(BoundsInt other);
        public override int GetHashCode();

        public static bool operator ==(BoundsInt lhs, BoundsInt rhs);
        public static bool operator !=(BoundsInt lhs, BoundsInt rhs);

        public struct PositionEnumerator : IEnumerator<Vector3Int>, IEnumerator, IDisposable
        {
            public PositionEnumerator(Vector3Int min, Vector3Int max);

            public Vector3Int Current { get; }

            public PositionEnumerator GetEnumerator();
            public bool MoveNext();
            public void Reset();
        }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Graphics/GraphicsScriptBindings.h")]
    [StaticAccessor("GeometryUtilityScripting", DoubleColon)]
    public sealed class GeometryUtility
    {
        public GeometryUtility();

        public static Plane[] CalculateFrustumPlanes(Camera camera);
        public static Plane[] CalculateFrustumPlanes(Matrix4x4 worldToProjectionMatrix);
        public static void CalculateFrustumPlanes(Camera camera, Plane[] planes);
        public static void CalculateFrustumPlanes(Matrix4x4 worldToProjectionMatrix, Plane[] planes);
        public static Bounds CalculateBounds(Vector3[] positions, Matrix4x4 transform);
        public static bool TryCreatePlaneFromPolygon(Vector3[] vertices, out Plane plane);
        public static bool TestPlanesAABB(Plane[] planes, Bounds bounds);
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    public struct Plane : IFormattable
    {
        public Plane(Vector3 inNormal, Vector3 inPoint);
        public Plane(Vector3 inNormal, float d);
        public Plane(Vector3 a, Vector3 b, Vector3 c);

        public Vector3 normal { get; set; }
        public float distance { get; set; }
        public Plane flipped { get; }

        public void SetNormalAndPosition(Vector3 inNormal, Vector3 inPoint);
        public void Set3Points(Vector3 a, Vector3 b, Vector3 c);
        public void Flip();
        public void Translate(Vector3 translation);
        public static Plane Translate(Plane plane, Vector3 translation);
        public Vector3 ClosestPointOnPlane(Vector3 point);
        public float GetDistanceToPoint(Vector3 point);
        public bool GetSide(Vector3 point);
        public bool SameSide(Vector3 inPt0, Vector3 inPt1);
        public bool Raycast(Ray ray, out float enter);
        public override string ToString();
        public string ToString(string format);
        public string ToString(string format, IFormatProvider formatProvider);
    }
}
using System;

namespace UnityEngine
{
    public struct Ray : IFormattable
    {
        public Ray(Vector3 origin, Vector3 direction);

        public Vector3 origin { get; set; }
        public Vector3 direction { get; set; }

        public Vector3 GetPoint(float distance);
        public override string ToString();
        public string ToString(string format);
        public string ToString(string format, IFormatProvider formatProvider);
    }
}
using System;

namespace UnityEngine
{
    public struct Ray2D : IFormattable
    {
        public Ray2D(Vector2 origin, Vector2 direction);

        public Vector2 origin { get; set; }
        public Vector2 direction { get; set; }

        public Vector2 GetPoint(float distance);
        public override string ToString();
        public string ToString(string format);
        public string ToString(string format, IFormatProvider formatProvider);
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Runtime/Math/Rect.h")]
    [NativeClass("Rectf", "template<typename T> class RectT; typedef RectT<float> Rectf;")]
    [RequiredByNativeCode(Optional = True, GenerateProxy = True)]
    public struct Rect : IEquatable<Rect>, IFormattable
    {
        public Rect(float x, float y, float width, float height);
        public Rect(Vector2 position, Vector2 size);
        public Rect(Rect source);

        public static Rect zero { get; }
        public float x { get; set; }
        public float y { get; set; }
        public Vector2 position { get; set; }
        public Vector2 center { get; set; }
        public Vector2 min { get; set; }
        public Vector2 max { get; set; }
        public float width { get; set; }
        public float height { get; set; }
        public Vector2 size { get; set; }
        public float xMin { get; set; }
        public float yMin { get; set; }
        public float xMax { get; set; }
        public float yMax { get; set; }
        [Obsolete("use xMin")]
        public float left { get; }
        [Obsolete("use xMax")]
        public float right { get; }
        [Obsolete("use yMin")]
        public float top { get; }
        [Obsolete("use yMax")]
        public float bottom { get; }

        public static Rect MinMaxRect(float xmin, float ymin, float xmax, float ymax);
        public void Set(float x, float y, float width, float height);
        public bool Contains(Vector2 point);
        public bool Contains(Vector3 point);
        public bool Contains(Vector3 point, bool allowInverse);
        public bool Overlaps(Rect other);
        public bool Overlaps(Rect other, bool allowInverse);
        public static Vector2 NormalizedToPoint(Rect rectangle, Vector2 normalizedRectCoordinates);
        public static Vector2 PointToNormalized(Rect rectangle, Vector2 point);
        public override int GetHashCode();
        public override bool Equals(object other);
        public bool Equals(Rect other);
        public override string ToString();
        public string ToString(string format);
        public string ToString(string format, IFormatProvider formatProvider);

        public static bool operator !=(Rect lhs, Rect rhs);
        public static bool operator ==(Rect lhs, Rect rhs);
    }
}
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    public struct RectInt : IEquatable<RectInt>, IFormattable
    {
        public RectInt(int xMin, int yMin, int width, int height);
        public RectInt(Vector2Int position, Vector2Int size);

        public int x { get; set; }
        public int y { get; set; }
        public Vector2 center { get; }
        public Vector2Int min { get; set; }
        public Vector2Int max { get; set; }
        public int width { get; set; }
        public int height { get; set; }
        public int xMin { get; set; }
        public int yMin { get; set; }
        public int xMax { get; set; }
        public int yMax { get; set; }
        public Vector2Int position { get; set; }
        public Vector2Int size { get; set; }
        public PositionEnumerator allPositionsWithin { get; }

        public void SetMinMax(Vector2Int minPosition, Vector2Int maxPosition);
        public void ClampToBounds(RectInt bounds);
        public bool Contains(Vector2Int position);
        public bool Overlaps(RectInt other);
        public override string ToString();
        public string ToString(string format);
        public string ToString(string format, IFormatProvider formatProvider);
        public bool Equals(RectInt other);

        public struct PositionEnumerator : IEnumerator<Vector2Int>, IEnumerator, IDisposable
        {
            public PositionEnumerator(Vector2Int min, Vector2Int max);

            public Vector2Int Current { get; }

            public PositionEnumerator GetEnumerator();
            public bool MoveNext();
            public void Reset();
        }
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    [NativeHeader("Modules/IMGUI/GUIStyle.h")]
    public class RectOffset : IFormattable
    {
        public RectOffset();
        public RectOffset(int left, int right, int top, int bottom);

        ~RectOffset();

        [NativeProperty("left", False, Field)]
        public int left { get; set; }
        [NativeProperty("right", False, Field)]
        public int right { get; set; }
        [NativeProperty("top", False, Field)]
        public int top { get; set; }
        [NativeProperty("bottom", False, Field)]
        public int bottom { get; set; }
        public int horizontal { get; }
        public int vertical { get; }

        public override string ToString();
        public string ToString(string format);
        public string ToString(string format, IFormatProvider formatProvider);
        public Rect Add(Rect rect);
        public Rect Remove(Rect rect);
    }
}
using System;
using System.ComponentModel;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/GI/DynamicGI.h")]
    public sealed class DynamicGI
    {
        public DynamicGI();

        public static float indirectScale { get; set; }
        public static float updateThreshold { get; set; }
        public static int materialUpdateTimeSlice { get; set; }
        public static bool synchronousMode { get; set; }
        public static bool isConverged { get; }

        public static void SetEmissive(Renderer renderer, Color color);
        [NativeThrows]
        public static void SetEnvironmentData([NotNull("ArgumentNullException")] float[] input);
        public static void UpdateEnvironment();
        [Obsolete("DynamicGI.UpdateMaterials(Renderer) is deprecated; instead, use extension method from RendererExtensions: 'renderer.UpdateGIMaterials()' (UnityUpgradable).", True)]
        [EditorBrowsable(Never)]
        public static void UpdateMaterials(Renderer renderer);
        [Obsolete("DynamicGI.UpdateMaterials(Terrain) is deprecated; instead, use extension method from TerrainExtensions: 'terrain.UpdateGIMaterials()' (UnityUpgradable).", True)]
        [EditorBrowsable(Never)]
        public static void UpdateMaterials(Object renderer);
        [Obsolete("DynamicGI.UpdateMaterials(Terrain, int, int, int, int) is deprecated; instead, use extension method from TerrainExtensions: 'terrain.UpdateGIMaterials(x, y, width, height)' (UnityUpgradable).", True)]
        [EditorBrowsable(Never)]
        public static void UpdateMaterials(Object renderer, int x, int y, int width, int height);
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [PreventReadOnlyInstanceModification]
    [NativeHeader("Runtime/Graphics/LightingSettings.h")]
    public sealed class LightingSettings : Object
    {
        public LightingSettings();

        [NativeName("EnableBakedLightmaps")]
        public bool bakedGI { get; set; }
        [NativeName("EnableRealtimeLightmaps")]
        public bool realtimeGI { get; set; }
        [NativeName("RealtimeEnvironmentLighting")]
        public bool realtimeEnvironmentLighting { get; set; }
        [NativeName("AutoGenerate")]
        public bool autoGenerate { get; set; }
        [NativeName("MixedBakeMode")]
        public MixedLightingMode mixedBakeMode { get; set; }
        [NativeName("AlbedoBoost")]
        public float albedoBoost { get; set; }
        [NativeName("IndirectOutputScale")]
        public float indirectScale { get; set; }
        [NativeName("BakeBackend")]
        public Lightmapper lightmapper { get; set; }
        [NativeName("LightmapMaxSize")]
        public int lightmapMaxSize { get; set; }
        [NativeName("BakeResolution")]
        public float lightmapResolution { get; set; }
        [NativeName("Padding")]
        public int lightmapPadding { get; set; }
        [NativeName("TextureCompression")]
        public bool compressLightmaps { get; set; }
        [NativeName("AO")]
        public bool ao { get; set; }
        [NativeName("AOMaxDistance")]
        public float aoMaxDistance { get; set; }
        [NativeName("CompAOExponent")]
        public float aoExponentIndirect { get; set; }
        [NativeName("CompAOExponentDirect")]
        public float aoExponentDirect { get; set; }
        [NativeName("ExtractAO")]
        public bool extractAO { get; set; }
        [NativeName("LightmapsBakeMode")]
        public LightmapsMode directionalityMode { get; set; }
        public bool exportTrainingData { get; set; }
        public string trainingDataDestination { get; set; }
        [NativeName("RealtimeResolution")]
        public float indirectResolution { get; set; }
        public bool finalGather { get; set; }
        public float finalGatherRayCount { get; set; }
        public bool finalGatherFiltering { get; set; }
        [NativeName("PVRSampling")]
        public Sampling sampling { get; set; }
        [NativeName("PVRDirectSampleCount")]
        public int directSampleCount { get; set; }
        [NativeName("PVRSampleCount")]
        public int indirectSampleCount { get; set; }
        [Obsolete("Use LightingSettings.maxBounces instead. (UnityUpgradable) -> UnityEngine.LightingSettings.maxBounces", False)]
        [NativeName("PVRBounces")]
        public int bounces { get; set; }
        [NativeName("PVRBounces")]
        public int maxBounces { get; set; }
        [Obsolete("Use LightingSettings.minBounces instead. (UnityUpgradable) -> UnityEngine.LightingSettings.minBounces", False)]
        [NativeName("PVRMinBounces")]
        public int russianRouletteStartBounce { get; set; }
        [NativeName("PVRMinBounces")]
        public int minBounces { get; set; }
        [NativeName("PVRCulling")]
        public bool prioritizeView { get; set; }
        [NativeName("PVRFilteringMode")]
        public FilterMode filteringMode { get; set; }
        [NativeName("PVRDenoiserTypeDirect")]
        public DenoiserType denoiserTypeDirect { get; set; }
        [NativeName("PVRDenoiserTypeIndirect")]
        public DenoiserType denoiserTypeIndirect { get; set; }
        [NativeName("PVRDenoiserTypeAO")]
        public DenoiserType denoiserTypeAO { get; set; }
        [NativeName("PVRFilterTypeDirect")]
        public FilterType filterTypeDirect { get; set; }
        [NativeName("PVRFilterTypeIndirect")]
        public FilterType filterTypeIndirect { get; set; }
        [NativeName("PVRFilterTypeAO")]
        public FilterType filterTypeAO { get; set; }
        [NativeName("PVRFilteringGaussRadiusDirect")]
        public int filteringGaussRadiusDirect { get; set; }
        [NativeName("PVRFilteringGaussRadiusIndirect")]
        public int filteringGaussRadiusIndirect { get; set; }
        [NativeName("PVRFilteringGaussRadiusAO")]
        public int filteringGaussRadiusAO { get; set; }
        [NativeName("PVRFilteringAtrousPositionSigmaDirect")]
        public float filteringAtrousPositionSigmaDirect { get; set; }
        [NativeName("PVRFilteringAtrousPositionSigmaIndirect")]
        public float filteringAtrousPositionSigmaIndirect { get; set; }
        [NativeName("PVRFilteringAtrousPositionSigmaAO")]
        public float filteringAtrousPositionSigmaAO { get; set; }
        [NativeName("PVREnvironmentSampleCount")]
        public int environmentSampleCount { get; set; }
        [NativeName("LightProbeSampleCountMultiplier")]
        public float lightProbeSampleCountMultiplier { get; set; }

        public enum Lightmapper
        {
            Enlighten = 0,
            ProgressiveCPU = 1,
            ProgressiveGPU = 2
        }
        public enum Sampling
        {
            Auto = 0,
            Fixed = 1
        }
        public enum FilterMode
        {
            None = 0,
            Auto = 1,
            Advanced = 2
        }
        public enum DenoiserType
        {
            None = 0,
            Optix = 1,
            OpenImage = 2,
            RadeonPro = 3
        }
        public enum FilterType
        {
            Gaussian = 0,
            ATrous = 1,
            None = 2
        }
    }
}
using UnityEngine.Bindings;
using UnityEngine.Internal;

namespace UnityEngine
{
    [NativeHeader("Runtime/Export/Gizmos/Gizmos.bindings.h")]
    [StaticAccessor("GizmoBindings", DoubleColon)]
    public sealed class Gizmos
    {
        public Gizmos();

        public static Color color { get; set; }
        public static Matrix4x4 matrix { get; set; }
        public static Texture exposure { get; set; }
        public static float probeSize { get; }

        [NativeThrows]
        public static void DrawLine(Vector3 from, Vector3 to);
        [NativeThrows]
        public static void DrawWireSphere(Vector3 center, float radius);
        [NativeThrows]
        public static void DrawSphere(Vector3 center, float radius);
        [NativeThrows]
        public static void DrawWireCube(Vector3 center, Vector3 size);
        [NativeThrows]
        public static void DrawCube(Vector3 center, Vector3 size);
        [NativeThrows]
        public static void DrawMesh(Mesh mesh, int submeshIndex, [DefaultValue("Vector3.zero")] Vector3 position, [DefaultValue("Quaternion.identity")] Quaternion rotation, [DefaultValue("Vector3.one")] Vector3 scale);
        [NativeThrows]
        public static void DrawWireMesh(Mesh mesh, int submeshIndex, [DefaultValue("Vector3.zero")] Vector3 position, [DefaultValue("Quaternion.identity")] Quaternion rotation, [DefaultValue("Vector3.one")] Vector3 scale);
        [NativeThrows]
        public static void DrawIcon(Vector3 center, string name, [DefaultValue("true")] bool allowScaling);
        [NativeThrows]
        public static void DrawIcon(Vector3 center, string name, [DefaultValue("true")] bool allowScaling, [DefaultValue("Color(255,255,255,255)")] Color tint);
        [NativeThrows]
        public static void DrawGUITexture(Rect screenRect, Texture texture, int leftBorder, int rightBorder, int topBorder, int bottomBorder, [DefaultValue("null")] Material mat);
        public static void DrawFrustum(Vector3 center, float fov, float maxRange, float minRange, float aspect);
        public static void DrawRay(Ray r);
        public static void DrawRay(Vector3 from, Vector3 direction);
        [ExcludeFromDocs]
        public static void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation);
        [ExcludeFromDocs]
        public static void DrawMesh(Mesh mesh, Vector3 position);
        [ExcludeFromDocs]
        public static void DrawMesh(Mesh mesh);
        public static void DrawMesh(Mesh mesh, [DefaultValue("Vector3.zero")] Vector3 position, [DefaultValue("Quaternion.identity")] Quaternion rotation, [DefaultValue("Vector3.one")] Vector3 scale);
        [ExcludeFromDocs]
        public static void DrawMesh(Mesh mesh, int submeshIndex, Vector3 position, Quaternion rotation);
        [ExcludeFromDocs]
        public static void DrawMesh(Mesh mesh, int submeshIndex, Vector3 position);
        [ExcludeFromDocs]
        public static void DrawMesh(Mesh mesh, int submeshIndex);
        [ExcludeFromDocs]
        public static void DrawWireMesh(Mesh mesh, Vector3 position, Quaternion rotation);
        [ExcludeFromDocs]
        public static void DrawWireMesh(Mesh mesh, Vector3 position);
        [ExcludeFromDocs]
        public static void DrawWireMesh(Mesh mesh);
        public static void DrawWireMesh(Mesh mesh, [DefaultValue("Vector3.zero")] Vector3 position, [DefaultValue("Quaternion.identity")] Quaternion rotation, [DefaultValue("Vector3.one")] Vector3 scale);
        [ExcludeFromDocs]
        public static void DrawWireMesh(Mesh mesh, int submeshIndex, Vector3 position, Quaternion rotation);
        [ExcludeFromDocs]
        public static void DrawWireMesh(Mesh mesh, int submeshIndex, Vector3 position);
        [ExcludeFromDocs]
        public static void DrawWireMesh(Mesh mesh, int submeshIndex);
        [ExcludeFromDocs]
        public static void DrawIcon(Vector3 center, string name);
        [ExcludeFromDocs]
        public static void DrawGUITexture(Rect screenRect, Texture texture);
        public static void DrawGUITexture(Rect screenRect, Texture texture, [DefaultValue("null")] Material mat);
        [ExcludeFromDocs]
        public static void DrawGUITexture(Rect screenRect, Texture texture, int leftBorder, int rightBorder, int topBorder, int bottomBorder);
    }
}
using System;

namespace UnityEngine
{
    [AttributeUsage(Method)]
    public class BeforeRenderOrderAttribute : Attribute
    {
        public BeforeRenderOrderAttribute(int order);

        public int order { get; }
    }
}
using System.Collections.Generic;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Graphics/Billboard/BillboardAsset.h")]
    [NativeHeader("Runtime/Export/Graphics/BillboardRenderer.bindings.h")]
    public sealed class BillboardAsset : Object
    {
        public BillboardAsset();

        public float width { get; set; }
        public float height { get; set; }
        public float bottom { get; set; }
        public int imageCount { get; }
        public int vertexCount { get; }
        public int indexCount { get; }
        public Material material { get; set; }

        public void GetImageTexCoords(List<Vector4> imageTexCoords);
        [NativeMethod("GetBillboardDataReadonly().GetImageTexCoords")]
        public Vector4[] GetImageTexCoords();
        public void SetImageTexCoords(List<Vector4> imageTexCoords);
        [FreeFunction(Name = "BillboardRenderer_Bindings::SetImageTexCoords", HasExplicitThis = True)]
        public void SetImageTexCoords([NotNull("ArgumentNullException")] Vector4[] imageTexCoords);
        public void GetVertices(List<Vector2> vertices);
        [NativeMethod("GetBillboardDataReadonly().GetVertices")]
        public Vector2[] GetVertices();
        public void SetVertices(List<Vector2> vertices);
        [FreeFunction(Name = "BillboardRenderer_Bindings::SetVertices", HasExplicitThis = True)]
        public void SetVertices([NotNull("ArgumentNullException")] Vector2[] vertices);
        public void GetIndices(List<ushort> indices);
        [NativeMethod("GetBillboardDataReadonly().GetIndices")]
        public ushort[] GetIndices();
        public void SetIndices(List<ushort> indices);
        [FreeFunction(Name = "BillboardRenderer_Bindings::SetIndices", HasExplicitThis = True)]
        public void SetIndices([NotNull("ArgumentNullException")] ushort[] indices);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Graphics/Billboard/BillboardRenderer.h")]
    public sealed class BillboardRenderer : Renderer
    {
        public BillboardRenderer();

        public BillboardAsset billboard { get; set; }
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Graphics/CustomRenderTextureManager.h")]
    public static class CustomRenderTextureManager
    {
        public static event Action<CustomRenderTexture> textureLoaded;
        public static event Action<CustomRenderTexture> textureUnloaded;
        public static event Action<CustomRenderTexture, int> updateTriggered;
        public static event Action<CustomRenderTexture> initializeTriggered;

        [FreeFunction(Name = "CustomRenderTextureManagerScripting::GetAllCustomRenderTextures", HasExplicitThis = False)]
        public static void GetAllCustomRenderTextures(List<CustomRenderTexture> currentCustomRenderTextures);
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    [NativeHeader("Runtime/Graphics/DisplayManager.h")]
    public class Display
    {
        public static Display[] displays;

        public int renderingWidth { get; }
        public int renderingHeight { get; }
        public int systemWidth { get; }
        public int systemHeight { get; }
        public RenderBuffer colorBuffer { get; }
        public RenderBuffer depthBuffer { get; }
        public bool active { get; }
        public bool requiresBlitToBackbuffer { get; }
        public bool requiresSrgbBlitToBackbuffer { get; }
        public static Display main { get; }
        public static int activeEditorGameViewTarget { get; }

        public static event DisplaysUpdatedDelegate onDisplaysUpdated;

        public void Activate();
        public void Activate(int width, int height, int refreshRate);
        public void SetParams(int width, int height, int x, int y);
        public void SetRenderingResolution(int w, int h);
        [Obsolete("MultiDisplayLicense has been deprecated.", False)]
        public static bool MultiDisplayLicense();
        public static Vector3 RelativeMouseAt(Vector3 inputMouseCoordinates);

        public delegate void DisplaysUpdatedDelegate();
    }
}
namespace UnityEngine
{
    public enum FullScreenMode
    {
        ExclusiveFullScreen = 0,
        FullScreenWindow = 1,
        MaximizedWindow = 2,
        Windowed = 3
    }
}
namespace UnityEngine
{
    public sealed class SleepTimeout
    {
        public const int NeverSleep = -1;
        public const int SystemSetting = -2;

        public SleepTimeout();
    }
}
using System;
using System.ComponentModel;
using UnityEngine.Internal;

namespace UnityEngine
{
    public sealed class Screen
    {
        public Screen();

        public static int width { get; }
        public static int height { get; }
        public static float dpi { get; }
        public static Resolution currentResolution { get; }
        public static Resolution[] resolutions { get; }
        public static bool fullScreen { get; set; }
        public static FullScreenMode fullScreenMode { get; set; }
        public static Rect safeArea { get; }
        public static Rect[] cutouts { get; }
        public static bool autorotateToPortrait { get; set; }
        public static bool autorotateToPortraitUpsideDown { get; set; }
        public static bool autorotateToLandscapeLeft { get; set; }
        public static bool autorotateToLandscapeRight { get; set; }
        public static ScreenOrientation orientation { get; set; }
        public static int sleepTimeout { get; set; }
        public static float brightness { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("Property GetResolution has been deprecated. Use resolutions instead (UnityUpgradable) -> resolutions", True)]
        public static Resolution[] GetResolution { get; }
        [Obsolete("Property showCursor has been deprecated. Use Cursor.visible instead (UnityUpgradable) -> UnityEngine.Cursor.visible", True)]
        [EditorBrowsable(Never)]
        public static bool showCursor { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("Use Cursor.lockState and Cursor.visible instead.", False)]
        public static bool lockCursor { get; set; }

        public static void SetResolution(int width, int height, FullScreenMode fullscreenMode, [UnityEngine.Internal.DefaultValue("0")] int preferredRefreshRate);
        public static void SetResolution(int width, int height, FullScreenMode fullscreenMode);
        public static void SetResolution(int width, int height, bool fullscreen, [UnityEngine.Internal.DefaultValue("0")] int preferredRefreshRate);
        public static void SetResolution(int width, int height, bool fullscreen);
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Graphics/GraphicsScriptBindings.h")]
    public struct RenderBuffer
    {
        [FreeFunction(Name = "RenderBufferScripting::GetNativeRenderBufferPtr", HasExplicitThis = True)]
        public IntPtr GetNativeRenderBufferPtr();
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeType("Runtime/GfxDevice/GfxDeviceTypes.h")]
    public enum ComputeBufferMode
    {
        Immutable = 0,
        Dynamic = 1,
        Circular = 2,
        StreamOut = 3,
        SubUpdates = 4
    }
}
using System;
using System.Collections.Generic;
using System.ComponentModel;
using UnityEngine.Bindings;
using UnityEngine.Internal;
using UnityEngine.Rendering;

namespace UnityEngine
{
    [NativeHeader("Runtime/Shaders/ComputeShader.h")]
    [NativeHeader("Runtime/Graphics/ColorGamut.h")]
    [NativeHeader("Runtime/Misc/PlayerSettings.h")]
    [NativeHeader("Runtime/Camera/LightProbeProxyVolume.h")]
    [NativeHeader("Runtime/Graphics/GraphicsScriptBindings.h")]
    [NativeHeader("Runtime/Graphics/CopyTexture.h")]
    public class Graphics
    {
        public Graphics();

        public static ColorGamut activeColorGamut { get; }
        [StaticAccessor("GetGfxDevice()", Dot)]
        public static GraphicsTier activeTier { get; set; }
        public static bool preserveFramebufferAlpha { get; }
        public static OpenGLESVersion minOpenGLESVersion { get; }
        public static RenderBuffer activeColorBuffer { get; }
        public static RenderBuffer activeDepthBuffer { get; }
        [EditorBrowsable(Never)]
        [Obsolete("Property deviceName has been deprecated. Use SystemInfo.graphicsDeviceName instead (UnityUpgradable) -> UnityEngine.SystemInfo.graphicsDeviceName", True)]
        public static string deviceName { get; }
        [EditorBrowsable(Never)]
        [Obsolete("Property deviceVendor has been deprecated. Use SystemInfo.graphicsDeviceVendor instead (UnityUpgradable) -> UnityEngine.SystemInfo.graphicsDeviceVendor", True)]
        public static string deviceVendor { get; }
        [Obsolete("Property deviceVersion has been deprecated. Use SystemInfo.graphicsDeviceVersion instead (UnityUpgradable) -> UnityEngine.SystemInfo.graphicsDeviceVersion", True)]
        [EditorBrowsable(Never)]
        public static string deviceVersion { get; }

        [StaticAccessor("GetGfxDevice()", Dot)]
        public static void ClearRandomWriteTargets();
        [NativeMethod(Name = "GraphicsScripting::ExecuteCommandBuffer", IsFreeFunction = True, ThrowsException = True)]
        public static void ExecuteCommandBuffer([NotNull("ArgumentNullException")] CommandBuffer buffer);
        [NativeMethod(Name = "GraphicsScripting::ExecuteCommandBufferAsync", IsFreeFunction = True, ThrowsException = True)]
        public static void ExecuteCommandBufferAsync([NotNull("ArgumentNullException")] CommandBuffer buffer, ComputeQueueType queueType);
        public static void SetRenderTarget(RenderTexture rt, [UnityEngine.Internal.DefaultValue("0")] int mipLevel, [UnityEngine.Internal.DefaultValue("CubemapFace.Unknown")] CubemapFace face, [UnityEngine.Internal.DefaultValue("0")] int depthSlice);
        public static void SetRenderTarget(RenderBuffer colorBuffer, RenderBuffer depthBuffer, [UnityEngine.Internal.DefaultValue("0")] int mipLevel, [UnityEngine.Internal.DefaultValue("CubemapFace.Unknown")] CubemapFace face, [UnityEngine.Internal.DefaultValue("0")] int depthSlice);
        public static void SetRenderTarget(RenderBuffer[] colorBuffers, RenderBuffer depthBuffer);
        public static void SetRenderTarget(RenderTargetSetup setup);
        public static void SetRandomWriteTarget(int index, RenderTexture uav);
        public static void SetRandomWriteTarget(int index, ComputeBuffer uav, [UnityEngine.Internal.DefaultValue("false")] bool preserveCounterValue);
        public static void SetRandomWriteTarget(int index, GraphicsBuffer uav, [UnityEngine.Internal.DefaultValue("false")] bool preserveCounterValue);
        public static void CopyTexture(Texture src, Texture dst);
        public static void CopyTexture(Texture src, int srcElement, Texture dst, int dstElement);
        public static void CopyTexture(Texture src, int srcElement, int srcMip, Texture dst, int dstElement, int dstMip);
        public static void CopyTexture(Texture src, int srcElement, int srcMip, int srcX, int srcY, int srcWidth, int srcHeight, Texture dst, int dstElement, int dstMip, int dstX, int dstY);
        public static bool ConvertTexture(Texture src, Texture dst);
        public static bool ConvertTexture(Texture src, int srcElement, Texture dst, int dstElement);
        public static GraphicsFence CreateAsyncGraphicsFence([UnityEngine.Internal.DefaultValue("SynchronisationStage.PixelProcessing")] SynchronisationStage stage);
        public static GraphicsFence CreateAsyncGraphicsFence();
        public static GraphicsFence CreateGraphicsFence(GraphicsFenceType fenceType, [UnityEngine.Internal.DefaultValue("SynchronisationStage.PixelProcessing")] SynchronisationStageFlags stage);
        public static void WaitOnAsyncGraphicsFence(GraphicsFence fence);
        public static void WaitOnAsyncGraphicsFence(GraphicsFence fence, [UnityEngine.Internal.DefaultValue("SynchronisationStage.PixelProcessing")] SynchronisationStage stage);
        public static void DrawTexture(Rect screenRect, Texture texture, Rect sourceRect, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Color color, [UnityEngine.Internal.DefaultValue("null")] Material mat, [UnityEngine.Internal.DefaultValue("-1")] int pass);
        public static void DrawTexture(Rect screenRect, Texture texture, Rect sourceRect, int leftBorder, int rightBorder, int topBorder, int bottomBorder, [UnityEngine.Internal.DefaultValue("null")] Material mat, [UnityEngine.Internal.DefaultValue("-1")] int pass);
        public static void DrawTexture(Rect screenRect, Texture texture, int leftBorder, int rightBorder, int topBorder, int bottomBorder, [UnityEngine.Internal.DefaultValue("null")] Material mat, [UnityEngine.Internal.DefaultValue("-1")] int pass);
        public static void DrawTexture(Rect screenRect, Texture texture, [UnityEngine.Internal.DefaultValue("null")] Material mat, [UnityEngine.Internal.DefaultValue("-1")] int pass);
        public static void DrawMeshNow(Mesh mesh, Vector3 position, Quaternion rotation, int materialIndex);
        public static void DrawMeshNow(Mesh mesh, Matrix4x4 matrix, int materialIndex);
        public static void DrawMeshNow(Mesh mesh, Vector3 position, Quaternion rotation);
        public static void DrawMeshNow(Mesh mesh, Matrix4x4 matrix);
        public static void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, [UnityEngine.Internal.DefaultValue("null")] Camera camera, [UnityEngine.Internal.DefaultValue("0")] int submeshIndex, [UnityEngine.Internal.DefaultValue("null")] MaterialPropertyBlock properties, [UnityEngine.Internal.DefaultValue("true")] bool castShadows, [UnityEngine.Internal.DefaultValue("true")] bool receiveShadows, [UnityEngine.Internal.DefaultValue("true")] bool useLightProbes);
        public static void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows, [UnityEngine.Internal.DefaultValue("true")] bool receiveShadows, [UnityEngine.Internal.DefaultValue("null")] Transform probeAnchor, [UnityEngine.Internal.DefaultValue("true")] bool useLightProbes);
        public static void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, [UnityEngine.Internal.DefaultValue("null")] Camera camera, [UnityEngine.Internal.DefaultValue("0")] int submeshIndex, [UnityEngine.Internal.DefaultValue("null")] MaterialPropertyBlock properties, [UnityEngine.Internal.DefaultValue("true")] bool castShadows, [UnityEngine.Internal.DefaultValue("true")] bool receiveShadows, [UnityEngine.Internal.DefaultValue("true")] bool useLightProbes);
        public static void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, Transform probeAnchor, LightProbeUsage lightProbeUsage, [UnityEngine.Internal.DefaultValue("null")] LightProbeProxyVolume lightProbeProxyVolume);
        public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, [UnityEngine.Internal.DefaultValue("matrices.Length")] int count, [UnityEngine.Internal.DefaultValue("null")] MaterialPropertyBlock properties, [UnityEngine.Internal.DefaultValue("ShadowCastingMode.On")] ShadowCastingMode castShadows, [UnityEngine.Internal.DefaultValue("true")] bool receiveShadows, [UnityEngine.Internal.DefaultValue("0")] int layer, [UnityEngine.Internal.DefaultValue("null")] Camera camera, [UnityEngine.Internal.DefaultValue("LightProbeUsage.BlendProbes")] LightProbeUsage lightProbeUsage, [UnityEngine.Internal.DefaultValue("null")] LightProbeProxyVolume lightProbeProxyVolume);
        public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, List<Matrix4x4> matrices, [UnityEngine.Internal.DefaultValue("null")] MaterialPropertyBlock properties, [UnityEngine.Internal.DefaultValue("ShadowCastingMode.On")] ShadowCastingMode castShadows, [UnityEngine.Internal.DefaultValue("true")] bool receiveShadows, [UnityEngine.Internal.DefaultValue("0")] int layer, [UnityEngine.Internal.DefaultValue("null")] Camera camera, [UnityEngine.Internal.DefaultValue("LightProbeUsage.BlendProbes")] LightProbeUsage lightProbeUsage, [UnityEngine.Internal.DefaultValue("null")] LightProbeProxyVolume lightProbeProxyVolume);
        public static void DrawMeshInstancedProcedural(Mesh mesh, int submeshIndex, Material material, Bounds bounds, int count, MaterialPropertyBlock properties = null, ShadowCastingMode castShadows = On, bool receiveShadows = True, int layer = 0, Camera camera = null, LightProbeUsage lightProbeUsage = BlendProbes, LightProbeProxyVolume lightProbeProxyVolume = null);
        public static void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, Bounds bounds, ComputeBuffer bufferWithArgs, [UnityEngine.Internal.DefaultValue("0")] int argsOffset, [UnityEngine.Internal.DefaultValue("null")] MaterialPropertyBlock properties, [UnityEngine.Internal.DefaultValue("ShadowCastingMode.On")] ShadowCastingMode castShadows, [UnityEngine.Internal.DefaultValue("true")] bool receiveShadows, [UnityEngine.Internal.DefaultValue("0")] int layer, [UnityEngine.Internal.DefaultValue("null")] Camera camera, [UnityEngine.Internal.DefaultValue("LightProbeUsage.BlendProbes")] LightProbeUsage lightProbeUsage, [UnityEngine.Internal.DefaultValue("null")] LightProbeProxyVolume lightProbeProxyVolume);
        public static void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, Bounds bounds, GraphicsBuffer bufferWithArgs, [UnityEngine.Internal.DefaultValue("0")] int argsOffset, [UnityEngine.Internal.DefaultValue("null")] MaterialPropertyBlock properties, [UnityEngine.Internal.DefaultValue("ShadowCastingMode.On")] ShadowCastingMode castShadows, [UnityEngine.Internal.DefaultValue("true")] bool receiveShadows, [UnityEngine.Internal.DefaultValue("0")] int layer, [UnityEngine.Internal.DefaultValue("null")] Camera camera, [UnityEngine.Internal.DefaultValue("LightProbeUsage.BlendProbes")] LightProbeUsage lightProbeUsage, [UnityEngine.Internal.DefaultValue("null")] LightProbeProxyVolume lightProbeProxyVolume);
        public static void DrawProceduralNow(MeshTopology topology, int vertexCount, int instanceCount = 1);
        public static void DrawProceduralNow(MeshTopology topology, GraphicsBuffer indexBuffer, int indexCount, int instanceCount = 1);
        public static void DrawProceduralIndirectNow(MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset = 0);
        public static void DrawProceduralIndirectNow(MeshTopology topology, GraphicsBuffer indexBuffer, ComputeBuffer bufferWithArgs, int argsOffset = 0);
        public static void DrawProceduralIndirectNow(MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset = 0);
        public static void DrawProceduralIndirectNow(MeshTopology topology, GraphicsBuffer indexBuffer, GraphicsBuffer bufferWithArgs, int argsOffset = 0);
        public static void DrawProcedural(Material material, Bounds bounds, MeshTopology topology, int vertexCount, int instanceCount = 1, Camera camera = null, MaterialPropertyBlock properties = null, ShadowCastingMode castShadows = On, bool receiveShadows = True, int layer = 0);
        public static void DrawProcedural(Material material, Bounds bounds, MeshTopology topology, GraphicsBuffer indexBuffer, int indexCount, int instanceCount = 1, Camera camera = null, MaterialPropertyBlock properties = null, ShadowCastingMode castShadows = On, bool receiveShadows = True, int layer = 0);
        public static void DrawProceduralIndirect(Material material, Bounds bounds, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset = 0, Camera camera = null, MaterialPropertyBlock properties = null, ShadowCastingMode castShadows = On, bool receiveShadows = True, int layer = 0);
        public static void DrawProceduralIndirect(Material material, Bounds bounds, MeshTopology topology, GraphicsBuffer indexBuffer, ComputeBuffer bufferWithArgs, int argsOffset = 0, Camera camera = null, MaterialPropertyBlock properties = null, ShadowCastingMode castShadows = On, bool receiveShadows = True, int layer = 0);
        public static void Blit(Texture source, RenderTexture dest);
        public static void Blit(Texture source, RenderTexture dest, int sourceDepthSlice, int destDepthSlice);
        public static void Blit(Texture source, RenderTexture dest, Vector2 scale, Vector2 offset);
        public static void Blit(Texture source, RenderTexture dest, Vector2 scale, Vector2 offset, int sourceDepthSlice, int destDepthSlice);
        public static void Blit(Texture source, RenderTexture dest, Material mat, [UnityEngine.Internal.DefaultValue("-1")] int pass);
        public static void Blit(Texture source, RenderTexture dest, Material mat, int pass, int destDepthSlice);
        public static void Blit(Texture source, RenderTexture dest, Material mat);
        public static void Blit(Texture source, Material mat, [UnityEngine.Internal.DefaultValue("-1")] int pass);
        public static void Blit(Texture source, Material mat, int pass, int destDepthSlice);
        public static void Blit(Texture source, Material mat);
        public static void BlitMultiTap(Texture source, RenderTexture dest, Material mat, params Vector2[] offsets);
        public static void BlitMultiTap(Texture source, RenderTexture dest, Material mat, int destDepthSlice, params Vector2[] offsets);
        [EditorBrowsable(Never)]
        [ExcludeFromDocs]
        [Obsolete("Method DrawMesh has been deprecated. Use Graphics.DrawMeshNow instead (UnityUpgradable) -> DrawMeshNow(*)", True)]
        public static void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation);
        [EditorBrowsable(Never)]
        [ExcludeFromDocs]
        [Obsolete("Method DrawMesh has been deprecated. Use Graphics.DrawMeshNow instead (UnityUpgradable) -> DrawMeshNow(*)", True)]
        public static void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, int materialIndex);
        [EditorBrowsable(Never)]
        [Obsolete("Method DrawMesh has been deprecated. Use Graphics.DrawMeshNow instead (UnityUpgradable) -> DrawMeshNow(*)", True)]
        [ExcludeFromDocs]
        public static void DrawMesh(Mesh mesh, Matrix4x4 matrix);
        [Obsolete("Method DrawMesh has been deprecated. Use Graphics.DrawMeshNow instead (UnityUpgradable) -> DrawMeshNow(*)", True)]
        [ExcludeFromDocs]
        [EditorBrowsable(Never)]
        public static void DrawMesh(Mesh mesh, Matrix4x4 matrix, int materialIndex);
        [ExcludeFromDocs]
        [Obsolete("Method DrawProcedural has been deprecated. Use Graphics.DrawProceduralNow instead. (UnityUpgradable) -> DrawProceduralNow(*)", True)]
        [EditorBrowsable(Never)]
        public static void DrawProcedural(MeshTopology topology, int vertexCount, int instanceCount = 1);
        [Obsolete("Method DrawProceduralIndirect has been deprecated. Use Graphics.DrawProceduralIndirectNow instead. (UnityUpgradable) -> DrawProceduralIndirectNow(*)", True)]
        [ExcludeFromDocs]
        [EditorBrowsable(Never)]
        public static void DrawProceduralIndirect(MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset = 0);
        [Obsolete("CreateGPUFence has been deprecated. Use CreateGraphicsFence instead (UnityUpgradable) -> CreateAsyncGraphicsFence(*)", True)]
        [EditorBrowsable(Never)]
        public static GPUFence CreateGPUFence([UnityEngine.Internal.DefaultValue("UnityEngine.Rendering.SynchronisationStage.PixelProcessing")] SynchronisationStage stage);
        [Obsolete("WaitOnGPUFence has been deprecated. Use WaitOnAsyncGraphicsFence instead (UnityUpgradable) -> WaitOnAsyncGraphicsFence(*)", True)]
        [EditorBrowsable(Never)]
        public static void WaitOnGPUFence(GPUFence fence, [UnityEngine.Internal.DefaultValue("UnityEngine.Rendering.SynchronisationStage.PixelProcessing")] SynchronisationStage stage);
        [Obsolete("CreateGPUFence has been deprecated. Use CreateGraphicsFence instead (UnityUpgradable) -> CreateAsyncGraphicsFence(*)", True)]
        [ExcludeFromDocs]
        [EditorBrowsable(Never)]
        public static GPUFence CreateGPUFence();
        [ExcludeFromDocs]
        [Obsolete("WaitOnGPUFence has been deprecated. Use WaitOnAsyncGraphicsFence instead (UnityUpgradable) -> WaitOnAsyncGraphicsFence(*)", True)]
        [EditorBrowsable(Never)]
        public static void WaitOnGPUFence(GPUFence fence);
        [ExcludeFromDocs]
        public static void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer);
        [ExcludeFromDocs]
        public static void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera);
        [ExcludeFromDocs]
        public static void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex);
        [ExcludeFromDocs]
        public static void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties);
        [ExcludeFromDocs]
        public static void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, bool castShadows);
        [ExcludeFromDocs]
        public static void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, bool castShadows, bool receiveShadows);
        [ExcludeFromDocs]
        public static void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows);
        [ExcludeFromDocs]
        public static void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows);
        [ExcludeFromDocs]
        public static void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, Transform probeAnchor);
        [ExcludeFromDocs]
        public static void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer);
        [ExcludeFromDocs]
        public static void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera);
        [ExcludeFromDocs]
        public static void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex);
        [ExcludeFromDocs]
        public static void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties);
        [ExcludeFromDocs]
        public static void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, bool castShadows);
        [ExcludeFromDocs]
        public static void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, bool castShadows, bool receiveShadows);
        [ExcludeFromDocs]
        public static void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows);
        [ExcludeFromDocs]
        public static void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows);
        [ExcludeFromDocs]
        public static void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, Transform probeAnchor);
        public static void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows, [UnityEngine.Internal.DefaultValue("true")] bool receiveShadows, [UnityEngine.Internal.DefaultValue("null")] Transform probeAnchor, [UnityEngine.Internal.DefaultValue("true")] bool useLightProbes);
        [ExcludeFromDocs]
        public static void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, Transform probeAnchor, LightProbeUsage lightProbeUsage);
        [ExcludeFromDocs]
        public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices);
        [ExcludeFromDocs]
        public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count);
        [ExcludeFromDocs]
        public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties);
        [ExcludeFromDocs]
        public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties, ShadowCastingMode castShadows);
        [ExcludeFromDocs]
        public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows);
        [ExcludeFromDocs]
        public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer);
        [ExcludeFromDocs]
        public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera);
        [ExcludeFromDocs]
        public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage);
        [ExcludeFromDocs]
        public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, List<Matrix4x4> matrices);
        [ExcludeFromDocs]
        public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, List<Matrix4x4> matrices, MaterialPropertyBlock properties);
        [ExcludeFromDocs]
        public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, List<Matrix4x4> matrices, MaterialPropertyBlock properties, ShadowCastingMode castShadows);
        [ExcludeFromDocs]
        public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, List<Matrix4x4> matrices, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows);
        [ExcludeFromDocs]
        public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, List<Matrix4x4> matrices, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer);
        [ExcludeFromDocs]
        public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, List<Matrix4x4> matrices, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera);
        [ExcludeFromDocs]
        public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, List<Matrix4x4> matrices, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage);
        [ExcludeFromDocs]
        public static void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, Bounds bounds, ComputeBuffer bufferWithArgs, int argsOffset = 0, MaterialPropertyBlock properties = null, ShadowCastingMode castShadows = On, bool receiveShadows = True, int layer = 0, Camera camera = null, LightProbeUsage lightProbeUsage = BlendProbes);
        [ExcludeFromDocs]
        public static void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, Bounds bounds, GraphicsBuffer bufferWithArgs, int argsOffset = 0, MaterialPropertyBlock properties = null, ShadowCastingMode castShadows = On, bool receiveShadows = True, int layer = 0, Camera camera = null, LightProbeUsage lightProbeUsage = BlendProbes);
        [ExcludeFromDocs]
        public static void DrawTexture(Rect screenRect, Texture texture, Rect sourceRect, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Color color, Material mat);
        [ExcludeFromDocs]
        public static void DrawTexture(Rect screenRect, Texture texture, Rect sourceRect, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Color color);
        [ExcludeFromDocs]
        public static void DrawTexture(Rect screenRect, Texture texture, Rect sourceRect, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Material mat);
        [ExcludeFromDocs]
        public static void DrawTexture(Rect screenRect, Texture texture, Rect sourceRect, int leftBorder, int rightBorder, int topBorder, int bottomBorder);
        [ExcludeFromDocs]
        public static void DrawTexture(Rect screenRect, Texture texture, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Material mat);
        [ExcludeFromDocs]
        public static void DrawTexture(Rect screenRect, Texture texture, int leftBorder, int rightBorder, int topBorder, int bottomBorder);
        [ExcludeFromDocs]
        public static void DrawTexture(Rect screenRect, Texture texture, Material mat);
        [ExcludeFromDocs]
        public static void DrawTexture(Rect screenRect, Texture texture);
        [ExcludeFromDocs]
        public static void SetRenderTarget(RenderTexture rt);
        [ExcludeFromDocs]
        public static void SetRenderTarget(RenderTexture rt, int mipLevel);
        [ExcludeFromDocs]
        public static void SetRenderTarget(RenderTexture rt, int mipLevel, CubemapFace face);
        [ExcludeFromDocs]
        public static void SetRenderTarget(RenderBuffer colorBuffer, RenderBuffer depthBuffer);
        [ExcludeFromDocs]
        public static void SetRenderTarget(RenderBuffer colorBuffer, RenderBuffer depthBuffer, int mipLevel);
        [ExcludeFromDocs]
        public static void SetRenderTarget(RenderBuffer colorBuffer, RenderBuffer depthBuffer, int mipLevel, CubemapFace face);
        [ExcludeFromDocs]
        public static void SetRandomWriteTarget(int index, ComputeBuffer uav);
        [ExcludeFromDocs]
        public static void SetRandomWriteTarget(int index, GraphicsBuffer uav);
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Internal;

namespace UnityEngine
{
    [NativeHeader("Runtime/Camera/CameraUtil.h")]
    [NativeHeader("Runtime/Camera/Camera.h")]
    [NativeHeader("Runtime/Graphics/GraphicsScriptBindings.h")]
    [StaticAccessor("GetGfxDevice()", Dot)]
    [NativeHeader("Runtime/GfxDevice/GfxDevice.h")]
    public sealed class GL
    {
        public const int TRIANGLES = 4;
        public const int TRIANGLE_STRIP = 5;
        public const int QUADS = 7;
        public const int LINES = 1;
        public const int LINE_STRIP = 2;

        public GL();

        public static bool wireframe { get; set; }
        public static bool sRGBWrite { get; set; }
        [NativeProperty("UserBackfaceMode")]
        public static bool invertCulling { get; set; }
        public static Matrix4x4 modelview { get; set; }

        [NativeName("ImmediateVertex")]
        public static void Vertex3(float x, float y, float z);
        public static void Vertex(Vector3 v);
        [NativeName("ImmediateTexCoordAll")]
        public static void TexCoord3(float x, float y, float z);
        public static void TexCoord(Vector3 v);
        public static void TexCoord2(float x, float y);
        [NativeName("ImmediateTexCoord")]
        public static void MultiTexCoord3(int unit, float x, float y, float z);
        public static void MultiTexCoord(int unit, Vector3 v);
        public static void MultiTexCoord2(int unit, float x, float y);
        public static void Color(Color c);
        public static void Flush();
        public static void RenderTargetBarrier();
        [NativeName("SetWorldMatrix")]
        public static void MultMatrix(Matrix4x4 m);
        [Obsolete("IssuePluginEvent(eventID) is deprecated. Use IssuePluginEvent(callback, eventID) instead.", False)]
        [NativeName("InsertCustomMarker")]
        public static void IssuePluginEvent(int eventID);
        [Obsolete("SetRevertBackfacing(revertBackFaces) is deprecated. Use invertCulling property instead.", False)]
        [NativeName("SetUserBackfaceMode")]
        public static void SetRevertBackfacing(bool revertBackFaces);
        [FreeFunction("GLPushMatrixScript")]
        public static void PushMatrix();
        [FreeFunction("GLPopMatrixScript")]
        public static void PopMatrix();
        [FreeFunction("GLLoadIdentityScript")]
        public static void LoadIdentity();
        [FreeFunction("GLLoadOrthoScript")]
        public static void LoadOrtho();
        [FreeFunction("GLLoadPixelMatrixScript")]
        public static void LoadPixelMatrix();
        [FreeFunction("GLLoadProjectionMatrixScript")]
        public static void LoadProjectionMatrix(Matrix4x4 mat);
        [FreeFunction("GLInvalidateState")]
        public static void InvalidateState();
        [FreeFunction("GLGetGPUProjectionMatrix")]
        public static Matrix4x4 GetGPUProjectionMatrix(Matrix4x4 proj, bool renderIntoTexture);
        public static void LoadPixelMatrix(float left, float right, float bottom, float top);
        public static void IssuePluginEvent(IntPtr callback, int eventID);
        [FreeFunction("GLBegin", ThrowsException = True)]
        public static void Begin(int mode);
        [FreeFunction("GLEnd")]
        public static void End();
        public static void Clear(bool clearDepth, bool clearColor, Color backgroundColor, [DefaultValue("1.0f")] float depth);
        public static void Clear(bool clearDepth, bool clearColor, Color backgroundColor);
        [FreeFunction("SetGLViewport")]
        public static void Viewport(Rect pixelRect);
        [FreeFunction("ClearWithSkybox")]
        public static void ClearWithSkybox(bool clearDepth, Camera camera);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [StaticAccessor("ScalableBufferManager::GetInstance()", Dot)]
    [NativeHeader("Runtime/GfxDevice/ScalableBufferManager.h")]
    public static class ScalableBufferManager
    {
        public static float widthScaleFactor { get; }
        public static float heightScaleFactor { get; }

        public static void ResizeBuffers(float widthScale, float heightScale);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/GfxDevice/FrameTiming.h")]
    public struct FrameTiming
    {
        [NativeName("m_CPUTimePresentCalled")]
        public ulong cpuTimePresentCalled;
        [NativeName("m_CPUFrameTime")]
        public double cpuFrameTime;
        [NativeName("m_CPUTimeFrameComplete")]
        public ulong cpuTimeFrameComplete;
        [NativeName("m_GPUFrameTime")]
        public double gpuFrameTime;
        [NativeName("m_HeightScale")]
        public float heightScale;
        [NativeName("m_WidthScale")]
        public float widthScale;
        [NativeName("m_SyncInterval")]
        public uint syncInterval;
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [StaticAccessor("GetUncheckedRealGfxDevice().GetFrameTimingManager()", Dot)]
    public static class FrameTimingManager
    {
        public static void CaptureFrameTimings();
        public static uint GetLatestTimings(uint numFrames, FrameTiming[] timings);
        public static float GetVSyncsPerSecond();
        public static ulong GetGpuTimerFrequency();
        public static ulong GetCpuTimerFrequency();
    }
}
using System;
using System.ComponentModel;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Runtime/Graphics/LightmapData.h")]
    [UsedByNativeCode]
    public sealed class LightmapData
    {
        public LightmapData();

        [Obsolete("Use lightmapColor property (UnityUpgradable) -> lightmapColor", False)]
        public Texture2D lightmapLight { get; set; }
        public Texture2D lightmapColor { get; set; }
        public Texture2D lightmapDir { get; set; }
        public Texture2D shadowMask { get; set; }
        [Obsolete("Property LightmapData.lightmap has been deprecated. Use LightmapData.lightmapColor instead (UnityUpgradable) -> lightmapColor", True)]
        [EditorBrowsable(Never)]
        public Texture2D lightmap { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("Property LightmapData.lightmapFar has been deprecated. Use LightmapData.lightmapColor instead (UnityUpgradable) -> lightmapColor", True)]
        public Texture2D lightmapFar { get; set; }
        [Obsolete("Property LightmapData.lightmapNear has been deprecated. Use LightmapData.lightmapDir instead (UnityUpgradable) -> lightmapDir", True)]
        [EditorBrowsable(Never)]
        public Texture2D lightmapNear { get; set; }
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [StaticAccessor("GetLightmapSettings()")]
    [NativeHeader("Runtime/Graphics/LightmapSettings.h")]
    public sealed class LightmapSettings : Object
    {
        public static LightmapData[] lightmaps { get; set; }
        public static LightmapsMode lightmapsMode { get; set; }
        public static LightProbes lightProbes { get; set; }
        [Obsolete("Use lightmapsMode instead.", False)]
        public static LightmapsModeLegacy lightmapsModeLegacy { get; set; }
        [Obsolete("Use QualitySettings.desiredColorSpace instead.", False)]
        public static ColorSpace bakedColorSpace { get; set; }
    }
}
using System;
using System.Collections.Generic;
using System.ComponentModel;
using UnityEngine.Bindings;
using UnityEngine.Rendering;

namespace UnityEngine
{
    [NativeHeader("Runtime/Export/Graphics/Graphics.bindings.h")]
    public sealed class LightProbes : Object
    {
        public Vector3[] positions { get; }
        public SphericalHarmonicsL2[] bakedProbes { get; set; }
        public int count { get; }
        public int cellCount { get; }
        [EditorBrowsable(Never)]
        [Obsolete("Use bakedProbes instead.", True)]
        public float[] coefficients { get; set; }

        public static event Action tetrahedralizationCompleted;
        public static event Action needsRetetrahedralization;

        [FreeFunction]
        public static void Tetrahedralize();
        [FreeFunction]
        public static void TetrahedralizeAsync();
        [FreeFunction]
        public static void GetInterpolatedProbe(Vector3 position, Renderer renderer, out SphericalHarmonicsL2 probe);
        public static void CalculateInterpolatedLightAndOcclusionProbes(Vector3[] positions, SphericalHarmonicsL2[] lightProbes, Vector4[] occlusionProbes);
        public static void CalculateInterpolatedLightAndOcclusionProbes(List<Vector3> positions, List<SphericalHarmonicsL2> lightProbes, List<Vector4> occlusionProbes);
        [Obsolete("Use GetInterpolatedProbe instead.", True)]
        [EditorBrowsable(Never)]
        public void GetInterpolatedLightProbe(Vector3 position, Renderer renderer, float[] coefficients);
    }
}
namespace UnityEngine
{
    public enum D3DHDRDisplayBitDepth
    {
        D3DHDRDisplayBitDepth10 = 0,
        D3DHDRDisplayBitDepth16 = 1
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Experimental.Rendering;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Runtime/GfxDevice/HDROutputSettings.h")]
    [UsedByNativeCode]
    public class HDROutputSettings
    {
        public static HDROutputSettings[] displays;

        public static HDROutputSettings main { get; }
        public bool active { get; }
        public bool available { get; }
        public bool automaticHDRTonemapping { get; set; }
        public ColorGamut displayColorGamut { get; }
        public RenderTextureFormat format { get; }
        public GraphicsFormat graphicsFormat { get; }
        public float paperWhiteNits { get; set; }
        public int maxFullFrameToneMapLuminance { get; }
        public int maxToneMapLuminance { get; }
        public int minToneMapLuminance { get; }
        public bool HDRModeChangeRequested { get; }

        public void RequestHDRModeChange(bool enabled);
        [Obsolete("SetPaperWhiteInNits is deprecated, please use paperWhiteNits instead.")]
        public static void SetPaperWhiteInNits(float paperWhite);
    }
}
using UnityEngine.Scripting;

namespace UnityEngine
{
    [RequiredByNativeCode]
    public struct Resolution
    {
        public int width { get; set; }
        public int height { get; set; }
        public int refreshRate { get; set; }

        public override string ToString();
    }
}
using UnityEngine.Rendering;

namespace UnityEngine
{
    public struct RenderTargetSetup
    {
        public RenderBuffer[] color;
        public RenderBuffer depth;
        public int mipLevel;
        public CubemapFace cubemapFace;
        public int depthSlice;
        public RenderBufferLoadAction[] colorLoad;
        public RenderBufferStoreAction[] colorStore;
        public RenderBufferLoadAction depthLoad;
        public RenderBufferStoreAction depthStore;

        public RenderTargetSetup(RenderBuffer[] color, RenderBuffer depth, int mip, CubemapFace face, RenderBufferLoadAction[] colorLoad, RenderBufferStoreAction[] colorStore, RenderBufferLoadAction depthLoad, RenderBufferStoreAction depthStore);
        public RenderTargetSetup(RenderBuffer color, RenderBuffer depth);
        public RenderTargetSetup(RenderBuffer color, RenderBuffer depth, int mipLevel);
        public RenderTargetSetup(RenderBuffer color, RenderBuffer depth, int mipLevel, CubemapFace face);
        public RenderTargetSetup(RenderBuffer color, RenderBuffer depth, int mipLevel, CubemapFace face, int depthSlice);
        public RenderTargetSetup(RenderBuffer[] color, RenderBuffer depth);
        public RenderTargetSetup(RenderBuffer[] color, RenderBuffer depth, int mipLevel);
        public RenderTargetSetup(RenderBuffer[] color, RenderBuffer depth, int mip, CubemapFace face);
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Internal;
using UnityEngine.Rendering;

namespace UnityEngine
{
    [NativeHeader("Runtime/Graphics/QualitySettings.h")]
    [NativeHeader("Runtime/Misc/PlayerSettings.h")]
    [StaticAccessor("GetQualitySettings()", Dot)]
    public sealed class QualitySettings : Object
    {
        [Obsolete("Use GetQualityLevel and SetQualityLevel", False)]
        public static QualityLevel currentLevel { get; set; }
        public static int pixelLightCount { get; set; }
        [NativeProperty("ShadowQuality")]
        public static ShadowQuality shadows { get; set; }
        public static ShadowProjection shadowProjection { get; set; }
        public static int shadowCascades { get; set; }
        public static float shadowDistance { get; set; }
        [NativeProperty("ShadowResolution")]
        public static ShadowResolution shadowResolution { get; set; }
        [NativeProperty("ShadowmaskMode")]
        public static ShadowmaskMode shadowmaskMode { get; set; }
        public static float shadowNearPlaneOffset { get; set; }
        public static float shadowCascade2Split { get; set; }
        public static Vector3 shadowCascade4Split { get; set; }
        [NativeProperty("LODBias")]
        public static float lodBias { get; set; }
        [NativeProperty("AnisotropicTextures")]
        public static AnisotropicFiltering anisotropicFiltering { get; set; }
        public static int masterTextureLimit { get; set; }
        public static int maximumLODLevel { get; set; }
        public static int particleRaycastBudget { get; set; }
        public static bool softParticles { get; set; }
        public static bool softVegetation { get; set; }
        public static int vSyncCount { get; set; }
        public static int antiAliasing { get; set; }
        public static int asyncUploadTimeSlice { get; set; }
        public static int asyncUploadBufferSize { get; set; }
        public static bool asyncUploadPersistentBuffer { get; set; }
        public static bool realtimeReflectionProbes { get; set; }
        public static bool billboardsFaceCameraPosition { get; set; }
        public static float resolutionScalingFixedDPIFactor { get; set; }
        public static RenderPipelineAsset renderPipeline { get; set; }
        [Obsolete("blendWeights is obsolete. Use skinWeights instead (UnityUpgradable) -> skinWeights", True)]
        public static BlendWeights blendWeights { get; set; }
        public static SkinWeights skinWeights { get; set; }
        public static bool streamingMipmapsActive { get; set; }
        public static float streamingMipmapsMemoryBudget { get; set; }
        public static int streamingMipmapsRenderersPerFrame { get; set; }
        public static int streamingMipmapsMaxLevelReduction { get; set; }
        public static bool streamingMipmapsAddAllCameras { get; set; }
        public static int streamingMipmapsMaxFileIORequests { get; set; }
        [StaticAccessor("QualitySettingsScripting", DoubleColon)]
        public static int maxQueuedFrames { get; set; }
        [NativeProperty("QualitySettingsNames")]
        public static string[] names { get; }
        public static ColorSpace desiredColorSpace { get; }
        public static ColorSpace activeColorSpace { get; }

        public static void IncreaseLevel([DefaultValue("false")] bool applyExpensiveChanges);
        public static void DecreaseLevel([DefaultValue("false")] bool applyExpensiveChanges);
        public static void SetQualityLevel(int index);
        public static void IncreaseLevel();
        public static void DecreaseLevel();
        public static RenderPipelineAsset GetRenderPipelineAssetAt(int index);
        [NativeName("GetCurrentIndex")]
        public static int GetQualityLevel();
        [NativeName("SetCurrentIndex")]
        public static void SetQualityLevel(int index, [DefaultValue("true")] bool applyExpensiveChanges);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Graphics/GraphicsScriptBindings.h")]
    public static class RendererExtensions
    {
        public static void UpdateGIMaterials(this Renderer renderer);
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    public sealed class ImageEffectTransformsToLDR : Attribute
    {
        public ImageEffectTransformsToLDR();
    }
}
using System;

namespace UnityEngine
{
    public sealed class ImageEffectAllowedInSceneView : Attribute
    {
        public ImageEffectAllowedInSceneView();
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    public sealed class ImageEffectOpaque : Attribute
    {
        public ImageEffectOpaque();
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    public sealed class ImageEffectAfterScale : Attribute
    {
        public ImageEffectAfterScale();
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    [AttributeUsage(Method)]
    public sealed class ImageEffectUsesCommandBuffer : Attribute
    {
        public ImageEffectUsesCommandBuffer();
    }
}
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Reflection;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine.Bindings;
using UnityEngine.Internal;
using UnityEngine.Rendering;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Runtime/Graphics/Mesh/MeshScriptBindings.h")]
    [RequiredByNativeCode]
    public sealed class Mesh : Object
    {
        [RequiredByNativeCode]
        public Mesh();

        [Obsolete("Property Mesh.uv1 has been deprecated. Use Mesh.uv2 instead (UnityUpgradable) -> uv2", True)]
        [EditorBrowsable(Never)]
        public Vector2[] uv1 { get; set; }
        public IndexFormat indexFormat { get; set; }
        public int vertexBufferCount { get; }
        public int blendShapeCount { get; }
        [NativeName("BindPosesFromScript")]
        public Matrix4x4[] bindposes { get; set; }
        public bool isReadable { get; }
        public int vertexCount { get; }
        public int subMeshCount { get; set; }
        public Bounds bounds { get; set; }
        public Vector3[] vertices { get; set; }
        public Vector3[] normals { get; set; }
        public Vector4[] tangents { get; set; }
        public Vector2[] uv { get; set; }
        public Vector2[] uv2 { get; set; }
        public Vector2[] uv3 { get; set; }
        public Vector2[] uv4 { get; set; }
        public Vector2[] uv5 { get; set; }
        public Vector2[] uv6 { get; set; }
        public Vector2[] uv7 { get; set; }
        public Vector2[] uv8 { get; set; }
        public Color[] colors { get; set; }
        public Color32[] colors32 { get; set; }
        public int vertexAttributeCount { get; }
        public int[] triangles { get; set; }
        public BoneWeight[] boneWeights { get; set; }

        [FreeFunction(Name = "MeshScripting::SetIndexBufferParams", HasExplicitThis = True)]
        public void SetIndexBufferParams(int indexCount, IndexFormat format);
        [FreeFunction(Name = "MeshScripting::GetVertexAttributeByIndex", HasExplicitThis = True, ThrowsException = True)]
        public VertexAttributeDescriptor GetVertexAttribute(int index);
        [FreeFunction(Name = "MeshScripting::HasChannel", HasExplicitThis = True)]
        public bool HasVertexAttribute(VertexAttribute attr);
        [FreeFunction(Name = "MeshScripting::GetChannelDimension", HasExplicitThis = True)]
        public int GetVertexAttributeDimension(VertexAttribute attr);
        [FreeFunction(Name = "MeshScripting::GetChannelFormat", HasExplicitThis = True)]
        public VertexAttributeFormat GetVertexAttributeFormat(VertexAttribute attr);
        [NativeThrows]
        [FreeFunction(Name = "MeshScripting::GetNativeVertexBufferPtr", HasExplicitThis = True)]
        public IntPtr GetNativeVertexBufferPtr(int index);
        [FreeFunction(Name = "MeshScripting::GetNativeIndexBufferPtr", HasExplicitThis = True)]
        public IntPtr GetNativeIndexBufferPtr();
        [FreeFunction(Name = "MeshScripting::ClearBlendShapes", HasExplicitThis = True)]
        public void ClearBlendShapes();
        [FreeFunction(Name = "MeshScripting::GetBlendShapeName", HasExplicitThis = True, ThrowsException = True)]
        public string GetBlendShapeName(int shapeIndex);
        [FreeFunction(Name = "MeshScripting::GetBlendShapeIndex", HasExplicitThis = True)]
        public int GetBlendShapeIndex(string blendShapeName);
        [FreeFunction(Name = "MeshScripting::GetBlendShapeFrameCount", HasExplicitThis = True, ThrowsException = True)]
        public int GetBlendShapeFrameCount(int shapeIndex);
        [FreeFunction(Name = "MeshScripting::GetBlendShapeFrameWeight", HasExplicitThis = True, ThrowsException = True)]
        public float GetBlendShapeFrameWeight(int shapeIndex, int frameIndex);
        [FreeFunction(Name = "GetBlendShapeFrameVerticesFromScript", HasExplicitThis = True, ThrowsException = True)]
        public void GetBlendShapeFrameVertices(int shapeIndex, int frameIndex, Vector3[] deltaVertices, Vector3[] deltaNormals, Vector3[] deltaTangents);
        [FreeFunction(Name = "AddBlendShapeFrameFromScript", HasExplicitThis = True, ThrowsException = True)]
        public void AddBlendShapeFrame(string shapeName, float frameWeight, Vector3[] deltaVertices, Vector3[] deltaNormals, Vector3[] deltaTangents);
        public void SetBoneWeights(NativeArray<byte> bonesPerVertex, NativeArray<BoneWeight1> weights);
        public NativeArray<BoneWeight1> GetAllBoneWeights();
        public NativeArray<byte> GetBonesPerVertex();
        [FreeFunction("MeshScripting::SetSubMesh", HasExplicitThis = True, ThrowsException = True)]
        public void SetSubMesh(int index, SubMeshDescriptor desc, MeshUpdateFlags flags = Default);
        [FreeFunction("MeshScripting::GetSubMesh", HasExplicitThis = True, ThrowsException = True)]
        public SubMeshDescriptor GetSubMesh(int index);
        [NativeMethod("MarkModified")]
        public void MarkModified();
        [NativeMethod("GetMeshMetric")]
        public float GetUVDistributionMetric(int uvSetIndex);
        public void GetVertices(List<Vector3> vertices);
        public void SetVertices(List<Vector3> inVertices);
        [ExcludeFromDocs]
        public void SetVertices(List<Vector3> inVertices, int start, int length);
        public void SetVertices(List<Vector3> inVertices, int start, int length, [UnityEngine.Internal.DefaultValue("MeshUpdateFlags.Default")] MeshUpdateFlags flags);
        public void SetVertices(Vector3[] inVertices);
        [ExcludeFromDocs]
        public void SetVertices(Vector3[] inVertices, int start, int length);
        public void SetVertices(Vector3[] inVertices, int start, int length, [UnityEngine.Internal.DefaultValue("MeshUpdateFlags.Default")] MeshUpdateFlags flags);
        public void SetVertices<T>(NativeArray<T> inVertices) where T : struct;
        [ExcludeFromDocs]
        public void SetVertices<T>(NativeArray<T> inVertices, int start, int length) where T : struct;
        public void SetVertices<T>(NativeArray<T> inVertices, int start, int length, [UnityEngine.Internal.DefaultValue("MeshUpdateFlags.Default")] MeshUpdateFlags flags) where T : struct;
        public void GetNormals(List<Vector3> normals);
        public void SetNormals(List<Vector3> inNormals);
        [ExcludeFromDocs]
        public void SetNormals(List<Vector3> inNormals, int start, int length);
        public void SetNormals(List<Vector3> inNormals, int start, int length, [UnityEngine.Internal.DefaultValue("MeshUpdateFlags.Default")] MeshUpdateFlags flags);
        public void SetNormals(Vector3[] inNormals);
        [ExcludeFromDocs]
        public void SetNormals(Vector3[] inNormals, int start, int length);
        public void SetNormals(Vector3[] inNormals, int start, int length, [UnityEngine.Internal.DefaultValue("MeshUpdateFlags.Default")] MeshUpdateFlags flags);
        public void SetNormals<T>(NativeArray<T> inNormals) where T : struct;
        [ExcludeFromDocs]
        public void SetNormals<T>(NativeArray<T> inNormals, int start, int length) where T : struct;
        public void SetNormals<T>(NativeArray<T> inNormals, int start, int length, [UnityEngine.Internal.DefaultValue("MeshUpdateFlags.Default")] MeshUpdateFlags flags) where T : struct;
        public void GetTangents(List<Vector4> tangents);
        public void SetTangents(List<Vector4> inTangents);
        [ExcludeFromDocs]
        public void SetTangents(List<Vector4> inTangents, int start, int length);
        public void SetTangents(List<Vector4> inTangents, int start, int length, [UnityEngine.Internal.DefaultValue("MeshUpdateFlags.Default")] MeshUpdateFlags flags);
        public void SetTangents(Vector4[] inTangents);
        [ExcludeFromDocs]
        public void SetTangents(Vector4[] inTangents, int start, int length);
        public void SetTangents(Vector4[] inTangents, int start, int length, [UnityEngine.Internal.DefaultValue("MeshUpdateFlags.Default")] MeshUpdateFlags flags);
        public void SetTangents<T>(NativeArray<T> inTangents) where T : struct;
        [ExcludeFromDocs]
        public void SetTangents<T>(NativeArray<T> inTangents, int start, int length) where T : struct;
        public void SetTangents<T>(NativeArray<T> inTangents, int start, int length, [UnityEngine.Internal.DefaultValue("MeshUpdateFlags.Default")] MeshUpdateFlags flags) where T : struct;
        public void GetColors(List<Color> colors);
        public void SetColors(List<Color> inColors);
        [ExcludeFromDocs]
        public void SetColors(List<Color> inColors, int start, int length);
        public void SetColors(List<Color> inColors, int start, int length, [UnityEngine.Internal.DefaultValue("MeshUpdateFlags.Default")] MeshUpdateFlags flags);
        public void SetColors(Color[] inColors);
        [ExcludeFromDocs]
        public void SetColors(Color[] inColors, int start, int length);
        public void SetColors(Color[] inColors, int start, int length, [UnityEngine.Internal.DefaultValue("MeshUpdateFlags.Default")] MeshUpdateFlags flags);
        public void GetColors(List<Color32> colors);
        public void SetColors(List<Color32> inColors);
        [ExcludeFromDocs]
        public void SetColors(List<Color32> inColors, int start, int length);
        public void SetColors(List<Color32> inColors, int start, int length, [UnityEngine.Internal.DefaultValue("MeshUpdateFlags.Default")] MeshUpdateFlags flags);
        public void SetColors(Color32[] inColors);
        [ExcludeFromDocs]
        public void SetColors(Color32[] inColors, int start, int length);
        public void SetColors(Color32[] inColors, int start, int length, [UnityEngine.Internal.DefaultValue("MeshUpdateFlags.Default")] MeshUpdateFlags flags);
        public void SetColors<T>(NativeArray<T> inColors) where T : struct;
        [ExcludeFromDocs]
        public void SetColors<T>(NativeArray<T> inColors, int start, int length) where T : struct;
        public void SetColors<T>(NativeArray<T> inColors, int start, int length, [UnityEngine.Internal.DefaultValue("MeshUpdateFlags.Default")] MeshUpdateFlags flags) where T : struct;
        public void SetUVs(int channel, List<Vector2> uvs);
        public void SetUVs(int channel, List<Vector3> uvs);
        public void SetUVs(int channel, List<Vector4> uvs);
        [ExcludeFromDocs]
        public void SetUVs(int channel, List<Vector2> uvs, int start, int length);
        public void SetUVs(int channel, List<Vector2> uvs, int start, int length, [UnityEngine.Internal.DefaultValue("MeshUpdateFlags.Default")] MeshUpdateFlags flags);
        [ExcludeFromDocs]
        public void SetUVs(int channel, List<Vector3> uvs, int start, int length);
        public void SetUVs(int channel, List<Vector3> uvs, int start, int length, [UnityEngine.Internal.DefaultValue("MeshUpdateFlags.Default")] MeshUpdateFlags flags);
        [ExcludeFromDocs]
        public void SetUVs(int channel, List<Vector4> uvs, int start, int length);
        public void SetUVs(int channel, List<Vector4> uvs, int start, int length, [UnityEngine.Internal.DefaultValue("MeshUpdateFlags.Default")] MeshUpdateFlags flags);
        public void SetUVs(int channel, Vector2[] uvs);
        public void SetUVs(int channel, Vector3[] uvs);
        public void SetUVs(int channel, Vector4[] uvs);
        [ExcludeFromDocs]
        public void SetUVs(int channel, Vector2[] uvs, int start, int length);
        public void SetUVs(int channel, Vector2[] uvs, int start, int length, [UnityEngine.Internal.DefaultValue("MeshUpdateFlags.Default")] MeshUpdateFlags flags);
        [ExcludeFromDocs]
        public void SetUVs(int channel, Vector3[] uvs, int start, int length);
        public void SetUVs(int channel, Vector3[] uvs, int start, int length, [UnityEngine.Internal.DefaultValue("MeshUpdateFlags.Default")] MeshUpdateFlags flags);
        [ExcludeFromDocs]
        public void SetUVs(int channel, Vector4[] uvs, int start, int length);
        public void SetUVs(int channel, Vector4[] uvs, int start, int length, [UnityEngine.Internal.DefaultValue("MeshUpdateFlags.Default")] MeshUpdateFlags flags);
        public void SetUVs<T>(int channel, NativeArray<T> uvs) where T : struct;
        [ExcludeFromDocs]
        public void SetUVs<T>(int channel, NativeArray<T> uvs, int start, int length) where T : struct;
        public void SetUVs<T>(int channel, NativeArray<T> uvs, int start, int length, [UnityEngine.Internal.DefaultValue("MeshUpdateFlags.Default")] MeshUpdateFlags flags) where T : struct;
        public void GetUVs(int channel, List<Vector2> uvs);
        public void GetUVs(int channel, List<Vector3> uvs);
        public void GetUVs(int channel, List<Vector4> uvs);
        public VertexAttributeDescriptor[] GetVertexAttributes();
        public int GetVertexAttributes(VertexAttributeDescriptor[] attributes);
        public int GetVertexAttributes(List<VertexAttributeDescriptor> attributes);
        public void SetVertexBufferParams(int vertexCount, params VertexAttributeDescriptor[] attributes);
        public void SetVertexBufferParams(int vertexCount, NativeArray<VertexAttributeDescriptor> attributes);
        public void SetVertexBufferData<T>(NativeArray<T> data, int dataStart, int meshBufferStart, int count, int stream = 0, MeshUpdateFlags flags = Default) where T : struct;
        public void SetVertexBufferData<T>(T[] data, int dataStart, int meshBufferStart, int count, int stream = 0, MeshUpdateFlags flags = Default) where T : struct;
        public void SetVertexBufferData<T>(List<T> data, int dataStart, int meshBufferStart, int count, int stream = 0, MeshUpdateFlags flags = Default) where T : struct;
        public static MeshDataArray AcquireReadOnlyMeshData(Mesh mesh);
        public static MeshDataArray AcquireReadOnlyMeshData(Mesh[] meshes);
        public static MeshDataArray AcquireReadOnlyMeshData(List<Mesh> meshes);
        public static MeshDataArray AllocateWritableMeshData(int meshCount);
        public static void ApplyAndDisposeWritableMeshData(MeshDataArray data, Mesh mesh, MeshUpdateFlags flags = Default);
        public static void ApplyAndDisposeWritableMeshData(MeshDataArray data, Mesh[] meshes, MeshUpdateFlags flags = Default);
        public static void ApplyAndDisposeWritableMeshData(MeshDataArray data, List<Mesh> meshes, MeshUpdateFlags flags = Default);
        public int[] GetTriangles(int submesh);
        public int[] GetTriangles(int submesh, [UnityEngine.Internal.DefaultValue("true")] bool applyBaseVertex);
        public void GetTriangles(List<int> triangles, int submesh);
        public void GetTriangles(List<int> triangles, int submesh, [UnityEngine.Internal.DefaultValue("true")] bool applyBaseVertex);
        public void GetTriangles(List<ushort> triangles, int submesh, bool applyBaseVertex = True);
        [ExcludeFromDocs]
        public int[] GetIndices(int submesh);
        public int[] GetIndices(int submesh, [UnityEngine.Internal.DefaultValue("true")] bool applyBaseVertex);
        [ExcludeFromDocs]
        public void GetIndices(List<int> indices, int submesh);
        public void GetIndices(List<int> indices, int submesh, [UnityEngine.Internal.DefaultValue("true")] bool applyBaseVertex);
        public void GetIndices(List<ushort> indices, int submesh, bool applyBaseVertex = True);
        public void SetIndexBufferData<T>(NativeArray<T> data, int dataStart, int meshBufferStart, int count, MeshUpdateFlags flags = Default) where T : struct;
        public void SetIndexBufferData<T>(T[] data, int dataStart, int meshBufferStart, int count, MeshUpdateFlags flags = Default) where T : struct;
        public void SetIndexBufferData<T>(List<T> data, int dataStart, int meshBufferStart, int count, MeshUpdateFlags flags = Default) where T : struct;
        public uint GetIndexStart(int submesh);
        public uint GetIndexCount(int submesh);
        public uint GetBaseVertex(int submesh);
        [ExcludeFromDocs]
        public void SetTriangles(int[] triangles, int submesh);
        [ExcludeFromDocs]
        public void SetTriangles(int[] triangles, int submesh, bool calculateBounds);
        public void SetTriangles(int[] triangles, int submesh, [UnityEngine.Internal.DefaultValue("true")] bool calculateBounds, [UnityEngine.Internal.DefaultValue("0")] int baseVertex);
        public void SetTriangles(int[] triangles, int trianglesStart, int trianglesLength, int submesh, bool calculateBounds = True, int baseVertex = 0);
        public void SetTriangles(ushort[] triangles, int submesh, bool calculateBounds = True, int baseVertex = 0);
        public void SetTriangles(ushort[] triangles, int trianglesStart, int trianglesLength, int submesh, bool calculateBounds = True, int baseVertex = 0);
        [ExcludeFromDocs]
        public void SetTriangles(List<int> triangles, int submesh);
        [ExcludeFromDocs]
        public void SetTriangles(List<int> triangles, int submesh, bool calculateBounds);
        public void SetTriangles(List<int> triangles, int submesh, [UnityEngine.Internal.DefaultValue("true")] bool calculateBounds, [UnityEngine.Internal.DefaultValue("0")] int baseVertex);
        public void SetTriangles(List<int> triangles, int trianglesStart, int trianglesLength, int submesh, bool calculateBounds = True, int baseVertex = 0);
        public void SetTriangles(List<ushort> triangles, int submesh, bool calculateBounds = True, int baseVertex = 0);
        public void SetTriangles(List<ushort> triangles, int trianglesStart, int trianglesLength, int submesh, bool calculateBounds = True, int baseVertex = 0);
        [ExcludeFromDocs]
        public void SetIndices(int[] indices, MeshTopology topology, int submesh);
        [ExcludeFromDocs]
        public void SetIndices(int[] indices, MeshTopology topology, int submesh, bool calculateBounds);
        public void SetIndices(int[] indices, MeshTopology topology, int submesh, [UnityEngine.Internal.DefaultValue("true")] bool calculateBounds, [UnityEngine.Internal.DefaultValue("0")] int baseVertex);
        public void SetIndices(int[] indices, int indicesStart, int indicesLength, MeshTopology topology, int submesh, bool calculateBounds = True, int baseVertex = 0);
        public void SetIndices(ushort[] indices, MeshTopology topology, int submesh, bool calculateBounds = True, int baseVertex = 0);
        public void SetIndices(ushort[] indices, int indicesStart, int indicesLength, MeshTopology topology, int submesh, bool calculateBounds = True, int baseVertex = 0);
        public void SetIndices<T>(NativeArray<T> indices, MeshTopology topology, int submesh, bool calculateBounds = True, int baseVertex = 0) where T : struct;
        public void SetIndices<T>(NativeArray<T> indices, int indicesStart, int indicesLength, MeshTopology topology, int submesh, bool calculateBounds = True, int baseVertex = 0) where T : struct;
        public void SetIndices(List<int> indices, MeshTopology topology, int submesh, bool calculateBounds = True, int baseVertex = 0);
        public void SetIndices(List<int> indices, int indicesStart, int indicesLength, MeshTopology topology, int submesh, bool calculateBounds = True, int baseVertex = 0);
        public void SetIndices(List<ushort> indices, MeshTopology topology, int submesh, bool calculateBounds = True, int baseVertex = 0);
        public void SetIndices(List<ushort> indices, int indicesStart, int indicesLength, MeshTopology topology, int submesh, bool calculateBounds = True, int baseVertex = 0);
        public void SetSubMeshes(SubMeshDescriptor[] desc, int start, int count, MeshUpdateFlags flags = Default);
        public void SetSubMeshes(SubMeshDescriptor[] desc, MeshUpdateFlags flags = Default);
        public void SetSubMeshes(List<SubMeshDescriptor> desc, int start, int count, MeshUpdateFlags flags = Default);
        public void SetSubMeshes(List<SubMeshDescriptor> desc, MeshUpdateFlags flags = Default);
        public void SetSubMeshes<T>(NativeArray<T> desc, int start, int count, MeshUpdateFlags flags = Default) where T : struct;
        public void SetSubMeshes<T>(NativeArray<T> desc, MeshUpdateFlags flags = Default) where T : struct;
        public void GetBindposes(List<Matrix4x4> bindposes);
        public void GetBoneWeights(List<BoneWeight> boneWeights);
        public void Clear([UnityEngine.Internal.DefaultValue("true")] bool keepVertexLayout);
        [ExcludeFromDocs]
        public void Clear();
        [ExcludeFromDocs]
        public void RecalculateBounds();
        [ExcludeFromDocs]
        public void RecalculateNormals();
        [ExcludeFromDocs]
        public void RecalculateTangents();
        public void RecalculateBounds([UnityEngine.Internal.DefaultValue("MeshUpdateFlags.Default")] MeshUpdateFlags flags);
        public void RecalculateNormals([UnityEngine.Internal.DefaultValue("MeshUpdateFlags.Default")] MeshUpdateFlags flags);
        public void RecalculateTangents([UnityEngine.Internal.DefaultValue("MeshUpdateFlags.Default")] MeshUpdateFlags flags);
        public void RecalculateUVDistributionMetric(int uvSetIndex, float uvAreaThreshold = 1E-09F);
        public void RecalculateUVDistributionMetrics(float uvAreaThreshold = 1E-09F);
        public void MarkDynamic();
        public void UploadMeshData(bool markNoLongerReadable);
        public void Optimize();
        public void OptimizeIndexBuffers();
        public void OptimizeReorderVertexBuffer();
        public MeshTopology GetTopology(int submesh);
        public void CombineMeshes(CombineInstance[] combine, [UnityEngine.Internal.DefaultValue("true")] bool mergeSubMeshes, [UnityEngine.Internal.DefaultValue("true")] bool useMatrices, [UnityEngine.Internal.DefaultValue("false")] bool hasLightmapData);
        [ExcludeFromDocs]
        public void CombineMeshes(CombineInstance[] combine, bool mergeSubMeshes, bool useMatrices);
        [ExcludeFromDocs]
        public void CombineMeshes(CombineInstance[] combine, bool mergeSubMeshes);
        [ExcludeFromDocs]
        public void CombineMeshes(CombineInstance[] combine);

        [StaticAccessor("MeshDataBindings", DoubleColon)]
        [NativeHeader("Runtime/Graphics/Mesh/MeshScriptBindings.h")]
        public struct MeshData
        {
            public int vertexCount { get; }
            public int vertexBufferCount { get; }
            public IndexFormat indexFormat { get; }
            public int subMeshCount { get; set; }

            public bool HasVertexAttribute(VertexAttribute attr);
            public int GetVertexAttributeDimension(VertexAttribute attr);
            public VertexAttributeFormat GetVertexAttributeFormat(VertexAttribute attr);
            public void GetVertices(NativeArray<Vector3> outVertices);
            public void GetNormals(NativeArray<Vector3> outNormals);
            public void GetTangents(NativeArray<Vector4> outTangents);
            public void GetColors(NativeArray<Color> outColors);
            public void GetColors(NativeArray<Color32> outColors);
            public void GetUVs(int channel, NativeArray<Vector2> outUVs);
            public void GetUVs(int channel, NativeArray<Vector3> outUVs);
            public void GetUVs(int channel, NativeArray<Vector4> outUVs);
            public NativeArray<T> GetVertexData<T>([UnityEngine.Internal.DefaultValue("0")] int stream = 0) where T : struct;
            public void SetVertexBufferParams(int vertexCount, params VertexAttributeDescriptor[] attributes);
            public void SetVertexBufferParams(int vertexCount, NativeArray<VertexAttributeDescriptor> attributes);
            public void SetIndexBufferParams(int indexCount, IndexFormat format);
            public void GetIndices(NativeArray<ushort> outIndices, int submesh, [UnityEngine.Internal.DefaultValue("true")] bool applyBaseVertex = True);
            public void GetIndices(NativeArray<int> outIndices, int submesh, [UnityEngine.Internal.DefaultValue("true")] bool applyBaseVertex = True);
            public NativeArray<T> GetIndexData<T>() where T : struct;
            public SubMeshDescriptor GetSubMesh(int index);
            public void SetSubMesh(int index, SubMeshDescriptor desc, MeshUpdateFlags flags = Default);
        }
        [NativeContainer]
        [StaticAccessor("MeshDataArrayBindings", DoubleColon)]
        [DefaultMember("Item")]
        [NativeContainerSupportsMinMaxWriteRestriction]
        public struct MeshDataArray : IDisposable
        {
            public MeshData this[int index] { get; }
            public int Length { get; }

            public void Dispose();
        }
    }
}
using System;
using System.Collections.Generic;
using System.ComponentModel;
using UnityEngine.Bindings;
using UnityEngine.Experimental.Rendering;
using UnityEngine.Rendering;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Runtime/Graphics/Renderer.h")]
    [NativeHeader("Runtime/Graphics/GraphicsScriptBindings.h")]
    [RequireComponent(typeof(Transform))]
    [UsedByNativeCode]
    public class Renderer : Component
    {
        public Renderer();

        [EditorBrowsable(Never)]
        [Obsolete("Property lightmapTilingOffset has been deprecated. Use lightmapScaleOffset (UnityUpgradable) -> lightmapScaleOffset", True)]
        public Vector4 lightmapTilingOffset { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("Use probeAnchor instead (UnityUpgradable) -> probeAnchor", True)]
        public Transform lightProbeAnchor { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("Use shadowCastingMode instead.", False)]
        public bool castShadows { get; set; }
        [Obsolete("Use motionVectorGenerationMode instead.", False)]
        public bool motionVectors { get; set; }
        [Obsolete("Use lightProbeUsage instead.", False)]
        public bool useLightProbes { get; set; }
        public Bounds bounds { get; }
        public bool enabled { get; set; }
        public bool isVisible { get; }
        public ShadowCastingMode shadowCastingMode { get; set; }
        public bool receiveShadows { get; set; }
        public bool forceRenderingOff { get; set; }
        public MotionVectorGenerationMode motionVectorGenerationMode { get; set; }
        public LightProbeUsage lightProbeUsage { get; set; }
        public ReflectionProbeUsage reflectionProbeUsage { get; set; }
        public uint renderingLayerMask { get; set; }
        public int rendererPriority { get; set; }
        public RayTracingMode rayTracingMode { get; set; }
        public string sortingLayerName { get; set; }
        public int sortingLayerID { get; set; }
        public int sortingOrder { get; set; }
        [NativeProperty("IsDynamicOccludee")]
        public bool allowOcclusionWhenDynamic { get; set; }
        public bool isPartOfStaticBatch { get; }
        public Matrix4x4 worldToLocalMatrix { get; }
        public Matrix4x4 localToWorldMatrix { get; }
        public GameObject lightProbeProxyVolumeOverride { get; set; }
        public Transform probeAnchor { get; set; }
        public int lightmapIndex { get; set; }
        public int realtimeLightmapIndex { get; set; }
        public Vector4 lightmapScaleOffset { get; set; }
        public Vector4 realtimeLightmapScaleOffset { get; set; }
        public Material[] materials { get; set; }
        public Material material { get; set; }
        public Material sharedMaterial { get; set; }
        public Material[] sharedMaterials { get; set; }

        [FreeFunction(Name = "RendererScripting::HasPropertyBlock", HasExplicitThis = True)]
        public bool HasPropertyBlock();
        public void SetPropertyBlock(MaterialPropertyBlock properties);
        public void SetPropertyBlock(MaterialPropertyBlock properties, int materialIndex);
        public void GetPropertyBlock(MaterialPropertyBlock properties);
        public void GetPropertyBlock(MaterialPropertyBlock properties, int materialIndex);
        public void GetMaterials(List<Material> m);
        public void GetSharedMaterials(List<Material> m);
        public void GetClosestReflectionProbes(List<ReflectionProbeBlendInfo> result);
    }
}
using System;
using System.ComponentModel;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Camera/Projector.h")]
    public sealed class Projector : Behaviour
    {
        public Projector();

        [Obsolete("Property isOrthoGraphic has been deprecated. Use orthographic instead (UnityUpgradable) -> orthographic", True)]
        [EditorBrowsable(Never)]
        public bool isOrthoGraphic { get; set; }
        [Obsolete("Property orthoGraphicSize has been deprecated. Use orthographicSize instead (UnityUpgradable) -> orthographicSize", True)]
        [EditorBrowsable(Never)]
        public float orthoGraphicSize { get; set; }
        public float nearClipPlane { get; set; }
        public float farClipPlane { get; set; }
        public float fieldOfView { get; set; }
        public float aspectRatio { get; set; }
        public bool orthographic { get; set; }
        public float orthographicSize { get; set; }
        public int ignoreLayers { get; set; }
        public Material material { get; set; }
    }
}
using System;
using System.Collections.Generic;
using System.ComponentModel;
using UnityEngine.Bindings;
using UnityEngine.Rendering;

namespace UnityEngine
{
    [NativeHeader("Runtime/Graphics/ShaderScriptBindings.h")]
    [NativeHeader("Runtime/Misc/ResourceManager.h")]
    [NativeHeader("Runtime/Shaders/GpuPrograms/ShaderVariantCollection.h")]
    [NativeHeader("Runtime/Shaders/ComputeShader.h")]
    [NativeHeader("Runtime/Shaders/Shader.h")]
    [NativeHeader("Runtime/Graphics/ShaderScriptBindings.h")]
    [NativeHeader("Runtime/Shaders/ShaderNameRegistry.h")]
    public sealed class Shader : Object
    {
        [Obsolete("Use Graphics.activeTier instead (UnityUpgradable) -> UnityEngine.Graphics.activeTier", False)]
        public static ShaderHardwareTier globalShaderHardwareTier { get; set; }
        [NativeProperty("MaximumShaderLOD")]
        public int maximumLOD { get; set; }
        [NativeProperty("GlobalMaximumShaderLOD")]
        public static int globalMaximumLOD { get; set; }
        public bool isSupported { get; }
        public static string globalRenderPipeline { get; set; }
        public int renderQueue { get; }
        public int passCount { get; }

        [Obsolete("SetGlobalTexGenMode is not supported anymore. Use programmable shaders to achieve the same effect.", True)]
        [EditorBrowsable(Never)]
        public static void SetGlobalTexGenMode(string propertyName, TexGenMode mode);
        [Obsolete("SetGlobalTextureMatrixName is not supported anymore. Use programmable shaders to achieve the same effect.", True)]
        [EditorBrowsable(Never)]
        public static void SetGlobalTextureMatrixName(string propertyName, string matrixName);
        public static Shader Find(string name);
        [FreeFunction("ShaderScripting::EnableKeyword")]
        public static void EnableKeyword(string keyword);
        [FreeFunction("ShaderScripting::DisableKeyword")]
        public static void DisableKeyword(string keyword);
        [FreeFunction("ShaderScripting::IsKeywordEnabled")]
        public static bool IsKeywordEnabled(string keyword);
        [FreeFunction]
        public static void WarmupAllShaders();
        [FreeFunction(Name = "ShaderScripting::PropertyToID", IsThreadSafe = True)]
        public static int PropertyToID(string name);
        public Shader GetDependency(string name);
        public ShaderTagId FindPassTagValue(int passIndex, ShaderTagId tagName);
        public static void SetGlobalFloat(string name, float value);
        public static void SetGlobalFloat(int nameID, float value);
        public static void SetGlobalInt(string name, int value);
        public static void SetGlobalInt(int nameID, int value);
        public static void SetGlobalVector(string name, Vector4 value);
        public static void SetGlobalVector(int nameID, Vector4 value);
        public static void SetGlobalColor(string name, Color value);
        public static void SetGlobalColor(int nameID, Color value);
        public static void SetGlobalMatrix(string name, Matrix4x4 value);
        public static void SetGlobalMatrix(int nameID, Matrix4x4 value);
        public static void SetGlobalTexture(string name, Texture value);
        public static void SetGlobalTexture(int nameID, Texture value);
        public static void SetGlobalTexture(string name, RenderTexture value, RenderTextureSubElement element);
        public static void SetGlobalTexture(int nameID, RenderTexture value, RenderTextureSubElement element);
        public static void SetGlobalBuffer(string name, ComputeBuffer value);
        public static void SetGlobalBuffer(int nameID, ComputeBuffer value);
        public static void SetGlobalBuffer(string name, GraphicsBuffer value);
        public static void SetGlobalBuffer(int nameID, GraphicsBuffer value);
        public static void SetGlobalConstantBuffer(string name, ComputeBuffer value, int offset, int size);
        public static void SetGlobalConstantBuffer(int nameID, ComputeBuffer value, int offset, int size);
        public static void SetGlobalConstantBuffer(string name, GraphicsBuffer value, int offset, int size);
        public static void SetGlobalConstantBuffer(int nameID, GraphicsBuffer value, int offset, int size);
        public static void SetGlobalFloatArray(string name, List<float> values);
        public static void SetGlobalFloatArray(int nameID, List<float> values);
        public static void SetGlobalFloatArray(string name, float[] values);
        public static void SetGlobalFloatArray(int nameID, float[] values);
        public static void SetGlobalVectorArray(string name, List<Vector4> values);
        public static void SetGlobalVectorArray(int nameID, List<Vector4> values);
        public static void SetGlobalVectorArray(string name, Vector4[] values);
        public static void SetGlobalVectorArray(int nameID, Vector4[] values);
        public static void SetGlobalMatrixArray(string name, List<Matrix4x4> values);
        public static void SetGlobalMatrixArray(int nameID, List<Matrix4x4> values);
        public static void SetGlobalMatrixArray(string name, Matrix4x4[] values);
        public static void SetGlobalMatrixArray(int nameID, Matrix4x4[] values);
        public static float GetGlobalFloat(string name);
        public static float GetGlobalFloat(int nameID);
        public static int GetGlobalInt(string name);
        public static int GetGlobalInt(int nameID);
        public static Vector4 GetGlobalVector(string name);
        public static Vector4 GetGlobalVector(int nameID);
        public static Color GetGlobalColor(string name);
        public static Color GetGlobalColor(int nameID);
        public static Matrix4x4 GetGlobalMatrix(string name);
        public static Matrix4x4 GetGlobalMatrix(int nameID);
        public static Texture GetGlobalTexture(string name);
        public static Texture GetGlobalTexture(int nameID);
        public static float[] GetGlobalFloatArray(string name);
        public static float[] GetGlobalFloatArray(int nameID);
        public static Vector4[] GetGlobalVectorArray(string name);
        public static Vector4[] GetGlobalVectorArray(int nameID);
        public static Matrix4x4[] GetGlobalMatrixArray(string name);
        public static Matrix4x4[] GetGlobalMatrixArray(int nameID);
        public static void GetGlobalFloatArray(string name, List<float> values);
        public static void GetGlobalFloatArray(int nameID, List<float> values);
        public static void GetGlobalVectorArray(string name, List<Vector4> values);
        public static void GetGlobalVectorArray(int nameID, List<Vector4> values);
        public static void GetGlobalMatrixArray(string name, List<Matrix4x4> values);
        public static void GetGlobalMatrixArray(int nameID, List<Matrix4x4> values);
        public int GetPropertyCount();
        public int FindPropertyIndex(string propertyName);
        public string GetPropertyName(int propertyIndex);
        public int GetPropertyNameId(int propertyIndex);
        public ShaderPropertyType GetPropertyType(int propertyIndex);
        public string GetPropertyDescription(int propertyIndex);
        public ShaderPropertyFlags GetPropertyFlags(int propertyIndex);
        public string[] GetPropertyAttributes(int propertyIndex);
        public float GetPropertyDefaultFloatValue(int propertyIndex);
        public Vector4 GetPropertyDefaultVectorValue(int propertyIndex);
        public Vector2 GetPropertyRangeLimits(int propertyIndex);
        public TextureDimension GetPropertyTextureDimension(int propertyIndex);
        public string GetPropertyTextureDefaultName(int propertyIndex);
        public bool FindTextureStack(int propertyIndex, out string stackName, out int layerIndex);
    }
}
namespace UnityEngine
{
    public enum LightmapsModeLegacy
    {
        Single = 0,
        Dual = 1,
        Directional = 2
    }
}
using System;
using Unity.Collections;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Graphics/GraphicsScriptBindings.h")]
    [NativeHeader("Runtime/Graphics/TrailRenderer.h")]
    public sealed class TrailRenderer : Renderer
    {
        public TrailRenderer();

        [Obsolete("Use positionCount instead (UnityUpgradable) -> positionCount", False)]
        public int numPositions { get; }
        public float time { get; set; }
        public float startWidth { get; set; }
        public float endWidth { get; set; }
        public float widthMultiplier { get; set; }
        public bool autodestruct { get; set; }
        public bool emitting { get; set; }
        public int numCornerVertices { get; set; }
        public int numCapVertices { get; set; }
        public float minVertexDistance { get; set; }
        public Color startColor { get; set; }
        public Color endColor { get; set; }
        [NativeProperty("PositionsCount")]
        public int positionCount { get; }
        public float shadowBias { get; set; }
        public bool generateLightingData { get; set; }
        public LineTextureMode textureMode { get; set; }
        public LineAlignment alignment { get; set; }
        public AnimationCurve widthCurve { get; set; }
        public Gradient colorGradient { get; set; }

        public void SetPosition(int index, Vector3 position);
        public Vector3 GetPosition(int index);
        public void Clear();
        public void BakeMesh(Mesh mesh, bool useTransform = False);
        public void BakeMesh([NotNull("ArgumentNullException")] Mesh mesh, [NotNull("ArgumentNullException")] Camera camera, bool useTransform = False);
        [FreeFunction(Name = "TrailRendererScripting::GetPositions", HasExplicitThis = True)]
        public int GetPositions([NotNull("ArgumentNullException")] out Vector3[] positions);
        [FreeFunction(Name = "TrailRendererScripting::SetPositions", HasExplicitThis = True)]
        public void SetPositions([NotNull("ArgumentNullException")] Vector3[] positions);
        [FreeFunction(Name = "TrailRendererScripting::AddPosition", HasExplicitThis = True)]
        public void AddPosition(Vector3 position);
        [FreeFunction(Name = "TrailRendererScripting::AddPositions", HasExplicitThis = True)]
        public void AddPositions([NotNull("ArgumentNullException")] Vector3[] positions);
        public void SetPositions(NativeArray<Vector3> positions);
        public void SetPositions(NativeSlice<Vector3> positions);
        public int GetPositions(out NativeArray<Vector3> positions);
        public int GetPositions(out NativeSlice<Vector3> positions);
        public void AddPositions(out NativeArray<Vector3> positions);
        public void AddPositions(out NativeSlice<Vector3> positions);
    }
}
using System;
using Unity.Collections;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Graphics/GraphicsScriptBindings.h")]
    [NativeHeader("Runtime/Graphics/LineRenderer.h")]
    public sealed class LineRenderer : Renderer
    {
        public LineRenderer();

        [Obsolete("Use positionCount instead (UnityUpgradable) -> positionCount", False)]
        public int numPositions { get; set; }
        public float startWidth { get; set; }
        public float endWidth { get; set; }
        public float widthMultiplier { get; set; }
        public int numCornerVertices { get; set; }
        public int numCapVertices { get; set; }
        public bool useWorldSpace { get; set; }
        public bool loop { get; set; }
        public Color startColor { get; set; }
        public Color endColor { get; set; }
        [NativeProperty("PositionsCount")]
        public int positionCount { get; set; }
        public float shadowBias { get; set; }
        public bool generateLightingData { get; set; }
        public LineTextureMode textureMode { get; set; }
        public LineAlignment alignment { get; set; }
        public AnimationCurve widthCurve { get; set; }
        public Gradient colorGradient { get; set; }

        [Obsolete("Use startWidth, endWidth or widthCurve instead.", False)]
        public void SetWidth(float start, float end);
        [Obsolete("Use startColor, endColor or colorGradient instead.", False)]
        public void SetColors(Color start, Color end);
        [Obsolete("Use positionCount instead.", False)]
        public void SetVertexCount(int count);
        public void SetPosition(int index, Vector3 position);
        public Vector3 GetPosition(int index);
        public void Simplify(float tolerance);
        public void BakeMesh(Mesh mesh, bool useTransform = False);
        public void BakeMesh([NotNull("ArgumentNullException")] Mesh mesh, [NotNull("ArgumentNullException")] Camera camera, bool useTransform = False);
        [FreeFunction(Name = "LineRendererScripting::GetPositions", HasExplicitThis = True)]
        public int GetPositions([NotNull("ArgumentNullException")] out Vector3[] positions);
        [FreeFunction(Name = "LineRendererScripting::SetPositions", HasExplicitThis = True)]
        public void SetPositions([NotNull("ArgumentNullException")] Vector3[] positions);
        public void SetPositions(NativeArray<Vector3> positions);
        public void SetPositions(NativeSlice<Vector3> positions);
        public int GetPositions(out NativeArray<Vector3> positions);
        public int GetPositions(out NativeSlice<Vector3> positions);
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Rendering;

namespace UnityEngine
{
    [NativeHeader("Runtime/Shaders/ComputeShader.h")]
    [NativeHeader("Runtime/Shaders/ShaderPropertySheet.h")]
    [NativeHeader("Runtime/Math/SphericalHarmonicsL2.h")]
    [NativeHeader("Runtime/Graphics/ShaderScriptBindings.h")]
    public sealed class MaterialPropertyBlock
    {
        public MaterialPropertyBlock();

        ~MaterialPropertyBlock();

        public bool isEmpty { get; }

        [Obsolete("Use SetFloat instead (UnityUpgradable) -> SetFloat(*)", False)]
        public void AddFloat(string name, float value);
        [Obsolete("Use SetFloat instead (UnityUpgradable) -> SetFloat(*)", False)]
        public void AddFloat(int nameID, float value);
        [Obsolete("Use SetVector instead (UnityUpgradable) -> SetVector(*)", False)]
        public void AddVector(string name, Vector4 value);
        [Obsolete("Use SetVector instead (UnityUpgradable) -> SetVector(*)", False)]
        public void AddVector(int nameID, Vector4 value);
        [Obsolete("Use SetColor instead (UnityUpgradable) -> SetColor(*)", False)]
        public void AddColor(string name, Color value);
        [Obsolete("Use SetColor instead (UnityUpgradable) -> SetColor(*)", False)]
        public void AddColor(int nameID, Color value);
        [Obsolete("Use SetMatrix instead (UnityUpgradable) -> SetMatrix(*)", False)]
        public void AddMatrix(string name, Matrix4x4 value);
        [Obsolete("Use SetMatrix instead (UnityUpgradable) -> SetMatrix(*)", False)]
        public void AddMatrix(int nameID, Matrix4x4 value);
        [Obsolete("Use SetTexture instead (UnityUpgradable) -> SetTexture(*)", False)]
        public void AddTexture(string name, Texture value);
        [Obsolete("Use SetTexture instead (UnityUpgradable) -> SetTexture(*)", False)]
        public void AddTexture(int nameID, Texture value);
        public void Clear();
        public void SetFloat(string name, float value);
        public void SetFloat(int nameID, float value);
        public void SetInt(string name, int value);
        public void SetInt(int nameID, int value);
        public void SetVector(string name, Vector4 value);
        public void SetVector(int nameID, Vector4 value);
        public void SetColor(string name, Color value);
        public void SetColor(int nameID, Color value);
        public void SetMatrix(string name, Matrix4x4 value);
        public void SetMatrix(int nameID, Matrix4x4 value);
        public void SetBuffer(string name, ComputeBuffer value);
        public void SetBuffer(int nameID, ComputeBuffer value);
        public void SetBuffer(string name, GraphicsBuffer value);
        public void SetBuffer(int nameID, GraphicsBuffer value);
        public void SetTexture(string name, Texture value);
        public void SetTexture(int nameID, Texture value);
        public void SetTexture(string name, RenderTexture value, RenderTextureSubElement element);
        public void SetTexture(int nameID, RenderTexture value, RenderTextureSubElement element);
        public void SetConstantBuffer(string name, ComputeBuffer value, int offset, int size);
        public void SetConstantBuffer(int nameID, ComputeBuffer value, int offset, int size);
        public void SetConstantBuffer(string name, GraphicsBuffer value, int offset, int size);
        public void SetConstantBuffer(int nameID, GraphicsBuffer value, int offset, int size);
        public void SetFloatArray(string name, List<float> values);
        public void SetFloatArray(int nameID, List<float> values);
        public void SetFloatArray(string name, float[] values);
        public void SetFloatArray(int nameID, float[] values);
        public void SetVectorArray(string name, List<Vector4> values);
        public void SetVectorArray(int nameID, List<Vector4> values);
        public void SetVectorArray(string name, Vector4[] values);
        public void SetVectorArray(int nameID, Vector4[] values);
        public void SetMatrixArray(string name, List<Matrix4x4> values);
        public void SetMatrixArray(int nameID, List<Matrix4x4> values);
        public void SetMatrixArray(string name, Matrix4x4[] values);
        public void SetMatrixArray(int nameID, Matrix4x4[] values);
        public float GetFloat(string name);
        public float GetFloat(int nameID);
        public int GetInt(string name);
        public int GetInt(int nameID);
        public Vector4 GetVector(string name);
        public Vector4 GetVector(int nameID);
        public Color GetColor(string name);
        public Color GetColor(int nameID);
        public Matrix4x4 GetMatrix(string name);
        public Matrix4x4 GetMatrix(int nameID);
        public Texture GetTexture(string name);
        public Texture GetTexture(int nameID);
        public float[] GetFloatArray(string name);
        public float[] GetFloatArray(int nameID);
        public Vector4[] GetVectorArray(string name);
        public Vector4[] GetVectorArray(int nameID);
        public Matrix4x4[] GetMatrixArray(string name);
        public Matrix4x4[] GetMatrixArray(int nameID);
        public void GetFloatArray(string name, List<float> values);
        public void GetFloatArray(int nameID, List<float> values);
        public void GetVectorArray(string name, List<Vector4> values);
        public void GetVectorArray(int nameID, List<Vector4> values);
        public void GetMatrixArray(string name, List<Matrix4x4> values);
        public void GetMatrixArray(int nameID, List<Matrix4x4> values);
        public void CopySHCoefficientArraysFrom(List<SphericalHarmonicsL2> lightProbes);
        public void CopySHCoefficientArraysFrom(SphericalHarmonicsL2[] lightProbes);
        public void CopySHCoefficientArraysFrom(List<SphericalHarmonicsL2> lightProbes, int sourceStart, int destStart, int count);
        public void CopySHCoefficientArraysFrom(SphericalHarmonicsL2[] lightProbes, int sourceStart, int destStart, int count);
        public void CopyProbeOcclusionArrayFrom(List<Vector4> occlusionProbes);
        public void CopyProbeOcclusionArrayFrom(Vector4[] occlusionProbes);
        public void CopyProbeOcclusionArrayFrom(List<Vector4> occlusionProbes, int sourceStart, int destStart, int count);
        public void CopyProbeOcclusionArrayFrom(Vector4[] occlusionProbes, int sourceStart, int destStart, int count);
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Rendering;

namespace UnityEngine
{
    [NativeHeader("Runtime/Graphics/GraphicsScriptBindings.h")]
    [NativeHeader("Runtime/Camera/RenderSettings.h")]
    [StaticAccessor("GetRenderSettings()", Dot)]
    [NativeHeader("Runtime/Graphics/QualitySettingsTypes.h")]
    public sealed class RenderSettings : Object
    {
        [Obsolete("Use RenderSettings.ambientIntensity instead (UnityUpgradable) -> ambientIntensity", False)]
        public static float ambientSkyboxAmount { get; set; }
        [NativeProperty("UseFog")]
        public static bool fog { get; set; }
        [NativeProperty("LinearFogStart")]
        public static float fogStartDistance { get; set; }
        [NativeProperty("LinearFogEnd")]
        public static float fogEndDistance { get; set; }
        public static FogMode fogMode { get; set; }
        public static Color fogColor { get; set; }
        public static float fogDensity { get; set; }
        public static AmbientMode ambientMode { get; set; }
        public static Color ambientSkyColor { get; set; }
        public static Color ambientEquatorColor { get; set; }
        public static Color ambientGroundColor { get; set; }
        public static float ambientIntensity { get; set; }
        [NativeProperty("AmbientSkyColor")]
        public static Color ambientLight { get; set; }
        public static Color subtractiveShadowColor { get; set; }
        [NativeProperty("SkyboxMaterial")]
        public static Material skybox { get; set; }
        public static Light sun { get; set; }
        public static SphericalHarmonicsL2 ambientProbe { get; set; }
        public static Cubemap customReflection { get; set; }
        public static float reflectionIntensity { get; set; }
        public static int reflectionBounces { get; set; }
        public static DefaultReflectionMode defaultReflectionMode { get; set; }
        public static int defaultReflectionResolution { get; set; }
        public static float haloStrength { get; set; }
        public static float flareStrength { get; set; }
        public static float flareFadeSpeed { get; set; }
    }
}
using System;
using System.Collections.Generic;
using System.ComponentModel;
using UnityEngine.Bindings;
using UnityEngine.Rendering;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Runtime/Shaders/Material.h")]
    [NativeHeader("Runtime/Graphics/ShaderScriptBindings.h")]
    public class Material : Object
    {
        public Material(Shader shader);
        [RequiredByNativeCode]
        public Material(Material source);
        [EditorBrowsable(Never)]
        [Obsolete("Creating materials from shader source string is no longer supported. Use Shader assets instead.", False)]
        public Material(string contents);

        public Shader shader { get; set; }
        public Color color { get; set; }
        public Texture mainTexture { get; set; }
        public Vector2 mainTextureOffset { get; set; }
        public Vector2 mainTextureScale { get; set; }
        public int renderQueue { get; set; }
        public MaterialGlobalIlluminationFlags globalIlluminationFlags { get; set; }
        public bool doubleSidedGI { get; set; }
        [NativeProperty("EnableInstancingVariants")]
        public bool enableInstancing { get; set; }
        public int passCount { get; }
        public string[] shaderKeywords { get; set; }

        [Obsolete("Creating materials from shader source string will be removed in the future. Use Shader assets instead.", False)]
        public static Material Create(string scriptContents);
        [NativeName("HasPropertyFromScript")]
        public bool HasProperty(int nameID);
        public bool HasProperty(string name);
        public void EnableKeyword(string keyword);
        public void DisableKeyword(string keyword);
        public bool IsKeywordEnabled(string keyword);
        [FreeFunction("MaterialScripting::SetShaderPassEnabled", HasExplicitThis = True)]
        public void SetShaderPassEnabled(string passName, bool enabled);
        [FreeFunction("MaterialScripting::GetShaderPassEnabled", HasExplicitThis = True)]
        public bool GetShaderPassEnabled(string passName);
        public string GetPassName(int pass);
        public int FindPass(string passName);
        public void SetOverrideTag(string tag, string val);
        public string GetTag(string tag, bool searchFallbacks, string defaultValue);
        public string GetTag(string tag, bool searchFallbacks);
        [FreeFunction("MaterialScripting::Lerp", HasExplicitThis = True)]
        [NativeThrows]
        public void Lerp(Material start, Material end, float t);
        [FreeFunction("MaterialScripting::SetPass", HasExplicitThis = True)]
        public bool SetPass(int pass);
        [FreeFunction("MaterialScripting::CopyPropertiesFrom", HasExplicitThis = True)]
        public void CopyPropertiesFromMaterial(Material mat);
        public int ComputeCRC();
        [FreeFunction("MaterialScripting::GetTexturePropertyNames", HasExplicitThis = True)]
        public string[] GetTexturePropertyNames();
        [FreeFunction("MaterialScripting::GetTexturePropertyNameIDs", HasExplicitThis = True)]
        public int[] GetTexturePropertyNameIDs();
        public void GetTexturePropertyNames(List<string> outNames);
        public void GetTexturePropertyNameIDs(List<int> outNames);
        public void SetFloat(string name, float value);
        public void SetFloat(int nameID, float value);
        public void SetInt(string name, int value);
        public void SetInt(int nameID, int value);
        public void SetColor(string name, Color value);
        public void SetColor(int nameID, Color value);
        public void SetVector(string name, Vector4 value);
        public void SetVector(int nameID, Vector4 value);
        public void SetMatrix(string name, Matrix4x4 value);
        public void SetMatrix(int nameID, Matrix4x4 value);
        public void SetTexture(string name, Texture value);
        public void SetTexture(int nameID, Texture value);
        public void SetTexture(string name, RenderTexture value, RenderTextureSubElement element);
        public void SetTexture(int nameID, RenderTexture value, RenderTextureSubElement element);
        public void SetBuffer(string name, ComputeBuffer value);
        public void SetBuffer(int nameID, ComputeBuffer value);
        public void SetBuffer(string name, GraphicsBuffer value);
        public void SetBuffer(int nameID, GraphicsBuffer value);
        public void SetConstantBuffer(string name, ComputeBuffer value, int offset, int size);
        public void SetConstantBuffer(int nameID, ComputeBuffer value, int offset, int size);
        public void SetConstantBuffer(string name, GraphicsBuffer value, int offset, int size);
        public void SetConstantBuffer(int nameID, GraphicsBuffer value, int offset, int size);
        public void SetFloatArray(string name, List<float> values);
        public void SetFloatArray(int nameID, List<float> values);
        public void SetFloatArray(string name, float[] values);
        public void SetFloatArray(int nameID, float[] values);
        public void SetColorArray(string name, List<Color> values);
        public void SetColorArray(int nameID, List<Color> values);
        public void SetColorArray(string name, Color[] values);
        public void SetColorArray(int nameID, Color[] values);
        public void SetVectorArray(string name, List<Vector4> values);
        public void SetVectorArray(int nameID, List<Vector4> values);
        public void SetVectorArray(string name, Vector4[] values);
        public void SetVectorArray(int nameID, Vector4[] values);
        public void SetMatrixArray(string name, List<Matrix4x4> values);
        public void SetMatrixArray(int nameID, List<Matrix4x4> values);
        public void SetMatrixArray(string name, Matrix4x4[] values);
        public void SetMatrixArray(int nameID, Matrix4x4[] values);
        public float GetFloat(string name);
        public float GetFloat(int nameID);
        public int GetInt(string name);
        public int GetInt(int nameID);
        public Color GetColor(string name);
        public Color GetColor(int nameID);
        public Vector4 GetVector(string name);
        public Vector4 GetVector(int nameID);
        public Matrix4x4 GetMatrix(string name);
        public Matrix4x4 GetMatrix(int nameID);
        public Texture GetTexture(string name);
        public Texture GetTexture(int nameID);
        public float[] GetFloatArray(string name);
        public float[] GetFloatArray(int nameID);
        public Color[] GetColorArray(string name);
        public Color[] GetColorArray(int nameID);
        public Vector4[] GetVectorArray(string name);
        public Vector4[] GetVectorArray(int nameID);
        public Matrix4x4[] GetMatrixArray(string name);
        public Matrix4x4[] GetMatrixArray(int nameID);
        public void GetFloatArray(string name, List<float> values);
        public void GetFloatArray(int nameID, List<float> values);
        public void GetColorArray(string name, List<Color> values);
        public void GetColorArray(int nameID, List<Color> values);
        public void GetVectorArray(string name, List<Vector4> values);
        public void GetVectorArray(int nameID, List<Vector4> values);
        public void GetMatrixArray(string name, List<Matrix4x4> values);
        public void GetMatrixArray(int nameID, List<Matrix4x4> values);
        public void SetTextureOffset(string name, Vector2 value);
        public void SetTextureOffset(int nameID, Vector2 value);
        public void SetTextureScale(string name, Vector2 value);
        public void SetTextureScale(int nameID, Vector2 value);
        public Vector2 GetTextureOffset(string name);
        public Vector2 GetTextureOffset(int nameID);
        public Vector2 GetTextureScale(string name);
        public Vector2 GetTextureScale(int nameID);
    }
}
using System;
using System.Collections.Generic;
using System.Security;
using Unity.Collections;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Runtime/Export/Graphics/GraphicsBuffer.bindings.h")]
    [NativeHeader("Runtime/Shaders/GraphicsBuffer.h")]
    [NativeHeader("Runtime/Shaders/ComputeShader.h")]
    [UsedByNativeCode]
    [NativeHeader("Runtime/GfxDevice/GfxBuffer.h")]
    public sealed class GraphicsBuffer : IDisposable
    {
        public GraphicsBuffer(Target target, int count, int stride);

        ~GraphicsBuffer();

        public int count { get; }
        public int stride { get; }

        public void Dispose();
        public void Release();
        public bool IsValid();
        [SecuritySafeCritical]
        public void SetData(Array data);
        [SecuritySafeCritical]
        public void SetData<T>(List<T> data) where T : struct;
        [SecuritySafeCritical]
        public void SetData<T>(NativeArray<T> data) where T : struct;
        [SecuritySafeCritical]
        public void SetData(Array data, int managedBufferStartIndex, int graphicsBufferStartIndex, int count);
        [SecuritySafeCritical]
        public void SetData<T>(List<T> data, int managedBufferStartIndex, int graphicsBufferStartIndex, int count) where T : struct;
        [SecuritySafeCritical]
        public void SetData<T>(NativeArray<T> data, int nativeBufferStartIndex, int graphicsBufferStartIndex, int count) where T : struct;
        [SecurityCritical]
        public void GetData(Array data);
        [SecurityCritical]
        public void GetData(Array data, int managedBufferStartIndex, int computeBufferStartIndex, int count);
        [FreeFunction(Name = "GraphicsBuffer_Bindings::InternalGetNativeBufferPtr", HasExplicitThis = True)]
        public IntPtr GetNativeBufferPtr();
        public void SetCounterValue(uint counterValue);
        public static void CopyCount(ComputeBuffer src, ComputeBuffer dst, int dstOffsetBytes);
        public static void CopyCount(GraphicsBuffer src, ComputeBuffer dst, int dstOffsetBytes);
        public static void CopyCount(ComputeBuffer src, GraphicsBuffer dst, int dstOffsetBytes);
        public static void CopyCount(GraphicsBuffer src, GraphicsBuffer dst, int dstOffsetBytes);

        [Flags]
        public enum Target
        {
            Vertex = 1,
            Index = 2,
            Structured = 16,
            Raw = 32,
            Append = 64,
            Counter = 128,
            IndirectArguments = 256,
            Constant = 512
        }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Camera/OcclusionPortal.h")]
    public sealed class OcclusionPortal : Component
    {
        public OcclusionPortal();

        [NativeProperty("IsOpen")]
        public bool open { get; set; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Camera/OcclusionArea.h")]
    public sealed class OcclusionArea : Component
    {
        public OcclusionArea();

        public Vector3 center { get; set; }
        public Vector3 size { get; set; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Camera/Flare.h")]
    public sealed class Flare : Object
    {
        public Flare();
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Camera/Flare.h")]
    public sealed class LensFlare : Behaviour
    {
        public LensFlare();

        public float brightness { get; set; }
        public float fadeSpeed { get; set; }
        public Color color { get; set; }
        public Flare flare { get; set; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Camera/SharedLightData.h")]
    public struct LightBakingOutput
    {
        public int probeOcclusionLightIndex;
        public int occlusionMaskChannel;
        [NativeName("lightmapBakeMode.lightmapBakeType")]
        public LightmapBakeType lightmapBakeType;
        [NativeName("lightmapBakeMode.mixedLightingMode")]
        public MixedLightingMode mixedLightingMode;
        public bool isBaked;
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Camera/SharedLightData.h")]
    public enum LightShadowCasterMode
    {
        Default = 0,
        NonLightmappedOnly = 1,
        Everything = 2
    }
}
using System;
using System.ComponentModel;
using UnityEngine.Bindings;
using UnityEngine.Rendering;

namespace UnityEngine
{
    [RequireComponent(typeof(Transform))]
    [NativeHeader("Runtime/Camera/Light.h")]
    [NativeHeader("Runtime/Export/Graphics/Light.bindings.h")]
    [RequireComponent(typeof(Transform))]
    public sealed class Light : Behaviour
    {
        public Light();

        [NativeProperty("LightType")]
        public LightType type { get; set; }
        [NativeProperty("LightShape")]
        public LightShape shape { get; set; }
        public float spotAngle { get; set; }
        public float innerSpotAngle { get; set; }
        public Color color { get; set; }
        public float colorTemperature { get; set; }
        public bool useColorTemperature { get; set; }
        public float intensity { get; set; }
        public float bounceIntensity { get; set; }
        public bool useBoundingSphereOverride { get; set; }
        public Vector4 boundingSphereOverride { get; set; }
        public bool useViewFrustumForShadowCasterCull { get; set; }
        public int shadowCustomResolution { get; set; }
        public float shadowBias { get; set; }
        public float shadowNormalBias { get; set; }
        public float shadowNearPlane { get; set; }
        public bool useShadowMatrixOverride { get; set; }
        public Matrix4x4 shadowMatrixOverride { get; set; }
        public float range { get; set; }
        public Flare flare { get; set; }
        public LightBakingOutput bakingOutput { get; set; }
        public int cullingMask { get; set; }
        public int renderingLayerMask { get; set; }
        public LightShadowCasterMode lightShadowCasterMode { get; set; }
        public float shadowRadius { get; set; }
        public float shadowAngle { get; set; }
        public LightShadows shadows { get; set; }
        public float shadowStrength { get; set; }
        public LightShadowResolution shadowResolution { get; set; }
        [Obsolete("Shadow softness is removed in Unity 5.0+", True)]
        [EditorBrowsable(Never)]
        public float shadowSoftness { get; set; }
        [Obsolete("Shadow softness is removed in Unity 5.0+", True)]
        [EditorBrowsable(Never)]
        public float shadowSoftnessFade { get; set; }
        public float[] layerShadowCullDistances { get; set; }
        public float cookieSize { get; set; }
        public Texture cookie { get; set; }
        public LightRenderMode renderMode { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("warning bakedIndex has been removed please use bakingOutput.isBaked instead.", True)]
        public int bakedIndex { get; set; }
        public Vector2 areaSize { get; set; }
        public LightmapBakeType lightmapBakeType { get; set; }
        public int commandBufferCount { get; }
        [Obsolete("Use QualitySettings.pixelLightCount instead.")]
        public static int pixelLightCount { get; set; }
        [Obsolete("light.shadowConstantBias was removed, use light.shadowBias", True)]
        public float shadowConstantBias { get; set; }
        [Obsolete("light.shadowObjectSizeBias was removed, use light.shadowBias", True)]
        public float shadowObjectSizeBias { get; set; }
        [Obsolete("light.attenuate was removed; all lights always attenuate now", True)]
        public bool attenuate { get; set; }
        [Obsolete("Light.lightmappingMode has been deprecated. Use Light.lightmapBakeType instead (UnityUpgradable) -> lightmapBakeType", True)]
        public LightmappingMode lightmappingMode { get; set; }
        [Obsolete("Light.isBaked is no longer supported. Use Light.bakingOutput.isBaked (and other members of Light.bakingOutput) instead.", False)]
        public bool isBaked { get; }
        [Obsolete("Light.alreadyLightmapped is no longer supported. Use Light.bakingOutput instead. Allowing to describe mixed light on top of realtime and baked ones.", False)]
        public bool alreadyLightmapped { get; set; }

        public void Reset();
        public void SetLightDirty();
        public void AddCommandBuffer(LightEvent evt, CommandBuffer buffer);
        [FreeFunction("Light_Bindings::AddCommandBuffer", HasExplicitThis = True)]
        public void AddCommandBuffer(LightEvent evt, CommandBuffer buffer, ShadowMapPass shadowPassMask);
        public void AddCommandBufferAsync(LightEvent evt, CommandBuffer buffer, ComputeQueueType queueType);
        [FreeFunction("Light_Bindings::AddCommandBufferAsync", HasExplicitThis = True)]
        public void AddCommandBufferAsync(LightEvent evt, CommandBuffer buffer, ShadowMapPass shadowPassMask, ComputeQueueType queueType);
        public void RemoveCommandBuffer(LightEvent evt, CommandBuffer buffer);
        public void RemoveCommandBuffers(LightEvent evt);
        public void RemoveAllCommandBuffers();
        [FreeFunction("Light_Bindings::GetCommandBuffers", HasExplicitThis = True)]
        public CommandBuffer[] GetCommandBuffers(LightEvent evt);
        [FreeFunction("Light_Bindings::GetLights")]
        public static Light[] GetLights(LightType type, int layer);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Camera/Skybox.h")]
    public sealed class Skybox : Behaviour
    {
        public Skybox();

        public Material material { get; set; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [RequireComponent(typeof(Transform))]
    [NativeHeader("Runtime/Graphics/Mesh/MeshFilter.h")]
    public sealed class MeshFilter : Component
    {
        public MeshFilter();

        public Mesh sharedMesh { get; set; }
        public Mesh mesh { get; set; }
    }
}
namespace UnityEngine
{
    public enum RenderingPath
    {
        UsePlayerSettings = -1,
        VertexLit = 0,
        Forward = 1,
        DeferredLighting = 2,
        DeferredShading = 3
    }
}
namespace UnityEngine
{
    public enum TransparencySortMode
    {
        Default = 0,
        Perspective = 1,
        Orthographic = 2,
        CustomAxis = 3
    }
}
namespace UnityEngine
{
    public enum StereoTargetEyeMask
    {
        None = 0,
        Left = 1,
        Right = 2,
        Both = 3
    }
}
using System;

namespace UnityEngine
{
    [Flags]
    public enum CameraType
    {
        Game = 1,
        SceneView = 2,
        Preview = 4,
        VR = 8,
        Reflection = 16
    }
}
using System;

namespace UnityEngine
{
    [Flags]
    public enum ComputeBufferType
    {
        Default = 0,
        Raw = 1,
        Append = 2,
        Counter = 4,
        Constant = 8,
        Structured = 16,
        [Obsolete("Enum member DrawIndirect has been deprecated. Use IndirectArguments instead (UnityUpgradable) -> IndirectArguments", False)]
        DrawIndirect = 256,
        IndirectArguments = 256,
        [Obsolete("Enum member GPUMemory has been deprecated. All compute buffers now follow the behavior previously defined by this member.", False)]
        GPUMemory = 512
    }
}
namespace UnityEngine
{
    public enum LightType
    {
        Spot = 0,
        Directional = 1,
        Point = 2,
        Area = 3,
        Rectangle = 3,
        Disc = 4
    }
}
namespace UnityEngine
{
    public enum LightShape
    {
        Cone = 0,
        Pyramid = 1,
        Box = 2
    }
}
namespace UnityEngine
{
    public enum LightRenderMode
    {
        Auto = 0,
        ForcePixel = 1,
        ForceVertex = 2
    }
}
namespace UnityEngine
{
    public enum LightShadows
    {
        None = 0,
        Hard = 1,
        Soft = 2
    }
}
namespace UnityEngine
{
    public enum FogMode
    {
        Linear = 1,
        Exponential = 2,
        ExponentialSquared = 3
    }
}
using System;

namespace UnityEngine
{
    [Flags]
    public enum LightmapBakeType
    {
        Realtime = 4,
        Baked = 2,
        Mixed = 1
    }
}
namespace UnityEngine
{
    public enum MixedLightingMode
    {
        IndirectOnly = 0,
        Shadowmask = 2,
        Subtractive = 1
    }
}
namespace UnityEngine
{
    public enum ReceiveGI
    {
        Lightmaps = 1,
        LightProbes = 2
    }
}
using System;

namespace UnityEngine
{
    [Obsolete("See QualitySettings.names, QualitySettings.SetQualityLevel, and QualitySettings.GetQualityLevel")]
    public enum QualityLevel
    {
        Fastest = 0,
        Fast = 1,
        Simple = 2,
        Good = 3,
        Beautiful = 4,
        Fantastic = 5
    }
}
namespace UnityEngine
{
    public enum ShadowProjection
    {
        CloseFit = 0,
        StableFit = 1
    }
}
namespace UnityEngine
{
    public enum ShadowQuality
    {
        Disable = 0,
        HardOnly = 1,
        All = 2
    }
}
namespace UnityEngine
{
    public enum ShadowResolution
    {
        Low = 0,
        Medium = 1,
        High = 2,
        VeryHigh = 3
    }
}
namespace UnityEngine
{
    public enum ShadowmaskMode
    {
        Shadowmask = 0,
        DistanceShadowmask = 1
    }
}
namespace UnityEngine
{
    public enum CameraClearFlags
    {
        Skybox = 1,
        Color = 2,
        SolidColor = 2,
        Depth = 3,
        Nothing = 4
    }
}
using System;

namespace UnityEngine
{
    [Flags]
    public enum DepthTextureMode
    {
        None = 0,
        Depth = 1,
        DepthNormals = 2,
        MotionVectors = 4
    }
}
namespace UnityEngine
{
    public enum TexGenMode
    {
        None = 0,
        SphereMap = 1,
        Object = 2,
        EyeLinear = 3,
        CubeReflect = 4,
        CubeNormal = 5
    }
}
namespace UnityEngine
{
    public enum AnisotropicFiltering
    {
        Disable = 0,
        Enable = 1,
        ForceEnable = 2
    }
}
using System;

namespace UnityEngine
{
    [Obsolete("BlendWeights is obsolete. Use SkinWeights instead (UnityUpgradable) -> SkinWeights", True)]
    public enum BlendWeights
    {
        [Obsolete("BlendWeights.OneBone is obsolete. Use SkinWeights.OneBone instead (UnityUpgradable) -> SkinWeights.OneBone", True)]
        OneBone = 1,
        [Obsolete("BlendWeights.TwoBones is obsolete. Use SkinWeights.TwoBones instead (UnityUpgradable) -> SkinWeights.TwoBones", True)]
        TwoBones = 2,
        [Obsolete("BlendWeights.FourBones is obsolete. Use SkinWeights.FourBones instead (UnityUpgradable) -> SkinWeights.FourBones", True)]
        FourBones = 4
    }
}
namespace UnityEngine
{
    public enum SkinWeights
    {
        OneBone = 1,
        TwoBones = 2,
        FourBones = 4,
        Unlimited = 255
    }
}
namespace UnityEngine
{
    public enum MeshTopology
    {
        Triangles = 0,
        Quads = 2,
        Lines = 3,
        LineStrip = 4,
        Points = 5
    }
}
namespace UnityEngine
{
    public enum SkinQuality
    {
        Auto = 0,
        Bone1 = 1,
        Bone2 = 2,
        Bone4 = 4
    }
}
namespace UnityEngine
{
    public enum ColorSpace
    {
        Uninitialized = -1,
        Gamma = 0,
        Linear = 1
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    [NativeHeader("Runtime/Graphics/ColorGamut.h")]
    public enum ColorGamut
    {
        sRGB = 0,
        Rec709 = 1,
        Rec2020 = 2,
        DisplayP3 = 3,
        HDR10 = 4,
        DolbyHDR = 5
    }
}
using System;

namespace UnityEngine
{
    public enum ScreenOrientation
    {
        [Obsolete("Enum member Unknown has been deprecated.", False)]
        Unknown = 0,
        Portrait = 1,
        PortraitUpsideDown = 2,
        LandscapeLeft = 3,
        LandscapeRight = 4,
        AutoRotation = 5,
        Landscape = 3
    }
}
namespace UnityEngine
{
    public enum FilterMode
    {
        Point = 0,
        Bilinear = 1,
        Trilinear = 2
    }
}
namespace UnityEngine
{
    public enum TextureWrapMode
    {
        Repeat = 0,
        Clamp = 1,
        Mirror = 2,
        MirrorOnce = 3
    }
}
using System;

namespace UnityEngine
{
    public enum NPOTSupport
    {
        [Obsolete("NPOTSupport.None does not happen on any platforms")]
        None = 0,
        Restricted = 1,
        Full = 2
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    public enum TextureFormat
    {
        Alpha8 = 1,
        ARGB4444 = 2,
        RGB24 = 3,
        RGBA32 = 4,
        ARGB32 = 5,
        RGB565 = 7,
        R16 = 9,
        DXT1 = 10,
        DXT5 = 12,
        RGBA4444 = 13,
        BGRA32 = 14,
        RHalf = 15,
        RGHalf = 16,
        RGBAHalf = 17,
        RFloat = 18,
        RGFloat = 19,
        RGBAFloat = 20,
        YUY2 = 21,
        RGB9e5Float = 22,
        BC4 = 26,
        BC5 = 27,
        BC6H = 24,
        BC7 = 25,
        DXT1Crunched = 28,
        DXT5Crunched = 29,
        PVRTC_RGB2 = 30,
        PVRTC_RGBA2 = 31,
        PVRTC_RGB4 = 32,
        PVRTC_RGBA4 = 33,
        ETC_RGB4 = 34,
        [EditorBrowsable(Never)]
        [Obsolete("Enum member TextureFormat.ATC_RGB4 has been deprecated. Use ETC_RGB4 instead (UnityUpgradable) -> ETC_RGB4", True)]
        ATC_RGB4 = -127,
        [EditorBrowsable(Never)]
        [Obsolete("Enum member TextureFormat.ATC_RGBA8 has been deprecated. Use ETC2_RGBA8 instead (UnityUpgradable) -> ETC2_RGBA8", True)]
        ATC_RGBA8 = -127,
        EAC_R = 41,
        EAC_R_SIGNED = 42,
        EAC_RG = 43,
        EAC_RG_SIGNED = 44,
        ETC2_RGB = 45,
        ETC2_RGBA1 = 46,
        ETC2_RGBA8 = 47,
        ASTC_4x4 = 48,
        ASTC_5x5 = 49,
        ASTC_6x6 = 50,
        ASTC_8x8 = 51,
        ASTC_10x10 = 52,
        ASTC_12x12 = 53,
        [Obsolete("Nintendo 3DS is no longer supported.")]
        ETC_RGB4_3DS = 60,
        [Obsolete("Nintendo 3DS is no longer supported.")]
        ETC_RGBA8_3DS = 61,
        RG16 = 62,
        R8 = 63,
        ETC_RGB4Crunched = 64,
        ETC2_RGBA8Crunched = 65,
        ASTC_HDR_4x4 = 66,
        ASTC_HDR_5x5 = 67,
        ASTC_HDR_6x6 = 68,
        ASTC_HDR_8x8 = 69,
        ASTC_HDR_10x10 = 70,
        ASTC_HDR_12x12 = 71,
        RG32 = 72,
        RGB48 = 73,
        RGBA64 = 74,
        [Obsolete("Enum member TextureFormat.ASTC_RGB_4x4 has been deprecated. Use ASTC_4x4 instead (UnityUpgradable) -> ASTC_4x4")]
        [EditorBrowsable(Never)]
        ASTC_RGB_4x4 = 48,
        [EditorBrowsable(Never)]
        [Obsolete("Enum member TextureFormat.ASTC_RGB_5x5 has been deprecated. Use ASTC_5x5 instead (UnityUpgradable) -> ASTC_5x5")]
        ASTC_RGB_5x5 = 49,
        [EditorBrowsable(Never)]
        [Obsolete("Enum member TextureFormat.ASTC_RGB_6x6 has been deprecated. Use ASTC_6x6 instead (UnityUpgradable) -> ASTC_6x6")]
        ASTC_RGB_6x6 = 50,
        [EditorBrowsable(Never)]
        [Obsolete("Enum member TextureFormat.ASTC_RGB_8x8 has been deprecated. Use ASTC_8x8 instead (UnityUpgradable) -> ASTC_8x8")]
        ASTC_RGB_8x8 = 51,
        [EditorBrowsable(Never)]
        [Obsolete("Enum member TextureFormat.ASTC_RGB_10x10 has been deprecated. Use ASTC_10x10 instead (UnityUpgradable) -> ASTC_10x10")]
        ASTC_RGB_10x10 = 52,
        [EditorBrowsable(Never)]
        [Obsolete("Enum member TextureFormat.ASTC_RGB_12x12 has been deprecated. Use ASTC_12x12 instead (UnityUpgradable) -> ASTC_12x12")]
        ASTC_RGB_12x12 = 53,
        [EditorBrowsable(Never)]
        [Obsolete("Enum member TextureFormat.ASTC_RGBA_4x4 has been deprecated. Use ASTC_4x4 instead (UnityUpgradable) -> ASTC_4x4")]
        ASTC_RGBA_4x4 = 54,
        [EditorBrowsable(Never)]
        [Obsolete("Enum member TextureFormat.ASTC_RGBA_5x5 has been deprecated. Use ASTC_5x5 instead (UnityUpgradable) -> ASTC_5x5")]
        ASTC_RGBA_5x5 = 55,
        [EditorBrowsable(Never)]
        [Obsolete("Enum member TextureFormat.ASTC_RGBA_6x6 has been deprecated. Use ASTC_6x6 instead (UnityUpgradable) -> ASTC_6x6")]
        ASTC_RGBA_6x6 = 56,
        [EditorBrowsable(Never)]
        [Obsolete("Enum member TextureFormat.ASTC_RGBA_8x8 has been deprecated. Use ASTC_8x8 instead (UnityUpgradable) -> ASTC_8x8")]
        ASTC_RGBA_8x8 = 57,
        [Obsolete("Enum member TextureFormat.ASTC_RGBA_10x10 has been deprecated. Use ASTC_10x10 instead (UnityUpgradable) -> ASTC_10x10")]
        [EditorBrowsable(Never)]
        ASTC_RGBA_10x10 = 58,
        [Obsolete("Enum member TextureFormat.ASTC_RGBA_12x12 has been deprecated. Use ASTC_12x12 instead (UnityUpgradable) -> ASTC_12x12")]
        [EditorBrowsable(Never)]
        ASTC_RGBA_12x12 = 59,
        [EditorBrowsable(Never)]
        [Obsolete("Enum member TextureFormat.PVRTC_2BPP_RGB has been deprecated. Use PVRTC_RGB2 instead (UnityUpgradable) -> PVRTC_RGB2", True)]
        PVRTC_2BPP_RGB = -127,
        [EditorBrowsable(Never)]
        [Obsolete("Enum member TextureFormat.PVRTC_2BPP_RGBA has been deprecated. Use PVRTC_RGBA2 instead (UnityUpgradable) -> PVRTC_RGBA2", True)]
        PVRTC_2BPP_RGBA = -127,
        [EditorBrowsable(Never)]
        [Obsolete("Enum member TextureFormat.PVRTC_4BPP_RGB has been deprecated. Use PVRTC_RGB4 instead (UnityUpgradable) -> PVRTC_RGB4", True)]
        PVRTC_4BPP_RGB = -127,
        [Obsolete("Enum member TextureFormat.PVRTC_4BPP_RGBA has been deprecated. Use PVRTC_RGBA4 instead (UnityUpgradable) -> PVRTC_RGBA4", True)]
        [EditorBrowsable(Never)]
        PVRTC_4BPP_RGBA = -127
    }
}
namespace UnityEngine
{
    public enum CubemapFace
    {
        Unknown = -1,
        PositiveX = 0,
        NegativeX = 1,
        PositiveY = 2,
        NegativeY = 3,
        PositiveZ = 4,
        NegativeZ = 5
    }
}
namespace UnityEngine
{
    public enum RenderTextureFormat
    {
        ARGB32 = 0,
        Depth = 1,
        ARGBHalf = 2,
        Shadowmap = 3,
        RGB565 = 4,
        ARGB4444 = 5,
        ARGB1555 = 6,
        Default = 7,
        ARGB2101010 = 8,
        DefaultHDR = 9,
        ARGB64 = 10,
        ARGBFloat = 11,
        RGFloat = 12,
        RGHalf = 13,
        RFloat = 14,
        RHalf = 15,
        R8 = 16,
        ARGBInt = 17,
        RGInt = 18,
        RInt = 19,
        BGRA32 = 20,
        RGB111110Float = 22,
        RG32 = 23,
        RGBAUShort = 24,
        RG16 = 25,
        BGRA10101010_XR = 26,
        BGR101010_XR = 27,
        R16 = 28
    }
}
namespace UnityEngine
{
    public enum VRTextureUsage
    {
        None = 0,
        OneEye = 1,
        TwoEyes = 2,
        DeviceSpecific = 3
    }
}
using System;

namespace UnityEngine
{
    [Flags]
    public enum RenderTextureCreationFlags
    {
        MipMap = 1,
        AutoGenerateMips = 2,
        SRGB = 4,
        EyeTexture = 8,
        EnableRandomWrite = 16,
        CreatedFromScript = 32,
        AllowVerticalFlip = 128,
        NoResolvedColorSurface = 256,
        DynamicallyScalable = 1024,
        BindMS = 2048
    }
}
namespace UnityEngine
{
    public enum RenderTextureReadWrite
    {
        Default = 0,
        Linear = 1,
        sRGB = 2
    }
}
using System;

namespace UnityEngine
{
    [Flags]
    public enum RenderTextureMemoryless
    {
        None = 0,
        Color = 1,
        Depth = 2,
        MSAA = 4
    }
}
using System;

namespace UnityEngine
{
    [Flags]
    public enum HDRDisplaySupportFlags
    {
        None = 0,
        Supported = 1,
        RuntimeSwitchable = 2,
        AutomaticTonemapping = 4
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [Flags]
    public enum LightmapsMode
    {
        NonDirectional = 0,
        CombinedDirectional = 1,
        [EditorBrowsable(Never)]
        [Obsolete("Enum member LightmapsMode.SeparateDirectional has been removed. Use CombinedDirectional instead (UnityUpgradable) -> CombinedDirectional", True)]
        SeparateDirectional = 2,
        [Obsolete("Enum member LightmapsMode.Single has been removed. Use NonDirectional instead (UnityUpgradable) -> NonDirectional", True)]
        [EditorBrowsable(Never)]
        Single = 0,
        [Obsolete("Enum member LightmapsMode.Dual has been removed. Use CombinedDirectional instead (UnityUpgradable) -> CombinedDirectional", True)]
        [EditorBrowsable(Never)]
        Dual = 1,
        [EditorBrowsable(Never)]
        [Obsolete("Enum member LightmapsMode.Directional has been removed. Use CombinedDirectional instead (UnityUpgradable) -> CombinedDirectional", True)]
        Directional = 2
    }
}
using System;

namespace UnityEngine
{
    [Flags]
    public enum MaterialGlobalIlluminationFlags
    {
        None = 0,
        RealtimeEmissive = 1,
        BakedEmissive = 2,
        EmissiveIsBlack = 4,
        AnyEmissive = 3
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Camera/LightProbeProxyVolume.h")]
    public sealed class LightProbeProxyVolume : Behaviour
    {
        public LightProbeProxyVolume();

        public static bool isFeatureSupported { get; }
        [NativeName("GlobalAABB")]
        public Bounds boundsGlobal { get; }
        [NativeName("BoundingBoxSizeCustom")]
        public Vector3 sizeCustom { get; set; }
        [NativeName("BoundingBoxOriginCustom")]
        public Vector3 originCustom { get; set; }
        public float probeDensity { get; set; }
        public int gridResolutionX { get; set; }
        public int gridResolutionY { get; set; }
        public int gridResolutionZ { get; set; }
        public BoundingBoxMode boundingBoxMode { get; set; }
        public ResolutionMode resolutionMode { get; set; }
        public ProbePositionMode probePositionMode { get; set; }
        public RefreshMode refreshMode { get; set; }
        public QualityMode qualityMode { get; set; }
        public DataFormat dataFormat { get; set; }

        public void Update();

        public enum ResolutionMode
        {
            Automatic = 0,
            Custom = 1
        }
        public enum BoundingBoxMode
        {
            AutomaticLocal = 0,
            AutomaticWorld = 1,
            Custom = 2
        }
        public enum ProbePositionMode
        {
            CellCorner = 0,
            CellCenter = 1
        }
        public enum RefreshMode
        {
            Automatic = 0,
            EveryFrame = 1,
            ViaScripting = 2
        }
        public enum QualityMode
        {
            Low = 0,
            Normal = 1
        }
        public enum DataFormat
        {
            HalfFloat = 0,
            Float = 1
        }
    }
}
namespace UnityEngine
{
    public enum CustomRenderTextureInitializationSource
    {
        TextureAndColor = 0,
        Material = 1
    }
}
namespace UnityEngine
{
    public enum CustomRenderTextureUpdateMode
    {
        OnLoad = 0,
        Realtime = 1,
        OnDemand = 2
    }
}
namespace UnityEngine
{
    public enum CustomRenderTextureUpdateZoneSpace
    {
        Normalized = 0,
        Pixel = 1
    }
}
namespace UnityEngine
{
    public enum MotionVectorGenerationMode
    {
        Camera = 0,
        Object = 1,
        ForceNoMotion = 2
    }
}
namespace UnityEngine
{
    public enum LineTextureMode
    {
        Stretch = 0,
        Tile = 1,
        DistributePerSegment = 2,
        RepeatPerSegment = 3
    }
}
using System;

namespace UnityEngine
{
    public enum LineAlignment
    {
        View = 0,
        [Obsolete("Enum member Local has been deprecated. Use TransformZ instead (UnityUpgradable) -> TransformZ", False)]
        Local = 1,
        TransformZ = 1
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Graphics/Mesh/SkinnedMeshRenderer.h")]
    public class SkinnedMeshRenderer : Renderer
    {
        public SkinnedMeshRenderer();

        public SkinQuality quality { get; set; }
        public bool updateWhenOffscreen { get; set; }
        public bool forceMatrixRecalculationPerRender { get; set; }
        public Transform rootBone { get; set; }
        public Transform[] bones { get; set; }
        [NativeProperty("Mesh")]
        public Mesh sharedMesh { get; set; }
        [NativeProperty("SkinnedMeshMotionVectors")]
        public bool skinnedMotionVectors { get; set; }
        public Bounds localBounds { get; set; }

        public float GetBlendShapeWeight(int index);
        public void SetBlendShapeWeight(int index, float value);
        public void BakeMesh(Mesh mesh);
        public void BakeMesh([NotNull("NullExceptionObject")] Mesh mesh, bool useScale);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Graphics/Mesh/MeshRenderer.h")]
    public class MeshRenderer : Renderer
    {
        public MeshRenderer();

        public Mesh additionalVertexStreams { get; set; }
        public Mesh enlightenVertexStream { get; set; }
        public int subMeshStartIndex { get; }
        public float scaleInLightmap { get; set; }
        public ReceiveGI receiveGI { get; set; }
        public bool stitchLightmapSeams { get; set; }
    }
}
using System;

namespace UnityEngine
{
    [Obsolete("LightmappingMode has been deprecated. Use LightmapBakeType instead (UnityUpgradable) -> LightmapBakeType", True)]
    public enum LightmappingMode
    {
        [Obsolete("LightmappingMode.Realtime has been deprecated. Use LightmapBakeType.Realtime instead (UnityUpgradable) -> LightmapBakeType.Realtime", True)]
        Realtime = 4,
        [Obsolete("LightmappingMode.Baked has been deprecated. Use LightmapBakeType.Baked instead (UnityUpgradable) -> LightmapBakeType.Baked", True)]
        Baked = 2,
        [Obsolete("LightmappingMode.Mixed has been deprecated. Use LightmapBakeType.Mixed instead (UnityUpgradable) -> LightmapBakeType.Mixed", True)]
        Mixed = 1
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Graphics/LightProbeGroup.h")]
    public sealed class LightProbeGroup : Behaviour
    {
        public LightProbeGroup();

        [NativeName("Positions")]
        public Vector3[] probePositions { get; set; }
        [NativeName("Dering")]
        public bool dering { get; set; }
    }
}
using System.Collections.Generic;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Export/Graphics/LineUtility.bindings.h")]
    public sealed class LineUtility
    {
        public LineUtility();

        public static void Simplify(List<Vector3> points, float tolerance, List<int> pointsToKeep);
        public static void Simplify(List<Vector3> points, float tolerance, List<Vector3> simplifiedPoints);
        public static void Simplify(List<Vector2> points, float tolerance, List<int> pointsToKeep);
        public static void Simplify(List<Vector2> points, float tolerance, List<Vector2> simplifiedPoints);
    }
}
namespace UnityEngine
{
    public enum LODFadeMode
    {
        None = 0,
        CrossFade = 1,
        SpeedTree = 2
    }
}
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    public struct LOD
    {
        public float screenRelativeTransitionHeight;
        public float fadeTransitionWidth;
        public Renderer[] renderers;

        public LOD(float screenRelativeTransitionHeight, Renderer[] renderers);
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Graphics/LOD/LODGroupManager.h")]
    [NativeHeader("Runtime/Graphics/LOD/LODGroup.h")]
    [StaticAccessor("GetLODGroupManager()", Dot)]
    [NativeHeader("Runtime/Graphics/LOD/LODUtility.h")]
    public class LODGroup : Component
    {
        public LODGroup();

        public Vector3 localReferencePoint { get; set; }
        public float size { get; set; }
        public int lodCount { get; }
        public LODFadeMode fadeMode { get; set; }
        public bool animateCrossFading { get; set; }
        public bool enabled { get; set; }
        [StaticAccessor("GetLODGroupManager()")]
        public static float crossFadeAnimationDuration { get; set; }

        [FreeFunction("UpdateLODGroupBoundingBox", HasExplicitThis = True)]
        public void RecalculateBounds();
        [FreeFunction("GetLODs_Binding", HasExplicitThis = True)]
        public LOD[] GetLODs();
        [Obsolete("Use SetLODs instead.")]
        public void SetLODS(LOD[] lods);
        [FreeFunction("SetLODs_Binding", HasExplicitThis = True)]
        public void SetLODs(LOD[] lods);
        [FreeFunction("ForceLODLevel", HasExplicitThis = True)]
        public void ForceLOD(int index);
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    public struct BoneWeight : IEquatable<BoneWeight>
    {
        public float weight0 { get; set; }
        public float weight1 { get; set; }
        public float weight2 { get; set; }
        public float weight3 { get; set; }
        public int boneIndex0 { get; set; }
        public int boneIndex1 { get; set; }
        public int boneIndex2 { get; set; }
        public int boneIndex3 { get; set; }

        public override int GetHashCode();
        public override bool Equals(object other);
        public bool Equals(BoneWeight other);

        public static bool operator ==(BoneWeight lhs, BoneWeight rhs);
        public static bool operator !=(BoneWeight lhs, BoneWeight rhs);
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    public struct BoneWeight1 : IEquatable<BoneWeight1>
    {
        public float weight { get; set; }
        public int boneIndex { get; set; }

        public override bool Equals(object other);
        public bool Equals(BoneWeight1 other);
        public override int GetHashCode();

        public static bool operator ==(BoneWeight1 lhs, BoneWeight1 rhs);
        public static bool operator !=(BoneWeight1 lhs, BoneWeight1 rhs);
    }
}
namespace UnityEngine
{
    public struct CombineInstance
    {
        public Mesh mesh { get; set; }
        public int subMeshIndex { get; set; }
        public Matrix4x4 transform { get; set; }
        public Vector4 lightmapScaleOffset { get; set; }
        public Vector4 realtimeLightmapScaleOffset { get; set; }
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Experimental.Rendering;
using UnityEngine.Rendering;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Runtime/Graphics/Texture.h")]
    [UsedByNativeCode]
    [NativeHeader("Runtime/Streaming/TextureStreamingManager.h")]
    public class Texture : Object
    {
        public static readonly int GenerateAllMips;

        protected Texture();

        [NativeProperty("GlobalMasterTextureLimit")]
        public static int masterTextureLimit { get; set; }
        public int mipmapCount { get; }
        [NativeProperty("AnisoLimit")]
        public static AnisotropicFiltering anisotropicFiltering { get; set; }
        public virtual GraphicsFormat graphicsFormat { get; }
        public virtual int width { get; set; }
        public virtual int height { get; set; }
        public virtual TextureDimension dimension { get; set; }
        public virtual bool isReadable { get; }
        public TextureWrapMode wrapMode { get; set; }
        public TextureWrapMode wrapModeU { get; set; }
        public TextureWrapMode wrapModeV { get; set; }
        public TextureWrapMode wrapModeW { get; set; }
        public FilterMode filterMode { get; set; }
        public int anisoLevel { get; set; }
        public float mipMapBias { get; set; }
        public Vector2 texelSize { get; }
        public uint updateCount { get; }
        public Hash128 imageContentsHash { get; set; }
        public static ulong totalTextureMemory { get; }
        public static ulong desiredTextureMemory { get; }
        public static ulong targetTextureMemory { get; }
        public static ulong currentTextureMemory { get; }
        public static ulong nonStreamingTextureMemory { get; }
        public static ulong streamingMipmapUploadCount { get; }
        public static ulong streamingRendererCount { get; }
        public static ulong streamingTextureCount { get; }
        public static ulong nonStreamingTextureCount { get; }
        public static ulong streamingTexturePendingLoadCount { get; }
        public static ulong streamingTextureLoadingCount { get; }
        public static bool streamingTextureForceLoadAll { get; set; }
        public static bool streamingTextureDiscardUnusedMips { get; set; }
        public static bool allowThreadedTextureCreation { get; set; }

        [NativeName("SetGlobalAnisoLimits")]
        public static void SetGlobalAnisotropicFilteringLimits(int forcedMin, int globalMax);
        public IntPtr GetNativeTexturePtr();
        [Obsolete("Use GetNativeTexturePtr instead.", False)]
        public int GetNativeTextureID();
        public void IncrementUpdateCount();
        [FreeFunction("GetTextureStreamingManager().SetStreamingTextureMaterialDebugProperties")]
        public static void SetStreamingTextureMaterialDebugProperties();
    }
}
using System;
using System.Collections.Generic;
using Unity.Collections;
using UnityEngine.Bindings;
using UnityEngine.Experimental.Rendering;
using UnityEngine.Internal;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Runtime/Graphics/GeneratedTextures.h")]
    [UsedByNativeCode]
    [NativeHeader("Runtime/Graphics/Texture2D.h")]
    public sealed class Texture2D : Texture
    {
        public Texture2D(int width, int height, DefaultFormat format, TextureCreationFlags flags);
        public Texture2D(int width, int height, GraphicsFormat format, TextureCreationFlags flags);
        public Texture2D(int width, int height, GraphicsFormat format, int mipCount, TextureCreationFlags flags);
        public Texture2D(int width, int height, [DefaultValue("TextureFormat.RGBA32")] TextureFormat textureFormat, [DefaultValue("-1")] int mipCount, [DefaultValue("false")] bool linear);
        public Texture2D(int width, int height, [DefaultValue("TextureFormat.RGBA32")] TextureFormat textureFormat, [DefaultValue("true")] bool mipChain, [DefaultValue("false")] bool linear);
        public Texture2D(int width, int height, TextureFormat textureFormat, bool mipChain);
        public Texture2D(int width, int height);

        public TextureFormat format { get; }
        public bool ignoreMipmapLimit { get; set; }
        [StaticAccessor("builtintex", DoubleColon)]
        public static Texture2D whiteTexture { get; }
        [StaticAccessor("builtintex", DoubleColon)]
        public static Texture2D blackTexture { get; }
        [StaticAccessor("builtintex", DoubleColon)]
        public static Texture2D redTexture { get; }
        [StaticAccessor("builtintex", DoubleColon)]
        public static Texture2D grayTexture { get; }
        [StaticAccessor("builtintex", DoubleColon)]
        public static Texture2D linearGrayTexture { get; }
        [StaticAccessor("builtintex", DoubleColon)]
        public static Texture2D normalTexture { get; }
        public override bool isReadable { get; }
        [NativeName("VTOnly")]
        [NativeConditional("ENABLE_VIRTUALTEXTURING && UNITY_EDITOR")]
        public bool vtOnly { get; }
        public bool streamingMipmaps { get; }
        public int streamingMipmapsPriority { get; }
        public int requestedMipmapLevel { get; set; }
        public int minimumMipmapLevel { get; set; }
        public int calculatedMipmapLevel { get; }
        public int desiredMipmapLevel { get; }
        public int loadingMipmapLevel { get; }
        public int loadedMipmapLevel { get; }
        public bool alphaIsTransparency { get; set; }

        public void Compress(bool highQuality);
        [FreeFunction(Name = "GetTextureStreamingManager().ClearRequestedMipmapLevel", HasExplicitThis = True)]
        public void ClearRequestedMipmapLevel();
        [FreeFunction(Name = "GetTextureStreamingManager().IsRequestedMipmapLevelLoaded", HasExplicitThis = True)]
        public bool IsRequestedMipmapLevelLoaded();
        [FreeFunction(Name = "GetTextureStreamingManager().ClearMinimumMipmapLevel", HasExplicitThis = True)]
        public void ClearMinimumMipmapLevel();
        [FreeFunction("Texture2DScripting::UpdateExternalTexture", HasExplicitThis = True)]
        public void UpdateExternalTexture(IntPtr nativeTex);
        [FreeFunction("Texture2DScripting::GetRawTextureData", HasExplicitThis = True)]
        public byte[] GetRawTextureData();
        [FreeFunction("Texture2DScripting::GetPixels", HasExplicitThis = True, ThrowsException = True)]
        public Color[] GetPixels(int x, int y, int blockWidth, int blockHeight, int miplevel);
        public Color[] GetPixels(int x, int y, int blockWidth, int blockHeight);
        [FreeFunction("Texture2DScripting::GetPixels32", HasExplicitThis = True, ThrowsException = True)]
        public Color32[] GetPixels32(int miplevel);
        public Color32[] GetPixels32();
        [FreeFunction("Texture2DScripting::PackTextures", HasExplicitThis = True)]
        public Rect[] PackTextures(Texture2D[] textures, int padding, int maximumAtlasSize, bool makeNoLongerReadable);
        public Rect[] PackTextures(Texture2D[] textures, int padding, int maximumAtlasSize);
        public Rect[] PackTextures(Texture2D[] textures, int padding);
        public static Texture2D CreateExternalTexture(int width, int height, TextureFormat format, bool mipChain, bool linear, IntPtr nativeTex);
        public void SetPixel(int x, int y, Color color);
        public void SetPixel(int x, int y, Color color, int mipLevel);
        public void SetPixels(int x, int y, int blockWidth, int blockHeight, Color[] colors, [DefaultValue("0")] int miplevel);
        public void SetPixels(int x, int y, int blockWidth, int blockHeight, Color[] colors);
        public void SetPixels(Color[] colors, [DefaultValue("0")] int miplevel);
        public void SetPixels(Color[] colors);
        public Color GetPixel(int x, int y);
        public Color GetPixel(int x, int y, int mipLevel);
        public Color GetPixelBilinear(float u, float v);
        public Color GetPixelBilinear(float u, float v, int mipLevel);
        public void LoadRawTextureData(IntPtr data, int size);
        public void LoadRawTextureData(byte[] data);
        public void LoadRawTextureData<T>(NativeArray<T> data) where T : struct;
        public void SetPixelData<T>(T[] data, int mipLevel, int sourceDataStartIndex = 0);
        public void SetPixelData<T>(NativeArray<T> data, int mipLevel, int sourceDataStartIndex = 0) where T : struct;
        public NativeArray<T> GetPixelData<T>(int mipLevel) where T : struct;
        public NativeArray<T> GetRawTextureData<T>() where T : struct;
        public void Apply([DefaultValue("true")] bool updateMipmaps, [DefaultValue("false")] bool makeNoLongerReadable);
        public void Apply(bool updateMipmaps);
        public void Apply();
        public bool Resize(int width, int height);
        public bool Resize(int width, int height, TextureFormat format, bool hasMipMap);
        public bool Resize(int width, int height, GraphicsFormat format, bool hasMipMap);
        public void ReadPixels(Rect source, int destX, int destY, [DefaultValue("true")] bool recalculateMipMaps);
        [ExcludeFromDocs]
        public void ReadPixels(Rect source, int destX, int destY);
        public static bool GenerateAtlas(Vector2[] sizes, int padding, int atlasSize, List<Rect> results);
        public void SetPixels32(Color32[] colors, int miplevel);
        public void SetPixels32(Color32[] colors);
        public void SetPixels32(int x, int y, int blockWidth, int blockHeight, Color32[] colors, int miplevel);
        public void SetPixels32(int x, int y, int blockWidth, int blockHeight, Color32[] colors);
        public Color[] GetPixels(int miplevel);
        public Color[] GetPixels();

        [Flags]
        public enum EXRFlags
        {
            None = 0,
            OutputAsFloat = 1,
            CompressZIP = 2,
            CompressRLE = 4,
            CompressPIZ = 8
        }
    }
}
using System;
using Unity.Collections;
using UnityEngine.Bindings;
using UnityEngine.Experimental.Rendering;
using UnityEngine.Internal;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Runtime/Graphics/CubemapTexture.h")]
    [ExcludeFromPreset]
    public sealed class Cubemap : Texture
    {
        public Cubemap(int width, DefaultFormat format, TextureCreationFlags flags);
        [RequiredByNativeCode]
        public Cubemap(int width, GraphicsFormat format, TextureCreationFlags flags);
        public Cubemap(int width, TextureFormat format, int mipCount);
        public Cubemap(int width, GraphicsFormat format, TextureCreationFlags flags, int mipCount);
        public Cubemap(int width, TextureFormat textureFormat, bool mipChain);

        public TextureFormat format { get; }
        public override bool isReadable { get; }
        public bool streamingMipmaps { get; }
        public int streamingMipmapsPriority { get; }
        public int requestedMipmapLevel { get; set; }
        public int desiredMipmapLevel { get; }
        public int loadingMipmapLevel { get; }
        public int loadedMipmapLevel { get; }

        [FreeFunction("CubemapScripting::UpdateExternalTexture", HasExplicitThis = True)]
        public void UpdateExternalTexture(IntPtr nativeTexture);
        [NativeName("FixupEdges")]
        public void SmoothEdges([DefaultValue("1")] int smoothRegionWidthInPixels);
        public void SmoothEdges();
        [FreeFunction(Name = "CubemapScripting::GetPixels", HasExplicitThis = True, ThrowsException = True)]
        public Color[] GetPixels(CubemapFace face, int miplevel);
        public Color[] GetPixels(CubemapFace face);
        [FreeFunction(Name = "CubemapScripting::SetPixels", HasExplicitThis = True, ThrowsException = True)]
        public void SetPixels(Color[] colors, CubemapFace face, int miplevel);
        public void SetPixels(Color[] colors, CubemapFace face);
        [FreeFunction(Name = "GetTextureStreamingManager().ClearRequestedMipmapLevel", HasExplicitThis = True)]
        public void ClearRequestedMipmapLevel();
        [FreeFunction(Name = "GetTextureStreamingManager().IsRequestedMipmapLevelLoaded", HasExplicitThis = True)]
        public bool IsRequestedMipmapLevelLoaded();
        public static Cubemap CreateExternalTexture(int width, TextureFormat format, bool mipmap, IntPtr nativeTex);
        public void SetPixelData<T>(T[] data, int mipLevel, CubemapFace face, int sourceDataStartIndex = 0);
        public void SetPixelData<T>(NativeArray<T> data, int mipLevel, CubemapFace face, int sourceDataStartIndex = 0) where T : struct;
        public NativeArray<T> GetPixelData<T>(int mipLevel, CubemapFace face) where T : struct;
        public void SetPixel(CubemapFace face, int x, int y, Color color);
        public Color GetPixel(CubemapFace face, int x, int y);
        public void Apply([DefaultValue("true")] bool updateMipmaps, [DefaultValue("false")] bool makeNoLongerReadable);
        public void Apply(bool updateMipmaps);
        public void Apply();
    }
}
using System;
using Unity.Collections;
using UnityEngine.Bindings;
using UnityEngine.Experimental.Rendering;
using UnityEngine.Internal;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [ExcludeFromPreset]
    [NativeHeader("Runtime/Graphics/Texture3D.h")]
    public sealed class Texture3D : Texture
    {
        public Texture3D(int width, int height, int depth, DefaultFormat format, TextureCreationFlags flags);
        [RequiredByNativeCode]
        public Texture3D(int width, int height, int depth, GraphicsFormat format, TextureCreationFlags flags);
        public Texture3D(int width, int height, int depth, GraphicsFormat format, TextureCreationFlags flags, int mipCount);
        public Texture3D(int width, int height, int depth, TextureFormat textureFormat, int mipCount);
        public Texture3D(int width, int height, int depth, TextureFormat textureFormat, int mipCount, IntPtr nativeTex);
        public Texture3D(int width, int height, int depth, TextureFormat textureFormat, bool mipChain);
        public Texture3D(int width, int height, int depth, TextureFormat textureFormat, bool mipChain, IntPtr nativeTex);

        public int depth { get; }
        public TextureFormat format { get; }
        public override bool isReadable { get; }

        [FreeFunction("Texture3DScripting::UpdateExternalTexture", HasExplicitThis = True)]
        public void UpdateExternalTexture(IntPtr nativeTex);
        [FreeFunction(Name = "Texture3DScripting::GetPixels", HasExplicitThis = True, ThrowsException = True)]
        public Color[] GetPixels(int miplevel);
        public Color[] GetPixels();
        [FreeFunction(Name = "Texture3DScripting::GetPixels32", HasExplicitThis = True, ThrowsException = True)]
        public Color32[] GetPixels32(int miplevel);
        public Color32[] GetPixels32();
        [FreeFunction(Name = "Texture3DScripting::SetPixels", HasExplicitThis = True, ThrowsException = True)]
        public void SetPixels(Color[] colors, int miplevel);
        public void SetPixels(Color[] colors);
        [FreeFunction(Name = "Texture3DScripting::SetPixels32", HasExplicitThis = True, ThrowsException = True)]
        public void SetPixels32(Color32[] colors, int miplevel);
        public void SetPixels32(Color32[] colors);
        public static Texture3D CreateExternalTexture(int width, int height, int depth, TextureFormat format, bool mipChain, IntPtr nativeTex);
        public void Apply([DefaultValue("true")] bool updateMipmaps, [DefaultValue("false")] bool makeNoLongerReadable);
        public void Apply(bool updateMipmaps);
        public void Apply();
        public void SetPixel(int x, int y, int z, Color color);
        public void SetPixel(int x, int y, int z, Color color, int mipLevel);
        public Color GetPixel(int x, int y, int z);
        public Color GetPixel(int x, int y, int z, int mipLevel);
        public Color GetPixelBilinear(float u, float v, float w);
        public Color GetPixelBilinear(float u, float v, float w, int mipLevel);
        public void SetPixelData<T>(T[] data, int mipLevel, int sourceDataStartIndex = 0);
        public void SetPixelData<T>(NativeArray<T> data, int mipLevel, int sourceDataStartIndex = 0) where T : struct;
        public NativeArray<T> GetPixelData<T>(int mipLevel) where T : struct;
    }
}
using Unity.Collections;
using UnityEngine.Bindings;
using UnityEngine.Experimental.Rendering;
using UnityEngine.Internal;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Runtime/Graphics/Texture2DArray.h")]
    public sealed class Texture2DArray : Texture
    {
        public Texture2DArray(int width, int height, int depth, DefaultFormat format, TextureCreationFlags flags);
        [RequiredByNativeCode]
        public Texture2DArray(int width, int height, int depth, GraphicsFormat format, TextureCreationFlags flags);
        public Texture2DArray(int width, int height, int depth, GraphicsFormat format, TextureCreationFlags flags, int mipCount);
        public Texture2DArray(int width, int height, int depth, TextureFormat textureFormat, int mipCount, [DefaultValue("true")] bool linear);
        public Texture2DArray(int width, int height, int depth, TextureFormat textureFormat, bool mipChain, [DefaultValue("true")] bool linear);
        public Texture2DArray(int width, int height, int depth, TextureFormat textureFormat, bool mipChain);

        public static int allSlices { get; }
        public int depth { get; }
        public TextureFormat format { get; }
        public override bool isReadable { get; }

        [FreeFunction(Name = "Texture2DArrayScripting::GetPixels", HasExplicitThis = True, ThrowsException = True)]
        public Color[] GetPixels(int arrayElement, int miplevel);
        public Color[] GetPixels(int arrayElement);
        [FreeFunction(Name = "Texture2DArrayScripting::GetPixels32", HasExplicitThis = True, ThrowsException = True)]
        public Color32[] GetPixels32(int arrayElement, int miplevel);
        public Color32[] GetPixels32(int arrayElement);
        [FreeFunction(Name = "Texture2DArrayScripting::SetPixels", HasExplicitThis = True, ThrowsException = True)]
        public void SetPixels(Color[] colors, int arrayElement, int miplevel);
        public void SetPixels(Color[] colors, int arrayElement);
        [FreeFunction(Name = "Texture2DArrayScripting::SetPixels32", HasExplicitThis = True, ThrowsException = True)]
        public void SetPixels32(Color32[] colors, int arrayElement, int miplevel);
        public void SetPixels32(Color32[] colors, int arrayElement);
        public void Apply([DefaultValue("true")] bool updateMipmaps, [DefaultValue("false")] bool makeNoLongerReadable);
        public void SetPixelData<T>(T[] data, int mipLevel, int element, int sourceDataStartIndex = 0);
        public void SetPixelData<T>(NativeArray<T> data, int mipLevel, int element, int sourceDataStartIndex = 0) where T : struct;
        public NativeArray<T> GetPixelData<T>(int mipLevel, int element) where T : struct;
        public void Apply(bool updateMipmaps);
        public void Apply();
    }
}
using Unity.Collections;
using UnityEngine.Bindings;
using UnityEngine.Experimental.Rendering;
using UnityEngine.Internal;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Runtime/Graphics/CubemapArrayTexture.h")]
    [ExcludeFromPreset]
    public sealed class CubemapArray : Texture
    {
        public CubemapArray(int width, int cubemapCount, DefaultFormat format, TextureCreationFlags flags);
        [RequiredByNativeCode]
        public CubemapArray(int width, int cubemapCount, GraphicsFormat format, TextureCreationFlags flags);
        public CubemapArray(int width, int cubemapCount, GraphicsFormat format, TextureCreationFlags flags, int mipCount);
        public CubemapArray(int width, int cubemapCount, TextureFormat textureFormat, int mipCount, [DefaultValue("true")] bool linear);
        public CubemapArray(int width, int cubemapCount, TextureFormat textureFormat, bool mipChain, [DefaultValue("true")] bool linear);
        public CubemapArray(int width, int cubemapCount, TextureFormat textureFormat, bool mipChain);

        public int cubemapCount { get; }
        public TextureFormat format { get; }
        public override bool isReadable { get; }

        [FreeFunction(Name = "CubemapArrayScripting::GetPixels", HasExplicitThis = True, ThrowsException = True)]
        public Color[] GetPixels(CubemapFace face, int arrayElement, int miplevel);
        public Color[] GetPixels(CubemapFace face, int arrayElement);
        [FreeFunction(Name = "CubemapArrayScripting::GetPixels32", HasExplicitThis = True, ThrowsException = True)]
        public Color32[] GetPixels32(CubemapFace face, int arrayElement, int miplevel);
        public Color32[] GetPixels32(CubemapFace face, int arrayElement);
        [FreeFunction(Name = "CubemapArrayScripting::SetPixels", HasExplicitThis = True, ThrowsException = True)]
        public void SetPixels(Color[] colors, CubemapFace face, int arrayElement, int miplevel);
        public void SetPixels(Color[] colors, CubemapFace face, int arrayElement);
        [FreeFunction(Name = "CubemapArrayScripting::SetPixels32", HasExplicitThis = True, ThrowsException = True)]
        public void SetPixels32(Color32[] colors, CubemapFace face, int arrayElement, int miplevel);
        public void SetPixels32(Color32[] colors, CubemapFace face, int arrayElement);
        public void Apply([DefaultValue("true")] bool updateMipmaps, [DefaultValue("false")] bool makeNoLongerReadable);
        public void Apply(bool updateMipmaps);
        public void Apply();
        public void SetPixelData<T>(T[] data, int mipLevel, CubemapFace face, int element, int sourceDataStartIndex = 0);
        public void SetPixelData<T>(NativeArray<T> data, int mipLevel, CubemapFace face, int element, int sourceDataStartIndex = 0) where T : struct;
        public NativeArray<T> GetPixelData<T>(int mipLevel, CubemapFace face, int element) where T : struct;
    }
}
using UnityEngine.Bindings;
using UnityEngine.Experimental.Rendering;

namespace UnityEngine
{
    [NativeHeader("Runtime/Graphics/SparseTexture.h")]
    public sealed class SparseTexture : Texture
    {
        public SparseTexture(int width, int height, DefaultFormat format, int mipCount);
        public SparseTexture(int width, int height, GraphicsFormat format, int mipCount);
        public SparseTexture(int width, int height, TextureFormat textureFormat, int mipCount);
        public SparseTexture(int width, int height, TextureFormat textureFormat, int mipCount, bool linear);

        public int tileWidth { get; }
        public int tileHeight { get; }
        public bool isCreated { get; }

        [FreeFunction(Name = "SparseTextureScripting::UpdateTile", HasExplicitThis = True)]
        public void UpdateTile(int tileX, int tileY, int miplevel, Color32[] data);
        [FreeFunction(Name = "SparseTextureScripting::UpdateTileRaw", HasExplicitThis = True)]
        public void UpdateTileRaw(int tileX, int tileY, int miplevel, byte[] data);
        public void UnloadTile(int tileX, int tileY, int miplevel);
    }
}
using System;
using System.ComponentModel;
using UnityEngine.Bindings;
using UnityEngine.Experimental.Rendering;
using UnityEngine.Internal;
using UnityEngine.Rendering;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Runtime/Camera/Camera.h")]
    [UsedByNativeCode]
    [NativeHeader("Runtime/Graphics/RenderTexture.h")]
    [NativeHeader("Runtime/Graphics/RenderBufferManager.h")]
    [NativeHeader("Runtime/Graphics/GraphicsScriptBindings.h")]
    public class RenderTexture : Texture
    {
        [RequiredByNativeCode]
        protected internal RenderTexture();
        public RenderTexture(RenderTextureDescriptor desc);
        public RenderTexture(RenderTexture textureToCopy);
        public RenderTexture(int width, int height, int depth, DefaultFormat format);
        public RenderTexture(int width, int height, int depth, GraphicsFormat format);
        public RenderTexture(int width, int height, int depth, GraphicsFormat format, int mipCount);
        public RenderTexture(int width, int height, int depth, [UnityEngine.Internal.DefaultValue("RenderTextureFormat.Default")] RenderTextureFormat format, [UnityEngine.Internal.DefaultValue("RenderTextureReadWrite.Default")] RenderTextureReadWrite readWrite);
        [ExcludeFromDocs]
        public RenderTexture(int width, int height, int depth, RenderTextureFormat format);
        [ExcludeFromDocs]
        public RenderTexture(int width, int height, int depth);
        [ExcludeFromDocs]
        public RenderTexture(int width, int height, int depth, RenderTextureFormat format, int mipCount);

        public override int width { get; set; }
        public override int height { get; set; }
        public override TextureDimension dimension { get; set; }
        [NativeProperty("ColorFormat")]
        public GraphicsFormat graphicsFormat { get; set; }
        [NativeProperty("MipMap")]
        public bool useMipMap { get; set; }
        [NativeProperty("SRGBReadWrite")]
        public bool sRGB { get; }
        [NativeProperty("VRUsage")]
        public VRTextureUsage vrUsage { get; set; }
        [NativeProperty("Memoryless")]
        public RenderTextureMemoryless memorylessMode { get; set; }
        public RenderTextureFormat format { get; set; }
        public GraphicsFormat stencilFormat { get; set; }
        public bool autoGenerateMips { get; set; }
        public int volumeDepth { get; set; }
        public int antiAliasing { get; set; }
        public bool bindTextureMS { get; set; }
        public bool enableRandomWrite { get; set; }
        public bool useDynamicScale { get; set; }
        public bool isPowerOfTwo { get; set; }
        public static RenderTexture active { get; set; }
        public RenderBuffer colorBuffer { get; }
        public RenderBuffer depthBuffer { get; }
        public int depth { get; set; }
        public RenderTextureDescriptor descriptor { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("Use RenderTexture.autoGenerateMips instead (UnityUpgradable) -> autoGenerateMips", False)]
        public bool generateMips { get; set; }
        [Obsolete("Use RenderTexture.dimension instead.", False)]
        public bool isCubemap { get; set; }
        [Obsolete("Use RenderTexture.dimension instead.", False)]
        public bool isVolume { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("RenderTexture.enabled is always now, no need to use it.", False)]
        public static bool enabled { get; set; }

        public IntPtr GetNativeDepthBufferPtr();
        public void DiscardContents(bool discardColor, bool discardDepth);
        public void MarkRestoreExpected();
        public void DiscardContents();
        public void ResolveAntiAliasedSurface();
        public void ResolveAntiAliasedSurface(RenderTexture target);
        [FreeFunction(Name = "RenderTextureScripting::SetGlobalShaderProperty", HasExplicitThis = True)]
        public void SetGlobalShaderProperty(string propertyName);
        public bool Create();
        public void Release();
        public bool IsCreated();
        public void GenerateMips();
        [NativeThrows]
        public void ConvertToEquirect(RenderTexture equirect, Camera.MonoOrStereoscopicEye eye = Mono);
        [FreeFunction("RenderTextureSupportsStencil")]
        public static bool SupportsStencil(RenderTexture rt);
        [FreeFunction("GetRenderBufferManager().GetTextures().ReleaseTempBuffer")]
        public static void ReleaseTemporary(RenderTexture temp);
        public static RenderTexture GetTemporary(RenderTextureDescriptor desc);
        [ExcludeFromDocs]
        public static RenderTexture GetTemporary(int width, int height, int depthBuffer, GraphicsFormat format, [UnityEngine.Internal.DefaultValue("1")] int antiAliasing, [UnityEngine.Internal.DefaultValue("RenderTextureMemoryless.None")] RenderTextureMemoryless memorylessMode, [UnityEngine.Internal.DefaultValue("VRTextureUsage.None")] VRTextureUsage vrUsage, [UnityEngine.Internal.DefaultValue("false")] bool useDynamicScale);
        [ExcludeFromDocs]
        public static RenderTexture GetTemporary(int width, int height, int depthBuffer, GraphicsFormat format, int antiAliasing, RenderTextureMemoryless memorylessMode, VRTextureUsage vrUsage);
        [ExcludeFromDocs]
        public static RenderTexture GetTemporary(int width, int height, int depthBuffer, GraphicsFormat format, int antiAliasing, RenderTextureMemoryless memorylessMode);
        [ExcludeFromDocs]
        public static RenderTexture GetTemporary(int width, int height, int depthBuffer, GraphicsFormat format, int antiAliasing);
        [ExcludeFromDocs]
        public static RenderTexture GetTemporary(int width, int height, int depthBuffer, GraphicsFormat format);
        public static RenderTexture GetTemporary(int width, int height, [UnityEngine.Internal.DefaultValue("0")] int depthBuffer, [UnityEngine.Internal.DefaultValue("RenderTextureFormat.Default")] RenderTextureFormat format, [UnityEngine.Internal.DefaultValue("RenderTextureReadWrite.Default")] RenderTextureReadWrite readWrite, [UnityEngine.Internal.DefaultValue("1")] int antiAliasing, [UnityEngine.Internal.DefaultValue("RenderTextureMemoryless.None")] RenderTextureMemoryless memorylessMode, [UnityEngine.Internal.DefaultValue("VRTextureUsage.None")] VRTextureUsage vrUsage, [UnityEngine.Internal.DefaultValue("false")] bool useDynamicScale);
        [ExcludeFromDocs]
        public static RenderTexture GetTemporary(int width, int height, int depthBuffer, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing, RenderTextureMemoryless memorylessMode, VRTextureUsage vrUsage);
        [ExcludeFromDocs]
        public static RenderTexture GetTemporary(int width, int height, int depthBuffer, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing, RenderTextureMemoryless memorylessMode);
        [ExcludeFromDocs]
        public static RenderTexture GetTemporary(int width, int height, int depthBuffer, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing);
        [ExcludeFromDocs]
        public static RenderTexture GetTemporary(int width, int height, int depthBuffer, RenderTextureFormat format, RenderTextureReadWrite readWrite);
        [ExcludeFromDocs]
        public static RenderTexture GetTemporary(int width, int height, int depthBuffer, RenderTextureFormat format);
        [ExcludeFromDocs]
        public static RenderTexture GetTemporary(int width, int height, int depthBuffer);
        [ExcludeFromDocs]
        public static RenderTexture GetTemporary(int width, int height);
        [EditorBrowsable(Never)]
        [Obsolete("UsSetBorderColor is no longer supported.", True)]
        public void SetBorderColor(Color color);
        [Obsolete("GetTexelOffset always returns zero now, no point in using it.", False)]
        [EditorBrowsable(Never)]
        public Vector2 GetTexelOffset();
    }
}
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    public struct CustomRenderTextureUpdateZone
    {
        public Vector3 updateZoneCenter;
        public Vector3 updateZoneSize;
        public float rotation;
        public int passIndex;
        public bool needSwap;
    }
}
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Experimental.Rendering;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    [NativeHeader("Runtime/Graphics/CustomRenderTexture.h")]
    public sealed class CustomRenderTexture : RenderTexture
    {
        public CustomRenderTexture(int width, int height, RenderTextureFormat format, RenderTextureReadWrite readWrite);
        public CustomRenderTexture(int width, int height, RenderTextureFormat format);
        public CustomRenderTexture(int width, int height);
        public CustomRenderTexture(int width, int height, DefaultFormat defaultFormat);
        public CustomRenderTexture(int width, int height, GraphicsFormat format);

        public Material material { get; set; }
        public Material initializationMaterial { get; set; }
        public Texture initializationTexture { get; set; }
        public CustomRenderTextureInitializationSource initializationSource { get; set; }
        public Color initializationColor { get; set; }
        public CustomRenderTextureUpdateMode updateMode { get; set; }
        public CustomRenderTextureUpdateMode initializationMode { get; set; }
        public CustomRenderTextureUpdateZoneSpace updateZoneSpace { get; set; }
        public int shaderPass { get; set; }
        public uint cubemapFaceMask { get; set; }
        public bool doubleBuffered { get; set; }
        public bool wrapUpdateZones { get; set; }
        public float updatePeriod { get; set; }

        public void Update(int count);
        public void Update();
        public void Initialize();
        public void ClearUpdateZones();
        public void GetUpdateZones(List<CustomRenderTextureUpdateZone> updateZones);
        [FreeFunction(Name = "CustomRenderTextureScripting::GetDoubleBufferRenderTexture", HasExplicitThis = True)]
        public RenderTexture GetDoubleBufferRenderTexture();
        public void EnsureDoubleBufferConsistency();
        public void SetUpdateZones(CustomRenderTextureUpdateZone[] updateZones);
    }
}
using UnityEngine.Experimental.Rendering;
using UnityEngine.Rendering;

namespace UnityEngine
{
    public struct RenderTextureDescriptor
    {
        public RenderTextureDescriptor(int width, int height);
        public RenderTextureDescriptor(int width, int height, RenderTextureFormat colorFormat);
        public RenderTextureDescriptor(int width, int height, RenderTextureFormat colorFormat, int depthBufferBits);
        public RenderTextureDescriptor(int width, int height, GraphicsFormat colorFormat, int depthBufferBits);
        public RenderTextureDescriptor(int width, int height, RenderTextureFormat colorFormat, int depthBufferBits, int mipCount);
        public RenderTextureDescriptor(int width, int height, GraphicsFormat colorFormat, int depthBufferBits, int mipCount);

        public int width { get; set; }
        public int height { get; set; }
        public int msaaSamples { get; set; }
        public int volumeDepth { get; set; }
        public int mipCount { get; set; }
        public GraphicsFormat graphicsFormat { get; set; }
        public GraphicsFormat stencilFormat { get; set; }
        public RenderTextureFormat colorFormat { get; set; }
        public bool sRGB { get; set; }
        public int depthBufferBits { get; set; }
        public TextureDimension dimension { get; set; }
        public ShadowSamplingMode shadowSamplingMode { get; set; }
        public VRTextureUsage vrUsage { get; set; }
        public RenderTextureCreationFlags flags { get; }
        public RenderTextureMemoryless memoryless { get; set; }
        public bool useMipMap { get; set; }
        public bool autoGenerateMips { get; set; }
        public bool enableRandomWrite { get; set; }
        public bool bindMS { get; set; }
        public bool useDynamicScale { get; set; }
    }
}
namespace UnityEngine
{
    public enum FullScreenMovieControlMode
    {
        Full = 0,
        Minimal = 1,
        CancelOnInput = 2,
        Hidden = 3
    }
}
namespace UnityEngine
{
    public enum FullScreenMovieScalingMode
    {
        None = 0,
        AspectFit = 1,
        AspectFill = 2,
        Fill = 3
    }
}
namespace UnityEngine
{
    public enum AndroidActivityIndicatorStyle
    {
        DontShow = -1,
        Large = 0,
        InversedLarge = 1,
        Small = 2,
        InversedSmall = 3
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Internal;
using UnityEngine.iOS;

namespace UnityEngine
{
    [NativeHeader("Runtime/Export/Handheld/Handheld.bindings.h")]
    [NativeHeader("Runtime/Input/GetInput.h")]
    [NativeHeader("Runtime/Video/MoviePlayback.h")]
    public class Handheld
    {
        public Handheld();

        [Obsolete("Property Handheld.use32BitDisplayBuffer has been deprecated. Modifying it has no effect, use PlayerSettings instead.")]
        public static bool use32BitDisplayBuffer { get; set; }

        public static bool PlayFullScreenMovie(string path, [DefaultValue("Color.black")] Color bgColor, [DefaultValue("FullScreenMovieControlMode.Full")] FullScreenMovieControlMode controlMode, [DefaultValue("FullScreenMovieScalingMode.AspectFit")] FullScreenMovieScalingMode scalingMode);
        [ExcludeFromDocs]
        public static bool PlayFullScreenMovie(string path, Color bgColor, FullScreenMovieControlMode controlMode);
        [ExcludeFromDocs]
        public static bool PlayFullScreenMovie(string path, Color bgColor);
        [ExcludeFromDocs]
        public static bool PlayFullScreenMovie(string path);
        [FreeFunction("Vibrate")]
        public static void Vibrate();
        public static void SetActivityIndicatorStyle(ActivityIndicatorStyle style);
        public static void SetActivityIndicatorStyle(AndroidActivityIndicatorStyle style);
        [FreeFunction("GetActivityIndicatorStyle_Bindings")]
        public static int GetActivityIndicatorStyle();
        [FreeFunction("StartActivityIndicator_Bindings")]
        public static void StartActivityIndicator();
        [FreeFunction("StopActivityIndicator_Bindings")]
        public static void StopActivityIndicator();
        [FreeFunction("ClearShaderCache_Bindings")]
        public static void ClearShaderCache();
    }
}
using System;
using System.Collections.Generic;
using Unity.Collections;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Runtime/Utilities/Hash128.h")]
    [UsedByNativeCode]
    [NativeHeader("Runtime/Export/Hashing/Hash128.bindings.h")]
    public struct Hash128 : IComparable, IComparable<Hash128>, IEquatable<Hash128>
    {
        public Hash128(uint u32_0, uint u32_1, uint u32_2, uint u32_3);
        public Hash128(ulong u64_0, ulong u64_1);

        public bool isValid { get; }

        public int CompareTo(Hash128 rhs);
        public override string ToString();
        [FreeFunction("StringToHash128", IsThreadSafe = True)]
        public static Hash128 Parse(string hashString);
        public static Hash128 Compute(string data);
        public static Hash128 Compute<T>(NativeArray<T> data) where T : struct;
        public static Hash128 Compute<T>(NativeArray<T> data, int start, int count) where T : struct;
        public static Hash128 Compute<T>(T[] data) where T : struct;
        public static Hash128 Compute<T>(T[] data, int start, int count) where T : struct;
        public static Hash128 Compute<T>(List<T> data) where T : struct;
        public static Hash128 Compute<T>(List<T> data, int start, int count) where T : struct;
        public static Hash128 Compute<T>(ref T val) where T : unmanaged;
        public static Hash128 Compute(int val);
        public static Hash128 Compute(float val);
        public static Hash128 Compute(void* data, ulong size);
        public void Append(string data);
        public void Append<T>(NativeArray<T> data) where T : struct;
        public void Append<T>(NativeArray<T> data, int start, int count) where T : struct;
        public void Append<T>(T[] data) where T : struct;
        public void Append<T>(T[] data, int start, int count) where T : struct;
        public void Append<T>(List<T> data) where T : struct;
        public void Append<T>(List<T> data, int start, int count) where T : struct;
        public void Append<T>(ref T val) where T : unmanaged;
        public void Append(int val);
        public void Append(float val);
        public void Append(void* data, ulong size);
        public override bool Equals(object obj);
        public bool Equals(Hash128 obj);
        public override int GetHashCode();
        public int CompareTo(object obj);

        public static bool operator ==(Hash128 hash1, Hash128 hash2);
        public static bool operator !=(Hash128 hash1, Hash128 hash2);
        public static bool operator <(Hash128 x, Hash128 y);
        public static bool operator >(Hash128 x, Hash128 y);
    }
}
namespace UnityEngine
{
    public static class HashUtilities
    {
        public static void AppendHash(ref Hash128 inHash, ref Hash128 outHash);
        public static void QuantisedMatrixHash(ref Matrix4x4 value, ref Hash128 hash);
        public static void QuantisedVectorHash(ref Vector3 value, ref Hash128 hash);
        public static void ComputeHash128<T>(ref T value, ref Hash128 hash) where T : struct;
        public static void ComputeHash128(byte[] value, ref Hash128 hash);
    }
}
namespace UnityEngine
{
    public static class HashUnsafeUtilities
    {
        public static void ComputeHash128(void* data, ulong dataSize, ulong* hash1, ulong* hash2);
        public static void ComputeHash128(void* data, ulong dataSize, Hash128* hash);
    }
}
namespace UnityEngine
{
    public enum CursorMode
    {
        Auto = 0,
        ForceSoftware = 1
    }
}
namespace UnityEngine
{
    public enum CursorLockMode
    {
        None = 0,
        Locked = 1,
        Confined = 2
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Export/Input/Cursor.bindings.h")]
    public class Cursor
    {
        public Cursor();

        public static bool visible { get; set; }
        public static CursorLockMode lockState { get; set; }

        public static void SetCursor(Texture2D texture, Vector2 hotspot, CursorMode cursorMode);
    }
}
namespace UnityEngine
{
    public enum KeyCode
    {
        None = 0,
        Backspace = 8,
        Delete = 127,
        Tab = 9,
        Clear = 12,
        Return = 13,
        Pause = 19,
        Escape = 27,
        Space = 32,
        Keypad0 = 256,
        Keypad1 = 257,
        Keypad2 = 258,
        Keypad3 = 259,
        Keypad4 = 260,
        Keypad5 = 261,
        Keypad6 = 262,
        Keypad7 = 263,
        Keypad8 = 264,
        Keypad9 = 265,
        KeypadPeriod = 266,
        KeypadDivide = 267,
        KeypadMultiply = 268,
        KeypadMinus = 269,
        KeypadPlus = 270,
        KeypadEnter = 271,
        KeypadEquals = 272,
        UpArrow = 273,
        DownArrow = 274,
        RightArrow = 275,
        LeftArrow = 276,
        Insert = 277,
        Home = 278,
        End = 279,
        PageUp = 280,
        PageDown = 281,
        F1 = 282,
        F2 = 283,
        F3 = 284,
        F4 = 285,
        F5 = 286,
        F6 = 287,
        F7 = 288,
        F8 = 289,
        F9 = 290,
        F10 = 291,
        F11 = 292,
        F12 = 293,
        F13 = 294,
        F14 = 295,
        F15 = 296,
        Alpha0 = 48,
        Alpha1 = 49,
        Alpha2 = 50,
        Alpha3 = 51,
        Alpha4 = 52,
        Alpha5 = 53,
        Alpha6 = 54,
        Alpha7 = 55,
        Alpha8 = 56,
        Alpha9 = 57,
        Exclaim = 33,
        DoubleQuote = 34,
        Hash = 35,
        Dollar = 36,
        Percent = 37,
        Ampersand = 38,
        Quote = 39,
        LeftParen = 40,
        RightParen = 41,
        Asterisk = 42,
        Plus = 43,
        Comma = 44,
        Minus = 45,
        Period = 46,
        Slash = 47,
        Colon = 58,
        Semicolon = 59,
        Less = 60,
        Equals = 61,
        Greater = 62,
        Question = 63,
        At = 64,
        LeftBracket = 91,
        Backslash = 92,
        RightBracket = 93,
        Caret = 94,
        Underscore = 95,
        BackQuote = 96,
        A = 97,
        B = 98,
        C = 99,
        D = 100,
        E = 101,
        F = 102,
        G = 103,
        H = 104,
        I = 105,
        J = 106,
        K = 107,
        L = 108,
        M = 109,
        N = 110,
        O = 111,
        P = 112,
        Q = 113,
        R = 114,
        S = 115,
        T = 116,
        U = 117,
        V = 118,
        W = 119,
        X = 120,
        Y = 121,
        Z = 122,
        LeftCurlyBracket = 123,
        Pipe = 124,
        RightCurlyBracket = 125,
        Tilde = 126,
        Numlock = 300,
        CapsLock = 301,
        ScrollLock = 302,
        RightShift = 303,
        LeftShift = 304,
        RightControl = 305,
        LeftControl = 306,
        RightAlt = 307,
        LeftAlt = 308,
        LeftCommand = 310,
        LeftApple = 310,
        LeftWindows = 311,
        RightCommand = 309,
        RightApple = 309,
        RightWindows = 312,
        AltGr = 313,
        Help = 315,
        Print = 316,
        SysReq = 317,
        Break = 318,
        Menu = 319,
        Mouse0 = 323,
        Mouse1 = 324,
        Mouse2 = 325,
        Mouse3 = 326,
        Mouse4 = 327,
        Mouse5 = 328,
        Mouse6 = 329,
        JoystickButton0 = 330,
        JoystickButton1 = 331,
        JoystickButton2 = 332,
        JoystickButton3 = 333,
        JoystickButton4 = 334,
        JoystickButton5 = 335,
        JoystickButton6 = 336,
        JoystickButton7 = 337,
        JoystickButton8 = 338,
        JoystickButton9 = 339,
        JoystickButton10 = 340,
        JoystickButton11 = 341,
        JoystickButton12 = 342,
        JoystickButton13 = 343,
        JoystickButton14 = 344,
        JoystickButton15 = 345,
        JoystickButton16 = 346,
        JoystickButton17 = 347,
        JoystickButton18 = 348,
        JoystickButton19 = 349,
        Joystick1Button0 = 350,
        Joystick1Button1 = 351,
        Joystick1Button2 = 352,
        Joystick1Button3 = 353,
        Joystick1Button4 = 354,
        Joystick1Button5 = 355,
        Joystick1Button6 = 356,
        Joystick1Button7 = 357,
        Joystick1Button8 = 358,
        Joystick1Button9 = 359,
        Joystick1Button10 = 360,
        Joystick1Button11 = 361,
        Joystick1Button12 = 362,
        Joystick1Button13 = 363,
        Joystick1Button14 = 364,
        Joystick1Button15 = 365,
        Joystick1Button16 = 366,
        Joystick1Button17 = 367,
        Joystick1Button18 = 368,
        Joystick1Button19 = 369,
        Joystick2Button0 = 370,
        Joystick2Button1 = 371,
        Joystick2Button2 = 372,
        Joystick2Button3 = 373,
        Joystick2Button4 = 374,
        Joystick2Button5 = 375,
        Joystick2Button6 = 376,
        Joystick2Button7 = 377,
        Joystick2Button8 = 378,
        Joystick2Button9 = 379,
        Joystick2Button10 = 380,
        Joystick2Button11 = 381,
        Joystick2Button12 = 382,
        Joystick2Button13 = 383,
        Joystick2Button14 = 384,
        Joystick2Button15 = 385,
        Joystick2Button16 = 386,
        Joystick2Button17 = 387,
        Joystick2Button18 = 388,
        Joystick2Button19 = 389,
        Joystick3Button0 = 390,
        Joystick3Button1 = 391,
        Joystick3Button2 = 392,
        Joystick3Button3 = 393,
        Joystick3Button4 = 394,
        Joystick3Button5 = 395,
        Joystick3Button6 = 396,
        Joystick3Button7 = 397,
        Joystick3Button8 = 398,
        Joystick3Button9 = 399,
        Joystick3Button10 = 400,
        Joystick3Button11 = 401,
        Joystick3Button12 = 402,
        Joystick3Button13 = 403,
        Joystick3Button14 = 404,
        Joystick3Button15 = 405,
        Joystick3Button16 = 406,
        Joystick3Button17 = 407,
        Joystick3Button18 = 408,
        Joystick3Button19 = 409,
        Joystick4Button0 = 410,
        Joystick4Button1 = 411,
        Joystick4Button2 = 412,
        Joystick4Button3 = 413,
        Joystick4Button4 = 414,
        Joystick4Button5 = 415,
        Joystick4Button6 = 416,
        Joystick4Button7 = 417,
        Joystick4Button8 = 418,
        Joystick4Button9 = 419,
        Joystick4Button10 = 420,
        Joystick4Button11 = 421,
        Joystick4Button12 = 422,
        Joystick4Button13 = 423,
        Joystick4Button14 = 424,
        Joystick4Button15 = 425,
        Joystick4Button16 = 426,
        Joystick4Button17 = 427,
        Joystick4Button18 = 428,
        Joystick4Button19 = 429,
        Joystick5Button0 = 430,
        Joystick5Button1 = 431,
        Joystick5Button2 = 432,
        Joystick5Button3 = 433,
        Joystick5Button4 = 434,
        Joystick5Button5 = 435,
        Joystick5Button6 = 436,
        Joystick5Button7 = 437,
        Joystick5Button8 = 438,
        Joystick5Button9 = 439,
        Joystick5Button10 = 440,
        Joystick5Button11 = 441,
        Joystick5Button12 = 442,
        Joystick5Button13 = 443,
        Joystick5Button14 = 444,
        Joystick5Button15 = 445,
        Joystick5Button16 = 446,
        Joystick5Button17 = 447,
        Joystick5Button18 = 448,
        Joystick5Button19 = 449,
        Joystick6Button0 = 450,
        Joystick6Button1 = 451,
        Joystick6Button2 = 452,
        Joystick6Button3 = 453,
        Joystick6Button4 = 454,
        Joystick6Button5 = 455,
        Joystick6Button6 = 456,
        Joystick6Button7 = 457,
        Joystick6Button8 = 458,
        Joystick6Button9 = 459,
        Joystick6Button10 = 460,
        Joystick6Button11 = 461,
        Joystick6Button12 = 462,
        Joystick6Button13 = 463,
        Joystick6Button14 = 464,
        Joystick6Button15 = 465,
        Joystick6Button16 = 466,
        Joystick6Button17 = 467,
        Joystick6Button18 = 468,
        Joystick6Button19 = 469,
        Joystick7Button0 = 470,
        Joystick7Button1 = 471,
        Joystick7Button2 = 472,
        Joystick7Button3 = 473,
        Joystick7Button4 = 474,
        Joystick7Button5 = 475,
        Joystick7Button6 = 476,
        Joystick7Button7 = 477,
        Joystick7Button8 = 478,
        Joystick7Button9 = 479,
        Joystick7Button10 = 480,
        Joystick7Button11 = 481,
        Joystick7Button12 = 482,
        Joystick7Button13 = 483,
        Joystick7Button14 = 484,
        Joystick7Button15 = 485,
        Joystick7Button16 = 486,
        Joystick7Button17 = 487,
        Joystick7Button18 = 488,
        Joystick7Button19 = 489,
        Joystick8Button0 = 490,
        Joystick8Button1 = 491,
        Joystick8Button2 = 492,
        Joystick8Button3 = 493,
        Joystick8Button4 = 494,
        Joystick8Button5 = 495,
        Joystick8Button6 = 496,
        Joystick8Button7 = 497,
        Joystick8Button8 = 498,
        Joystick8Button9 = 499,
        Joystick8Button10 = 500,
        Joystick8Button11 = 501,
        Joystick8Button12 = 502,
        Joystick8Button13 = 503,
        Joystick8Button14 = 504,
        Joystick8Button15 = 505,
        Joystick8Button16 = 506,
        Joystick8Button17 = 507,
        Joystick8Button18 = 508,
        Joystick8Button19 = 509
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [EditorBrowsable(Never)]
    [Obsolete("iPhoneScreenOrientation enumeration is deprecated. Please use ScreenOrientation instead (UnityUpgradable) -> ScreenOrientation", True)]
    public enum iPhoneScreenOrientation
    {
        Unknown = 0,
        Portrait = 1,
        PortraitUpsideDown = 2,
        LandscapeLeft = 3,
        LandscapeRight = 4,
        AutoRotation = 5,
        Landscape = 6
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [EditorBrowsable(Never)]
    [Obsolete("iPhoneNetworkReachability enumeration is deprecated. Please use NetworkReachability instead (UnityUpgradable) -> NetworkReachability", True)]
    public enum iPhoneNetworkReachability
    {
        NotReachable = 0,
        ReachableViaCarrierDataNetwork = 1,
        [Obsolete]
        ReachableViaWiFiNetwork = 2
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [EditorBrowsable(Never)]
    [Obsolete("iPhoneGeneration enumeration is deprecated. Please use iOS.DeviceGeneration instead (UnityUpgradable) -> UnityEngine.iOS.DeviceGeneration", True)]
    public enum iPhoneGeneration
    {
        Unknown = 0,
        iPhone = 1,
        iPhone3G = 2,
        iPhone3GS = 3,
        iPodTouch1Gen = 4,
        iPodTouch2Gen = 5,
        iPodTouch3Gen = 6,
        iPad1Gen = 7,
        iPhone4 = 8,
        iPodTouch4Gen = 9,
        iPad2Gen = 10,
        iPhone4S = 11,
        iPad3Gen = 12,
        iPhone5 = 13,
        iPodTouch5Gen = 14,
        iPadMini1Gen = 15,
        iPad4Gen = 16,
        iPhone5C = 17,
        iPhone5S = 18,
        iPhoneUnknown = 19,
        iPadUnknown = 20,
        iPodTouchUnknown = 21
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [EditorBrowsable(Never)]
    public class iPhoneSettings
    {
        public iPhoneSettings();

        [Obsolete("screenOrientation property is deprecated. Please use Screen.orientation instead (UnityUpgradable) -> Screen.orientation", True)]
        [EditorBrowsable(Never)]
        public static iPhoneScreenOrientation screenOrientation { get; }
        [Obsolete("uniqueIdentifier property is deprecated. Please use SystemInfo.deviceUniqueIdentifier instead (UnityUpgradable) -> SystemInfo.deviceUniqueIdentifier", True)]
        [EditorBrowsable(Never)]
        public static string uniqueIdentifier { get; }
        [Obsolete("name property is deprecated (UnityUpgradable). Please use SystemInfo.deviceName instead (UnityUpgradable) -> SystemInfo.deviceName", True)]
        [EditorBrowsable(Never)]
        public static string name { get; }
        [Obsolete("model property is deprecated. Please use SystemInfo.deviceModel instead (UnityUpgradable) -> SystemInfo.deviceModel", True)]
        [EditorBrowsable(Never)]
        public static string model { get; }
        [EditorBrowsable(Never)]
        [Obsolete("systemName property is deprecated. Please use SystemInfo.operatingSystem instead (UnityUpgradable) -> SystemInfo.operatingSystem", True)]
        public static string systemName { get; }
        [EditorBrowsable(Never)]
        [Obsolete("internetReachability property is deprecated. Please use Application.internetReachability instead (UnityUpgradable) -> Application.internetReachability", True)]
        public static iPhoneNetworkReachability internetReachability { get; }
        [EditorBrowsable(Never)]
        [Obsolete("systemVersion property is deprecated. Please use iOS.Device.systemVersion instead (UnityUpgradable) -> UnityEngine.iOS.Device.systemVersion", True)]
        public static string systemVersion { get; }
        [EditorBrowsable(Never)]
        [Obsolete("generation property is deprecated. Please use iOS.Device.generation instead (UnityUpgradable) -> UnityEngine.iOS.Device.generation", True)]
        public static iPhoneGeneration generation { get; }
        [Obsolete("verticalOrientation property is deprecated. Please use Screen.orientation == ScreenOrientation.Portrait || Screen.orientation == ScreenOrientation.PortraitUpsideDown instead.", False)]
        public static bool verticalOrientation { get; }
        [Obsolete("screenCanDarken property is deprecated. Please use (Screen.sleepTimeout != SleepTimeout.NeverSleep) instead.", False)]
        public static bool screenCanDarken { get; }
        [Obsolete("locationServiceEnabledByUser property is deprecated. Please use Input.location.isEnabledByUser instead.", True)]
        public static bool locationServiceEnabledByUser { get; }

        [Obsolete("StartLocationServiceUpdates method is deprecated. Please use Input.location.Start instead.", True)]
        public static void StartLocationServiceUpdates(float desiredAccuracyInMeters, float updateDistanceInMeters);
        [Obsolete("StartLocationServiceUpdates method is deprecated. Please use Input.location.Start instead.", True)]
        public static void StartLocationServiceUpdates(float desiredAccuracyInMeters);
        [Obsolete("StartLocationServiceUpdates method is deprecated. Please use Input.location.Start instead.", True)]
        public static void StartLocationServiceUpdates();
        [Obsolete("StopLocationServiceUpdates method is deprecated. Please use Input.location.Stop instead.", True)]
        public static void StopLocationServiceUpdates();
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [EditorBrowsable(Never)]
    [Obsolete("iPhoneTouchPhase enumeration is deprecated. Please use TouchPhase instead (UnityUpgradable) -> TouchPhase", True)]
    public enum iPhoneTouchPhase
    {
        Began = 0,
        Moved = 1,
        Stationary = 2,
        Ended = 3,
        Canceled = 4
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [Obsolete("iPhoneTouch struct is deprecated. Please use Touch instead (UnityUpgradable) -> Touch", True)]
    [EditorBrowsable(Never)]
    public struct iPhoneTouch
    {
        [EditorBrowsable(Never)]
        [Obsolete("positionDelta property is deprecated. Please use Touch.deltaPosition instead (UnityUpgradable) -> Touch.deltaPosition", True)]
        public Vector2 positionDelta { get; }
        [Obsolete("timeDelta property is deprecated. Please use Touch.deltaTime instead (UnityUpgradable) -> Touch.deltaTime", True)]
        [EditorBrowsable(Never)]
        public float timeDelta { get; }
        public int fingerId { get; }
        public Vector2 position { get; }
        public Vector2 deltaPosition { get; }
        public float deltaTime { get; }
        public int tapCount { get; }
        public iPhoneTouchPhase phase { get; }
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [EditorBrowsable(Never)]
    [Obsolete("iPhoneMovieControlMode enumeration is deprecated. Please use FullScreenMovieControlMode instead (UnityUpgradable) -> FullScreenMovieControlMode", True)]
    public enum iPhoneMovieControlMode
    {
        Full = 0,
        Minimal = 1,
        [Obsolete]
        CancelOnTouch = 2,
        Hidden = 3,
        [Obsolete]
        VolumeOnly = 4
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [Obsolete("iPhoneMovieScalingMode enumeration is deprecated. Please use FullScreenMovieScalingMode instead  (UnityUpgradable) -> FullScreenMovieScalingMode", True)]
    [EditorBrowsable(Never)]
    public enum iPhoneMovieScalingMode
    {
        None = 0,
        AspectFit = 1,
        AspectFill = 2,
        Fill = 3
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [EditorBrowsable(Never)]
    public class iPhoneUtils
    {
        public iPhoneUtils();

        [Obsolete("isApplicationGenuine property is deprecated. Please use Application.genuine instead (UnityUpgradable) -> Application.genuine")]
        public static bool isApplicationGenuine { get; }
        [Obsolete("isApplicationGenuineAvailable property is deprecated. Please use Application.genuineCheckAvailable instead (UnityUpgradable) -> Application.genuineCheckAvailable")]
        public static bool isApplicationGenuineAvailable { get; }

        [Obsolete("PlayMovie method is deprecated. Please use Handheld.PlayFullScreenMovie instead (UnityUpgradable) -> [mscorlib] System.Boolean Handheld.PlayFullScreenMovie(*)")]
        public static void PlayMovie(string path, Color bgColor, iPhoneMovieControlMode controlMode, iPhoneMovieScalingMode scalingMode);
        [Obsolete("PlayMovie method is deprecated. Please use Handheld.PlayFullScreenMovie instead (UnityUpgradable) -> [mscorlib] System.Boolean Handheld.PlayFullScreenMovie(*)")]
        public static void PlayMovie(string path, Color bgColor, iPhoneMovieControlMode controlMode);
        [Obsolete("PlayMovie method is deprecated. Please use Handheld.PlayFullScreenMovie instead (UnityUpgradable) -> [mscorlib] System.Boolean Handheld.PlayFullScreenMovie(*)")]
        public static void PlayMovie(string path, Color bgColor);
        [Obsolete("PlayMovieURL method is deprecated. Please use Handheld.PlayFullScreenMovie instead (UnityUpgradable) -> [mscorlib] System.Boolean Handheld.PlayFullScreenMovie(*)")]
        public static void PlayMovieURL(string url, Color bgColor, iPhoneMovieControlMode controlMode, iPhoneMovieScalingMode scalingMode);
        [Obsolete("PlayMovieURL method is deprecated. Please use Handheld.PlayFullScreenMovie instead (UnityUpgradable) -> [mscorlib] System.Boolean Handheld.PlayFullScreenMovie(*)")]
        public static void PlayMovieURL(string url, Color bgColor, iPhoneMovieControlMode controlMode);
        [Obsolete("PlayMovieURL method is deprecated. Please use Handheld.PlayFullScreenMovie instead (UnityUpgradable) -> [mscorlib] System.Boolean Handheld.PlayFullScreenMovie(*)")]
        public static void PlayMovieURL(string url, Color bgColor);
        [Obsolete("Vibrate method is deprecated. Please use Handheld.Vibrate instead (UnityUpgradable) -> Handheld.Vibrate()")]
        public static void Vibrate();
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [Obsolete("iPhoneKeyboardType enumeration is deprecated. Please use TouchScreenKeyboardType instead (UnityUpgradable) -> TouchScreenKeyboardType", True)]
    [EditorBrowsable(Never)]
    public enum iPhoneKeyboardType
    {
        Default = 0,
        ASCIICapable = 1,
        NumbersAndPunctuation = 2,
        URL = 3,
        NumberPad = 4,
        PhonePad = 5,
        NamePhonePad = 6,
        EmailAddress = 7
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [Obsolete("iPhoneKeyboard class is deprecated. Please use TouchScreenKeyboard instead (UnityUpgradable) -> TouchScreenKeyboard", True)]
    [EditorBrowsable(Never)]
    public class iPhoneKeyboard
    {
        public iPhoneKeyboard();

        public string text { get; set; }
        public static bool hideInput { get; set; }
        public bool active { get; set; }
        public bool done { get; }
        public static Rect area { get; }
        public static bool visible { get; }
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [Obsolete("iPhoneAccelerationEvent struct is deprecated. Please use AccelerationEvent instead (UnityUpgradable) -> AccelerationEvent", True)]
    [EditorBrowsable(Never)]
    public struct iPhoneAccelerationEvent
    {
        [Obsolete("timeDelta property is deprecated. Please use AccelerationEvent.deltaTime instead (UnityUpgradable) -> AccelerationEvent.deltaTime", True)]
        [EditorBrowsable(Never)]
        public float timeDelta { get; }
        public Vector3 acceleration { get; }
        public float deltaTime { get; }
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [Obsolete("iPhoneOrientation enumeration is deprecated. Please use DeviceOrientation instead (UnityUpgradable) -> DeviceOrientation", True)]
    [EditorBrowsable(Never)]
    public enum iPhoneOrientation
    {
        Unknown = 0,
        Portrait = 1,
        PortraitUpsideDown = 2,
        LandscapeLeft = 3,
        LandscapeRight = 4,
        FaceUp = 5,
        FaceDown = 6
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [EditorBrowsable(Never)]
    [Obsolete("iPhoneInput class is deprecated. Please use Input instead (UnityUpgradable) -> Input", True)]
    public class iPhoneInput
    {
        public iPhoneInput();

        [Obsolete("orientation property is deprecated. Please use Input.deviceOrientation instead (UnityUpgradable) -> Input.deviceOrientation", True)]
        [EditorBrowsable(Never)]
        public static iPhoneOrientation orientation { get; }
        public static iPhoneAccelerationEvent[] accelerationEvents { get; }
        public static iPhoneTouch[] touches { get; }
        public static int touchCount { get; }
        public static bool multiTouchEnabled { get; set; }
        public static int accelerationEventCount { get; }
        public static Vector3 acceleration { get; }

        public static iPhoneTouch GetTouch(int index);
        public static iPhoneAccelerationEvent GetAccelerationEvent(int index);
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [EditorBrowsable(Never)]
    [Obsolete("iPhone class is deprecated. Please use iOS.Device instead (UnityUpgradable) -> UnityEngine.iOS.Device", True)]
    public sealed class iPhone
    {
        public iPhone();

        public static iPhoneGeneration generation { get; }
        public static string vendorIdentifier { get; }
        public static string advertisingIdentifier { get; }
        public static bool advertisingTrackingEnabled { get; }

        public static void SetNoBackupFlag(string path);
        public static void ResetNoBackupFlag(string path);
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [Obsolete("iOSActivityIndicatorStyle enumeration is deprecated. Please use iOS.ActivityIndicatorStyle instead (UnityUpgradable) -> UnityEngine.iOS.ActivityIndicatorStyle", True)]
    [EditorBrowsable(Never)]
    public enum iOSActivityIndicatorStyle
    {
        DontShow = 0,
        WhiteLarge = 1,
        White = 2,
        Gray = 3
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [EditorBrowsable(Never)]
    [Obsolete("CalendarIdentifier is deprecated. Please use iOS.CalendarIdentifier instead (UnityUpgradable) -> UnityEngine.iOS.CalendarIdentifier", True)]
    public enum CalendarIdentifier
    {
        GregorianCalendar = 0,
        BuddhistCalendar = 1,
        ChineseCalendar = 2,
        HebrewCalendar = 3,
        IslamicCalendar = 4,
        IslamicCivilCalendar = 5,
        JapaneseCalendar = 6,
        RepublicOfChinaCalendar = 7,
        PersianCalendar = 8,
        IndianCalendar = 9,
        ISO8601Calendar = 10
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [EditorBrowsable(Never)]
    [Obsolete("CalendarUnit is deprecated. Please use iOS.CalendarUnit instead (UnityUpgradable) -> UnityEngine.iOS.CalendarUnit", True)]
    public enum CalendarUnit
    {
        Era = 0,
        Year = 1,
        Month = 2,
        Day = 3,
        Hour = 4,
        Minute = 5,
        Second = 6,
        Week = 7,
        Weekday = 8,
        WeekdayOrdinal = 9,
        Quarter = 10
    }
}
using System;
using System.Collections;
using System.ComponentModel;

namespace UnityEngine
{
    [Obsolete("LocalNotification is deprecated. Please use iOS.LocalNotification instead (UnityUpgradable) -> UnityEngine.iOS.LocalNotification", True)]
    [EditorBrowsable(Never)]
    public sealed class LocalNotification
    {
        public LocalNotification();

        public DateTime fireDate { get; set; }
        public string timeZone { get; set; }
        public CalendarUnit repeatInterval { get; set; }
        public CalendarIdentifier repeatCalendar { get; set; }
        public string alertBody { get; set; }
        public string alertAction { get; set; }
        public bool hasAction { get; set; }
        public string alertLaunchImage { get; set; }
        public int applicationIconBadgeNumber { get; set; }
        public string soundName { get; set; }
        public static string defaultSoundName { get; }
        public IDictionary userInfo { get; set; }
    }
}
using System;
using System.Collections;
using System.ComponentModel;

namespace UnityEngine
{
    [Obsolete("RemoteNotification is deprecated. Please use iOS.RemoteNotification instead (UnityUpgradable) -> UnityEngine.iOS.RemoteNotification", True)]
    [EditorBrowsable(Never)]
    public sealed class RemoteNotification
    {
        public RemoteNotification();

        public string alertBody { get; }
        public bool hasAction { get; }
        public int applicationIconBadgeNumber { get; }
        public string soundName { get; }
        public IDictionary userInfo { get; }
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [EditorBrowsable(Never)]
    [Obsolete("RemoteNotificationType is deprecated. Please use iOS.NotificationType instead (UnityUpgradable) -> UnityEngine.iOS.NotificationType", True)]
    public enum RemoteNotificationType
    {
        None = 0,
        Badge = 1,
        Sound = 2,
        Alert = 3
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [Obsolete("NotificationServices is deprecated. Please use iOS.NotificationServices instead (UnityUpgradable) -> UnityEngine.iOS.NotificationServices", True)]
    [EditorBrowsable(Never)]
    public sealed class NotificationServices
    {
        public NotificationServices();

        [Obsolete("RegisterForRemoteNotificationTypes is deprecated. Please use RegisterForNotifications instead (UnityUpgradable) -> UnityEngine.iOS.NotificationServices.RegisterForNotifications(*)", True)]
        [EditorBrowsable(Never)]
        public static void RegisterForRemoteNotificationTypes(RemoteNotificationType notificationTypes);
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [EditorBrowsable(Never)]
    [Obsolete("ADBannerView class is obsolete, Apple iAD service discontinued", True)]
    public sealed class ADBannerView
    {
        public ADBannerView(Type type, Layout layout);

        public bool loaded { get; }
        public bool visible { get; set; }
        public Layout layout { get; set; }
        public Vector2 position { get; set; }
        public Vector2 size { get; }

        public static event BannerWasClickedDelegate onBannerWasClicked;
        public static event BannerWasLoadedDelegate onBannerWasLoaded;

        public static bool IsAvailable(Type type);

        public enum Layout
        {
            Top = 0,
            Bottom = 1,
            TopLeft = 0,
            TopRight = 4,
            TopCenter = 8,
            BottomLeft = 1,
            BottomRight = 5,
            BottomCenter = 9,
            CenterLeft = 2,
            CenterRight = 6,
            Center = 10,
            Manual = -1
        }
        public enum Type
        {
            Banner = 0,
            MediumRect = 1
        }
        public delegate void BannerWasClickedDelegate();
        public delegate void BannerWasLoadedDelegate();
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [EditorBrowsable(Never)]
    [Obsolete("ADInterstitialAd class is obsolete, Apple iAD service discontinued", True)]
    public sealed class ADInterstitialAd
    {
        public ADInterstitialAd(bool autoReload);
        public ADInterstitialAd();

        ~ADInterstitialAd();

        public static bool isAvailable { get; }
        public bool loaded { get; }

        public static event InterstitialWasLoadedDelegate onInterstitialWasLoaded;

        public void Show();
        public void ReloadAd();

        public delegate void InterstitialWasLoadedDelegate();
    }
}
using System;

namespace UnityEngine
{
    public interface ILogger : ILogHandler
    {
        ILogHandler logHandler { get; set; }
        bool logEnabled { get; set; }
        LogType filterLogType { get; set; }

        bool IsLogTypeAllowed(LogType logType);
        void Log(LogType logType, object message);
        void Log(LogType logType, object message, Object context);
        void Log(LogType logType, string tag, object message);
        void Log(LogType logType, string tag, object message, Object context);
        void Log(object message);
        void Log(string tag, object message);
        void Log(string tag, object message, Object context);
        void LogWarning(string tag, object message);
        void LogWarning(string tag, object message, Object context);
        void LogError(string tag, object message);
        void LogError(string tag, object message, Object context);
        void LogFormat(LogType logType, string format, params object[] args);
        void LogException(Exception exception);
    }
}
using System;

namespace UnityEngine
{
    public interface ILogHandler
    {
        void LogFormat(LogType logType, Object context, string format, params object[] args);
        void LogException(Exception exception, Object context);
    }
}
using System;

namespace UnityEngine
{
    public class Logger : ILogger, ILogHandler
    {
        public Logger(ILogHandler logHandler);

        public ILogHandler logHandler { get; set; }
        public bool logEnabled { get; set; }
        public LogType filterLogType { get; set; }

        public bool IsLogTypeAllowed(LogType logType);
        public void Log(LogType logType, object message);
        public void Log(LogType logType, object message, Object context);
        public void Log(LogType logType, string tag, object message);
        public void Log(LogType logType, string tag, object message, Object context);
        public void Log(object message);
        public void Log(string tag, object message);
        public void Log(string tag, object message, Object context);
        public void LogWarning(string tag, object message);
        public void LogWarning(string tag, object message, Object context);
        public void LogError(string tag, object message);
        public void LogError(string tag, object message, Object context);
        public void LogException(Exception exception);
        public void LogException(Exception exception, Object context);
        public void LogFormat(LogType logType, string format, params object[] args);
        public void LogFormat(LogType logType, Object context, string format, params object[] args);
    }
}
using System;
using System.Reflection;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [RequiredByNativeCode(Optional = True, GenerateProxy = True)]
    [DefaultMember("Item")]
    [NativeHeader("Runtime/Math/Color.h")]
    [NativeClass("ColorRGBAf")]
    public struct Color : IEquatable<Color>, IFormattable
    {
        public float r;
        public float g;
        public float b;
        public float a;

        public Color(float r, float g, float b, float a);
        public Color(float r, float g, float b);

        public float this[int index] { get; set; }
        public static Color red { get; }
        public static Color green { get; }
        public static Color blue { get; }
        public static Color white { get; }
        public static Color black { get; }
        public static Color yellow { get; }
        public static Color cyan { get; }
        public static Color magenta { get; }
        public static Color gray { get; }
        public static Color grey { get; }
        public static Color clear { get; }
        public float grayscale { get; }
        public Color linear { get; }
        public Color gamma { get; }
        public float maxColorComponent { get; }

        public override string ToString();
        public string ToString(string format);
        public string ToString(string format, IFormatProvider formatProvider);
        public override int GetHashCode();
        public override bool Equals(object other);
        public bool Equals(Color other);
        public static Color Lerp(Color a, Color b, float t);
        public static Color LerpUnclamped(Color a, Color b, float t);
        public static void RGBToHSV(Color rgbColor, out float H, out float S, out float V);
        public static Color HSVToRGB(float H, float S, float V);
        public static Color HSVToRGB(float H, float S, float V, bool hdr);

        public static Color operator +(Color a, Color b);
        public static Color operator -(Color a, Color b);
        public static Color operator *(Color a, Color b);
        public static Color operator *(Color a, float b);
        public static Color operator *(float b, Color a);
        public static Color operator /(Color a, float b);
        public static bool operator ==(Color lhs, Color rhs);
        public static bool operator !=(Color lhs, Color rhs);

        public static implicit operator Vector4(Color c);
        public static implicit operator Color(Vector4 v);
    }
}
using System;
using System.Reflection;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    [DefaultMember("Item")]
    public struct Color32 : IFormattable
    {
        public byte r;
        public byte g;
        public byte b;
        public byte a;

        public Color32(byte r, byte g, byte b, byte a);

        public byte this[int index] { get; set; }

        public static Color32 Lerp(Color32 a, Color32 b, float t);
        public static Color32 LerpUnclamped(Color32 a, Color32 b, float t);
        public override string ToString();
        public string ToString(string format);
        public string ToString(string format, IFormatProvider formatProvider);

        public static implicit operator Color32(Color c);
        public static implicit operator Color(Color32 c);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Export/Math/ColorUtility.bindings.h")]
    public class ColorUtility
    {
        public ColorUtility();

        public static bool TryParseHtmlString(string htmlString, out Color color);
        public static string ToHtmlStringRGB(Color color);
        public static string ToHtmlStringRGBA(Color color);
    }
}
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    public struct GradientColorKey
    {
        public Color color;
        public float time;

        public GradientColorKey(Color col, float time);
    }
}
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    public struct GradientAlphaKey
    {
        public float alpha;
        public float time;

        public GradientAlphaKey(float alpha, float time);
    }
}
namespace UnityEngine
{
    public enum GradientMode
    {
        Blend = 0,
        Fixed = 1
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Runtime/Export/Math/Gradient.bindings.h")]
    [RequiredByNativeCode]
    public class Gradient : IEquatable<Gradient>
    {
        [RequiredByNativeCode]
        public Gradient();

        ~Gradient();

        public GradientColorKey[] colorKeys { get; set; }
        public GradientAlphaKey[] alphaKeys { get; set; }
        public GradientMode mode { get; set; }

        [FreeFunction(Name = "Gradient_Bindings::Evaluate", IsThreadSafe = True, HasExplicitThis = True)]
        public Color Evaluate(float time);
        [FreeFunction(Name = "Gradient_Bindings::SetKeys", IsThreadSafe = True, HasExplicitThis = True)]
        public void SetKeys(GradientColorKey[] colorKeys, GradientAlphaKey[] alphaKeys);
        public override bool Equals(object o);
        public bool Equals(Gradient other);
        public override int GetHashCode();
    }
}
namespace UnityEngine
{
    public struct FrustumPlanes
    {
        public float left;
        public float right;
        public float bottom;
        public float top;
        public float zNear;
        public float zFar;
    }
}
using System;
using System.Reflection;
using Unity.IL2CPP.CompilerServices;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [RequiredByNativeCode(Optional = True, GenerateProxy = True)]
    [DefaultMember("Item")]
    [Il2CppEagerStaticClassConstruction]
    [NativeClass("Matrix4x4f")]
    [NativeHeader("Runtime/Math/MathScripting.h")]
    [NativeType(Header = "Runtime/Math/Matrix4x4.h")]
    public struct Matrix4x4 : IEquatable<Matrix4x4>, IFormattable
    {
        [NativeName("m_Data[0]")]
        public float m00;
        [NativeName("m_Data[1]")]
        public float m10;
        [NativeName("m_Data[2]")]
        public float m20;
        [NativeName("m_Data[3]")]
        public float m30;
        [NativeName("m_Data[4]")]
        public float m01;
        [NativeName("m_Data[5]")]
        public float m11;
        [NativeName("m_Data[6]")]
        public float m21;
        [NativeName("m_Data[7]")]
        public float m31;
        [NativeName("m_Data[8]")]
        public float m02;
        [NativeName("m_Data[9]")]
        public float m12;
        [NativeName("m_Data[10]")]
        public float m22;
        [NativeName("m_Data[11]")]
        public float m32;
        [NativeName("m_Data[12]")]
        public float m03;
        [NativeName("m_Data[13]")]
        public float m13;
        [NativeName("m_Data[14]")]
        public float m23;
        [NativeName("m_Data[15]")]
        public float m33;

        public Matrix4x4(Vector4 column0, Vector4 column1, Vector4 column2, Vector4 column3);

        public float this[int row, int column] { get; set; }
        public float this[int index] { get; set; }
        public Quaternion rotation { get; }
        public Vector3 lossyScale { get; }
        public bool isIdentity { get; }
        public float determinant { get; }
        public FrustumPlanes decomposeProjection { get; }
        public Matrix4x4 inverse { get; }
        public Matrix4x4 transpose { get; }
        public static Matrix4x4 zero { get; }
        public static Matrix4x4 identity { get; }

        [ThreadSafe]
        public bool ValidTRS();
        public static float Determinant(Matrix4x4 m);
        [FreeFunction("MatrixScripting::TRS", IsThreadSafe = True)]
        public static Matrix4x4 TRS(Vector3 pos, Quaternion q, Vector3 s);
        public void SetTRS(Vector3 pos, Quaternion q, Vector3 s);
        [FreeFunction("MatrixScripting::Inverse3DAffine", IsThreadSafe = True)]
        public static bool Inverse3DAffine(Matrix4x4 input, ref Matrix4x4 result);
        [FreeFunction("MatrixScripting::Inverse", IsThreadSafe = True)]
        public static Matrix4x4 Inverse(Matrix4x4 m);
        [FreeFunction("MatrixScripting::Transpose", IsThreadSafe = True)]
        public static Matrix4x4 Transpose(Matrix4x4 m);
        [FreeFunction("MatrixScripting::Ortho", IsThreadSafe = True)]
        public static Matrix4x4 Ortho(float left, float right, float bottom, float top, float zNear, float zFar);
        [FreeFunction("MatrixScripting::Perspective", IsThreadSafe = True)]
        public static Matrix4x4 Perspective(float fov, float aspect, float zNear, float zFar);
        [FreeFunction("MatrixScripting::LookAt", IsThreadSafe = True)]
        public static Matrix4x4 LookAt(Vector3 from, Vector3 to, Vector3 up);
        [FreeFunction("MatrixScripting::Frustum", IsThreadSafe = True)]
        public static Matrix4x4 Frustum(float left, float right, float bottom, float top, float zNear, float zFar);
        public static Matrix4x4 Frustum(FrustumPlanes fp);
        public override int GetHashCode();
        public override bool Equals(object other);
        public bool Equals(Matrix4x4 other);
        public Vector4 GetColumn(int index);
        public Vector4 GetRow(int index);
        public void SetColumn(int index, Vector4 column);
        public void SetRow(int index, Vector4 row);
        public Vector3 MultiplyPoint(Vector3 point);
        public Vector3 MultiplyPoint3x4(Vector3 point);
        public Vector3 MultiplyVector(Vector3 vector);
        public Plane TransformPlane(Plane plane);
        public static Matrix4x4 Scale(Vector3 vector);
        public static Matrix4x4 Translate(Vector3 vector);
        public static Matrix4x4 Rotate(Quaternion q);
        public override string ToString();
        public string ToString(string format);
        public string ToString(string format, IFormatProvider formatProvider);

        public static Matrix4x4 operator *(Matrix4x4 lhs, Matrix4x4 rhs);
        public static Vector4 operator *(Matrix4x4 lhs, Vector4 vector);
        public static bool operator ==(Matrix4x4 lhs, Matrix4x4 rhs);
        public static bool operator !=(Matrix4x4 lhs, Matrix4x4 rhs);
    }
}
using System;
using System.Reflection;
using Unity.IL2CPP.CompilerServices;
using UnityEngine.Bindings;
using UnityEngine.Internal;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [Il2CppEagerStaticClassConstruction]
    [RequiredByNativeCode(Optional = True, GenerateProxy = True)]
    [NativeClass("Vector3f")]
    [NativeHeader("Runtime/Math/Vector3.h")]
    [NativeType(Header = "Runtime/Math/Vector3.h")]
    [NativeHeader("Runtime/Math/MathScripting.h")]
    [DefaultMember("Item")]
    public struct Vector3 : IEquatable<Vector3>, IFormattable
    {
        public const float kEpsilon = 1E-05F;
        public const float kEpsilonNormalSqrt = 1E-15F;
        public float x;
        public float y;
        public float z;

        public Vector3(float x, float y, float z);
        public Vector3(float x, float y);

        public float this[int index] { get; set; }
        public Vector3 normalized { get; }
        public float magnitude { get; }
        public float sqrMagnitude { get; }
        public static Vector3 zero { get; }
        public static Vector3 one { get; }
        public static Vector3 forward { get; }
        public static Vector3 back { get; }
        public static Vector3 up { get; }
        public static Vector3 down { get; }
        public static Vector3 left { get; }
        public static Vector3 right { get; }
        public static Vector3 positiveInfinity { get; }
        public static Vector3 negativeInfinity { get; }
        [Obsolete("Use Vector3.forward instead.")]
        public static Vector3 fwd { get; }

        [FreeFunction("VectorScripting::Slerp", IsThreadSafe = True)]
        public static Vector3 Slerp(Vector3 a, Vector3 b, float t);
        [FreeFunction("VectorScripting::SlerpUnclamped", IsThreadSafe = True)]
        public static Vector3 SlerpUnclamped(Vector3 a, Vector3 b, float t);
        public static void OrthoNormalize(ref Vector3 normal, ref Vector3 tangent);
        public static void OrthoNormalize(ref Vector3 normal, ref Vector3 tangent, ref Vector3 binormal);
        [FreeFunction(IsThreadSafe = True)]
        public static Vector3 RotateTowards(Vector3 current, Vector3 target, float maxRadiansDelta, float maxMagnitudeDelta);
        public static Vector3 Lerp(Vector3 a, Vector3 b, float t);
        public static Vector3 LerpUnclamped(Vector3 a, Vector3 b, float t);
        public static Vector3 MoveTowards(Vector3 current, Vector3 target, float maxDistanceDelta);
        [ExcludeFromDocs]
        public static Vector3 SmoothDamp(Vector3 current, Vector3 target, ref Vector3 currentVelocity, float smoothTime, float maxSpeed);
        [ExcludeFromDocs]
        public static Vector3 SmoothDamp(Vector3 current, Vector3 target, ref Vector3 currentVelocity, float smoothTime);
        public static Vector3 SmoothDamp(Vector3 current, Vector3 target, ref Vector3 currentVelocity, float smoothTime, [DefaultValue("Mathf.Infinity")] float maxSpeed, [DefaultValue("Time.deltaTime")] float deltaTime);
        public void Set(float newX, float newY, float newZ);
        public static Vector3 Scale(Vector3 a, Vector3 b);
        public void Scale(Vector3 scale);
        public static Vector3 Cross(Vector3 lhs, Vector3 rhs);
        public override int GetHashCode();
        public override bool Equals(object other);
        public bool Equals(Vector3 other);
        public static Vector3 Reflect(Vector3 inDirection, Vector3 inNormal);
        public static Vector3 Normalize(Vector3 value);
        public void Normalize();
        public static float Dot(Vector3 lhs, Vector3 rhs);
        public static Vector3 Project(Vector3 vector, Vector3 onNormal);
        public static Vector3 ProjectOnPlane(Vector3 vector, Vector3 planeNormal);
        public static float Angle(Vector3 from, Vector3 to);
        public static float SignedAngle(Vector3 from, Vector3 to, Vector3 axis);
        public static float Distance(Vector3 a, Vector3 b);
        public static Vector3 ClampMagnitude(Vector3 vector, float maxLength);
        public static float Magnitude(Vector3 vector);
        public static float SqrMagnitude(Vector3 vector);
        public static Vector3 Min(Vector3 lhs, Vector3 rhs);
        public static Vector3 Max(Vector3 lhs, Vector3 rhs);
        public override string ToString();
        public string ToString(string format);
        public string ToString(string format, IFormatProvider formatProvider);
        [Obsolete("Use Vector3.Angle instead. AngleBetween uses radians instead of degrees and was deprecated for this reason")]
        public static float AngleBetween(Vector3 from, Vector3 to);
        [Obsolete("Use Vector3.ProjectOnPlane instead.")]
        public static Vector3 Exclude(Vector3 excludeThis, Vector3 fromThat);

        public static Vector3 operator +(Vector3 a, Vector3 b);
        public static Vector3 operator -(Vector3 a, Vector3 b);
        public static Vector3 operator -(Vector3 a);
        public static Vector3 operator *(Vector3 a, float d);
        public static Vector3 operator *(float d, Vector3 a);
        public static Vector3 operator /(Vector3 a, float d);
        public static bool operator ==(Vector3 lhs, Vector3 rhs);
        public static bool operator !=(Vector3 lhs, Vector3 rhs);
    }
}
using System;
using System.Reflection;
using Unity.IL2CPP.CompilerServices;
using UnityEngine.Bindings;
using UnityEngine.Internal;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [Il2CppEagerStaticClassConstruction]
    [DefaultMember("Item")]
    [NativeHeader("Runtime/Math/MathScripting.h")]
    [UsedByNativeCode]
    [NativeType(Header = "Runtime/Math/Quaternion.h")]
    public struct Quaternion : IEquatable<Quaternion>, IFormattable
    {
        public float x;
        public float y;
        public float z;
        public float w;
        public const float kEpsilon = 1E-06F;

        public Quaternion(float x, float y, float z, float w);

        public float this[int index] { get; set; }
        public static Quaternion identity { get; }
        public Vector3 eulerAngles { get; set; }
        public Quaternion normalized { get; }

        [FreeFunction("FromToQuaternionSafe", IsThreadSafe = True)]
        public static Quaternion FromToRotation(Vector3 fromDirection, Vector3 toDirection);
        [FreeFunction(IsThreadSafe = True)]
        public static Quaternion Inverse(Quaternion rotation);
        [FreeFunction("QuaternionScripting::Slerp", IsThreadSafe = True)]
        public static Quaternion Slerp(Quaternion a, Quaternion b, float t);
        [FreeFunction("QuaternionScripting::SlerpUnclamped", IsThreadSafe = True)]
        public static Quaternion SlerpUnclamped(Quaternion a, Quaternion b, float t);
        [FreeFunction("QuaternionScripting::Lerp", IsThreadSafe = True)]
        public static Quaternion Lerp(Quaternion a, Quaternion b, float t);
        [FreeFunction("QuaternionScripting::LerpUnclamped", IsThreadSafe = True)]
        public static Quaternion LerpUnclamped(Quaternion a, Quaternion b, float t);
        [FreeFunction("QuaternionScripting::AngleAxis", IsThreadSafe = True)]
        public static Quaternion AngleAxis(float angle, Vector3 axis);
        [FreeFunction("QuaternionScripting::LookRotation", IsThreadSafe = True)]
        public static Quaternion LookRotation(Vector3 forward, [DefaultValue("Vector3.up")] Vector3 upwards);
        [ExcludeFromDocs]
        public static Quaternion LookRotation(Vector3 forward);
        public void Set(float newX, float newY, float newZ, float newW);
        public static float Dot(Quaternion a, Quaternion b);
        [ExcludeFromDocs]
        public void SetLookRotation(Vector3 view);
        public void SetLookRotation(Vector3 view, [DefaultValue("Vector3.up")] Vector3 up);
        public static float Angle(Quaternion a, Quaternion b);
        public static Quaternion Euler(float x, float y, float z);
        public static Quaternion Euler(Vector3 euler);
        public void ToAngleAxis(out float angle, out Vector3 axis);
        public void SetFromToRotation(Vector3 fromDirection, Vector3 toDirection);
        public static Quaternion RotateTowards(Quaternion from, Quaternion to, float maxDegreesDelta);
        public static Quaternion Normalize(Quaternion q);
        public void Normalize();
        public override int GetHashCode();
        public override bool Equals(object other);
        public bool Equals(Quaternion other);
        public override string ToString();
        public string ToString(string format);
        public string ToString(string format, IFormatProvider formatProvider);
        [Obsolete("Use Quaternion.Euler instead. This function was deprecated because it uses radians instead of degrees.")]
        public static Quaternion EulerRotation(float x, float y, float z);
        [Obsolete("Use Quaternion.Euler instead. This function was deprecated because it uses radians instead of degrees.")]
        public static Quaternion EulerRotation(Vector3 euler);
        [Obsolete("Use Quaternion.Euler instead. This function was deprecated because it uses radians instead of degrees.")]
        public void SetEulerRotation(float x, float y, float z);
        [Obsolete("Use Quaternion.Euler instead. This function was deprecated because it uses radians instead of degrees.")]
        public void SetEulerRotation(Vector3 euler);
        [Obsolete("Use Quaternion.eulerAngles instead. This function was deprecated because it uses radians instead of degrees.")]
        public Vector3 ToEuler();
        [Obsolete("Use Quaternion.Euler instead. This function was deprecated because it uses radians instead of degrees.")]
        public static Quaternion EulerAngles(float x, float y, float z);
        [Obsolete("Use Quaternion.Euler instead. This function was deprecated because it uses radians instead of degrees.")]
        public static Quaternion EulerAngles(Vector3 euler);
        [Obsolete("Use Quaternion.ToAngleAxis instead. This function was deprecated because it uses radians instead of degrees.")]
        public void ToAxisAngle(out Vector3 axis, out float angle);
        [Obsolete("Use Quaternion.Euler instead. This function was deprecated because it uses radians instead of degrees.")]
        public void SetEulerAngles(float x, float y, float z);
        [Obsolete("Use Quaternion.Euler instead. This function was deprecated because it uses radians instead of degrees.")]
        public void SetEulerAngles(Vector3 euler);
        [Obsolete("Use Quaternion.eulerAngles instead. This function was deprecated because it uses radians instead of degrees.")]
        public static Vector3 ToEulerAngles(Quaternion rotation);
        [Obsolete("Use Quaternion.eulerAngles instead. This function was deprecated because it uses radians instead of degrees.")]
        public Vector3 ToEulerAngles();
        [Obsolete("Use Quaternion.AngleAxis instead. This function was deprecated because it uses radians instead of degrees.")]
        public void SetAxisAngle(Vector3 axis, float angle);
        [Obsolete("Use Quaternion.AngleAxis instead. This function was deprecated because it uses radians instead of degrees")]
        public static Quaternion AxisAngle(Vector3 axis, float angle);

        public static Quaternion operator *(Quaternion lhs, Quaternion rhs);
        public static Vector3 operator *(Quaternion rotation, Vector3 point);
        public static bool operator ==(Quaternion lhs, Quaternion rhs);
        public static bool operator !=(Quaternion lhs, Quaternion rhs);
    }
}
using Unity.IL2CPP.CompilerServices;
using UnityEngine.Bindings;
using UnityEngine.Internal;

namespace UnityEngine
{
    [NativeHeader("Runtime/Math/FloatConversion.h")]
    [NativeHeader("Runtime/Utilities/BitUtility.h")]
    [Il2CppEagerStaticClassConstruction]
    [NativeHeader("Runtime/Math/PerlinNoise.h")]
    [NativeHeader("Runtime/Math/ColorSpaceConversion.h")]
    public struct Mathf
    {
        public const float PI = 3.141593F;
        public const float Infinity = InfinityF;
        public const float NegativeInfinity = -InfinityF;
        public const float Deg2Rad = 0.01745329F;
        public const float Rad2Deg = 57.29578F;
        public static readonly float Epsilon;

        [FreeFunction(IsThreadSafe = True)]
        public static int ClosestPowerOfTwo(int value);
        [FreeFunction(IsThreadSafe = True)]
        public static bool IsPowerOfTwo(int value);
        [FreeFunction(IsThreadSafe = True)]
        public static int NextPowerOfTwo(int value);
        [FreeFunction(IsThreadSafe = True)]
        public static float GammaToLinearSpace(float value);
        [FreeFunction(IsThreadSafe = True)]
        public static float LinearToGammaSpace(float value);
        [FreeFunction(IsThreadSafe = True)]
        public static Color CorrelatedColorTemperatureToRGB(float kelvin);
        [FreeFunction(IsThreadSafe = True)]
        public static ushort FloatToHalf(float val);
        [FreeFunction(IsThreadSafe = True)]
        public static float HalfToFloat(ushort val);
        [FreeFunction("PerlinNoise::NoiseNormalized", IsThreadSafe = True)]
        public static float PerlinNoise(float x, float y);
        public static float Sin(float f);
        public static float Cos(float f);
        public static float Tan(float f);
        public static float Asin(float f);
        public static float Acos(float f);
        public static float Atan(float f);
        public static float Atan2(float y, float x);
        public static float Sqrt(float f);
        public static float Abs(float f);
        public static int Abs(int value);
        public static float Min(float a, float b);
        public static float Min(params float[] values);
        public static int Min(int a, int b);
        public static int Min(params int[] values);
        public static float Max(float a, float b);
        public static float Max(params float[] values);
        public static int Max(int a, int b);
        public static int Max(params int[] values);
        public static float Pow(float f, float p);
        public static float Exp(float power);
        public static float Log(float f, float p);
        public static float Log(float f);
        public static float Log10(float f);
        public static float Ceil(float f);
        public static float Floor(float f);
        public static float Round(float f);
        public static int CeilToInt(float f);
        public static int FloorToInt(float f);
        public static int RoundToInt(float f);
        public static float Sign(float f);
        public static float Clamp(float value, float min, float max);
        public static int Clamp(int value, int min, int max);
        public static float Clamp01(float value);
        public static float Lerp(float a, float b, float t);
        public static float LerpUnclamped(float a, float b, float t);
        public static float LerpAngle(float a, float b, float t);
        public static float MoveTowards(float current, float target, float maxDelta);
        public static float MoveTowardsAngle(float current, float target, float maxDelta);
        public static float SmoothStep(float from, float to, float t);
        public static float Gamma(float value, float absmax, float gamma);
        public static bool Approximately(float a, float b);
        [ExcludeFromDocs]
        public static float SmoothDamp(float current, float target, ref float currentVelocity, float smoothTime, float maxSpeed);
        [ExcludeFromDocs]
        public static float SmoothDamp(float current, float target, ref float currentVelocity, float smoothTime);
        public static float SmoothDamp(float current, float target, ref float currentVelocity, float smoothTime, [DefaultValue("Mathf.Infinity")] float maxSpeed, [DefaultValue("Time.deltaTime")] float deltaTime);
        [ExcludeFromDocs]
        public static float SmoothDampAngle(float current, float target, ref float currentVelocity, float smoothTime, float maxSpeed);
        [ExcludeFromDocs]
        public static float SmoothDampAngle(float current, float target, ref float currentVelocity, float smoothTime);
        public static float SmoothDampAngle(float current, float target, ref float currentVelocity, float smoothTime, [DefaultValue("Mathf.Infinity")] float maxSpeed, [DefaultValue("Time.deltaTime")] float deltaTime);
        public static float Repeat(float t, float length);
        public static float PingPong(float t, float length);
        public static float InverseLerp(float a, float b, float value);
        public static float DeltaAngle(float current, float target);
    }
}
using System;
using System.Reflection;
using Unity.IL2CPP.CompilerServices;
using UnityEngine.Internal;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [DefaultMember("Item")]
    [NativeClass("Vector2f")]
    [RequiredByNativeCode(Optional = True, GenerateProxy = True)]
    [Il2CppEagerStaticClassConstruction]
    public struct Vector2 : IEquatable<Vector2>, IFormattable
    {
        public float x;
        public float y;
        public const float kEpsilon = 1E-05F;
        public const float kEpsilonNormalSqrt = 1E-15F;

        public Vector2(float x, float y);

        public float this[int index] { get; set; }
        public Vector2 normalized { get; }
        public float magnitude { get; }
        public float sqrMagnitude { get; }
        public static Vector2 zero { get; }
        public static Vector2 one { get; }
        public static Vector2 up { get; }
        public static Vector2 down { get; }
        public static Vector2 left { get; }
        public static Vector2 right { get; }
        public static Vector2 positiveInfinity { get; }
        public static Vector2 negativeInfinity { get; }

        public void Set(float newX, float newY);
        public static Vector2 Lerp(Vector2 a, Vector2 b, float t);
        public static Vector2 LerpUnclamped(Vector2 a, Vector2 b, float t);
        public static Vector2 MoveTowards(Vector2 current, Vector2 target, float maxDistanceDelta);
        public static Vector2 Scale(Vector2 a, Vector2 b);
        public void Scale(Vector2 scale);
        public void Normalize();
        public override string ToString();
        public string ToString(string format);
        public string ToString(string format, IFormatProvider formatProvider);
        public override int GetHashCode();
        public override bool Equals(object other);
        public bool Equals(Vector2 other);
        public static Vector2 Reflect(Vector2 inDirection, Vector2 inNormal);
        public static Vector2 Perpendicular(Vector2 inDirection);
        public static float Dot(Vector2 lhs, Vector2 rhs);
        public static float Angle(Vector2 from, Vector2 to);
        public static float SignedAngle(Vector2 from, Vector2 to);
        public static float Distance(Vector2 a, Vector2 b);
        public static Vector2 ClampMagnitude(Vector2 vector, float maxLength);
        public static float SqrMagnitude(Vector2 a);
        public float SqrMagnitude();
        public static Vector2 Min(Vector2 lhs, Vector2 rhs);
        public static Vector2 Max(Vector2 lhs, Vector2 rhs);
        [ExcludeFromDocs]
        public static Vector2 SmoothDamp(Vector2 current, Vector2 target, ref Vector2 currentVelocity, float smoothTime, float maxSpeed);
        [ExcludeFromDocs]
        public static Vector2 SmoothDamp(Vector2 current, Vector2 target, ref Vector2 currentVelocity, float smoothTime);
        public static Vector2 SmoothDamp(Vector2 current, Vector2 target, ref Vector2 currentVelocity, float smoothTime, [DefaultValue("Mathf.Infinity")] float maxSpeed, [DefaultValue("Time.deltaTime")] float deltaTime);

        public static Vector2 operator +(Vector2 a, Vector2 b);
        public static Vector2 operator -(Vector2 a, Vector2 b);
        public static Vector2 operator *(Vector2 a, Vector2 b);
        public static Vector2 operator /(Vector2 a, Vector2 b);
        public static Vector2 operator -(Vector2 a);
        public static Vector2 operator *(Vector2 a, float d);
        public static Vector2 operator *(float d, Vector2 a);
        public static Vector2 operator /(Vector2 a, float d);
        public static bool operator ==(Vector2 lhs, Vector2 rhs);
        public static bool operator !=(Vector2 lhs, Vector2 rhs);

        public static implicit operator Vector2(Vector3 v);
        public static implicit operator Vector3(Vector2 v);
    }
}
using System;
using System.Reflection;
using Unity.IL2CPP.CompilerServices;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    [DefaultMember("Item")]
    [Il2CppEagerStaticClassConstruction]
    public struct Vector2Int : IEquatable<Vector2Int>, IFormattable
    {
        public Vector2Int(int x, int y);

        public int this[int index] { get; set; }
        public int x { get; set; }
        public int y { get; set; }
        public float magnitude { get; }
        public int sqrMagnitude { get; }
        public static Vector2Int zero { get; }
        public static Vector2Int one { get; }
        public static Vector2Int up { get; }
        public static Vector2Int down { get; }
        public static Vector2Int left { get; }
        public static Vector2Int right { get; }

        public void Set(int x, int y);
        public static float Distance(Vector2Int a, Vector2Int b);
        public static Vector2Int Min(Vector2Int lhs, Vector2Int rhs);
        public static Vector2Int Max(Vector2Int lhs, Vector2Int rhs);
        public static Vector2Int Scale(Vector2Int a, Vector2Int b);
        public void Scale(Vector2Int scale);
        public void Clamp(Vector2Int min, Vector2Int max);
        public static Vector2Int FloorToInt(Vector2 v);
        public static Vector2Int CeilToInt(Vector2 v);
        public static Vector2Int RoundToInt(Vector2 v);
        public override bool Equals(object other);
        public bool Equals(Vector2Int other);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format);
        public string ToString(string format, IFormatProvider formatProvider);

        public static Vector2Int operator -(Vector2Int v);
        public static Vector2Int operator +(Vector2Int a, Vector2Int b);
        public static Vector2Int operator -(Vector2Int a, Vector2Int b);
        public static Vector2Int operator *(Vector2Int a, Vector2Int b);
        public static Vector2Int operator *(int a, Vector2Int b);
        public static Vector2Int operator *(Vector2Int a, int b);
        public static Vector2Int operator /(Vector2Int a, int b);
        public static bool operator ==(Vector2Int lhs, Vector2Int rhs);
        public static bool operator !=(Vector2Int lhs, Vector2Int rhs);

        public static implicit operator Vector2(Vector2Int v);
        public static explicit operator Vector3Int(Vector2Int v);
    }
}
using System;
using System.Reflection;
using Unity.IL2CPP.CompilerServices;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [DefaultMember("Item")]
    [Il2CppEagerStaticClassConstruction]
    [UsedByNativeCode]
    public struct Vector3Int : IEquatable<Vector3Int>, IFormattable
    {
        public Vector3Int(int x, int y, int z);

        public int this[int index] { get; set; }
        public int x { get; set; }
        public int y { get; set; }
        public int z { get; set; }
        public float magnitude { get; }
        public int sqrMagnitude { get; }
        public static Vector3Int zero { get; }
        public static Vector3Int one { get; }
        public static Vector3Int up { get; }
        public static Vector3Int down { get; }
        public static Vector3Int left { get; }
        public static Vector3Int right { get; }
        public static Vector3Int forward { get; }
        public static Vector3Int back { get; }

        public void Set(int x, int y, int z);
        public static float Distance(Vector3Int a, Vector3Int b);
        public static Vector3Int Min(Vector3Int lhs, Vector3Int rhs);
        public static Vector3Int Max(Vector3Int lhs, Vector3Int rhs);
        public static Vector3Int Scale(Vector3Int a, Vector3Int b);
        public void Scale(Vector3Int scale);
        public void Clamp(Vector3Int min, Vector3Int max);
        public static Vector3Int FloorToInt(Vector3 v);
        public static Vector3Int CeilToInt(Vector3 v);
        public static Vector3Int RoundToInt(Vector3 v);
        public override bool Equals(object other);
        public bool Equals(Vector3Int other);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format);
        public string ToString(string format, IFormatProvider formatProvider);

        public static Vector3Int operator +(Vector3Int a, Vector3Int b);
        public static Vector3Int operator -(Vector3Int a, Vector3Int b);
        public static Vector3Int operator *(Vector3Int a, Vector3Int b);
        public static Vector3Int operator -(Vector3Int a);
        public static Vector3Int operator *(Vector3Int a, int b);
        public static Vector3Int operator *(int a, Vector3Int b);
        public static Vector3Int operator /(Vector3Int a, int b);
        public static bool operator ==(Vector3Int lhs, Vector3Int rhs);
        public static bool operator !=(Vector3Int lhs, Vector3Int rhs);

        public static implicit operator Vector3(Vector3Int v);
        public static explicit operator Vector2Int(Vector3Int v);
    }
}
using System;
using System.Reflection;
using Unity.IL2CPP.CompilerServices;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Runtime/Math/Vector4.h")]
    [RequiredByNativeCode(Optional = True, GenerateProxy = True)]
    [NativeClass("Vector4f")]
    [Il2CppEagerStaticClassConstruction]
    [DefaultMember("Item")]
    public struct Vector4 : IEquatable<Vector4>, IFormattable
    {
        public const float kEpsilon = 1E-05F;
        public float x;
        public float y;
        public float z;
        public float w;

        public Vector4(float x, float y, float z, float w);
        public Vector4(float x, float y, float z);
        public Vector4(float x, float y);

        public float this[int index] { get; set; }
        public Vector4 normalized { get; }
        public float magnitude { get; }
        public float sqrMagnitude { get; }
        public static Vector4 zero { get; }
        public static Vector4 one { get; }
        public static Vector4 positiveInfinity { get; }
        public static Vector4 negativeInfinity { get; }

        public void Set(float newX, float newY, float newZ, float newW);
        public static Vector4 Lerp(Vector4 a, Vector4 b, float t);
        public static Vector4 LerpUnclamped(Vector4 a, Vector4 b, float t);
        public static Vector4 MoveTowards(Vector4 current, Vector4 target, float maxDistanceDelta);
        public static Vector4 Scale(Vector4 a, Vector4 b);
        public void Scale(Vector4 scale);
        public override int GetHashCode();
        public override bool Equals(object other);
        public bool Equals(Vector4 other);
        public static Vector4 Normalize(Vector4 a);
        public void Normalize();
        public static float Dot(Vector4 a, Vector4 b);
        public static Vector4 Project(Vector4 a, Vector4 b);
        public static float Distance(Vector4 a, Vector4 b);
        public static float Magnitude(Vector4 a);
        public static Vector4 Min(Vector4 lhs, Vector4 rhs);
        public static Vector4 Max(Vector4 lhs, Vector4 rhs);
        public override string ToString();
        public string ToString(string format);
        public string ToString(string format, IFormatProvider formatProvider);
        public static float SqrMagnitude(Vector4 a);
        public float SqrMagnitude();

        public static Vector4 operator +(Vector4 a, Vector4 b);
        public static Vector4 operator -(Vector4 a, Vector4 b);
        public static Vector4 operator -(Vector4 a);
        public static Vector4 operator *(Vector4 a, float d);
        public static Vector4 operator *(float d, Vector4 a);
        public static Vector4 operator /(Vector4 a, float d);
        public static bool operator ==(Vector4 lhs, Vector4 rhs);
        public static bool operator !=(Vector4 lhs, Vector4 rhs);

        public static implicit operator Vector4(Vector3 v);
        public static implicit operator Vector3(Vector4 v);
        public static implicit operator Vector4(Vector2 v);
        public static implicit operator Vector2(Vector4 v);
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
    [EditorBrowsable(Never)]
    public enum RPCMode
    {
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [EditorBrowsable(Never)]
    [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
    public enum ConnectionTesterStatus
    {
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
    [EditorBrowsable(Never)]
    public enum NetworkConnectionError
    {
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [EditorBrowsable(Never)]
    [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
    public enum NetworkDisconnection
    {
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [EditorBrowsable(Never)]
    [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
    public enum MasterServerEvent
    {
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
    [EditorBrowsable(Never)]
    public enum NetworkStateSynchronization
    {
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [EditorBrowsable(Never)]
    [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
    public enum NetworkPeerType
    {
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [EditorBrowsable(Never)]
    [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
    public enum NetworkLogLevel
    {
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [EditorBrowsable(Never)]
    [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
    public struct NetworkPlayer
    {
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public NetworkPlayer(string ip, int port);

        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public string ipAddress { get; }
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public int port { get; }
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public string guid { get; }
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public string externalIP { get; }
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public int externalPort { get; }
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [EditorBrowsable(Never)]
    [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
    public struct NetworkViewID
    {
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public static NetworkViewID unassigned { get; }
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public bool isMine { get; }
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public NetworkPlayer owner { get; }
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
    [NativeClass(null)]
    [EditorBrowsable(Never)]
    public class NetworkView : Behaviour
    {
        public NetworkView();

        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public Component observed { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public NetworkStateSynchronization stateSynchronization { get; set; }
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public NetworkViewID viewID { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public int group { get; set; }
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public bool isMine { get; }
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public NetworkPlayer owner { get; }

        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public void RPC(string name, RPCMode mode, params object[] args);
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public void RPC(string name, NetworkPlayer target, params object[] args);
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [EditorBrowsable(Never)]
    [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
    public class Network
    {
        public Network();

        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static string incomingPassword { get; set; }
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public static NetworkLogLevel logLevel { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static NetworkPlayer[] connections { get; }
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static NetworkPlayer player { get; }
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static bool isClient { get; }
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static bool isServer { get; }
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static NetworkPeerType peerType { get; }
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public static float sendRate { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static bool isMessageQueueRunning { get; set; }
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public static double time { get; }
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public static int minimumAllocatableViewIDs { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static bool useNat { get; set; }
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public static string natFacilitatorIP { get; set; }
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public static int natFacilitatorPort { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static string connectionTesterIP { get; set; }
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public static int connectionTesterPort { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static int maxConnections { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static string proxyIP { get; set; }
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public static int proxyPort { get; set; }
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public static bool useProxy { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static string proxyPassword { get; set; }

        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public static NetworkConnectionError InitializeServer(int connections, int listenPort, bool useNat);
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public static NetworkConnectionError InitializeServer(int connections, int listenPort);
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static void InitializeSecurity();
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static NetworkConnectionError Connect(string IP, int remotePort);
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public static NetworkConnectionError Connect(string IP, int remotePort, string password);
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public static NetworkConnectionError Connect(string[] IPs, int remotePort);
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public static NetworkConnectionError Connect(string[] IPs, int remotePort, string password);
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static NetworkConnectionError Connect(string GUID);
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static NetworkConnectionError Connect(string GUID, string password);
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public static NetworkConnectionError Connect(HostData hostData);
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public static NetworkConnectionError Connect(HostData hostData, string password);
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public static void Disconnect();
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static void Disconnect(int timeout);
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public static void CloseConnection(NetworkPlayer target, bool sendDisconnectionNotification);
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public static NetworkViewID AllocateViewID();
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static Object Instantiate(Object prefab, Vector3 position, Quaternion rotation, int group);
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public static void Destroy(NetworkViewID viewID);
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static void Destroy(GameObject gameObject);
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static void DestroyPlayerObjects(NetworkPlayer playerID);
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static void RemoveRPCs(NetworkPlayer playerID);
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static void RemoveRPCs(NetworkPlayer playerID, int group);
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public static void RemoveRPCs(NetworkViewID viewID);
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public static void RemoveRPCsInGroup(int group);
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public static void SetLevelPrefix(int prefix);
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public static int GetLastPing(NetworkPlayer player);
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public static int GetAveragePing(NetworkPlayer player);
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static void SetReceivingEnabled(NetworkPlayer player, int group, bool enabled);
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static void SetSendingEnabled(int group, bool enabled);
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static void SetSendingEnabled(NetworkPlayer player, int group, bool enabled);
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static ConnectionTesterStatus TestConnection();
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static ConnectionTesterStatus TestConnection(bool forceTest);
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static ConnectionTesterStatus TestConnectionNAT();
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public static ConnectionTesterStatus TestConnectionNAT(bool forceTest);
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public static bool HavePublicAddress();
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [EditorBrowsable(Never)]
    [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
    public class BitStream
    {
        public BitStream();

        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public bool isReading { get; }
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public bool isWriting { get; }

        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public void Serialize(ref bool value);
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public void Serialize(ref char value);
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public void Serialize(ref short value);
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public void Serialize(ref int value);
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public void Serialize(ref float value);
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public void Serialize(ref float value, float maxDelta);
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public void Serialize(ref Quaternion value);
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public void Serialize(ref Quaternion value, float maxDelta);
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public void Serialize(ref Vector3 value);
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public void Serialize(ref Vector3 value, float maxDelta);
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public void Serialize(ref NetworkPlayer value);
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public void Serialize(ref NetworkViewID viewID);
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
    [EditorBrowsable(Never)]
    public class RPC : Attribute
    {
        public RPC();
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [EditorBrowsable(Never)]
    [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
    public class HostData
    {
        public HostData();

        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public bool useNat { get; set; }
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public string gameType { get; set; }
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public string gameName { get; set; }
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public int connectedPlayers { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public int playerLimit { get; set; }
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public string[] ip { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public int port { get; set; }
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public bool passwordProtected { get; set; }
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public string comment { get; set; }
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public string guid { get; set; }
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [EditorBrowsable(Never)]
    [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
    public class MasterServer
    {
        public MasterServer();

        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static string ipAddress { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static int port { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static int updateRate { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static bool dedicatedServer { get; set; }

        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public static void RequestHostList(string gameTypeName);
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static HostData[] PollHostList();
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static void RegisterHost(string gameTypeName, string gameName);
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static void RegisterHost(string gameTypeName, string gameName, string comment);
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public static void UnregisterHost();
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public static void ClearHostList();
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [EditorBrowsable(Never)]
    [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
    public struct NetworkMessageInfo
    {
        [EditorBrowsable(Never)]
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        public double timestamp { get; }
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public NetworkPlayer sender { get; }
        [Obsolete("The legacy networking system has been removed in Unity 2018.2. Use Unity Multiplayer and NetworkIdentity instead.", True)]
        [EditorBrowsable(Never)]
        public NetworkView networkView { get; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Export/Networking/Ping.bindings.h")]
    public sealed class Ping
    {
        public Ping(string address);

        ~Ping();

        public bool isDone { get; }
        public int time { get; }
        public string ip { get; }

        [ThreadAndSerializationSafe]
        public void DestroyPing();
    }
}
using System;

namespace UnityEngine
{
    public class PlayerPrefsException : Exception
    {
        public PlayerPrefsException(string error);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Utilities/PlayerPrefs.h")]
    public class PlayerPrefs
    {
        public PlayerPrefs();

        public static void SetInt(string key, int value);
        public static int GetInt(string key, int defaultValue);
        public static int GetInt(string key);
        public static void SetFloat(string key, float value);
        public static float GetFloat(string key, float defaultValue);
        public static float GetFloat(string key);
        public static void SetString(string key, string value);
        public static string GetString(string key, string defaultValue);
        public static string GetString(string key);
        public static bool HasKey(string key);
        public static void DeleteKey(string key);
        [NativeMethod("DeleteAllWithCallback")]
        public static void DeleteAll();
        [NativeMethod("Sync")]
        public static void Save();
    }
}
using System;

namespace UnityEngine
{
    [AttributeUsage(Field, Inherited = True, AllowMultiple = False)]
    public abstract class PropertyAttribute : Attribute
    {
        protected PropertyAttribute();

        public int order { get; set; }
    }
}
using System;

namespace UnityEngine
{
    [AttributeUsage(Field, Inherited = True, AllowMultiple = True)]
    public class ContextMenuItemAttribute : PropertyAttribute
    {
        public readonly string name;
        public readonly string function;

        public ContextMenuItemAttribute(string name, string function);
    }
}
using System;

namespace UnityEngine
{
    [AttributeUsage(Field, Inherited = True, AllowMultiple = False)]
    public class InspectorNameAttribute : PropertyAttribute
    {
        public readonly string displayName;

        public InspectorNameAttribute(string displayName);
    }
}
using System;

namespace UnityEngine
{
    [AttributeUsage(Field, Inherited = True, AllowMultiple = False)]
    public class TooltipAttribute : PropertyAttribute
    {
        public readonly string tooltip;

        public TooltipAttribute(string tooltip);
    }
}
using System;

namespace UnityEngine
{
    [AttributeUsage(Field, Inherited = True, AllowMultiple = True)]
    public class SpaceAttribute : PropertyAttribute
    {
        public readonly float height;

        public SpaceAttribute();
        public SpaceAttribute(float height);
    }
}
using System;

namespace UnityEngine
{
    [AttributeUsage(Field, Inherited = True, AllowMultiple = True)]
    public class HeaderAttribute : PropertyAttribute
    {
        public readonly string header;

        public HeaderAttribute(string header);
    }
}
using System;

namespace UnityEngine
{
    [AttributeUsage(Field, Inherited = True, AllowMultiple = False)]
    public sealed class RangeAttribute : PropertyAttribute
    {
        public readonly float min;
        public readonly float max;

        public RangeAttribute(float min, float max);
    }
}
using System;

namespace UnityEngine
{
    [AttributeUsage(Field, Inherited = True, AllowMultiple = False)]
    public sealed class MinAttribute : PropertyAttribute
    {
        public readonly float min;

        public MinAttribute(float min);
    }
}
using System;

namespace UnityEngine
{
    [AttributeUsage(Field, Inherited = True, AllowMultiple = False)]
    public sealed class MultilineAttribute : PropertyAttribute
    {
        public readonly int lines;

        public MultilineAttribute();
        public MultilineAttribute(int lines);
    }
}
using System;

namespace UnityEngine
{
    [AttributeUsage(Field, Inherited = True, AllowMultiple = False)]
    public sealed class TextAreaAttribute : PropertyAttribute
    {
        public readonly int minLines;
        public readonly int maxLines;

        public TextAreaAttribute();
        public TextAreaAttribute(int minLines, int maxLines);
    }
}
using System;

namespace UnityEngine
{
    [AttributeUsage(Field, Inherited = True, AllowMultiple = False)]
    public sealed class ColorUsageAttribute : PropertyAttribute
    {
        public readonly bool showAlpha;
        public readonly bool hdr;
        [Obsolete("This field is no longer used for anything.")]
        public readonly float minBrightness;
        [Obsolete("This field is no longer used for anything.")]
        public readonly float maxBrightness;
        [Obsolete("This field is no longer used for anything.")]
        public readonly float minExposureValue;
        [Obsolete("This field is no longer used for anything.")]
        public readonly float maxExposureValue;

        public ColorUsageAttribute(bool showAlpha);
        public ColorUsageAttribute(bool showAlpha, bool hdr);
        [Obsolete("Brightness and exposure parameters are no longer used for anything. Use ColorUsageAttribute(bool showAlpha, bool hdr)")]
        public ColorUsageAttribute(bool showAlpha, bool hdr, float minBrightness, float maxBrightness, float minExposureValue, float maxExposureValue);
    }
}
using System;

namespace UnityEngine
{
    [AttributeUsage(Field, Inherited = True, AllowMultiple = False)]
    public sealed class GradientUsageAttribute : PropertyAttribute
    {
        public readonly bool hdr;
        public readonly ColorSpace colorSpace;

        public GradientUsageAttribute(bool hdr);
        public GradientUsageAttribute(bool hdr, ColorSpace colorSpace);
    }
}
using System;

namespace UnityEngine
{
    [AttributeUsage(Field, Inherited = True, AllowMultiple = False)]
    public sealed class DelayedAttribute : PropertyAttribute
    {
        public DelayedAttribute();
    }
}
using System;

namespace UnityEngine
{
    [AttributeUsage(Field, Inherited = True, AllowMultiple = False)]
    public sealed class NonReorderableAttribute : PropertyAttribute
    {
        public NonReorderableAttribute();
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    public struct PropertyName : IEquatable<PropertyName>
    {
        public PropertyName(string name);
        public PropertyName(PropertyName other);
        public PropertyName(int id);

        public static bool IsNullOrEmpty(PropertyName prop);
        public override int GetHashCode();
        public override bool Equals(object other);
        public bool Equals(PropertyName other);
        public override string ToString();

        public static bool operator ==(PropertyName lhs, PropertyName rhs);
        public static bool operator !=(PropertyName lhs, PropertyName rhs);

        public static implicit operator PropertyName(string name);
        public static implicit operator PropertyName(int id);
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Export/Random/Random.bindings.h")]
    public static class Random
    {
        [StaticAccessor("GetScriptingRand()", Dot)]
        public static State state { get; set; }
        public static float value { get; }
        public static Vector3 insideUnitSphere { get; }
        public static Vector2 insideUnitCircle { get; }
        public static Vector3 onUnitSphere { get; }
        public static Quaternion rotation { get; }
        public static Quaternion rotationUniform { get; }
        [Obsolete("Deprecated. Use InitState() function or Random.state property instead.")]
        [StaticAccessor("GetScriptingRand()", Dot)]
        public static int seed { get; set; }

        [StaticAccessor("GetScriptingRand()", Dot)]
        [NativeMethod("SetSeed")]
        public static void InitState(int seed);
        [FreeFunction]
        public static float Range(float minInclusive, float maxInclusive);
        public static int Range(int minInclusive, int maxExclusive);
        [Obsolete("Use Random.Range instead")]
        public static float RandomRange(float min, float max);
        [Obsolete("Use Random.Range instead")]
        public static int RandomRange(int min, int max);
        public static Color ColorHSV();
        public static Color ColorHSV(float hueMin, float hueMax);
        public static Color ColorHSV(float hueMin, float hueMax, float saturationMin, float saturationMax);
        public static Color ColorHSV(float hueMin, float hueMax, float saturationMin, float saturationMax, float valueMin, float valueMax);
        public static Color ColorHSV(float hueMin, float hueMax, float saturationMin, float saturationMax, float valueMin, float valueMax, float alphaMin, float alphaMax);

        public struct State
        {
        }
    }
}
using UnityEngine.Scripting;

namespace UnityEngine
{
    [RequiredByNativeCode]
    public class ResourceRequest : AsyncOperation
    {
        public ResourceRequest();

        public Object asset { get; }

        protected virtual Object GetResult();
    }
}
using System;

namespace UnityEngine
{
    public class ResourcesAPI
    {
        protected internal ResourcesAPI();

        public static ResourcesAPI overrideAPI { get; set; }

        protected internal virtual Object[] FindObjectsOfTypeAll(Type systemTypeInstance);
        protected internal virtual Shader FindShaderByName(string name);
        protected internal virtual Object Load(string path, Type systemTypeInstance);
        protected internal virtual Object[] LoadAll(string path, Type systemTypeInstance);
        protected internal virtual ResourceRequest LoadAsync(string path, Type systemTypeInstance);
        protected internal virtual void UnloadAsset(Object assetToUnload);
    }
}
using System;
using System.Collections.Generic;
using System.ComponentModel;
using Unity.Collections;
using UnityEngine.Bindings;
using UnityEngineInternal;

namespace UnityEngine
{
    [NativeHeader("Runtime/Misc/ResourceManagerUtility.h")]
    [NativeHeader("Runtime/Export/Resources/Resources.bindings.h")]
    public sealed class Resources
    {
        public Resources();

        public static Object[] FindObjectsOfTypeAll(Type type);
        public static T[] FindObjectsOfTypeAll<T>() where T : Object;
        public static Object Load(string path);
        public static T Load<T>(string path) where T : Object;
        public static Object Load(string path, Type systemTypeInstance);
        public static ResourceRequest LoadAsync(string path);
        public static ResourceRequest LoadAsync<T>(string path) where T : Object;
        public static ResourceRequest LoadAsync(string path, Type type);
        public static Object[] LoadAll(string path, Type systemTypeInstance);
        public static Object[] LoadAll(string path);
        public static T[] LoadAll<T>(string path) where T : Object;
        [TypeInferenceRule(TypeReferencedByFirstArgument)]
        [FreeFunction("GetScriptingBuiltinResource", ThrowsException = True)]
        public static Object GetBuiltinResource([NotNull("ArgumentNullException")] Type type, string path);
        public static T GetBuiltinResource<T>(string path) where T : Object;
        public static void UnloadAsset(Object assetToUnload);
        [FreeFunction("Resources_Bindings::UnloadUnusedAssets")]
        public static AsyncOperation UnloadUnusedAssets();
        [FreeFunction("Resources_Bindings::InstanceIDToObject")]
        public static Object InstanceIDToObject(int instanceID);
        public static void InstanceIDToObjectList(NativeArray<int> instanceIDs, List<Object> objects);
        [EditorBrowsable(Never)]
        [TypeInferenceRule(TypeReferencedBySecondArgument)]
        [Obsolete("Use AssetDatabase.LoadAssetAtPath instead (UnityUpgradable) -> * [UnityEditor] UnityEditor.AssetDatabase.LoadAssetAtPath(*)", True)]
        public static Object LoadAssetAtPath(string assetPath, Type type);
        [Obsolete("Use AssetDatabase.LoadAssetAtPath<T>() instead (UnityUpgradable) -> * [UnityEditor] UnityEditor.AssetDatabase.LoadAssetAtPath<T>(*)", True)]
        [EditorBrowsable(Never)]
        public static T LoadAssetAtPath<T>(string assetPath) where T : Object;
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Runtime/Misc/AsyncOperation.h")]
    [NativeHeader("Runtime/Export/Scripting/AsyncOperation.bindings.h")]
    [RequiredByNativeCode]
    public class AsyncOperation : YieldInstruction
    {
        public AsyncOperation();

        ~AsyncOperation();

        public bool isDone { get; }
        public float progress { get; }
        public int priority { get; set; }
        public bool allowSceneActivation { get; set; }

        public event Action<AsyncOperation> completed;
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [RequiredByNativeCode]
    [AttributeUsage(Class, Inherited = False)]
    public sealed class DisallowMultipleComponent : Attribute
    {
        public DisallowMultipleComponent();
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [RequiredByNativeCode]
    [AttributeUsage(Class, AllowMultiple = True)]
    public sealed class RequireComponent : Attribute
    {
        public Type m_Type0;
        public Type m_Type1;
        public Type m_Type2;

        public RequireComponent(Type requiredComponent);
        public RequireComponent(Type requiredComponent, Type requiredComponent2);
        public RequireComponent(Type requiredComponent, Type requiredComponent2, Type requiredComponent3);
    }
}
using System;

namespace UnityEngine
{
    public sealed class AddComponentMenu : Attribute
    {
        public AddComponentMenu(string menuName);
        public AddComponentMenu(string menuName, int order);

        public string componentMenu { get; }
        public int componentOrder { get; }
    }
}
using System;

namespace UnityEngine
{
    [AttributeUsage(Class, AllowMultiple = False, Inherited = False)]
    public sealed class CreateAssetMenuAttribute : Attribute
    {
        public CreateAssetMenuAttribute();

        public string menuName { get; set; }
        public string fileName { get; set; }
        public int order { get; set; }
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [AttributeUsage(Method, AllowMultiple = True)]
    [RequiredByNativeCode]
    public sealed class ContextMenu : Attribute
    {
        public readonly string menuItem;
        public readonly bool validate;
        public readonly int priority;

        public ContextMenu(string itemName);
        public ContextMenu(string itemName, bool isValidateFunction);
        public ContextMenu(string itemName, bool isValidateFunction, int priority);
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    public sealed class ExecuteInEditMode : Attribute
    {
        public ExecuteInEditMode();
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    public sealed class ExecuteAlways : Attribute
    {
        public ExecuteAlways();
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    public sealed class HideInInspector : Attribute
    {
        public HideInInspector();
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [AttributeUsage(Class, AllowMultiple = False)]
    [UsedByNativeCode]
    public sealed class HelpURLAttribute : Attribute
    {
        public HelpURLAttribute(string url);

        public string URL { get; }
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [AttributeUsage(Class)]
    [UsedByNativeCode]
    public class DefaultExecutionOrder : Attribute
    {
        public DefaultExecutionOrder(int order);

        public int order { get; }
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [AttributeUsage(Assembly)]
    [RequiredByNativeCode]
    public class AssemblyIsEditorAssembly : Attribute
    {
        public AssemblyIsEditorAssembly();
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [AttributeUsage(Class, Inherited = False)]
    [UsedByNativeCode]
    public class ExcludeFromPresetAttribute : Attribute
    {
        public ExcludeFromPresetAttribute();
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    [NativeHeader("Runtime/Mono/MonoBehaviour.h")]
    public class Behaviour : Component
    {
        public Behaviour();

        [RequiredByNativeCode]
        [NativeProperty]
        public bool enabled { get; set; }
        [NativeProperty]
        public bool isActiveAndEnabled { get; }
    }
}
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Security;
using UnityEngine.Bindings;
using UnityEngine.Internal;
using UnityEngine.Scripting;
using UnityEngineInternal;

namespace UnityEngine
{
    [NativeHeader("Runtime/Export/Scripting/Component.bindings.h")]
    [NativeClass("Unity::Component")]
    [RequiredByNativeCode]
    public class Component : Object
    {
        public Component();

        public Transform transform { get; }
        public GameObject gameObject { get; }
        public string tag { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("Property rigidbody has been deprecated. Use GetComponent<Rigidbody>() instead. (UnityUpgradable)", True)]
        public Component rigidbody { get; }
        [EditorBrowsable(Never)]
        [Obsolete("Property rigidbody2D has been deprecated. Use GetComponent<Rigidbody2D>() instead. (UnityUpgradable)", True)]
        public Component rigidbody2D { get; }
        [Obsolete("Property camera has been deprecated. Use GetComponent<Camera>() instead. (UnityUpgradable)", True)]
        [EditorBrowsable(Never)]
        public Component camera { get; }
        [Obsolete("Property light has been deprecated. Use GetComponent<Light>() instead. (UnityUpgradable)", True)]
        [EditorBrowsable(Never)]
        public Component light { get; }
        [EditorBrowsable(Never)]
        [Obsolete("Property animation has been deprecated. Use GetComponent<Animation>() instead. (UnityUpgradable)", True)]
        public Component animation { get; }
        [Obsolete("Property constantForce has been deprecated. Use GetComponent<ConstantForce>() instead. (UnityUpgradable)", True)]
        [EditorBrowsable(Never)]
        public Component constantForce { get; }
        [Obsolete("Property renderer has been deprecated. Use GetComponent<Renderer>() instead. (UnityUpgradable)", True)]
        [EditorBrowsable(Never)]
        public Component renderer { get; }
        [Obsolete("Property audio has been deprecated. Use GetComponent<AudioSource>() instead. (UnityUpgradable)", True)]
        [EditorBrowsable(Never)]
        public Component audio { get; }
        [Obsolete("Property networkView has been deprecated. Use GetComponent<NetworkView>() instead. (UnityUpgradable)", True)]
        [EditorBrowsable(Never)]
        public Component networkView { get; }
        [EditorBrowsable(Never)]
        [Obsolete("Property collider has been deprecated. Use GetComponent<Collider>() instead. (UnityUpgradable)", True)]
        public Component collider { get; }
        [Obsolete("Property collider2D has been deprecated. Use GetComponent<Collider2D>() instead. (UnityUpgradable)", True)]
        [EditorBrowsable(Never)]
        public Component collider2D { get; }
        [EditorBrowsable(Never)]
        [Obsolete("Property hingeJoint has been deprecated. Use GetComponent<HingeJoint>() instead. (UnityUpgradable)", True)]
        public Component hingeJoint { get; }
        [EditorBrowsable(Never)]
        [Obsolete("Property particleSystem has been deprecated. Use GetComponent<ParticleSystem>() instead. (UnityUpgradable)", True)]
        public Component particleSystem { get; }

        [TypeInferenceRule(TypeReferencedByFirstArgument)]
        public Component GetComponent(Type type);
        [SecuritySafeCritical]
        public T GetComponent<T>();
        [TypeInferenceRule(TypeReferencedByFirstArgument)]
        public bool TryGetComponent(Type type, out Component component);
        [SecuritySafeCritical]
        public bool TryGetComponent<T>(out T component);
        [FreeFunction(HasExplicitThis = True)]
        public Component GetComponent(string type);
        [TypeInferenceRule(TypeReferencedByFirstArgument)]
        public Component GetComponentInChildren(Type t, bool includeInactive);
        [TypeInferenceRule(TypeReferencedByFirstArgument)]
        public Component GetComponentInChildren(Type t);
        public T GetComponentInChildren<T>([UnityEngine.Internal.DefaultValue("false")] bool includeInactive);
        [ExcludeFromDocs]
        public T GetComponentInChildren<T>();
        public Component[] GetComponentsInChildren(Type t, bool includeInactive);
        [ExcludeFromDocs]
        public Component[] GetComponentsInChildren(Type t);
        public T[] GetComponentsInChildren<T>(bool includeInactive);
        public void GetComponentsInChildren<T>(bool includeInactive, List<T> result);
        public T[] GetComponentsInChildren<T>();
        public void GetComponentsInChildren<T>(List<T> results);
        [TypeInferenceRule(TypeReferencedByFirstArgument)]
        public Component GetComponentInParent(Type t);
        public T GetComponentInParent<T>();
        public Component[] GetComponentsInParent(Type t, [UnityEngine.Internal.DefaultValue("false")] bool includeInactive);
        [ExcludeFromDocs]
        public Component[] GetComponentsInParent(Type t);
        public T[] GetComponentsInParent<T>(bool includeInactive);
        public void GetComponentsInParent<T>(bool includeInactive, List<T> results);
        public T[] GetComponentsInParent<T>();
        public Component[] GetComponents(Type type);
        public void GetComponents(Type type, List<Component> results);
        public void GetComponents<T>(List<T> results);
        public T[] GetComponents<T>();
        public bool CompareTag(string tag);
        [FreeFunction(HasExplicitThis = True)]
        public void SendMessageUpwards(string methodName, [UnityEngine.Internal.DefaultValue("null")] object value, [UnityEngine.Internal.DefaultValue("SendMessageOptions.RequireReceiver")] SendMessageOptions options);
        [ExcludeFromDocs]
        public void SendMessageUpwards(string methodName, object value);
        [ExcludeFromDocs]
        public void SendMessageUpwards(string methodName);
        public void SendMessageUpwards(string methodName, SendMessageOptions options);
        public void SendMessage(string methodName, object value);
        public void SendMessage(string methodName);
        [FreeFunction("SendMessage", HasExplicitThis = True)]
        public void SendMessage(string methodName, object value, SendMessageOptions options);
        public void SendMessage(string methodName, SendMessageOptions options);
        [FreeFunction("BroadcastMessage", HasExplicitThis = True)]
        public void BroadcastMessage(string methodName, [UnityEngine.Internal.DefaultValue("null")] object parameter, [UnityEngine.Internal.DefaultValue("SendMessageOptions.RequireReceiver")] SendMessageOptions options);
        [ExcludeFromDocs]
        public void BroadcastMessage(string methodName, object parameter);
        [ExcludeFromDocs]
        public void BroadcastMessage(string methodName);
        public void BroadcastMessage(string methodName, SendMessageOptions options);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Runtime/Mono/Coroutine.h")]
    [RequiredByNativeCode]
    public sealed class Coroutine : YieldInstruction
    {
        ~Coroutine();
    }
}
using System.Collections;

namespace UnityEngine
{
    public abstract class CustomYieldInstruction : IEnumerator
    {
        protected CustomYieldInstruction();

        public abstract bool keepWaiting { get; }
        public object Current { get; }

        public bool MoveNext();
        public virtual void Reset();
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [AttributeUsage(Class)]
    [UsedByNativeCode]
    public class ExcludeFromObjectFactoryAttribute : Attribute
    {
        public ExcludeFromObjectFactoryAttribute();
    }
}
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Security;
using UnityEngine.Bindings;
using UnityEngine.Internal;
using UnityEngine.SceneManagement;
using UnityEngine.Scripting;
using UnityEngineInternal;

namespace UnityEngine
{
    [NativeHeader("Runtime/Export/Scripting/GameObject.bindings.h")]
    [UsedByNativeCode]
    [ExcludeFromPreset]
    public sealed class GameObject : Object
    {
        public GameObject(string name);
        public GameObject();
        public GameObject(string name, params Type[] components);

        public Transform transform { get; }
        public int layer { get; set; }
        [Obsolete("GameObject.active is obsolete. Use GameObject.SetActive(), GameObject.activeSelf or GameObject.activeInHierarchy.")]
        public bool active { get; set; }
        public bool activeSelf { get; }
        public bool activeInHierarchy { get; }
        public bool isStatic { get; set; }
        public string tag { get; set; }
        public Scene scene { get; }
        public ulong sceneCullingMask { get; }
        public GameObject gameObject { get; }
        [Obsolete("Property rigidbody has been deprecated. Use GetComponent<Rigidbody>() instead. (UnityUpgradable)", True)]
        [EditorBrowsable(Never)]
        public Component rigidbody { get; }
        [Obsolete("Property rigidbody2D has been deprecated. Use GetComponent<Rigidbody2D>() instead. (UnityUpgradable)", True)]
        [EditorBrowsable(Never)]
        public Component rigidbody2D { get; }
        [Obsolete("Property camera has been deprecated. Use GetComponent<Camera>() instead. (UnityUpgradable)", True)]
        [EditorBrowsable(Never)]
        public Component camera { get; }
        [EditorBrowsable(Never)]
        [Obsolete("Property light has been deprecated. Use GetComponent<Light>() instead. (UnityUpgradable)", True)]
        public Component light { get; }
        [Obsolete("Property animation has been deprecated. Use GetComponent<Animation>() instead. (UnityUpgradable)", True)]
        [EditorBrowsable(Never)]
        public Component animation { get; }
        [EditorBrowsable(Never)]
        [Obsolete("Property constantForce has been deprecated. Use GetComponent<ConstantForce>() instead. (UnityUpgradable)", True)]
        public Component constantForce { get; }
        [Obsolete("Property renderer has been deprecated. Use GetComponent<Renderer>() instead. (UnityUpgradable)", True)]
        [EditorBrowsable(Never)]
        public Component renderer { get; }
        [EditorBrowsable(Never)]
        [Obsolete("Property audio has been deprecated. Use GetComponent<AudioSource>() instead. (UnityUpgradable)", True)]
        public Component audio { get; }
        [EditorBrowsable(Never)]
        [Obsolete("Property networkView has been deprecated. Use GetComponent<NetworkView>() instead. (UnityUpgradable)", True)]
        public Component networkView { get; }
        [EditorBrowsable(Never)]
        [Obsolete("Property collider has been deprecated. Use GetComponent<Collider>() instead. (UnityUpgradable)", True)]
        public Component collider { get; }
        [EditorBrowsable(Never)]
        [Obsolete("Property collider2D has been deprecated. Use GetComponent<Collider2D>() instead. (UnityUpgradable)", True)]
        public Component collider2D { get; }
        [EditorBrowsable(Never)]
        [Obsolete("Property hingeJoint has been deprecated. Use GetComponent<HingeJoint>() instead. (UnityUpgradable)", True)]
        public Component hingeJoint { get; }
        [EditorBrowsable(Never)]
        [Obsolete("Property particleSystem has been deprecated. Use GetComponent<ParticleSystem>() instead. (UnityUpgradable)", True)]
        public Component particleSystem { get; }

        [FreeFunction("GameObjectBindings::CreatePrimitive")]
        public static GameObject CreatePrimitive(PrimitiveType type);
        [SecuritySafeCritical]
        public T GetComponent<T>();
        [TypeInferenceRule(TypeReferencedByFirstArgument)]
        [FreeFunction(Name = "GameObjectBindings::GetComponentFromType", HasExplicitThis = True, ThrowsException = True)]
        public Component GetComponent(Type type);
        public Component GetComponent(string type);
        [TypeInferenceRule(TypeReferencedByFirstArgument)]
        [FreeFunction(Name = "GameObjectBindings::GetComponentInChildren", HasExplicitThis = True, ThrowsException = True)]
        public Component GetComponentInChildren(Type type, bool includeInactive);
        [TypeInferenceRule(TypeReferencedByFirstArgument)]
        public Component GetComponentInChildren(Type type);
        [ExcludeFromDocs]
        public T GetComponentInChildren<T>();
        public T GetComponentInChildren<T>([UnityEngine.Internal.DefaultValue("false")] bool includeInactive);
        [FreeFunction(Name = "GameObjectBindings::GetComponentInParent", HasExplicitThis = True, ThrowsException = True)]
        [TypeInferenceRule(TypeReferencedByFirstArgument)]
        public Component GetComponentInParent(Type type, bool includeInactive);
        [TypeInferenceRule(TypeReferencedByFirstArgument)]
        public Component GetComponentInParent(Type type);
        [ExcludeFromDocs]
        public T GetComponentInParent<T>();
        public T GetComponentInParent<T>([UnityEngine.Internal.DefaultValue("false")] bool includeInactive);
        public Component[] GetComponents(Type type);
        public T[] GetComponents<T>();
        public void GetComponents(Type type, List<Component> results);
        public void GetComponents<T>(List<T> results);
        [ExcludeFromDocs]
        public Component[] GetComponentsInChildren(Type type);
        public Component[] GetComponentsInChildren(Type type, [UnityEngine.Internal.DefaultValue("false")] bool includeInactive);
        public T[] GetComponentsInChildren<T>(bool includeInactive);
        public void GetComponentsInChildren<T>(bool includeInactive, List<T> results);
        public T[] GetComponentsInChildren<T>();
        public void GetComponentsInChildren<T>(List<T> results);
        [ExcludeFromDocs]
        public Component[] GetComponentsInParent(Type type);
        public Component[] GetComponentsInParent(Type type, [UnityEngine.Internal.DefaultValue("false")] bool includeInactive);
        public void GetComponentsInParent<T>(bool includeInactive, List<T> results);
        public T[] GetComponentsInParent<T>(bool includeInactive);
        public T[] GetComponentsInParent<T>();
        [SecuritySafeCritical]
        public bool TryGetComponent<T>(out T component);
        public bool TryGetComponent(Type type, out Component component);
        public static GameObject FindWithTag(string tag);
        public void SendMessageUpwards(string methodName, SendMessageOptions options);
        public void SendMessage(string methodName, SendMessageOptions options);
        public void BroadcastMessage(string methodName, SendMessageOptions options);
        [TypeInferenceRule(TypeReferencedByFirstArgument)]
        public Component AddComponent(Type componentType);
        public T AddComponent<T>() where T : Component;
        [NativeMethod(Name = "SetSelfActive")]
        public void SetActive(bool value);
        [NativeMethod(Name = "SetActiveRecursivelyDeprecated")]
        [Obsolete("gameObject.SetActiveRecursively() is obsolete. Use GameObject.SetActive(), which is now inherited by children.")]
        public void SetActiveRecursively(bool state);
        [FreeFunction(Name = "GameObjectBindings::CompareTag", HasExplicitThis = True)]
        public bool CompareTag(string tag);
        [FreeFunction(Name = "GameObjectBindings::FindGameObjectWithTag", ThrowsException = True)]
        public static GameObject FindGameObjectWithTag(string tag);
        [FreeFunction(Name = "GameObjectBindings::FindGameObjectsWithTag", ThrowsException = True)]
        public static GameObject[] FindGameObjectsWithTag(string tag);
        [FreeFunction(Name = "Scripting::SendScriptingMessageUpwards", HasExplicitThis = True)]
        public void SendMessageUpwards(string methodName, [UnityEngine.Internal.DefaultValue("null")] object value, [UnityEngine.Internal.DefaultValue("SendMessageOptions.RequireReceiver")] SendMessageOptions options);
        [ExcludeFromDocs]
        public void SendMessageUpwards(string methodName, object value);
        [ExcludeFromDocs]
        public void SendMessageUpwards(string methodName);
        [FreeFunction(Name = "Scripting::SendScriptingMessage", HasExplicitThis = True)]
        public void SendMessage(string methodName, [UnityEngine.Internal.DefaultValue("null")] object value, [UnityEngine.Internal.DefaultValue("SendMessageOptions.RequireReceiver")] SendMessageOptions options);
        [ExcludeFromDocs]
        public void SendMessage(string methodName, object value);
        [ExcludeFromDocs]
        public void SendMessage(string methodName);
        [FreeFunction(Name = "Scripting::BroadcastScriptingMessage", HasExplicitThis = True)]
        public void BroadcastMessage(string methodName, [UnityEngine.Internal.DefaultValue("null")] object parameter, [UnityEngine.Internal.DefaultValue("SendMessageOptions.RequireReceiver")] SendMessageOptions options);
        [ExcludeFromDocs]
        public void BroadcastMessage(string methodName, object parameter);
        [ExcludeFromDocs]
        public void BroadcastMessage(string methodName);
        [FreeFunction(Name = "GameObjectBindings::Find")]
        public static GameObject Find(string name);
        [EditorBrowsable(Never)]
        [Obsolete("GameObject.SampleAnimation(AnimationClip, float) has been deprecated. Use AnimationClip.SampleAnimation(GameObject, float) instead (UnityUpgradable).", True)]
        public void SampleAnimation(Object clip, float time);
        [EditorBrowsable(Never)]
        [Obsolete("GameObject.AddComponent with string argument has been deprecated. Use GameObject.AddComponent<T>() instead. (UnityUpgradable).", True)]
        public Component AddComponent(string className);
        [EditorBrowsable(Never)]
        [Obsolete("gameObject.PlayAnimation is not supported anymore. Use animation.Play()", True)]
        public void PlayAnimation(Object animation);
        [Obsolete("gameObject.StopAnimation is not supported anymore. Use animation.Stop()", True)]
        [EditorBrowsable(Never)]
        public void StopAnimation();
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeClass("BitField", "struct BitField;")]
    [NativeHeader("Runtime/BaseClasses/BitField.h")]
    [NativeHeader("Runtime/BaseClasses/TagManager.h")]
    [RequiredByNativeCode(Optional = True, GenerateProxy = True)]
    public struct LayerMask
    {
        public int value { get; set; }

        [StaticAccessor("GetTagManager()", Dot)]
        [NativeMethod("LayerToString")]
        public static string LayerToName(int layer);
        [StaticAccessor("GetTagManager()", Dot)]
        [NativeMethod("StringToLayer")]
        public static int NameToLayer(string layerName);
        public static int GetMask(params string[] layerNames);

        public static implicit operator int(LayerMask mask);
        public static implicit operator LayerMask(int intVal);
    }
}
namespace UnityEngine
{
    public struct LazyLoadReference<T> where T : Object
    {
        public LazyLoadReference(T asset);
        public LazyLoadReference(int instanceID);

        public bool isSet { get; }
        public bool isBroken { get; }
        public T asset { get; set; }
        public int instanceID { get; set; }

        public static implicit operator LazyLoadReference<T>(T asset);
        public static implicit operator LazyLoadReference<T>(int instanceID);
    }
}
using System;
using System.Collections;
using UnityEngine.Bindings;
using UnityEngine.Internal;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [RequiredByNativeCode]
    [NativeHeader("Runtime/Mono/MonoBehaviour.h")]
    [ExtensionOfNativeClass]
    [NativeHeader("Runtime/Scripting/DelayedCallUtility.h")]
    public class MonoBehaviour : Behaviour
    {
        public MonoBehaviour();

        public bool useGUILayout { get; set; }
        public bool runInEditMode { get; set; }

        public bool IsInvoking();
        public void CancelInvoke();
        public void Invoke(string methodName, float time);
        public void InvokeRepeating(string methodName, float time, float repeatRate);
        public void CancelInvoke(string methodName);
        public bool IsInvoking(string methodName);
        [ExcludeFromDocs]
        public Coroutine StartCoroutine(string methodName);
        public Coroutine StartCoroutine(string methodName, [DefaultValue("null")] object value);
        public Coroutine StartCoroutine(IEnumerator routine);
        [Obsolete("StartCoroutine_Auto has been deprecated. Use StartCoroutine instead (UnityUpgradable) -> StartCoroutine([mscorlib] System.Collections.IEnumerator)", False)]
        public Coroutine StartCoroutine_Auto(IEnumerator routine);
        public void StopCoroutine(IEnumerator routine);
        public void StopCoroutine(Coroutine routine);
        public void StopCoroutine(string methodName);
        public void StopAllCoroutines();
        public static void print(object message);
    }
}
namespace UnityEngine
{
    public struct RangeInt
    {
        public int start;
        public int length;

        public RangeInt(int start, int length);

        public int end { get; }
    }
}
namespace UnityEngine
{
    public enum RuntimeInitializeLoadType
    {
        AfterSceneLoad = 0,
        BeforeSceneLoad = 1,
        AfterAssembliesLoaded = 2,
        BeforeSplashScreen = 3,
        SubsystemRegistration = 4
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [RequiredByNativeCode]
    [AttributeUsage(Method, AllowMultiple = False)]
    public class RuntimeInitializeOnLoadMethodAttribute : PreserveAttribute
    {
        public RuntimeInitializeOnLoadMethodAttribute();
        public RuntimeInitializeOnLoadMethodAttribute(RuntimeInitializeLoadType loadType);

        public RuntimeInitializeLoadType loadType { get; }
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [RequiredByNativeCode]
    [ExtensionOfNativeClass]
    [NativeClass(null)]
    [NativeHeader("Runtime/Mono/MonoBehaviour.h")]
    public class ScriptableObject : Object
    {
        public ScriptableObject();

        [NativeConditional("ENABLE_MONO")]
        [Obsolete("Use EditorUtility.SetDirty instead")]
        public void SetDirty();
        public static ScriptableObject CreateInstance(string className);
        public static ScriptableObject CreateInstance(Type type);
        public static T CreateInstance<T>() where T : ScriptableObject;
    }
}
using System;

namespace UnityEngine
{
    [AttributeUsage(Class, Inherited = True, AllowMultiple = False)]
    public class SelectionBaseAttribute : Attribute
    {
        public SelectionBaseAttribute();
    }
}
using System.Security;
using UnityEngine.Scripting;

namespace UnityEngine
{
    public static class StackTraceUtility
    {
        [SecuritySafeCritical]
        [RequiredByNativeCode]
        public static string ExtractStackTrace();
        public static string ExtractStringFromException(object exception);
    }
}
using System;
using System.Runtime.Serialization;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [RequiredByNativeCode]
    public class UnityException : SystemException
    {
        public UnityException();
        public UnityException(string message);
        public UnityException(string message, Exception innerException);
        protected UnityException(SerializationInfo info, StreamingContext context);
    }
}
using System;
using System.Runtime.Serialization;

namespace UnityEngine
{
    public class MissingComponentException : SystemException
    {
        public MissingComponentException();
        public MissingComponentException(string message);
        public MissingComponentException(string message, Exception innerException);
        protected MissingComponentException(SerializationInfo info, StreamingContext context);
    }
}
using System;
using System.Runtime.Serialization;

namespace UnityEngine
{
    public class UnassignedReferenceException : SystemException
    {
        public UnassignedReferenceException();
        public UnassignedReferenceException(string message);
        public UnassignedReferenceException(string message, Exception innerException);
        protected UnassignedReferenceException(SerializationInfo info, StreamingContext context);
    }
}
using System;
using System.Runtime.Serialization;

namespace UnityEngine
{
    public class MissingReferenceException : SystemException
    {
        public MissingReferenceException();
        public MissingReferenceException(string message);
        public MissingReferenceException(string message, Exception innerException);
        protected MissingReferenceException(SerializationInfo info, StreamingContext context);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Scripting/TextAsset.h")]
    public class TextAsset : Object
    {
        public TextAsset();
        public TextAsset(string text);

        public byte[] bytes { get; }
        public string text { get; }

        public override string ToString();
    }
}
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    public class TrackedReference
    {
        protected TrackedReference();

        public override bool Equals(object o);
        public override int GetHashCode();

        public static bool operator ==(TrackedReference x, TrackedReference y);
        public static bool operator !=(TrackedReference x, TrackedReference y);

        public static implicit operator bool(TrackedReference exists);
    }
}
using System;

namespace UnityEngine
{
    [AttributeUsage(Assembly, AllowMultiple = False)]
    public class UnityAPICompatibilityVersionAttribute : Attribute
    {
        [Obsolete("This overload of the attribute has been deprecated. Use the constructor that takes the version and a boolean", True)]
        public UnityAPICompatibilityVersionAttribute(string version);
        public UnityAPICompatibilityVersionAttribute(string version, bool checkOnlyUnityVersion);
        public UnityAPICompatibilityVersionAttribute(string version, string[] configurationAssembliesHashes);

        public string version { get; }
    }
}
using System;

namespace UnityEngine
{
    [Flags]
    public enum HideFlags
    {
        None = 0,
        HideInHierarchy = 1,
        HideInInspector = 2,
        DontSaveInEditor = 4,
        NotEditable = 8,
        DontSaveInBuild = 16,
        DontUnloadUnusedAsset = 32,
        DontSave = 52,
        HideAndDontSave = 61
    }
}
using System;
using System.Security;
using UnityEngine.Bindings;
using UnityEngine.Internal;
using UnityEngine.Scripting;
using UnityEngineInternal;

namespace UnityEngine
{
    [RequiredByNativeCode(GenerateProxy = True)]
    [NativeHeader("Runtime/SceneManager/SceneManager.h")]
    [NativeHeader("Runtime/GameCode/CloneObject.h")]
    [NativeHeader("Runtime/Export/Scripting/UnityEngineObject.bindings.h")]
    public class Object
    {
        public Object();

        public string name { get; set; }
        public HideFlags hideFlags { get; set; }

        [SecuritySafeCritical]
        public int GetInstanceID();
        public override int GetHashCode();
        public override bool Equals(object other);
        [TypeInferenceRule(TypeOfFirstArgument)]
        public static Object Instantiate(Object original, Vector3 position, Quaternion rotation);
        [TypeInferenceRule(TypeOfFirstArgument)]
        public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent);
        [TypeInferenceRule(TypeOfFirstArgument)]
        public static Object Instantiate(Object original);
        [TypeInferenceRule(TypeOfFirstArgument)]
        public static Object Instantiate(Object original, Transform parent);
        [TypeInferenceRule(TypeOfFirstArgument)]
        public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace);
        public static T Instantiate<T>(T original) where T : Object;
        public static T Instantiate<T>(T original, Vector3 position, Quaternion rotation) where T : Object;
        public static T Instantiate<T>(T original, Vector3 position, Quaternion rotation, Transform parent) where T : Object;
        public static T Instantiate<T>(T original, Transform parent) where T : Object;
        public static T Instantiate<T>(T original, Transform parent, bool worldPositionStays) where T : Object;
        [NativeMethod(Name = "Scripting::DestroyObjectFromScripting", IsFreeFunction = True, ThrowsException = True)]
        public static void Destroy(Object obj, [DefaultValue("0.0F")] float t);
        [ExcludeFromDocs]
        public static void Destroy(Object obj);
        [NativeMethod(Name = "Scripting::DestroyObjectFromScriptingImmediate", IsFreeFunction = True, ThrowsException = True)]
        public static void DestroyImmediate(Object obj, [DefaultValue("false")] bool allowDestroyingAssets);
        [ExcludeFromDocs]
        public static void DestroyImmediate(Object obj);
        public static Object[] FindObjectsOfType(Type type);
        [FreeFunction("UnityEngineObjectBindings::FindObjectsOfType")]
        [TypeInferenceRule(ArrayOfTypeReferencedByFirstArgument)]
        public static Object[] FindObjectsOfType(Type type, bool includeInactive);
        [FreeFunction("GetSceneManager().DontDestroyOnLoad", ThrowsException = True)]
        public static void DontDestroyOnLoad([NotNull("NullExceptionObject")] Object target);
        [Obsolete("use Object.Destroy instead.")]
        public static void DestroyObject(Object obj, [DefaultValue("0.0F")] float t);
        [ExcludeFromDocs]
        [Obsolete("use Object.Destroy instead.")]
        public static void DestroyObject(Object obj);
        [Obsolete("warning use Object.FindObjectsOfType instead.")]
        public static Object[] FindSceneObjectsOfType(Type type);
        [Obsolete("use Resources.FindObjectsOfTypeAll instead.")]
        [FreeFunction("UnityEngineObjectBindings::FindObjectsOfTypeIncludingAssets")]
        public static Object[] FindObjectsOfTypeIncludingAssets(Type type);
        public static T[] FindObjectsOfType<T>() where T : Object;
        public static T[] FindObjectsOfType<T>(bool includeInactive) where T : Object;
        public static T FindObjectOfType<T>() where T : Object;
        public static T FindObjectOfType<T>(bool includeInactive) where T : Object;
        [Obsolete("Please use Resources.FindObjectsOfTypeAll instead")]
        public static Object[] FindObjectsOfTypeAll(Type type);
        [TypeInferenceRule(TypeReferencedByFirstArgument)]
        public static Object FindObjectOfType(Type type);
        [TypeInferenceRule(TypeReferencedByFirstArgument)]
        public static Object FindObjectOfType(Type type, bool includeInactive);
        public override string ToString();

        public static bool operator ==(Object x, Object y);
        public static bool operator !=(Object x, Object y);

        public static implicit operator bool(Object exists);
    }
}
using UnityEngine.Scripting;

namespace UnityEngine
{
    [RequiredByNativeCode]
    public sealed class WaitForEndOfFrame : YieldInstruction
    {
        public WaitForEndOfFrame();
    }
}
using UnityEngine.Scripting;

namespace UnityEngine
{
    [RequiredByNativeCode]
    public sealed class WaitForFixedUpdate : YieldInstruction
    {
        public WaitForFixedUpdate();
    }
}
using UnityEngine.Scripting;

namespace UnityEngine
{
    [RequiredByNativeCode]
    public sealed class WaitForSeconds : YieldInstruction
    {
        public WaitForSeconds(float seconds);
    }
}
namespace UnityEngine
{
    public class WaitForSecondsRealtime : CustomYieldInstruction
    {
        public WaitForSecondsRealtime(float time);

        public float waitTime { get; set; }
        public override bool keepWaiting { get; }

        public override void Reset();
    }
}
using System;

namespace UnityEngine
{
    public sealed class WaitUntil : CustomYieldInstruction
    {
        public WaitUntil(Func<bool> predicate);

        public override bool keepWaiting { get; }
    }
}
using System;

namespace UnityEngine
{
    public sealed class WaitWhile : CustomYieldInstruction
    {
        public WaitWhile(Func<bool> predicate);

        public override bool keepWaiting { get; }
    }
}
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    public class YieldInstruction
    {
        public YieldInstruction();
    }
}
using System;
using System.ComponentModel;
using System.Reflection;
using UnityEngine.Internal;

namespace UnityEngine
{
    public sealed class Security
    {
        public Security();

        [EditorBrowsable(Never)]
        [Obsolete("This was an internal method which is no longer used", True)]
        public static Assembly LoadAndVerifyAssembly(byte[] assemblyData, string authorizationKey);
        [EditorBrowsable(Never)]
        [Obsolete("This was an internal method which is no longer used", True)]
        public static Assembly LoadAndVerifyAssembly(byte[] assemblyData);
        [Obsolete("Security.PrefetchSocketPolicy is no longer supported, since the Unity Web Player is no longer supported by Unity.", True)]
        [ExcludeFromDocs]
        public static bool PrefetchSocketPolicy(string ip, int atPort);
        [Obsolete("Security.PrefetchSocketPolicy is no longer supported, since the Unity Web Player is no longer supported by Unity.", True)]
        public static bool PrefetchSocketPolicy(string ip, int atPort, [UnityEngine.Internal.DefaultValue("3000")] int timeout);
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    public static class Types
    {
        [EditorBrowsable(Never)]
        [Obsolete("This was an internal method which is no longer used", True)]
        public static Type GetType(string typeName, string assemblyName);
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [RequiredByNativeCode]
    public sealed class SerializeField : Attribute
    {
        public SerializeField();
    }
}
using System;
using UnityEngine.Internal;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [RequiredByNativeCode]
    [AttributeUsage(Field)]
    public sealed class SerializeReference : Attribute
    {
        [ExcludeFromDocs]
        public SerializeReference();
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [RequiredByNativeCode]
    [AttributeUsage(Class)]
    public sealed class PreferBinarySerialization : Attribute
    {
        public PreferBinarySerialization();
    }
}
using UnityEngine.Scripting;

namespace UnityEngine
{
    [RequiredByNativeCode]
    public interface ISerializationCallbackReceiver
    {
        [RequiredByNativeCode]
        void OnBeforeSerialize();
        [RequiredByNativeCode]
        void OnAfterDeserialize();
    }
}
using System;
using System.Collections.Generic;
using System.Security;
using Unity.Collections;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Runtime/Export/Shaders/ComputeShader.bindings.h")]
    [NativeHeader("Runtime/Shaders/ComputeShader.h")]
    [UsedByNativeCode]
    public sealed class ComputeBuffer : IDisposable
    {
        public ComputeBuffer(int count, int stride);
        public ComputeBuffer(int count, int stride, ComputeBufferType type);
        public ComputeBuffer(int count, int stride, ComputeBufferType type, ComputeBufferMode usage);

        ~ComputeBuffer();

        public int count { get; }
        public int stride { get; }
        public string name { set; }

        public void Dispose();
        public void Release();
        public bool IsValid();
        [SecuritySafeCritical]
        public void SetData(Array data);
        [SecuritySafeCritical]
        public void SetData<T>(List<T> data) where T : struct;
        [SecuritySafeCritical]
        public void SetData<T>(NativeArray<T> data) where T : struct;
        [SecuritySafeCritical]
        public void SetData(Array data, int managedBufferStartIndex, int computeBufferStartIndex, int count);
        [SecuritySafeCritical]
        public void SetData<T>(List<T> data, int managedBufferStartIndex, int computeBufferStartIndex, int count) where T : struct;
        [SecuritySafeCritical]
        public void SetData<T>(NativeArray<T> data, int nativeBufferStartIndex, int computeBufferStartIndex, int count) where T : struct;
        [SecurityCritical]
        public void GetData(Array data);
        [SecurityCritical]
        public void GetData(Array data, int managedBufferStartIndex, int computeBufferStartIndex, int count);
        public NativeArray<T> BeginWrite<T>(int computeBufferStartIndex, int count) where T : struct;
        public void EndWrite<T>(int countWritten) where T : struct;
        public void SetCounterValue(uint counterValue);
        public static void CopyCount(ComputeBuffer src, ComputeBuffer dst, int dstOffsetBytes);
        public IntPtr GetNativeBufferPtr();
    }
}
using UnityEngine.Bindings;
using UnityEngine.Internal;
using UnityEngine.Rendering;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Runtime/Graphics/ShaderScriptBindings.h")]
    [UsedByNativeCode]
    [NativeHeader("Runtime/Shaders/ComputeShader.h")]
    public sealed class ComputeShader : Object
    {
        public string[] shaderKeywords { get; set; }

        [NativeMethod(Name = "ComputeShaderScripting::FindKernel", HasExplicitThis = True, IsFreeFunction = True, ThrowsException = True)]
        [RequiredByNativeCode]
        public int FindKernel(string name);
        [FreeFunction(Name = "ComputeShaderScripting::HasKernel", HasExplicitThis = True)]
        public bool HasKernel(string name);
        [FreeFunction(Name = "ComputeShaderScripting::SetValue<float>", HasExplicitThis = True)]
        public void SetFloat(int nameID, float val);
        [FreeFunction(Name = "ComputeShaderScripting::SetValue<int>", HasExplicitThis = True)]
        public void SetInt(int nameID, int val);
        [FreeFunction(Name = "ComputeShaderScripting::SetValue<Vector4f>", HasExplicitThis = True)]
        public void SetVector(int nameID, Vector4 val);
        [FreeFunction(Name = "ComputeShaderScripting::SetValue<Matrix4x4f>", HasExplicitThis = True)]
        public void SetMatrix(int nameID, Matrix4x4 val);
        [FreeFunction(Name = "ComputeShaderScripting::SetArray<Vector4f>", HasExplicitThis = True)]
        public void SetVectorArray(int nameID, Vector4[] values);
        [FreeFunction(Name = "ComputeShaderScripting::SetArray<Matrix4x4f>", HasExplicitThis = True)]
        public void SetMatrixArray(int nameID, Matrix4x4[] values);
        [NativeMethod(Name = "ComputeShaderScripting::SetTexture", HasExplicitThis = True, IsFreeFunction = True, ThrowsException = True)]
        public void SetTexture(int kernelIndex, int nameID, [NotNull("ArgumentNullException")] Texture texture, int mipLevel);
        [NativeMethod(Name = "ComputeShaderScripting::SetTextureFromGlobal", HasExplicitThis = True, IsFreeFunction = True, ThrowsException = True)]
        public void SetTextureFromGlobal(int kernelIndex, int nameID, int globalTextureNameID);
        public void SetBuffer(int kernelIndex, int nameID, ComputeBuffer buffer);
        public void SetBuffer(int kernelIndex, int nameID, GraphicsBuffer buffer);
        [NativeMethod(Name = "ComputeShaderScripting::GetKernelThreadGroupSizes", HasExplicitThis = True, IsFreeFunction = True, ThrowsException = True)]
        public void GetKernelThreadGroupSizes(int kernelIndex, out uint x, out uint y, out uint z);
        [NativeName("DispatchComputeShader")]
        public void Dispatch(int kernelIndex, int threadGroupsX, int threadGroupsY, int threadGroupsZ);
        [FreeFunction("ComputeShaderScripting::EnableKeyword", HasExplicitThis = True)]
        public void EnableKeyword(string keyword);
        [FreeFunction("ComputeShaderScripting::DisableKeyword", HasExplicitThis = True)]
        public void DisableKeyword(string keyword);
        [FreeFunction("ComputeShaderScripting::IsKeywordEnabled", HasExplicitThis = True)]
        public bool IsKeywordEnabled(string keyword);
        public void SetFloat(string name, float val);
        public void SetInt(string name, int val);
        public void SetVector(string name, Vector4 val);
        public void SetMatrix(string name, Matrix4x4 val);
        public void SetVectorArray(string name, Vector4[] values);
        public void SetMatrixArray(string name, Matrix4x4[] values);
        public void SetFloats(string name, params float[] values);
        public void SetFloats(int nameID, params float[] values);
        public void SetInts(string name, params int[] values);
        public void SetInts(int nameID, params int[] values);
        public void SetBool(string name, bool val);
        public void SetBool(int nameID, bool val);
        public void SetTexture(int kernelIndex, int nameID, Texture texture);
        public void SetTexture(int kernelIndex, string name, Texture texture);
        public void SetTexture(int kernelIndex, string name, Texture texture, int mipLevel);
        public void SetTexture(int kernelIndex, int nameID, RenderTexture texture, int mipLevel, RenderTextureSubElement element);
        public void SetTexture(int kernelIndex, string name, RenderTexture texture, int mipLevel, RenderTextureSubElement element);
        public void SetTextureFromGlobal(int kernelIndex, string name, string globalTextureName);
        public void SetBuffer(int kernelIndex, string name, ComputeBuffer buffer);
        public void SetBuffer(int kernelIndex, string name, GraphicsBuffer buffer);
        public void SetConstantBuffer(int nameID, ComputeBuffer buffer, int offset, int size);
        public void SetConstantBuffer(string name, ComputeBuffer buffer, int offset, int size);
        public void SetConstantBuffer(int nameID, GraphicsBuffer buffer, int offset, int size);
        public void SetConstantBuffer(string name, GraphicsBuffer buffer, int offset, int size);
        public void DispatchIndirect(int kernelIndex, ComputeBuffer argsBuffer, [DefaultValue("0")] uint argsOffset);
        [ExcludeFromDocs]
        public void DispatchIndirect(int kernelIndex, ComputeBuffer argsBuffer);
        public void DispatchIndirect(int kernelIndex, GraphicsBuffer argsBuffer, [DefaultValue("0")] uint argsOffset);
        [ExcludeFromDocs]
        public void DispatchIndirect(int kernelIndex, GraphicsBuffer argsBuffer);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Rendering;

namespace UnityEngine
{
    public sealed class ShaderVariantCollection : Object
    {
        public ShaderVariantCollection();

        public int shaderCount { get; }
        public int variantCount { get; }
        public bool isWarmedUp { get; }

        [NativeName("ClearVariants")]
        public void Clear();
        [NativeName("WarmupShaders")]
        public void WarmUp();
        public bool Add(ShaderVariant variant);
        public bool Remove(ShaderVariant variant);
        public bool Contains(ShaderVariant variant);

        public struct ShaderVariant
        {
            public Shader shader;
            public PassType passType;
            public string[] keywords;

            public ShaderVariant(Shader shader, PassType passType, params string[] keywords);
        }
    }
}
using System;

namespace UnityEngine
{
    [Flags]
    public enum SnapAxis
    {
        None = 0,
        X = 1,
        Y = 2,
        Z = 4,
        All = 7
    }
}
namespace UnityEngine
{
    public static class Snapping
    {
        public static float Snap(float val, float snap);
        public static Vector2 Snap(Vector2 val, Vector2 snap);
        public static Vector3 Snap(Vector3 val, Vector3 snap, SnapAxis axis = All);
    }
}
namespace UnityEngine
{
    public sealed class StaticBatchingUtility
    {
        public StaticBatchingUtility();

        public static void Combine(GameObject staticBatchRoot);
        public static void Combine(GameObject[] gos, GameObject staticBatchRoot);
    }
}
namespace UnityEngine
{
    public enum BatteryStatus
    {
        Unknown = 0,
        Charging = 1,
        Discharging = 2,
        NotCharging = 3,
        Full = 4
    }
}
namespace UnityEngine
{
    public enum OperatingSystemFamily
    {
        Other = 0,
        MacOSX = 1,
        Windows = 2,
        Linux = 3
    }
}
namespace UnityEngine
{
    public enum DeviceType
    {
        Unknown = 0,
        Handheld = 1,
        Console = 2,
        Desktop = 3
    }
}
using System;
using UnityEngine.Experimental.Rendering;
using UnityEngine.Rendering;

namespace UnityEngine
{
    public sealed class SystemInfo
    {
        public const string unsupportedIdentifier = "n/a";

        public SystemInfo();

        public static float batteryLevel { get; }
        public static BatteryStatus batteryStatus { get; }
        public static string operatingSystem { get; }
        public static OperatingSystemFamily operatingSystemFamily { get; }
        public static string processorType { get; }
        public static int processorFrequency { get; }
        public static int processorCount { get; }
        public static int systemMemorySize { get; }
        public static string deviceUniqueIdentifier { get; }
        public static string deviceName { get; }
        public static string deviceModel { get; }
        public static bool supportsAccelerometer { get; }
        public static bool supportsGyroscope { get; }
        public static bool supportsLocationService { get; }
        public static bool supportsVibration { get; }
        public static bool supportsAudio { get; }
        public static DeviceType deviceType { get; }
        public static int graphicsMemorySize { get; }
        public static string graphicsDeviceName { get; }
        public static string graphicsDeviceVendor { get; }
        public static int graphicsDeviceID { get; }
        public static int graphicsDeviceVendorID { get; }
        public static GraphicsDeviceType graphicsDeviceType { get; }
        public static bool graphicsUVStartsAtTop { get; }
        public static string graphicsDeviceVersion { get; }
        public static int graphicsShaderLevel { get; }
        public static bool graphicsMultiThreaded { get; }
        public static RenderingThreadingMode renderingThreadingMode { get; }
        public static bool hasHiddenSurfaceRemovalOnGPU { get; }
        public static bool hasDynamicUniformArrayIndexingInFragmentShaders { get; }
        public static bool supportsShadows { get; }
        public static bool supportsRawShadowDepthSampling { get; }
        public static bool supportsMotionVectors { get; }
        public static bool supports3DTextures { get; }
        public static bool supportsCompressed3DTextures { get; }
        public static bool supports2DArrayTextures { get; }
        public static bool supports3DRenderTextures { get; }
        public static bool supportsCubemapArrayTextures { get; }
        public static CopyTextureSupport copyTextureSupport { get; }
        public static bool supportsComputeShaders { get; }
        public static bool supportsConservativeRaster { get; }
        public static bool supportsMultiview { get; }
        public static bool supportsGeometryShaders { get; }
        public static bool supportsTessellationShaders { get; }
        public static bool supportsRenderTargetArrayIndexFromVertexShader { get; }
        public static bool supportsInstancing { get; }
        public static bool supportsHardwareQuadTopology { get; }
        public static bool supports32bitsIndexBuffer { get; }
        public static bool supportsSparseTextures { get; }
        public static int supportedRenderTargetCount { get; }
        public static bool supportsSeparatedRenderTargetsBlend { get; }
        public static int supportedRandomWriteTargetCount { get; }
        public static int supportsMultisampledTextures { get; }
        public static bool supportsMultisampled2DArrayTextures { get; }
        public static bool supportsMultisampleAutoResolve { get; }
        public static int supportsTextureWrapMirrorOnce { get; }
        public static bool usesReversedZBuffer { get; }
        public static NPOTSupport npotSupport { get; }
        public static int maxTextureSize { get; }
        public static int maxCubemapSize { get; }
        public static int maxComputeBufferInputsVertex { get; }
        public static int maxComputeBufferInputsFragment { get; }
        public static int maxComputeBufferInputsGeometry { get; }
        public static int maxComputeBufferInputsDomain { get; }
        public static int maxComputeBufferInputsHull { get; }
        public static int maxComputeBufferInputsCompute { get; }
        public static int maxComputeWorkGroupSize { get; }
        public static int maxComputeWorkGroupSizeX { get; }
        public static int maxComputeWorkGroupSizeY { get; }
        public static int maxComputeWorkGroupSizeZ { get; }
        public static bool supportsAsyncCompute { get; }
        public static bool supportsGpuRecorder { get; }
        public static bool supportsGraphicsFence { get; }
        public static bool supportsAsyncGPUReadback { get; }
        public static bool supportsRayTracing { get; }
        public static bool supportsSetConstantBuffer { get; }
        public static int constantBufferOffsetAlignment { get; }
        [Obsolete("Use SystemInfo.constantBufferOffsetAlignment instead.")]
        public static bool minConstantBufferOffsetAlignment { get; }
        public static bool hasMipMaxLevel { get; }
        public static bool supportsMipStreaming { get; }
        public static bool usesLoadStoreActions { get; }
        public static HDRDisplaySupportFlags hdrDisplaySupportFlags { get; }
        public static bool supportsStoreAndResolveAction { get; }
        [Obsolete("supportsRenderTextures always returns true, no need to call it")]
        public static bool supportsRenderTextures { get; }
        [Obsolete("supportsRenderToCubemap always returns true, no need to call it")]
        public static bool supportsRenderToCubemap { get; }
        [Obsolete("supportsImageEffects always returns true, no need to call it")]
        public static bool supportsImageEffects { get; }
        [Obsolete("supportsStencil always returns true, no need to call it")]
        public static int supportsStencil { get; }
        [Obsolete("graphicsPixelFillrate is no longer supported in Unity 5.0+.")]
        public static int graphicsPixelFillrate { get; }
        [Obsolete("Vertex program support is required in Unity 5.0+")]
        public static bool supportsVertexPrograms { get; }
        [Obsolete("SystemInfo.supportsGPUFence has been deprecated, use SystemInfo.supportsGraphicsFence instead (UnityUpgradable) ->  supportsGraphicsFence", True)]
        public static bool supportsGPUFence { get; }

        public static bool SupportsRenderTextureFormat(RenderTextureFormat format);
        public static bool SupportsBlendingOnRenderTextureFormat(RenderTextureFormat format);
        public static bool SupportsTextureFormat(TextureFormat format);
        public static bool SupportsVertexAttributeFormat(VertexAttributeFormat format, int dimension);
        public static bool IsFormatSupported(GraphicsFormat format, FormatUsage usage);
        public static GraphicsFormat GetCompatibleFormat(GraphicsFormat format, FormatUsage usage);
        public static GraphicsFormat GetGraphicsFormat(DefaultFormat format);
        public static int GetRenderTextureSupportedMSAASampleCount(RenderTextureDescriptor desc);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [StaticAccessor("GetTimeManager()", Dot)]
    [NativeHeader("Runtime/Input/TimeManager.h")]
    public class Time
    {
        public Time();

        [NativeProperty("CurTime")]
        public static float time { get; }
        [NativeProperty("CurTime")]
        public static double timeAsDouble { get; }
        [NativeProperty("TimeSinceSceneLoad")]
        public static float timeSinceLevelLoad { get; }
        [NativeProperty("TimeSinceSceneLoad")]
        public static double timeSinceLevelLoadAsDouble { get; }
        public static float deltaTime { get; }
        public static float fixedTime { get; }
        [NativeProperty("FixedTime")]
        public static double fixedTimeAsDouble { get; }
        public static float unscaledTime { get; }
        [NativeProperty("UnscaledTime")]
        public static double unscaledTimeAsDouble { get; }
        public static float fixedUnscaledTime { get; }
        [NativeProperty("FixedUnscaledTime")]
        public static double fixedUnscaledTimeAsDouble { get; }
        public static float unscaledDeltaTime { get; }
        public static float fixedUnscaledDeltaTime { get; }
        public static float fixedDeltaTime { get; set; }
        public static float maximumDeltaTime { get; set; }
        public static float smoothDeltaTime { get; }
        public static float maximumParticleDeltaTime { get; set; }
        public static float timeScale { get; set; }
        public static int frameCount { get; }
        [NativeProperty("RenderFrameCount")]
        public static int renderedFrameCount { get; }
        [NativeProperty("Realtime")]
        public static float realtimeSinceStartup { get; }
        [NativeProperty("Realtime")]
        public static double realtimeSinceStartupAsDouble { get; }
        public static float captureDeltaTime { get; set; }
        public static int captureFramerate { get; set; }
        public static bool inFixedTimeStep { get; }
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Internal;

namespace UnityEngine
{
    [NativeConditional("ENABLE_ONSCREEN_KEYBOARD")]
    [NativeHeader("Runtime/Input/KeyboardOnScreen.h")]
    [NativeHeader("Runtime/Export/TouchScreenKeyboard/TouchScreenKeyboard.bindings.h")]
    public class TouchScreenKeyboard
    {
        public TouchScreenKeyboard(string text, TouchScreenKeyboardType keyboardType, bool autocorrection, bool multiline, bool secure, bool alert, string textPlaceholder, int characterLimit);

        ~TouchScreenKeyboard();

        public static bool isSupported { get; }
        public static bool isInPlaceEditingAllowed { get; }
        public string text { get; set; }
        public static bool hideInput { get; set; }
        public bool active { get; set; }
        [Obsolete("Property done is deprecated, use status instead")]
        public bool done { get; }
        [Obsolete("Property wasCanceled is deprecated, use status instead.")]
        public bool wasCanceled { get; }
        public Status status { get; }
        public int characterLimit { get; set; }
        public bool canGetSelection { get; }
        public bool canSetSelection { get; }
        public RangeInt selection { get; set; }
        public TouchScreenKeyboardType type { get; }
        public int targetDisplay { get; set; }
        [NativeConditional("ENABLE_ONSCREEN_KEYBOARD", "RectT<float>()")]
        public static Rect area { get; }
        public static bool visible { get; }

        public static TouchScreenKeyboard Open(string text, [DefaultValue("TouchScreenKeyboardType.Default")] TouchScreenKeyboardType keyboardType, [DefaultValue("true")] bool autocorrection, [DefaultValue("false")] bool multiline, [DefaultValue("false")] bool secure, [DefaultValue("false")] bool alert, [DefaultValue("\"\"")] string textPlaceholder, [DefaultValue("0")] int characterLimit);
        [ExcludeFromDocs]
        public static TouchScreenKeyboard Open(string text, TouchScreenKeyboardType keyboardType, bool autocorrection, bool multiline, bool secure, bool alert, string textPlaceholder);
        [ExcludeFromDocs]
        public static TouchScreenKeyboard Open(string text, TouchScreenKeyboardType keyboardType, bool autocorrection, bool multiline, bool secure, bool alert);
        [ExcludeFromDocs]
        public static TouchScreenKeyboard Open(string text, TouchScreenKeyboardType keyboardType, bool autocorrection, bool multiline, bool secure);
        [ExcludeFromDocs]
        public static TouchScreenKeyboard Open(string text, TouchScreenKeyboardType keyboardType, bool autocorrection, bool multiline);
        [ExcludeFromDocs]
        public static TouchScreenKeyboard Open(string text, TouchScreenKeyboardType keyboardType, bool autocorrection);
        [ExcludeFromDocs]
        public static TouchScreenKeyboard Open(string text, TouchScreenKeyboardType keyboardType);
        [ExcludeFromDocs]
        public static TouchScreenKeyboard Open(string text);

        public enum Status
        {
            Visible = 0,
            Done = 1,
            Canceled = 2,
            LostFocus = 3
        }
        public class Android
        {
            public Android();

            [Obsolete("TouchScreenKeyboard.Android.closeKeyboardOnOutsideTap is obsolete. Use TouchScreenKeyboard.Android.consumesOutsideTouches instead (UnityUpgradable) -> UnityEngine.TouchScreenKeyboard/Android.consumesOutsideTouches")]
            public static bool closeKeyboardOnOutsideTap { get; set; }
            public static bool consumesOutsideTouches { get; set; }
        }
    }
}
using System;

namespace UnityEngine
{
    public enum TouchScreenKeyboardType
    {
        Default = 0,
        ASCIICapable = 1,
        NumbersAndPunctuation = 2,
        URL = 3,
        NumberPad = 4,
        PhonePad = 5,
        NamePhonePad = 6,
        EmailAddress = 7,
        [Obsolete("Wii U is no longer supported as of Unity 2018.1.")]
        NintendoNetworkAccount = 8,
        Social = 9,
        Search = 10,
        DecimalPad = 11,
        OneTimeCode = 12
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Export/UnityEvent/UnityEventQueueSystem.bindings.h")]
    public class UnityEventQueueSystem
    {
        public UnityEventQueueSystem();

        public static string GenerateEventIdForPayload(string eventPayloadName);
        [FreeFunction]
        public static IntPtr GetGlobalEventQueue();
    }
}
using System;

namespace UnityEngine
{
    public struct Pose : IEquatable<Pose>
    {
        public Vector3 position;
        public Quaternion rotation;

        public Pose(Vector3 position, Quaternion rotation);

        public Vector3 forward { get; }
        public Vector3 right { get; }
        public Vector3 up { get; }
        public static Pose identity { get; }

        public override string ToString();
        public string ToString(string format);
        public Pose GetTransformedBy(Pose lhs);
        public Pose GetTransformedBy(Transform lhs);
        public override bool Equals(object obj);
        public bool Equals(Pose other);
        public override int GetHashCode();

        public static bool operator ==(Pose a, Pose b);
        public static bool operator !=(Pose a, Pose b);
    }
}
using System;

namespace UnityEngine
{
    [Flags]
    public enum DrivenTransformProperties
    {
        None = 0,
        All = -1,
        AnchoredPositionX = 2,
        AnchoredPositionY = 4,
        AnchoredPositionZ = 8,
        Rotation = 16,
        ScaleX = 32,
        ScaleY = 64,
        ScaleZ = 128,
        AnchorMinX = 256,
        AnchorMinY = 512,
        AnchorMaxX = 1024,
        AnchorMaxY = 2048,
        SizeDeltaX = 4096,
        SizeDeltaY = 8192,
        PivotX = 16384,
        PivotY = 32768,
        AnchoredPosition = 6,
        AnchoredPosition3D = 14,
        Scale = 224,
        AnchorMin = 768,
        AnchorMax = 3072,
        Anchors = 3840,
        SizeDelta = 12288,
        Pivot = 49152
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Editor/Src/Animation/AnimationModeSnapshot.h")]
    [NativeHeader("Editor/Src/Undo/PropertyDiffUndoRecorder.h")]
    public struct DrivenRectTransformTracker
    {
        public static void StopRecordingUndo();
        public static void StartRecordingUndo();
        public void Add(Object driver, RectTransform rectTransform, DrivenTransformProperties drivenProperties);
        [Obsolete("revertValues parameter is ignored. Please use Clear() instead.")]
        public void Clear(bool revertValues);
        public void Clear();
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeClass("UI::RectTransform")]
    [NativeHeader("Runtime/Transform/RectTransform.h")]
    public sealed class RectTransform : Transform
    {
        public RectTransform();

        public Rect rect { get; }
        public Vector2 anchorMin { get; set; }
        public Vector2 anchorMax { get; set; }
        public Vector2 anchoredPosition { get; set; }
        public Vector2 sizeDelta { get; set; }
        public Vector2 pivot { get; set; }
        public Vector3 anchoredPosition3D { get; set; }
        public Vector2 offsetMin { get; set; }
        public Vector2 offsetMax { get; set; }

        public static event ReapplyDrivenProperties reapplyDrivenProperties;

        [NativeMethod("UpdateIfTransformDispatchIsDirty")]
        public void ForceUpdateRectTransforms();
        public void GetLocalCorners(Vector3[] fourCornersArray);
        public void GetWorldCorners(Vector3[] fourCornersArray);
        public void SetInsetAndSizeFromParentEdge(Edge edge, float inset, float size);
        public void SetSizeWithCurrentAnchors(Axis axis, float size);

        public enum Edge
        {
            Left = 0,
            Right = 1,
            Top = 2,
            Bottom = 3
        }
        public enum Axis
        {
            Horizontal = 0,
            Vertical = 1
        }
        public delegate void ReapplyDrivenProperties(RectTransform driven);
    }
}
using System;
using System.Collections;
using UnityEngine.Bindings;
using UnityEngine.Internal;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Configuration/UnityConfigure.h")]
    [NativeHeader("Runtime/Transform/Transform.h")]
    [NativeHeader("Runtime/Transform/ScriptBindings/TransformScriptBindings.h")]
    [RequiredByNativeCode]
    public class Transform : Component, IEnumerable
    {
        protected Transform();

        public Vector3 position { get; set; }
        public Vector3 localPosition { get; set; }
        public Vector3 eulerAngles { get; set; }
        public Vector3 localEulerAngles { get; set; }
        public Vector3 right { get; set; }
        public Vector3 up { get; set; }
        public Vector3 forward { get; set; }
        public Quaternion rotation { get; set; }
        public Quaternion localRotation { get; set; }
        public Vector3 localScale { get; set; }
        public Transform parent { get; set; }
        public Matrix4x4 worldToLocalMatrix { get; }
        public Matrix4x4 localToWorldMatrix { get; }
        public Transform root { get; }
        public int childCount { get; }
        public Vector3 lossyScale { get; }
        [NativeProperty("HasChangedDeprecated")]
        public bool hasChanged { get; set; }
        public int hierarchyCapacity { get; set; }
        public int hierarchyCount { get; }

        public void SetParent(Transform p);
        [FreeFunction("SetParent", HasExplicitThis = True)]
        public void SetParent(Transform parent, bool worldPositionStays);
        public void SetPositionAndRotation(Vector3 position, Quaternion rotation);
        public void Translate(Vector3 translation, [DefaultValue("Space.Self")] Space relativeTo);
        public void Translate(Vector3 translation);
        public void Translate(float x, float y, float z, [DefaultValue("Space.Self")] Space relativeTo);
        public void Translate(float x, float y, float z);
        public void Translate(Vector3 translation, Transform relativeTo);
        public void Translate(float x, float y, float z, Transform relativeTo);
        public void Rotate(Vector3 eulers, [DefaultValue("Space.Self")] Space relativeTo);
        public void Rotate(Vector3 eulers);
        public void Rotate(float xAngle, float yAngle, float zAngle, [DefaultValue("Space.Self")] Space relativeTo);
        public void Rotate(float xAngle, float yAngle, float zAngle);
        public void Rotate(Vector3 axis, float angle, [DefaultValue("Space.Self")] Space relativeTo);
        public void Rotate(Vector3 axis, float angle);
        public void RotateAround(Vector3 point, Vector3 axis, float angle);
        public void LookAt(Transform target, [DefaultValue("Vector3.up")] Vector3 worldUp);
        public void LookAt(Transform target);
        public void LookAt(Vector3 worldPosition, [DefaultValue("Vector3.up")] Vector3 worldUp);
        public void LookAt(Vector3 worldPosition);
        public Vector3 TransformDirection(Vector3 direction);
        public Vector3 TransformDirection(float x, float y, float z);
        public Vector3 InverseTransformDirection(Vector3 direction);
        public Vector3 InverseTransformDirection(float x, float y, float z);
        public Vector3 TransformVector(Vector3 vector);
        public Vector3 TransformVector(float x, float y, float z);
        public Vector3 InverseTransformVector(Vector3 vector);
        public Vector3 InverseTransformVector(float x, float y, float z);
        public Vector3 TransformPoint(Vector3 position);
        public Vector3 TransformPoint(float x, float y, float z);
        public Vector3 InverseTransformPoint(Vector3 position);
        public Vector3 InverseTransformPoint(float x, float y, float z);
        [FreeFunction("DetachChildren", HasExplicitThis = True)]
        public void DetachChildren();
        public void SetAsFirstSibling();
        public void SetAsLastSibling();
        public void SetSiblingIndex(int index);
        public int GetSiblingIndex();
        public Transform Find(string n);
        [FreeFunction("Internal_IsChildOrSameTransform", HasExplicitThis = True)]
        public bool IsChildOf([NotNull("ArgumentNullException")] Transform parent);
        [Obsolete("FindChild has been deprecated. Use Find instead (UnityUpgradable) -> Find([mscorlib] System.String)", False)]
        public Transform FindChild(string n);
        public IEnumerator GetEnumerator();
        [Obsolete("warning use Transform.Rotate instead.")]
        public void RotateAround(Vector3 axis, float angle);
        [Obsolete("warning use Transform.Rotate instead.")]
        public void RotateAroundLocal(Vector3 axis, float angle);
        [NativeThrows]
        [FreeFunction("GetChild", HasExplicitThis = True)]
        public Transform GetChild(int index);
        [Obsolete("warning use Transform.childCount instead (UnityUpgradable) -> Transform.childCount", False)]
        [NativeMethod("GetChildrenCount")]
        public int GetChildCount();
    }
}
namespace UnityEngine
{
    public enum SpriteDrawMode
    {
        Simple = 0,
        Sliced = 1,
        Tiled = 2
    }
}
namespace UnityEngine
{
    public enum SpriteTileMode
    {
        Continuous = 0,
        Adaptive = 1
    }
}
namespace UnityEngine
{
    public enum SpriteMaskInteraction
    {
        None = 0,
        VisibleInsideMask = 1,
        VisibleOutsideMask = 2
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeType("Runtime/Graphics/Mesh/SpriteRenderer.h")]
    [RequireComponent(typeof(Transform))]
    public sealed class SpriteRenderer : Renderer
    {
        public SpriteRenderer();

        public Sprite sprite { get; set; }
        public SpriteDrawMode drawMode { get; set; }
        public Vector2 size { get; set; }
        public float adaptiveModeThreshold { get; set; }
        public SpriteTileMode tileMode { get; set; }
        public Color color { get; set; }
        public SpriteMaskInteraction maskInteraction { get; set; }
        public bool flipX { get; set; }
        public bool flipY { get; set; }
        public SpriteSortPoint spriteSortPoint { get; set; }
    }
}
namespace UnityEngine
{
    public enum SpriteMeshType
    {
        FullRect = 0,
        Tight = 1
    }
}
namespace UnityEngine
{
    public enum SpriteAlignment
    {
        Center = 0,
        TopLeft = 1,
        TopCenter = 2,
        TopRight = 3,
        LeftCenter = 4,
        RightCenter = 5,
        BottomLeft = 6,
        BottomCenter = 7,
        BottomRight = 8,
        Custom = 9
    }
}
namespace UnityEngine
{
    public enum SpritePackingMode
    {
        Tight = 0,
        Rectangle = 1
    }
}
namespace UnityEngine
{
    public enum SpritePackingRotation
    {
        None = 0,
        FlipHorizontal = 1,
        FlipVertical = 2,
        Rotate180 = 3,
        Any = 15
    }
}
namespace UnityEngine
{
    public enum SpriteSortPoint
    {
        Center = 0,
        Pivot = 1
    }
}
namespace UnityEngine
{
    public struct SecondarySpriteTexture
    {
        public string name;
        public Texture2D texture;
    }
}
using System.Collections.Generic;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [ExcludeFromPreset]
    [NativeType("Runtime/Graphics/SpriteFrame.h")]
    [NativeHeader("Runtime/Graphics/SpriteUtility.h")]
    [NativeHeader("Runtime/2D/Common/ScriptBindings/SpritesMarshalling.h")]
    [NativeHeader("Runtime/2D/Common/SpriteDataAccess.h")]
    public sealed class Sprite : Object
    {
        public Bounds bounds { get; }
        public Rect rect { get; }
        public Vector4 border { get; }
        public Texture2D texture { get; }
        public float pixelsPerUnit { get; }
        public float spriteAtlasTextureScale { get; }
        public Texture2D associatedAlphaSplitTexture { get; }
        public Vector2 pivot { get; }
        public bool packed { get; }
        public SpritePackingMode packingMode { get; }
        public SpritePackingRotation packingRotation { get; }
        public Rect textureRect { get; }
        public Vector2 textureRectOffset { get; }
        public Vector2[] vertices { get; }
        public ushort[] triangles { get; }
        public Vector2[] uv { get; }

        public int GetPhysicsShapeCount();
        public int GetPhysicsShapePointCount(int shapeIdx);
        public int GetPhysicsShape(int shapeIdx, List<Vector2> physicsShape);
        public void OverridePhysicsShape(IList<Vector2[]> physicsShapes);
        [FreeFunction("SpritesBindings::OverrideGeometry", HasExplicitThis = True)]
        public void OverrideGeometry(Vector2[] vertices, ushort[] triangles);
        public static Sprite Create(Texture2D texture, Rect rect, Vector2 pivot, float pixelsPerUnit, uint extrude, SpriteMeshType meshType, Vector4 border, bool generateFallbackPhysicsShape);
        public static Sprite Create(Texture2D texture, Rect rect, Vector2 pivot, float pixelsPerUnit, uint extrude, SpriteMeshType meshType, Vector4 border);
        public static Sprite Create(Texture2D texture, Rect rect, Vector2 pivot, float pixelsPerUnit, uint extrude, SpriteMeshType meshType);
        public static Sprite Create(Texture2D texture, Rect rect, Vector2 pivot, float pixelsPerUnit, uint extrude);
        public static Sprite Create(Texture2D texture, Rect rect, Vector2 pivot, float pixelsPerUnit);
        public static Sprite Create(Texture2D texture, Rect rect, Vector2 pivot);
    }
}
namespace UnityEngine.Sprites
{
    public sealed class DataUtility
    {
        public DataUtility();

        public static Vector4 GetInnerUV(Sprite sprite);
        public static Vector4 GetOuterUV(Sprite sprite);
        public static Vector4 GetPadding(Sprite sprite);
        public static Vector2 GetMinSize(Sprite sprite);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.U2D
{
    [MovedFrom("UnityEngine.Experimental.U2D")]
    [NativeHeader("Runtime/2D/Common/PixelSnapping.h")]
    public static class PixelPerfectRendering
    {
        public static float pixelSnapSpacing { get; set; }
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.U2D
{
    [MovedFrom("UnityEngine.Experimental.U2D")]
    [NativeHeader("Runtime/2D/Common/SpriteDataMarshalling.h")]
    [NativeType(Custom, "ScriptingSpriteBone")]
    [NativeHeader("Runtime/2D/Common/SpriteDataAccess.h")]
    [RequiredByNativeCode]
    public struct SpriteBone
    {
        public string name { get; set; }
        public Vector3 position { get; set; }
        public Quaternion rotation { get; set; }
        public float length { get; set; }
        public int parentId { get; set; }
    }
}
using Unity.Collections;
using UnityEngine.Bindings;
using UnityEngine.Rendering;

namespace UnityEngine.U2D
{
    [NativeHeader("Runtime/Graphics/SpriteFrame.h")]
    [NativeHeader("Runtime/2D/Common/SpriteDataAccess.h")]
    public static class SpriteDataAccessExtensions
    {
        public static NativeSlice<T> GetVertexAttribute<T>(this Sprite sprite, VertexAttribute channel) where T : struct;
        public static void SetVertexAttribute<T>(this Sprite sprite, VertexAttribute channel, NativeArray<T> src) where T : struct;
        public static NativeArray<Matrix4x4> GetBindPoses(this Sprite sprite);
        public static void SetBindPoses(this Sprite sprite, NativeArray<Matrix4x4> src);
        public static NativeArray<ushort> GetIndices(this Sprite sprite);
        public static void SetIndices(this Sprite sprite, NativeArray<ushort> src);
        public static SpriteBone[] GetBones(this Sprite sprite);
        public static void SetBones(this Sprite sprite, SpriteBone[] src);
        [NativeName("HasChannel")]
        public static bool HasVertexAttribute([NotNull("ArgumentNullException")] this Sprite sprite, VertexAttribute channel);
        public static void SetVertexCount([NotNull("ArgumentNullException")] this Sprite sprite, int count);
        public static int GetVertexCount([NotNull("ArgumentNullException")] this Sprite sprite);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.U2D
{
    [NativeHeader("Runtime/Graphics/Mesh/SpriteRenderer.h")]
    [NativeHeader("Runtime/2D/Common/SpriteDataAccess.h")]
    public static class SpriteRendererDataAccessExtensions
    {
        public static void DeactivateDeformableBuffer([NotNull("ArgumentNullException")] this SpriteRenderer renderer);
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEngine.U2D
{
    [NativeHeader("Runtime/2D/SpriteAtlas/SpriteAtlas.h")]
    [NativeHeader("Runtime/2D/SpriteAtlas/SpriteAtlasManager.h")]
    [StaticAccessor("GetSpriteAtlasManager()", Dot)]
    public class SpriteAtlasManager
    {
        public SpriteAtlasManager();

        public static event Action<string, Action<SpriteAtlas>> atlasRequested;
        public static event Action<SpriteAtlas> atlasRegistered;
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.U2D
{
    [NativeHeader("Runtime/Graphics/SpriteFrame.h")]
    [NativeType(Header = "Runtime/2D/SpriteAtlas/SpriteAtlas.h")]
    public class SpriteAtlas : Object
    {
        public SpriteAtlas();

        public bool isVariant { get; }
        public string tag { get; }
        public int spriteCount { get; }

        public bool CanBindTo([NotNull("ArgumentNullException")] Sprite sprite);
        public Sprite GetSprite(string name);
        public int GetSprites(Sprite[] sprites);
        public int GetSprites(Sprite[] sprites, string name);
    }
}
namespace UnityEngine.Profiling
{
    public enum ProfilerArea
    {
        CPU = 0,
        GPU = 1,
        Rendering = 2,
        Memory = 3,
        Audio = 4,
        Video = 5,
        Physics = 6,
        Physics2D = 7,
        NetworkMessages = 8,
        NetworkOperations = 9,
        UI = 10,
        UIDetails = 11,
        GlobalIllumination = 12,
        VirtualTexturing = 13
    }
}
using System;
using System.Collections.Generic;
using System.Diagnostics;
using Unity.Collections;
using UnityEngine.Bindings;
using UnityEngine.Scripting;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Profiling
{
    [NativeHeader("Runtime/Profiler/ScriptBindings/Profiler.bindings.h")]
    [NativeHeader("Runtime/Utilities/MemoryUtilities.h")]
    [UsedByNativeCode]
    [NativeHeader("Runtime/Profiler/Profiler.h")]
    [NativeHeader("Runtime/Allocator/MemoryManager.h")]
    [MovedFrom("UnityEngine")]
    [NativeHeader("Runtime/ScriptingBackend/ScriptingApi.h")]
    public sealed class Profiler
    {
        public static bool supported { get; }
        [StaticAccessor("ProfilerBindings", DoubleColon)]
        public static string logFile { get; set; }
        public static bool enableBinaryLog { get; set; }
        public static int maxUsedMemory { get; set; }
        public static bool enabled { get; set; }
        public static bool enableAllocationCallstacks { get; set; }
        public static int areaCount { get; }
        [Obsolete("maxNumberOfSamplesPerFrame has been depricated. Use maxUsedMemory instead")]
        public static int maxNumberOfSamplesPerFrame { get; set; }
        [Obsolete("usedHeapSize has been deprecated since it is limited to 4GB. Please use usedHeapSizeLong instead.")]
        public static uint usedHeapSize { get; }
        public static long usedHeapSizeLong { get; }

        [Conditional("ENABLE_PROFILER")]
        [FreeFunction("profiler_set_area_enabled")]
        public static void SetAreaEnabled(ProfilerArea area, bool enabled);
        [NativeConditional("ENABLE_PROFILER")]
        [FreeFunction("profiler_is_area_enabled")]
        public static bool GetAreaEnabled(ProfilerArea area);
        [Conditional("UNITY_EDITOR")]
        public static void AddFramesFromFile(string file);
        [Conditional("ENABLE_PROFILER")]
        public static void BeginThreadProfiling(string threadGroupName, string threadName);
        [NativeConditional("ENABLE_PROFILER")]
        public static void EndThreadProfiling();
        [Conditional("ENABLE_PROFILER")]
        public static void BeginSample(string name);
        [Conditional("ENABLE_PROFILER")]
        public static void BeginSample(string name, Object targetObject);
        [Conditional("ENABLE_PROFILER")]
        [NativeMethod(Name = "ProfilerBindings::EndSample", IsFreeFunction = True, IsThreadSafe = True)]
        public static void EndSample();
        [Obsolete("GetRuntimeMemorySize has been deprecated since it is limited to 2GB. Please use GetRuntimeMemorySizeLong() instead.")]
        public static int GetRuntimeMemorySize(Object o);
        [NativeMethod(Name = "ProfilerBindings::GetRuntimeMemorySizeLong", IsFreeFunction = True)]
        public static long GetRuntimeMemorySizeLong([NotNull("ArgumentNullException")] Object o);
        [Obsolete("GetMonoHeapSize has been deprecated since it is limited to 4GB. Please use GetMonoHeapSizeLong() instead.")]
        public static uint GetMonoHeapSize();
        [NativeMethod(Name = "scripting_gc_get_heap_size", IsFreeFunction = True)]
        public static long GetMonoHeapSizeLong();
        [Obsolete("GetMonoUsedSize has been deprecated since it is limited to 4GB. Please use GetMonoUsedSizeLong() instead.")]
        public static uint GetMonoUsedSize();
        [NativeMethod(Name = "scripting_gc_get_used_size", IsFreeFunction = True)]
        public static long GetMonoUsedSizeLong();
        [StaticAccessor("GetMemoryManager()", Dot)]
        [NativeConditional("ENABLE_MEMORY_MANAGER")]
        public static bool SetTempAllocatorRequestedSize(uint size);
        [NativeConditional("ENABLE_MEMORY_MANAGER")]
        [StaticAccessor("GetMemoryManager()", Dot)]
        public static uint GetTempAllocatorSize();
        [Obsolete("GetTotalAllocatedMemory has been deprecated since it is limited to 4GB. Please use GetTotalAllocatedMemoryLong() instead.")]
        public static uint GetTotalAllocatedMemory();
        [StaticAccessor("GetMemoryManager()", Dot)]
        [NativeMethod(Name = "GetTotalAllocatedMemory")]
        [NativeConditional("ENABLE_MEMORY_MANAGER")]
        public static long GetTotalAllocatedMemoryLong();
        [Obsolete("GetTotalUnusedReservedMemory has been deprecated since it is limited to 4GB. Please use GetTotalUnusedReservedMemoryLong() instead.")]
        public static uint GetTotalUnusedReservedMemory();
        [StaticAccessor("GetMemoryManager()", Dot)]
        [NativeMethod(Name = "GetTotalUnusedReservedMemory")]
        [NativeConditional("ENABLE_MEMORY_MANAGER")]
        public static long GetTotalUnusedReservedMemoryLong();
        [Obsolete("GetTotalReservedMemory has been deprecated since it is limited to 4GB. Please use GetTotalReservedMemoryLong() instead.")]
        public static uint GetTotalReservedMemory();
        [NativeMethod(Name = "GetTotalReservedMemory")]
        [StaticAccessor("GetMemoryManager()", Dot)]
        [NativeConditional("ENABLE_MEMORY_MANAGER")]
        public static long GetTotalReservedMemoryLong();
        [NativeConditional("ENABLE_MEMORY_MANAGER")]
        public static long GetTotalFragmentationInfo(NativeArray<int> stats);
        [NativeConditional("ENABLE_PROFILER")]
        [NativeMethod(Name = "GetRegisteredGFXDriverMemory")]
        [StaticAccessor("GetMemoryManager()", Dot)]
        public static long GetAllocatedMemoryForGraphicsDriver();
        [Conditional("ENABLE_PROFILER")]
        public static void EmitFrameMetaData(Guid id, int tag, Array data);
        [Conditional("ENABLE_PROFILER")]
        public static void EmitFrameMetaData<T>(Guid id, int tag, List<T> data) where T : struct;
        [Conditional("ENABLE_PROFILER")]
        public static void EmitFrameMetaData<T>(Guid id, int tag, NativeArray<T> data) where T : struct;
        [Conditional("ENABLE_PROFILER")]
        public static void EmitSessionMetaData(Guid id, int tag, Array data);
        [Conditional("ENABLE_PROFILER")]
        public static void EmitSessionMetaData<T>(Guid id, int tag, List<T> data) where T : struct;
        [Conditional("ENABLE_PROFILER")]
        public static void EmitSessionMetaData<T>(Guid id, int tag, NativeArray<T> data) where T : struct;
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Profiling
{
    [NativeHeader("Runtime/Profiler/Recorder.h")]
    [UsedByNativeCode]
    [NativeHeader("Runtime/Profiler/ScriptBindings/Recorder.bindings.h")]
    public sealed class Recorder
    {
        ~Recorder();

        public bool isValid { get; }
        public bool enabled { get; set; }
        public long elapsedNanoseconds { get; }
        public long gpuElapsedNanoseconds { get; }
        public int sampleBlockCount { get; }
        public int gpuSampleBlockCount { get; }

        public static Recorder Get(string samplerName);
        [ThreadSafe]
        public void FilterToCurrentThread();
        [ThreadSafe]
        public void CollectFromAllThreads();
    }
}
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Profiling
{
    [UsedByNativeCode]
    [NativeHeader("Runtime/Profiler/ScriptBindings/Sampler.bindings.h")]
    [NativeHeader("Runtime/Profiler/Marker.h")]
    public class Sampler
    {
        public bool isValid { get; }
        public string name { get; }

        public Recorder GetRecorder();
        public static Sampler Get(string name);
        public static int GetNames(List<string> names);
    }
}
using System.Diagnostics;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Profiling
{
    [UsedByNativeCode]
    [NativeHeader("Runtime/Profiler/ScriptBindings/Sampler.bindings.h")]
    [NativeHeader("Runtime/Profiler/Marker.h")]
    public sealed class CustomSampler : Sampler
    {
        public static CustomSampler Create(string name, bool collectGpuData = False);
        [Conditional("ENABLE_PROFILER")]
        public void Begin();
        [Conditional("ENABLE_PROFILER")]
        public void Begin(Object targetObject);
        [Conditional("ENABLE_PROFILER")]
        public void End();
    }
}
using Unity.Collections;

namespace UnityEngine.Profiling.Experimental
{
    public struct DebugScreenCapture
    {
        public NativeArray<byte> rawImageDataReference { get; set; }
        public TextureFormat imageFormat { get; set; }
        public int width { get; set; }
        public int height { get; set; }
    }
}
using System;

namespace UnityEngine.Profiling.Memory.Experimental
{
    [Flags]
    public enum CaptureFlags
    {
        ManagedObjects = 1,
        NativeObjects = 2,
        NativeAllocations = 4,
        NativeAllocationSites = 8,
        NativeStackTraces = 16
    }
}
namespace UnityEngine.Profiling.Memory.Experimental
{
    public class MetaData
    {
        public string content;
        public string platform;

        public MetaData();
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Profiling.Experimental;

namespace UnityEngine.Profiling.Memory.Experimental
{
    [NativeHeader("Modules/Profiler/Runtime/MemorySnapshotManager.h")]
    public sealed class MemoryProfiler
    {
        public MemoryProfiler();

        public static event Action<MetaData> createMetaData;

        public static void TakeSnapshot(string path, Action<string, bool> finishCallback, CaptureFlags captureFlags = ManagedObjects, NativeObjects);
        public static void TakeSnapshot(string path, Action<string, bool> finishCallback, Action<string, bool, DebugScreenCapture> screenshotCallback, CaptureFlags captureFlags = ManagedObjects, NativeObjects);
        public static void TakeTempSnapshot(Action<string, bool> finishCallback, CaptureFlags captureFlags = ManagedObjects, NativeObjects);
    }
}
using Unity.Jobs.LowLevel.Unsafe;

namespace UnityEngine.Jobs
{
    [JobProducerType(typeof(IJobParallelForTransformExtensions.TransformParallelForLoopStruct<>))]
    public interface IJobParallelForTransform
    {
        void Execute(int index, TransformAccess transform);
    }
}
using Unity.Jobs;

namespace UnityEngine.Jobs
{
    public static class IJobParallelForTransformExtensions
    {
        public static JobHandle Schedule<T>(this T jobData, TransformAccessArray transforms, JobHandle dependsOn = null) where T : IJobParallelForTransform, struct;
        public static JobHandle ScheduleReadOnly<T>(this T jobData, TransformAccessArray transforms, int batchSize, JobHandle dependsOn = null) where T : IJobParallelForTransform, struct;
        public static void RunReadOnly<T>(this T jobData, TransformAccessArray transforms) where T : IJobParallelForTransform, struct;
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Jobs
{
    [NativeHeader("Runtime/Transform/ScriptBindings/TransformAccess.bindings.h")]
    public struct TransformAccess
    {
        public Vector3 position { get; set; }
        public Quaternion rotation { get; set; }
        public Vector3 localPosition { get; set; }
        public Quaternion localRotation { get; set; }
        public Vector3 localScale { get; set; }
        public Matrix4x4 localToWorldMatrix { get; }
        public Matrix4x4 worldToLocalMatrix { get; }
        public bool isValid { get; }
    }
}
using System;
using System.Reflection;
using UnityEngine.Bindings;

namespace UnityEngine.Jobs
{
    [NativeType(Header = "Runtime/Transform/ScriptBindings/TransformAccess.bindings.h", CodegenOptions = Custom)]
    [DefaultMember("Item")]
    public struct TransformAccessArray : IDisposable
    {
        public TransformAccessArray(Transform[] transforms, int desiredJobCount = -1);
        public TransformAccessArray(int capacity, int desiredJobCount = -1);

        public Transform this[int index] { get; set; }
        public bool isCreated { get; }
        public int capacity { get; set; }
        public int length { get; }

        public static void Allocate(int capacity, int desiredJobCount, out TransformAccessArray array);
        public void Dispose();
        public void Add(Transform transform);
        public void RemoveAtSwapBack(int index);
        public void SetTransforms(Transform[] transforms);
    }
}
namespace UnityEngine.WSA
{
    public delegate void AppCallbackItem();
}
namespace UnityEngine.WSA
{
    public delegate void WindowSizeChanged(int width, int height);
}
namespace UnityEngine.WSA
{
    public enum WindowActivationState
    {
        CodeActivated = 0,
        Deactivated = 1,
        PointerActivated = 2
    }
}
namespace UnityEngine.WSA
{
    public delegate void WindowActivated(WindowActivationState state);
}
using UnityEngine.Bindings;

namespace UnityEngine.WSA
{
    [NativeHeader("Runtime/Export/WSA/WSAApplication.bindings.h")]
    [StaticAccessor("WSAApplicationBindings", DoubleColon)]
    public sealed class Application
    {
        public Application();

        public static string arguments { get; }
        public static string advertisingIdentifier { get; }

        public static event WindowSizeChanged windowSizeChanged;
        public static event WindowActivated windowActivated;

        public static void InvokeOnAppThread(AppCallbackItem item, bool waitUntilDone);
        public static void InvokeOnUIThread(AppCallbackItem item, bool waitUntilDone);
        [ThreadAndSerializationSafe]
        public static bool RunningOnAppThread();
        [ThreadAndSerializationSafe]
        public static bool RunningOnUIThread();
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.WSA
{
    [NativeConditional("PLATFORM_WINRT")]
    [NativeHeader("PlatformDependent/MetroPlayer/MetroCursor.h")]
    public static class Cursor
    {
        [FreeFunction("Cursors::SetHardwareCursor")]
        public static void SetCustomCursor(uint id);
    }
}
namespace UnityEngine.WSA
{
    public enum Folder
    {
        Installation = 0,
        Temporary = 1,
        Local = 2,
        Roaming = 3,
        CameraRoll = 4,
        DocumentsLibrary = 5,
        HomeGroup = 6,
        MediaServerDevices = 7,
        MusicLibrary = 8,
        PicturesLibrary = 9,
        Playlists = 10,
        RemovableDevices = 11,
        SavedPictures = 12,
        VideosLibrary = 13
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.WSA
{
    [NativeHeader("PlatformDependent/MetroPlayer/MetroLauncher.h")]
    [StaticAccessor("metro::Launcher", DoubleColon)]
    [NativeHeader("Runtime/Export/WSA/WSALauncher.bindings.h")]
    [NativeConditional("PLATFORM_METRO")]
    public sealed class Launcher
    {
        public Launcher();

        public static void LaunchFile(Folder folder, string relativeFilePath, bool showWarning);
        public static void LaunchFileWithPicker(string fileExtension);
        public static void LaunchUri(string uri, bool showWarning);
    }
}
namespace UnityEngine.WSA
{
    public enum TileTemplate
    {
        TileSquare150x150Image = 0,
        TileSquare150x150Block = 1,
        TileSquare150x150Text01 = 2,
        TileSquare150x150Text02 = 3,
        TileSquare150x150Text03 = 4,
        TileSquare150x150Text04 = 5,
        TileSquare150x150PeekImageAndText01 = 6,
        TileSquare150x150PeekImageAndText02 = 7,
        TileSquare150x150PeekImageAndText03 = 8,
        TileSquare150x150PeekImageAndText04 = 9,
        TileWide310x150Image = 10,
        TileWide310x150ImageCollection = 11,
        TileWide310x150ImageAndText01 = 12,
        TileWide310x150ImageAndText02 = 13,
        TileWide310x150BlockAndText01 = 14,
        TileWide310x150BlockAndText02 = 15,
        TileWide310x150PeekImageCollection01 = 16,
        TileWide310x150PeekImageCollection02 = 17,
        TileWide310x150PeekImageCollection03 = 18,
        TileWide310x150PeekImageCollection04 = 19,
        TileWide310x150PeekImageCollection05 = 20,
        TileWide310x150PeekImageCollection06 = 21,
        TileWide310x150PeekImageAndText01 = 22,
        TileWide310x150PeekImageAndText02 = 23,
        TileWide310x150PeekImage01 = 24,
        TileWide310x150PeekImage02 = 25,
        TileWide310x150PeekImage03 = 26,
        TileWide310x150PeekImage04 = 27,
        TileWide310x150PeekImage05 = 28,
        TileWide310x150PeekImage06 = 29,
        TileWide310x150SmallImageAndText01 = 30,
        TileWide310x150SmallImageAndText02 = 31,
        TileWide310x150SmallImageAndText03 = 32,
        TileWide310x150SmallImageAndText04 = 33,
        TileWide310x150SmallImageAndText05 = 34,
        TileWide310x150Text01 = 35,
        TileWide310x150Text02 = 36,
        TileWide310x150Text03 = 37,
        TileWide310x150Text04 = 38,
        TileWide310x150Text05 = 39,
        TileWide310x150Text06 = 40,
        TileWide310x150Text07 = 41,
        TileWide310x150Text08 = 42,
        TileWide310x150Text09 = 43,
        TileWide310x150Text10 = 44,
        TileWide310x150Text11 = 45,
        TileSquare310x310BlockAndText01 = 46,
        TileSquare310x310BlockAndText02 = 47,
        TileSquare310x310Image = 48,
        TileSquare310x310ImageAndText01 = 49,
        TileSquare310x310ImageAndText02 = 50,
        TileSquare310x310ImageAndTextOverlay01 = 51,
        TileSquare310x310ImageAndTextOverlay02 = 52,
        TileSquare310x310ImageAndTextOverlay03 = 53,
        TileSquare310x310ImageCollectionAndText01 = 54,
        TileSquare310x310ImageCollectionAndText02 = 55,
        TileSquare310x310ImageCollection = 56,
        TileSquare310x310SmallImagesAndTextList01 = 57,
        TileSquare310x310SmallImagesAndTextList02 = 58,
        TileSquare310x310SmallImagesAndTextList03 = 59,
        TileSquare310x310SmallImagesAndTextList04 = 60,
        TileSquare310x310Text01 = 61,
        TileSquare310x310Text02 = 62,
        TileSquare310x310Text03 = 63,
        TileSquare310x310Text04 = 64,
        TileSquare310x310Text05 = 65,
        TileSquare310x310Text06 = 66,
        TileSquare310x310Text07 = 67,
        TileSquare310x310Text08 = 68,
        TileSquare310x310TextList01 = 69,
        TileSquare310x310TextList02 = 70,
        TileSquare310x310TextList03 = 71,
        TileSquare310x310SmallImageAndText01 = 72,
        TileSquare310x310SmallImagesAndTextList05 = 73,
        TileSquare310x310Text09 = 74,
        TileSquare71x71IconWithBadge = 75,
        TileSquare150x150IconWithBadge = 76,
        TileWide310x150IconWithBadgeAndText = 77,
        TileSquare71x71Image = 78,
        TileTall150x310Image = 79,
        TileSquare99x99IconWithBadge = 1000,
        TileSquare210x210IconWithBadge = 1001,
        TileWide432x210IconWithBadgeAndText = 1002
    }
}
namespace UnityEngine.WSA
{
    public enum ToastTemplate
    {
        ToastImageAndText01 = 0,
        ToastImageAndText02 = 1,
        ToastImageAndText03 = 2,
        ToastImageAndText04 = 3,
        ToastText01 = 4,
        ToastText02 = 5,
        ToastText03 = 6,
        ToastText04 = 7
    }
}
namespace UnityEngine.WSA
{
    public enum TileForegroundText
    {
        Default = -1,
        Dark = 0,
        Light = 1
    }
}
namespace UnityEngine.WSA
{
    public struct SecondaryTileData
    {
        public string arguments;
        public bool backgroundColorSet;
        public string displayName;
        public TileForegroundText foregroundText;
        public string lockScreenBadgeLogo;
        public bool lockScreenDisplayBadgeAndTileText;
        public string phoneticName;
        public bool roamingEnabled;
        public bool showNameOnSquare150x150Logo;
        public bool showNameOnSquare310x310Logo;
        public bool showNameOnWide310x150Logo;
        public string square150x150Logo;
        public string square30x30Logo;
        public string square310x310Logo;
        public string square70x70Logo;
        public string tileId;
        public string wide310x150Logo;

        public SecondaryTileData(string id, string displayName);

        public Color32 backgroundColor { get; set; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.WSA
{
    [NativeConditional("PLATFORM_WINRT")]
    [StaticAccessor("WSATilesBindings::Tile", DoubleColon)]
    [NativeHeader("Runtime/Export/WSA/WSATiles.bindings.h")]
    public sealed class Tile
    {
        public static Tile main { get; }
        public string id { get; }
        public bool hasUserConsent { get; }
        public bool exists { get; }

        [ThreadAndSerializationSafe]
        public static string GetTemplate(TileTemplate templ);
        public void Update(string xml);
        public void Update(string medium, string wide, string large, string text);
        public void PeriodicUpdate(string uri, float interval);
        public void StopPeriodicUpdate();
        public void UpdateBadgeImage(string image);
        public void UpdateBadgeNumber(float number);
        public void RemoveBadge();
        public void PeriodicBadgeUpdate(string uri, float interval);
        public void StopPeriodicBadgeUpdate();
        [ThreadAndSerializationSafe]
        public static bool Exists(string tileId);
        public static Tile CreateOrUpdateSecondary(SecondaryTileData data);
        public static Tile CreateOrUpdateSecondary(SecondaryTileData data, Vector2 pos);
        public static Tile CreateOrUpdateSecondary(SecondaryTileData data, Rect area);
        public static Tile GetSecondary(string tileId);
        public static Tile[] GetSecondaries();
        public void Delete();
        [ThreadAndSerializationSafe]
        public static void DeleteSecondary(string tileId);
        public void Delete(Vector2 pos);
        public static void DeleteSecondary(string tileId, Vector2 pos);
        public void Delete(Rect area);
        public static void DeleteSecondary(string tileId, Rect area);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.WSA
{
    [NativeHeader("Runtime/Export/WSA/WSATiles.bindings.h")]
    [StaticAccessor("WSATilesBindings::Toast", DoubleColon)]
    [NativeConditional("PLATFORM_WINRT")]
    public sealed class Toast
    {
        public string arguments { get; set; }
        public bool activated { get; }
        public bool dismissed { get; }
        public bool dismissedByUser { get; }

        public static string GetTemplate(ToastTemplate templ);
        public static Toast Create(string xml);
        public static Toast Create(string image, string text);
        public void Show();
        public void Hide();
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Windows
{
    [NativeHeader("PlatformDependent/MetroPlayer/Bindings/ApplicationTrialBindings.h")]
    public static class LicenseInformation
    {
        public static bool isOnAppTrial { get; }

        public static string PurchaseApp();
    }
}
namespace UnityEngine.Windows
{
    public static class CrashReporting
    {
        public static string crashReportFolder { get; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Windows
{
    public static class Crypto
    {
        [NativeHeader("PlatformDependent/MetroPlayer/Bindings/WindowsCryptoBindings.h")]
        public static byte[] ComputeMD5Hash(byte[] buffer);
        [NativeHeader("PlatformDependent/MetroPlayer/Bindings/WindowsCryptoBindings.h")]
        public static byte[] ComputeSHA1Hash(byte[] buffer);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Windows
{
    public static class Directory
    {
        [NativeHeader("Runtime/Export/Windows/WindowsDirectoryBindings.h")]
        public static string temporaryFolder { get; }
        [NativeHeader("Runtime/Export/Windows/WindowsDirectoryBindings.h")]
        public static string localFolder { get; }
        [NativeHeader("Runtime/Export/Windows/WindowsDirectoryBindings.h")]
        public static string roamingFolder { get; }

        [NativeHeader("Runtime/Export/Windows/WindowsDirectoryBindings.h")]
        public static void CreateDirectory(string path);
        [NativeHeader("Runtime/Export/Windows/WindowsDirectoryBindings.h")]
        public static bool Exists(string path);
        [NativeHeader("Runtime/Export/Windows/WindowsDirectoryBindings.h")]
        public static void Delete(string path);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Windows
{
    public static class File
    {
        [NativeHeader("PlatformDependent/MetroPlayer/Bindings/WindowsFileBindings.h")]
        public static byte[] ReadAllBytes(string path);
        [NativeHeader("PlatformDependent/MetroPlayer/Bindings/WindowsFileBindings.h")]
        public static void WriteAllBytes(string path, byte[] bytes);
        [NativeHeader("PlatformDependent/MetroPlayer/Bindings/WindowsFileBindings.h")]
        public static bool Exists(string path);
        [NativeHeader("PlatformDependent/MetroPlayer/Bindings/WindowsFileBindings.h")]
        public static void Delete(string path);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Windows.Speech
{
    public static class PhraseRecognitionSystem
    {
        public static bool isSupported { get; }
        public static SpeechSystemStatus Status { get; }

        public static event ErrorDelegate OnError;
        public static event StatusDelegate OnStatusChanged;

        [NativeHeader("PlatformDependent/Win/Bindings/SpeechBindings.h")]
        [NativeThrows]
        public static void Restart();
        [NativeHeader("PlatformDependent/Win/Bindings/SpeechBindings.h")]
        public static void Shutdown();

        public delegate void ErrorDelegate(SpeechError errorCode);
        public delegate void StatusDelegate(SpeechSystemStatus status);
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEngine.Windows.Speech
{
    public abstract class PhraseRecognizer : IDisposable
    {
        protected IntPtr m_Recognizer;

        ~PhraseRecognizer();

        public bool IsRunning { get; }

        public event PhraseRecognizedDelegate OnPhraseRecognized;

        [NativeThrows]
        [NativeHeader("PlatformDependent/Win/Bindings/SpeechBindings.h")]
        protected static IntPtr CreateFromKeywords(object self, string[] keywords, ConfidenceLevel minimumConfidence);
        [NativeThrows]
        [NativeHeader("PlatformDependent/Win/Bindings/SpeechBindings.h")]
        protected static IntPtr CreateFromGrammarFile(object self, string grammarFilePath, ConfidenceLevel minimumConfidence);
        public void Start();
        public void Stop();
        public void Dispose();

        public delegate void PhraseRecognizedDelegate(PhraseRecognizedEventArgs args);
    }
}
using System;

namespace UnityEngine.Windows.Speech
{
    public sealed class DictationRecognizer : IDisposable
    {
        public DictationRecognizer();
        public DictationRecognizer(ConfidenceLevel confidenceLevel);
        public DictationRecognizer(DictationTopicConstraint topic);
        public DictationRecognizer(ConfidenceLevel minimumConfidence, DictationTopicConstraint topic);

        ~DictationRecognizer();

        public SpeechSystemStatus Status { get; }
        public float AutoSilenceTimeoutSeconds { get; set; }
        public float InitialSilenceTimeoutSeconds { get; set; }

        public event DictationHypothesisDelegate DictationHypothesis;
        public event DictationResultDelegate DictationResult;
        public event DictationCompletedDelegate DictationComplete;
        public event DictationErrorHandler DictationError;

        public void Start();
        public void Stop();
        public void Dispose();

        public delegate void DictationHypothesisDelegate(string text);
        public delegate void DictationResultDelegate(string text, ConfidenceLevel confidence);
        public delegate void DictationCompletedDelegate(DictationCompletionCause cause);
        public delegate void DictationErrorHandler(string error, int hresult);
    }
}
namespace UnityEngine.Windows.Speech
{
    public enum ConfidenceLevel
    {
        High = 0,
        Medium = 1,
        Low = 2,
        Rejected = 3
    }
}
namespace UnityEngine.Windows.Speech
{
    public enum SpeechSystemStatus
    {
        Stopped = 0,
        Running = 1,
        Failed = 2
    }
}
namespace UnityEngine.Windows.Speech
{
    public enum SpeechError
    {
        NoError = 0,
        TopicLanguageNotSupported = 1,
        GrammarLanguageMismatch = 2,
        GrammarCompilationFailure = 3,
        AudioQualityFailure = 4,
        PauseLimitExceeded = 5,
        TimeoutExceeded = 6,
        NetworkFailure = 7,
        MicrophoneUnavailable = 8,
        UnknownError = 9
    }
}
namespace UnityEngine.Windows.Speech
{
    public enum DictationTopicConstraint
    {
        WebSearch = 0,
        Form = 1,
        Dictation = 2
    }
}
namespace UnityEngine.Windows.Speech
{
    public enum DictationCompletionCause
    {
        Complete = 0,
        AudioQualityFailure = 1,
        Canceled = 2,
        TimeoutExceeded = 3,
        PauseLimitExceeded = 4,
        NetworkFailure = 5,
        MicrophoneUnavailable = 6,
        UnknownError = 7
    }
}
namespace UnityEngine.Windows.Speech
{
    public struct SemanticMeaning
    {
        public string key;
        public string[] values;
    }
}
using System;

namespace UnityEngine.Windows.Speech
{
    public struct PhraseRecognizedEventArgs
    {
        public readonly ConfidenceLevel confidence;
        public readonly SemanticMeaning[] semanticMeanings;
        public readonly string text;
        public readonly DateTime phraseStartTime;
        public readonly TimeSpan phraseDuration;
    }
}
using System.Collections.Generic;

namespace UnityEngine.Windows.Speech
{
    public sealed class KeywordRecognizer : PhraseRecognizer
    {
        public KeywordRecognizer(string[] keywords);
        public KeywordRecognizer(string[] keywords, ConfidenceLevel minimumConfidence);

        public IEnumerable<string> Keywords { get; }
    }
}
namespace UnityEngine.Windows.Speech
{
    public sealed class GrammarRecognizer : PhraseRecognizer
    {
        public GrammarRecognizer(string grammarFilePath);
        public GrammarRecognizer(string grammarFilePath, ConfidenceLevel minimumConfidence);

        public string GrammarFilePath { get; }
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Windows.WebCam
{
    [MovedFrom("UnityEngine.XR.WSA.WebCam")]
    public enum PhotoCaptureFileOutputFormat
    {
        PNG = 0,
        JPG = 1
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Windows.WebCam
{
    [NativeHeader("PlatformDependent/Win/Webcam/PhotoCapture.h")]
    [StaticAccessor("PhotoCapture", DoubleColon)]
    [MovedFrom("UnityEngine.XR.WSA.WebCam")]
    public class PhotoCapture : IDisposable
    {
        ~PhotoCapture();

        public static IEnumerable<Resolution> SupportedResolutions { get; }

        public static void CreateAsync(bool showHolograms, OnCaptureResourceCreatedCallback onCreatedCallback);
        public static void CreateAsync(OnCaptureResourceCreatedCallback onCreatedCallback);
        public void StartPhotoModeAsync(CameraParameters setupParams, OnPhotoModeStartedCallback onPhotoModeStartedCallback);
        [NativeName("StopPhotoMode")]
        [NativeConditional("(PLATFORM_WIN || PLATFORM_WINRT) && !PLATFORM_XBOXONE")]
        public void StopPhotoModeAsync(OnPhotoModeStoppedCallback onPhotoModeStoppedCallback);
        public void TakePhotoAsync(string filename, PhotoCaptureFileOutputFormat fileOutputFormat, OnCapturedToDiskCallback onCapturedPhotoToDiskCallback);
        public void TakePhotoAsync(OnCapturedToMemoryCallback onCapturedPhotoToMemoryCallback);
        [NativeConditional("(PLATFORM_WIN || PLATFORM_WINRT) && !PLATFORM_XBOXONE")]
        [ThreadAndSerializationSafe]
        [NativeName("GetUnsafePointerToVideoDeviceController")]
        public IntPtr GetUnsafePointerToVideoDeviceController();
        public void Dispose();

        public enum CaptureResultType
        {
            Success = 0,
            UnknownError = 1
        }
        public struct PhotoCaptureResult
        {
            public CaptureResultType resultType;
            public long hResult;

            public bool success { get; }
        }
        public delegate void OnCaptureResourceCreatedCallback(PhotoCapture captureObject);
        public delegate void OnPhotoModeStartedCallback(PhotoCaptureResult result);
        public delegate void OnPhotoModeStoppedCallback(PhotoCaptureResult result);
        public delegate void OnCapturedToDiskCallback(PhotoCaptureResult result);
        public delegate void OnCapturedToMemoryCallback(PhotoCaptureResult result, PhotoCaptureFrame photoCaptureFrame);
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Windows.WebCam
{
    [NativeHeader("PlatformDependent/Win/Webcam/PhotoCaptureFrame.h")]
    [MovedFrom("UnityEngine.XR.WSA.WebCam")]
    [NativeConditional("(PLATFORM_WIN || PLATFORM_WINRT) && !PLATFORM_XBOXONE")]
    public sealed class PhotoCaptureFrame : IDisposable
    {
        ~PhotoCaptureFrame();

        public int dataLength { get; }
        public bool hasLocationData { get; }
        public CapturePixelFormat pixelFormat { get; }

        public bool TryGetCameraToWorldMatrix(out Matrix4x4 cameraToWorldMatrix);
        public bool TryGetProjectionMatrix(out Matrix4x4 projectionMatrix);
        public bool TryGetProjectionMatrix(float nearClipPlane, float farClipPlane, out Matrix4x4 projectionMatrix);
        public void UploadImageDataToTexture(Texture2D targetTexture);
        [ThreadAndSerializationSafe]
        [NativeConditional("(PLATFORM_WIN || PLATFORM_WINRT) && !PLATFORM_XBOXONE")]
        public IntPtr GetUnsafePointerToBuffer();
        public void CopyRawImageDataIntoBuffer(List<byte> byteBuffer);
        public void Dispose();
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Windows.WebCam
{
    [MovedFrom("UnityEngine.XR.WSA.WebCam")]
    [NativeHeader("PlatformDependent/Win/Webcam/VideoCaptureBindings.h")]
    [StaticAccessor("VideoCaptureBindings", DoubleColon)]
    public class VideoCapture : IDisposable
    {
        ~VideoCapture();

        public static IEnumerable<Resolution> SupportedResolutions { get; }
        public bool IsRecording { get; }

        public static IEnumerable<float> GetSupportedFrameRatesForResolution(Resolution resolution);
        public static void CreateAsync(bool showHolograms, OnVideoCaptureResourceCreatedCallback onCreatedCallback);
        public static void CreateAsync(OnVideoCaptureResourceCreatedCallback onCreatedCallback);
        public void StartVideoModeAsync(CameraParameters setupParams, AudioState audioState, OnVideoModeStartedCallback onVideoModeStartedCallback);
        [NativeMethod("VideoCaptureBindings::StopVideoMode", HasExplicitThis = True)]
        [NativeConditional("(PLATFORM_WIN || PLATFORM_WINRT) && !PLATFORM_XBOXONE")]
        public void StopVideoModeAsync([NotNull("ArgumentNullException")] OnVideoModeStoppedCallback onVideoModeStoppedCallback);
        public void StartRecordingAsync(string filename, OnStartedRecordingVideoCallback onStartedRecordingVideoCallback);
        [NativeConditional("(PLATFORM_WIN || PLATFORM_WINRT) && !PLATFORM_XBOXONE")]
        [NativeMethod("VideoCaptureBindings::StopRecordingVideoToDisk", HasExplicitThis = True)]
        public void StopRecordingAsync([NotNull("ArgumentNullException")] OnStoppedRecordingVideoCallback onStoppedRecordingVideoCallback);
        [NativeMethod("VideoCaptureBindings::GetUnsafePointerToVideoDeviceController", HasExplicitThis = True)]
        [NativeConditional("(PLATFORM_WIN || PLATFORM_WINRT) && !PLATFORM_XBOXONE")]
        [ThreadAndSerializationSafe]
        public IntPtr GetUnsafePointerToVideoDeviceController();
        public void Dispose();

        public enum CaptureResultType
        {
            Success = 0,
            UnknownError = 1
        }
        public enum AudioState
        {
            MicAudio = 0,
            ApplicationAudio = 1,
            ApplicationAndMicAudio = 2,
            None = 3
        }
        public struct VideoCaptureResult
        {
            public CaptureResultType resultType;
            public long hResult;

            public bool success { get; }
        }
        public delegate void OnVideoCaptureResourceCreatedCallback(VideoCapture captureObject);
        public delegate void OnVideoModeStartedCallback(VideoCaptureResult result);
        public delegate void OnVideoModeStoppedCallback(VideoCaptureResult result);
        public delegate void OnStartedRecordingVideoCallback(VideoCaptureResult result);
        public delegate void OnStoppedRecordingVideoCallback(VideoCaptureResult result);
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Windows.WebCam
{
    [MovedFrom("UnityEngine.XR.WSA.WebCam")]
    public enum CapturePixelFormat
    {
        BGRA32 = 0,
        NV12 = 1,
        JPEG = 2,
        PNG = 3
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Windows.WebCam
{
    [MovedFrom("UnityEngine.XR.WSA.WebCam")]
    public enum WebCamMode
    {
        None = 0,
        PhotoMode = 1,
        VideoMode = 2
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Windows.WebCam
{
    [NativeHeader("PlatformDependent/Win/Webcam/WebCam.h")]
    [StaticAccessor("WebCam::GetInstance()", Dot)]
    [MovedFrom("UnityEngine.XR.WSA.WebCam")]
    public class WebCam
    {
        public WebCam();

        public static WebCamMode Mode { get; }
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Windows.WebCam
{
    [NativeHeader("PlatformDependent/Win/Webcam/CameraParameters.h")]
    [UsedByNativeCode]
    [MovedFrom("UnityEngine.XR.WSA.WebCam")]
    public struct CameraParameters
    {
        public CameraParameters(WebCamMode webCamMode);

        public float hologramOpacity { get; set; }
        public float frameRate { get; set; }
        public int cameraResolutionWidth { get; set; }
        public int cameraResolutionHeight { get; set; }
        public CapturePixelFormat pixelFormat { get; set; }
    }
}
namespace UnityEngine.Events
{
    public enum PersistentListenerMode
    {
        EventDefined = 0,
        Void = 1,
        Object = 2,
        Int = 3,
        Float = 4,
        String = 5,
        Bool = 6
    }
}
namespace UnityEngine.Events
{
    public enum UnityEventCallState
    {
        Off = 0,
        EditorAndRuntime = 1,
        RuntimeOnly = 2
    }
}
using System;
using System.Reflection;
using UnityEngine.Scripting;

namespace UnityEngine.Events
{
    [UsedByNativeCode]
    public abstract class UnityEventBase : ISerializationCallbackReceiver
    {
        protected UnityEventBase();

        protected MethodInfo FindMethod_Impl(string name, object targetObj);
        protected abstract MethodInfo FindMethod_Impl(string name, Type targetObjType);
        public int GetPersistentEventCount();
        public Object GetPersistentTarget(int index);
        public string GetPersistentMethodName(int index);
        public void SetPersistentListenerState(int index, UnityEventCallState state);
        protected void AddListener(object targetObj, MethodInfo method);
        protected void RemoveListener(object targetObj, MethodInfo method);
        public void RemoveAllListeners();
        protected void Invoke(object[] parameters);
        public override string ToString();
        public static MethodInfo GetValidMethodInfo(object obj, string functionName, Type[] argumentTypes);
        public static MethodInfo GetValidMethodInfo(Type objectType, string functionName, Type[] argumentTypes);
        protected bool ValidateRegistration(MethodInfo method, object targetObj, PersistentListenerMode mode);
        protected bool ValidateRegistration(MethodInfo method, object targetObj, PersistentListenerMode mode, Type argumentType);
        protected void RegisterPersistentListener(int index, object targetObj, MethodInfo method);
        protected void RegisterPersistentListener(int index, object targetObj, Type targetObjType, MethodInfo method);
    }
}
namespace UnityEngine.Events
{
    public delegate void UnityAction();
}
using System;
using System.Reflection;
using UnityEngine.Scripting;

namespace UnityEngine.Events
{
    public class UnityEvent : UnityEventBase
    {
        [RequiredByNativeCode]
        public UnityEvent();

        public void AddListener(UnityAction call);
        public void RemoveListener(UnityAction call);
        protected override MethodInfo FindMethod_Impl(string name, Type targetObjType);
        public void Invoke();
    }
}
namespace UnityEngine.Events
{
    public delegate void UnityAction<T0>(T0 arg0);
}
using System;
using System.Reflection;
using UnityEngine.Scripting;

namespace UnityEngine.Events
{
    public class UnityEvent<T0> : UnityEventBase
    {
        [RequiredByNativeCode]
        public UnityEvent();

        public void AddListener(UnityAction<T0> call);
        public void RemoveListener(UnityAction<T0> call);
        protected override MethodInfo FindMethod_Impl(string name, Type targetObjType);
        public void Invoke(T0 arg0);
    }
}
namespace UnityEngine.Events
{
    public delegate void UnityAction<T0, T1>(T0 arg0, T1 arg1);
}
using System;
using System.Reflection;
using UnityEngine.Scripting;

namespace UnityEngine.Events
{
    public class UnityEvent<T0, T1> : UnityEventBase
    {
        [RequiredByNativeCode]
        public UnityEvent();

        public void AddListener(UnityAction<T0, T1> call);
        public void RemoveListener(UnityAction<T0, T1> call);
        protected override MethodInfo FindMethod_Impl(string name, Type targetObjType);
        public void Invoke(T0 arg0, T1 arg1);
    }
}
namespace UnityEngine.Events
{
    public delegate void UnityAction<T0, T1, T2>(T0 arg0, T1 arg1, T2 arg2);
}
using System;
using System.Reflection;
using UnityEngine.Scripting;

namespace UnityEngine.Events
{
    public class UnityEvent<T0, T1, T2> : UnityEventBase
    {
        [RequiredByNativeCode]
        public UnityEvent();

        public void AddListener(UnityAction<T0, T1, T2> call);
        public void RemoveListener(UnityAction<T0, T1, T2> call);
        protected override MethodInfo FindMethod_Impl(string name, Type targetObjType);
        public void Invoke(T0 arg0, T1 arg1, T2 arg2);
    }
}
namespace UnityEngine.Events
{
    public delegate void UnityAction<T0, T1, T2, T3>(T0 arg0, T1 arg1, T2 arg2, T3 arg3);
}
using System;
using System.Reflection;
using UnityEngine.Scripting;

namespace UnityEngine.Events
{
    public class UnityEvent<T0, T1, T2, T3> : UnityEventBase
    {
        [RequiredByNativeCode]
        public UnityEvent();

        public void AddListener(UnityAction<T0, T1, T2, T3> call);
        public void RemoveListener(UnityAction<T0, T1, T2, T3> call);
        protected override MethodInfo FindMethod_Impl(string name, Type targetObjType);
        public void Invoke(T0 arg0, T1 arg1, T2 arg2, T3 arg3);
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine.Serialization
{
    [AttributeUsage(Field, AllowMultiple = True, Inherited = False)]
    [RequiredByNativeCode]
    public class FormerlySerializedAsAttribute : Attribute
    {
        public FormerlySerializedAsAttribute(string oldName);

        public string oldName { get; }
    }
}
using System;
using System.Runtime.Serialization;

namespace UnityEngine.Serialization
{
    public class UnitySurrogateSelector : ISurrogateSelector
    {
        public UnitySurrogateSelector();

        public ISerializationSurrogate GetSurrogate(Type type, StreamingContext context, out ISurrogateSelector selector);
        public void ChainSelector(ISurrogateSelector selector);
        public ISurrogateSelector GetNextSelector();
    }
}
using System;

namespace UnityEngine.SearchService
{
    [AttributeUsage(Field)]
    public class ObjectSelectorHandlerWithLabelsAttribute : Attribute
    {
        public ObjectSelectorHandlerWithLabelsAttribute(params string[] labels);
        public ObjectSelectorHandlerWithLabelsAttribute(bool matchAll, params string[] labels);

        public string[] labels { get; }
        public bool matchAll { get; }
    }
}
using System;

namespace UnityEngine.SearchService
{
    [AttributeUsage(Field)]
    public class ObjectSelectorHandlerWithTagsAttribute : Attribute
    {
        public ObjectSelectorHandlerWithTagsAttribute(params string[] tags);

        public string[] tags { get; }
    }
}
using System;

namespace UnityEngine.Scripting
{
    [AttributeUsage(Assembly)]
    public class AlwaysLinkAssemblyAttribute : Attribute
    {
        public AlwaysLinkAssemblyAttribute();
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEngine.Scripting
{
    [NativeHeader("Runtime/Scripting/GarbageCollector.h")]
    public static class GarbageCollector
    {
        public static Mode GCMode { get; set; }
        public static bool isIncremental { get; }
        public static ulong incrementalTimeSliceNanoseconds { get; set; }

        public static event Action<Mode> GCModeChanged;

        [NativeThrows]
        [NativeMethod("CollectIncrementalWrapper")]
        public static bool CollectIncremental(ulong nanoseconds = 0);

        public enum Mode
        {
            Disabled = 0,
            Enabled = 1,
            Manual = 2
        }
    }
}
using System;

namespace UnityEngine.Scripting
{
    [RequiredByNativeCode]
    [AttributeUsage(Assembly, Class, Struct, Enum, Constructor, Method, Property, Field, Event, Interface, Delegate, Inherited = False)]
    public class PreserveAttribute : Attribute
    {
        public PreserveAttribute();
    }
}
using System;

namespace UnityEngine.Scripting
{
    [AttributeUsage(Class, AllowMultiple = False)]
    public class RequireAttributeUsagesAttribute : Attribute
    {
        public RequireAttributeUsagesAttribute();
    }
}
using System;

namespace UnityEngine.Scripting
{
    [AttributeUsage(Class, AllowMultiple = False)]
    public class RequireDerivedAttribute : Attribute
    {
        public RequireDerivedAttribute();
    }
}
using System;

namespace UnityEngine.Scripting
{
    [AttributeUsage(Class, Struct, Interface, AllowMultiple = True)]
    public class RequiredInterfaceAttribute : Attribute
    {
        public RequiredInterfaceAttribute(Type interfaceType);
    }
}
using System;

namespace UnityEngine.Scripting
{
    [AttributeUsage(Constructor, Method, Property, Field, Event)]
    public class RequiredMemberAttribute : Attribute
    {
        public RequiredMemberAttribute();
    }
}
using System;

namespace UnityEngine.Scripting
{
    [AttributeUsage(Interface, AllowMultiple = False)]
    public class RequireImplementorsAttribute : Attribute
    {
        public RequireImplementorsAttribute();
    }
}
using System;

namespace UnityEngine.Scripting.APIUpdating
{
    [AttributeUsage(Class, Struct, Enum, Interface, Delegate)]
    public class MovedFromAttribute : Attribute
    {
        public MovedFromAttribute(bool autoUpdateAPI, string sourceNamespace = null, string sourceAssembly = null, string sourceClassName = null);
        public MovedFromAttribute(string sourceNamespace);

        public bool IsInDifferentAssembly { get; }
    }
}
using System.Collections.Generic;
using UnityEngine.Bindings;

namespace UnityEngine.SceneManagement
{
    [NativeHeader("Runtime/Export/SceneManager/Scene.bindings.h")]
    public struct Scene
    {
        public int handle { get; }
        public string path { get; }
        public string name { get; set; }
        public bool isLoaded { get; }
        public int buildIndex { get; }
        public bool isDirty { get; }
        public int rootCount { get; }
        public bool isSubScene { get; set; }

        public bool IsValid();
        public GameObject[] GetRootGameObjects();
        public void GetRootGameObjects(List<GameObject> rootGameObjects);
        public override int GetHashCode();
        public override bool Equals(object other);

        public static bool operator ==(Scene lhs, Scene rhs);
        public static bool operator !=(Scene lhs, Scene rhs);
    }
}
namespace UnityEngine.SceneManagement
{
    public class SceneManagerAPI
    {
        protected internal SceneManagerAPI();

        public static SceneManagerAPI overrideAPI { get; set; }

        protected internal virtual int GetNumScenesInBuildSettings();
        protected internal virtual Scene GetSceneByBuildIndex(int buildIndex);
        protected internal virtual AsyncOperation LoadSceneAsyncByNameOrIndex(string sceneName, int sceneBuildIndex, LoadSceneParameters parameters, bool mustCompleteNextFrame);
        protected internal virtual AsyncOperation UnloadSceneAsyncByNameOrIndex(string sceneName, int sceneBuildIndex, bool immediately, UnloadSceneOptions options, out bool outSuccess);
        protected internal virtual AsyncOperation LoadFirstScene(bool mustLoadAsync);
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Events;
using UnityEngine.Internal;
using UnityEngine.Scripting;

namespace UnityEngine.SceneManagement
{
    [RequiredByNativeCode]
    [NativeHeader("Runtime/Export/SceneManager/SceneManager.bindings.h")]
    public class SceneManager
    {
        public SceneManager();

        public static int sceneCount { get; }
        public static int sceneCountInBuildSettings { get; }

        public static event UnityAction<Scene, LoadSceneMode> sceneLoaded;
        public static event UnityAction<Scene> sceneUnloaded;
        public static event UnityAction<Scene, Scene> activeSceneChanged;

        [StaticAccessor("SceneManagerBindings", DoubleColon)]
        public static Scene GetActiveScene();
        [NativeThrows]
        [StaticAccessor("SceneManagerBindings", DoubleColon)]
        public static bool SetActiveScene(Scene scene);
        [StaticAccessor("SceneManagerBindings", DoubleColon)]
        public static Scene GetSceneByPath(string scenePath);
        [StaticAccessor("SceneManagerBindings", DoubleColon)]
        public static Scene GetSceneByName(string name);
        public static Scene GetSceneByBuildIndex(int buildIndex);
        [StaticAccessor("SceneManagerBindings", DoubleColon)]
        [NativeThrows]
        public static Scene GetSceneAt(int index);
        [StaticAccessor("SceneManagerBindings", DoubleColon)]
        [NativeThrows]
        public static Scene CreateScene([NotNull("ArgumentNullException")] string sceneName, CreateSceneParameters parameters);
        [NativeThrows]
        [StaticAccessor("SceneManagerBindings", DoubleColon)]
        public static void MergeScenes(Scene sourceScene, Scene destinationScene);
        [NativeThrows]
        [StaticAccessor("SceneManagerBindings", DoubleColon)]
        public static void MoveGameObjectToScene([NotNull("ArgumentNullException")] GameObject go, Scene scene);
        [Obsolete("Use SceneManager.sceneCount and SceneManager.GetSceneAt(int index) to loop the all scenes instead.")]
        public static Scene[] GetAllScenes();
        public static Scene CreateScene(string sceneName);
        public static void LoadScene(string sceneName, [DefaultValue("LoadSceneMode.Single")] LoadSceneMode mode);
        [ExcludeFromDocs]
        public static void LoadScene(string sceneName);
        public static Scene LoadScene(string sceneName, LoadSceneParameters parameters);
        public static void LoadScene(int sceneBuildIndex, [DefaultValue("LoadSceneMode.Single")] LoadSceneMode mode);
        [ExcludeFromDocs]
        public static void LoadScene(int sceneBuildIndex);
        public static Scene LoadScene(int sceneBuildIndex, LoadSceneParameters parameters);
        public static AsyncOperation LoadSceneAsync(int sceneBuildIndex, [DefaultValue("LoadSceneMode.Single")] LoadSceneMode mode);
        [ExcludeFromDocs]
        public static AsyncOperation LoadSceneAsync(int sceneBuildIndex);
        public static AsyncOperation LoadSceneAsync(int sceneBuildIndex, LoadSceneParameters parameters);
        public static AsyncOperation LoadSceneAsync(string sceneName, [DefaultValue("LoadSceneMode.Single")] LoadSceneMode mode);
        [ExcludeFromDocs]
        public static AsyncOperation LoadSceneAsync(string sceneName);
        public static AsyncOperation LoadSceneAsync(string sceneName, LoadSceneParameters parameters);
        [Obsolete("Use SceneManager.UnloadSceneAsync. This function is not safe to use during triggers and under other circumstances. See Scripting reference for more details.")]
        public static bool UnloadScene(Scene scene);
        [Obsolete("Use SceneManager.UnloadSceneAsync. This function is not safe to use during triggers and under other circumstances. See Scripting reference for more details.")]
        public static bool UnloadScene(int sceneBuildIndex);
        [Obsolete("Use SceneManager.UnloadSceneAsync. This function is not safe to use during triggers and under other circumstances. See Scripting reference for more details.")]
        public static bool UnloadScene(string sceneName);
        public static AsyncOperation UnloadSceneAsync(int sceneBuildIndex);
        public static AsyncOperation UnloadSceneAsync(string sceneName);
        public static AsyncOperation UnloadSceneAsync(Scene scene);
        public static AsyncOperation UnloadSceneAsync(int sceneBuildIndex, UnloadSceneOptions options);
        public static AsyncOperation UnloadSceneAsync(string sceneName, UnloadSceneOptions options);
        public static AsyncOperation UnloadSceneAsync(Scene scene, UnloadSceneOptions options);
    }
}
namespace UnityEngine.SceneManagement
{
    public enum LoadSceneMode
    {
        Single = 0,
        Additive = 1
    }
}
using System;

namespace UnityEngine.SceneManagement
{
    [Flags]
    public enum LocalPhysicsMode
    {
        None = 0,
        Physics2D = 1,
        Physics3D = 2
    }
}
namespace UnityEngine.SceneManagement
{
    public struct LoadSceneParameters
    {
        public LoadSceneParameters(LoadSceneMode mode);
        public LoadSceneParameters(LoadSceneMode mode, LocalPhysicsMode physicsMode);

        public LoadSceneMode loadSceneMode { get; set; }
        public LocalPhysicsMode localPhysicsMode { get; set; }
    }
}
namespace UnityEngine.SceneManagement
{
    public struct CreateSceneParameters
    {
        public CreateSceneParameters(LocalPhysicsMode physicsMode);

        public LocalPhysicsMode localPhysicsMode { get; set; }
    }
}
using System;

namespace UnityEngine.SceneManagement
{
    [Flags]
    public enum UnloadSceneOptions
    {
        None = 0,
        UnloadAllEmbeddedSceneObjects = 1
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.SceneManagement
{
    [NativeHeader("Runtime/Export/SceneManager/SceneUtility.bindings.h")]
    public static class SceneUtility
    {
        [StaticAccessor("SceneUtilityBindings", DoubleColon)]
        public static string GetScenePathByBuildIndex(int buildIndex);
        [StaticAccessor("SceneUtilityBindings", DoubleColon)]
        public static int GetBuildIndexByScenePath(string scenePath);
    }
}
using System;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.LowLevel
{
    [MovedFrom("UnityEngine.Experimental.LowLevel")]
    public struct PlayerLoopSystem
    {
        public Type type;
        public PlayerLoopSystem[] subSystemList;
        public UpdateFunction updateDelegate;
        public IntPtr updateFunction;
        public IntPtr loopConditionFunction;

        public override string ToString();

        public delegate void UpdateFunction();
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.LowLevel
{
    [MovedFrom("UnityEngine.Experimental.LowLevel")]
    public class PlayerLoop
    {
        public PlayerLoop();

        public static PlayerLoopSystem GetDefaultPlayerLoop();
        public static PlayerLoopSystem GetCurrentPlayerLoop();
        public static void SetPlayerLoop(PlayerLoopSystem loop);
    }
}
using UnityEngine.Scripting;

namespace UnityEngine.PlayerLoop
{
    [RequiredByNativeCode]
    public struct TimeUpdate
    {
        [RequiredByNativeCode]
        public struct WaitForLastPresentationAndUpdateTime
        {
        }
    }
}
using System;
using UnityEngine.Scripting;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.PlayerLoop
{
    [MovedFrom("UnityEngine.Experimental.PlayerLoop")]
    [RequiredByNativeCode]
    public struct Initialization
    {
        [Obsolete("PlayerUpdateTime player loop component has been moved to its own category called TimeUpdate. (UnityUpgradable) -> UnityEngine.PlayerLoop.TimeUpdate/WaitForLastPresentationAndUpdateTime", True)]
        public struct PlayerUpdateTime
        {
        }
        [RequiredByNativeCode]
        public struct UpdateCameraMotionVectors
        {
        }
        [RequiredByNativeCode]
        public struct DirectorSampleTime
        {
        }
        [RequiredByNativeCode]
        public struct AsyncUploadTimeSlicedUpdate
        {
        }
        [RequiredByNativeCode]
        public struct SynchronizeState
        {
        }
        [RequiredByNativeCode]
        public struct SynchronizeInputs
        {
        }
        [RequiredByNativeCode]
        public struct XREarlyUpdate
        {
        }
    }
}
using System;
using UnityEngine.Scripting;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.PlayerLoop
{
    [MovedFrom("UnityEngine.Experimental.PlayerLoop")]
    [RequiredByNativeCode]
    public struct EarlyUpdate
    {
        [RequiredByNativeCode]
        public struct PollPlayerConnection
        {
        }
        [RequiredByNativeCode]
        public struct ProfilerStartFrame
        {
        }
        [RequiredByNativeCode]
        public struct PollHtcsPlayerConnection
        {
        }
        [RequiredByNativeCode]
        public struct GpuTimestamp
        {
        }
        [RequiredByNativeCode]
        public struct AnalyticsCoreStatsUpdate
        {
        }
        [RequiredByNativeCode]
        public struct UnityWebRequestUpdate
        {
        }
        [RequiredByNativeCode]
        public struct UpdateStreamingManager
        {
        }
        [RequiredByNativeCode]
        public struct ExecuteMainThreadJobs
        {
        }
        [RequiredByNativeCode]
        public struct ProcessMouseInWindow
        {
        }
        [RequiredByNativeCode]
        public struct ClearIntermediateRenderers
        {
        }
        [RequiredByNativeCode]
        public struct ClearLines
        {
        }
        [RequiredByNativeCode]
        public struct PresentBeforeUpdate
        {
        }
        [RequiredByNativeCode]
        public struct ResetFrameStatsAfterPresent
        {
        }
        [RequiredByNativeCode]
        public struct UpdateAsyncReadbackManager
        {
        }
        [RequiredByNativeCode]
        public struct UpdateTextureStreamingManager
        {
        }
        [RequiredByNativeCode]
        public struct UpdatePreloading
        {
        }
        [RequiredByNativeCode]
        public struct RendererNotifyInvisible
        {
        }
        [RequiredByNativeCode]
        public struct PlayerCleanupCachedData
        {
        }
        [RequiredByNativeCode]
        public struct UpdateMainGameViewRect
        {
        }
        [RequiredByNativeCode]
        public struct UpdateCanvasRectTransform
        {
        }
        [RequiredByNativeCode]
        public struct UpdateInputManager
        {
        }
        [RequiredByNativeCode]
        public struct ProcessRemoteInput
        {
        }
        [RequiredByNativeCode]
        public struct XRUpdate
        {
        }
        [RequiredByNativeCode]
        public struct ScriptRunDelayedStartupFrame
        {
        }
        [RequiredByNativeCode]
        public struct UpdateKinect
        {
        }
        [RequiredByNativeCode]
        public struct DeliverIosPlatformEvents
        {
        }
        [RequiredByNativeCode]
        public struct DispatchEventQueueEvents
        {
        }
        [RequiredByNativeCode]
        public struct PhysicsResetInterpolatedTransformPosition
        {
        }
        [RequiredByNativeCode]
        public struct SpriteAtlasManagerUpdate
        {
        }
        [Obsolete("TangoUpdate has been deprecated. Use ARCoreUpdate instead (UnityUpgradable) -> UnityEngine.PlayerLoop.EarlyUpdate/ARCoreUpdate", False)]
        [RequiredByNativeCode]
        public struct TangoUpdate
        {
        }
        [RequiredByNativeCode]
        public struct ARCoreUpdate
        {
        }
        [RequiredByNativeCode]
        public struct PerformanceAnalyticsUpdate
        {
        }
    }
}
using UnityEngine.Scripting;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.PlayerLoop
{
    [MovedFrom("UnityEngine.Experimental.PlayerLoop")]
    [RequiredByNativeCode]
    public struct FixedUpdate
    {
        [RequiredByNativeCode]
        public struct ClearLines
        {
        }
        [RequiredByNativeCode]
        public struct DirectorFixedSampleTime
        {
        }
        [RequiredByNativeCode]
        public struct AudioFixedUpdate
        {
        }
        [RequiredByNativeCode]
        public struct ScriptRunBehaviourFixedUpdate
        {
        }
        [RequiredByNativeCode]
        public struct DirectorFixedUpdate
        {
        }
        [RequiredByNativeCode]
        public struct LegacyFixedAnimationUpdate
        {
        }
        [RequiredByNativeCode]
        public struct XRFixedUpdate
        {
        }
        [RequiredByNativeCode]
        public struct PhysicsFixedUpdate
        {
        }
        [RequiredByNativeCode]
        public struct Physics2DFixedUpdate
        {
        }
        [RequiredByNativeCode]
        public struct DirectorFixedUpdatePostPhysics
        {
        }
        [RequiredByNativeCode]
        public struct ScriptRunDelayedFixedFrameRate
        {
        }
        [RequiredByNativeCode]
        public struct NewInputFixedUpdate
        {
        }
    }
}
using UnityEngine.Scripting;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.PlayerLoop
{
    [MovedFrom("UnityEngine.Experimental.PlayerLoop")]
    [RequiredByNativeCode]
    public struct PreUpdate
    {
        [RequiredByNativeCode]
        public struct PhysicsUpdate
        {
        }
        [RequiredByNativeCode]
        public struct Physics2DUpdate
        {
        }
        [RequiredByNativeCode]
        public struct CheckTexFieldInput
        {
        }
        [RequiredByNativeCode]
        public struct IMGUISendQueuedEvents
        {
        }
        [RequiredByNativeCode]
        public struct SendMouseEvents
        {
        }
        [RequiredByNativeCode]
        public struct AIUpdate
        {
        }
        [RequiredByNativeCode]
        public struct WindUpdate
        {
        }
        [RequiredByNativeCode]
        public struct UpdateVideo
        {
        }
        [RequiredByNativeCode]
        public struct NewInputUpdate
        {
        }
    }
}
using UnityEngine.Scripting;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.PlayerLoop
{
    [RequiredByNativeCode]
    [MovedFrom("UnityEngine.Experimental.PlayerLoop")]
    public struct Update
    {
        [RequiredByNativeCode]
        public struct ScriptRunBehaviourUpdate
        {
        }
        [RequiredByNativeCode]
        public struct DirectorUpdate
        {
        }
        [RequiredByNativeCode]
        public struct ScriptRunDelayedDynamicFrameRate
        {
        }
        [RequiredByNativeCode]
        public struct ScriptRunDelayedTasks
        {
        }
    }
}
using UnityEngine.Scripting;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.PlayerLoop
{
    [MovedFrom("UnityEngine.Experimental.PlayerLoop")]
    [RequiredByNativeCode]
    public struct PreLateUpdate
    {
        [RequiredByNativeCode]
        public struct Physics2DLateUpdate
        {
        }
        [RequiredByNativeCode]
        public struct AIUpdatePostScript
        {
        }
        [RequiredByNativeCode]
        public struct DirectorUpdateAnimationBegin
        {
        }
        [RequiredByNativeCode]
        public struct LegacyAnimationUpdate
        {
        }
        [RequiredByNativeCode]
        public struct DirectorUpdateAnimationEnd
        {
        }
        [RequiredByNativeCode]
        public struct DirectorDeferredEvaluate
        {
        }
        [RequiredByNativeCode]
        public struct UIElementsUpdatePanels
        {
        }
        [RequiredByNativeCode]
        public struct UpdateNetworkManager
        {
        }
        [RequiredByNativeCode]
        public struct UpdateMasterServerInterface
        {
        }
        [RequiredByNativeCode]
        public struct UNetUpdate
        {
        }
        [RequiredByNativeCode]
        public struct EndGraphicsJobsAfterScriptUpdate
        {
        }
        [RequiredByNativeCode]
        public struct ParticleSystemBeginUpdateAll
        {
        }
        [RequiredByNativeCode]
        public struct ScriptRunBehaviourLateUpdate
        {
        }
        [RequiredByNativeCode]
        public struct ConstraintManagerUpdate
        {
        }
    }
}
using UnityEngine.Scripting;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.PlayerLoop
{
    [RequiredByNativeCode]
    [MovedFrom("UnityEngine.Experimental.PlayerLoop")]
    public struct PostLateUpdate
    {
        [RequiredByNativeCode]
        public struct PlayerSendFrameStarted
        {
        }
        [RequiredByNativeCode]
        public struct UpdateRectTransform
        {
        }
        [RequiredByNativeCode]
        public struct UpdateCanvasRectTransform
        {
        }
        [RequiredByNativeCode]
        public struct PlayerUpdateCanvases
        {
        }
        [RequiredByNativeCode]
        public struct UpdateAudio
        {
        }
        [RequiredByNativeCode]
        public struct UpdateVideo
        {
        }
        [RequiredByNativeCode]
        public struct DirectorLateUpdate
        {
        }
        [RequiredByNativeCode]
        public struct ScriptRunDelayedDynamicFrameRate
        {
        }
        [RequiredByNativeCode]
        public struct VFXUpdate
        {
        }
        [RequiredByNativeCode]
        public struct ParticleSystemEndUpdateAll
        {
        }
        [RequiredByNativeCode]
        public struct EndGraphicsJobsAfterScriptLateUpdate
        {
        }
        [RequiredByNativeCode]
        public struct UpdateSubstance
        {
        }
        [RequiredByNativeCode]
        public struct UpdateCustomRenderTextures
        {
        }
        [RequiredByNativeCode]
        public struct XRPostLateUpdate
        {
        }
        [RequiredByNativeCode]
        public struct UpdateAllRenderers
        {
        }
        [RequiredByNativeCode]
        public struct UpdateLightProbeProxyVolumes
        {
        }
        [RequiredByNativeCode]
        public struct EnlightenRuntimeUpdate
        {
        }
        [RequiredByNativeCode]
        public struct UpdateAllSkinnedMeshes
        {
        }
        [RequiredByNativeCode]
        public struct ProcessWebSendMessages
        {
        }
        [RequiredByNativeCode]
        public struct SortingGroupsUpdate
        {
        }
        [RequiredByNativeCode]
        public struct UpdateVideoTextures
        {
        }
        [RequiredByNativeCode]
        public struct DirectorRenderImage
        {
        }
        [RequiredByNativeCode]
        public struct PlayerEmitCanvasGeometry
        {
        }
        [RequiredByNativeCode]
        public struct FinishFrameRendering
        {
        }
        [RequiredByNativeCode]
        public struct BatchModeUpdate
        {
        }
        [RequiredByNativeCode]
        public struct PlayerSendFrameComplete
        {
        }
        [RequiredByNativeCode]
        public struct UpdateCaptureScreenshot
        {
        }
        [RequiredByNativeCode]
        public struct PresentAfterDraw
        {
        }
        [RequiredByNativeCode]
        public struct ClearImmediateRenderers
        {
        }
        [RequiredByNativeCode]
        public struct XRPostPresent
        {
        }
        [RequiredByNativeCode]
        public struct UpdateResolution
        {
        }
        [RequiredByNativeCode]
        public struct InputEndFrame
        {
        }
        [RequiredByNativeCode]
        public struct GUIClearEvents
        {
        }
        [RequiredByNativeCode]
        public struct ShaderHandleErrors
        {
        }
        [RequiredByNativeCode]
        public struct ResetInputAxis
        {
        }
        [RequiredByNativeCode]
        public struct ThreadedLoadingDebug
        {
        }
        [RequiredByNativeCode]
        public struct ProfilerSynchronizeStats
        {
        }
        [RequiredByNativeCode]
        public struct MemoryFrameMaintenance
        {
        }
        [RequiredByNativeCode]
        public struct ExecuteGameCenterCallbacks
        {
        }
        [RequiredByNativeCode]
        public struct XRPreEndFrame
        {
        }
        [RequiredByNativeCode]
        public struct ProfilerEndFrame
        {
        }
        [RequiredByNativeCode]
        public struct PlayerSendFramePostPresent
        {
        }
        [RequiredByNativeCode]
        public struct PhysicsSkinnedClothBeginUpdate
        {
        }
        [RequiredByNativeCode]
        public struct PhysicsSkinnedClothFinishUpdate
        {
        }
        [RequiredByNativeCode]
        public struct TriggerEndOfFrameCallbacks
        {
        }
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Networking.PlayerConnection
{
    [MovedFrom("UnityEngine.Experimental.Networking.PlayerConnection")]
    public enum ConnectionTarget
    {
        None = 0,
        Player = 1,
        Editor = 2
    }
}
using System;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Networking.PlayerConnection
{
    [MovedFrom("UnityEngine.Experimental.Networking.PlayerConnection")]
    public interface IConnectionState : IDisposable
    {
        ConnectionTarget connectedToTarget { get; }
        string connectionName { get; }
    }
}
namespace UnityEngine.Networking.PlayerConnection
{
    public class MessageEventArgs
    {
        public int playerId;
        public byte[] data;

        public MessageEventArgs();
    }
}
using System;
using UnityEngine.Events;

namespace UnityEngine.Networking.PlayerConnection
{
    public interface IEditorPlayerConnection
    {
        void Register(Guid messageId, UnityAction<MessageEventArgs> callback);
        void Unregister(Guid messageId, UnityAction<MessageEventArgs> callback);
        void DisconnectAll();
        void RegisterConnection(UnityAction<int> callback);
        void RegisterDisconnection(UnityAction<int> callback);
        void UnregisterConnection(UnityAction<int> callback);
        void UnregisterDisconnection(UnityAction<int> callback);
        void Send(Guid messageId, byte[] data);
        bool TrySend(Guid messageId, byte[] data);
    }
}
using System;
using UnityEngine.Events;

namespace UnityEngine.Networking.PlayerConnection
{
    public class PlayerConnection : ScriptableObject, IEditorPlayerConnection
    {
        public PlayerConnection();

        public static PlayerConnection instance { get; }
        public bool isConnected { get; }

        public void OnEnable();
        public void Register(Guid messageId, UnityAction<MessageEventArgs> callback);
        public void Unregister(Guid messageId, UnityAction<MessageEventArgs> callback);
        public void RegisterConnection(UnityAction<int> callback);
        public void RegisterDisconnection(UnityAction<int> callback);
        public void UnregisterConnection(UnityAction<int> callback);
        public void UnregisterDisconnection(UnityAction<int> callback);
        public void Send(Guid messageId, byte[] data);
        public bool TrySend(Guid messageId, byte[] data);
        public bool BlockUntilRecvMsg(Guid messageId, int timeout);
        public void DisconnectAll();
    }
}
using System;

namespace UnityEngine.Lumin
{
    [AttributeUsage(Class, AllowMultiple = False)]
    public sealed class UsesLuminPlatformLevelAttribute : Attribute
    {
        public UsesLuminPlatformLevelAttribute(uint platformLevel);

        public uint platformLevel { get; }
    }
}
using System;

namespace UnityEngine.Lumin
{
    [AttributeUsage(Class, AllowMultiple = True)]
    public sealed class UsesLuminPrivilegeAttribute : Attribute
    {
        public UsesLuminPrivilegeAttribute(string privilege);

        public string privilege { get; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.tvOS
{
    [NativeHeader("PlatformDependent/iPhonePlayer/IOSScriptBindings.h")]
    public sealed class Remote
    {
        public Remote();

        public static bool allowExitToHome { get; set; }
        public static bool allowRemoteRotation { get; set; }
        public static bool reportAbsoluteDpadValues { get; set; }
        public static bool touchesEnabled { get; set; }
    }
}
using System;

namespace UnityEngine.tvOS
{
    public enum DeviceGeneration
    {
        Unknown = 0,
        [Obsolete("AppleTV1Gen has been renamed. Use AppleTVHD instead (UnityUpgradable) -> AppleTVHD", False)]
        AppleTV1Gen = 1001,
        AppleTVHD = 1001,
        [Obsolete("AppleTV2Gen has been renamed. Use AppleTV4K instead (UnityUpgradable) -> AppleTV4K", False)]
        AppleTV2Gen = 1002,
        AppleTV4K = 1002,
        AppleTV4K2Gen = 1003
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.tvOS
{
    [NativeHeader("PlatformDependent/iPhonePlayer/IOSScriptBindings.h")]
    public sealed class Device
    {
        public Device();

        public static string systemVersion { get; }
        public static DeviceGeneration generation { get; }
        public static string vendorIdentifier { get; }
        public static string advertisingIdentifier { get; }
        public static bool advertisingTrackingEnabled { get; }

        public static void SetNoBackupFlag(string path);
        public static void ResetNoBackupFlag(string path);
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine.iOS
{
    [EditorBrowsable(Never)]
    [Obsolete("iOS.ADBannerView class is obsolete, Apple iAD service discontinued", True)]
    public sealed class ADBannerView
    {
        public ADBannerView(Type type, Layout layout);

        public bool loaded { get; }
        public bool visible { get; set; }
        public Layout layout { get; set; }
        public Vector2 position { get; set; }
        public Vector2 size { get; }

        public static event BannerWasClickedDelegate onBannerWasClicked;
        public static event BannerWasLoadedDelegate onBannerWasLoaded;
        public static event BannerFailedToLoadDelegate onBannerFailedToLoad;

        public static bool IsAvailable(Type type);

        public enum Layout
        {
            Top = 0,
            Bottom = 1,
            TopLeft = 0,
            TopRight = 4,
            TopCenter = 8,
            BottomLeft = 1,
            BottomRight = 5,
            BottomCenter = 9,
            CenterLeft = 2,
            CenterRight = 6,
            Center = 10,
            Manual = -1
        }
        public enum Type
        {
            Banner = 0,
            MediumRect = 1
        }
        public delegate void BannerWasClickedDelegate();
        public delegate void BannerWasLoadedDelegate();
        public delegate void BannerFailedToLoadDelegate();
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine.iOS
{
    [EditorBrowsable(Never)]
    [Obsolete("iOS.ADInterstitialAd class is obsolete, Apple iAD service discontinued", True)]
    public sealed class ADInterstitialAd
    {
        public ADInterstitialAd(bool autoReload);
        public ADInterstitialAd();

        public static bool isAvailable { get; }
        public bool loaded { get; }

        public static event InterstitialWasLoadedDelegate onInterstitialWasLoaded;
        public static event InterstitialWasViewedDelegate onInterstitialWasViewed;

        public void Show();
        public void ReloadAd();

        public delegate void InterstitialWasLoadedDelegate();
        public delegate void InterstitialWasViewedDelegate();
    }
}
namespace UnityEngine.iOS
{
    public enum DeviceGeneration
    {
        Unknown = 0,
        iPhone = 1,
        iPhone3G = 2,
        iPhone3GS = 3,
        iPodTouch1Gen = 4,
        iPodTouch2Gen = 5,
        iPodTouch3Gen = 6,
        iPad1Gen = 7,
        iPhone4 = 8,
        iPodTouch4Gen = 9,
        iPad2Gen = 10,
        iPhone4S = 11,
        iPad3Gen = 12,
        iPhone5 = 13,
        iPodTouch5Gen = 14,
        iPadMini1Gen = 15,
        iPad4Gen = 16,
        iPhone5C = 17,
        iPhone5S = 18,
        iPadAir1 = 19,
        iPadMini2Gen = 20,
        iPhone6 = 21,
        iPhone6Plus = 22,
        iPadMini3Gen = 23,
        iPadAir2 = 24,
        iPhone6S = 25,
        iPhone6SPlus = 26,
        iPadPro1Gen = 27,
        iPadMini4Gen = 28,
        iPhoneSE1Gen = 29,
        iPadPro10Inch1Gen = 30,
        iPhone7 = 31,
        iPhone7Plus = 32,
        iPodTouch6Gen = 33,
        iPad5Gen = 34,
        iPadPro2Gen = 35,
        iPadPro10Inch2Gen = 36,
        iPhone8 = 37,
        iPhone8Plus = 38,
        iPhoneX = 39,
        iPhoneXS = 40,
        iPhoneXSMax = 41,
        iPhoneXR = 42,
        iPadPro11Inch = 43,
        iPadPro3Gen = 44,
        iPad6Gen = 45,
        iPadAir3Gen = 46,
        iPadMini5Gen = 47,
        iPhone11 = 48,
        iPhone11Pro = 49,
        iPhone11ProMax = 50,
        iPodTouch7Gen = 51,
        iPad7Gen = 52,
        iPhoneSE2Gen = 53,
        iPadPro11Inch2Gen = 54,
        iPadPro4Gen = 55,
        iPhone12Mini = 56,
        iPhone12 = 57,
        iPhone12Pro = 58,
        iPhone12ProMax = 59,
        iPad8Gen = 60,
        iPadAir4Gen = 61,
        iPad9Gen = 62,
        iPadMini6Gen = 63,
        iPhone13 = 64,
        iPhone13Mini = 65,
        iPhone13Pro = 66,
        iPhone13ProMax = 67,
        iPadPro5Gen = 68,
        iPadPro11Inch3Gen = 69,
        iPhoneSE3Gen = 70,
        iPadAir5Gen = 71,
        iPhoneUnknown = 10001,
        iPadUnknown = 10002,
        iPodTouchUnknown = 10003
    }
}
namespace UnityEngine.iOS
{
    public enum ActivityIndicatorStyle
    {
        DontShow = -1,
        WhiteLarge = 0,
        White = 1,
        Gray = 2
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.iOS
{
    [NativeHeader("PlatformDependent/iPhonePlayer/IOSScriptBindings.h")]
    public sealed class Device
    {
        public Device();

        public static string systemVersion { get; }
        public static DeviceGeneration generation { get; }
        public static string vendorIdentifier { get; }
        public static string advertisingIdentifier { get; }
        public static bool advertisingTrackingEnabled { get; }
        public static bool hideHomeButton { get; set; }
        public static bool lowPowerModeEnabled { get; }
        public static bool wantsSoftwareDimming { get; set; }
        public static bool iosAppOnMac { get; }
        public static SystemGestureDeferMode deferSystemGesturesMode { get; set; }

        [NativeConditional("PLATFORM_IOS || PLATFORM_TVOS")]
        [NativeMethod(Name = "IOSScripting::SetNoBackupFlag", IsFreeFunction = True, IsThreadSafe = True)]
        public static void SetNoBackupFlag(string path);
        [NativeMethod(Name = "IOSScripting::ResetNoBackupFlag", IsFreeFunction = True, IsThreadSafe = True)]
        [NativeConditional("PLATFORM_IOS || PLATFORM_TVOS")]
        public static void ResetNoBackupFlag(string path);
        [NativeConditional("PLATFORM_IOS")]
        [NativeMethod(Name = "IOSScripting::RequestStoreReview", IsFreeFunction = True, IsThreadSafe = True)]
        public static bool RequestStoreReview();
    }
}
using System;

namespace UnityEngine.iOS
{
    [Obsolete("iOS.Notification Services is deprecated. Consider using the Mobile Notifications package (available in the package manager) which implements the UserNotifications framework.")]
    public enum CalendarIdentifier
    {
        GregorianCalendar = 0,
        BuddhistCalendar = 1,
        ChineseCalendar = 2,
        HebrewCalendar = 3,
        IslamicCalendar = 4,
        IslamicCivilCalendar = 5,
        JapaneseCalendar = 6,
        RepublicOfChinaCalendar = 7,
        PersianCalendar = 8,
        IndianCalendar = 9,
        ISO8601Calendar = 10
    }
}
using System;

namespace UnityEngine.iOS
{
    [Obsolete("iOS.Notification Services is deprecated. Consider using the Mobile Notifications package (available in the package manager) which implements the UserNotifications framework.")]
    public enum CalendarUnit
    {
        Era = 2,
        Year = 4,
        Month = 8,
        Day = 16,
        Hour = 32,
        Minute = 64,
        Second = 128,
        Week = 256,
        Weekday = 512,
        WeekdayOrdinal = 1024,
        Quarter = 2048
    }
}
using System;

namespace UnityEngine.iOS
{
    [Obsolete("iOS.Notification Services is deprecated. Consider using the Mobile Notifications package (available in the package manager) which implements the UserNotifications framework.")]
    public enum NotificationType
    {
        None = 0,
        Badge = 1,
        Sound = 2,
        Alert = 4
    }
}
using System;
using System.Collections;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.iOS
{
    [Obsolete("iOS.Notification Services is deprecated. Consider using the Mobile Notifications package (available in the package manager) which implements the UserNotifications framework.")]
    [NativeHeader("PlatformDependent/iPhonePlayer/Notifications.h")]
    [RequiredByNativeCode]
    [NativeConditional("PLATFORM_IOS")]
    public sealed class LocalNotification
    {
        public LocalNotification();

        ~LocalNotification();

        public string timeZone { get; set; }
        public CalendarIdentifier repeatCalendar { get; set; }
        public CalendarUnit repeatInterval { get; set; }
        public DateTime fireDate { get; set; }
        public string alertBody { get; set; }
        public string alertTitle { get; set; }
        public string alertAction { get; set; }
        public string alertLaunchImage { get; set; }
        public string soundName { get; set; }
        public int applicationIconBadgeNumber { get; set; }
        public static string defaultSoundName { get; }
        [NativeThrows]
        public IDictionary userInfo { get; set; }
        public bool hasAction { get; set; }
    }
}
using System;
using System.Collections;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.iOS
{
    [RequiredByNativeCode]
    [NativeConditional("PLATFORM_IOS || PLATFORM_TVOS")]
    [NativeHeader("PlatformDependent/iPhonePlayer/Notifications.h")]
    [Obsolete("iOS.Notification Services is deprecated. Consider using the Mobile Notifications package (available in the package manager) which implements the UserNotifications framework.")]
    public sealed class RemoteNotification
    {
        ~RemoteNotification();

        public string alertBody { get; }
        public string alertTitle { get; }
        public string soundName { get; }
        public int applicationIconBadgeNumber { get; }
        public IDictionary userInfo { get; }
        public bool hasAction { get; }
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEngine.iOS
{
    [NativeHeader("PlatformDependent/iPhonePlayer/Notifications.h")]
    [NativeConditional("PLATFORM_IOS || PLATFORM_TVOS")]
    [Obsolete("iOS.Notification Services is deprecated. Consider using the Mobile Notifications package (available in the package manager) which implements the UserNotifications framework.")]
    public sealed class NotificationServices
    {
        public NotificationServices();

        public static int localNotificationCount { get; }
        public static int remoteNotificationCount { get; }
        public static NotificationType enabledNotificationTypes { get; }
        public static string registrationError { get; }
        public static byte[] deviceToken { get; }
        public static LocalNotification[] localNotifications { get; }
        public static RemoteNotification[] remoteNotifications { get; }
        public static LocalNotification[] scheduledLocalNotifications { get; }

        [FreeFunction("NotificationScripting::ClearLocal")]
        public static void ClearLocalNotifications();
        [FreeFunction("NotificationScripting::ClearRemote")]
        public static void ClearRemoteNotifications();
        public static void RegisterForNotifications(NotificationType notificationTypes);
        public static void RegisterForNotifications(NotificationType notificationTypes, bool registerForRemote);
        public static void ScheduleLocalNotification(LocalNotification notification);
        public static void PresentLocalNotificationNow(LocalNotification notification);
        public static void CancelLocalNotification(LocalNotification notification);
        [FreeFunction("iPhoneLocalNotification::CancelAll")]
        public static void CancelAllLocalNotifications();
        [FreeFunction("iPhoneRemoteNotification::Unregister")]
        public static void UnregisterForRemoteNotifications();
        public static LocalNotification GetLocalNotification(int index);
        public static RemoteNotification GetRemoteNotification(int index);
    }
}
using System;

namespace UnityEngine.iOS
{
    [Flags]
    public enum SystemGestureDeferMode
    {
        None = 0,
        TopEdge = 1,
        LeftEdge = 2,
        BottomEdge = 4,
        RightEdge = 8,
        All = 15
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.iOS
{
    [NativeHeader("Runtime/Export/iOS/OnDemandResources.h")]
    [UsedByNativeCode]
    public sealed class OnDemandResourcesRequest : AsyncOperation, IDisposable
    {
        ~OnDemandResourcesRequest();

        public string error { get; }
        public float loadingPriority { get; set; }

        public string GetResourcePath(string resourceName);
        public void Dispose();
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.iOS
{
    [NativeHeader("Runtime/Export/iOS/OnDemandResources.h")]
    public static class OnDemandResources
    {
        public static bool enabled { get; }

        public static OnDemandResourcesRequest PreloadAsync(string[] tags);
    }
}
using System;

namespace UnityEngine.Internal
{
    [AttributeUsage(Parameter, GenericParameter)]
    public class DefaultValueAttribute : Attribute
    {
        public DefaultValueAttribute(string value);

        public object Value { get; }

        public override bool Equals(object obj);
        public override int GetHashCode();
    }
}
using System;

namespace UnityEngine.Internal
{
    public class ExcludeFromDocsAttribute : Attribute
    {
        public ExcludeFromDocsAttribute();
    }
}
using Unity.Collections;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Rendering
{
    [NativeHeader("Runtime/Shaders/ComputeShader.h")]
    [NativeHeader("Runtime/Graphics/Texture.h")]
    [NativeHeader("Runtime/Graphics/AsyncGPUReadbackManaged.h")]
    [UsedByNativeCode]
    public struct AsyncGPUReadbackRequest
    {
        public bool done { get; }
        public bool hasError { get; }
        public int layerCount { get; }
        public int layerDataSize { get; }
        public int width { get; }
        public int height { get; }
        public int depth { get; }

        public void Update();
        public void WaitForCompletion();
        public NativeArray<T> GetData<T>(int layer = 0) where T : struct;
    }
}
using System;
using Unity.Collections;
using UnityEngine.Bindings;
using UnityEngine.Experimental.Rendering;

namespace UnityEngine.Rendering
{
    [StaticAccessor("AsyncGPUReadbackManager::GetInstance()", Dot)]
    public static class AsyncGPUReadback
    {
        public static void WaitAllRequests();
        public static AsyncGPUReadbackRequest Request(ComputeBuffer src, Action<AsyncGPUReadbackRequest> callback = null);
        public static AsyncGPUReadbackRequest Request(ComputeBuffer src, int size, int offset, Action<AsyncGPUReadbackRequest> callback = null);
        public static AsyncGPUReadbackRequest Request(GraphicsBuffer src, Action<AsyncGPUReadbackRequest> callback = null);
        public static AsyncGPUReadbackRequest Request(GraphicsBuffer src, int size, int offset, Action<AsyncGPUReadbackRequest> callback = null);
        public static AsyncGPUReadbackRequest Request(Texture src, int mipIndex = 0, Action<AsyncGPUReadbackRequest> callback = null);
        public static AsyncGPUReadbackRequest Request(Texture src, int mipIndex, TextureFormat dstFormat, Action<AsyncGPUReadbackRequest> callback = null);
        public static AsyncGPUReadbackRequest Request(Texture src, int mipIndex, GraphicsFormat dstFormat, Action<AsyncGPUReadbackRequest> callback = null);
        public static AsyncGPUReadbackRequest Request(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, Action<AsyncGPUReadbackRequest> callback = null);
        public static AsyncGPUReadbackRequest Request(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, TextureFormat dstFormat, Action<AsyncGPUReadbackRequest> callback = null);
        public static AsyncGPUReadbackRequest Request(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, GraphicsFormat dstFormat, Action<AsyncGPUReadbackRequest> callback = null);
        public static AsyncGPUReadbackRequest RequestIntoNativeArray<T>(ref NativeArray<T> output, ComputeBuffer src, Action<AsyncGPUReadbackRequest> callback = null) where T : struct;
        public static AsyncGPUReadbackRequest RequestIntoNativeArray<T>(ref NativeArray<T> output, ComputeBuffer src, int size, int offset, Action<AsyncGPUReadbackRequest> callback = null) where T : struct;
        public static AsyncGPUReadbackRequest RequestIntoNativeArray<T>(ref NativeArray<T> output, GraphicsBuffer src, Action<AsyncGPUReadbackRequest> callback = null) where T : struct;
        public static AsyncGPUReadbackRequest RequestIntoNativeArray<T>(ref NativeArray<T> output, GraphicsBuffer src, int size, int offset, Action<AsyncGPUReadbackRequest> callback = null) where T : struct;
        public static AsyncGPUReadbackRequest RequestIntoNativeArray<T>(ref NativeArray<T> output, Texture src, int mipIndex = 0, Action<AsyncGPUReadbackRequest> callback = null) where T : struct;
        public static AsyncGPUReadbackRequest RequestIntoNativeArray<T>(ref NativeArray<T> output, Texture src, int mipIndex, TextureFormat dstFormat, Action<AsyncGPUReadbackRequest> callback = null) where T : struct;
        public static AsyncGPUReadbackRequest RequestIntoNativeArray<T>(ref NativeArray<T> output, Texture src, int mipIndex, GraphicsFormat dstFormat, Action<AsyncGPUReadbackRequest> callback = null) where T : struct;
        public static AsyncGPUReadbackRequest RequestIntoNativeArray<T>(ref NativeArray<T> output, Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, TextureFormat dstFormat, Action<AsyncGPUReadbackRequest> callback = null) where T : struct;
        public static AsyncGPUReadbackRequest RequestIntoNativeArray<T>(ref NativeArray<T> output, Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, GraphicsFormat dstFormat, Action<AsyncGPUReadbackRequest> callback = null) where T : struct;
        public static AsyncGPUReadbackRequest RequestIntoNativeSlice<T>(ref NativeSlice<T> output, ComputeBuffer src, Action<AsyncGPUReadbackRequest> callback = null) where T : struct;
        public static AsyncGPUReadbackRequest RequestIntoNativeSlice<T>(ref NativeSlice<T> output, ComputeBuffer src, int size, int offset, Action<AsyncGPUReadbackRequest> callback = null) where T : struct;
        public static AsyncGPUReadbackRequest RequestIntoNativeSlice<T>(ref NativeSlice<T> output, GraphicsBuffer src, Action<AsyncGPUReadbackRequest> callback = null) where T : struct;
        public static AsyncGPUReadbackRequest RequestIntoNativeSlice<T>(ref NativeSlice<T> output, GraphicsBuffer src, int size, int offset, Action<AsyncGPUReadbackRequest> callback = null) where T : struct;
        public static AsyncGPUReadbackRequest RequestIntoNativeSlice<T>(ref NativeSlice<T> output, Texture src, int mipIndex = 0, Action<AsyncGPUReadbackRequest> callback = null) where T : struct;
        public static AsyncGPUReadbackRequest RequestIntoNativeSlice<T>(ref NativeSlice<T> output, Texture src, int mipIndex, TextureFormat dstFormat, Action<AsyncGPUReadbackRequest> callback = null) where T : struct;
        public static AsyncGPUReadbackRequest RequestIntoNativeSlice<T>(ref NativeSlice<T> output, Texture src, int mipIndex, GraphicsFormat dstFormat, Action<AsyncGPUReadbackRequest> callback = null) where T : struct;
        public static AsyncGPUReadbackRequest RequestIntoNativeSlice<T>(ref NativeSlice<T> output, Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, TextureFormat dstFormat, Action<AsyncGPUReadbackRequest> callback = null) where T : struct;
        public static AsyncGPUReadbackRequest RequestIntoNativeSlice<T>(ref NativeSlice<T> output, Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, GraphicsFormat dstFormat, Action<AsyncGPUReadbackRequest> callback = null) where T : struct;
    }
}
namespace UnityEngine.Rendering
{
    public enum SynchronisationStage
    {
        VertexProcessing = 0,
        PixelProcessing = 1
    }
}
using System;

namespace UnityEngine.Rendering
{
    [Obsolete("GPUFence has been deprecated. Use GraphicsFence instead (UnityUpgradable) -> GraphicsFence", False)]
    public struct GPUFence
    {
        public bool passed { get; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Rendering
{
    [NativeHeader("Runtime/Graphics/GraphicsScriptBindings.h")]
    public class PIX
    {
        public PIX();

        [FreeFunction("PIX::BeginGPUCapture")]
        public static void BeginGPUCapture();
        [FreeFunction("PIX::EndGPUCapture")]
        public static void EndGPUCapture();
        [FreeFunction("PIX::IsAttached")]
        public static bool IsAttached();
    }
}
using System;

namespace UnityEngine.Rendering
{
    [Obsolete("ShaderHardwareTier was renamed to GraphicsTier (UnityUpgradable) -> GraphicsTier", False)]
    public enum ShaderHardwareTier
    {
        Tier1 = 0,
        Tier2 = 1,
        Tier3 = 2
    }
}
namespace UnityEngine.Rendering
{
    public enum IndexFormat
    {
        UInt16 = 0,
        UInt32 = 1
    }
}
using System;

namespace UnityEngine.Rendering
{
    [Flags]
    public enum MeshUpdateFlags
    {
        Default = 0,
        DontValidateIndices = 1,
        DontResetBoneBounds = 2,
        DontNotifyMeshUsers = 4,
        DontRecalculateBounds = 8
    }
}
namespace UnityEngine.Rendering
{
    public enum VertexAttributeFormat
    {
        Float32 = 0,
        Float16 = 1,
        UNorm8 = 2,
        SNorm8 = 3,
        UNorm16 = 4,
        SNorm16 = 5,
        UInt8 = 6,
        SInt8 = 7,
        UInt16 = 8,
        SInt16 = 9,
        UInt32 = 10,
        SInt32 = 11
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering
{
    [MovedFrom("UnityEngine.Experimental.Rendering")]
    public enum VertexAttribute
    {
        Position = 0,
        Normal = 1,
        Tangent = 2,
        Color = 3,
        TexCoord0 = 4,
        TexCoord1 = 5,
        TexCoord2 = 6,
        TexCoord3 = 7,
        TexCoord4 = 8,
        TexCoord5 = 9,
        TexCoord6 = 10,
        TexCoord7 = 11,
        BlendWeight = 12,
        BlendIndices = 13
    }
}
namespace UnityEngine.Rendering
{
    public enum ShaderParamType
    {
        Float = 0,
        Int = 1,
        Bool = 2,
        Half = 3,
        Short = 4,
        UInt = 5
    }
}
namespace UnityEngine.Rendering
{
    public enum ShaderConstantType
    {
        Vector = 0,
        Matrix = 1,
        Struct = 2
    }
}
namespace UnityEngine.Rendering
{
    public enum OpaqueSortMode
    {
        Default = 0,
        FrontToBack = 1,
        NoDistanceSort = 2
    }
}
namespace UnityEngine.Rendering
{
    public enum RenderQueue
    {
        Background = 1000,
        Geometry = 2000,
        AlphaTest = 2450,
        GeometryLast = 2500,
        Transparent = 3000,
        Overlay = 4000
    }
}
namespace UnityEngine.Rendering
{
    public enum RenderBufferLoadAction
    {
        Load = 0,
        Clear = 1,
        DontCare = 2
    }
}
namespace UnityEngine.Rendering
{
    public enum RenderBufferStoreAction
    {
        Store = 0,
        Resolve = 1,
        StoreAndResolve = 2,
        DontCare = 3
    }
}
using System;

namespace UnityEngine.Rendering
{
    [Flags]
    public enum FastMemoryFlags
    {
        None = 0,
        SpillTop = 1,
        SpillBottom = 2
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Rendering
{
    [NativeHeader("Runtime/GfxDevice/GfxDeviceTypes.h")]
    public enum BlendMode
    {
        Zero = 0,
        One = 1,
        DstColor = 2,
        SrcColor = 3,
        OneMinusDstColor = 4,
        SrcAlpha = 5,
        OneMinusSrcColor = 6,
        DstAlpha = 7,
        OneMinusDstAlpha = 8,
        SrcAlphaSaturate = 9,
        OneMinusSrcAlpha = 10
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Rendering
{
    [NativeHeader("Runtime/GfxDevice/GfxDeviceTypes.h")]
    public enum BlendOp
    {
        Add = 0,
        Subtract = 1,
        ReverseSubtract = 2,
        Min = 3,
        Max = 4,
        LogicalClear = 5,
        LogicalSet = 6,
        LogicalCopy = 7,
        LogicalCopyInverted = 8,
        LogicalNoop = 9,
        LogicalInvert = 10,
        LogicalAnd = 11,
        LogicalNand = 12,
        LogicalOr = 13,
        LogicalNor = 14,
        LogicalXor = 15,
        LogicalEquivalence = 16,
        LogicalAndReverse = 17,
        LogicalAndInverted = 18,
        LogicalOrReverse = 19,
        LogicalOrInverted = 20,
        Multiply = 21,
        Screen = 22,
        Overlay = 23,
        Darken = 24,
        Lighten = 25,
        ColorDodge = 26,
        ColorBurn = 27,
        HardLight = 28,
        SoftLight = 29,
        Difference = 30,
        Exclusion = 31,
        HSLHue = 32,
        HSLSaturation = 33,
        HSLColor = 34,
        HSLLuminosity = 35
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Rendering
{
    [NativeHeader("Runtime/GfxDevice/GfxDeviceTypes.h")]
    public enum CompareFunction
    {
        Disabled = 0,
        Never = 1,
        Less = 2,
        Equal = 3,
        LessEqual = 4,
        Greater = 5,
        NotEqual = 6,
        GreaterEqual = 7,
        Always = 8
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Rendering
{
    [NativeHeader("Runtime/GfxDevice/GfxDeviceTypes.h")]
    public enum CullMode
    {
        Off = 0,
        Front = 1,
        Back = 2
    }
}
using System;

namespace UnityEngine.Rendering
{
    [Flags]
    public enum ColorWriteMask
    {
        Alpha = 1,
        Blue = 2,
        Green = 4,
        Red = 8,
        All = 15
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Rendering
{
    [NativeHeader("Runtime/GfxDevice/GfxDeviceTypes.h")]
    public enum StencilOp
    {
        Keep = 0,
        Zero = 1,
        Replace = 2,
        IncrementSaturate = 3,
        DecrementSaturate = 4,
        Invert = 5,
        IncrementWrap = 6,
        DecrementWrap = 7
    }
}
namespace UnityEngine.Rendering
{
    public enum AmbientMode
    {
        Skybox = 0,
        Trilight = 1,
        Flat = 3,
        Custom = 4
    }
}
namespace UnityEngine.Rendering
{
    public enum DefaultReflectionMode
    {
        Skybox = 0,
        Custom = 1
    }
}
namespace UnityEngine.Rendering
{
    public enum ReflectionCubemapCompression
    {
        Uncompressed = 0,
        Compressed = 1,
        Auto = 2
    }
}
namespace UnityEngine.Rendering
{
    public enum CameraEvent
    {
        BeforeDepthTexture = 0,
        AfterDepthTexture = 1,
        BeforeDepthNormalsTexture = 2,
        AfterDepthNormalsTexture = 3,
        BeforeGBuffer = 4,
        AfterGBuffer = 5,
        BeforeLighting = 6,
        AfterLighting = 7,
        BeforeFinalPass = 8,
        AfterFinalPass = 9,
        BeforeForwardOpaque = 10,
        AfterForwardOpaque = 11,
        BeforeImageEffectsOpaque = 12,
        AfterImageEffectsOpaque = 13,
        BeforeSkybox = 14,
        AfterSkybox = 15,
        BeforeForwardAlpha = 16,
        AfterForwardAlpha = 17,
        BeforeImageEffects = 18,
        AfterImageEffects = 19,
        AfterEverything = 20,
        BeforeReflections = 21,
        AfterReflections = 22,
        BeforeHaloAndLensFlares = 23,
        AfterHaloAndLensFlares = 24
    }
}
namespace UnityEngine.Rendering
{
    public enum LightEvent
    {
        BeforeShadowMap = 0,
        AfterShadowMap = 1,
        BeforeScreenspaceMask = 2,
        AfterScreenspaceMask = 3,
        BeforeShadowMapPass = 4,
        AfterShadowMapPass = 5
    }
}
using System;

namespace UnityEngine.Rendering
{
    [Flags]
    public enum ShadowMapPass
    {
        PointlightPositiveX = 1,
        PointlightNegativeX = 2,
        PointlightPositiveY = 4,
        PointlightNegativeY = 8,
        PointlightPositiveZ = 16,
        PointlightNegativeZ = 32,
        DirectionalCascade0 = 64,
        DirectionalCascade1 = 128,
        DirectionalCascade2 = 256,
        DirectionalCascade3 = 512,
        Spotlight = 1024,
        Pointlight = 63,
        Directional = 960,
        All = 2047
    }
}
namespace UnityEngine.Rendering
{
    public enum BuiltinRenderTextureType
    {
        PropertyName = -4,
        BufferPtr = -3,
        RenderTexture = -2,
        BindableTexture = -1,
        None = 0,
        CurrentActive = 1,
        CameraTarget = 2,
        Depth = 3,
        DepthNormals = 4,
        ResolvedDepth = 5,
        PrepassNormalsSpec = 7,
        PrepassLight = 8,
        PrepassLightSpec = 9,
        GBuffer0 = 10,
        GBuffer1 = 11,
        GBuffer2 = 12,
        GBuffer3 = 13,
        Reflections = 14,
        MotionVectors = 15,
        GBuffer4 = 16,
        GBuffer5 = 17,
        GBuffer6 = 18,
        GBuffer7 = 19
    }
}
using System;

namespace UnityEngine.Rendering
{
    public enum PassType
    {
        Normal = 0,
        Vertex = 1,
        VertexLM = 2,
        [Obsolete("VertexLMRGBM PassType is obsolete. Please use VertexLM PassType together with DecodeLightmap shader function.")]
        VertexLMRGBM = 3,
        ForwardBase = 4,
        ForwardAdd = 5,
        LightPrePassBase = 6,
        LightPrePassFinal = 7,
        ShadowCaster = 8,
        Deferred = 10,
        Meta = 11,
        MotionVectors = 12,
        ScriptableRenderPipeline = 13,
        ScriptableRenderPipelineDefaultUnlit = 14
    }
}
namespace UnityEngine.Rendering
{
    public enum ShadowCastingMode
    {
        Off = 0,
        On = 1,
        TwoSided = 2,
        ShadowsOnly = 3
    }
}
namespace UnityEngine.Rendering
{
    public enum LightShadowResolution
    {
        FromQualitySettings = -1,
        Low = 0,
        Medium = 1,
        High = 2,
        VeryHigh = 3
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine.Rendering
{
    [UsedByNativeCode]
    public enum GraphicsDeviceType
    {
        [Obsolete("OpenGL2 is no longer supported in Unity 5.5+")]
        OpenGL2 = 0,
        [Obsolete("Direct3D 9 is no longer supported in Unity 2017.2+")]
        Direct3D9 = 1,
        Direct3D11 = 2,
        [Obsolete("PS3 is no longer supported in Unity 5.5+")]
        PlayStation3 = 3,
        Null = 4,
        [Obsolete("Xbox360 is no longer supported in Unity 5.5+")]
        Xbox360 = 6,
        OpenGLES2 = 8,
        OpenGLES3 = 11,
        [Obsolete("PVita is no longer supported as of Unity 2018")]
        PlayStationVita = 12,
        PlayStation4 = 13,
        XboxOne = 14,
        [Obsolete("PlayStationMobile is no longer supported in Unity 5.3+")]
        PlayStationMobile = 15,
        Metal = 16,
        OpenGLCore = 17,
        Direct3D12 = 18,
        [Obsolete("Nintendo 3DS support is unavailable since 2018.1")]
        N3DS = 19,
        Vulkan = 21,
        Switch = 22,
        XboxOneD3D12 = 23,
        GameCoreXboxOne = 24,
        [Obsolete("GameCoreScarlett is deprecated, please use GameCoreXboxSeries (UnityUpgradable) -> GameCoreXboxSeries", False)]
        GameCoreScarlett = -1,
        GameCoreXboxSeries = 25,
        PlayStation5 = 26,
        PlayStation5NGGC = 27
    }
}
namespace UnityEngine.Rendering
{
    public enum GraphicsTier
    {
        Tier1 = 0,
        Tier2 = 1,
        Tier3 = 2
    }
}
namespace UnityEngine.Rendering
{
    public struct SubMeshDescriptor
    {
        public SubMeshDescriptor(int indexStart, int indexCount, MeshTopology topology = Triangles);

        public Bounds bounds { get; set; }
        public MeshTopology topology { get; set; }
        public int indexStart { get; set; }
        public int indexCount { get; set; }
        public int baseVertex { get; set; }
        public int firstVertex { get; set; }
        public int vertexCount { get; set; }

        public override string ToString();
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine.Rendering
{
    [UsedByNativeCode]
    public struct VertexAttributeDescriptor : IEquatable<VertexAttributeDescriptor>
    {
        public VertexAttributeDescriptor(VertexAttribute attribute = Position, VertexAttributeFormat format = Float32, int dimension = 3, int stream = 0);

        public VertexAttribute attribute { get; set; }
        public VertexAttributeFormat format { get; set; }
        public int dimension { get; set; }
        public int stream { get; set; }

        public override string ToString();
        public override int GetHashCode();
        public override bool Equals(object other);
        public bool Equals(VertexAttributeDescriptor other);

        public static bool operator ==(VertexAttributeDescriptor lhs, VertexAttributeDescriptor rhs);
        public static bool operator !=(VertexAttributeDescriptor lhs, VertexAttributeDescriptor rhs);
    }
}
namespace UnityEngine.Rendering
{
    public enum FormatSwizzle
    {
        FormatSwizzleR = 0,
        FormatSwizzleG = 1,
        FormatSwizzleB = 2,
        FormatSwizzleA = 3,
        FormatSwizzle0 = 4,
        FormatSwizzle1 = 5
    }
}
using System;

namespace UnityEngine.Rendering
{
    public struct RenderTargetIdentifier : IEquatable<RenderTargetIdentifier>
    {
        public const int AllDepthSlices = -1;

        public RenderTargetIdentifier(BuiltinRenderTextureType type);
        public RenderTargetIdentifier(BuiltinRenderTextureType type, int mipLevel = 0, CubemapFace cubeFace = Unknown, int depthSlice = 0);
        public RenderTargetIdentifier(string name);
        public RenderTargetIdentifier(string name, int mipLevel = 0, CubemapFace cubeFace = Unknown, int depthSlice = 0);
        public RenderTargetIdentifier(int nameID);
        public RenderTargetIdentifier(int nameID, int mipLevel = 0, CubemapFace cubeFace = Unknown, int depthSlice = 0);
        public RenderTargetIdentifier(RenderTargetIdentifier renderTargetIdentifier, int mipLevel, CubemapFace cubeFace = Unknown, int depthSlice = 0);
        public RenderTargetIdentifier(Texture tex);
        public RenderTargetIdentifier(Texture tex, int mipLevel = 0, CubemapFace cubeFace = Unknown, int depthSlice = 0);
        public RenderTargetIdentifier(RenderBuffer buf, int mipLevel = 0, CubemapFace cubeFace = Unknown, int depthSlice = 0);

        public override string ToString();
        public override int GetHashCode();
        public bool Equals(RenderTargetIdentifier rhs);
        public override bool Equals(object obj);

        public static bool operator ==(RenderTargetIdentifier lhs, RenderTargetIdentifier rhs);
        public static bool operator !=(RenderTargetIdentifier lhs, RenderTargetIdentifier rhs);

        public static implicit operator RenderTargetIdentifier(BuiltinRenderTextureType type);
        public static implicit operator RenderTargetIdentifier(string name);
        public static implicit operator RenderTargetIdentifier(int nameID);
        public static implicit operator RenderTargetIdentifier(Texture tex);
        public static implicit operator RenderTargetIdentifier(RenderBuffer buf);
    }
}
using System;

namespace UnityEngine.Rendering
{
    [Flags]
    public enum RenderTargetFlags
    {
        None = 0,
        ReadOnlyDepth = 1,
        ReadOnlyStencil = 2,
        ReadOnlyDepthStencil = 3
    }
}
namespace UnityEngine.Rendering
{
    public struct RenderTargetBinding
    {
        public RenderTargetBinding(RenderTargetIdentifier[] colorRenderTargets, RenderBufferLoadAction[] colorLoadActions, RenderBufferStoreAction[] colorStoreActions, RenderTargetIdentifier depthRenderTarget, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction);
        public RenderTargetBinding(RenderTargetIdentifier colorRenderTarget, RenderBufferLoadAction colorLoadAction, RenderBufferStoreAction colorStoreAction, RenderTargetIdentifier depthRenderTarget, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction);
        public RenderTargetBinding(RenderTargetSetup setup);

        public RenderTargetIdentifier[] colorRenderTargets { get; set; }
        public RenderTargetIdentifier depthRenderTarget { get; set; }
        public RenderBufferLoadAction[] colorLoadActions { get; set; }
        public RenderBufferStoreAction[] colorStoreActions { get; set; }
        public RenderBufferLoadAction depthLoadAction { get; set; }
        public RenderBufferStoreAction depthStoreAction { get; set; }
        public RenderTargetFlags flags { get; set; }
    }
}
namespace UnityEngine.Rendering
{
    public enum ReflectionProbeUsage
    {
        Off = 0,
        BlendProbes = 1,
        BlendProbesAndSkybox = 2,
        Simple = 3
    }
}
namespace UnityEngine.Rendering
{
    public enum ReflectionProbeType
    {
        Cube = 0,
        Card = 1
    }
}
namespace UnityEngine.Rendering
{
    public enum ReflectionProbeClearFlags
    {
        Skybox = 1,
        SolidColor = 2
    }
}
namespace UnityEngine.Rendering
{
    public enum ReflectionProbeMode
    {
        Baked = 0,
        Realtime = 1,
        Custom = 2
    }
}
using UnityEngine.Scripting;

namespace UnityEngine.Rendering
{
    [UsedByNativeCode]
    public struct ReflectionProbeBlendInfo
    {
        public ReflectionProbe probe;
        public float weight;
    }
}
namespace UnityEngine.Rendering
{
    public enum ReflectionProbeRefreshMode
    {
        OnAwake = 0,
        EveryFrame = 1,
        ViaScripting = 2
    }
}
namespace UnityEngine.Rendering
{
    public enum ReflectionProbeTimeSlicingMode
    {
        AllFacesAtOnce = 0,
        IndividualFaces = 1,
        NoTimeSlicing = 2
    }
}
namespace UnityEngine.Rendering
{
    public enum ShadowSamplingMode
    {
        CompareDepths = 0,
        RawDepth = 1,
        None = 2
    }
}
namespace UnityEngine.Rendering
{
    public enum LightProbeUsage
    {
        Off = 0,
        BlendProbes = 1,
        UseProxyVolume = 2,
        CustomProvided = 4
    }
}
namespace UnityEngine.Rendering
{
    public enum BuiltinShaderType
    {
        DeferredShading = 0,
        DeferredReflections = 1,
        LegacyDeferredLighting = 2,
        ScreenSpaceShadows = 3,
        DepthNormals = 4,
        MotionVectors = 5,
        LightHalo = 6,
        LensFlare = 7
    }
}
namespace UnityEngine.Rendering
{
    public enum BuiltinShaderMode
    {
        Disabled = 0,
        UseBuiltin = 1,
        UseCustom = 2
    }
}
namespace UnityEngine.Rendering
{
    public enum BuiltinShaderDefine
    {
        UNITY_NO_DXT5nm = 0,
        UNITY_NO_RGBM = 1,
        UNITY_USE_NATIVE_HDR = 2,
        UNITY_ENABLE_REFLECTION_BUFFERS = 3,
        UNITY_FRAMEBUFFER_FETCH_AVAILABLE = 4,
        UNITY_ENABLE_NATIVE_SHADOW_LOOKUPS = 5,
        UNITY_METAL_SHADOWS_USE_POINT_FILTERING = 6,
        UNITY_NO_CUBEMAP_ARRAY = 7,
        UNITY_NO_SCREENSPACE_SHADOWS = 8,
        UNITY_USE_DITHER_MASK_FOR_ALPHABLENDED_SHADOWS = 9,
        UNITY_PBS_USE_BRDF1 = 10,
        UNITY_PBS_USE_BRDF2 = 11,
        UNITY_PBS_USE_BRDF3 = 12,
        UNITY_NO_FULL_STANDARD_SHADER = 13,
        UNITY_SPECCUBE_BOX_PROJECTION = 14,
        UNITY_SPECCUBE_BLENDING = 15,
        UNITY_ENABLE_DETAIL_NORMALMAP = 16,
        SHADER_API_MOBILE = 17,
        SHADER_API_DESKTOP = 18,
        UNITY_HARDWARE_TIER1 = 19,
        UNITY_HARDWARE_TIER2 = 20,
        UNITY_HARDWARE_TIER3 = 21,
        UNITY_COLORSPACE_GAMMA = 22,
        UNITY_LIGHT_PROBE_PROXY_VOLUME = 23,
        UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS = 24,
        UNITY_LIGHTMAP_DLDR_ENCODING = 25,
        UNITY_LIGHTMAP_RGBM_ENCODING = 26,
        UNITY_LIGHTMAP_FULL_HDR = 27,
        UNITY_VIRTUAL_TEXTURING = 28,
        UNITY_PRETRANSFORM_TO_DISPLAY_ORIENTATION = 29,
        UNITY_ASTC_NORMALMAP_ENCODING = 30,
        SHADER_API_GLES30 = 31,
        UNITY_UNIFIED_SHADER_PRECISION_MODEL = 32
    }
}
namespace UnityEngine.Rendering
{
    public enum VideoShadersIncludeMode
    {
        Never = 0,
        Referenced = 1,
        Always = 2
    }
}
namespace UnityEngine.Rendering
{
    public enum TextureDimension
    {
        Unknown = -1,
        None = 0,
        Any = 1,
        Tex2D = 2,
        Tex3D = 3,
        Cube = 4,
        Tex2DArray = 5,
        CubeArray = 6
    }
}
using System;

namespace UnityEngine.Rendering
{
    [Flags]
    public enum CopyTextureSupport
    {
        None = 0,
        Basic = 1,
        Copy3D = 2,
        DifferentTypes = 4,
        TextureToRT = 8,
        RTToTexture = 16
    }
}
namespace UnityEngine.Rendering
{
    public enum CameraHDRMode
    {
        FP16 = 1,
        R11G11B10 = 2
    }
}
namespace UnityEngine.Rendering
{
    public enum RealtimeGICPUUsage
    {
        Low = 25,
        Medium = 50,
        High = 75,
        Unlimited = 100
    }
}
namespace UnityEngine.Rendering
{
    public enum ComputeQueueType
    {
        Default = 0,
        Background = 1,
        Urgent = 2
    }
}
namespace UnityEngine.Rendering
{
    public enum SinglePassStereoMode
    {
        None = 0,
        SideBySide = 1,
        Instancing = 2,
        Multiview = 3
    }
}
namespace UnityEngine.Rendering
{
    public enum CommandBufferExecutionFlags
    {
        None = 0,
        AsyncCompute = 2
    }
}
namespace UnityEngine.Rendering
{
    public enum RenderTextureSubElement
    {
        Color = 0,
        Depth = 1,
        Stencil = 2,
        Default = 3
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering
{
    [MovedFrom("UnityEngine.Experimental.Rendering")]
    public enum RenderingThreadingMode
    {
        Direct = 0,
        SingleThreaded = 1,
        MultiThreaded = 2,
        LegacyJobified = 3,
        NativeGraphicsJobs = 4,
        NativeGraphicsJobsWithoutRenderThread = 5
    }
}
namespace UnityEngine.Rendering
{
    public enum CameraLateLatchMatrixType
    {
        View = 0,
        InverseView = 1,
        ViewProjection = 2,
        InverseViewProjection = 3
    }
}
namespace UnityEngine.Rendering
{
    public enum OpenGLESVersion
    {
        None = 0,
        OpenGLES20 = 1,
        OpenGLES30 = 2,
        OpenGLES31 = 3,
        OpenGLES31AEP = 4,
        OpenGLES32 = 5
    }
}
namespace UnityEngine.Rendering
{
    public enum SynchronisationStageFlags
    {
        VertexProcessing = 1,
        PixelProcessing = 2,
        ComputeProcessing = 4,
        AllGPUOperations = 7
    }
}
namespace UnityEngine.Rendering
{
    public enum GraphicsFenceType
    {
        AsyncQueueSynchronisation = 0,
        CPUSynchronisation = 1
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Rendering
{
    [UsedByNativeCode]
    [NativeHeader("Runtime/Graphics/GPUFence.h")]
    public struct GraphicsFence
    {
        public bool passed { get; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Rendering
{
    [StaticAccessor("GetGraphicsSettings()", Dot)]
    [NativeHeader("Runtime/Camera/GraphicsSettings.h")]
    public sealed class GraphicsSettings : Object
    {
        public static TransparencySortMode transparencySortMode { get; set; }
        public static Vector3 transparencySortAxis { get; set; }
        public static bool realtimeDirectRectangularAreaLights { get; set; }
        public static bool lightsUseLinearIntensity { get; set; }
        public static bool lightsUseColorTemperature { get; set; }
        public static uint defaultRenderingLayerMask { get; set; }
        public static bool useScriptableRenderPipelineBatching { get; set; }
        public static bool logWhenShaderIsCompiled { get; set; }
        public static bool disableBuiltinCustomRenderTextureUpdate { get; set; }
        public static VideoShadersIncludeMode videoShadersIncludeMode { get; set; }
        public static RenderPipelineAsset currentRenderPipeline { get; }
        public static RenderPipelineAsset renderPipelineAsset { get; set; }
        public static RenderPipelineAsset defaultRenderPipeline { get; set; }
        public static RenderPipelineAsset[] allConfiguredRenderPipelines { get; }

        public static bool HasShaderDefine(GraphicsTier tier, BuiltinShaderDefine defineHash);
        public static bool HasShaderDefine(BuiltinShaderDefine defineHash);
        [FreeFunction]
        public static Object GetGraphicsSettings();
        [NativeName("SetShaderModeScript")]
        public static void SetShaderMode(BuiltinShaderType type, BuiltinShaderMode mode);
        [NativeName("GetShaderModeScript")]
        public static BuiltinShaderMode GetShaderMode(BuiltinShaderType type);
        [NativeName("SetCustomShaderScript")]
        public static void SetCustomShader(BuiltinShaderType type, Shader shader);
        [NativeName("GetCustomShaderScript")]
        public static Shader GetCustomShader(BuiltinShaderType type);
    }
}
using UnityEngine.Scripting;

namespace UnityEngine.Rendering
{
    [RequiredByNativeCode]
    public class OnDemandRendering
    {
        public OnDemandRendering();

        public static bool willCurrentFrameRender { get; }
        public static int renderFrameInterval { get; set; }
        public static int effectiveRenderFrameRate { get; }
    }
}
using System;
using System.Collections.Generic;
using System.Security;
using Unity.Collections;
using UnityEngine.Bindings;
using UnityEngine.Experimental.Rendering;
using UnityEngine.Profiling;
using UnityEngine.Scripting;

namespace UnityEngine.Rendering
{
    [UsedByNativeCode]
    [NativeHeader("Runtime/Shaders/RayTracingShader.h")]
    [NativeHeader("Runtime/Export/Graphics/RenderingCommandBuffer.bindings.h")]
    [NativeHeader("Runtime/Shaders/ComputeShader.h")]
    [NativeType("Runtime/Graphics/CommandBuffer/RenderingCommandBuffer.h")]
    public class CommandBuffer : IDisposable
    {
        public CommandBuffer();

        ~CommandBuffer();

        public string name { get; set; }
        public int sizeInBytes { get; }

        public void ConvertTexture(RenderTargetIdentifier src, RenderTargetIdentifier dst);
        public void ConvertTexture(RenderTargetIdentifier src, int srcElement, RenderTargetIdentifier dst, int dstElement);
        [NativeMethod("AddWaitAllAsyncReadbackRequests")]
        public void WaitAllAsyncReadbackRequests();
        public void RequestAsyncReadback(ComputeBuffer src, Action<AsyncGPUReadbackRequest> callback);
        public void RequestAsyncReadback(GraphicsBuffer src, Action<AsyncGPUReadbackRequest> callback);
        public void RequestAsyncReadback(ComputeBuffer src, int size, int offset, Action<AsyncGPUReadbackRequest> callback);
        public void RequestAsyncReadback(GraphicsBuffer src, int size, int offset, Action<AsyncGPUReadbackRequest> callback);
        public void RequestAsyncReadback(Texture src, Action<AsyncGPUReadbackRequest> callback);
        public void RequestAsyncReadback(Texture src, int mipIndex, Action<AsyncGPUReadbackRequest> callback);
        public void RequestAsyncReadback(Texture src, int mipIndex, TextureFormat dstFormat, Action<AsyncGPUReadbackRequest> callback);
        public void RequestAsyncReadback(Texture src, int mipIndex, GraphicsFormat dstFormat, Action<AsyncGPUReadbackRequest> callback);
        public void RequestAsyncReadback(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, Action<AsyncGPUReadbackRequest> callback);
        public void RequestAsyncReadback(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, TextureFormat dstFormat, Action<AsyncGPUReadbackRequest> callback);
        public void RequestAsyncReadback(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, GraphicsFormat dstFormat, Action<AsyncGPUReadbackRequest> callback);
        public void RequestAsyncReadbackIntoNativeArray<T>(ref NativeArray<T> output, ComputeBuffer src, Action<AsyncGPUReadbackRequest> callback) where T : struct;
        public void RequestAsyncReadbackIntoNativeArray<T>(ref NativeArray<T> output, ComputeBuffer src, int size, int offset, Action<AsyncGPUReadbackRequest> callback) where T : struct;
        public void RequestAsyncReadbackIntoNativeArray<T>(ref NativeArray<T> output, GraphicsBuffer src, Action<AsyncGPUReadbackRequest> callback) where T : struct;
        public void RequestAsyncReadbackIntoNativeArray<T>(ref NativeArray<T> output, GraphicsBuffer src, int size, int offset, Action<AsyncGPUReadbackRequest> callback) where T : struct;
        public void RequestAsyncReadbackIntoNativeArray<T>(ref NativeArray<T> output, Texture src, Action<AsyncGPUReadbackRequest> callback) where T : struct;
        public void RequestAsyncReadbackIntoNativeArray<T>(ref NativeArray<T> output, Texture src, int mipIndex, Action<AsyncGPUReadbackRequest> callback) where T : struct;
        public void RequestAsyncReadbackIntoNativeArray<T>(ref NativeArray<T> output, Texture src, int mipIndex, TextureFormat dstFormat, Action<AsyncGPUReadbackRequest> callback) where T : struct;
        public void RequestAsyncReadbackIntoNativeArray<T>(ref NativeArray<T> output, Texture src, int mipIndex, GraphicsFormat dstFormat, Action<AsyncGPUReadbackRequest> callback) where T : struct;
        public void RequestAsyncReadbackIntoNativeArray<T>(ref NativeArray<T> output, Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, Action<AsyncGPUReadbackRequest> callback) where T : struct;
        public void RequestAsyncReadbackIntoNativeArray<T>(ref NativeArray<T> output, Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, TextureFormat dstFormat, Action<AsyncGPUReadbackRequest> callback) where T : struct;
        public void RequestAsyncReadbackIntoNativeArray<T>(ref NativeArray<T> output, Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, GraphicsFormat dstFormat, Action<AsyncGPUReadbackRequest> callback) where T : struct;
        public void RequestAsyncReadbackIntoNativeSlice<T>(ref NativeSlice<T> output, ComputeBuffer src, Action<AsyncGPUReadbackRequest> callback) where T : struct;
        public void RequestAsyncReadbackIntoNativeSlice<T>(ref NativeSlice<T> output, ComputeBuffer src, int size, int offset, Action<AsyncGPUReadbackRequest> callback) where T : struct;
        public void RequestAsyncReadbackIntoNativeSlice<T>(ref NativeSlice<T> output, GraphicsBuffer src, Action<AsyncGPUReadbackRequest> callback) where T : struct;
        public void RequestAsyncReadbackIntoNativeSlice<T>(ref NativeSlice<T> output, GraphicsBuffer src, int size, int offset, Action<AsyncGPUReadbackRequest> callback) where T : struct;
        public void RequestAsyncReadbackIntoNativeSlice<T>(ref NativeSlice<T> output, Texture src, Action<AsyncGPUReadbackRequest> callback) where T : struct;
        public void RequestAsyncReadbackIntoNativeSlice<T>(ref NativeSlice<T> output, Texture src, int mipIndex, Action<AsyncGPUReadbackRequest> callback) where T : struct;
        public void RequestAsyncReadbackIntoNativeSlice<T>(ref NativeSlice<T> output, Texture src, int mipIndex, TextureFormat dstFormat, Action<AsyncGPUReadbackRequest> callback) where T : struct;
        public void RequestAsyncReadbackIntoNativeSlice<T>(ref NativeSlice<T> output, Texture src, int mipIndex, GraphicsFormat dstFormat, Action<AsyncGPUReadbackRequest> callback) where T : struct;
        public void RequestAsyncReadbackIntoNativeSlice<T>(ref NativeSlice<T> output, Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, Action<AsyncGPUReadbackRequest> callback) where T : struct;
        public void RequestAsyncReadbackIntoNativeSlice<T>(ref NativeSlice<T> output, Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, TextureFormat dstFormat, Action<AsyncGPUReadbackRequest> callback) where T : struct;
        public void RequestAsyncReadbackIntoNativeSlice<T>(ref NativeSlice<T> output, Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, GraphicsFormat dstFormat, Action<AsyncGPUReadbackRequest> callback) where T : struct;
        [NativeMethod("AddSetInvertCulling")]
        public void SetInvertCulling(bool invertCulling);
        [FreeFunction("RenderingCommandBuffer_Bindings::SetComputeFloatParam", HasExplicitThis = True)]
        public void SetComputeFloatParam([NotNull("ArgumentNullException")] ComputeShader computeShader, int nameID, float val);
        [FreeFunction("RenderingCommandBuffer_Bindings::SetComputeIntParam", HasExplicitThis = True)]
        public void SetComputeIntParam([NotNull("ArgumentNullException")] ComputeShader computeShader, int nameID, int val);
        [FreeFunction("RenderingCommandBuffer_Bindings::SetComputeVectorParam", HasExplicitThis = True)]
        public void SetComputeVectorParam([NotNull("ArgumentNullException")] ComputeShader computeShader, int nameID, Vector4 val);
        [FreeFunction("RenderingCommandBuffer_Bindings::SetComputeVectorArrayParam", HasExplicitThis = True)]
        public void SetComputeVectorArrayParam([NotNull("ArgumentNullException")] ComputeShader computeShader, int nameID, Vector4[] values);
        [FreeFunction("RenderingCommandBuffer_Bindings::SetComputeMatrixParam", HasExplicitThis = True)]
        public void SetComputeMatrixParam([NotNull("ArgumentNullException")] ComputeShader computeShader, int nameID, Matrix4x4 val);
        [FreeFunction("RenderingCommandBuffer_Bindings::SetComputeMatrixArrayParam", HasExplicitThis = True)]
        public void SetComputeMatrixArrayParam([NotNull("ArgumentNullException")] ComputeShader computeShader, int nameID, Matrix4x4[] values);
        [NativeMethod("AddSetRayTracingShaderPass")]
        public void SetRayTracingShaderPass([NotNull("ArgumentNullException")] RayTracingShader rayTracingShader, string passName);
        [NativeMethod("ClearCommands")]
        public void Clear();
        [FreeFunction("RenderingCommandBuffer_Bindings::ClearRandomWriteTargets", HasExplicitThis = True, ThrowsException = True)]
        public void ClearRandomWriteTargets();
        [FreeFunction("RenderingCommandBuffer_Bindings::SetViewport", HasExplicitThis = True, ThrowsException = True)]
        public void SetViewport(Rect pixelRect);
        [FreeFunction("RenderingCommandBuffer_Bindings::EnableScissorRect", HasExplicitThis = True, ThrowsException = True)]
        public void EnableScissorRect(Rect scissor);
        [FreeFunction("RenderingCommandBuffer_Bindings::DisableScissorRect", HasExplicitThis = True, ThrowsException = True)]
        public void DisableScissorRect();
        [FreeFunction("RenderingCommandBuffer_Bindings::GetTemporaryRT", HasExplicitThis = True)]
        public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, GraphicsFormat format, int antiAliasing, bool enableRandomWrite, RenderTextureMemoryless memorylessMode, bool useDynamicScale);
        public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, GraphicsFormat format, int antiAliasing, bool enableRandomWrite, RenderTextureMemoryless memorylessMode);
        public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, GraphicsFormat format, int antiAliasing, bool enableRandomWrite);
        public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, GraphicsFormat format, int antiAliasing);
        public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, GraphicsFormat format);
        public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing, bool enableRandomWrite, RenderTextureMemoryless memorylessMode, bool useDynamicScale);
        public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing, bool enableRandomWrite, RenderTextureMemoryless memorylessMode);
        public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing, bool enableRandomWrite);
        public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing);
        public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite);
        public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, RenderTextureFormat format);
        public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter);
        public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer);
        public void GetTemporaryRT(int nameID, int width, int height);
        public void GetTemporaryRT(int nameID, RenderTextureDescriptor desc, FilterMode filter);
        public void GetTemporaryRT(int nameID, RenderTextureDescriptor desc);
        [FreeFunction("RenderingCommandBuffer_Bindings::GetTemporaryRTArray", HasExplicitThis = True)]
        public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, GraphicsFormat format, int antiAliasing, bool enableRandomWrite, bool useDynamicScale);
        public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, GraphicsFormat format, int antiAliasing, bool enableRandomWrite);
        public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, GraphicsFormat format, int antiAliasing);
        public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, GraphicsFormat format);
        public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing, bool enableRandomWrite);
        public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing);
        public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite);
        public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, RenderTextureFormat format);
        public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter);
        public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer);
        public void GetTemporaryRTArray(int nameID, int width, int height, int slices);
        [FreeFunction("RenderingCommandBuffer_Bindings::ReleaseTemporaryRT", HasExplicitThis = True)]
        public void ReleaseTemporaryRT(int nameID);
        [FreeFunction("RenderingCommandBuffer_Bindings::ClearRenderTarget", HasExplicitThis = True)]
        public void ClearRenderTarget(bool clearDepth, bool clearColor, Color backgroundColor, float depth);
        public void ClearRenderTarget(bool clearDepth, bool clearColor, Color backgroundColor);
        [FreeFunction("RenderingCommandBuffer_Bindings::SetGlobalFloat", HasExplicitThis = True)]
        public void SetGlobalFloat(int nameID, float value);
        [FreeFunction("RenderingCommandBuffer_Bindings::SetGlobalInt", HasExplicitThis = True)]
        public void SetGlobalInt(int nameID, int value);
        [FreeFunction("RenderingCommandBuffer_Bindings::SetGlobalVector", HasExplicitThis = True)]
        public void SetGlobalVector(int nameID, Vector4 value);
        [FreeFunction("RenderingCommandBuffer_Bindings::SetGlobalColor", HasExplicitThis = True)]
        public void SetGlobalColor(int nameID, Color value);
        [FreeFunction("RenderingCommandBuffer_Bindings::SetGlobalMatrix", HasExplicitThis = True)]
        public void SetGlobalMatrix(int nameID, Matrix4x4 value);
        [FreeFunction("RenderingCommandBuffer_Bindings::EnableShaderKeyword", HasExplicitThis = True)]
        public void EnableShaderKeyword(string keyword);
        [FreeFunction("RenderingCommandBuffer_Bindings::DisableShaderKeyword", HasExplicitThis = True)]
        public void DisableShaderKeyword(string keyword);
        [FreeFunction("RenderingCommandBuffer_Bindings::SetViewMatrix", HasExplicitThis = True, ThrowsException = True)]
        public void SetViewMatrix(Matrix4x4 view);
        [FreeFunction("RenderingCommandBuffer_Bindings::SetProjectionMatrix", HasExplicitThis = True, ThrowsException = True)]
        public void SetProjectionMatrix(Matrix4x4 proj);
        [FreeFunction("RenderingCommandBuffer_Bindings::SetViewProjectionMatrices", HasExplicitThis = True, ThrowsException = True)]
        public void SetViewProjectionMatrices(Matrix4x4 view, Matrix4x4 proj);
        [NativeMethod("AddSetGlobalDepthBias")]
        public void SetGlobalDepthBias(float bias, float slopeBias);
        [FreeFunction("RenderingCommandBuffer_Bindings::SetExecutionFlags", HasExplicitThis = True, ThrowsException = True)]
        public void SetExecutionFlags(CommandBufferExecutionFlags flags);
        [FreeFunction("RenderingCommandBuffer_Bindings::SetGlobalFloatArray", HasExplicitThis = True, ThrowsException = True)]
        public void SetGlobalFloatArray(int nameID, float[] values);
        [FreeFunction("RenderingCommandBuffer_Bindings::SetGlobalVectorArray", HasExplicitThis = True, ThrowsException = True)]
        public void SetGlobalVectorArray(int nameID, Vector4[] values);
        [FreeFunction("RenderingCommandBuffer_Bindings::SetGlobalMatrixArray", HasExplicitThis = True, ThrowsException = True)]
        public void SetGlobalMatrixArray(int nameID, Matrix4x4[] values);
        [FreeFunction("RenderingCommandBuffer_Bindings::SetLateLatchProjectionMatrices", HasExplicitThis = True, ThrowsException = True)]
        public void SetLateLatchProjectionMatrices(Matrix4x4[] projectionMat);
        [FreeFunction("RenderingCommandBuffer_Bindings::MarkLateLatchMatrixShaderPropertyID", HasExplicitThis = True)]
        public void MarkLateLatchMatrixShaderPropertyID(CameraLateLatchMatrixType matrixPropertyType, int shaderPropertyID);
        [FreeFunction("RenderingCommandBuffer_Bindings::UnmarkLateLatchMatrix", HasExplicitThis = True)]
        public void UnmarkLateLatchMatrix(CameraLateLatchMatrixType matrixPropertyType);
        [FreeFunction("RenderingCommandBuffer_Bindings::BeginSample", HasExplicitThis = True)]
        public void BeginSample(string name);
        [FreeFunction("RenderingCommandBuffer_Bindings::EndSample", HasExplicitThis = True)]
        public void EndSample(string name);
        public void BeginSample(CustomSampler sampler);
        public void EndSample(CustomSampler sampler);
        [FreeFunction("RenderingCommandBuffer_Bindings::IncrementUpdateCount", HasExplicitThis = True)]
        public void IncrementUpdateCount(RenderTargetIdentifier dest);
        [FreeFunction("RenderingCommandBuffer_Bindings::SetInstanceMultiplier", HasExplicitThis = True)]
        public void SetInstanceMultiplier(uint multiplier);
        public void SetRenderTarget(RenderTargetIdentifier rt);
        public void SetRenderTarget(RenderTargetIdentifier rt, RenderBufferLoadAction loadAction, RenderBufferStoreAction storeAction);
        public void SetRenderTarget(RenderTargetIdentifier rt, RenderBufferLoadAction colorLoadAction, RenderBufferStoreAction colorStoreAction, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction);
        public void SetRenderTarget(RenderTargetIdentifier rt, int mipLevel);
        public void SetRenderTarget(RenderTargetIdentifier rt, int mipLevel, CubemapFace cubemapFace);
        public void SetRenderTarget(RenderTargetIdentifier rt, int mipLevel, CubemapFace cubemapFace, int depthSlice);
        public void SetRenderTarget(RenderTargetIdentifier color, RenderTargetIdentifier depth);
        public void SetRenderTarget(RenderTargetIdentifier color, RenderTargetIdentifier depth, int mipLevel);
        public void SetRenderTarget(RenderTargetIdentifier color, RenderTargetIdentifier depth, int mipLevel, CubemapFace cubemapFace);
        public void SetRenderTarget(RenderTargetIdentifier color, RenderTargetIdentifier depth, int mipLevel, CubemapFace cubemapFace, int depthSlice);
        public void SetRenderTarget(RenderTargetIdentifier color, RenderBufferLoadAction colorLoadAction, RenderBufferStoreAction colorStoreAction, RenderTargetIdentifier depth, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction);
        public void SetRenderTarget(RenderTargetIdentifier[] colors, RenderTargetIdentifier depth);
        public void SetRenderTarget(RenderTargetIdentifier[] colors, RenderTargetIdentifier depth, int mipLevel, CubemapFace cubemapFace, int depthSlice);
        public void SetRenderTarget(RenderTargetBinding binding, int mipLevel, CubemapFace cubemapFace, int depthSlice);
        public void SetRenderTarget(RenderTargetBinding binding);
        [SecuritySafeCritical]
        public void SetComputeBufferData(ComputeBuffer buffer, Array data);
        [SecuritySafeCritical]
        public void SetComputeBufferData<T>(ComputeBuffer buffer, List<T> data) where T : struct;
        [SecuritySafeCritical]
        public void SetComputeBufferData<T>(ComputeBuffer buffer, NativeArray<T> data) where T : struct;
        [SecuritySafeCritical]
        public void SetComputeBufferData(ComputeBuffer buffer, Array data, int managedBufferStartIndex, int graphicsBufferStartIndex, int count);
        [SecuritySafeCritical]
        public void SetComputeBufferData<T>(ComputeBuffer buffer, List<T> data, int managedBufferStartIndex, int graphicsBufferStartIndex, int count) where T : struct;
        [SecuritySafeCritical]
        public void SetComputeBufferData<T>(ComputeBuffer buffer, NativeArray<T> data, int nativeBufferStartIndex, int graphicsBufferStartIndex, int count) where T : struct;
        [FreeFunction(Name = "RenderingCommandBuffer_Bindings::InternalSetComputeBufferCounterValue", HasExplicitThis = True)]
        public void SetComputeBufferCounterValue([NotNull("ArgumentNullException")] ComputeBuffer buffer, uint counterValue);
        public void Dispose();
        public void Release();
        public GraphicsFence CreateAsyncGraphicsFence();
        public GraphicsFence CreateAsyncGraphicsFence(SynchronisationStage stage);
        public GraphicsFence CreateGraphicsFence(GraphicsFenceType fenceType, SynchronisationStageFlags stage);
        public void WaitOnAsyncGraphicsFence(GraphicsFence fence);
        public void WaitOnAsyncGraphicsFence(GraphicsFence fence, SynchronisationStage stage);
        public void WaitOnAsyncGraphicsFence(GraphicsFence fence, SynchronisationStageFlags stage);
        public void SetComputeFloatParam(ComputeShader computeShader, string name, float val);
        public void SetComputeIntParam(ComputeShader computeShader, string name, int val);
        public void SetComputeVectorParam(ComputeShader computeShader, string name, Vector4 val);
        public void SetComputeVectorArrayParam(ComputeShader computeShader, string name, Vector4[] values);
        public void SetComputeMatrixParam(ComputeShader computeShader, string name, Matrix4x4 val);
        public void SetComputeMatrixArrayParam(ComputeShader computeShader, string name, Matrix4x4[] values);
        public void SetComputeFloatParams(ComputeShader computeShader, string name, params float[] values);
        public void SetComputeFloatParams(ComputeShader computeShader, int nameID, params float[] values);
        public void SetComputeIntParams(ComputeShader computeShader, string name, params int[] values);
        public void SetComputeIntParams(ComputeShader computeShader, int nameID, params int[] values);
        public void SetComputeTextureParam(ComputeShader computeShader, int kernelIndex, string name, RenderTargetIdentifier rt);
        public void SetComputeTextureParam(ComputeShader computeShader, int kernelIndex, int nameID, RenderTargetIdentifier rt);
        public void SetComputeTextureParam(ComputeShader computeShader, int kernelIndex, string name, RenderTargetIdentifier rt, int mipLevel);
        public void SetComputeTextureParam(ComputeShader computeShader, int kernelIndex, int nameID, RenderTargetIdentifier rt, int mipLevel);
        public void SetComputeTextureParam(ComputeShader computeShader, int kernelIndex, string name, RenderTargetIdentifier rt, int mipLevel, RenderTextureSubElement element);
        public void SetComputeTextureParam(ComputeShader computeShader, int kernelIndex, int nameID, RenderTargetIdentifier rt, int mipLevel, RenderTextureSubElement element);
        public void SetComputeBufferParam(ComputeShader computeShader, int kernelIndex, int nameID, ComputeBuffer buffer);
        public void SetComputeBufferParam(ComputeShader computeShader, int kernelIndex, string name, ComputeBuffer buffer);
        public void SetComputeBufferParam(ComputeShader computeShader, int kernelIndex, int nameID, GraphicsBuffer buffer);
        public void SetComputeBufferParam(ComputeShader computeShader, int kernelIndex, string name, GraphicsBuffer buffer);
        public void SetComputeConstantBufferParam(ComputeShader computeShader, int nameID, ComputeBuffer buffer, int offset, int size);
        public void SetComputeConstantBufferParam(ComputeShader computeShader, string name, ComputeBuffer buffer, int offset, int size);
        public void SetComputeConstantBufferParam(ComputeShader computeShader, int nameID, GraphicsBuffer buffer, int offset, int size);
        public void SetComputeConstantBufferParam(ComputeShader computeShader, string name, GraphicsBuffer buffer, int offset, int size);
        public void DispatchCompute(ComputeShader computeShader, int kernelIndex, int threadGroupsX, int threadGroupsY, int threadGroupsZ);
        public void DispatchCompute(ComputeShader computeShader, int kernelIndex, ComputeBuffer indirectBuffer, uint argsOffset);
        public void DispatchCompute(ComputeShader computeShader, int kernelIndex, GraphicsBuffer indirectBuffer, uint argsOffset);
        public void BuildRayTracingAccelerationStructure(RayTracingAccelerationStructure accelerationStructure);
        public void BuildRayTracingAccelerationStructure(RayTracingAccelerationStructure accelerationStructure, Vector3 relativeOrigin);
        public void SetRayTracingAccelerationStructure(RayTracingShader rayTracingShader, string name, RayTracingAccelerationStructure rayTracingAccelerationStructure);
        public void SetRayTracingAccelerationStructure(RayTracingShader rayTracingShader, int nameID, RayTracingAccelerationStructure rayTracingAccelerationStructure);
        public void SetRayTracingBufferParam(RayTracingShader rayTracingShader, string name, ComputeBuffer buffer);
        public void SetRayTracingBufferParam(RayTracingShader rayTracingShader, int nameID, ComputeBuffer buffer);
        public void SetRayTracingConstantBufferParam(RayTracingShader rayTracingShader, int nameID, ComputeBuffer buffer, int offset, int size);
        public void SetRayTracingConstantBufferParam(RayTracingShader rayTracingShader, string name, ComputeBuffer buffer, int offset, int size);
        public void SetRayTracingConstantBufferParam(RayTracingShader rayTracingShader, int nameID, GraphicsBuffer buffer, int offset, int size);
        public void SetRayTracingConstantBufferParam(RayTracingShader rayTracingShader, string name, GraphicsBuffer buffer, int offset, int size);
        public void SetRayTracingTextureParam(RayTracingShader rayTracingShader, string name, RenderTargetIdentifier rt);
        public void SetRayTracingTextureParam(RayTracingShader rayTracingShader, int nameID, RenderTargetIdentifier rt);
        public void SetRayTracingFloatParam(RayTracingShader rayTracingShader, string name, float val);
        public void SetRayTracingFloatParam(RayTracingShader rayTracingShader, int nameID, float val);
        public void SetRayTracingFloatParams(RayTracingShader rayTracingShader, string name, params float[] values);
        public void SetRayTracingFloatParams(RayTracingShader rayTracingShader, int nameID, params float[] values);
        public void SetRayTracingIntParam(RayTracingShader rayTracingShader, string name, int val);
        public void SetRayTracingIntParam(RayTracingShader rayTracingShader, int nameID, int val);
        public void SetRayTracingIntParams(RayTracingShader rayTracingShader, string name, params int[] values);
        public void SetRayTracingIntParams(RayTracingShader rayTracingShader, int nameID, params int[] values);
        public void SetRayTracingVectorParam(RayTracingShader rayTracingShader, string name, Vector4 val);
        public void SetRayTracingVectorParam(RayTracingShader rayTracingShader, int nameID, Vector4 val);
        public void SetRayTracingVectorArrayParam(RayTracingShader rayTracingShader, string name, params Vector4[] values);
        public void SetRayTracingVectorArrayParam(RayTracingShader rayTracingShader, int nameID, params Vector4[] values);
        public void SetRayTracingMatrixParam(RayTracingShader rayTracingShader, string name, Matrix4x4 val);
        public void SetRayTracingMatrixParam(RayTracingShader rayTracingShader, int nameID, Matrix4x4 val);
        public void SetRayTracingMatrixArrayParam(RayTracingShader rayTracingShader, string name, params Matrix4x4[] values);
        public void SetRayTracingMatrixArrayParam(RayTracingShader rayTracingShader, int nameID, params Matrix4x4[] values);
        public void DispatchRays(RayTracingShader rayTracingShader, string rayGenName, uint width, uint height, uint depth, Camera camera = null);
        public void GenerateMips(RenderTargetIdentifier rt);
        public void GenerateMips(RenderTexture rt);
        public void ResolveAntiAliasedSurface(RenderTexture rt, RenderTexture target = null);
        public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int submeshIndex, int shaderPass, MaterialPropertyBlock properties);
        public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int submeshIndex, int shaderPass);
        public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int submeshIndex);
        public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material);
        public void DrawRenderer(Renderer renderer, Material material, int submeshIndex, int shaderPass);
        public void DrawRenderer(Renderer renderer, Material material, int submeshIndex);
        public void DrawRenderer(Renderer renderer, Material material);
        public void DrawProcedural(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, int vertexCount, int instanceCount, MaterialPropertyBlock properties);
        public void DrawProcedural(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, int vertexCount, int instanceCount);
        public void DrawProcedural(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, int vertexCount);
        public void DrawProcedural(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, int indexCount, int instanceCount, MaterialPropertyBlock properties);
        public void DrawProcedural(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, int indexCount, int instanceCount);
        public void DrawProcedural(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, int indexCount);
        public void DrawProceduralIndirect(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties);
        public void DrawProceduralIndirect(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset);
        public void DrawProceduralIndirect(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs);
        public void DrawProceduralIndirect(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties);
        public void DrawProceduralIndirect(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset);
        public void DrawProceduralIndirect(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs);
        public void DrawProceduralIndirect(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties);
        public void DrawProceduralIndirect(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset);
        public void DrawProceduralIndirect(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, GraphicsBuffer bufferWithArgs);
        public void DrawProceduralIndirect(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties);
        public void DrawProceduralIndirect(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset);
        public void DrawProceduralIndirect(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, GraphicsBuffer bufferWithArgs);
        public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, int shaderPass, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties);
        public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, int shaderPass, Matrix4x4[] matrices, int count);
        public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, int shaderPass, Matrix4x4[] matrices);
        public void DrawMeshInstancedProcedural(Mesh mesh, int submeshIndex, Material material, int shaderPass, int count, MaterialPropertyBlock properties = null);
        public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, int shaderPass, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties);
        public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, int shaderPass, ComputeBuffer bufferWithArgs, int argsOffset);
        public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, int shaderPass, ComputeBuffer bufferWithArgs);
        public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, int shaderPass, GraphicsBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties);
        public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, int shaderPass, GraphicsBuffer bufferWithArgs, int argsOffset);
        public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, int shaderPass, GraphicsBuffer bufferWithArgs);
        public void DrawOcclusionMesh(RectInt normalizedCamViewport);
        public void SetRandomWriteTarget(int index, RenderTargetIdentifier rt);
        public void SetRandomWriteTarget(int index, ComputeBuffer buffer, bool preserveCounterValue);
        public void SetRandomWriteTarget(int index, ComputeBuffer buffer);
        public void SetRandomWriteTarget(int index, GraphicsBuffer buffer, bool preserveCounterValue);
        public void SetRandomWriteTarget(int index, GraphicsBuffer buffer);
        public void CopyCounterValue(ComputeBuffer src, ComputeBuffer dst, uint dstOffsetBytes);
        public void CopyCounterValue(GraphicsBuffer src, ComputeBuffer dst, uint dstOffsetBytes);
        public void CopyCounterValue(ComputeBuffer src, GraphicsBuffer dst, uint dstOffsetBytes);
        public void CopyCounterValue(GraphicsBuffer src, GraphicsBuffer dst, uint dstOffsetBytes);
        public void CopyTexture(RenderTargetIdentifier src, RenderTargetIdentifier dst);
        public void CopyTexture(RenderTargetIdentifier src, int srcElement, RenderTargetIdentifier dst, int dstElement);
        public void CopyTexture(RenderTargetIdentifier src, int srcElement, int srcMip, RenderTargetIdentifier dst, int dstElement, int dstMip);
        public void CopyTexture(RenderTargetIdentifier src, int srcElement, int srcMip, int srcX, int srcY, int srcWidth, int srcHeight, RenderTargetIdentifier dst, int dstElement, int dstMip, int dstX, int dstY);
        public void Blit(Texture source, RenderTargetIdentifier dest);
        public void Blit(Texture source, RenderTargetIdentifier dest, Vector2 scale, Vector2 offset);
        public void Blit(Texture source, RenderTargetIdentifier dest, Material mat);
        public void Blit(Texture source, RenderTargetIdentifier dest, Material mat, int pass);
        public void Blit(RenderTargetIdentifier source, RenderTargetIdentifier dest);
        public void Blit(RenderTargetIdentifier source, RenderTargetIdentifier dest, Vector2 scale, Vector2 offset);
        public void Blit(RenderTargetIdentifier source, RenderTargetIdentifier dest, Material mat);
        public void Blit(RenderTargetIdentifier source, RenderTargetIdentifier dest, Material mat, int pass);
        public void Blit(RenderTargetIdentifier source, RenderTargetIdentifier dest, int sourceDepthSlice, int destDepthSlice);
        public void Blit(RenderTargetIdentifier source, RenderTargetIdentifier dest, Vector2 scale, Vector2 offset, int sourceDepthSlice, int destDepthSlice);
        public void Blit(RenderTargetIdentifier source, RenderTargetIdentifier dest, Material mat, int pass, int destDepthSlice);
        public void SetGlobalFloat(string name, float value);
        public void SetGlobalInt(string name, int value);
        public void SetGlobalVector(string name, Vector4 value);
        public void SetGlobalColor(string name, Color value);
        public void SetGlobalMatrix(string name, Matrix4x4 value);
        public void SetGlobalFloatArray(string propertyName, List<float> values);
        public void SetGlobalFloatArray(int nameID, List<float> values);
        public void SetGlobalFloatArray(string propertyName, float[] values);
        public void SetGlobalVectorArray(string propertyName, List<Vector4> values);
        public void SetGlobalVectorArray(int nameID, List<Vector4> values);
        public void SetGlobalVectorArray(string propertyName, Vector4[] values);
        public void SetGlobalMatrixArray(string propertyName, List<Matrix4x4> values);
        public void SetGlobalMatrixArray(int nameID, List<Matrix4x4> values);
        public void SetGlobalMatrixArray(string propertyName, Matrix4x4[] values);
        public void SetGlobalTexture(string name, RenderTargetIdentifier value);
        public void SetGlobalTexture(int nameID, RenderTargetIdentifier value);
        public void SetGlobalTexture(string name, RenderTargetIdentifier value, RenderTextureSubElement element);
        public void SetGlobalTexture(int nameID, RenderTargetIdentifier value, RenderTextureSubElement element);
        public void SetGlobalBuffer(string name, ComputeBuffer value);
        public void SetGlobalBuffer(int nameID, ComputeBuffer value);
        public void SetGlobalBuffer(string name, GraphicsBuffer value);
        public void SetGlobalBuffer(int nameID, GraphicsBuffer value);
        public void SetGlobalConstantBuffer(ComputeBuffer buffer, int nameID, int offset, int size);
        public void SetGlobalConstantBuffer(ComputeBuffer buffer, string name, int offset, int size);
        public void SetGlobalConstantBuffer(GraphicsBuffer buffer, int nameID, int offset, int size);
        public void SetGlobalConstantBuffer(GraphicsBuffer buffer, string name, int offset, int size);
        public void SetShadowSamplingMode(RenderTargetIdentifier shadowmap, ShadowSamplingMode mode);
        public void SetSinglePassStereo(SinglePassStereoMode mode);
        public void IssuePluginEvent(IntPtr callback, int eventID);
        public void IssuePluginEventAndData(IntPtr callback, int eventID, IntPtr data);
        public void IssuePluginCustomBlit(IntPtr callback, uint command, RenderTargetIdentifier source, RenderTargetIdentifier dest, uint commandParam, uint commandFlags);
        [Obsolete("Use IssuePluginCustomTextureUpdateV2 to register TextureUpdate callbacks instead. Callbacks will be passed event IDs kUnityRenderingExtEventUpdateTextureBeginV2 or kUnityRenderingExtEventUpdateTextureEndV2, and data parameter of type UnityRenderingExtTextureUpdateParamsV2.", False)]
        public void IssuePluginCustomTextureUpdate(IntPtr callback, Texture targetTexture, uint userData);
        [Obsolete("Use IssuePluginCustomTextureUpdateV2 to register TextureUpdate callbacks instead. Callbacks will be passed event IDs kUnityRenderingExtEventUpdateTextureBeginV2 or kUnityRenderingExtEventUpdateTextureEndV2, and data parameter of type UnityRenderingExtTextureUpdateParamsV2.", False)]
        public void IssuePluginCustomTextureUpdateV1(IntPtr callback, Texture targetTexture, uint userData);
        public void IssuePluginCustomTextureUpdateV2(IntPtr callback, Texture targetTexture, uint userData);
        public void ProcessVTFeedback(RenderTargetIdentifier rt, IntPtr resolver, int slice, int x, int width, int y, int height, int mip);
        [Obsolete("CommandBuffer.CreateGPUFence has been deprecated. Use CreateGraphicsFence instead (UnityUpgradable) -> CreateAsyncGraphicsFence(*)", False)]
        public GPUFence CreateGPUFence(SynchronisationStage stage);
        [Obsolete("CommandBuffer.CreateGPUFence has been deprecated. Use CreateGraphicsFence instead (UnityUpgradable) -> CreateAsyncGraphicsFence()", False)]
        public GPUFence CreateGPUFence();
        [Obsolete("CommandBuffer.WaitOnGPUFence has been deprecated. Use WaitOnGraphicsFence instead (UnityUpgradable) -> WaitOnAsyncGraphicsFence(*)", False)]
        public void WaitOnGPUFence(GPUFence fence, SynchronisationStage stage);
        [Obsolete("CommandBuffer.WaitOnGPUFence has been deprecated. Use WaitOnGraphicsFence instead (UnityUpgradable) -> WaitOnAsyncGraphicsFence(*)", False)]
        public void WaitOnGPUFence(GPUFence fence);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Rendering
{
    [NativeHeader("Runtime/Export/Graphics/RenderingCommandBufferExtensions.bindings.h")]
    [UsedByNativeCode]
    public static class CommandBufferExtensions
    {
        [NativeConditional("UNITY_XBOXONE || UNITY_GAMECORE_XBOXONE")]
        public static void SwitchIntoFastMemory(this CommandBuffer cmd, RenderTargetIdentifier rid, FastMemoryFlags fastMemoryFlags, float residency, bool copyContents);
        [NativeConditional("UNITY_XBOXONE || UNITY_GAMECORE_XBOXONE")]
        public static void SwitchOutOfFastMemory(this CommandBuffer cmd, RenderTargetIdentifier rid, bool copyContents);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Rendering
{
    [NativeHeader("Runtime/Graphics/DrawSplashScreenAndWatermarks.h")]
    public class SplashScreen
    {
        public SplashScreen();

        public static bool isFinished { get; }

        [FreeFunction("BeginSplashScreen_Binding")]
        public static void Begin();
        public static void Stop(StopBehavior stopBehavior);
        [FreeFunction("DrawSplashScreen_Binding")]
        public static void Draw();

        public enum StopBehavior
        {
            StopImmediate = 0,
            FadeOut = 1
        }
    }
}
using System;
using System.Reflection;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Rendering
{
    [NativeHeader("Runtime/Export/Math/SphericalHarmonicsL2.bindings.h")]
    [UsedByNativeCode]
    [DefaultMember("Item")]
    public struct SphericalHarmonicsL2 : IEquatable<SphericalHarmonicsL2>
    {
        public float this[int rgb, int coefficient] { get; set; }

        public void Clear();
        public void AddAmbientLight(Color color);
        public void AddDirectionalLight(Vector3 direction, Color color, float intensity);
        public void Evaluate(Vector3[] directions, Color[] results);
        public override int GetHashCode();
        public override bool Equals(object other);
        public bool Equals(SphericalHarmonicsL2 other);

        public static SphericalHarmonicsL2 operator *(SphericalHarmonicsL2 lhs, float rhs);
        public static SphericalHarmonicsL2 operator *(float lhs, SphericalHarmonicsL2 rhs);
        public static SphericalHarmonicsL2 operator +(SphericalHarmonicsL2 lhs, SphericalHarmonicsL2 rhs);
        public static bool operator ==(SphericalHarmonicsL2 lhs, SphericalHarmonicsL2 rhs);
        public static bool operator !=(SphericalHarmonicsL2 lhs, SphericalHarmonicsL2 rhs);
    }
}
namespace UnityEngine.Rendering
{
    public struct BatchVisibility
    {
        public readonly int offset;
        public readonly int instancesCount;
        public int visibleCount;
    }
}
using System;
using Unity.Collections;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Rendering
{
    [UsedByNativeCode]
    [NativeHeader("Runtime/Camera/BatchRendererGroup.h")]
    public struct BatchCullingContext
    {
        public readonly NativeArray<Plane> cullingPlanes;
        public NativeArray<BatchVisibility> batchVisibility;
        public NativeArray<int> visibleIndices;
        public NativeArray<int> visibleIndicesY;
        public readonly LODParameters lodParameters;
        public readonly Matrix4x4 cullingMatrix;
        public readonly float nearPlane;

        [Obsolete("For internal BatchRendererGroup use only")]
        public BatchCullingContext(NativeArray<Plane> inCullingPlanes, NativeArray<BatchVisibility> inOutBatchVisibility, NativeArray<int> outVisibleIndices, LODParameters inLodParameters);
        [Obsolete("For internal BatchRendererGroup use only")]
        public BatchCullingContext(NativeArray<Plane> inCullingPlanes, NativeArray<BatchVisibility> inOutBatchVisibility, NativeArray<int> outVisibleIndices, LODParameters inLodParameters, Matrix4x4 inCullingMatrix, float inNearPlane);
    }
}
using System;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Rendering
{
    [NativeHeader("Runtime/Math/Matrix4x4.h")]
    [RequiredByNativeCode]
    [NativeHeader("Runtime/Camera/BatchRendererGroup.h")]
    public class BatchRendererGroup : IDisposable
    {
        public BatchRendererGroup(OnPerformCulling cullingCallback);

        public void Dispose();
        public int AddBatch(Mesh mesh, int subMeshIndex, Material material, int layer, ShadowCastingMode castShadows, bool receiveShadows, bool invertCulling, Bounds bounds, int instanceCount, MaterialPropertyBlock customProps, GameObject associatedSceneObject);
        public int AddBatch(Mesh mesh, int subMeshIndex, Material material, int layer, ShadowCastingMode castShadows, bool receiveShadows, bool invertCulling, Bounds bounds, int instanceCount, MaterialPropertyBlock customProps, GameObject associatedSceneObject, ulong sceneCullingMask);
        public int AddBatch(Mesh mesh, int subMeshIndex, Material material, int layer, ShadowCastingMode castShadows, bool receiveShadows, bool invertCulling, Bounds bounds, int instanceCount, MaterialPropertyBlock customProps, GameObject associatedSceneObject, ulong sceneCullingMask, uint renderingLayerMask);
        public void SetBatchFlags(int batchIndex, ulong flags);
        public void SetBatchPropertyMetadata(int batchIndex, NativeArray<int> cbufferLengths, NativeArray<int> cbufferMetadata);
        public void SetInstancingData(int batchIndex, int instanceCount, MaterialPropertyBlock customProps);
        public NativeArray<Matrix4x4> GetBatchMatrices(int batchIndex);
        public NativeArray<int> GetBatchScalarArrayInt(int batchIndex, string propertyName);
        public NativeArray<float> GetBatchScalarArray(int batchIndex, string propertyName);
        public NativeArray<int> GetBatchVectorArrayInt(int batchIndex, string propertyName);
        public NativeArray<Vector4> GetBatchVectorArray(int batchIndex, string propertyName);
        public NativeArray<Matrix4x4> GetBatchMatrixArray(int batchIndex, string propertyName);
        public NativeArray<int> GetBatchScalarArrayInt(int batchIndex, int propertyName);
        public NativeArray<float> GetBatchScalarArray(int batchIndex, int propertyName);
        public NativeArray<int> GetBatchVectorArrayInt(int batchIndex, int propertyName);
        public NativeArray<Vector4> GetBatchVectorArray(int batchIndex, int propertyName);
        public NativeArray<Matrix4x4> GetBatchMatrixArray(int batchIndex, int propertyName);
        public void SetBatchBounds(int batchIndex, Bounds bounds);
        public int GetNumBatches();
        public void RemoveBatch(int index);
        public void EnableVisibleIndicesYArray(bool enabled);

        public delegate JobHandle OnPerformCulling(BatchRendererGroup rendererGroup, BatchCullingContext cullingContext);
    }
}
using System;
using UnityEngine.Experimental.Rendering;

namespace UnityEngine.Rendering
{
    public struct AttachmentDescriptor : IEquatable<AttachmentDescriptor>
    {
        public AttachmentDescriptor(GraphicsFormat format);
        public AttachmentDescriptor(RenderTextureFormat format);
        public AttachmentDescriptor(RenderTextureFormat format, RenderTargetIdentifier target, bool loadExistingContents = False, bool storeResults = False, bool resolve = False);

        public RenderBufferLoadAction loadAction { get; set; }
        public RenderBufferStoreAction storeAction { get; set; }
        public GraphicsFormat graphicsFormat { get; set; }
        public RenderTextureFormat format { get; set; }
        public RenderTargetIdentifier loadStoreTarget { get; set; }
        public RenderTargetIdentifier resolveTarget { get; set; }
        public Color clearColor { get; set; }
        public float clearDepth { get; set; }
        public uint clearStencil { get; set; }

        public void ConfigureTarget(RenderTargetIdentifier target, bool loadExistingContents, bool storeResults);
        public void ConfigureResolveTarget(RenderTargetIdentifier target);
        public void ConfigureClear(Color clearColor, float clearDepth = 1, uint clearStencil = 0);
        public bool Equals(AttachmentDescriptor other);
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static bool operator ==(AttachmentDescriptor left, AttachmentDescriptor right);
        public static bool operator !=(AttachmentDescriptor left, AttachmentDescriptor right);
    }
}
using System;

namespace UnityEngine.Rendering
{
    public struct BlendState : IEquatable<BlendState>
    {
        public BlendState(bool separateMRTBlend = False, bool alphaToMask = False);

        public static BlendState defaultValue { get; }
        public bool separateMRTBlendStates { get; set; }
        public bool alphaToMask { get; set; }
        public RenderTargetBlendState blendState0 { get; set; }
        public RenderTargetBlendState blendState1 { get; set; }
        public RenderTargetBlendState blendState2 { get; set; }
        public RenderTargetBlendState blendState3 { get; set; }
        public RenderTargetBlendState blendState4 { get; set; }
        public RenderTargetBlendState blendState5 { get; set; }
        public RenderTargetBlendState blendState6 { get; set; }
        public RenderTargetBlendState blendState7 { get; set; }

        public bool Equals(BlendState other);
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static bool operator ==(BlendState left, BlendState right);
        public static bool operator !=(BlendState left, BlendState right);
    }
}
using System;
using System.Runtime.CompilerServices;
using UnityEngine.Scripting;

namespace UnityEngine.Rendering
{
    [UsedByNativeCode]
    public struct CameraProperties : IEquatable<CameraProperties>
    {
        public Plane GetShadowCullingPlane(int index);
        public void SetShadowCullingPlane(int index, Plane plane);
        public Plane GetCameraCullingPlane(int index);
        public void SetCameraCullingPlane(int index, Plane plane);
        public bool Equals(CameraProperties other);
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static bool operator ==(CameraProperties left, CameraProperties right);
        public static bool operator !=(CameraProperties left, CameraProperties right);

        [CompilerGenerated]
        [UnsafeValueType]
        public struct <m_ShadowCullPlanes>e__FixedBuffer
        {
            public byte FixedElementField;
        }
        [CompilerGenerated]
        [UnsafeValueType]
        public struct <m_CameraCullPlanes>e__FixedBuffer
        {
            public byte FixedElementField;
        }
        [CompilerGenerated]
        [UnsafeValueType]
        public struct <layerCullDistances>e__FixedBuffer
        {
            public float FixedElementField;
        }
    }
}
using System;

namespace UnityEngine.Rendering
{
    [Flags]
    public enum CullingOptions
    {
        None = 0,
        ForceEvenIfCameraIsNotActive = 1,
        OcclusionCull = 2,
        NeedsLighting = 4,
        NeedsReflectionProbes = 8,
        Stereo = 16,
        DisablePerObjectCulling = 32,
        ShadowCasters = 64
    }
}
using System;
using System.Runtime.CompilerServices;
using UnityEngine.Scripting;

namespace UnityEngine.Rendering
{
    [UsedByNativeCode]
    public struct ScriptableCullingParameters : IEquatable<ScriptableCullingParameters>
    {
        public static readonly int maximumCullingPlaneCount;
        public static readonly int layerCount;

        public int maximumVisibleLights { get; set; }
        public int cullingPlaneCount { get; set; }
        public bool isOrthographic { get; set; }
        public LODParameters lodParameters { get; set; }
        public uint cullingMask { get; set; }
        public Matrix4x4 cullingMatrix { get; set; }
        public Vector3 origin { get; set; }
        public float shadowDistance { get; set; }
        public CullingOptions cullingOptions { get; set; }
        public ReflectionProbeSortingCriteria reflectionProbeSortingCriteria { get; set; }
        public CameraProperties cameraProperties { get; set; }
        public Matrix4x4 stereoViewMatrix { get; set; }
        public Matrix4x4 stereoProjectionMatrix { get; set; }
        public float stereoSeparationDistance { get; set; }
        public float accurateOcclusionThreshold { get; set; }
        public int maximumPortalCullingJobs { get; set; }
        public static int cullingJobsLowerLimit { get; }
        public static int cullingJobsUpperLimit { get; }

        public float GetLayerCullingDistance(int layerIndex);
        public void SetLayerCullingDistance(int layerIndex, float distance);
        public Plane GetCullingPlane(int index);
        public void SetCullingPlane(int index, Plane plane);
        public bool Equals(ScriptableCullingParameters other);
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static bool operator ==(ScriptableCullingParameters left, ScriptableCullingParameters right);
        public static bool operator !=(ScriptableCullingParameters left, ScriptableCullingParameters right);

        [CompilerGenerated]
        [UnsafeValueType]
        public struct <m_CullingPlanes>e__FixedBuffer
        {
            public byte FixedElementField;
        }
        [CompilerGenerated]
        [UnsafeValueType]
        public struct <m_LayerFarCullDistances>e__FixedBuffer
        {
            public float FixedElementField;
        }
    }
}
using System;
using Unity.Collections;
using UnityEngine.Bindings;

namespace UnityEngine.Rendering
{
    [NativeHeader("Runtime/Graphics/ScriptableRenderLoop/ScriptableCulling.h")]
    [NativeHeader("Runtime/Export/RenderPipeline/ScriptableRenderPipeline.bindings.h")]
    [NativeHeader("Runtime/Scripting/ScriptingCommonStructDefinitions.h")]
    public struct CullingResults : IEquatable<CullingResults>
    {
        public NativeArray<VisibleLight> visibleLights { get; }
        public NativeArray<VisibleLight> visibleOffscreenVertexLights { get; }
        public NativeArray<VisibleReflectionProbe> visibleReflectionProbes { get; }
        public int lightIndexCount { get; }
        public int reflectionProbeIndexCount { get; }
        public int lightAndReflectionProbeIndexCount { get; }

        public void FillLightAndReflectionProbeIndices(ComputeBuffer computeBuffer);
        public void FillLightAndReflectionProbeIndices(GraphicsBuffer buffer);
        public NativeArray<int> GetLightIndexMap(Allocator allocator);
        public void SetLightIndexMap(NativeArray<int> lightIndexMap);
        public NativeArray<int> GetReflectionProbeIndexMap(Allocator allocator);
        public void SetReflectionProbeIndexMap(NativeArray<int> lightIndexMap);
        public bool GetShadowCasterBounds(int lightIndex, out Bounds outBounds);
        public bool ComputeSpotShadowMatricesAndCullingPrimitives(int activeLightIndex, out Matrix4x4 viewMatrix, out Matrix4x4 projMatrix, out ShadowSplitData shadowSplitData);
        public bool ComputePointShadowMatricesAndCullingPrimitives(int activeLightIndex, CubemapFace cubemapFace, float fovBias, out Matrix4x4 viewMatrix, out Matrix4x4 projMatrix, out ShadowSplitData shadowSplitData);
        public bool ComputeDirectionalShadowMatricesAndCullingPrimitives(int activeLightIndex, int splitIndex, int splitCount, Vector3 splitRatio, int shadowResolution, float shadowNearPlaneOffset, out Matrix4x4 viewMatrix, out Matrix4x4 projMatrix, out ShadowSplitData shadowSplitData);
        public bool Equals(CullingResults other);
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static bool operator ==(CullingResults left, CullingResults right);
        public static bool operator !=(CullingResults left, CullingResults right);
    }
}
using System;

namespace UnityEngine.Rendering
{
    public struct DepthState : IEquatable<DepthState>
    {
        public DepthState(bool writeEnabled = True, CompareFunction compareFunction = Less);

        public static DepthState defaultValue { get; }
        public bool writeEnabled { get; set; }
        public CompareFunction compareFunction { get; set; }

        public bool Equals(DepthState other);
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static bool operator ==(DepthState left, DepthState right);
        public static bool operator !=(DepthState left, DepthState right);
    }
}
using System;
using System.Runtime.CompilerServices;

namespace UnityEngine.Rendering
{
    public struct DrawingSettings : IEquatable<DrawingSettings>
    {
        public static readonly int maxShaderPasses;

        public DrawingSettings(ShaderTagId shaderPassName, SortingSettings sortingSettings);

        public SortingSettings sortingSettings { get; set; }
        public PerObjectData perObjectData { get; set; }
        public bool enableDynamicBatching { get; set; }
        public bool enableInstancing { get; set; }
        public Material overrideMaterial { get; set; }
        public int overrideMaterialPassIndex { get; set; }
        public int mainLightIndex { get; set; }

        public ShaderTagId GetShaderPassName(int index);
        public void SetShaderPassName(int index, ShaderTagId shaderPassName);
        public bool Equals(DrawingSettings other);
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static bool operator ==(DrawingSettings left, DrawingSettings right);
        public static bool operator !=(DrawingSettings left, DrawingSettings right);

        [UnsafeValueType]
        [CompilerGenerated]
        public struct <shaderPassNames>e__FixedBuffer
        {
            public int FixedElementField;
        }
    }
}
using System;
using UnityEngine.Internal;

namespace UnityEngine.Rendering
{
    public struct FilteringSettings : IEquatable<FilteringSettings>
    {
        public FilteringSettings([DefaultValue("RenderQueueRange.all")] RenderQueueRange? renderQueueRange = null, int layerMask = -1, uint renderingLayerMask = 4294967295, int excludeMotionVectorObjects = 0);

        public static FilteringSettings defaultValue { get; }
        public RenderQueueRange renderQueueRange { get; set; }
        public int layerMask { get; set; }
        public uint renderingLayerMask { get; set; }
        public bool excludeMotionVectorObjects { get; set; }
        public SortingLayerRange sortingLayerRange { get; set; }

        public bool Equals(FilteringSettings other);
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static bool operator ==(FilteringSettings left, FilteringSettings right);
        public static bool operator !=(FilteringSettings left, FilteringSettings right);
    }
}
namespace UnityEngine.Rendering
{
    public enum GizmoSubset
    {
        PreImageEffects = 0,
        PostImageEffects = 1
    }
}
using System;

namespace UnityEngine.Rendering
{
    public struct LODParameters : IEquatable<LODParameters>
    {
        public bool isOrthographic { get; set; }
        public Vector3 cameraPosition { get; set; }
        public float fieldOfView { get; set; }
        public float orthoSize { get; set; }
        public int cameraPixelHeight { get; set; }

        public bool Equals(LODParameters other);
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static bool operator ==(LODParameters left, LODParameters right);
        public static bool operator !=(LODParameters left, LODParameters right);
    }
}
using System;

namespace UnityEngine.Rendering
{
    [Flags]
    public enum PerObjectData
    {
        None = 0,
        LightProbe = 1,
        ReflectionProbes = 2,
        LightProbeProxyVolume = 4,
        Lightmaps = 8,
        LightData = 16,
        MotionVectors = 32,
        LightIndices = 64,
        ReflectionProbeData = 128,
        OcclusionProbe = 256,
        OcclusionProbeProxyVolume = 512,
        ShadowMask = 1024
    }
}
using System;

namespace UnityEngine.Rendering
{
    public struct RasterState : IEquatable<RasterState>
    {
        public static readonly RasterState defaultValue;

        public RasterState(CullMode cullingMode = Back, int offsetUnits = 0, float offsetFactor = 0, bool depthClip = True);

        public CullMode cullingMode { get; set; }
        public bool depthClip { get; set; }
        public bool conservative { get; set; }
        public int offsetUnits { get; set; }
        public float offsetFactor { get; set; }

        public bool Equals(RasterState other);
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static bool operator ==(RasterState left, RasterState right);
        public static bool operator !=(RasterState left, RasterState right);
    }
}
namespace UnityEngine.Rendering
{
    public enum ReflectionProbeSortingCriteria
    {
        None = 0,
        Importance = 1,
        Size = 2,
        ImportanceThenSize = 3
    }
}
using System.Collections.Generic;

namespace UnityEngine.Rendering
{
    public abstract class RenderPipeline
    {
        protected RenderPipeline();

        public bool disposed { get; }

        protected abstract void Render(ScriptableRenderContext context, Camera[] cameras);
        protected virtual void ProcessRenderRequests(ScriptableRenderContext context, Camera camera, List<Camera.RenderRequest> renderRequests);
        protected static void BeginFrameRendering(ScriptableRenderContext context, Camera[] cameras);
        protected static void BeginCameraRendering(ScriptableRenderContext context, Camera camera);
        protected static void EndFrameRendering(ScriptableRenderContext context, Camera[] cameras);
        protected static void EndCameraRendering(ScriptableRenderContext context, Camera camera);
        protected virtual void Dispose(bool disposing);
    }
}
namespace UnityEngine.Rendering
{
    public abstract class RenderPipelineAsset : ScriptableObject
    {
        protected RenderPipelineAsset();

        public virtual int terrainBrushPassIndex { get; }
        public virtual string[] renderingLayerMaskNames { get; }
        public virtual Material defaultMaterial { get; }
        public virtual Shader autodeskInteractiveShader { get; }
        public virtual Shader autodeskInteractiveTransparentShader { get; }
        public virtual Shader autodeskInteractiveMaskedShader { get; }
        public virtual Shader terrainDetailLitShader { get; }
        public virtual Shader terrainDetailGrassShader { get; }
        public virtual Shader terrainDetailGrassBillboardShader { get; }
        public virtual Material defaultParticleMaterial { get; }
        public virtual Material defaultLineMaterial { get; }
        public virtual Material defaultTerrainMaterial { get; }
        public virtual Material defaultUIMaterial { get; }
        public virtual Material defaultUIOverdrawMaterial { get; }
        public virtual Material defaultUIETC1SupportedMaterial { get; }
        public virtual Material default2DMaterial { get; }
        public virtual Shader defaultShader { get; }
        public virtual Shader defaultSpeedTree7Shader { get; }
        public virtual Shader defaultSpeedTree8Shader { get; }

        protected abstract RenderPipeline CreatePipeline();
        protected virtual void OnValidate();
        protected virtual void OnDisable();
    }
}
using System;

namespace UnityEngine.Rendering
{
    public static class RenderPipelineManager
    {
        public static RenderPipeline currentPipeline { get; }

        public static event Action<ScriptableRenderContext, Camera[]> beginFrameRendering;
        public static event Action<ScriptableRenderContext, Camera> beginCameraRendering;
        public static event Action<ScriptableRenderContext, Camera[]> endFrameRendering;
        public static event Action<ScriptableRenderContext, Camera> endCameraRendering;
    }
}
using System;

namespace UnityEngine.Rendering
{
    public struct RenderQueueRange : IEquatable<RenderQueueRange>
    {
        public static readonly int minimumBound;
        public static readonly int maximumBound;

        public RenderQueueRange(int lowerBound, int upperBound);

        public static RenderQueueRange all { get; }
        public static RenderQueueRange opaque { get; }
        public static RenderQueueRange transparent { get; }
        public int lowerBound { get; set; }
        public int upperBound { get; set; }

        public bool Equals(RenderQueueRange other);
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static bool operator ==(RenderQueueRange left, RenderQueueRange right);
        public static bool operator !=(RenderQueueRange left, RenderQueueRange right);
    }
}
using System;

namespace UnityEngine.Rendering
{
    public struct RenderStateBlock : IEquatable<RenderStateBlock>
    {
        public RenderStateBlock(RenderStateMask mask);

        public BlendState blendState { get; set; }
        public RasterState rasterState { get; set; }
        public DepthState depthState { get; set; }
        public StencilState stencilState { get; set; }
        public int stencilReference { get; set; }
        public RenderStateMask mask { get; set; }

        public bool Equals(RenderStateBlock other);
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static bool operator ==(RenderStateBlock left, RenderStateBlock right);
        public static bool operator !=(RenderStateBlock left, RenderStateBlock right);
    }
}
using System;

namespace UnityEngine.Rendering
{
    [Flags]
    public enum RenderStateMask
    {
        Nothing = 0,
        Blend = 1,
        Raster = 2,
        Depth = 4,
        Stencil = 8,
        Everything = 15
    }
}
using System;

namespace UnityEngine.Rendering
{
    public struct RenderTargetBlendState : IEquatable<RenderTargetBlendState>
    {
        public RenderTargetBlendState(ColorWriteMask writeMask = All, BlendMode sourceColorBlendMode = One, BlendMode destinationColorBlendMode = Zero, BlendMode sourceAlphaBlendMode = One, BlendMode destinationAlphaBlendMode = Zero, BlendOp colorBlendOperation = Add, BlendOp alphaBlendOperation = Add);

        public static RenderTargetBlendState defaultValue { get; }
        public ColorWriteMask writeMask { get; set; }
        public BlendMode sourceColorBlendMode { get; set; }
        public BlendMode destinationColorBlendMode { get; set; }
        public BlendMode sourceAlphaBlendMode { get; set; }
        public BlendMode destinationAlphaBlendMode { get; set; }
        public BlendOp colorBlendOperation { get; set; }
        public BlendOp alphaBlendOperation { get; set; }

        public bool Equals(RenderTargetBlendState other);
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static bool operator ==(RenderTargetBlendState left, RenderTargetBlendState right);
        public static bool operator !=(RenderTargetBlendState left, RenderTargetBlendState right);
    }
}
using System;

namespace UnityEngine.Rendering
{
    public struct ScopedRenderPass : IDisposable
    {
        public void Dispose();
    }
}
using System;

namespace UnityEngine.Rendering
{
    public struct ScopedSubPass : IDisposable
    {
        public void Dispose();
    }
}
using System;
using Unity.Collections;
using UnityEngine.Bindings;

namespace UnityEngine.Rendering
{
    [NativeType("Runtime/Graphics/ScriptableRenderLoop/ScriptableRenderContext.h")]
    [NativeHeader("Runtime/Graphics/ScriptableRenderLoop/ScriptableDrawRenderersUtility.h")]
    [NativeHeader("Runtime/Export/RenderPipeline/ScriptableRenderContext.bindings.h")]
    [NativeHeader("Runtime/Export/RenderPipeline/ScriptableRenderPipeline.bindings.h")]
    [NativeHeader("Modules/UI/Canvas.h")]
    [NativeHeader("Modules/UI/CanvasManager.h")]
    public struct ScriptableRenderContext : IEquatable<ScriptableRenderContext>
    {
        [FreeFunction("UI::GetCanvasManager().EmitWorldGeometryForSceneView")]
        public static void EmitWorldGeometryForSceneView(Camera cullingCamera);
        [FreeFunction("UI::GetCanvasManager().EmitGeometryForCamera")]
        public static void EmitGeometryForCamera(Camera camera);
        public void BeginRenderPass(int width, int height, int samples, NativeArray<AttachmentDescriptor> attachments, int depthAttachmentIndex = -1);
        public ScopedRenderPass BeginScopedRenderPass(int width, int height, int samples, NativeArray<AttachmentDescriptor> attachments, int depthAttachmentIndex = -1);
        public void BeginSubPass(NativeArray<int> colors, NativeArray<int> inputs, bool isDepthReadOnly, bool isStencilReadOnly);
        public void BeginSubPass(NativeArray<int> colors, NativeArray<int> inputs, bool isDepthStencilReadOnly = False);
        public void BeginSubPass(NativeArray<int> colors, bool isDepthReadOnly, bool isStencilReadOnly);
        public void BeginSubPass(NativeArray<int> colors, bool isDepthStencilReadOnly = False);
        public ScopedSubPass BeginScopedSubPass(NativeArray<int> colors, NativeArray<int> inputs, bool isDepthReadOnly, bool isStencilReadOnly);
        public ScopedSubPass BeginScopedSubPass(NativeArray<int> colors, NativeArray<int> inputs, bool isDepthStencilReadOnly = False);
        public ScopedSubPass BeginScopedSubPass(NativeArray<int> colors, bool isDepthReadOnly, bool isStencilReadOnly);
        public ScopedSubPass BeginScopedSubPass(NativeArray<int> colors, bool isDepthStencilReadOnly = False);
        public void EndSubPass();
        public void EndRenderPass();
        public void Submit();
        public void DrawRenderers(CullingResults cullingResults, ref DrawingSettings drawingSettings, ref FilteringSettings filteringSettings);
        public void DrawRenderers(CullingResults cullingResults, ref DrawingSettings drawingSettings, ref FilteringSettings filteringSettings, ref RenderStateBlock stateBlock);
        public void DrawRenderers(CullingResults cullingResults, ref DrawingSettings drawingSettings, ref FilteringSettings filteringSettings, NativeArray<ShaderTagId> renderTypes, NativeArray<RenderStateBlock> stateBlocks);
        public void DrawRenderers(CullingResults cullingResults, ref DrawingSettings drawingSettings, ref FilteringSettings filteringSettings, ShaderTagId tagName, bool isPassTagName, NativeArray<ShaderTagId> tagValues, NativeArray<RenderStateBlock> stateBlocks);
        public void DrawShadows(ref ShadowDrawingSettings settings);
        public void ExecuteCommandBuffer(CommandBuffer commandBuffer);
        public void ExecuteCommandBufferAsync(CommandBuffer commandBuffer, ComputeQueueType queueType);
        public void SetupCameraProperties(Camera camera, bool stereoSetup = False);
        public void SetupCameraProperties(Camera camera, bool stereoSetup, int eye);
        public void StereoEndRender(Camera camera);
        public void StereoEndRender(Camera camera, int eye);
        public void StereoEndRender(Camera camera, int eye, bool isFinalPass);
        public void StartMultiEye(Camera camera);
        public void StartMultiEye(Camera camera, int eye);
        public void StopMultiEye(Camera camera);
        public void DrawSkybox(Camera camera);
        public void InvokeOnRenderObjectCallback();
        public void DrawGizmos(Camera camera, GizmoSubset gizmoSubset);
        public void DrawWireOverlay(Camera camera);
        public void DrawUIOverlay(Camera camera);
        public CullingResults Cull(ref ScriptableCullingParameters parameters);
        public bool Equals(ScriptableRenderContext other);
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static bool operator ==(ScriptableRenderContext left, ScriptableRenderContext right);
        public static bool operator !=(ScriptableRenderContext left, ScriptableRenderContext right);
    }
}
using System;

namespace UnityEngine.Rendering
{
    public struct ShaderTagId : IEquatable<ShaderTagId>
    {
        public static readonly ShaderTagId none;

        public ShaderTagId(string name);

        public string name { get; }

        public override bool Equals(object obj);
        public bool Equals(ShaderTagId other);
        public override int GetHashCode();

        public static bool operator ==(ShaderTagId tag1, ShaderTagId tag2);
        public static bool operator !=(ShaderTagId tag1, ShaderTagId tag2);

        public static explicit operator ShaderTagId(string name);
        public static explicit operator string(ShaderTagId tagId);
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine.Rendering
{
    [UsedByNativeCode]
    public struct ShadowDrawingSettings : IEquatable<ShadowDrawingSettings>
    {
        public ShadowDrawingSettings(CullingResults cullingResults, int lightIndex);

        public CullingResults cullingResults { get; set; }
        public int lightIndex { get; set; }
        public bool useRenderingLayerMaskTest { get; set; }
        public ShadowSplitData splitData { get; set; }

        public bool Equals(ShadowDrawingSettings other);
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static bool operator ==(ShadowDrawingSettings left, ShadowDrawingSettings right);
        public static bool operator !=(ShadowDrawingSettings left, ShadowDrawingSettings right);
    }
}
using System;
using System.Runtime.CompilerServices;
using UnityEngine.Scripting;

namespace UnityEngine.Rendering
{
    [UsedByNativeCode]
    public struct ShadowSplitData : IEquatable<ShadowSplitData>
    {
        public static readonly int maximumCullingPlaneCount;

        public int cullingPlaneCount { get; set; }
        public Vector4 cullingSphere { get; set; }
        public float shadowCascadeBlendCullingFactor { get; set; }

        public Plane GetCullingPlane(int index);
        public void SetCullingPlane(int index, Plane plane);
        public bool Equals(ShadowSplitData other);
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static bool operator ==(ShadowSplitData left, ShadowSplitData right);
        public static bool operator !=(ShadowSplitData left, ShadowSplitData right);

        [CompilerGenerated]
        [UnsafeValueType]
        public struct <m_CullingPlanes>e__FixedBuffer
        {
            public byte FixedElementField;
        }
    }
}
using System;

namespace UnityEngine.Rendering
{
    [Flags]
    public enum SortingCriteria
    {
        None = 0,
        SortingLayer = 1,
        RenderQueue = 2,
        BackToFront = 4,
        QuantizedFrontToBack = 8,
        OptimizeStateChanges = 16,
        CanvasOrder = 32,
        RendererPriority = 64,
        CommonOpaque = 59,
        CommonTransparent = 23
    }
}
using System;

namespace UnityEngine.Rendering
{
    public struct SortingLayerRange : IEquatable<SortingLayerRange>
    {
        public SortingLayerRange(short lowerBound, short upperBound);

        public short lowerBound { get; set; }
        public short upperBound { get; set; }
        public static SortingLayerRange all { get; }

        public bool Equals(SortingLayerRange other);
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static bool operator !=(SortingLayerRange lhs, SortingLayerRange rhs);
        public static bool operator ==(SortingLayerRange lhs, SortingLayerRange rhs);
    }
}
namespace UnityEngine.Rendering
{
    public enum DistanceMetric
    {
        Perspective = 0,
        Orthographic = 1,
        CustomAxis = 2
    }
}
using System;

namespace UnityEngine.Rendering
{
    public struct SortingSettings : IEquatable<SortingSettings>
    {
        public SortingSettings(Camera camera);

        public Matrix4x4 worldToCameraMatrix { get; set; }
        public Vector3 cameraPosition { get; set; }
        public Vector3 customAxis { get; set; }
        public SortingCriteria criteria { get; set; }
        public DistanceMetric distanceMetric { get; set; }

        public bool Equals(SortingSettings other);
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static bool operator ==(SortingSettings left, SortingSettings right);
        public static bool operator !=(SortingSettings left, SortingSettings right);
    }
}
using System;

namespace UnityEngine.Rendering
{
    public struct StencilState : IEquatable<StencilState>
    {
        public StencilState(bool enabled = True, byte readMask = 255, byte writeMask = 255, CompareFunction compareFunction = Always, StencilOp passOperation = Keep, StencilOp failOperation = Keep, StencilOp zFailOperation = Keep);
        public StencilState(bool enabled, byte readMask, byte writeMask, CompareFunction compareFunctionFront, StencilOp passOperationFront, StencilOp failOperationFront, StencilOp zFailOperationFront, CompareFunction compareFunctionBack, StencilOp passOperationBack, StencilOp failOperationBack, StencilOp zFailOperationBack);

        public static StencilState defaultValue { get; }
        public bool enabled { get; set; }
        public byte readMask { get; set; }
        public byte writeMask { get; set; }
        public CompareFunction compareFunctionFront { get; set; }
        public StencilOp passOperationFront { get; set; }
        public StencilOp failOperationFront { get; set; }
        public StencilOp zFailOperationFront { get; set; }
        public CompareFunction compareFunctionBack { get; set; }
        public StencilOp passOperationBack { get; set; }
        public StencilOp failOperationBack { get; set; }
        public StencilOp zFailOperationBack { get; set; }

        public void SetCompareFunction(CompareFunction value);
        public void SetPassOperation(StencilOp value);
        public void SetFailOperation(StencilOp value);
        public void SetZFailOperation(StencilOp value);
        public bool Equals(StencilState other);
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static bool operator ==(StencilState left, StencilState right);
        public static bool operator !=(StencilState left, StencilState right);
    }
}
using System;

namespace UnityEngine.Rendering
{
    public class SupportedRenderingFeatures
    {
        public SupportedRenderingFeatures();

        public static SupportedRenderingFeatures active { get; set; }
        public ReflectionProbeModes reflectionProbeModes { get; set; }
        public LightmapMixedBakeModes defaultMixedLightingModes { get; set; }
        public LightmapMixedBakeModes mixedLightingModes { get; set; }
        public LightmapBakeType lightmapBakeTypes { get; set; }
        public LightmapsMode lightmapsModes { get; set; }
        public bool enlighten { get; set; }
        public bool lightProbeProxyVolumes { get; set; }
        public bool motionVectors { get; set; }
        public bool receiveShadows { get; set; }
        public bool reflectionProbes { get; set; }
        public bool rendererPriority { get; set; }
        public bool terrainDetailUnsupported { get; set; }
        public bool rendersUIOverlay { get; set; }
        public bool overridesEnvironmentLighting { get; set; }
        public bool overridesFog { get; set; }
        public bool overridesRealtimeReflectionProbes { get; set; }
        public bool overridesOtherLightingSettings { get; set; }
        public bool editableMaterialRenderQueue { get; set; }
        public bool overridesLODBias { get; set; }
        public bool overridesMaximumLODLevel { get; set; }
        public bool rendererProbes { get; set; }
        public bool particleSystemInstancing { get; set; }
        public bool autoAmbientProbeBaking { get; set; }
        public bool autoDefaultReflectionProbeBaking { get; set; }
        public bool overridesShadowmask { get; set; }
        public string overrideShadowmaskMessage { get; set; }
        public string shadowmaskMessage { get; }

        [Flags]
        public enum ReflectionProbeModes
        {
            None = 0,
            Rotation = 1
        }
        [Flags]
        public enum LightmapMixedBakeModes
        {
            None = 0,
            IndirectOnly = 1,
            Subtractive = 2,
            Shadowmask = 4
        }
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine.Rendering
{
    [UsedByNativeCode]
    public struct VisibleLight : IEquatable<VisibleLight>
    {
        public Light light { get; }
        public LightType lightType { get; set; }
        public Color finalColor { get; set; }
        public Rect screenRect { get; set; }
        public Matrix4x4 localToWorldMatrix { get; set; }
        public float range { get; set; }
        public float spotAngle { get; set; }
        public bool intersectsNearPlane { get; set; }
        public bool intersectsFarPlane { get; set; }

        public bool Equals(VisibleLight other);
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static bool operator ==(VisibleLight left, VisibleLight right);
        public static bool operator !=(VisibleLight left, VisibleLight right);
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine.Rendering
{
    [UsedByNativeCode]
    public struct VisibleReflectionProbe : IEquatable<VisibleReflectionProbe>
    {
        public Texture texture { get; }
        public ReflectionProbe reflectionProbe { get; }
        public Bounds bounds { get; set; }
        public Matrix4x4 localToWorldMatrix { get; set; }
        public Vector4 hdrData { get; set; }
        public Vector3 center { get; set; }
        public float blendDistance { get; set; }
        public int importance { get; set; }
        public bool isBoxProjection { get; set; }

        public bool Equals(VisibleReflectionProbe other);
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static bool operator ==(VisibleReflectionProbe left, VisibleReflectionProbe right);
        public static bool operator !=(VisibleReflectionProbe left, VisibleReflectionProbe right);
    }
}
using UnityEngine.Scripting;

namespace UnityEngine.Rendering
{
    [UsedByNativeCode]
    public struct PlatformKeywordSet
    {
        public bool IsEnabled(BuiltinShaderDefine define);
        public void Enable(BuiltinShaderDefine define);
        public void Disable(BuiltinShaderDefine define);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Rendering
{
    [UsedByNativeCode]
    [NativeHeader("Runtime/Shaders/ShaderKeywordSet.h")]
    public enum ShaderKeywordType
    {
        None = 0,
        BuiltinDefault = 2,
        BuiltinExtra = 6,
        BuiltinAutoStripped = 10,
        UserDefined = 16
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Rendering
{
    [NativeHeader("Runtime/Graphics/ShaderScriptBindings.h")]
    [UsedByNativeCode]
    [NativeHeader("Runtime/Shaders/ShaderKeywords.h")]
    public struct ShaderKeyword
    {
        public ShaderKeyword(string keywordName);
        public ShaderKeyword(Shader shader, string keywordName);
        public ShaderKeyword(ComputeShader shader, string keywordName);

        public int index { get; }

        [FreeFunction("ShaderScripting::GetGlobalKeywordName")]
        public static string GetGlobalKeywordName(ShaderKeyword index);
        [FreeFunction("ShaderScripting::GetGlobalKeywordType")]
        public static ShaderKeywordType GetGlobalKeywordType(ShaderKeyword index);
        [FreeFunction("ShaderScripting::IsKeywordLocal")]
        public static bool IsKeywordLocal(ShaderKeyword index);
        [FreeFunction("ShaderScripting::GetKeywordName")]
        public static string GetKeywordName(Shader shader, ShaderKeyword index);
        [FreeFunction("ShaderScripting::GetKeywordType")]
        public static ShaderKeywordType GetKeywordType(Shader shader, ShaderKeyword index);
        public static string GetKeywordName(ComputeShader shader, ShaderKeyword index);
        public static ShaderKeywordType GetKeywordType(ComputeShader shader, ShaderKeyword index);
        public bool IsValid();
        [Obsolete("GetKeywordType is deprecated. Use ShaderKeyword.GetGlobalKeywordType instead.")]
        public ShaderKeywordType GetKeywordType();
        [Obsolete("GetKeywordName is deprecated. Use ShaderKeyword.GetGlobalKeywordName instead.")]
        public string GetKeywordName();
        [Obsolete("GetName() has been deprecated. Use ShaderKeyword.GetGlobalKeywordName instead.")]
        public string GetName();
    }
}
using System.Runtime.CompilerServices;
using UnityEngine.Scripting;

namespace UnityEngine.Rendering
{
    [UsedByNativeCode]
    public struct ShaderKeywordSet
    {
        public bool IsEnabled(ShaderKeyword keyword);
        public void Enable(ShaderKeyword keyword);
        public void Disable(ShaderKeyword keyword);
        public ShaderKeyword[] GetShaderKeywords();

        [CompilerGenerated]
        [UnsafeValueType]
        public struct <m_Bits>e__FixedBuffer
        {
            public uint FixedElementField;
        }
    }
}
namespace UnityEngine.Rendering
{
    public enum ShaderPropertyType
    {
        Color = 0,
        Vector = 1,
        Float = 2,
        Range = 3,
        Texture = 4
    }
}
using System;

namespace UnityEngine.Rendering
{
    [Flags]
    public enum ShaderPropertyFlags
    {
        None = 0,
        HideInInspector = 1,
        PerRendererData = 2,
        NoScaleOffset = 4,
        Normal = 8,
        HDR = 16,
        Gamma = 32,
        NonModifiableTextureData = 64,
        MainTexture = 128,
        MainColor = 256
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Rendering
{
    [NativeType(Header = "Runtime/2D/Sorting/SortingGroup.h")]
    [RequireComponent(typeof(Transform))]
    public sealed class SortingGroup : Behaviour
    {
        public SortingGroup();

        public string sortingLayerName { get; set; }
        public int sortingLayerID { get; set; }
        public int sortingOrder { get; set; }

        [StaticAccessor("SortingGroup", DoubleColon)]
        public static void UpdateAllSortingGroups();
    }
}
using System;

namespace UnityEngine.Playables
{
    public struct FrameData
    {
        public ulong frameId { get; }
        public float deltaTime { get; }
        public float weight { get; }
        public float effectiveWeight { get; }
        [Obsolete("effectiveParentDelay is obsolete; use a custom ScriptPlayable to implement this feature", False)]
        public double effectiveParentDelay { get; }
        public float effectiveParentSpeed { get; }
        public float effectiveSpeed { get; }
        public EvaluationType evaluationType { get; }
        public bool seekOccurred { get; }
        public bool timeLooped { get; }
        public bool timeHeld { get; }
        public PlayableOutput output { get; }
        public PlayState effectivePlayState { get; }

        public enum EvaluationType
        {
            Evaluate = 0,
            Playback = 1
        }
    }
}
namespace UnityEngine.Playables
{
    public interface INotification
    {
        PropertyName id { get; }
    }
}
using UnityEngine.Scripting;

namespace UnityEngine.Playables
{
    [RequiredByNativeCode]
    public interface INotificationReceiver
    {
        [RequiredByNativeCode]
        void OnNotify(Playable origin, INotification notification, object context);
    }
}
namespace UnityEngine.Playables
{
    public interface IPlayable
    {
        PlayableHandle GetHandle();
    }
}
using UnityEngine.Scripting;

namespace UnityEngine.Playables
{
    public interface IPlayableBehaviour
    {
        [RequiredByNativeCode]
        void OnGraphStart(Playable playable);
        [RequiredByNativeCode]
        void OnGraphStop(Playable playable);
        [RequiredByNativeCode]
        void OnPlayableCreate(Playable playable);
        [RequiredByNativeCode]
        void OnPlayableDestroy(Playable playable);
        [RequiredByNativeCode]
        void OnBehaviourPlay(Playable playable, FrameData info);
        [RequiredByNativeCode]
        void OnBehaviourPause(Playable playable, FrameData info);
        [RequiredByNativeCode]
        void PrepareFrame(Playable playable, FrameData info);
        [RequiredByNativeCode]
        void ProcessFrame(Playable playable, FrameData info, object playerData);
    }
}
namespace UnityEngine.Playables
{
    public interface IPlayableOutput
    {
        PlayableOutputHandle GetHandle();
    }
}
namespace UnityEngine.Playables
{
    public class Notification : INotification
    {
        public Notification(string name);

        public PropertyName id { get; }
    }
}
namespace UnityEngine.Playables
{
    public enum DirectorWrapMode
    {
        Hold = 0,
        Loop = 1,
        None = 2
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine.Playables
{
    [RequiredByNativeCode]
    public struct Playable : IEquatable<Playable>, IPlayable
    {
        public static Playable Null { get; }

        public static Playable Create(PlayableGraph graph, int inputCount = 0);
        public PlayableHandle GetHandle();
        public bool IsPlayableOfType<T>() where T : IPlayable, struct;
        public Type GetPlayableType();
        public bool Equals(Playable other);
    }
}
using System.Collections.Generic;

namespace UnityEngine.Playables
{
    public interface IPlayableAsset
    {
        double duration { get; }
        IEnumerable<PlayableBinding> outputs { get; }

        Playable CreatePlayable(PlayableGraph graph, GameObject owner);
    }
}
using System.Collections.Generic;
using UnityEngine.Scripting;

namespace UnityEngine.Playables
{
    [RequiredByNativeCode]
    [AssetFileNameExtension("playable", new[] { })]
    public abstract class PlayableAsset : ScriptableObject, IPlayableAsset
    {
        protected PlayableAsset();

        public virtual double duration { get; }
        public virtual IEnumerable<PlayableBinding> outputs { get; }

        public abstract Playable CreatePlayable(PlayableGraph graph, GameObject owner);
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine.Playables
{
    [RequiredByNativeCode]
    public abstract class PlayableBehaviour : IPlayableBehaviour, ICloneable
    {
        public PlayableBehaviour();

        public virtual void OnGraphStart(Playable playable);
        public virtual void OnGraphStop(Playable playable);
        public virtual void OnPlayableCreate(Playable playable);
        public virtual void OnPlayableDestroy(Playable playable);
        [Obsolete("OnBehaviourDelay is obsolete; use a custom ScriptPlayable to implement this feature", False)]
        public virtual void OnBehaviourDelay(Playable playable, FrameData info);
        public virtual void OnBehaviourPlay(Playable playable, FrameData info);
        public virtual void OnBehaviourPause(Playable playable, FrameData info);
        public virtual void PrepareData(Playable playable, FrameData info);
        public virtual void PrepareFrame(Playable playable, FrameData info);
        public virtual void ProcessFrame(Playable playable, FrameData info, object playerData);
        public virtual object Clone();
    }
}
using System;

namespace UnityEngine.Playables
{
    [Obsolete("DataStreamType is no longer required and will be removed in a future release.", False)]
    public enum DataStreamType
    {
        Animation = 0,
        Audio = 1,
        Texture = 2,
        None = 3
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine.Playables
{
    public struct PlayableBinding
    {
        public static readonly PlayableBinding[] None;
        public static readonly double DefaultDuration;

        public string streamName { get; set; }
        public Object sourceObject { get; set; }
        public Type outputTargetType { get; }
        [EditorBrowsable(Never)]
        [Obsolete("sourceBindingType is no longer supported on PlayableBinding. Use outputBindingType instead to get the required output target type, and the appropriate binding create method (e.g. AnimationPlayableBinding.Create(name, key)) to create PlayableBindings", True)]
        public Type sourceBindingType { get; set; }
        [Obsolete("streamType is no longer supported on PlayableBinding. Use the appropriate binding create method (e.g. AnimationPlayableBinding.Create(name, key)) instead.", True)]
        [EditorBrowsable(Never)]
        public DataStreamType streamType { get; set; }
    }
}
namespace UnityEngine.Playables
{
    public enum PlayableTraversalMode
    {
        Mix = 0,
        Passthrough = 1
    }
}
using System;

namespace UnityEngine.Playables
{
    public static class PlayableExtensions
    {
        public static bool IsNull<U>(this U playable) where U : IPlayable, struct;
        public static bool IsValid<U>(this U playable) where U : IPlayable, struct;
        public static void Destroy<U>(this U playable) where U : IPlayable, struct;
        public static PlayableGraph GetGraph<U>(this U playable) where U : IPlayable, struct;
        [Obsolete("SetPlayState() has been deprecated. Use Play(), Pause() or SetDelay() instead", False)]
        public static void SetPlayState<U>(this U playable, PlayState value) where U : IPlayable, struct;
        public static PlayState GetPlayState<U>(this U playable) where U : IPlayable, struct;
        public static void Play<U>(this U playable) where U : IPlayable, struct;
        public static void Pause<U>(this U playable) where U : IPlayable, struct;
        public static void SetSpeed<U>(this U playable, double value) where U : IPlayable, struct;
        public static double GetSpeed<U>(this U playable) where U : IPlayable, struct;
        public static void SetDuration<U>(this U playable, double value) where U : IPlayable, struct;
        public static double GetDuration<U>(this U playable) where U : IPlayable, struct;
        public static void SetTime<U>(this U playable, double value) where U : IPlayable, struct;
        public static double GetTime<U>(this U playable) where U : IPlayable, struct;
        public static double GetPreviousTime<U>(this U playable) where U : IPlayable, struct;
        public static void SetDone<U>(this U playable, bool value) where U : IPlayable, struct;
        public static bool IsDone<U>(this U playable) where U : IPlayable, struct;
        public static void SetPropagateSetTime<U>(this U playable, bool value) where U : IPlayable, struct;
        public static bool GetPropagateSetTime<U>(this U playable) where U : IPlayable, struct;
        public static bool CanChangeInputs<U>(this U playable) where U : IPlayable, struct;
        public static bool CanSetWeights<U>(this U playable) where U : IPlayable, struct;
        public static bool CanDestroy<U>(this U playable) where U : IPlayable, struct;
        public static void SetInputCount<U>(this U playable, int value) where U : IPlayable, struct;
        public static int GetInputCount<U>(this U playable) where U : IPlayable, struct;
        public static void SetOutputCount<U>(this U playable, int value) where U : IPlayable, struct;
        public static int GetOutputCount<U>(this U playable) where U : IPlayable, struct;
        public static Playable GetInput<U>(this U playable, int inputPort) where U : IPlayable, struct;
        public static Playable GetOutput<U>(this U playable, int outputPort) where U : IPlayable, struct;
        public static void SetInputWeight<U>(this U playable, int inputIndex, float weight) where U : IPlayable, struct;
        public static void SetInputWeight<U, V>(this U playable, V input, float weight) where U : IPlayable, struct where V : IPlayable, struct;
        public static float GetInputWeight<U>(this U playable, int inputIndex) where U : IPlayable, struct;
        public static void ConnectInput<U, V>(this U playable, int inputIndex, V sourcePlayable, int sourceOutputIndex) where U : IPlayable, struct where V : IPlayable, struct;
        public static void ConnectInput<U, V>(this U playable, int inputIndex, V sourcePlayable, int sourceOutputIndex, float weight) where U : IPlayable, struct where V : IPlayable, struct;
        public static void DisconnectInput<U>(this U playable, int inputPort) where U : IPlayable, struct;
        public static int AddInput<U, V>(this U playable, V sourcePlayable, int sourceOutputIndex, float weight = 0) where U : IPlayable, struct where V : IPlayable, struct;
        [Obsolete("SetDelay is obsolete; use a custom ScriptPlayable to implement this feature", False)]
        public static void SetDelay<U>(this U playable, double delay) where U : IPlayable, struct;
        [Obsolete("GetDelay is obsolete; use a custom ScriptPlayable to implement this feature", False)]
        public static double GetDelay<U>(this U playable) where U : IPlayable, struct;
        [Obsolete("IsDelayed is obsolete; use a custom ScriptPlayable to implement this feature", False)]
        public static bool IsDelayed<U>(this U playable) where U : IPlayable, struct;
        public static void SetLeadTime<U>(this U playable, float value) where U : IPlayable, struct;
        public static float GetLeadTime<U>(this U playable) where U : IPlayable, struct;
        public static PlayableTraversalMode GetTraversalMode<U>(this U playable) where U : IPlayable, struct;
        public static void SetTraversalMode<U>(this U playable, PlayableTraversalMode mode) where U : IPlayable, struct;
    }
}
namespace UnityEngine.Playables
{
    public enum DirectorUpdateMode
    {
        DSPClock = 0,
        GameTime = 1,
        UnscaledGameTime = 2,
        Manual = 3
    }
}
using System.ComponentModel;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Playables
{
    [NativeHeader("Runtime/Director/Core/HPlayableOutput.h")]
    [NativeHeader("Runtime/Director/Core/HPlayable.h")]
    [NativeHeader("Runtime/Export/Director/PlayableGraph.bindings.h")]
    [UsedByNativeCode]
    [NativeHeader("Runtime/Director/Core/HPlayableGraph.h")]
    public struct PlayableGraph
    {
        public Playable GetRootPlayable(int index);
        public bool Connect<U, V>(U source, int sourceOutputPort, V destination, int destinationInputPort) where U : IPlayable, struct where V : IPlayable, struct;
        public void Disconnect<U>(U input, int inputPort) where U : IPlayable, struct;
        public void DestroyPlayable<U>(U playable) where U : IPlayable, struct;
        public void DestroySubgraph<U>(U playable) where U : IPlayable, struct;
        public void DestroyOutput<U>(U output) where U : IPlayableOutput, struct;
        public int GetOutputCountByType<T>() where T : IPlayableOutput, struct;
        public PlayableOutput GetOutput(int index);
        public PlayableOutput GetOutputByType<T>(int index) where T : IPlayableOutput, struct;
        public void Evaluate();
        public static PlayableGraph Create();
        public static PlayableGraph Create(string name);
        [FreeFunction("PlayableGraphBindings::Destroy", HasExplicitThis = True, ThrowsException = True)]
        public void Destroy();
        public bool IsValid();
        [FreeFunction("PlayableGraphBindings::IsPlaying", HasExplicitThis = True, ThrowsException = True)]
        public bool IsPlaying();
        [FreeFunction("PlayableGraphBindings::IsDone", HasExplicitThis = True, ThrowsException = True)]
        public bool IsDone();
        [FreeFunction("PlayableGraphBindings::Play", HasExplicitThis = True, ThrowsException = True)]
        public void Play();
        [FreeFunction("PlayableGraphBindings::Stop", HasExplicitThis = True, ThrowsException = True)]
        public void Stop();
        [FreeFunction("PlayableGraphBindings::Evaluate", HasExplicitThis = True, ThrowsException = True)]
        public void Evaluate([DefaultValue("0")] float deltaTime);
        [FreeFunction("PlayableGraphBindings::GetTimeUpdateMode", HasExplicitThis = True, ThrowsException = True)]
        public DirectorUpdateMode GetTimeUpdateMode();
        [FreeFunction("PlayableGraphBindings::SetTimeUpdateMode", HasExplicitThis = True, ThrowsException = True)]
        public void SetTimeUpdateMode(DirectorUpdateMode value);
        [FreeFunction("PlayableGraphBindings::GetResolver", HasExplicitThis = True, ThrowsException = True)]
        public IExposedPropertyTable GetResolver();
        [FreeFunction("PlayableGraphBindings::SetResolver", HasExplicitThis = True, ThrowsException = True)]
        public void SetResolver(IExposedPropertyTable value);
        [FreeFunction("PlayableGraphBindings::GetPlayableCount", HasExplicitThis = True, ThrowsException = True)]
        public int GetPlayableCount();
        [FreeFunction("PlayableGraphBindings::GetRootPlayableCount", HasExplicitThis = True, ThrowsException = True)]
        public int GetRootPlayableCount();
        [FreeFunction("PlayableGraphBindings::GetOutputCount", HasExplicitThis = True, ThrowsException = True)]
        public int GetOutputCount();
        [FreeFunction("PlayableGraphBindings::GetEditorName", HasExplicitThis = True, ThrowsException = True)]
        public string GetEditorName();
    }
}
using System;

namespace UnityEngine.Playables
{
    public enum PlayState
    {
        Paused = 0,
        Playing = 1,
        [Obsolete("Delayed is obsolete; use a custom ScriptPlayable to implement this feature", False)]
        Delayed = 2
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Playables
{
    [UsedByNativeCode]
    [NativeHeader("Runtime/Export/Director/PlayableHandle.bindings.h")]
    [NativeHeader("Runtime/Director/Core/HPlayableGraph.h")]
    [NativeHeader("Runtime/Director/Core/HPlayable.h")]
    public struct PlayableHandle : IEquatable<PlayableHandle>
    {
        public static PlayableHandle Null { get; }

        public override bool Equals(object p);
        public bool Equals(PlayableHandle other);
        public override int GetHashCode();

        public static bool operator ==(PlayableHandle x, PlayableHandle y);
        public static bool operator !=(PlayableHandle x, PlayableHandle y);
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine.Playables
{
    [RequiredByNativeCode]
    public struct PlayableOutput : IPlayableOutput, IEquatable<PlayableOutput>
    {
        public static PlayableOutput Null { get; }

        public PlayableOutputHandle GetHandle();
        public bool IsPlayableOutputOfType<T>() where T : IPlayableOutput, struct;
        public Type GetPlayableOutputType();
        public bool Equals(PlayableOutput other);
    }
}
using System;

namespace UnityEngine.Playables
{
    public static class PlayableOutputExtensions
    {
        public static bool IsOutputNull<U>(this U output) where U : IPlayableOutput, struct;
        public static bool IsOutputValid<U>(this U output) where U : IPlayableOutput, struct;
        public static Object GetReferenceObject<U>(this U output) where U : IPlayableOutput, struct;
        public static void SetReferenceObject<U>(this U output, Object value) where U : IPlayableOutput, struct;
        public static Object GetUserData<U>(this U output) where U : IPlayableOutput, struct;
        public static void SetUserData<U>(this U output, Object value) where U : IPlayableOutput, struct;
        public static Playable GetSourcePlayable<U>(this U output) where U : IPlayableOutput, struct;
        public static void SetSourcePlayable<U, V>(this U output, V value) where U : IPlayableOutput, struct where V : IPlayable, struct;
        public static void SetSourcePlayable<U, V>(this U output, V value, int port) where U : IPlayableOutput, struct where V : IPlayable, struct;
        public static int GetSourceOutputPort<U>(this U output) where U : IPlayableOutput, struct;
        public static float GetWeight<U>(this U output) where U : IPlayableOutput, struct;
        public static void SetWeight<U>(this U output, float value) where U : IPlayableOutput, struct;
        public static void PushNotification<U>(this U output, Playable origin, INotification notification, object context = null) where U : IPlayableOutput, struct;
        public static INotificationReceiver[] GetNotificationReceivers<U>(this U output) where U : IPlayableOutput, struct;
        public static void AddNotificationReceiver<U>(this U output, INotificationReceiver receiver) where U : IPlayableOutput, struct;
        public static void RemoveNotificationReceiver<U>(this U output, INotificationReceiver receiver) where U : IPlayableOutput, struct;
        [Obsolete("Method GetSourceInputPort has been renamed to GetSourceOutputPort (UnityUpgradable) -> GetSourceOutputPort<U>(*)", False)]
        public static int GetSourceInputPort<U>(this U output) where U : IPlayableOutput, struct;
        [Obsolete("Method SetSourceInputPort has been deprecated. Use SetSourcePlayable(Playable, Port) instead.", False)]
        public static void SetSourceInputPort<U>(this U output, int value) where U : IPlayableOutput, struct;
        [Obsolete("Method SetSourceOutputPort has been deprecated. Use SetSourcePlayable(Playable, Port) instead.", False)]
        public static void SetSourceOutputPort<U>(this U output, int value) where U : IPlayableOutput, struct;
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Playables
{
    [NativeHeader("Runtime/Director/Core/HPlayable.h")]
    [UsedByNativeCode]
    [NativeHeader("Runtime/Director/Core/HPlayableOutput.h")]
    [NativeHeader("Runtime/Export/Director/PlayableOutputHandle.bindings.h")]
    public struct PlayableOutputHandle : IEquatable<PlayableOutputHandle>
    {
        public static PlayableOutputHandle Null { get; }

        public override int GetHashCode();
        public override bool Equals(object p);
        public bool Equals(PlayableOutputHandle other);

        public static bool operator ==(PlayableOutputHandle lhs, PlayableOutputHandle rhs);
        public static bool operator !=(PlayableOutputHandle lhs, PlayableOutputHandle rhs);
    }
}
using System;

namespace UnityEngine.Playables
{
    public struct ScriptPlayable<T> : IEquatable<ScriptPlayable<T>>, IPlayable where T : IPlayableBehaviour, class, new()
    {
        public static ScriptPlayable<T> Null { get; }

        public static ScriptPlayable<T> Create(PlayableGraph graph, int inputCount = 0);
        public static ScriptPlayable<T> Create(PlayableGraph graph, T template, int inputCount = 0);
        public PlayableHandle GetHandle();
        public T GetBehaviour();
        public bool Equals(ScriptPlayable<T> other);

        public static implicit operator Playable(ScriptPlayable<T> playable);
        public static explicit operator ScriptPlayable<T>(Playable playable);
    }
}
using System;

namespace UnityEngine.Playables
{
    public static class ScriptPlayableBinding
    {
        public static PlayableBinding Create(string name, Object key, Type type);
    }
}
using UnityEngine.Scripting;

namespace UnityEngine.Playables
{
    [RequiredByNativeCode]
    public struct ScriptPlayableOutput : IPlayableOutput
    {
        public static ScriptPlayableOutput Null { get; }

        public static ScriptPlayableOutput Create(PlayableGraph graph, string name);
        public PlayableOutputHandle GetHandle();

        public static implicit operator PlayableOutput(ScriptPlayableOutput output);
        public static explicit operator ScriptPlayableOutput(PlayableOutput output);
    }
}
namespace UnityEngine.Diagnostics
{
    public enum ForcedCrashCategory
    {
        AccessViolation = 0,
        FatalError = 1,
        Abort = 2,
        PureVirtualFunction = 3,
        MonoAbort = 4
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Diagnostics
{
    [NativeHeader("Runtime/Export/Diagnostics/DiagnosticsUtils.bindings.h")]
    public static class Utils
    {
        [FreeFunction("DiagnosticsUtils_Bindings::ForceCrash", ThrowsException = True)]
        public static void ForceCrash(ForcedCrashCategory crashCategory);
        [FreeFunction("DiagnosticsUtils_Bindings::NativeAssert")]
        public static void NativeAssert(string message);
        [FreeFunction("DiagnosticsUtils_Bindings::NativeError")]
        public static void NativeError(string message);
        [FreeFunction("DiagnosticsUtils_Bindings::NativeWarning")]
        public static void NativeWarning(string message);
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine.Diagnostics
{
    public static class PlayerConnection
    {
        [Obsolete("Use UnityEngine.Networking.PlayerConnection.PlayerConnection.instance.isConnected instead.")]
        public static bool connected { get; }

        [Obsolete("PlayerConnection.SendFile is no longer supported.", True)]
        [EditorBrowsable(Never)]
        public static void SendFile(string remoteFilePath, byte[] data);
    }
}
namespace UnityEngine.Experimental.GlobalIllumination
{
    public enum LightType
    {
        Directional = 0,
        Point = 1,
        Spot = 2,
        Rectangle = 3,
        Disc = 4,
        SpotPyramidShape = 5,
        SpotBoxShape = 6
    }
}
namespace UnityEngine.Experimental.GlobalIllumination
{
    public enum LightMode
    {
        Realtime = 0,
        Mixed = 1,
        Baked = 2,
        Unknown = 3
    }
}
namespace UnityEngine.Experimental.GlobalIllumination
{
    public enum FalloffType
    {
        InverseSquared = 0,
        InverseSquaredNoRangeAttenuation = 1,
        Linear = 2,
        Legacy = 3,
        Undefined = 4
    }
}
namespace UnityEngine.Experimental.GlobalIllumination
{
    public enum AngularFalloffType
    {
        LUT = 0,
        AnalyticAndInnerAngle = 1
    }
}
namespace UnityEngine.Experimental.GlobalIllumination
{
    public struct LinearColor
    {
        public float red { get; set; }
        public float green { get; set; }
        public float blue { get; set; }
        public float intensity { get; set; }

        public static LinearColor Convert(Color color, float intensity);
        public static LinearColor Black();
    }
}
using System;

namespace UnityEngine.Experimental.GlobalIllumination
{
    public struct DirectionalLight
    {
        public int instanceID;
        public bool shadow;
        public LightMode mode;
        public Vector3 position;
        public Quaternion orientation;
        public LinearColor color;
        public LinearColor indirectColor;
        public float penumbraWidthRadian;
        [Obsolete("Directional lights support cookies now. In order to position the cookie projection in the world, a position and full orientation are necessary. Use the position and orientation members instead of the direction parameter.", True)]
        public Vector3 direction;
    }
}
namespace UnityEngine.Experimental.GlobalIllumination
{
    public struct PointLight
    {
        public int instanceID;
        public bool shadow;
        public LightMode mode;
        public Vector3 position;
        public Quaternion orientation;
        public LinearColor color;
        public LinearColor indirectColor;
        public float range;
        public float sphereRadius;
        public FalloffType falloff;
    }
}
namespace UnityEngine.Experimental.GlobalIllumination
{
    public struct SpotLight
    {
        public int instanceID;
        public bool shadow;
        public LightMode mode;
        public Vector3 position;
        public Quaternion orientation;
        public LinearColor color;
        public LinearColor indirectColor;
        public float range;
        public float sphereRadius;
        public float coneAngle;
        public float innerConeAngle;
        public FalloffType falloff;
        public AngularFalloffType angularFalloff;
    }
}
namespace UnityEngine.Experimental.GlobalIllumination
{
    public struct RectangleLight
    {
        public int instanceID;
        public bool shadow;
        public LightMode mode;
        public Vector3 position;
        public Quaternion orientation;
        public LinearColor color;
        public LinearColor indirectColor;
        public float range;
        public float width;
        public float height;
        public FalloffType falloff;
    }
}
namespace UnityEngine.Experimental.GlobalIllumination
{
    public struct DiscLight
    {
        public int instanceID;
        public bool shadow;
        public LightMode mode;
        public Vector3 position;
        public Quaternion orientation;
        public LinearColor color;
        public LinearColor indirectColor;
        public float range;
        public float radius;
        public FalloffType falloff;
    }
}
namespace UnityEngine.Experimental.GlobalIllumination
{
    public struct SpotLightBoxShape
    {
        public int instanceID;
        public bool shadow;
        public LightMode mode;
        public Vector3 position;
        public Quaternion orientation;
        public LinearColor color;
        public LinearColor indirectColor;
        public float range;
        public float width;
        public float height;
    }
}
namespace UnityEngine.Experimental.GlobalIllumination
{
    public struct SpotLightPyramidShape
    {
        public int instanceID;
        public bool shadow;
        public LightMode mode;
        public Vector3 position;
        public Quaternion orientation;
        public LinearColor color;
        public LinearColor indirectColor;
        public float range;
        public float angle;
        public float aspectRatio;
        public FalloffType falloff;
    }
}
namespace UnityEngine.Experimental.GlobalIllumination
{
    public struct Cookie
    {
        public int instanceID;
        public float scale;
        public Vector2 sizes;

        public static Cookie Defaults();
    }
}
using UnityEngine.Scripting;

namespace UnityEngine.Experimental.GlobalIllumination
{
    [UsedByNativeCode]
    public struct LightDataGI
    {
        public int instanceID;
        public int cookieID;
        public float cookieScale;
        public LinearColor color;
        public LinearColor indirectColor;
        public Quaternion orientation;
        public Vector3 position;
        public float range;
        public float coneAngle;
        public float innerConeAngle;
        public float shape0;
        public float shape1;
        public LightType type;
        public LightMode mode;
        public byte shadow;
        public FalloffType falloff;

        public void Init(ref DirectionalLight light, ref Cookie cookie);
        public void Init(ref PointLight light, ref Cookie cookie);
        public void Init(ref SpotLight light, ref Cookie cookie);
        public void Init(ref RectangleLight light, ref Cookie cookie);
        public void Init(ref DiscLight light, ref Cookie cookie);
        public void Init(ref SpotLightBoxShape light, ref Cookie cookie);
        public void Init(ref SpotLightPyramidShape light, ref Cookie cookie);
        public void Init(ref DirectionalLight light);
        public void Init(ref PointLight light);
        public void Init(ref SpotLight light);
        public void Init(ref RectangleLight light);
        public void Init(ref DiscLight light);
        public void Init(ref SpotLightBoxShape light);
        public void Init(ref SpotLightPyramidShape light);
        public void InitNoBake(int lightInstanceID);
    }
}
namespace UnityEngine.Experimental.GlobalIllumination
{
    public static class LightmapperUtils
    {
        public static LightMode Extract(LightmapBakeType baketype);
        public static LinearColor ExtractIndirect(Light l);
        public static float ExtractInnerCone(Light l);
        public static void Extract(Light l, ref DirectionalLight dir);
        public static void Extract(Light l, ref PointLight point);
        public static void Extract(Light l, ref SpotLight spot);
        public static void Extract(Light l, ref RectangleLight rect);
        public static void Extract(Light l, ref DiscLight disc);
        public static void Extract(Light l, out Cookie cookie);
    }
}
using Unity.Collections;
using UnityEngine.Scripting;

namespace UnityEngine.Experimental.GlobalIllumination
{
    public static class Lightmapping
    {
        [RequiredByNativeCode]
        public static void SetDelegate(RequestLightsDelegate del);
        [RequiredByNativeCode]
        public static RequestLightsDelegate GetDelegate();
        [RequiredByNativeCode]
        public static void ResetDelegate();

        public delegate void RequestLightsDelegate(Light[] requests, NativeArray<LightDataGI> lightsOutput);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Experimental.GlobalIllumination
{
    [StaticAccessor("GetRenderSettings()", Dot)]
    [NativeHeader("Runtime/Camera/RenderSettings.h")]
    public class RenderSettings
    {
        public RenderSettings();

        public static bool useRadianceAmbientProbe { get; set; }
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Playables;
using UnityEngine.Scripting;

namespace UnityEngine.Experimental.Playables
{
    [RequiredByNativeCode]
    [NativeHeader("Runtime/Export/Director/CameraPlayable.bindings.h")]
    [NativeHeader("Runtime/Camera//Director/CameraPlayable.h")]
    [NativeHeader("Runtime/Director/Core/HPlayable.h")]
    [StaticAccessor("CameraPlayableBindings", DoubleColon)]
    public struct CameraPlayable : IEquatable<CameraPlayable>, IPlayable
    {
        public static CameraPlayable Create(PlayableGraph graph, Camera camera);
        public PlayableHandle GetHandle();
        public bool Equals(CameraPlayable other);
        public Camera GetCamera();
        public void SetCamera(Camera value);

        public static implicit operator Playable(CameraPlayable playable);
        public static explicit operator CameraPlayable(Playable playable);
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Playables;
using UnityEngine.Scripting;

namespace UnityEngine.Experimental.Playables
{
    [NativeHeader("Runtime/Export/Director/MaterialEffectPlayable.bindings.h")]
    [NativeHeader("Runtime/Shaders/Director/MaterialEffectPlayable.h")]
    [RequiredByNativeCode]
    [StaticAccessor("MaterialEffectPlayableBindings", DoubleColon)]
    [NativeHeader("Runtime/Director/Core/HPlayable.h")]
    public struct MaterialEffectPlayable : IEquatable<MaterialEffectPlayable>, IPlayable
    {
        public static MaterialEffectPlayable Create(PlayableGraph graph, Material material, int pass = -1);
        public PlayableHandle GetHandle();
        public bool Equals(MaterialEffectPlayable other);
        public Material GetMaterial();
        public void SetMaterial(Material value);
        public int GetPass();
        public void SetPass(int value);

        public static implicit operator Playable(MaterialEffectPlayable playable);
        public static explicit operator MaterialEffectPlayable(Playable playable);
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Playables;
using UnityEngine.Scripting;

namespace UnityEngine.Experimental.Playables
{
    [StaticAccessor("TextureMixerPlayableBindings", DoubleColon)]
    [NativeHeader("Runtime/Graphics/Director/TextureMixerPlayable.h")]
    [RequiredByNativeCode]
    [NativeHeader("Runtime/Director/Core/HPlayable.h")]
    [NativeHeader("Runtime/Export/Director/TextureMixerPlayable.bindings.h")]
    public struct TextureMixerPlayable : IEquatable<TextureMixerPlayable>, IPlayable
    {
        public static TextureMixerPlayable Create(PlayableGraph graph);
        public PlayableHandle GetHandle();
        public bool Equals(TextureMixerPlayable other);

        public static implicit operator Playable(TextureMixerPlayable playable);
        public static explicit operator TextureMixerPlayable(Playable playable);
    }
}
using UnityEngine.Playables;

namespace UnityEngine.Experimental.Playables
{
    public static class TexturePlayableBinding
    {
        public static PlayableBinding Create(string name, Object key);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Playables;
using UnityEngine.Scripting;

namespace UnityEngine.Experimental.Playables
{
    [RequiredByNativeCode]
    [StaticAccessor("TexturePlayableOutputBindings", DoubleColon)]
    [NativeHeader("Runtime/Graphics/RenderTexture.h")]
    [NativeHeader("Runtime/Export/Director/TexturePlayableOutput.bindings.h")]
    [NativeHeader("Runtime/Graphics/Director/TexturePlayableOutput.h")]
    public struct TexturePlayableOutput : IPlayableOutput
    {
        public static TexturePlayableOutput Null { get; }

        public static TexturePlayableOutput Create(PlayableGraph graph, string name, RenderTexture target);
        public PlayableOutputHandle GetHandle();
        public RenderTexture GetTarget();
        public void SetTarget(RenderTexture value);

        public static implicit operator PlayableOutput(TexturePlayableOutput output);
        public static explicit operator TexturePlayableOutput(PlayableOutput output);
    }
}
using System;

namespace UnityEngine.Experimental.Rendering
{
    public interface IScriptableRuntimeReflectionSystem : IDisposable
    {
        bool TickRealtimeProbes();
    }
}
using System;

namespace UnityEngine.Experimental.Rendering
{
    public abstract class ScriptableRuntimeReflectionSystem : IDisposable, IScriptableRuntimeReflectionSystem
    {
        protected ScriptableRuntimeReflectionSystem();

        public virtual bool TickRealtimeProbes();
        protected virtual void Dispose(bool disposing);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Experimental.Rendering
{
    [RequiredByNativeCode]
    [NativeHeader("Runtime/Camera/ScriptableRuntimeReflectionSystem.h")]
    public static class ScriptableRuntimeReflectionSystemSettings
    {
        public static IScriptableRuntimeReflectionSystem system { get; set; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Experimental.Rendering
{
    [NativeHeader("Runtime/Graphics/GraphicsScriptBindings.h")]
    public static class ExternalGPUProfiler
    {
        [FreeFunction("ExternalGPUProfilerBindings::BeginGPUCapture")]
        public static void BeginGPUCapture();
        [FreeFunction("ExternalGPUProfilerBindings::EndGPUCapture")]
        public static void EndGPUCapture();
        [FreeFunction("ExternalGPUProfilerBindings::IsAttached")]
        public static bool IsAttached();
    }
}
namespace UnityEngine.Experimental.Rendering
{
    public enum WaitForPresentSyncPoint
    {
        BeginFrame = 0,
        EndFrame = 1
    }
}
namespace UnityEngine.Experimental.Rendering
{
    public enum GraphicsJobsSyncPoint
    {
        EndOfFrame = 0,
        AfterScriptUpdate = 1,
        AfterScriptLateUpdate = 2,
        WaitForPresent = 3
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Experimental.Rendering
{
    public static class GraphicsDeviceSettings
    {
        [StaticAccessor("GetGfxDevice()", Dot)]
        public static WaitForPresentSyncPoint waitForPresentSyncPoint { get; set; }
        [StaticAccessor("GetGfxDevice()", Dot)]
        public static GraphicsJobsSyncPoint graphicsJobsSyncPoint { get; set; }
    }
}
using System;

namespace UnityEngine.Experimental.Rendering
{
    [Flags]
    public enum TextureCreationFlags
    {
        None = 0,
        MipChain = 1,
        Crunch = 64
    }
}
namespace UnityEngine.Experimental.Rendering
{
    public enum FormatUsage
    {
        Sample = 0,
        Linear = 1,
        Sparse = 2,
        Render = 4,
        Blend = 5,
        GetPixels = 6,
        SetPixels = 7,
        SetPixels32 = 8,
        ReadPixels = 9,
        LoadStore = 10,
        MSAA2x = 11,
        MSAA4x = 12,
        MSAA8x = 13,
        StencilSampling = 16
    }
}
namespace UnityEngine.Experimental.Rendering
{
    public enum DefaultFormat
    {
        LDR = 0,
        HDR = 1
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine.Experimental.Rendering
{
    public enum GraphicsFormat
    {
        None = 0,
        R8_SRGB = 1,
        R8G8_SRGB = 2,
        R8G8B8_SRGB = 3,
        R8G8B8A8_SRGB = 4,
        R8_UNorm = 5,
        R8G8_UNorm = 6,
        R8G8B8_UNorm = 7,
        R8G8B8A8_UNorm = 8,
        R8_SNorm = 9,
        R8G8_SNorm = 10,
        R8G8B8_SNorm = 11,
        R8G8B8A8_SNorm = 12,
        R8_UInt = 13,
        R8G8_UInt = 14,
        R8G8B8_UInt = 15,
        R8G8B8A8_UInt = 16,
        R8_SInt = 17,
        R8G8_SInt = 18,
        R8G8B8_SInt = 19,
        R8G8B8A8_SInt = 20,
        R16_UNorm = 21,
        R16G16_UNorm = 22,
        R16G16B16_UNorm = 23,
        R16G16B16A16_UNorm = 24,
        R16_SNorm = 25,
        R16G16_SNorm = 26,
        R16G16B16_SNorm = 27,
        R16G16B16A16_SNorm = 28,
        R16_UInt = 29,
        R16G16_UInt = 30,
        R16G16B16_UInt = 31,
        R16G16B16A16_UInt = 32,
        R16_SInt = 33,
        R16G16_SInt = 34,
        R16G16B16_SInt = 35,
        R16G16B16A16_SInt = 36,
        R32_UInt = 37,
        R32G32_UInt = 38,
        R32G32B32_UInt = 39,
        R32G32B32A32_UInt = 40,
        R32_SInt = 41,
        R32G32_SInt = 42,
        R32G32B32_SInt = 43,
        R32G32B32A32_SInt = 44,
        R16_SFloat = 45,
        R16G16_SFloat = 46,
        R16G16B16_SFloat = 47,
        R16G16B16A16_SFloat = 48,
        R32_SFloat = 49,
        R32G32_SFloat = 50,
        R32G32B32_SFloat = 51,
        R32G32B32A32_SFloat = 52,
        B8G8R8_SRGB = 56,
        B8G8R8A8_SRGB = 57,
        B8G8R8_UNorm = 58,
        B8G8R8A8_UNorm = 59,
        B8G8R8_SNorm = 60,
        B8G8R8A8_SNorm = 61,
        B8G8R8_UInt = 62,
        B8G8R8A8_UInt = 63,
        B8G8R8_SInt = 64,
        B8G8R8A8_SInt = 65,
        R4G4B4A4_UNormPack16 = 66,
        B4G4R4A4_UNormPack16 = 67,
        R5G6B5_UNormPack16 = 68,
        B5G6R5_UNormPack16 = 69,
        R5G5B5A1_UNormPack16 = 70,
        B5G5R5A1_UNormPack16 = 71,
        A1R5G5B5_UNormPack16 = 72,
        E5B9G9R9_UFloatPack32 = 73,
        B10G11R11_UFloatPack32 = 74,
        A2B10G10R10_UNormPack32 = 75,
        A2B10G10R10_UIntPack32 = 76,
        A2B10G10R10_SIntPack32 = 77,
        A2R10G10B10_UNormPack32 = 78,
        A2R10G10B10_UIntPack32 = 79,
        A2R10G10B10_SIntPack32 = 80,
        A2R10G10B10_XRSRGBPack32 = 81,
        A2R10G10B10_XRUNormPack32 = 82,
        R10G10B10_XRSRGBPack32 = 83,
        R10G10B10_XRUNormPack32 = 84,
        A10R10G10B10_XRSRGBPack32 = 85,
        A10R10G10B10_XRUNormPack32 = 86,
        [EditorBrowsable(Never)]
        [Obsolete("Enum member GraphicsFormat.RGB_DXT1_SRGB has been deprecated. Use GraphicsFormat.RGBA_DXT1_SRGB instead (UnityUpgradable) -> RGBA_DXT1_SRGB", True)]
        RGB_DXT1_SRGB = 96,
        RGBA_DXT1_SRGB = 96,
        [Obsolete("Enum member GraphicsFormat.RGB_DXT1_UNorm has been deprecated. Use GraphicsFormat.RGBA_DXT1_UNorm instead (UnityUpgradable) -> RGBA_DXT1_UNorm", True)]
        [EditorBrowsable(Never)]
        RGB_DXT1_UNorm = 97,
        RGBA_DXT1_UNorm = 97,
        RGBA_DXT3_SRGB = 98,
        RGBA_DXT3_UNorm = 99,
        RGBA_DXT5_SRGB = 100,
        RGBA_DXT5_UNorm = 101,
        R_BC4_UNorm = 102,
        R_BC4_SNorm = 103,
        RG_BC5_UNorm = 104,
        RG_BC5_SNorm = 105,
        RGB_BC6H_UFloat = 106,
        RGB_BC6H_SFloat = 107,
        RGBA_BC7_SRGB = 108,
        RGBA_BC7_UNorm = 109,
        RGB_PVRTC_2Bpp_SRGB = 110,
        RGB_PVRTC_2Bpp_UNorm = 111,
        RGB_PVRTC_4Bpp_SRGB = 112,
        RGB_PVRTC_4Bpp_UNorm = 113,
        RGBA_PVRTC_2Bpp_SRGB = 114,
        RGBA_PVRTC_2Bpp_UNorm = 115,
        RGBA_PVRTC_4Bpp_SRGB = 116,
        RGBA_PVRTC_4Bpp_UNorm = 117,
        RGB_ETC_UNorm = 118,
        RGB_ETC2_SRGB = 119,
        RGB_ETC2_UNorm = 120,
        RGB_A1_ETC2_SRGB = 121,
        RGB_A1_ETC2_UNorm = 122,
        RGBA_ETC2_SRGB = 123,
        RGBA_ETC2_UNorm = 124,
        R_EAC_UNorm = 125,
        R_EAC_SNorm = 126,
        RG_EAC_UNorm = 127,
        RG_EAC_SNorm = 128,
        RGBA_ASTC4X4_SRGB = 129,
        RGBA_ASTC4X4_UNorm = 130,
        RGBA_ASTC5X5_SRGB = 131,
        RGBA_ASTC5X5_UNorm = 132,
        RGBA_ASTC6X6_SRGB = 133,
        RGBA_ASTC6X6_UNorm = 134,
        RGBA_ASTC8X8_SRGB = 135,
        RGBA_ASTC8X8_UNorm = 136,
        RGBA_ASTC10X10_SRGB = 137,
        RGBA_ASTC10X10_UNorm = 138,
        RGBA_ASTC12X12_SRGB = 139,
        RGBA_ASTC12X12_UNorm = 140,
        RGBA_ASTC4X4_UFloat = 145,
        RGBA_ASTC5X5_UFloat = 146,
        RGBA_ASTC6X6_UFloat = 147,
        RGBA_ASTC8X8_UFloat = 148,
        RGBA_ASTC10X10_UFloat = 149,
        RGBA_ASTC12X12_UFloat = 150
    }
}
namespace UnityEngine.Experimental.Rendering
{
    public enum RayTracingMode
    {
        Off = 0,
        Static = 1,
        DynamicTransform = 2,
        DynamicGeometry = 3
    }
}
using UnityEngine.Bindings;
using UnityEngine.Rendering;

namespace UnityEngine.Experimental.Rendering
{
    [NativeHeader("Runtime/Graphics/Format.h")]
    [NativeHeader("Runtime/Graphics/GraphicsFormatUtility.bindings.h")]
    [NativeHeader("Runtime/Graphics/TextureFormat.h")]
    public class GraphicsFormatUtility
    {
        public GraphicsFormatUtility();

        public static GraphicsFormat GetGraphicsFormat(TextureFormat format, bool isSRGB);
        public static TextureFormat GetTextureFormat(GraphicsFormat format);
        public static GraphicsFormat GetGraphicsFormat(RenderTextureFormat format, bool isSRGB);
        public static GraphicsFormat GetGraphicsFormat(RenderTextureFormat format, RenderTextureReadWrite readWrite);
        [FreeFunction(IsThreadSafe = True)]
        public static bool IsSRGBFormat(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static bool IsSwizzleFormat(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static GraphicsFormat GetSRGBFormat(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static GraphicsFormat GetLinearFormat(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static RenderTextureFormat GetRenderTextureFormat(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static uint GetColorComponentCount(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static uint GetAlphaComponentCount(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static uint GetComponentCount(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static string GetFormatString(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static bool IsCompressedFormat(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static bool IsPackedFormat(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static bool Is16BitPackedFormat(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static GraphicsFormat ConvertToAlphaFormat(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static bool IsAlphaOnlyFormat(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static bool IsAlphaTestFormat(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static bool HasAlphaChannel(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static bool IsDepthFormat(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static bool IsStencilFormat(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static bool IsIEEE754Format(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static bool IsFloatFormat(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static bool IsHalfFormat(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static bool IsUnsignedFormat(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static bool IsSignedFormat(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static bool IsNormFormat(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static bool IsUNormFormat(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static bool IsSNormFormat(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static bool IsIntegerFormat(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static bool IsUIntFormat(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static bool IsSIntFormat(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static bool IsXRFormat(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static bool IsDXTCFormat(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static bool IsRGTCFormat(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static bool IsBPTCFormat(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static bool IsBCFormat(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static bool IsPVRTCFormat(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static bool IsETCFormat(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static bool IsEACFormat(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static bool IsASTCFormat(GraphicsFormat format);
        public static bool IsCrunchFormat(TextureFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static FormatSwizzle GetSwizzleR(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static FormatSwizzle GetSwizzleG(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static FormatSwizzle GetSwizzleB(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static FormatSwizzle GetSwizzleA(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static uint GetBlockSize(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static uint GetBlockWidth(GraphicsFormat format);
        [FreeFunction(IsThreadSafe = True)]
        public static uint GetBlockHeight(GraphicsFormat format);
        public static uint ComputeMipmapSize(int width, int height, GraphicsFormat format);
        public static uint ComputeMipmapSize(int width, int height, int depth, GraphicsFormat format);
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Experimental.Rendering
{
    [NativeHeader("Runtime/Export/Graphics/RayTracingAccelerationStructure.bindings.h")]
    [NativeHeader("Runtime/Shaders/RayTracingAccelerationStructure.h")]
    [UsedByNativeCode]
    public sealed class RayTracingAccelerationStructure : IDisposable
    {
        public RayTracingAccelerationStructure(RASSettings settings);
        public RayTracingAccelerationStructure();

        ~RayTracingAccelerationStructure();

        public void Dispose();
        public void Release();
        public void Build();
        [Obsolete("Method Update has been deprecated. Use Build instead (UnityUpgradable) -> Build()", True)]
        public void Update();
        [FreeFunction(Name = "RayTracingAccelerationStructure_Bindings::Build", HasExplicitThis = True)]
        public void Build(Vector3 relativeOrigin);
        [FreeFunction(Name = "RayTracingAccelerationStructure_Bindings::Update", HasExplicitThis = True)]
        [Obsolete("Method Update has been deprecated. Use Build instead (UnityUpgradable) -> Build(*)", True)]
        public void Update(Vector3 relativeOrigin);
        [FreeFunction(Name = "RayTracingAccelerationStructure_Bindings::AddInstance", HasExplicitThis = True)]
        public void AddInstance([NotNull("ArgumentNullException")] Renderer targetRenderer, bool[] subMeshMask = null, bool[] subMeshTransparencyFlags = null, bool enableTriangleCulling = True, bool frontTriangleCounterClockwise = False, uint mask = 255);
        public void AddInstance(GraphicsBuffer aabbBuffer, uint numElements, Material material, bool isCutOff, bool enableTriangleCulling = True, bool frontTriangleCounterClockwise = False, uint mask = 255, bool reuseBounds = False);
        public void AddInstance(GraphicsBuffer aabbBuffer, uint numElements, Material material, Matrix4x4 instanceTransform, bool isCutOff, bool enableTriangleCulling = True, bool frontTriangleCounterClockwise = False, uint mask = 255, bool reuseBounds = False);
        [FreeFunction(Name = "RayTracingAccelerationStructure_Bindings::UpdateInstanceTransform", HasExplicitThis = True)]
        public void UpdateInstanceTransform([NotNull("ArgumentNullException")] Renderer renderer);
        [FreeFunction(Name = "RayTracingAccelerationStructure_Bindings::GetSize", HasExplicitThis = True)]
        public ulong GetSize();

        [Flags]
        public enum RayTracingModeMask
        {
            Nothing = 0,
            Static = 2,
            DynamicTransform = 4,
            DynamicGeometry = 8,
            Everything = 14
        }
        public enum ManagementMode
        {
            Manual = 0,
            Automatic = 1
        }
        public struct RASSettings
        {
            public ManagementMode managementMode;
            public RayTracingModeMask rayTracingModeMask;
            public int layerMask;

            public RASSettings(ManagementMode sceneManagementMode, RayTracingModeMask rayTracingModeMask, int layerMask);
        }
    }
}
using UnityEngine.Rendering;

namespace UnityEngine.Experimental.Rendering
{
    public struct ShaderWarmupSetup
    {
        public VertexAttributeDescriptor[] vdecl;
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Experimental.Rendering
{
    [NativeHeader("Runtime/Graphics/ShaderScriptBindings.h")]
    public static class ShaderWarmup
    {
        [FreeFunction(Name = "ShaderWarmupScripting::WarmupShader")]
        public static void WarmupShader(Shader shader, ShaderWarmupSetup setup);
        [FreeFunction(Name = "ShaderWarmupScripting::WarmupShaderFromCollection")]
        public static void WarmupShaderFromCollection(ShaderVariantCollection collection, Shader shader, ShaderWarmupSetup setup);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Experimental.Rendering
{
    [NativeHeader("Runtime/Shaders/RayTracingAccelerationStructure.h")]
    [NativeHeader("Runtime/Graphics/ShaderScriptBindings.h")]
    [NativeHeader("Runtime/Shaders/RayTracingShader.h")]
    public sealed class RayTracingShader : Object
    {
        public float maxRecursionDepth { get; }

        [FreeFunction(Name = "RayTracingShaderScripting::SetValue<float>", HasExplicitThis = True)]
        public void SetFloat(int nameID, float val);
        [FreeFunction(Name = "RayTracingShaderScripting::SetValue<int>", HasExplicitThis = True)]
        public void SetInt(int nameID, int val);
        [FreeFunction(Name = "RayTracingShaderScripting::SetValue<Vector4f>", HasExplicitThis = True)]
        public void SetVector(int nameID, Vector4 val);
        [FreeFunction(Name = "RayTracingShaderScripting::SetValue<Matrix4x4f>", HasExplicitThis = True)]
        public void SetMatrix(int nameID, Matrix4x4 val);
        [FreeFunction(Name = "RayTracingShaderScripting::SetArray<Vector4f>", HasExplicitThis = True)]
        public void SetVectorArray(int nameID, Vector4[] values);
        [FreeFunction(Name = "RayTracingShaderScripting::SetArray<Matrix4x4f>", HasExplicitThis = True)]
        public void SetMatrixArray(int nameID, Matrix4x4[] values);
        [NativeMethod(Name = "RayTracingShaderScripting::SetTexture", HasExplicitThis = True, IsFreeFunction = True)]
        public void SetTexture(int nameID, [NotNull("ArgumentNullException")] Texture texture);
        [NativeMethod(Name = "RayTracingShaderScripting::SetBuffer", HasExplicitThis = True, IsFreeFunction = True)]
        public void SetBuffer(int nameID, [NotNull("ArgumentNullException")] ComputeBuffer buffer);
        [NativeMethod(Name = "RayTracingShaderScripting::SetAccelerationStructure", HasExplicitThis = True, IsFreeFunction = True)]
        public void SetAccelerationStructure(int nameID, [NotNull("ArgumentNullException")] RayTracingAccelerationStructure accelerationStructure);
        public void SetShaderPass(string passName);
        [NativeMethod(Name = "RayTracingShaderScripting::SetTextureFromGlobal", HasExplicitThis = True, IsFreeFunction = True)]
        public void SetTextureFromGlobal(int nameID, int globalTextureNameID);
        [NativeName("DispatchRays")]
        public void Dispatch(string rayGenFunctionName, int width, int height, int depth, Camera camera = null);
        public void SetBuffer(int nameID, GraphicsBuffer buffer);
        public void SetFloat(string name, float val);
        public void SetInt(string name, int val);
        public void SetVector(string name, Vector4 val);
        public void SetMatrix(string name, Matrix4x4 val);
        public void SetVectorArray(string name, Vector4[] values);
        public void SetMatrixArray(string name, Matrix4x4[] values);
        public void SetFloats(string name, params float[] values);
        public void SetFloats(int nameID, params float[] values);
        public void SetInts(string name, params int[] values);
        public void SetInts(int nameID, params int[] values);
        public void SetBool(string name, bool val);
        public void SetBool(int nameID, bool val);
        public void SetTexture(string name, Texture texture);
        public void SetBuffer(string name, ComputeBuffer buffer);
        public void SetBuffer(string name, GraphicsBuffer buffer);
        public void SetConstantBuffer(int nameID, ComputeBuffer buffer, int offset, int size);
        public void SetConstantBuffer(string name, ComputeBuffer buffer, int offset, int size);
        public void SetConstantBuffer(int nameID, GraphicsBuffer buffer, int offset, int size);
        public void SetConstantBuffer(string name, GraphicsBuffer buffer, int offset, int size);
        public void SetAccelerationStructure(string name, RayTracingAccelerationStructure accelerationStructure);
        public void SetTextureFromGlobal(string name, string globalTextureName);
    }
}
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;

namespace UnityEngine.Assertions
{
    [DebuggerStepThrough]
    public static class Assert
    {
        [Obsolete("Future versions of Unity are expected to always throw exceptions and not have this field.")]
        public static bool raiseExceptions;

        [EditorBrowsable(Never)]
        [Obsolete("Assert.Equals should not be used for Assertions", True)]
        public static bool Equals(object obj1, object obj2);
        [EditorBrowsable(Never)]
        [Obsolete("Assert.ReferenceEquals should not be used for Assertions", True)]
        public static bool ReferenceEquals(object obj1, object obj2);
        [Conditional("UNITY_ASSERTIONS")]
        public static void IsTrue(bool condition);
        [Conditional("UNITY_ASSERTIONS")]
        public static void IsTrue(bool condition, string message);
        [Conditional("UNITY_ASSERTIONS")]
        public static void IsFalse(bool condition);
        [Conditional("UNITY_ASSERTIONS")]
        public static void IsFalse(bool condition, string message);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreApproximatelyEqual(float expected, float actual);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreApproximatelyEqual(float expected, float actual, string message);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreApproximatelyEqual(float expected, float actual, float tolerance);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreApproximatelyEqual(float expected, float actual, float tolerance, string message);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreNotApproximatelyEqual(float expected, float actual);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreNotApproximatelyEqual(float expected, float actual, string message);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreNotApproximatelyEqual(float expected, float actual, float tolerance);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreNotApproximatelyEqual(float expected, float actual, float tolerance, string message);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreEqual<T>(T expected, T actual);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreEqual<T>(T expected, T actual, string message);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreEqual<T>(T expected, T actual, string message, IEqualityComparer<T> comparer);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreEqual(Object expected, Object actual, string message);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreNotEqual<T>(T expected, T actual);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreNotEqual<T>(T expected, T actual, string message);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreNotEqual<T>(T expected, T actual, string message, IEqualityComparer<T> comparer);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreNotEqual(Object expected, Object actual, string message);
        [Conditional("UNITY_ASSERTIONS")]
        public static void IsNull<T>(T value) where T : class;
        [Conditional("UNITY_ASSERTIONS")]
        public static void IsNull<T>(T value, string message) where T : class;
        [Conditional("UNITY_ASSERTIONS")]
        public static void IsNull(Object value, string message);
        [Conditional("UNITY_ASSERTIONS")]
        public static void IsNotNull<T>(T value) where T : class;
        [Conditional("UNITY_ASSERTIONS")]
        public static void IsNotNull<T>(T value, string message) where T : class;
        [Conditional("UNITY_ASSERTIONS")]
        public static void IsNotNull(Object value, string message);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreEqual(sbyte expected, sbyte actual);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreEqual(sbyte expected, sbyte actual, string message);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreNotEqual(sbyte expected, sbyte actual);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreNotEqual(sbyte expected, sbyte actual, string message);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreEqual(byte expected, byte actual);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreEqual(byte expected, byte actual, string message);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreNotEqual(byte expected, byte actual);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreNotEqual(byte expected, byte actual, string message);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreEqual(char expected, char actual);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreEqual(char expected, char actual, string message);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreNotEqual(char expected, char actual);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreNotEqual(char expected, char actual, string message);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreEqual(short expected, short actual);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreEqual(short expected, short actual, string message);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreNotEqual(short expected, short actual);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreNotEqual(short expected, short actual, string message);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreEqual(ushort expected, ushort actual);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreEqual(ushort expected, ushort actual, string message);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreNotEqual(ushort expected, ushort actual);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreNotEqual(ushort expected, ushort actual, string message);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreEqual(int expected, int actual);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreEqual(int expected, int actual, string message);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreNotEqual(int expected, int actual);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreNotEqual(int expected, int actual, string message);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreEqual(uint expected, uint actual);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreEqual(uint expected, uint actual, string message);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreNotEqual(uint expected, uint actual);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreNotEqual(uint expected, uint actual, string message);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreEqual(long expected, long actual);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreEqual(long expected, long actual, string message);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreNotEqual(long expected, long actual);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreNotEqual(long expected, long actual, string message);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreEqual(ulong expected, ulong actual);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreEqual(ulong expected, ulong actual, string message);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreNotEqual(ulong expected, ulong actual);
        [Conditional("UNITY_ASSERTIONS")]
        public static void AreNotEqual(ulong expected, ulong actual, string message);
    }
}
using System;

namespace UnityEngine.Assertions
{
    public class AssertionException : Exception
    {
        public AssertionException(string message, string userMessage);

        public override string Message { get; }
    }
}
using System;
using System.Diagnostics;

namespace UnityEngine.Assertions.Must
{
    [DebuggerStepThrough]
    [Obsolete("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
    public static class MustExtensions
    {
        [Obsolete("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
        [Conditional("UNITY_ASSERTIONS")]
        public static void MustBeTrue(this bool value);
        [Conditional("UNITY_ASSERTIONS")]
        [Obsolete("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
        public static void MustBeTrue(this bool value, string message);
        [Obsolete("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
        [Conditional("UNITY_ASSERTIONS")]
        public static void MustBeFalse(this bool value);
        [Conditional("UNITY_ASSERTIONS")]
        [Obsolete("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
        public static void MustBeFalse(this bool value, string message);
        [Obsolete("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
        [Conditional("UNITY_ASSERTIONS")]
        public static void MustBeApproximatelyEqual(this float actual, float expected);
        [Obsolete("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
        [Conditional("UNITY_ASSERTIONS")]
        public static void MustBeApproximatelyEqual(this float actual, float expected, string message);
        [Obsolete("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
        [Conditional("UNITY_ASSERTIONS")]
        public static void MustBeApproximatelyEqual(this float actual, float expected, float tolerance);
        [Obsolete("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
        [Conditional("UNITY_ASSERTIONS")]
        public static void MustBeApproximatelyEqual(this float actual, float expected, float tolerance, string message);
        [Obsolete("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
        [Conditional("UNITY_ASSERTIONS")]
        public static void MustNotBeApproximatelyEqual(this float actual, float expected);
        [Conditional("UNITY_ASSERTIONS")]
        [Obsolete("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
        public static void MustNotBeApproximatelyEqual(this float actual, float expected, string message);
        [Conditional("UNITY_ASSERTIONS")]
        [Obsolete("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
        public static void MustNotBeApproximatelyEqual(this float actual, float expected, float tolerance);
        [Conditional("UNITY_ASSERTIONS")]
        [Obsolete("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
        public static void MustNotBeApproximatelyEqual(this float actual, float expected, float tolerance, string message);
        [Obsolete("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
        [Conditional("UNITY_ASSERTIONS")]
        public static void MustBeEqual<T>(this T actual, T expected);
        [Conditional("UNITY_ASSERTIONS")]
        [Obsolete("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
        public static void MustBeEqual<T>(this T actual, T expected, string message);
        [Conditional("UNITY_ASSERTIONS")]
        [Obsolete("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
        public static void MustNotBeEqual<T>(this T actual, T expected);
        [Obsolete("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
        [Conditional("UNITY_ASSERTIONS")]
        public static void MustNotBeEqual<T>(this T actual, T expected, string message);
        [Obsolete("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
        [Conditional("UNITY_ASSERTIONS")]
        public static void MustBeNull<T>(this T expected) where T : class;
        [Conditional("UNITY_ASSERTIONS")]
        [Obsolete("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
        public static void MustBeNull<T>(this T expected, string message) where T : class;
        [Conditional("UNITY_ASSERTIONS")]
        [Obsolete("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
        public static void MustNotBeNull<T>(this T expected) where T : class;
        [Conditional("UNITY_ASSERTIONS")]
        [Obsolete("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
        public static void MustNotBeNull<T>(this T expected, string message) where T : class;
    }
}
using System.Collections.Generic;

namespace UnityEngine.Assertions.Comparers
{
    public class FloatComparer : IEqualityComparer<float>
    {
        public static readonly FloatComparer s_ComparerWithDefaultTolerance;
        public const float kEpsilon = 1E-05F;

        public FloatComparer();
        public FloatComparer(bool relative);
        public FloatComparer(float error);
        public FloatComparer(float error, bool relative);

        public bool Equals(float a, float b);
        public int GetHashCode(float obj);
        public static bool AreEqual(float expected, float actual, float error);
        public static bool AreEqualRelative(float expected, float actual, float error);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Apple
{
    [NativeHeader("Runtime/Export/Apple/FrameCaptureMetalScriptBindings.h")]
    public enum FrameCaptureDestination
    {
        DevTools = 1,
        GPUTraceDocument = 2
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Apple
{
    [NativeHeader("Runtime/Export/Apple/FrameCaptureMetalScriptBindings.h")]
    [NativeConditional("PLATFORM_IOS || PLATFORM_TVOS || PLATFORM_OSX")]
    public class FrameCapture
    {
        public static bool IsDestinationSupported(FrameCaptureDestination dest);
        public static void BeginCaptureToXcode();
        public static void BeginCaptureToFile(string path);
        public static void EndCapture();
        public static void CaptureNextFrameToXcode();
        public static void CaptureNextFrameToFile(string path);
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine.Apple.TV
{
    [EditorBrowsable(Never)]
    [Obsolete("UnityEngine.Apple.TV.Remote has been deprecated. Use UnityEngine.tvOS.Remote instead (UnityUpgradable) -> UnityEngine.tvOS.Remote", True)]
    public sealed class Remote
    {
        public Remote();

        public static bool allowExitToHome { get; set; }
        public static bool allowRemoteRotation { get; set; }
        public static bool reportAbsoluteDpadValues { get; set; }
        public static bool touchesEnabled { get; set; }
    }
}
using UnityEngine.Bindings;
using UnityEngine.Internal;

namespace UnityEngine.Apple.ReplayKit
{
    [NativeHeader("PlatformDependent/iPhonePlayer/IOSScriptBindings.h")]
    public static class ReplayKit
    {
        public static bool APIAvailable { get; }
        public static bool broadcastingAPIAvailable { get; }
        public static bool recordingAvailable { get; }
        public static bool isRecording { get; }
        public static bool isBroadcasting { get; }
        public static bool isBroadcastingPaused { get; }
        public static bool isPreviewControllerActive { get; }
        public static bool cameraEnabled { get; set; }
        public static bool microphoneEnabled { get; set; }
        public static string broadcastURL { get; }
        public static string lastError { get; }

        public static bool StartRecording([DefaultValue("false")] bool enableMicrophone, [DefaultValue("false")] bool enableCamera);
        public static bool StartRecording(bool enableMicrophone);
        public static bool StartRecording();
        public static void StartBroadcasting(BroadcastStatusCallback callback, [DefaultValue("false")] bool enableMicrophone, [DefaultValue("false")] bool enableCamera);
        public static void StartBroadcasting(BroadcastStatusCallback callback, bool enableMicrophone);
        public static void StartBroadcasting(BroadcastStatusCallback callback);
        [FreeFunction("UnityReplayKitStopRecording")]
        [NativeConditional("PLATFORM_IOS || PLATFORM_TVOS")]
        public static bool StopRecording();
        [FreeFunction("UnityReplayKitStopBroadcasting")]
        [NativeConditional("PLATFORM_IOS || PLATFORM_TVOS")]
        public static void StopBroadcasting();
        [FreeFunction("UnityReplayKitPauseBroadcasting")]
        [NativeConditional("PLATFORM_IOS || PLATFORM_TVOS")]
        public static void PauseBroadcasting();
        [FreeFunction("UnityReplayKitResumeBroadcasting")]
        [NativeConditional("PLATFORM_IOS || PLATFORM_TVOS")]
        public static void ResumeBroadcasting();
        [NativeConditional("PLATFORM_IOS || PLATFORM_TVOS")]
        [FreeFunction("UnityReplayKitPreview")]
        public static bool Preview();
        [FreeFunction("UnityReplayKitDiscard")]
        [NativeConditional("PLATFORM_IOS || PLATFORM_TVOS")]
        public static bool Discard();
        public static bool ShowCameraPreviewAt(float posX, float posY);
        [NativeConditional("PLATFORM_IOS || PLATFORM_TVOS")]
        [FreeFunction("UnityReplayKitShowCameraPreviewAt")]
        public static bool ShowCameraPreviewAt(float posX, float posY, float width, float height);
        [NativeConditional("PLATFORM_IOS || PLATFORM_TVOS")]
        [FreeFunction("UnityReplayKitHideCameraPreview")]
        public static void HideCameraPreview();

        public delegate void BroadcastStatusCallback(bool hasStarted, string errorMessage);
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine.TestTools
{
    [AttributeUsage(Assembly, Class, Struct, Constructor, Method)]
    [UsedByNativeCode]
    public class ExcludeFromCoverageAttribute : Attribute
    {
        public ExcludeFromCoverageAttribute();
    }
}
using System.Reflection;
using UnityEngine.Bindings;

namespace UnityEngine.TestTools
{
    [NativeType(Custom, "ManagedCoveredSequencePoint", Header = "Runtime/Scripting/ScriptingCoverage.bindings.h")]
    public struct CoveredSequencePoint
    {
        public MethodBase method;
        public uint ilOffset;
        public uint hitCount;
        public string filename;
        public uint line;
        public uint column;
    }
}
using System.Reflection;
using UnityEngine.Bindings;

namespace UnityEngine.TestTools
{
    [NativeType(Custom, "ManagedCoveredMethodStats", Header = "Runtime/Scripting/ScriptingCoverage.bindings.h")]
    public struct CoveredMethodStats
    {
        public MethodBase method;
        public int totalSequencePoints;
        public int uncoveredSequencePoints;

        public override string ToString();
    }
}
using System;
using System.Reflection;
using UnityEngine.Bindings;

namespace UnityEngine.TestTools
{
    [NativeClass("ScriptingCoverage")]
    [NativeType("Runtime/Scripting/ScriptingCoverage.h")]
    public static class Coverage
    {
        public static bool enabled { get; set; }

        public static CoveredSequencePoint[] GetSequencePointsFor(MethodBase method);
        public static CoveredMethodStats GetStatsFor(MethodBase method);
        public static CoveredMethodStats[] GetStatsFor(MethodBase[] methods);
        public static CoveredMethodStats[] GetStatsFor(Type type);
        [FreeFunction("ScriptingCoverageGetStatsForAllCoveredMethodsFromScripting", ThrowsException = True)]
        public static CoveredMethodStats[] GetStatsForAllCoveredMethods();
        public static void ResetFor(MethodBase method);
        [FreeFunction("ScriptingCoverageResetAllFromScripting", ThrowsException = True)]
        public static void ResetAll();
    }
}
-------- {UnityEngine.CrashReportingModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.CrashReportingModule.dll)}:    0 --------
using UnityEngine.Bindings;

namespace UnityEngine.CrashReportHandler
{
    [StaticAccessor("CrashReporting::CrashReporter::Get()", Dot)]
    [NativeHeader("Modules/CrashReporting/Public/CrashReporter.h")]
    public class CrashReportHandler
    {
        [NativeProperty("Enabled")]
        public static bool enableCaptureExceptions { get; set; }
        [NativeThrows]
        public static uint logBufferSize { get; set; }

        [NativeThrows]
        public static string GetUserMetadata(string key);
        [NativeThrows]
        public static void SetUserMetadata(string key, string value);
    }
}
-------- {UnityEngine.DSPGraphModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.DSPGraphModule.dll)}:    9 --------
-------- {UnityEngine.DirectorModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.DirectorModule.dll)}:    0 --------
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Playables
{
    [NativeHeader("Runtime/Mono/MonoBehaviour.h")]
    [NativeHeader("Modules/Director/PlayableDirector.h")]
    [RequiredByNativeCode]
    public class PlayableDirector : Behaviour, IExposedPropertyTable
    {
        public PlayableDirector();

        public PlayState state { get; }
        public DirectorWrapMode extrapolationMode { get; set; }
        public PlayableAsset playableAsset { get; set; }
        public PlayableGraph playableGraph { get; }
        public bool playOnAwake { get; set; }
        public DirectorUpdateMode timeUpdateMode { get; set; }
        public double time { get; set; }
        public double initialTime { get; set; }
        public double duration { get; }

        public event Action<PlayableDirector> played;
        public event Action<PlayableDirector> paused;
        public event Action<PlayableDirector> stopped;

        public void DeferredEvaluate();
        public void Play(PlayableAsset asset);
        public void Play(PlayableAsset asset, DirectorWrapMode mode);
        public void SetGenericBinding(Object key, Object value);
        [NativeThrows]
        public void Evaluate();
        [NativeThrows]
        public void Play();
        public void Stop();
        public void Pause();
        public void Resume();
        [NativeThrows]
        public void RebuildGraph();
        public void ClearReferenceValue(PropertyName id);
        public void SetReferenceValue(PropertyName id, Object value);
        public Object GetReferenceValue(PropertyName id, out bool idValid);
        [NativeMethod("GetBindingFor")]
        public Object GetGenericBinding(Object key);
        [NativeMethod("ClearBindingFor")]
        public void ClearGenericBinding(Object key);
        [NativeThrows]
        public void RebindPlayableGraphOutputs();
    }
}
-------- {UnityEngine.GIModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.GIModule.dll)}:   -1 --------
-------- {UnityEngine.GameCenterModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.GameCenterModule.dll)}:   28 --------
using System;
using UnityEngine.SocialPlatforms;

namespace UnityEngine
{
    public static class Social
    {
        public static ISocialPlatform Active { get; set; }
        public static ILocalUser localUser { get; }

        public static void LoadUsers(string[] userIDs, Action<IUserProfile[]> callback);
        public static void ReportProgress(string achievementID, double progress, Action<bool> callback);
        public static void LoadAchievementDescriptions(Action<IAchievementDescription[]> callback);
        public static void LoadAchievements(Action<IAchievement[]> callback);
        public static void ReportScore(long score, string board, Action<bool> callback);
        public static void LoadScores(string leaderboardID, Action<IScore[]> callback);
        public static ILeaderboard CreateLeaderboard();
        public static IAchievement CreateAchievement();
        public static void ShowAchievementsUI();
        public static void ShowLeaderboardUI();
    }
}
using System;

namespace UnityEngine.SocialPlatforms
{
    public class Local : ISocialPlatform
    {
        public Local();

        public ILocalUser localUser { get; }

        public void LoadUsers(string[] userIDs, Action<IUserProfile[]> callback);
        public void ReportProgress(string id, double progress, Action<bool> callback);
        public void LoadAchievementDescriptions(Action<IAchievementDescription[]> callback);
        public void LoadAchievements(Action<IAchievement[]> callback);
        public void ReportScore(long score, string board, Action<bool> callback);
        public void LoadScores(string leaderboardID, Action<IScore[]> callback);
        public void ShowAchievementsUI();
        public void ShowLeaderboardUI();
        public ILeaderboard CreateLeaderboard();
        public IAchievement CreateAchievement();
    }
}
using System;

namespace UnityEngine.SocialPlatforms
{
    public interface ISocialPlatform
    {
        ILocalUser localUser { get; }

        void LoadUsers(string[] userIDs, Action<IUserProfile[]> callback);
        void ReportProgress(string achievementID, double progress, Action<bool> callback);
        void LoadAchievementDescriptions(Action<IAchievementDescription[]> callback);
        void LoadAchievements(Action<IAchievement[]> callback);
        IAchievement CreateAchievement();
        void ReportScore(long score, string board, Action<bool> callback);
        void LoadScores(string leaderboardID, Action<IScore[]> callback);
        ILeaderboard CreateLeaderboard();
        void ShowAchievementsUI();
        void ShowLeaderboardUI();
        void Authenticate(ILocalUser user, Action<bool> callback);
        void Authenticate(ILocalUser user, Action<bool, string> callback);
        void LoadFriends(ILocalUser user, Action<bool> callback);
        void LoadScores(ILeaderboard board, Action<bool> callback);
        bool GetLoading(ILeaderboard board);
    }
}
using System;

namespace UnityEngine.SocialPlatforms
{
    public interface ILocalUser : IUserProfile
    {
        IUserProfile[] friends { get; }
        bool authenticated { get; }
        bool underage { get; }

        void Authenticate(Action<bool> callback);
        void Authenticate(Action<bool, string> callback);
        void LoadFriends(Action<bool> callback);
    }
}
namespace UnityEngine.SocialPlatforms
{
    public enum UserState
    {
        Online = 0,
        OnlineAndAway = 1,
        OnlineAndBusy = 2,
        Offline = 3,
        Playing = 4
    }
}
namespace UnityEngine.SocialPlatforms
{
    public interface IUserProfile
    {
        string userName { get; }
        string id { get; }
        bool isFriend { get; }
        UserState state { get; }
        Texture2D image { get; }
    }
}
using System;

namespace UnityEngine.SocialPlatforms
{
    public interface IAchievement
    {
        string id { get; set; }
        double percentCompleted { get; set; }
        bool completed { get; }
        bool hidden { get; }
        DateTime lastReportedDate { get; }

        void ReportProgress(Action<bool> callback);
    }
}
namespace UnityEngine.SocialPlatforms
{
    public interface IAchievementDescription
    {
        string id { get; set; }
        string title { get; }
        Texture2D image { get; }
        string achievedDescription { get; }
        string unachievedDescription { get; }
        bool hidden { get; }
        int points { get; }
    }
}
using System;

namespace UnityEngine.SocialPlatforms
{
    public interface IScore
    {
        string leaderboardID { get; set; }
        long value { get; set; }
        DateTime date { get; }
        string formattedValue { get; }
        string userID { get; }
        int rank { get; }

        void ReportScore(Action<bool> callback);
    }
}
namespace UnityEngine.SocialPlatforms
{
    public enum UserScope
    {
        Global = 0,
        FriendsOnly = 1
    }
}
namespace UnityEngine.SocialPlatforms
{
    public enum TimeScope
    {
        Today = 0,
        Week = 1,
        AllTime = 2
    }
}
namespace UnityEngine.SocialPlatforms
{
    public struct Range
    {
        public int from;
        public int count;

        public Range(int fromValue, int valueCount);
    }
}
using System;

namespace UnityEngine.SocialPlatforms
{
    public interface ILeaderboard
    {
        bool loading { get; }
        string id { get; set; }
        UserScope userScope { get; set; }
        Range range { get; set; }
        TimeScope timeScope { get; set; }
        IScore localUserScore { get; }
        uint maxRange { get; }
        IScore[] scores { get; }
        string title { get; }

        void SetUserFilter(string[] userIDs);
        void LoadScores(Action<bool> callback);
    }
}
using System;

namespace UnityEngine.SocialPlatforms.Impl
{
    public class LocalUser : UserProfile, ILocalUser
    {
        public LocalUser();

        public IUserProfile[] friends { get; }
        public bool authenticated { get; }
        public bool underage { get; }

        public void Authenticate(Action<bool> callback);
        public void Authenticate(Action<bool, string> callback);
        public void LoadFriends(Action<bool> callback);
        public void SetFriends(IUserProfile[] friends);
        public void SetAuthenticated(bool value);
        public void SetUnderage(bool value);
    }
}
using System;

namespace UnityEngine.SocialPlatforms.Impl
{
    public class UserProfile : IUserProfile
    {
        protected string m_UserName;
        protected string m_ID;
        protected bool m_IsFriend;
        protected UserState m_State;
        protected Texture2D m_Image;

        public UserProfile();
        public UserProfile(string name, string id, bool friend);
        public UserProfile(string name, string id, bool friend, UserState state, Texture2D image);
        public UserProfile(string name, string teamId, string gameId, bool friend, UserState state, Texture2D image);

        public string userName { get; }
        public string id { get; }
        [Obsolete("legacyId returns playerID from GKPlayer, which became obsolete in iOS 12.4 . id returns playerID for devices running versions before iOS 12.4, and the newer teamPlayerID for later versions. Please use IUserProfile.id or UserProfile.id instead (UnityUpgradable) -> id")]
        public string legacyId { get; }
        public string gameId { get; }
        public bool isFriend { get; }
        public UserState state { get; }
        public Texture2D image { get; }

        public override string ToString();
        public void SetUserName(string name);
        public void SetUserID(string id);
        public void SetLegacyUserID(string id);
        public void SetUserGameID(string id);
        public void SetImage(Texture2D image);
        public void SetIsFriend(bool value);
        public void SetState(UserState state);
    }
}
using System;

namespace UnityEngine.SocialPlatforms.Impl
{
    public class Achievement : IAchievement
    {
        public Achievement(string id, double percentCompleted, bool completed, bool hidden, DateTime lastReportedDate);
        public Achievement(string id, double percent);
        public Achievement();

        public string id { get; set; }
        public double percentCompleted { get; set; }
        public bool completed { get; }
        public bool hidden { get; }
        public DateTime lastReportedDate { get; }

        public override string ToString();
        public void ReportProgress(Action<bool> callback);
        public void SetCompleted(bool value);
        public void SetHidden(bool value);
        public void SetLastReportedDate(DateTime date);
    }
}
namespace UnityEngine.SocialPlatforms.Impl
{
    public class AchievementDescription : IAchievementDescription
    {
        public AchievementDescription(string id, string title, Texture2D image, string achievedDescription, string unachievedDescription, bool hidden, int points);

        public string id { get; set; }
        public string title { get; }
        public Texture2D image { get; }
        public string achievedDescription { get; }
        public string unachievedDescription { get; }
        public bool hidden { get; }
        public int points { get; }

        public override string ToString();
        public void SetImage(Texture2D image);
    }
}
using System;

namespace UnityEngine.SocialPlatforms.Impl
{
    public class Score : IScore
    {
        public Score();
        public Score(string leaderboardID, long value);
        public Score(string leaderboardID, long value, string userID, DateTime date, string formattedValue, int rank);

        public string leaderboardID { get; set; }
        public long value { get; set; }
        public DateTime date { get; }
        public string formattedValue { get; }
        public string userID { get; }
        public int rank { get; }

        public override string ToString();
        public void ReportScore(Action<bool> callback);
        public void SetDate(DateTime date);
        public void SetFormattedValue(string value);
        public void SetUserID(string userID);
        public void SetRank(int rank);
    }
}
using System;

namespace UnityEngine.SocialPlatforms.Impl
{
    public class Leaderboard : ILeaderboard
    {
        public Leaderboard();

        public bool loading { get; }
        public string id { get; set; }
        public UserScope userScope { get; set; }
        public Range range { get; set; }
        public TimeScope timeScope { get; set; }
        public IScore localUserScore { get; }
        public uint maxRange { get; }
        public IScore[] scores { get; }
        public string title { get; }

        public void SetUserFilter(string[] userIDs);
        public override string ToString();
        public void LoadScores(Action<bool> callback);
        public void SetLocalUserScore(IScore score);
        public void SetMaxRange(uint maxRange);
        public void SetScores(IScore[] scores);
        public void SetTitle(string title);
        public string[] GetUserFilter();
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.SocialPlatforms.GameCenter
{
    [NativeHeader("Modules/GameCenter/Public/GameCenterScriptingGlue.h")]
    [RequiredByNativeCode]
    public class GameCenterPlatform : ISocialPlatform
    {
        public GameCenterPlatform();

        public ILocalUser localUser { get; }

        public void LoadAchievementDescriptions(Action<IAchievementDescription[]> callback);
        public void ReportProgress(string id, double progress, Action<bool> callback);
        public void LoadAchievements(Action<IAchievement[]> callback);
        public void ReportScore(long score, string board, Action<bool> callback);
        public void LoadScores(string category, Action<IScore[]> callback);
        public void LoadScores(ILeaderboard board, Action<bool> callback);
        public bool GetLoading(ILeaderboard board);
        public void ShowAchievementsUI();
        public void ShowLeaderboardUI();
        public void LoadUsers(string[] userIds, Action<IUserProfile[]> callback);
        public ILeaderboard CreateLeaderboard();
        public IAchievement CreateAchievement();
        public static void ResetAllAchievements(Action<bool> callback);
        public static void ShowDefaultAchievementCompletionBanner(bool value);
        public static void ShowLeaderboardUI(string leaderboardID, TimeScope timeScope);
    }
}
-------- {UnityEngine.GridModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.GridModule.dll)}:    3 --------
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeType(Header = "Modules/Grid/Public/Grid.h")]
    [RequireComponent(typeof(Transform))]
    [NativeHeader("Modules/Grid/Public/GridMarshalling.h")]
    public sealed class Grid : GridLayout
    {
        public Grid();

        public Vector3 cellSize { get; set; }
        public Vector3 cellGap { get; set; }
        public GridLayout.CellLayout cellLayout { get; set; }
        public GridLayout.CellSwizzle cellSwizzle { get; set; }

        public Vector3 GetCellCenterLocal(Vector3Int position);
        public Vector3 GetCellCenterWorld(Vector3Int position);
        [FreeFunction("GridBindings::CellSwizzle")]
        public static Vector3 Swizzle(GridLayout.CellSwizzle swizzle, Vector3 position);
        [FreeFunction("GridBindings::InverseCellSwizzle")]
        public static Vector3 InverseSwizzle(GridLayout.CellSwizzle swizzle, Vector3 position);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeType(Header = "Modules/Grid/Public/Grid.h")]
    [NativeHeader("Modules/Grid/Public/GridMarshalling.h")]
    [RequireComponent(typeof(Transform))]
    public class GridLayout : Behaviour
    {
        public GridLayout();

        public Vector3 cellSize { get; }
        public Vector3 cellGap { get; }
        public CellLayout cellLayout { get; }
        public CellSwizzle cellSwizzle { get; }

        [FreeFunction("GridLayoutBindings::GetBoundsLocal", HasExplicitThis = True)]
        public Bounds GetBoundsLocal(Vector3Int cellPosition);
        public Bounds GetBoundsLocal(Vector3 origin, Vector3 size);
        [FreeFunction("GridLayoutBindings::CellToLocal", HasExplicitThis = True)]
        public Vector3 CellToLocal(Vector3Int cellPosition);
        [FreeFunction("GridLayoutBindings::LocalToCell", HasExplicitThis = True)]
        public Vector3Int LocalToCell(Vector3 localPosition);
        [FreeFunction("GridLayoutBindings::CellToLocalInterpolated", HasExplicitThis = True)]
        public Vector3 CellToLocalInterpolated(Vector3 cellPosition);
        [FreeFunction("GridLayoutBindings::LocalToCellInterpolated", HasExplicitThis = True)]
        public Vector3 LocalToCellInterpolated(Vector3 localPosition);
        [FreeFunction("GridLayoutBindings::CellToWorld", HasExplicitThis = True)]
        public Vector3 CellToWorld(Vector3Int cellPosition);
        [FreeFunction("GridLayoutBindings::WorldToCell", HasExplicitThis = True)]
        public Vector3Int WorldToCell(Vector3 worldPosition);
        [FreeFunction("GridLayoutBindings::LocalToWorld", HasExplicitThis = True)]
        public Vector3 LocalToWorld(Vector3 localPosition);
        [FreeFunction("GridLayoutBindings::WorldToLocal", HasExplicitThis = True)]
        public Vector3 WorldToLocal(Vector3 worldPosition);
        [FreeFunction("GridLayoutBindings::GetLayoutCellCenter", HasExplicitThis = True)]
        public Vector3 GetLayoutCellCenter();

        public enum CellLayout
        {
            Rectangle = 0,
            Hexagon = 1,
            Isometric = 2,
            IsometricZAsY = 3
        }
        public enum CellSwizzle
        {
            XYZ = 0,
            XZY = 1,
            YXZ = 2,
            YZX = 3,
            ZXY = 4,
            ZYX = 5
        }
    }
}
-------- {UnityEngine.HotReloadModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.HotReloadModule.dll)}:   -1 --------
-------- {UnityEngine.IMGUIModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.IMGUIModule.dll)}:   66 --------
using System;
using System.ComponentModel;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [StaticAccessor("GUIEvent", DoubleColon)]
    [NativeHeader("Modules/IMGUI/Event.bindings.h")]
    public sealed class Event
    {
        public Event();
        public Event(int displayIndex);
        public Event(Event other);

        ~Event();

        [NativeProperty("type", False, Field)]
        public EventType rawType { get; }
        [NativeProperty("mousePosition", False, Field)]
        public Vector2 mousePosition { get; set; }
        [NativeProperty("delta", False, Field)]
        public Vector2 delta { get; set; }
        [NativeProperty("pointerType", False, Field)]
        public PointerType pointerType { get; set; }
        [NativeProperty("button", False, Field)]
        public int button { get; set; }
        [NativeProperty("modifiers", False, Field)]
        public EventModifiers modifiers { get; set; }
        [NativeProperty("pressure", False, Field)]
        public float pressure { get; set; }
        [NativeProperty("clickCount", False, Field)]
        public int clickCount { get; set; }
        [NativeProperty("character", False, Field)]
        public char character { get; set; }
        [NativeProperty("keycode", False, Field)]
        public KeyCode keyCode { get; set; }
        [NativeProperty("displayIndex", False, Field)]
        public int displayIndex { get; set; }
        public EventType type { get; set; }
        public string commandName { get; set; }
        [Obsolete("Use HandleUtility.GUIPointToWorldRay(Event.current.mousePosition);", True)]
        [EditorBrowsable(Never)]
        public Ray mouseRay { get; set; }
        public bool shift { get; set; }
        public bool control { get; set; }
        public bool alt { get; set; }
        public bool command { get; set; }
        public bool capsLock { get; set; }
        public bool numeric { get; set; }
        public bool functionKey { get; }
        public static Event current { get; set; }
        public bool isKey { get; }
        public bool isMouse { get; }
        public bool isScrollWheel { get; }

        [FreeFunction("GUIEvent::GetTypeForControl", HasExplicitThis = True)]
        public EventType GetTypeForControl(int controlID);
        public static bool PopEvent([NotNull("ArgumentNullException")] Event outEvent);
        public static int GetEventCount();
        public static Event KeyboardEvent(string key);
        public override int GetHashCode();
        public override bool Equals(object obj);
        public override string ToString();
        public void Use();
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    public enum EventType
    {
        MouseDown = 0,
        MouseUp = 1,
        MouseMove = 2,
        MouseDrag = 3,
        KeyDown = 4,
        KeyUp = 5,
        ScrollWheel = 6,
        Repaint = 7,
        Layout = 8,
        DragUpdated = 9,
        DragPerform = 10,
        DragExited = 15,
        Ignore = 11,
        Used = 12,
        ValidateCommand = 13,
        ExecuteCommand = 14,
        ContextClick = 16,
        MouseEnterWindow = 20,
        MouseLeaveWindow = 21,
        TouchDown = 30,
        TouchUp = 31,
        TouchMove = 32,
        TouchEnter = 33,
        TouchLeave = 34,
        TouchStationary = 35,
        [EditorBrowsable(Never)]
        [Obsolete("Use MouseDown instead (UnityUpgradable) -> MouseDown", True)]
        mouseDown = 0,
        [EditorBrowsable(Never)]
        [Obsolete("Use MouseUp instead (UnityUpgradable) -> MouseUp", True)]
        mouseUp = 1,
        [EditorBrowsable(Never)]
        [Obsolete("Use MouseMove instead (UnityUpgradable) -> MouseMove", True)]
        mouseMove = 2,
        [EditorBrowsable(Never)]
        [Obsolete("Use MouseDrag instead (UnityUpgradable) -> MouseDrag", True)]
        mouseDrag = 3,
        [EditorBrowsable(Never)]
        [Obsolete("Use KeyDown instead (UnityUpgradable) -> KeyDown", True)]
        keyDown = 4,
        [Obsolete("Use KeyUp instead (UnityUpgradable) -> KeyUp", True)]
        [EditorBrowsable(Never)]
        keyUp = 5,
        [Obsolete("Use ScrollWheel instead (UnityUpgradable) -> ScrollWheel", True)]
        [EditorBrowsable(Never)]
        scrollWheel = 6,
        [Obsolete("Use Repaint instead (UnityUpgradable) -> Repaint", True)]
        [EditorBrowsable(Never)]
        repaint = 7,
        [Obsolete("Use Layout instead (UnityUpgradable) -> Layout", True)]
        [EditorBrowsable(Never)]
        layout = 8,
        [Obsolete("Use DragUpdated instead (UnityUpgradable) -> DragUpdated", True)]
        [EditorBrowsable(Never)]
        dragUpdated = 9,
        [Obsolete("Use DragPerform instead (UnityUpgradable) -> DragPerform", True)]
        [EditorBrowsable(Never)]
        dragPerform = 10,
        [EditorBrowsable(Never)]
        [Obsolete("Use Ignore instead (UnityUpgradable) -> Ignore", True)]
        ignore = 11,
        [EditorBrowsable(Never)]
        [Obsolete("Use Used instead (UnityUpgradable) -> Used", True)]
        used = 12
    }
}
using System;

namespace UnityEngine
{
    [Flags]
    public enum EventModifiers
    {
        None = 0,
        Shift = 1,
        Control = 2,
        Alt = 4,
        Command = 8,
        Numeric = 16,
        CapsLock = 32,
        FunctionKey = 64
    }
}
namespace UnityEngine
{
    public enum PointerType
    {
        Mouse = 0,
        Touch = 1,
        Pen = 2
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/IMGUI/GUISkin.bindings.h")]
    [NativeHeader("Modules/IMGUI/GUI.bindings.h")]
    public class GUI
    {
        public GUI();

        public static Color color { get; set; }
        public static Color backgroundColor { get; set; }
        public static Color contentColor { get; set; }
        public static bool changed { get; set; }
        public static bool enabled { get; set; }
        public static int depth { get; set; }
        public static GUISkin skin { get; set; }
        public static Matrix4x4 matrix { get; set; }
        public static string tooltip { get; set; }
        protected static string mouseTooltip { get; }
        protected static Rect tooltipRect { get; set; }

        [FreeFunction("GetGUIState().SetNameOfNextControl")]
        public static void SetNextControlName(string name);
        [FreeFunction("GetGUIState().GetNameOfFocusedControl")]
        public static string GetNameOfFocusedControl();
        [FreeFunction("GetGUIState().FocusKeyboardControl")]
        public static void FocusControl(string name);
        public static void DragWindow(Rect position);
        public static void BringWindowToFront(int windowID);
        public static void BringWindowToBack(int windowID);
        public static void FocusWindow(int windowID);
        public static void UnfocusWindow();
        public static void Label(Rect position, string text);
        public static void Label(Rect position, Texture image);
        public static void Label(Rect position, GUIContent content);
        public static void Label(Rect position, string text, GUIStyle style);
        public static void Label(Rect position, Texture image, GUIStyle style);
        public static void Label(Rect position, GUIContent content, GUIStyle style);
        public static void DrawTexture(Rect position, Texture image);
        public static void DrawTexture(Rect position, Texture image, ScaleMode scaleMode);
        public static void DrawTexture(Rect position, Texture image, ScaleMode scaleMode, bool alphaBlend);
        public static void DrawTexture(Rect position, Texture image, ScaleMode scaleMode, bool alphaBlend, float imageAspect);
        public static void DrawTexture(Rect position, Texture image, ScaleMode scaleMode, bool alphaBlend, float imageAspect, Color color, float borderWidth, float borderRadius);
        public static void DrawTexture(Rect position, Texture image, ScaleMode scaleMode, bool alphaBlend, float imageAspect, Color color, Vector4 borderWidths, float borderRadius);
        public static void DrawTexture(Rect position, Texture image, ScaleMode scaleMode, bool alphaBlend, float imageAspect, Color color, Vector4 borderWidths, Vector4 borderRadiuses);
        public static void DrawTextureWithTexCoords(Rect position, Texture image, Rect texCoords);
        public static void DrawTextureWithTexCoords(Rect position, Texture image, Rect texCoords, bool alphaBlend);
        public static void Box(Rect position, string text);
        public static void Box(Rect position, Texture image);
        public static void Box(Rect position, GUIContent content);
        public static void Box(Rect position, string text, GUIStyle style);
        public static void Box(Rect position, Texture image, GUIStyle style);
        public static void Box(Rect position, GUIContent content, GUIStyle style);
        public static bool Button(Rect position, string text);
        public static bool Button(Rect position, Texture image);
        public static bool Button(Rect position, GUIContent content);
        public static bool Button(Rect position, string text, GUIStyle style);
        public static bool Button(Rect position, Texture image, GUIStyle style);
        public static bool Button(Rect position, GUIContent content, GUIStyle style);
        public static bool RepeatButton(Rect position, string text);
        public static bool RepeatButton(Rect position, Texture image);
        public static bool RepeatButton(Rect position, GUIContent content);
        public static bool RepeatButton(Rect position, string text, GUIStyle style);
        public static bool RepeatButton(Rect position, Texture image, GUIStyle style);
        public static bool RepeatButton(Rect position, GUIContent content, GUIStyle style);
        public static string TextField(Rect position, string text);
        public static string TextField(Rect position, string text, int maxLength);
        public static string TextField(Rect position, string text, GUIStyle style);
        public static string TextField(Rect position, string text, int maxLength, GUIStyle style);
        public static string PasswordField(Rect position, string password, char maskChar);
        public static string PasswordField(Rect position, string password, char maskChar, int maxLength);
        public static string PasswordField(Rect position, string password, char maskChar, GUIStyle style);
        public static string PasswordField(Rect position, string password, char maskChar, int maxLength, GUIStyle style);
        public static string TextArea(Rect position, string text);
        public static string TextArea(Rect position, string text, int maxLength);
        public static string TextArea(Rect position, string text, GUIStyle style);
        public static string TextArea(Rect position, string text, int maxLength, GUIStyle style);
        public static bool Toggle(Rect position, bool value, string text);
        public static bool Toggle(Rect position, bool value, Texture image);
        public static bool Toggle(Rect position, bool value, GUIContent content);
        public static bool Toggle(Rect position, bool value, string text, GUIStyle style);
        public static bool Toggle(Rect position, bool value, Texture image, GUIStyle style);
        public static bool Toggle(Rect position, bool value, GUIContent content, GUIStyle style);
        public static bool Toggle(Rect position, int id, bool value, GUIContent content, GUIStyle style);
        public static int Toolbar(Rect position, int selected, string[] texts);
        public static int Toolbar(Rect position, int selected, Texture[] images);
        public static int Toolbar(Rect position, int selected, GUIContent[] contents);
        public static int Toolbar(Rect position, int selected, string[] texts, GUIStyle style);
        public static int Toolbar(Rect position, int selected, Texture[] images, GUIStyle style);
        public static int Toolbar(Rect position, int selected, GUIContent[] contents, GUIStyle style);
        public static int Toolbar(Rect position, int selected, GUIContent[] contents, GUIStyle style, ToolbarButtonSize buttonSize);
        public static int SelectionGrid(Rect position, int selected, string[] texts, int xCount);
        public static int SelectionGrid(Rect position, int selected, Texture[] images, int xCount);
        public static int SelectionGrid(Rect position, int selected, GUIContent[] content, int xCount);
        public static int SelectionGrid(Rect position, int selected, string[] texts, int xCount, GUIStyle style);
        public static int SelectionGrid(Rect position, int selected, Texture[] images, int xCount, GUIStyle style);
        public static int SelectionGrid(Rect position, int selected, GUIContent[] contents, int xCount, GUIStyle style);
        public static float HorizontalSlider(Rect position, float value, float leftValue, float rightValue);
        public static float HorizontalSlider(Rect position, float value, float leftValue, float rightValue, GUIStyle slider, GUIStyle thumb);
        public static float HorizontalSlider(Rect position, float value, float leftValue, float rightValue, GUIStyle slider, GUIStyle thumb, GUIStyle thumbExtent);
        public static float VerticalSlider(Rect position, float value, float topValue, float bottomValue);
        public static float VerticalSlider(Rect position, float value, float topValue, float bottomValue, GUIStyle slider, GUIStyle thumb);
        public static float VerticalSlider(Rect position, float value, float topValue, float bottomValue, GUIStyle slider, GUIStyle thumb, GUIStyle thumbExtent);
        public static float Slider(Rect position, float value, float size, float start, float end, GUIStyle slider, GUIStyle thumb, bool horiz, int id, GUIStyle thumbExtent = null);
        public static float HorizontalScrollbar(Rect position, float value, float size, float leftValue, float rightValue);
        public static float HorizontalScrollbar(Rect position, float value, float size, float leftValue, float rightValue, GUIStyle style);
        public static float VerticalScrollbar(Rect position, float value, float size, float topValue, float bottomValue);
        public static float VerticalScrollbar(Rect position, float value, float size, float topValue, float bottomValue, GUIStyle style);
        public static void BeginClip(Rect position, Vector2 scrollOffset, Vector2 renderOffset, bool resetOffset);
        public static void BeginGroup(Rect position);
        public static void BeginGroup(Rect position, string text);
        public static void BeginGroup(Rect position, Texture image);
        public static void BeginGroup(Rect position, GUIContent content);
        public static void BeginGroup(Rect position, GUIStyle style);
        public static void BeginGroup(Rect position, string text, GUIStyle style);
        public static void BeginGroup(Rect position, Texture image, GUIStyle style);
        public static void BeginGroup(Rect position, GUIContent content, GUIStyle style);
        public static void EndGroup();
        public static void BeginClip(Rect position);
        public static void EndClip();
        public static Vector2 BeginScrollView(Rect position, Vector2 scrollPosition, Rect viewRect);
        public static Vector2 BeginScrollView(Rect position, Vector2 scrollPosition, Rect viewRect, bool alwaysShowHorizontal, bool alwaysShowVertical);
        public static Vector2 BeginScrollView(Rect position, Vector2 scrollPosition, Rect viewRect, GUIStyle horizontalScrollbar, GUIStyle verticalScrollbar);
        public static Vector2 BeginScrollView(Rect position, Vector2 scrollPosition, Rect viewRect, bool alwaysShowHorizontal, bool alwaysShowVertical, GUIStyle horizontalScrollbar, GUIStyle verticalScrollbar);
        protected static Vector2 DoBeginScrollView(Rect position, Vector2 scrollPosition, Rect viewRect, bool alwaysShowHorizontal, bool alwaysShowVertical, GUIStyle horizontalScrollbar, GUIStyle verticalScrollbar, GUIStyle background);
        public static void EndScrollView();
        public static void EndScrollView(bool handleScrollWheel);
        public static void ScrollTo(Rect position);
        public static bool ScrollTowards(Rect position, float maxDelta);
        public static Rect Window(int id, Rect clientRect, WindowFunction func, string text);
        public static Rect Window(int id, Rect clientRect, WindowFunction func, Texture image);
        public static Rect Window(int id, Rect clientRect, WindowFunction func, GUIContent content);
        public static Rect Window(int id, Rect clientRect, WindowFunction func, string text, GUIStyle style);
        public static Rect Window(int id, Rect clientRect, WindowFunction func, Texture image, GUIStyle style);
        public static Rect Window(int id, Rect clientRect, WindowFunction func, GUIContent title, GUIStyle style);
        public static Rect ModalWindow(int id, Rect clientRect, WindowFunction func, string text);
        public static Rect ModalWindow(int id, Rect clientRect, WindowFunction func, Texture image);
        public static Rect ModalWindow(int id, Rect clientRect, WindowFunction func, GUIContent content);
        public static Rect ModalWindow(int id, Rect clientRect, WindowFunction func, string text, GUIStyle style);
        public static Rect ModalWindow(int id, Rect clientRect, WindowFunction func, Texture image, GUIStyle style);
        public static Rect ModalWindow(int id, Rect clientRect, WindowFunction func, GUIContent content, GUIStyle style);
        public static void DragWindow();

        public enum ToolbarButtonSize
        {
            Fixed = 0,
            FitToContents = 1
        }
        public delegate void WindowFunction(int id);
        public abstract class Scope : IDisposable
        {
            protected Scope();

            ~Scope();

            public void Dispose();
            protected abstract void CloseScope();
        }
        public class GroupScope : Scope
        {
            public GroupScope(Rect position);
            public GroupScope(Rect position, string text);
            public GroupScope(Rect position, Texture image);
            public GroupScope(Rect position, GUIContent content);
            public GroupScope(Rect position, GUIStyle style);
            public GroupScope(Rect position, string text, GUIStyle style);
            public GroupScope(Rect position, Texture image, GUIStyle style);

            protected override void CloseScope();
        }
        public class ScrollViewScope : Scope
        {
            public ScrollViewScope(Rect position, Vector2 scrollPosition, Rect viewRect);
            public ScrollViewScope(Rect position, Vector2 scrollPosition, Rect viewRect, bool alwaysShowHorizontal, bool alwaysShowVertical);
            public ScrollViewScope(Rect position, Vector2 scrollPosition, Rect viewRect, GUIStyle horizontalScrollbar, GUIStyle verticalScrollbar);
            public ScrollViewScope(Rect position, Vector2 scrollPosition, Rect viewRect, bool alwaysShowHorizontal, bool alwaysShowVertical, GUIStyle horizontalScrollbar, GUIStyle verticalScrollbar);

            public Vector2 scrollPosition { get; }
            public bool handleScrollWheel { get; set; }

            protected override void CloseScope();
        }
        public class ClipScope : Scope
        {
            public ClipScope(Rect position);

            protected override void CloseScope();
        }
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Modules/IMGUI/GUIContent.h")]
    [RequiredByNativeCode(Optional = True, GenerateProxy = True)]
    public class GUIContent
    {
        public static GUIContent none;

        public GUIContent();
        public GUIContent(string text);
        public GUIContent(Texture image);
        public GUIContent(string text, Texture image);
        public GUIContent(string text, string tooltip);
        public GUIContent(Texture image, string tooltip);
        public GUIContent(string text, Texture image, string tooltip);
        public GUIContent(GUIContent src);

        public string text { get; set; }
        public Texture image { get; set; }
        public string tooltip { get; set; }
    }
}
using System;
using System.ComponentModel;
using UnityEngine.Internal;

namespace UnityEngine
{
    [ExcludeFromPreset]
    [ExcludeFromObjectFactory]
    [EditorBrowsable(Never)]
    [Obsolete("GUIElement has been removed.", True)]
    public sealed class GUIElement
    {
        public GUIElement();

        [Obsolete("GUIElement has been removed.", True)]
        public bool HitTest(Vector3 screenPosition);
        [Obsolete("GUIElement has been removed.", True)]
        public bool HitTest(Vector3 screenPosition, [UnityEngine.Internal.DefaultValue("null")] Camera camera);
        [Obsolete("GUIElement has been removed.", True)]
        public Rect GetScreenRect([UnityEngine.Internal.DefaultValue("null")] Camera camera);
        [Obsolete("GUIElement has been removed.", True)]
        public Rect GetScreenRect();
    }
}
namespace UnityEngine
{
    public enum ScaleMode
    {
        StretchToFill = 0,
        ScaleAndCrop = 1,
        ScaleToFit = 2
    }
}
using System;

namespace UnityEngine
{
    public enum FocusType
    {
        [Obsolete("FocusType.Native now behaves the same as FocusType.Passive in all OS cases. (UnityUpgradable) -> Passive", False)]
        Native = 0,
        Keyboard = 1,
        Passive = 2
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [ExcludeFromPreset]
    [ExcludeFromObjectFactory]
    [Obsolete("GUILayer has been removed.", True)]
    [EditorBrowsable(Never)]
    public sealed class GUILayer
    {
        public GUILayer();

        [Obsolete("GUILayer has been removed.", True)]
        public GUIElement HitTest(Vector3 screenPosition);
    }
}
namespace UnityEngine
{
    public class GUILayout
    {
        public GUILayout();

        public static void Label(Texture image, params GUILayoutOption[] options);
        public static void Label(string text, params GUILayoutOption[] options);
        public static void Label(GUIContent content, params GUILayoutOption[] options);
        public static void Label(Texture image, GUIStyle style, params GUILayoutOption[] options);
        public static void Label(string text, GUIStyle style, params GUILayoutOption[] options);
        public static void Label(GUIContent content, GUIStyle style, params GUILayoutOption[] options);
        public static void Box(Texture image, params GUILayoutOption[] options);
        public static void Box(string text, params GUILayoutOption[] options);
        public static void Box(GUIContent content, params GUILayoutOption[] options);
        public static void Box(Texture image, GUIStyle style, params GUILayoutOption[] options);
        public static void Box(string text, GUIStyle style, params GUILayoutOption[] options);
        public static void Box(GUIContent content, GUIStyle style, params GUILayoutOption[] options);
        public static bool Button(Texture image, params GUILayoutOption[] options);
        public static bool Button(string text, params GUILayoutOption[] options);
        public static bool Button(GUIContent content, params GUILayoutOption[] options);
        public static bool Button(Texture image, GUIStyle style, params GUILayoutOption[] options);
        public static bool Button(string text, GUIStyle style, params GUILayoutOption[] options);
        public static bool Button(GUIContent content, GUIStyle style, params GUILayoutOption[] options);
        public static bool RepeatButton(Texture image, params GUILayoutOption[] options);
        public static bool RepeatButton(string text, params GUILayoutOption[] options);
        public static bool RepeatButton(GUIContent content, params GUILayoutOption[] options);
        public static bool RepeatButton(Texture image, GUIStyle style, params GUILayoutOption[] options);
        public static bool RepeatButton(string text, GUIStyle style, params GUILayoutOption[] options);
        public static bool RepeatButton(GUIContent content, GUIStyle style, params GUILayoutOption[] options);
        public static string TextField(string text, params GUILayoutOption[] options);
        public static string TextField(string text, int maxLength, params GUILayoutOption[] options);
        public static string TextField(string text, GUIStyle style, params GUILayoutOption[] options);
        public static string TextField(string text, int maxLength, GUIStyle style, params GUILayoutOption[] options);
        public static string PasswordField(string password, char maskChar, params GUILayoutOption[] options);
        public static string PasswordField(string password, char maskChar, int maxLength, params GUILayoutOption[] options);
        public static string PasswordField(string password, char maskChar, GUIStyle style, params GUILayoutOption[] options);
        public static string PasswordField(string password, char maskChar, int maxLength, GUIStyle style, params GUILayoutOption[] options);
        public static string TextArea(string text, params GUILayoutOption[] options);
        public static string TextArea(string text, int maxLength, params GUILayoutOption[] options);
        public static string TextArea(string text, GUIStyle style, params GUILayoutOption[] options);
        public static string TextArea(string text, int maxLength, GUIStyle style, params GUILayoutOption[] options);
        public static bool Toggle(bool value, Texture image, params GUILayoutOption[] options);
        public static bool Toggle(bool value, string text, params GUILayoutOption[] options);
        public static bool Toggle(bool value, GUIContent content, params GUILayoutOption[] options);
        public static bool Toggle(bool value, Texture image, GUIStyle style, params GUILayoutOption[] options);
        public static bool Toggle(bool value, string text, GUIStyle style, params GUILayoutOption[] options);
        public static bool Toggle(bool value, GUIContent content, GUIStyle style, params GUILayoutOption[] options);
        public static int Toolbar(int selected, string[] texts, params GUILayoutOption[] options);
        public static int Toolbar(int selected, Texture[] images, params GUILayoutOption[] options);
        public static int Toolbar(int selected, GUIContent[] contents, params GUILayoutOption[] options);
        public static int Toolbar(int selected, string[] texts, GUIStyle style, params GUILayoutOption[] options);
        public static int Toolbar(int selected, Texture[] images, GUIStyle style, params GUILayoutOption[] options);
        public static int Toolbar(int selected, string[] texts, GUIStyle style, GUI.ToolbarButtonSize buttonSize, params GUILayoutOption[] options);
        public static int Toolbar(int selected, Texture[] images, GUIStyle style, GUI.ToolbarButtonSize buttonSize, params GUILayoutOption[] options);
        public static int Toolbar(int selected, GUIContent[] contents, GUIStyle style, params GUILayoutOption[] options);
        public static int Toolbar(int selected, GUIContent[] contents, GUIStyle style, GUI.ToolbarButtonSize buttonSize, params GUILayoutOption[] options);
        public static int Toolbar(int selected, GUIContent[] contents, bool[] enabled, GUIStyle style, params GUILayoutOption[] options);
        public static int Toolbar(int selected, GUIContent[] contents, bool[] enabled, GUIStyle style, GUI.ToolbarButtonSize buttonSize, params GUILayoutOption[] options);
        public static int SelectionGrid(int selected, string[] texts, int xCount, params GUILayoutOption[] options);
        public static int SelectionGrid(int selected, Texture[] images, int xCount, params GUILayoutOption[] options);
        public static int SelectionGrid(int selected, GUIContent[] content, int xCount, params GUILayoutOption[] options);
        public static int SelectionGrid(int selected, string[] texts, int xCount, GUIStyle style, params GUILayoutOption[] options);
        public static int SelectionGrid(int selected, Texture[] images, int xCount, GUIStyle style, params GUILayoutOption[] options);
        public static int SelectionGrid(int selected, GUIContent[] contents, int xCount, GUIStyle style, params GUILayoutOption[] options);
        public static float HorizontalSlider(float value, float leftValue, float rightValue, params GUILayoutOption[] options);
        public static float HorizontalSlider(float value, float leftValue, float rightValue, GUIStyle slider, GUIStyle thumb, params GUILayoutOption[] options);
        public static float VerticalSlider(float value, float leftValue, float rightValue, params GUILayoutOption[] options);
        public static float VerticalSlider(float value, float leftValue, float rightValue, GUIStyle slider, GUIStyle thumb, params GUILayoutOption[] options);
        public static float HorizontalScrollbar(float value, float size, float leftValue, float rightValue, params GUILayoutOption[] options);
        public static float HorizontalScrollbar(float value, float size, float leftValue, float rightValue, GUIStyle style, params GUILayoutOption[] options);
        public static float VerticalScrollbar(float value, float size, float topValue, float bottomValue, params GUILayoutOption[] options);
        public static float VerticalScrollbar(float value, float size, float topValue, float bottomValue, GUIStyle style, params GUILayoutOption[] options);
        public static void Space(float pixels);
        public static void FlexibleSpace();
        public static void BeginHorizontal(params GUILayoutOption[] options);
        public static void BeginHorizontal(GUIStyle style, params GUILayoutOption[] options);
        public static void BeginHorizontal(string text, GUIStyle style, params GUILayoutOption[] options);
        public static void BeginHorizontal(Texture image, GUIStyle style, params GUILayoutOption[] options);
        public static void BeginHorizontal(GUIContent content, GUIStyle style, params GUILayoutOption[] options);
        public static void EndHorizontal();
        public static void BeginVertical(params GUILayoutOption[] options);
        public static void BeginVertical(GUIStyle style, params GUILayoutOption[] options);
        public static void BeginVertical(string text, GUIStyle style, params GUILayoutOption[] options);
        public static void BeginVertical(Texture image, GUIStyle style, params GUILayoutOption[] options);
        public static void BeginVertical(GUIContent content, GUIStyle style, params GUILayoutOption[] options);
        public static void EndVertical();
        public static void BeginArea(Rect screenRect);
        public static void BeginArea(Rect screenRect, string text);
        public static void BeginArea(Rect screenRect, Texture image);
        public static void BeginArea(Rect screenRect, GUIContent content);
        public static void BeginArea(Rect screenRect, GUIStyle style);
        public static void BeginArea(Rect screenRect, string text, GUIStyle style);
        public static void BeginArea(Rect screenRect, Texture image, GUIStyle style);
        public static void BeginArea(Rect screenRect, GUIContent content, GUIStyle style);
        public static void EndArea();
        public static Vector2 BeginScrollView(Vector2 scrollPosition, params GUILayoutOption[] options);
        public static Vector2 BeginScrollView(Vector2 scrollPosition, bool alwaysShowHorizontal, bool alwaysShowVertical, params GUILayoutOption[] options);
        public static Vector2 BeginScrollView(Vector2 scrollPosition, GUIStyle horizontalScrollbar, GUIStyle verticalScrollbar, params GUILayoutOption[] options);
        public static Vector2 BeginScrollView(Vector2 scrollPosition, GUIStyle style);
        public static Vector2 BeginScrollView(Vector2 scrollPosition, GUIStyle style, params GUILayoutOption[] options);
        public static Vector2 BeginScrollView(Vector2 scrollPosition, bool alwaysShowHorizontal, bool alwaysShowVertical, GUIStyle horizontalScrollbar, GUIStyle verticalScrollbar, params GUILayoutOption[] options);
        public static Vector2 BeginScrollView(Vector2 scrollPosition, bool alwaysShowHorizontal, bool alwaysShowVertical, GUIStyle horizontalScrollbar, GUIStyle verticalScrollbar, GUIStyle background, params GUILayoutOption[] options);
        public static void EndScrollView();
        public static Rect Window(int id, Rect screenRect, GUI.WindowFunction func, string text, params GUILayoutOption[] options);
        public static Rect Window(int id, Rect screenRect, GUI.WindowFunction func, Texture image, params GUILayoutOption[] options);
        public static Rect Window(int id, Rect screenRect, GUI.WindowFunction func, GUIContent content, params GUILayoutOption[] options);
        public static Rect Window(int id, Rect screenRect, GUI.WindowFunction func, string text, GUIStyle style, params GUILayoutOption[] options);
        public static Rect Window(int id, Rect screenRect, GUI.WindowFunction func, Texture image, GUIStyle style, params GUILayoutOption[] options);
        public static Rect Window(int id, Rect screenRect, GUI.WindowFunction func, GUIContent content, GUIStyle style, params GUILayoutOption[] options);
        public static GUILayoutOption Width(float width);
        public static GUILayoutOption MinWidth(float minWidth);
        public static GUILayoutOption MaxWidth(float maxWidth);
        public static GUILayoutOption Height(float height);
        public static GUILayoutOption MinHeight(float minHeight);
        public static GUILayoutOption MaxHeight(float maxHeight);
        public static GUILayoutOption ExpandWidth(bool expand);
        public static GUILayoutOption ExpandHeight(bool expand);

        public class HorizontalScope : GUI.Scope
        {
            public HorizontalScope(params GUILayoutOption[] options);
            public HorizontalScope(GUIStyle style, params GUILayoutOption[] options);
            public HorizontalScope(string text, GUIStyle style, params GUILayoutOption[] options);
            public HorizontalScope(Texture image, GUIStyle style, params GUILayoutOption[] options);
            public HorizontalScope(GUIContent content, GUIStyle style, params GUILayoutOption[] options);

            protected override void CloseScope();
        }
        public class VerticalScope : GUI.Scope
        {
            public VerticalScope(params GUILayoutOption[] options);
            public VerticalScope(GUIStyle style, params GUILayoutOption[] options);
            public VerticalScope(string text, GUIStyle style, params GUILayoutOption[] options);
            public VerticalScope(Texture image, GUIStyle style, params GUILayoutOption[] options);
            public VerticalScope(GUIContent content, GUIStyle style, params GUILayoutOption[] options);

            protected override void CloseScope();
        }
        public class AreaScope : GUI.Scope
        {
            public AreaScope(Rect screenRect);
            public AreaScope(Rect screenRect, string text);
            public AreaScope(Rect screenRect, Texture image);
            public AreaScope(Rect screenRect, GUIContent content);
            public AreaScope(Rect screenRect, string text, GUIStyle style);
            public AreaScope(Rect screenRect, Texture image, GUIStyle style);
            public AreaScope(Rect screenRect, GUIContent content, GUIStyle style);

            protected override void CloseScope();
        }
        public class ScrollViewScope : GUI.Scope
        {
            public ScrollViewScope(Vector2 scrollPosition, params GUILayoutOption[] options);
            public ScrollViewScope(Vector2 scrollPosition, bool alwaysShowHorizontal, bool alwaysShowVertical, params GUILayoutOption[] options);
            public ScrollViewScope(Vector2 scrollPosition, GUIStyle horizontalScrollbar, GUIStyle verticalScrollbar, params GUILayoutOption[] options);
            public ScrollViewScope(Vector2 scrollPosition, GUIStyle style, params GUILayoutOption[] options);
            public ScrollViewScope(Vector2 scrollPosition, bool alwaysShowHorizontal, bool alwaysShowVertical, GUIStyle horizontalScrollbar, GUIStyle verticalScrollbar, params GUILayoutOption[] options);
            public ScrollViewScope(Vector2 scrollPosition, bool alwaysShowHorizontal, bool alwaysShowVertical, GUIStyle horizontalScrollbar, GUIStyle verticalScrollbar, GUIStyle background, params GUILayoutOption[] options);

            public Vector2 scrollPosition { get; }
            public bool handleScrollWheel { get; set; }

            protected override void CloseScope();
        }
    }
}
namespace UnityEngine
{
    public sealed class GUILayoutOption
    {
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/IMGUI/GUILayoutUtility.bindings.h")]
    public class GUILayoutUtility
    {
        public GUILayoutUtility();

        [Obsolete("BeginGroup has no effect and will be removed", False)]
        public static void BeginGroup(string GroupName);
        [Obsolete("EndGroup has no effect and will be removed", False)]
        public static void EndGroup(string groupName);
        public static Rect GetRect(GUIContent content, GUIStyle style);
        public static Rect GetRect(GUIContent content, GUIStyle style, params GUILayoutOption[] options);
        public static Rect GetRect(float width, float height);
        public static Rect GetRect(float width, float height, GUIStyle style);
        public static Rect GetRect(float width, float height, params GUILayoutOption[] options);
        public static Rect GetRect(float width, float height, GUIStyle style, params GUILayoutOption[] options);
        public static Rect GetRect(float minWidth, float maxWidth, float minHeight, float maxHeight);
        public static Rect GetRect(float minWidth, float maxWidth, float minHeight, float maxHeight, GUIStyle style);
        public static Rect GetRect(float minWidth, float maxWidth, float minHeight, float maxHeight, params GUILayoutOption[] options);
        public static Rect GetRect(float minWidth, float maxWidth, float minHeight, float maxHeight, GUIStyle style, params GUILayoutOption[] options);
        public static Rect GetLastRect();
        public static Rect GetAspectRect(float aspect);
        public static Rect GetAspectRect(float aspect, GUIStyle style);
        public static Rect GetAspectRect(float aspect, params GUILayoutOption[] options);
        public static Rect GetAspectRect(float aspect, GUIStyle style, params GUILayoutOption[] options);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/IMGUI/GUISkin.bindings.h")]
    public sealed class GUISettings
    {
        public GUISettings();

        public bool doubleClickSelectsWord { get; set; }
        public bool tripleClickSelectsLine { get; set; }
        public Color cursorColor { get; set; }
        public float cursorFlashSpeed { get; set; }
        public Color selectionColor { get; set; }
    }
}
using System.Collections;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [ExecuteInEditMode]
    [AssetFileNameExtension("guiskin", new[] { })]
    [RequiredByNativeCode]
    public sealed class GUISkin : ScriptableObject
    {
        public GUISkin();

        public Font font { get; set; }
        public GUIStyle box { get; set; }
        public GUIStyle label { get; set; }
        public GUIStyle textField { get; set; }
        public GUIStyle textArea { get; set; }
        public GUIStyle button { get; set; }
        public GUIStyle toggle { get; set; }
        public GUIStyle window { get; set; }
        public GUIStyle horizontalSlider { get; set; }
        public GUIStyle horizontalSliderThumb { get; set; }
        public GUIStyle verticalSlider { get; set; }
        public GUIStyle verticalSliderThumb { get; set; }
        public GUIStyle horizontalScrollbar { get; set; }
        public GUIStyle horizontalScrollbarThumb { get; set; }
        public GUIStyle horizontalScrollbarLeftButton { get; set; }
        public GUIStyle horizontalScrollbarRightButton { get; set; }
        public GUIStyle verticalScrollbar { get; set; }
        public GUIStyle verticalScrollbarThumb { get; set; }
        public GUIStyle verticalScrollbarUpButton { get; set; }
        public GUIStyle verticalScrollbarDownButton { get; set; }
        public GUIStyle scrollView { get; set; }
        public GUIStyle[] customStyles { get; set; }
        public GUISettings settings { get; }

        public GUIStyle GetStyle(string styleName);
        public GUIStyle FindStyle(string styleName);
        public IEnumerator GetEnumerator();
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/IMGUI/GUIStyle.bindings.h")]
    public sealed class GUIStyleState
    {
        public GUIStyleState();

        ~GUIStyleState();

        [NativeProperty("Background", False, Function)]
        public Texture2D background { get; set; }
        [NativeProperty("textColor", False, Field)]
        public Color textColor { get; set; }
        [NativeProperty("scaledBackgrounds", False, Field)]
        public Texture2D[] scaledBackgrounds { get; set; }
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [RequiredByNativeCode]
    [NativeHeader("IMGUIScriptingClasses.h")]
    [NativeHeader("Modules/IMGUI/GUIStyle.bindings.h")]
    public sealed class GUIStyle
    {
        public GUIStyle();
        public GUIStyle(GUIStyle other);

        ~GUIStyle();

        [NativeProperty("Font", False, Function)]
        public Font font { get; set; }
        [NativeProperty("m_ImagePosition", False, Field)]
        public ImagePosition imagePosition { get; set; }
        [NativeProperty("m_Alignment", False, Field)]
        public TextAnchor alignment { get; set; }
        [NativeProperty("m_WordWrap", False, Field)]
        public bool wordWrap { get; set; }
        [NativeProperty("m_Clipping", False, Field)]
        public TextClipping clipping { get; set; }
        [NativeProperty("m_ContentOffset", False, Field)]
        public Vector2 contentOffset { get; set; }
        [NativeProperty("m_FixedWidth", False, Field)]
        public float fixedWidth { get; set; }
        [NativeProperty("m_FixedHeight", False, Field)]
        public float fixedHeight { get; set; }
        [NativeProperty("m_StretchWidth", False, Field)]
        public bool stretchWidth { get; set; }
        [NativeProperty("m_StretchHeight", False, Field)]
        public bool stretchHeight { get; set; }
        [NativeProperty("m_FontSize", False, Field)]
        public int fontSize { get; set; }
        [NativeProperty("m_FontStyle", False, Field)]
        public FontStyle fontStyle { get; set; }
        [NativeProperty("m_RichText", False, Field)]
        public bool richText { get; set; }
        [Obsolete("Don't use clipOffset - put things inside BeginGroup instead. This functionality will be removed in a later version.", False)]
        [NativeProperty("m_ClipOffset", False, Field)]
        public Vector2 clipOffset { get; set; }
        public string name { get; set; }
        public GUIStyleState normal { get; set; }
        public GUIStyleState hover { get; set; }
        public GUIStyleState active { get; set; }
        public GUIStyleState onNormal { get; set; }
        public GUIStyleState onHover { get; set; }
        public GUIStyleState onActive { get; set; }
        public GUIStyleState focused { get; set; }
        public GUIStyleState onFocused { get; set; }
        public RectOffset border { get; set; }
        public RectOffset margin { get; set; }
        public RectOffset padding { get; set; }
        public RectOffset overflow { get; set; }
        public float lineHeight { get; }
        public static GUIStyle none { get; }
        public bool isHeightDependantOnWidth { get; }

        public void Draw(Rect position, bool isHover, bool isActive, bool on, bool hasKeyboardFocus);
        public void Draw(Rect position, string text, bool isHover, bool isActive, bool on, bool hasKeyboardFocus);
        public void Draw(Rect position, Texture image, bool isHover, bool isActive, bool on, bool hasKeyboardFocus);
        public void Draw(Rect position, GUIContent content, bool isHover, bool isActive, bool on, bool hasKeyboardFocus);
        public void Draw(Rect position, GUIContent content, int controlID);
        public void Draw(Rect position, GUIContent content, int controlID, bool on);
        public void Draw(Rect position, GUIContent content, int controlID, bool on, bool hover);
        public void DrawCursor(Rect position, GUIContent content, int controlID, int character);
        public void DrawWithTextSelection(Rect position, GUIContent content, int controlID, int firstSelectedCharacter, int lastSelectedCharacter);
        public Vector2 GetCursorPixelPosition(Rect position, GUIContent content, int cursorStringIndex);
        public int GetCursorStringIndex(Rect position, GUIContent content, Vector2 cursorPixelPosition);
        public Vector2 CalcSize(GUIContent content);
        public Vector2 CalcScreenSize(Vector2 contentSize);
        public float CalcHeight(GUIContent content, float width);
        public void CalcMinMaxWidth(GUIContent content, out float minWidth, out float maxWidth);
        public override string ToString();

        public static implicit operator GUIStyle(string str);
    }
}
namespace UnityEngine
{
    public enum ImagePosition
    {
        ImageLeft = 0,
        ImageAbove = 1,
        ImageOnly = 2,
        TextOnly = 3
    }
}
namespace UnityEngine
{
    public enum TextClipping
    {
        Overflow = 0,
        Clip = 1
    }
}
using System;

namespace UnityEngine
{
    [AttributeUsage(Method)]
    public class GUITargetAttribute : Attribute
    {
        public GUITargetAttribute();
        public GUITargetAttribute(int displayIndex);
        public GUITargetAttribute(int displayIndex, int displayIndex1);
        public GUITargetAttribute(int displayIndex, int displayIndex1, params int[] displayIndexList);
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [Obsolete("GUITexture has been removed. Use UI.Image instead.", True)]
    [EditorBrowsable(Never)]
    [ExcludeFromObjectFactory]
    [ExcludeFromPreset]
    public sealed class GUITexture
    {
        public GUITexture();

        [Obsolete("GUITexture has been removed. Use UI.Image instead.", True)]
        public Color color { get; set; }
        [Obsolete("GUITexture has been removed. Use UI.Image instead.", True)]
        public Texture texture { get; set; }
        [Obsolete("GUITexture has been removed. Use UI.Image instead.", True)]
        public Rect pixelInset { get; set; }
        [Obsolete("GUITexture has been removed. Use UI.Image instead.", True)]
        public RectOffset border { get; set; }
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/IMGUI/GUIUtility.h")]
    [NativeHeader("Runtime/Input/InputBindings.h")]
    [NativeHeader("Runtime/Input/InputManager.h")]
    [NativeHeader("Runtime/Camera/RenderLayers/GUITexture.h")]
    [NativeHeader("Runtime/Utilities/CopyPaste.h")]
    [NativeHeader("Modules/IMGUI/GUIManager.h")]
    public class GUIUtility
    {
        public GUIUtility();

        public static bool hasModalWindow { get; }
        public static string systemCopyBuffer { get; set; }
        public static int hotControl { get; set; }
        public static int keyboardControl { get; set; }

        public static int GetControlID(int hint, FocusType focusType, Rect rect);
        public static Rect AlignRectToDevice(Rect rect, out int widthInPixels, out int heightInPixels);
        public static int GetControlID(FocusType focus);
        public static int GetControlID(GUIContent contents, FocusType focus);
        public static int GetControlID(FocusType focus, Rect position);
        public static int GetControlID(GUIContent contents, FocusType focus, Rect position);
        public static int GetControlID(int hint, FocusType focus);
        public static object GetStateObject(Type t, int controlID);
        public static object QueryStateObject(Type t, int controlID);
        public static void ExitGUI();
        public static Vector2 GUIToScreenPoint(Vector2 guiPoint);
        public static Rect GUIToScreenRect(Rect guiRect);
        public static Vector2 ScreenToGUIPoint(Vector2 screenPoint);
        public static Rect ScreenToGUIRect(Rect screenRect);
        public static void RotateAroundPivot(float angle, Vector2 pivotPoint);
        public static void ScaleAroundPivot(Vector2 scale, Vector2 pivotPoint);
        public static Rect AlignRectToDevice(Rect rect);
    }
}
using System;

namespace UnityEngine
{
    public sealed class ExitGUIException : Exception
    {
        public ExitGUIException();
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine
{
    public class TextEditor
    {
        public TouchScreenKeyboard keyboardOnScreen;
        public int controlID;
        public GUIStyle style;
        public bool multiline;
        public bool hasHorizontalCursorPos;
        public bool isPasswordField;
        public Vector2 scrollOffset;
        public Vector2 graphicalCursorPos;
        public Vector2 graphicalSelectCursorPos;

        [RequiredByNativeCode]
        public TextEditor();

        [Obsolete("Please use 'text' instead of 'content'", False)]
        public GUIContent content { get; set; }
        public string text { get; set; }
        public Rect position { get; set; }
        public int cursorIndex { get; set; }
        public int selectIndex { get; set; }
        public DblClickSnapping doubleClickSnapping { get; set; }
        public int altCursorPosition { get; set; }
        public bool hasSelection { get; }
        public string SelectedText { get; }

        public void OnFocus();
        public void OnLostFocus();
        public bool HandleKeyEvent(Event e);
        public bool DeleteLineBack();
        public bool DeleteWordBack();
        public bool DeleteWordForward();
        public bool Delete();
        public bool CanPaste();
        public bool Backspace();
        public void SelectAll();
        public void SelectNone();
        public bool DeleteSelection();
        public void ReplaceSelection(string replace);
        public void Insert(char c);
        public void MoveSelectionToAltCursor();
        public void MoveRight();
        public void MoveLeft();
        public void MoveUp();
        public void MoveDown();
        public void MoveLineStart();
        public void MoveLineEnd();
        public void MoveGraphicalLineStart();
        public void MoveGraphicalLineEnd();
        public void MoveTextStart();
        public void MoveTextEnd();
        public void MoveParagraphForward();
        public void MoveParagraphBackward();
        public void MoveCursorToPosition(Vector2 cursorPosition);
        protected internal void MoveCursorToPosition_Internal(Vector2 cursorPosition, bool shift);
        public void MoveAltCursorToPosition(Vector2 cursorPosition);
        public bool IsOverSelection(Vector2 cursorPosition);
        public void SelectToPosition(Vector2 cursorPosition);
        public void SelectLeft();
        public void SelectRight();
        public void SelectUp();
        public void SelectDown();
        public void SelectTextEnd();
        public void SelectTextStart();
        public void MouseDragSelectsWholeWords(bool on);
        public void DblClickSnap(DblClickSnapping snapping);
        public void MoveWordRight();
        public void MoveToStartOfNextWord();
        public void MoveToEndOfPreviousWord();
        public void SelectToStartOfNextWord();
        public void SelectToEndOfPreviousWord();
        public int FindStartOfNextWord(int p);
        public void MoveWordLeft();
        public void SelectWordRight();
        public void SelectWordLeft();
        public void ExpandSelectGraphicalLineStart();
        public void ExpandSelectGraphicalLineEnd();
        public void SelectGraphicalLineStart();
        public void SelectGraphicalLineEnd();
        public void SelectParagraphForward();
        public void SelectParagraphBackward();
        public void SelectCurrentWord();
        public void SelectCurrentParagraph();
        public void UpdateScrollOffsetIfNeeded(Event evt);
        public void DrawCursor(string newText);
        public void SaveBackup();
        public void Undo();
        public bool Cut();
        public void Copy();
        public bool Paste();
        public void DetectFocusChange();

        public enum DblClickSnapping
        {
            WORDS = 0,
            PARAGRAPHS = 1
        }
    }
}
-------- {UnityEngine.ImageConversionModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.ImageConversionModule.dll)}:    0 --------
using System;
using Unity.Collections;
using UnityEngine.Bindings;
using UnityEngine.Experimental.Rendering;

namespace UnityEngine
{
    [NativeHeader("Modules/ImageConversion/ScriptBindings/ImageConversion.bindings.h")]
    public static class ImageConversion
    {
        public static bool EnableLegacyPngGammaRuntimeLoadBehavior { get; set; }

        [NativeMethod(Name = "ImageConversionBindings::EncodeToTGA", IsFreeFunction = True, ThrowsException = True)]
        public static byte[] EncodeToTGA(this Texture2D tex);
        [NativeMethod(Name = "ImageConversionBindings::EncodeToPNG", IsFreeFunction = True, ThrowsException = True)]
        public static byte[] EncodeToPNG(this Texture2D tex);
        [NativeMethod(Name = "ImageConversionBindings::EncodeToJPG", IsFreeFunction = True, ThrowsException = True)]
        public static byte[] EncodeToJPG(this Texture2D tex, int quality);
        public static byte[] EncodeToJPG(this Texture2D tex);
        [NativeMethod(Name = "ImageConversionBindings::EncodeToEXR", IsFreeFunction = True, ThrowsException = True)]
        public static byte[] EncodeToEXR(this Texture2D tex, Texture2D.EXRFlags flags);
        public static byte[] EncodeToEXR(this Texture2D tex);
        [NativeMethod(Name = "ImageConversionBindings::LoadImage", IsFreeFunction = True)]
        public static bool LoadImage([NotNull("ArgumentNullException")] this Texture2D tex, byte[] data, bool markNonReadable);
        public static bool LoadImage(this Texture2D tex, byte[] data);
        [FreeFunction("ImageConversionBindings::EncodeArrayToTGA", True)]
        public static byte[] EncodeArrayToTGA(Array array, GraphicsFormat format, uint width, uint height, uint rowBytes = 0);
        [FreeFunction("ImageConversionBindings::EncodeArrayToPNG", True)]
        public static byte[] EncodeArrayToPNG(Array array, GraphicsFormat format, uint width, uint height, uint rowBytes = 0);
        [FreeFunction("ImageConversionBindings::EncodeArrayToJPG", True)]
        public static byte[] EncodeArrayToJPG(Array array, GraphicsFormat format, uint width, uint height, uint rowBytes = 0, int quality = 75);
        [FreeFunction("ImageConversionBindings::EncodeArrayToEXR", True)]
        public static byte[] EncodeArrayToEXR(Array array, GraphicsFormat format, uint width, uint height, uint rowBytes = 0, Texture2D.EXRFlags flags = None);
        public static NativeArray<byte> EncodeNativeArrayToTGA<T>(NativeArray<T> input, GraphicsFormat format, uint width, uint height, uint rowBytes = 0) where T : struct;
        public static NativeArray<byte> EncodeNativeArrayToPNG<T>(NativeArray<T> input, GraphicsFormat format, uint width, uint height, uint rowBytes = 0) where T : struct;
        public static NativeArray<byte> EncodeNativeArrayToJPG<T>(NativeArray<T> input, GraphicsFormat format, uint width, uint height, uint rowBytes = 0, int quality = 75) where T : struct;
        public static NativeArray<byte> EncodeNativeArrayToEXR<T>(NativeArray<T> input, GraphicsFormat format, uint width, uint height, uint rowBytes = 0, Texture2D.EXRFlags flags = None) where T : struct;
    }
}
-------- {UnityEngine.InputModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.InputModule.dll)}:    5 --------
-------- {UnityEngine.InputLegacyModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.InputLegacyModule.dll)}:   16 --------
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Input/GetInput.h")]
    public class AndroidInput
    {
        public static int touchCountSecondary { get; }
        public static bool secondaryTouchEnabled { get; }
        public static int secondaryTouchWidth { get; }
        public static int secondaryTouchHeight { get; }

        public static Touch GetSecondaryTouch(int index);
    }
}
namespace UnityEngine
{
    public enum TouchPhase
    {
        Began = 0,
        Moved = 1,
        Stationary = 2,
        Ended = 3,
        Canceled = 4
    }
}
namespace UnityEngine
{
    public enum IMECompositionMode
    {
        Auto = 0,
        On = 1,
        Off = 2
    }
}
namespace UnityEngine
{
    public enum TouchType
    {
        Direct = 0,
        Indirect = 1,
        Stylus = 2
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Input/InputBindings.h")]
    public struct Touch
    {
        public int fingerId { get; set; }
        public Vector2 position { get; set; }
        public Vector2 rawPosition { get; set; }
        public Vector2 deltaPosition { get; set; }
        public float deltaTime { get; set; }
        public int tapCount { get; set; }
        public TouchPhase phase { get; set; }
        public float pressure { get; set; }
        public float maximumPossiblePressure { get; set; }
        public TouchType type { get; set; }
        public float altitudeAngle { get; set; }
        public float azimuthAngle { get; set; }
        public float radius { get; set; }
        public float radiusVariance { get; set; }
    }
}
namespace UnityEngine
{
    public enum DeviceOrientation
    {
        Unknown = 0,
        Portrait = 1,
        PortraitUpsideDown = 2,
        LandscapeLeft = 3,
        LandscapeRight = 4,
        FaceUp = 5,
        FaceDown = 6
    }
}
namespace UnityEngine
{
    public struct AccelerationEvent
    {
        public Vector3 acceleration { get; }
        public float deltaTime { get; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Input/GetInput.h")]
    public class Gyroscope
    {
        public Vector3 rotationRate { get; }
        public Vector3 rotationRateUnbiased { get; }
        public Vector3 gravity { get; }
        public Vector3 userAcceleration { get; }
        public Quaternion attitude { get; }
        public bool enabled { get; set; }
        public float updateInterval { get; set; }
    }
}
namespace UnityEngine
{
    public struct LocationInfo
    {
        public float latitude { get; }
        public float longitude { get; }
        public float altitude { get; }
        public float horizontalAccuracy { get; }
        public float verticalAccuracy { get; }
        public double timestamp { get; }
    }
}
namespace UnityEngine
{
    public enum LocationServiceStatus
    {
        Stopped = 0,
        Initializing = 1,
        Running = 2,
        Failed = 3
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Input/LocationService.h")]
    [NativeHeader("Runtime/Input/InputBindings.h")]
    public class LocationService
    {
        public LocationService();

        public bool isEnabledByUser { get; }
        public LocationServiceStatus status { get; }
        public LocationInfo lastData { get; }

        public void Start(float desiredAccuracyInMeters, float updateDistanceInMeters);
        public void Start(float desiredAccuracyInMeters);
        public void Start();
        public void Stop();
    }
}
namespace UnityEngine
{
    public class Compass
    {
        public Compass();

        public float magneticHeading { get; }
        public float trueHeading { get; }
        public float headingAccuracy { get; }
        public Vector3 rawVector { get; }
        public double timestamp { get; }
        public bool enabled { get; set; }
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Input/InputBindings.h")]
    public class Input
    {
        public Input();

        public static bool simulateMouseWithTouches { get; set; }
        [NativeThrows]
        public static bool anyKey { get; }
        [NativeThrows]
        public static bool anyKeyDown { get; }
        [NativeThrows]
        public static string inputString { get; }
        [NativeThrows]
        public static Vector3 mousePosition { get; }
        [NativeThrows]
        public static Vector2 mouseScrollDelta { get; }
        public static IMECompositionMode imeCompositionMode { get; set; }
        public static string compositionString { get; }
        public static bool imeIsSelected { get; }
        public static Vector2 compositionCursorPos { get; set; }
        [Obsolete("eatKeyPressOnTextFieldFocus property is deprecated, and only provided to support legacy behavior.")]
        public static bool eatKeyPressOnTextFieldFocus { get; set; }
        public static bool mousePresent { get; }
        public static int touchCount { get; }
        public static bool touchPressureSupported { get; }
        public static bool stylusTouchSupported { get; }
        public static bool touchSupported { get; }
        public static bool multiTouchEnabled { get; set; }
        [Obsolete("isGyroAvailable property is deprecated. Please use SystemInfo.supportsGyroscope instead.")]
        public static bool isGyroAvailable { get; }
        public static DeviceOrientation deviceOrientation { get; }
        public static Vector3 acceleration { get; }
        public static bool compensateSensors { get; set; }
        public static int accelerationEventCount { get; }
        public static bool backButtonLeavesApp { get; set; }
        public static LocationService location { get; }
        public static Compass compass { get; }
        public static Gyroscope gyro { get; }
        public static Touch[] touches { get; }
        public static AccelerationEvent[] accelerationEvents { get; }

        [NativeThrows]
        public static float GetAxis(string axisName);
        [NativeThrows]
        public static float GetAxisRaw(string axisName);
        [NativeThrows]
        public static bool GetButton(string buttonName);
        [NativeThrows]
        public static bool GetButtonDown(string buttonName);
        [NativeThrows]
        public static bool GetButtonUp(string buttonName);
        [NativeThrows]
        public static bool GetMouseButton(int button);
        [NativeThrows]
        public static bool GetMouseButtonDown(int button);
        [NativeThrows]
        public static bool GetMouseButtonUp(int button);
        [FreeFunction("ResetInput")]
        public static void ResetInputAxes();
        public static bool IsJoystickPreconfigured(string joystickName);
        [NativeThrows]
        public static string[] GetJoystickNames();
        [NativeThrows]
        public static Touch GetTouch(int index);
        [NativeThrows]
        public static AccelerationEvent GetAccelerationEvent(int index);
        public static bool GetKey(KeyCode key);
        public static bool GetKey(string name);
        public static bool GetKeyUp(KeyCode key);
        public static bool GetKeyUp(string name);
        public static bool GetKeyDown(KeyCode key);
        public static bool GetKeyDown(string name);
    }
}
-------- {UnityEngine.JSONSerializeModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.JSONSerializeModule.dll)}:    0 --------
using System;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/JSONSerialize/Public/JsonUtility.bindings.h")]
    public static class JsonUtility
    {
        public static string ToJson(object obj);
        public static string ToJson(object obj, bool prettyPrint);
        public static T FromJson<T>(string json);
        public static object FromJson(string json, Type type);
        public static void FromJsonOverwrite(string json, object objectToOverwrite);
    }
}
-------- {UnityEngine.LocalizationModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.LocalizationModule.dll)}:    0 --------
using UnityEngine.Bindings;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine
{
    [ExcludeFromPreset]
    [NativeClass("LocalizationAsset")]
    [NativeHeader("Modules/Localization/Public/LocalizationAsset.bindings.h")]
    [NativeHeader("Modules/Localization/Public/LocalizationAsset.h")]
    [MovedFrom("UnityEditor")]
    public sealed class LocalizationAsset : Object
    {
        public LocalizationAsset();

        public string localeIsoCode { get; set; }
        public bool isEditorAsset { get; set; }

        [NativeMethod("StoreLocalizedString")]
        public void SetLocalizedString(string original, string localized);
        [NativeMethod("GetLocalized")]
        public string GetLocalizedString(string original);
    }
}
-------- {UnityEngine.ParticleSystemModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.ParticleSystemModule.dll)}:  107 --------
using System;

namespace UnityEngine
{
    [Obsolete("ParticleSystemEmissionType no longer does anything. Time and Distance based emission are now both always active.", False)]
    public enum ParticleSystemEmissionType
    {
        Time = 0,
        Distance = 1
    }
}
using System;
using System.Collections.Generic;
using System.ComponentModel;
using Unity.Collections;
using UnityEngine.Bindings;
using UnityEngine.Internal;
using UnityEngine.Rendering;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Modules/ParticleSystem/ParticleSystem.h")]
    [NativeHeader("Modules/ParticleSystem/ParticleSystemGeometryJob.h")]
    [NativeHeader("Modules/ParticleSystem/ScriptBindings/ParticleSystemScriptBindings.h")]
    [NativeHeader("ParticleSystemScriptingClasses.h")]
    [RequireComponent(typeof(Transform))]
    [NativeHeader("ParticleSystemScriptingClasses.h")]
    [NativeHeader("Modules/ParticleSystem/ParticleSystem.h")]
    [NativeHeader("Modules/ParticleSystem/ScriptBindings/ParticleSystemModulesScriptBindings.h")]
    [NativeHeader("Modules/ParticleSystem/ScriptBindings/ParticleSystemScriptBindings.h")]
    [UsedByNativeCode]
    public sealed class ParticleSystem : Component
    {
        public ParticleSystem();

        [Obsolete("safeCollisionEventSize has been deprecated. Use GetSafeCollisionEventSize() instead (UnityUpgradable) -> ParticlePhysicsExtensions.GetSafeCollisionEventSize(UnityEngine.ParticleSystem)", False)]
        public int safeCollisionEventSize { get; }
        [Obsolete("startDelay property is deprecated. Use main.startDelay or main.startDelayMultiplier instead.", False)]
        public float startDelay { get; set; }
        [Obsolete("loop property is deprecated. Use main.loop instead.", False)]
        public bool loop { get; set; }
        [Obsolete("playOnAwake property is deprecated. Use main.playOnAwake instead.", False)]
        public bool playOnAwake { get; set; }
        [Obsolete("duration property is deprecated. Use main.duration instead.", False)]
        public float duration { get; }
        [Obsolete("playbackSpeed property is deprecated. Use main.simulationSpeed instead.", False)]
        public float playbackSpeed { get; set; }
        [Obsolete("enableEmission property is deprecated. Use emission.enabled instead.", False)]
        public bool enableEmission { get; set; }
        [Obsolete("emissionRate property is deprecated. Use emission.rateOverTime, emission.rateOverDistance, emission.rateOverTimeMultiplier or emission.rateOverDistanceMultiplier instead.", False)]
        public float emissionRate { get; set; }
        [Obsolete("startSpeed property is deprecated. Use main.startSpeed or main.startSpeedMultiplier instead.", False)]
        public float startSpeed { get; set; }
        [Obsolete("startSize property is deprecated. Use main.startSize or main.startSizeMultiplier instead.", False)]
        public float startSize { get; set; }
        [Obsolete("startColor property is deprecated. Use main.startColor instead.", False)]
        public Color startColor { get; set; }
        [Obsolete("startRotation property is deprecated. Use main.startRotation or main.startRotationMultiplier instead.", False)]
        public float startRotation { get; set; }
        [Obsolete("startRotation3D property is deprecated. Use main.startRotationX, main.startRotationY and main.startRotationZ instead. (Or main.startRotationXMultiplier, main.startRotationYMultiplier and main.startRotationZMultiplier).", False)]
        public Vector3 startRotation3D { get; set; }
        [Obsolete("startLifetime property is deprecated. Use main.startLifetime or main.startLifetimeMultiplier instead.", False)]
        public float startLifetime { get; set; }
        [Obsolete("gravityModifier property is deprecated. Use main.gravityModifier or main.gravityModifierMultiplier instead.", False)]
        public float gravityModifier { get; set; }
        [Obsolete("maxParticles property is deprecated. Use main.maxParticles instead.", False)]
        public int maxParticles { get; set; }
        [Obsolete("simulationSpace property is deprecated. Use main.simulationSpace instead.", False)]
        public ParticleSystemSimulationSpace simulationSpace { get; set; }
        [Obsolete("scalingMode property is deprecated. Use main.scalingMode instead.", False)]
        public ParticleSystemScalingMode scalingMode { get; set; }
        [Obsolete("automaticCullingEnabled property is deprecated. Use proceduralSimulationSupported instead (UnityUpgradable) -> proceduralSimulationSupported", True)]
        public bool automaticCullingEnabled { get; }
        public bool isPlaying { get; }
        public bool isEmitting { get; }
        public bool isStopped { get; }
        public bool isPaused { get; }
        public int particleCount { get; }
        public float time { get; set; }
        public uint randomSeed { get; set; }
        public bool useAutoRandomSeed { get; set; }
        public bool proceduralSimulationSupported { get; }
        public MainModule main { get; }
        public EmissionModule emission { get; }
        public ShapeModule shape { get; }
        public VelocityOverLifetimeModule velocityOverLifetime { get; }
        public LimitVelocityOverLifetimeModule limitVelocityOverLifetime { get; }
        public InheritVelocityModule inheritVelocity { get; }
        public LifetimeByEmitterSpeedModule lifetimeByEmitterSpeed { get; }
        public ForceOverLifetimeModule forceOverLifetime { get; }
        public ColorOverLifetimeModule colorOverLifetime { get; }
        public ColorBySpeedModule colorBySpeed { get; }
        public SizeOverLifetimeModule sizeOverLifetime { get; }
        public SizeBySpeedModule sizeBySpeed { get; }
        public RotationOverLifetimeModule rotationOverLifetime { get; }
        public RotationBySpeedModule rotationBySpeed { get; }
        public ExternalForcesModule externalForces { get; }
        public NoiseModule noise { get; }
        public CollisionModule collision { get; }
        public TriggerModule trigger { get; }
        public SubEmittersModule subEmitters { get; }
        public TextureSheetAnimationModule textureSheetAnimation { get; }
        public LightsModule lights { get; }
        public TrailModule trails { get; }
        public CustomDataModule customData { get; }

        [Obsolete("Emit with specific parameters is deprecated. Pass a ParticleSystem.EmitParams parameter instead, which allows you to override some/all of the emission properties", False)]
        public void Emit(Vector3 position, Vector3 velocity, float size, float lifetime, Color32 color);
        [Obsolete("Emit with a single particle structure is deprecated. Pass a ParticleSystem.EmitParams parameter instead, which allows you to override some/all of the emission properties", False)]
        public void Emit(Particle particle);
        [FreeFunction(Name = "ParticleSystemScriptBindings::SetParticles", HasExplicitThis = True, ThrowsException = True)]
        public void SetParticles(out Particle[] particles, int size, int offset);
        public void SetParticles(out Particle[] particles, int size);
        public void SetParticles(out Particle[] particles);
        public void SetParticles(out NativeArray<Particle> particles, int size, int offset);
        public void SetParticles(out NativeArray<Particle> particles, int size);
        public void SetParticles(out NativeArray<Particle> particles);
        [FreeFunction(Name = "ParticleSystemScriptBindings::GetParticles", HasExplicitThis = True, ThrowsException = True)]
        public int GetParticles([NotNull("ArgumentNullException")] out Particle[] particles, int size, int offset);
        public int GetParticles(out Particle[] particles, int size);
        public int GetParticles(out Particle[] particles);
        public int GetParticles(out NativeArray<Particle> particles, int size, int offset);
        public int GetParticles(out NativeArray<Particle> particles, int size);
        public int GetParticles(out NativeArray<Particle> particles);
        [FreeFunction(Name = "ParticleSystemScriptBindings::SetCustomParticleData", HasExplicitThis = True, ThrowsException = True)]
        public void SetCustomParticleData([NotNull("ArgumentNullException")] List<Vector4> customData, ParticleSystemCustomData streamIndex);
        [FreeFunction(Name = "ParticleSystemScriptBindings::GetCustomParticleData", HasExplicitThis = True, ThrowsException = True)]
        public int GetCustomParticleData([NotNull("ArgumentNullException")] List<Vector4> customData, ParticleSystemCustomData streamIndex);
        public PlaybackState GetPlaybackState();
        public void SetPlaybackState(PlaybackState playbackState);
        public Trails GetTrails();
        public int GetTrails(ref Trails trailData);
        [FreeFunction(Name = "ParticleSystemScriptBindings::SetTrailData", HasExplicitThis = True)]
        public void SetTrails(Trails trailData);
        [FreeFunction(Name = "ParticleSystemScriptBindings::Simulate", HasExplicitThis = True)]
        public void Simulate(float t, [UnityEngine.Internal.DefaultValue("true")] bool withChildren, [UnityEngine.Internal.DefaultValue("true")] bool restart, [UnityEngine.Internal.DefaultValue("true")] bool fixedTimeStep);
        public void Simulate(float t, [UnityEngine.Internal.DefaultValue("true")] bool withChildren, [UnityEngine.Internal.DefaultValue("true")] bool restart);
        public void Simulate(float t, [UnityEngine.Internal.DefaultValue("true")] bool withChildren);
        public void Simulate(float t);
        [FreeFunction(Name = "ParticleSystemScriptBindings::Play", HasExplicitThis = True)]
        public void Play([UnityEngine.Internal.DefaultValue("true")] bool withChildren);
        public void Play();
        [FreeFunction(Name = "ParticleSystemScriptBindings::Pause", HasExplicitThis = True)]
        public void Pause([UnityEngine.Internal.DefaultValue("true")] bool withChildren);
        public void Pause();
        [FreeFunction(Name = "ParticleSystemScriptBindings::Stop", HasExplicitThis = True)]
        public void Stop([UnityEngine.Internal.DefaultValue("true")] bool withChildren, [UnityEngine.Internal.DefaultValue("ParticleSystemStopBehavior.StopEmitting")] ParticleSystemStopBehavior stopBehavior);
        public void Stop([UnityEngine.Internal.DefaultValue("true")] bool withChildren);
        public void Stop();
        [FreeFunction(Name = "ParticleSystemScriptBindings::Clear", HasExplicitThis = True)]
        public void Clear([UnityEngine.Internal.DefaultValue("true")] bool withChildren);
        public void Clear();
        [FreeFunction(Name = "ParticleSystemScriptBindings::IsAlive", HasExplicitThis = True)]
        public bool IsAlive([UnityEngine.Internal.DefaultValue("true")] bool withChildren);
        public bool IsAlive();
        [RequiredByNativeCode]
        public void Emit(int count);
        [NativeName("SyncJobs()->EmitParticlesExternal")]
        public void Emit(EmitParams emitParams, int count);
        public void TriggerSubEmitter(int subEmitterIndex);
        public void TriggerSubEmitter(int subEmitterIndex, ref Particle particle);
        [FreeFunction(Name = "ParticleSystemScriptBindings::TriggerSubEmitter", HasExplicitThis = True)]
        public void TriggerSubEmitter(int subEmitterIndex, List<Particle> particles);
        [FreeFunction(Name = "ParticleSystemGeometryJob::ResetPreMappedBufferMemory")]
        public static void ResetPreMappedBufferMemory();
        [FreeFunction(Name = "ParticleSystemGeometryJob::SetMaximumPreMappedBufferCounts")]
        public static void SetMaximumPreMappedBufferCounts(int vertexBuffersCount, int indexBuffersCount);
        [NativeName("SetUsesAxisOfRotation")]
        public void AllocateAxisOfRotationAttribute();
        [NativeName("SetUsesMeshIndex")]
        public void AllocateMeshIndexAttribute();
        [NativeName("SetUsesCustomData")]
        public void AllocateCustomDataAttribute(ParticleSystemCustomData stream);

        [NativeType(Custom, "MonoMinMaxCurve", Header = "Runtime/Scripting/ScriptingCommonStructDefinitions.h")]
        public struct MinMaxCurve
        {
            public MinMaxCurve(float constant);
            public MinMaxCurve(float multiplier, AnimationCurve curve);
            public MinMaxCurve(float multiplier, AnimationCurve min, AnimationCurve max);
            public MinMaxCurve(float min, float max);

            [Obsolete("Please use MinMaxCurve.curveMultiplier instead. (UnityUpgradable) -> UnityEngine.ParticleSystem/MinMaxCurve.curveMultiplier", False)]
            public float curveScalar { get; set; }
            public ParticleSystemCurveMode mode { get; set; }
            public float curveMultiplier { get; set; }
            public AnimationCurve curveMax { get; set; }
            public AnimationCurve curveMin { get; set; }
            public float constantMax { get; set; }
            public float constantMin { get; set; }
            public float constant { get; set; }
            public AnimationCurve curve { get; set; }

            public float Evaluate(float time);
            public float Evaluate(float time, float lerpFactor);

            public static implicit operator MinMaxCurve(float constant);
        }
        public struct MainModule
        {
            [Obsolete("Please use flipRotation instead. (UnityUpgradable) -> UnityEngine.ParticleSystem/MainModule.flipRotation", False)]
            public float randomizeRotationDirection { get; set; }
            public float duration { get; set; }
            public bool loop { get; set; }
            public bool prewarm { get; set; }
            public MinMaxCurve startDelay { get; set; }
            public float startDelayMultiplier { get; set; }
            public MinMaxCurve startLifetime { get; set; }
            public float startLifetimeMultiplier { get; set; }
            public MinMaxCurve startSpeed { get; set; }
            public float startSpeedMultiplier { get; set; }
            public bool startSize3D { get; set; }
            [NativeName("StartSizeX")]
            public MinMaxCurve startSize { get; set; }
            [NativeName("StartSizeXMultiplier")]
            public float startSizeMultiplier { get; set; }
            public MinMaxCurve startSizeX { get; set; }
            public float startSizeXMultiplier { get; set; }
            public MinMaxCurve startSizeY { get; set; }
            public float startSizeYMultiplier { get; set; }
            public MinMaxCurve startSizeZ { get; set; }
            public float startSizeZMultiplier { get; set; }
            public bool startRotation3D { get; set; }
            [NativeName("StartRotationZ")]
            public MinMaxCurve startRotation { get; set; }
            [NativeName("StartRotationZMultiplier")]
            public float startRotationMultiplier { get; set; }
            public MinMaxCurve startRotationX { get; set; }
            public float startRotationXMultiplier { get; set; }
            public MinMaxCurve startRotationY { get; set; }
            public float startRotationYMultiplier { get; set; }
            public MinMaxCurve startRotationZ { get; set; }
            public float startRotationZMultiplier { get; set; }
            public float flipRotation { get; set; }
            public MinMaxGradient startColor { get; set; }
            public MinMaxCurve gravityModifier { get; set; }
            public float gravityModifierMultiplier { get; set; }
            public ParticleSystemSimulationSpace simulationSpace { get; set; }
            public Transform customSimulationSpace { get; set; }
            public float simulationSpeed { get; set; }
            public bool useUnscaledTime { get; set; }
            public ParticleSystemScalingMode scalingMode { get; set; }
            public bool playOnAwake { get; set; }
            public int maxParticles { get; set; }
            public ParticleSystemEmitterVelocityMode emitterVelocityMode { get; set; }
            public ParticleSystemStopAction stopAction { get; set; }
            public ParticleSystemRingBufferMode ringBufferMode { get; set; }
            public Vector2 ringBufferLoopRange { get; set; }
            public ParticleSystemCullingMode cullingMode { get; set; }
        }
        public struct EmissionModule
        {
            [Obsolete("ParticleSystemEmissionType no longer does anything. Time and Distance based emission are now both always active.", False)]
            public ParticleSystemEmissionType type { get; set; }
            [Obsolete("rate property is deprecated. Use rateOverTime or rateOverDistance instead.", False)]
            public MinMaxCurve rate { get; set; }
            [Obsolete("rateMultiplier property is deprecated. Use rateOverTimeMultiplier or rateOverDistanceMultiplier instead.", False)]
            public float rateMultiplier { get; set; }
            public bool enabled { get; set; }
            public MinMaxCurve rateOverTime { get; set; }
            public float rateOverTimeMultiplier { get; set; }
            public MinMaxCurve rateOverDistance { get; set; }
            public float rateOverDistanceMultiplier { get; set; }
            public int burstCount { get; set; }

            public void SetBursts(Burst[] bursts);
            public void SetBursts(Burst[] bursts, int size);
            public int GetBursts(Burst[] bursts);
            [NativeThrows]
            public void SetBurst(int index, Burst burst);
            [NativeThrows]
            public Burst GetBurst(int index);
        }
        public struct ShapeModule
        {
            [Obsolete("Please use scale instead. (UnityUpgradable) -> UnityEngine.ParticleSystem/ShapeModule.scale", False)]
            public Vector3 box { get; set; }
            [Obsolete("meshScale property is deprecated.Please use scale instead.", False)]
            public float meshScale { get; set; }
            [Obsolete("randomDirection property is deprecated. Use randomDirectionAmount instead.", False)]
            public bool randomDirection { get; set; }
            public bool enabled { get; set; }
            public ParticleSystemShapeType shapeType { get; set; }
            public float randomDirectionAmount { get; set; }
            public float sphericalDirectionAmount { get; set; }
            public float randomPositionAmount { get; set; }
            public bool alignToDirection { get; set; }
            public float radius { get; set; }
            public ParticleSystemShapeMultiModeValue radiusMode { get; set; }
            public float radiusSpread { get; set; }
            public MinMaxCurve radiusSpeed { get; set; }
            public float radiusSpeedMultiplier { get; set; }
            public float radiusThickness { get; set; }
            public float angle { get; set; }
            public float length { get; set; }
            public Vector3 boxThickness { get; set; }
            public ParticleSystemMeshShapeType meshShapeType { get; set; }
            public Mesh mesh { get; set; }
            public MeshRenderer meshRenderer { get; set; }
            public SkinnedMeshRenderer skinnedMeshRenderer { get; set; }
            public Sprite sprite { get; set; }
            public SpriteRenderer spriteRenderer { get; set; }
            public bool useMeshMaterialIndex { get; set; }
            public int meshMaterialIndex { get; set; }
            public bool useMeshColors { get; set; }
            public float normalOffset { get; set; }
            public ParticleSystemShapeMultiModeValue meshSpawnMode { get; set; }
            public float meshSpawnSpread { get; set; }
            public MinMaxCurve meshSpawnSpeed { get; set; }
            public float meshSpawnSpeedMultiplier { get; set; }
            public float arc { get; set; }
            public ParticleSystemShapeMultiModeValue arcMode { get; set; }
            public float arcSpread { get; set; }
            public MinMaxCurve arcSpeed { get; set; }
            public float arcSpeedMultiplier { get; set; }
            public float donutRadius { get; set; }
            public Vector3 position { get; set; }
            public Vector3 rotation { get; set; }
            public Vector3 scale { get; set; }
            public Texture2D texture { get; set; }
            public ParticleSystemShapeTextureChannel textureClipChannel { get; set; }
            public float textureClipThreshold { get; set; }
            public bool textureColorAffectsParticles { get; set; }
            public bool textureAlphaAffectsParticles { get; set; }
            public bool textureBilinearFiltering { get; set; }
            public int textureUVChannel { get; set; }
        }
        public struct CollisionModule
        {
            [Obsolete("The maxPlaneCount restriction has been removed. Please use planeCount instead to find out how many planes there are. (UnityUpgradable) -> UnityEngine.ParticleSystem/CollisionModule.planeCount", False)]
            public int maxPlaneCount { get; }
            public bool enabled { get; set; }
            public ParticleSystemCollisionType type { get; set; }
            public ParticleSystemCollisionMode mode { get; set; }
            public MinMaxCurve dampen { get; set; }
            public float dampenMultiplier { get; set; }
            public MinMaxCurve bounce { get; set; }
            public float bounceMultiplier { get; set; }
            public MinMaxCurve lifetimeLoss { get; set; }
            public float lifetimeLossMultiplier { get; set; }
            public float minKillSpeed { get; set; }
            public float maxKillSpeed { get; set; }
            public LayerMask collidesWith { get; set; }
            public bool enableDynamicColliders { get; set; }
            public int maxCollisionShapes { get; set; }
            public ParticleSystemCollisionQuality quality { get; set; }
            public float voxelSize { get; set; }
            public float radiusScale { get; set; }
            public bool sendCollisionMessages { get; set; }
            public float colliderForce { get; set; }
            public bool multiplyColliderForceByCollisionAngle { get; set; }
            public bool multiplyColliderForceByParticleSpeed { get; set; }
            public bool multiplyColliderForceByParticleSize { get; set; }
            [NativeThrows]
            public int planeCount { get; }
            [Obsolete("enableInteriorCollisions property is deprecated and is no longer required and has no effect on the particle system.", False)]
            public bool enableInteriorCollisions { get; set; }

            [NativeThrows]
            public void AddPlane(Transform transform);
            [NativeThrows]
            public void RemovePlane(int index);
            public void RemovePlane(Transform transform);
            [NativeThrows]
            public void SetPlane(int index, Transform transform);
            [NativeThrows]
            public Transform GetPlane(int index);
        }
        public struct TriggerModule
        {
            [Obsolete("The maxColliderCount restriction has been removed. Please use colliderCount instead to find out how many colliders there are. (UnityUpgradable) -> UnityEngine.ParticleSystem/TriggerModule.colliderCount", False)]
            public int maxColliderCount { get; }
            public bool enabled { get; set; }
            public ParticleSystemOverlapAction inside { get; set; }
            public ParticleSystemOverlapAction outside { get; set; }
            public ParticleSystemOverlapAction enter { get; set; }
            public ParticleSystemOverlapAction exit { get; set; }
            public ParticleSystemColliderQueryMode colliderQueryMode { get; set; }
            public float radiusScale { get; set; }
            [NativeThrows]
            public int colliderCount { get; }

            [NativeThrows]
            public void AddCollider(Component collider);
            [NativeThrows]
            public void RemoveCollider(int index);
            public void RemoveCollider(Component collider);
            [NativeThrows]
            public void SetCollider(int index, Component collider);
            [NativeThrows]
            public Component GetCollider(int index);
        }
        public struct SubEmittersModule
        {
            [Obsolete("birth0 property is deprecated. Use AddSubEmitter, RemoveSubEmitter, SetSubEmitterSystem and GetSubEmitterSystem instead.", False)]
            public ParticleSystem birth0 { get; set; }
            [Obsolete("birth1 property is deprecated. Use AddSubEmitter, RemoveSubEmitter, SetSubEmitterSystem and GetSubEmitterSystem instead.", False)]
            public ParticleSystem birth1 { get; set; }
            [Obsolete("collision0 property is deprecated. Use AddSubEmitter, RemoveSubEmitter, SetSubEmitterSystem and GetSubEmitterSystem instead.", False)]
            public ParticleSystem collision0 { get; set; }
            [Obsolete("collision1 property is deprecated. Use AddSubEmitter, RemoveSubEmitter, SetSubEmitterSystem and GetSubEmitterSystem instead.", False)]
            public ParticleSystem collision1 { get; set; }
            [Obsolete("death0 property is deprecated. Use AddSubEmitter, RemoveSubEmitter, SetSubEmitterSystem and GetSubEmitterSystem instead.", False)]
            public ParticleSystem death0 { get; set; }
            [Obsolete("death1 property is deprecated. Use AddSubEmitter, RemoveSubEmitter, SetSubEmitterSystem and GetSubEmitterSystem instead.", False)]
            public ParticleSystem death1 { get; set; }
            public bool enabled { get; set; }
            public int subEmittersCount { get; }

            [NativeThrows]
            public void AddSubEmitter(ParticleSystem subEmitter, ParticleSystemSubEmitterType type, ParticleSystemSubEmitterProperties properties, float emitProbability);
            public void AddSubEmitter(ParticleSystem subEmitter, ParticleSystemSubEmitterType type, ParticleSystemSubEmitterProperties properties);
            [NativeThrows]
            public void RemoveSubEmitter(int index);
            public void RemoveSubEmitter(ParticleSystem subEmitter);
            [NativeThrows]
            public void SetSubEmitterSystem(int index, ParticleSystem subEmitter);
            [NativeThrows]
            public void SetSubEmitterType(int index, ParticleSystemSubEmitterType type);
            [NativeThrows]
            public void SetSubEmitterProperties(int index, ParticleSystemSubEmitterProperties properties);
            [NativeThrows]
            public void SetSubEmitterEmitProbability(int index, float emitProbability);
            [NativeThrows]
            public ParticleSystem GetSubEmitterSystem(int index);
            [NativeThrows]
            public ParticleSystemSubEmitterType GetSubEmitterType(int index);
            [NativeThrows]
            public ParticleSystemSubEmitterProperties GetSubEmitterProperties(int index);
            [NativeThrows]
            public float GetSubEmitterEmitProbability(int index);
        }
        public struct TextureSheetAnimationModule
        {
            [Obsolete("flipU property is deprecated. Use ParticleSystemRenderer.flip.x instead.", False)]
            public float flipU { get; set; }
            [Obsolete("flipV property is deprecated. Use ParticleSystemRenderer.flip.y instead.", False)]
            public float flipV { get; set; }
            [Obsolete("useRandomRow property is deprecated. Use rowMode instead.", False)]
            public bool useRandomRow { get; set; }
            public bool enabled { get; set; }
            public ParticleSystemAnimationMode mode { get; set; }
            public ParticleSystemAnimationTimeMode timeMode { get; set; }
            public float fps { get; set; }
            public int numTilesX { get; set; }
            public int numTilesY { get; set; }
            public ParticleSystemAnimationType animation { get; set; }
            public ParticleSystemAnimationRowMode rowMode { get; set; }
            public MinMaxCurve frameOverTime { get; set; }
            public float frameOverTimeMultiplier { get; set; }
            public MinMaxCurve startFrame { get; set; }
            public float startFrameMultiplier { get; set; }
            public int cycleCount { get; set; }
            public int rowIndex { get; set; }
            public UVChannelFlags uvChannelMask { get; set; }
            public int spriteCount { get; }
            public Vector2 speedRange { get; set; }

            [NativeThrows]
            public void AddSprite(Sprite sprite);
            [NativeThrows]
            public void RemoveSprite(int index);
            [NativeThrows]
            public void SetSprite(int index, Sprite sprite);
            [NativeThrows]
            public Sprite GetSprite(int index);
        }
        [RequiredByNativeCode("particleSystemParticle", Optional = True)]
        public struct Particle
        {
            [Obsolete("Please use Particle.remainingLifetime instead. (UnityUpgradable) -> UnityEngine.ParticleSystem/Particle.remainingLifetime", False)]
            public float lifetime { get; set; }
            [Obsolete("randomValue property is deprecated. Use randomSeed instead to control random behavior of particles.", False)]
            public float randomValue { get; set; }
            [Obsolete("size property is deprecated. Use startSize or GetCurrentSize() instead.", False)]
            public float size { get; set; }
            [Obsolete("color property is deprecated. Use startColor or GetCurrentColor() instead.", False)]
            public Color32 color { get; set; }
            public Vector3 position { get; set; }
            public Vector3 velocity { get; set; }
            public Vector3 animatedVelocity { get; }
            public Vector3 totalVelocity { get; }
            public float remainingLifetime { get; set; }
            public float startLifetime { get; set; }
            public Color32 startColor { get; set; }
            public uint randomSeed { get; set; }
            public Vector3 axisOfRotation { get; set; }
            public float startSize { get; set; }
            public Vector3 startSize3D { get; set; }
            public float rotation { get; set; }
            public Vector3 rotation3D { get; set; }
            public float angularVelocity { get; set; }
            public Vector3 angularVelocity3D { get; set; }

            public float GetCurrentSize(ParticleSystem system);
            public Vector3 GetCurrentSize3D(ParticleSystem system);
            public Color32 GetCurrentColor(ParticleSystem system);
            public void SetMeshIndex(int index);
            public int GetMeshIndex(ParticleSystem system);
        }
        [EditorBrowsable(Never)]
        [Obsolete("ParticleSystem.CollisionEvent has been deprecated. Use ParticleCollisionEvent instead (UnityUpgradable)", True)]
        public struct CollisionEvent
        {
            public Vector3 intersection { get; }
            public Vector3 normal { get; }
            public Vector3 velocity { get; }
            public Component collider { get; }
        }
        [NativeType(Custom, "MonoBurst", Header = "Runtime/Scripting/ScriptingCommonStructDefinitions.h")]
        public struct Burst
        {
            public Burst(float _time, short _count);
            public Burst(float _time, short _minCount, short _maxCount);
            public Burst(float _time, short _minCount, short _maxCount, int _cycleCount, float _repeatInterval);
            public Burst(float _time, MinMaxCurve _count);
            public Burst(float _time, MinMaxCurve _count, int _cycleCount, float _repeatInterval);

            public float time { get; set; }
            public MinMaxCurve count { get; set; }
            public short minCount { get; set; }
            public short maxCount { get; set; }
            public int cycleCount { get; set; }
            public float repeatInterval { get; set; }
            public float probability { get; set; }
        }
        [NativeType(Custom, "MonoMinMaxGradient", Header = "Runtime/Scripting/ScriptingCommonStructDefinitions.h")]
        public struct MinMaxGradient
        {
            public MinMaxGradient(Color color);
            public MinMaxGradient(Gradient gradient);
            public MinMaxGradient(Color min, Color max);
            public MinMaxGradient(Gradient min, Gradient max);

            public ParticleSystemGradientMode mode { get; set; }
            public Gradient gradientMax { get; set; }
            public Gradient gradientMin { get; set; }
            public Color colorMax { get; set; }
            public Color colorMin { get; set; }
            public Color color { get; set; }
            public Gradient gradient { get; set; }

            public Color Evaluate(float time);
            public Color Evaluate(float time, float lerpFactor);

            public static implicit operator MinMaxGradient(Color color);
            public static implicit operator MinMaxGradient(Gradient gradient);
        }
        public struct EmitParams
        {
            public Particle particle { get; set; }
            public Vector3 position { get; set; }
            public bool applyShapeToPosition { get; set; }
            public Vector3 velocity { get; set; }
            public float startLifetime { get; set; }
            public float startSize { get; set; }
            public Vector3 startSize3D { get; set; }
            public Vector3 axisOfRotation { get; set; }
            public float rotation { get; set; }
            public Vector3 rotation3D { get; set; }
            public float angularVelocity { get; set; }
            public Vector3 angularVelocity3D { get; set; }
            public Color32 startColor { get; set; }
            public uint randomSeed { get; set; }
            public int meshIndex { set; }

            public void ResetPosition();
            public void ResetVelocity();
            public void ResetAxisOfRotation();
            public void ResetRotation();
            public void ResetAngularVelocity();
            public void ResetStartSize();
            public void ResetStartColor();
            public void ResetRandomSeed();
            public void ResetStartLifetime();
            public void ResetMeshIndex();
        }
        public struct PlaybackState
        {
        }
        [NativeType(Custom, "MonoParticleTrails")]
        public struct Trails
        {
            public int capacity { get; set; }
        }
        public struct ColliderData
        {
            public int GetColliderCount(int particleIndex);
            public Component GetCollider(int particleIndex, int colliderIndex);
        }
        public struct VelocityOverLifetimeModule
        {
            public bool enabled { get; set; }
            public MinMaxCurve x { get; set; }
            public MinMaxCurve y { get; set; }
            public MinMaxCurve z { get; set; }
            public float xMultiplier { get; set; }
            public float yMultiplier { get; set; }
            public float zMultiplier { get; set; }
            public MinMaxCurve orbitalX { get; set; }
            public MinMaxCurve orbitalY { get; set; }
            public MinMaxCurve orbitalZ { get; set; }
            public float orbitalXMultiplier { get; set; }
            public float orbitalYMultiplier { get; set; }
            public float orbitalZMultiplier { get; set; }
            public MinMaxCurve orbitalOffsetX { get; set; }
            public MinMaxCurve orbitalOffsetY { get; set; }
            public MinMaxCurve orbitalOffsetZ { get; set; }
            public float orbitalOffsetXMultiplier { get; set; }
            public float orbitalOffsetYMultiplier { get; set; }
            public float orbitalOffsetZMultiplier { get; set; }
            public MinMaxCurve radial { get; set; }
            public float radialMultiplier { get; set; }
            public MinMaxCurve speedModifier { get; set; }
            public float speedModifierMultiplier { get; set; }
            public ParticleSystemSimulationSpace space { get; set; }
        }
        public struct LimitVelocityOverLifetimeModule
        {
            public bool enabled { get; set; }
            public MinMaxCurve limitX { get; set; }
            public float limitXMultiplier { get; set; }
            public MinMaxCurve limitY { get; set; }
            public float limitYMultiplier { get; set; }
            public MinMaxCurve limitZ { get; set; }
            public float limitZMultiplier { get; set; }
            [NativeName("Magnitude")]
            public MinMaxCurve limit { get; set; }
            [NativeName("MagnitudeMultiplier")]
            public float limitMultiplier { get; set; }
            public float dampen { get; set; }
            public bool separateAxes { get; set; }
            public ParticleSystemSimulationSpace space { get; set; }
            public MinMaxCurve drag { get; set; }
            public float dragMultiplier { get; set; }
            public bool multiplyDragByParticleSize { get; set; }
            public bool multiplyDragByParticleVelocity { get; set; }
        }
        public struct InheritVelocityModule
        {
            public bool enabled { get; set; }
            public ParticleSystemInheritVelocityMode mode { get; set; }
            public MinMaxCurve curve { get; set; }
            public float curveMultiplier { get; set; }
        }
        public struct LifetimeByEmitterSpeedModule
        {
            public bool enabled { get; set; }
            public MinMaxCurve curve { get; set; }
            public float curveMultiplier { get; set; }
            public Vector2 range { get; set; }
        }
        public struct ForceOverLifetimeModule
        {
            public bool enabled { get; set; }
            public MinMaxCurve x { get; set; }
            public MinMaxCurve y { get; set; }
            public MinMaxCurve z { get; set; }
            public float xMultiplier { get; set; }
            public float yMultiplier { get; set; }
            public float zMultiplier { get; set; }
            public ParticleSystemSimulationSpace space { get; set; }
            public bool randomized { get; set; }
        }
        public struct ColorOverLifetimeModule
        {
            public bool enabled { get; set; }
            public MinMaxGradient color { get; set; }
        }
        public struct ColorBySpeedModule
        {
            public bool enabled { get; set; }
            public MinMaxGradient color { get; set; }
            public Vector2 range { get; set; }
        }
        public struct SizeOverLifetimeModule
        {
            public bool enabled { get; set; }
            [NativeName("X")]
            public MinMaxCurve size { get; set; }
            [NativeName("XMultiplier")]
            public float sizeMultiplier { get; set; }
            public MinMaxCurve x { get; set; }
            public float xMultiplier { get; set; }
            public MinMaxCurve y { get; set; }
            public float yMultiplier { get; set; }
            public MinMaxCurve z { get; set; }
            public float zMultiplier { get; set; }
            public bool separateAxes { get; set; }
        }
        public struct SizeBySpeedModule
        {
            public bool enabled { get; set; }
            [NativeName("X")]
            public MinMaxCurve size { get; set; }
            [NativeName("XMultiplier")]
            public float sizeMultiplier { get; set; }
            public MinMaxCurve x { get; set; }
            public float xMultiplier { get; set; }
            public MinMaxCurve y { get; set; }
            public float yMultiplier { get; set; }
            public MinMaxCurve z { get; set; }
            public float zMultiplier { get; set; }
            public bool separateAxes { get; set; }
            public Vector2 range { get; set; }
        }
        public struct RotationOverLifetimeModule
        {
            public bool enabled { get; set; }
            public MinMaxCurve x { get; set; }
            public float xMultiplier { get; set; }
            public MinMaxCurve y { get; set; }
            public float yMultiplier { get; set; }
            public MinMaxCurve z { get; set; }
            public float zMultiplier { get; set; }
            public bool separateAxes { get; set; }
        }
        public struct RotationBySpeedModule
        {
            public bool enabled { get; set; }
            public MinMaxCurve x { get; set; }
            public float xMultiplier { get; set; }
            public MinMaxCurve y { get; set; }
            public float yMultiplier { get; set; }
            public MinMaxCurve z { get; set; }
            public float zMultiplier { get; set; }
            public bool separateAxes { get; set; }
            public Vector2 range { get; set; }
        }
        public struct ExternalForcesModule
        {
            public bool enabled { get; set; }
            public float multiplier { get; set; }
            public MinMaxCurve multiplierCurve { get; set; }
            public ParticleSystemGameObjectFilter influenceFilter { get; set; }
            public LayerMask influenceMask { get; set; }
            [NativeThrows]
            public int influenceCount { get; }

            public bool IsAffectedBy(ParticleSystemForceField field);
            [NativeThrows]
            public void AddInfluence([NotNull("ArgumentNullException")] ParticleSystemForceField field);
            public void RemoveInfluence(int index);
            [NativeThrows]
            public void RemoveInfluence([NotNull("ArgumentNullException")] ParticleSystemForceField field);
            [NativeThrows]
            public void RemoveAllInfluences();
            [NativeThrows]
            public void SetInfluence(int index, [NotNull("ArgumentNullException")] ParticleSystemForceField field);
            [NativeThrows]
            public ParticleSystemForceField GetInfluence(int index);
        }
        public struct NoiseModule
        {
            public bool enabled { get; set; }
            public bool separateAxes { get; set; }
            [NativeName("StrengthX")]
            public MinMaxCurve strength { get; set; }
            [NativeName("StrengthXMultiplier")]
            public float strengthMultiplier { get; set; }
            public MinMaxCurve strengthX { get; set; }
            public float strengthXMultiplier { get; set; }
            public MinMaxCurve strengthY { get; set; }
            public float strengthYMultiplier { get; set; }
            public MinMaxCurve strengthZ { get; set; }
            public float strengthZMultiplier { get; set; }
            public float frequency { get; set; }
            public bool damping { get; set; }
            public int octaveCount { get; set; }
            public float octaveMultiplier { get; set; }
            public float octaveScale { get; set; }
            public ParticleSystemNoiseQuality quality { get; set; }
            public MinMaxCurve scrollSpeed { get; set; }
            public float scrollSpeedMultiplier { get; set; }
            public bool remapEnabled { get; set; }
            [NativeName("RemapX")]
            public MinMaxCurve remap { get; set; }
            [NativeName("RemapXMultiplier")]
            public float remapMultiplier { get; set; }
            public MinMaxCurve remapX { get; set; }
            public float remapXMultiplier { get; set; }
            public MinMaxCurve remapY { get; set; }
            public float remapYMultiplier { get; set; }
            public MinMaxCurve remapZ { get; set; }
            public float remapZMultiplier { get; set; }
            public MinMaxCurve positionAmount { get; set; }
            public MinMaxCurve rotationAmount { get; set; }
            public MinMaxCurve sizeAmount { get; set; }
        }
        public struct LightsModule
        {
            public bool enabled { get; set; }
            public float ratio { get; set; }
            public bool useRandomDistribution { get; set; }
            public Light light { get; set; }
            public bool useParticleColor { get; set; }
            public bool sizeAffectsRange { get; set; }
            public bool alphaAffectsIntensity { get; set; }
            public MinMaxCurve range { get; set; }
            public float rangeMultiplier { get; set; }
            public MinMaxCurve intensity { get; set; }
            public float intensityMultiplier { get; set; }
            public int maxLights { get; set; }
        }
        public struct TrailModule
        {
            public bool enabled { get; set; }
            public ParticleSystemTrailMode mode { get; set; }
            public float ratio { get; set; }
            public MinMaxCurve lifetime { get; set; }
            public float lifetimeMultiplier { get; set; }
            public float minVertexDistance { get; set; }
            public ParticleSystemTrailTextureMode textureMode { get; set; }
            public bool worldSpace { get; set; }
            public bool dieWithParticles { get; set; }
            public bool sizeAffectsWidth { get; set; }
            public bool sizeAffectsLifetime { get; set; }
            public bool inheritParticleColor { get; set; }
            public MinMaxGradient colorOverLifetime { get; set; }
            public MinMaxCurve widthOverTrail { get; set; }
            public float widthOverTrailMultiplier { get; set; }
            public MinMaxGradient colorOverTrail { get; set; }
            public bool generateLightingData { get; set; }
            public int ribbonCount { get; set; }
            public float shadowBias { get; set; }
            public bool splitSubEmitterRibbons { get; set; }
            public bool attachRibbonsToTransform { get; set; }
        }
        public struct CustomDataModule
        {
            public bool enabled { get; set; }

            [NativeThrows]
            public void SetMode(ParticleSystemCustomData stream, ParticleSystemCustomDataMode mode);
            [NativeThrows]
            public ParticleSystemCustomDataMode GetMode(ParticleSystemCustomData stream);
            [NativeThrows]
            public void SetVectorComponentCount(ParticleSystemCustomData stream, int count);
            [NativeThrows]
            public int GetVectorComponentCount(ParticleSystemCustomData stream);
            [NativeThrows]
            public void SetVector(ParticleSystemCustomData stream, int component, MinMaxCurve curve);
            [NativeThrows]
            public MinMaxCurve GetVector(ParticleSystemCustomData stream, int component);
            [NativeThrows]
            public void SetColor(ParticleSystemCustomData stream, MinMaxGradient gradient);
            [NativeThrows]
            public MinMaxGradient GetColor(ParticleSystemCustomData stream);
        }
    }
}
using System;
using System.Collections.Generic;

namespace UnityEngine
{
    public static class ParticlePhysicsExtensions
    {
        [Obsolete("GetCollisionEvents function using ParticleCollisionEvent[] is deprecated. Use List<ParticleCollisionEvent> instead.", False)]
        public static int GetCollisionEvents(this ParticleSystem ps, GameObject go, ParticleCollisionEvent[] collisionEvents);
        public static int GetSafeCollisionEventSize(this ParticleSystem ps);
        public static int GetCollisionEvents(this ParticleSystem ps, GameObject go, List<ParticleCollisionEvent> collisionEvents);
        public static int GetSafeTriggerParticlesSize(this ParticleSystem ps, ParticleSystemTriggerEventType type);
        public static int GetTriggerParticles(this ParticleSystem ps, ParticleSystemTriggerEventType type, List<ParticleSystem.Particle> particles);
        public static int GetTriggerParticles(this ParticleSystem ps, ParticleSystemTriggerEventType type, List<ParticleSystem.Particle> particles, out ParticleSystem.ColliderData colliderData);
        public static void SetTriggerParticles(this ParticleSystem ps, ParticleSystemTriggerEventType type, List<ParticleSystem.Particle> particles, int offset, int count);
        public static void SetTriggerParticles(this ParticleSystem ps, ParticleSystemTriggerEventType type, List<ParticleSystem.Particle> particles);
    }
}
using System;
using System.ComponentModel;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [RequiredByNativeCode(Optional = True)]
    public struct ParticleCollisionEvent
    {
        [Obsolete("collider property is deprecated. Use colliderComponent instead, which supports Collider and Collider2D components (UnityUpgradable) -> colliderComponent", True)]
        [EditorBrowsable(Never)]
        public Component collider { get; }
        public Vector3 intersection { get; }
        public Vector3 normal { get; }
        public Vector3 velocity { get; }
        public Component colliderComponent { get; }
    }
}
namespace UnityEngine
{
    public enum ParticleSystemRenderMode
    {
        Billboard = 0,
        Stretch = 1,
        HorizontalBillboard = 2,
        VerticalBillboard = 3,
        Mesh = 4,
        None = 5
    }
}
namespace UnityEngine
{
    public enum ParticleSystemSortMode
    {
        None = 0,
        Distance = 1,
        OldestInFront = 2,
        YoungestInFront = 3,
        Depth = 4
    }
}
namespace UnityEngine
{
    public enum ParticleSystemCollisionQuality
    {
        High = 0,
        Medium = 1,
        Low = 2
    }
}
namespace UnityEngine
{
    public enum ParticleSystemRenderSpace
    {
        View = 0,
        World = 1,
        Local = 2,
        Facing = 3,
        Velocity = 4
    }
}
namespace UnityEngine
{
    public enum ParticleSystemCurveMode
    {
        Constant = 0,
        Curve = 1,
        TwoCurves = 2,
        TwoConstants = 3
    }
}
namespace UnityEngine
{
    public enum ParticleSystemGradientMode
    {
        Color = 0,
        Gradient = 1,
        TwoColors = 2,
        TwoGradients = 3,
        RandomColor = 4
    }
}
using System;

namespace UnityEngine
{
    public enum ParticleSystemShapeType
    {
        Sphere = 0,
        [Obsolete("SphereShell is deprecated and does nothing. Please use ShapeModule.radiusThickness instead, to control edge emission.", False)]
        SphereShell = 1,
        Hemisphere = 2,
        [Obsolete("HemisphereShell is deprecated and does nothing. Please use ShapeModule.radiusThickness instead, to control edge emission.", False)]
        HemisphereShell = 3,
        Cone = 4,
        Box = 5,
        Mesh = 6,
        [Obsolete("ConeShell is deprecated and does nothing. Please use ShapeModule.radiusThickness instead, to control edge emission.", False)]
        ConeShell = 7,
        ConeVolume = 8,
        [Obsolete("ConeVolumeShell is deprecated and does nothing. Please use ShapeModule.radiusThickness instead, to control edge emission.", False)]
        ConeVolumeShell = 9,
        Circle = 10,
        [Obsolete("CircleEdge is deprecated and does nothing. Please use ShapeModule.radiusThickness instead, to control edge emission.", False)]
        CircleEdge = 11,
        SingleSidedEdge = 12,
        MeshRenderer = 13,
        SkinnedMeshRenderer = 14,
        BoxShell = 15,
        BoxEdge = 16,
        Donut = 17,
        Rectangle = 18,
        Sprite = 19,
        SpriteRenderer = 20
    }
}
namespace UnityEngine
{
    public enum ParticleSystemMeshShapeType
    {
        Vertex = 0,
        Edge = 1,
        Triangle = 2
    }
}
namespace UnityEngine
{
    public enum ParticleSystemShapeTextureChannel
    {
        Red = 0,
        Green = 1,
        Blue = 2,
        Alpha = 3
    }
}
namespace UnityEngine
{
    public enum ParticleSystemAnimationMode
    {
        Grid = 0,
        Sprites = 1
    }
}
namespace UnityEngine
{
    public enum ParticleSystemAnimationTimeMode
    {
        Lifetime = 0,
        Speed = 1,
        FPS = 2
    }
}
namespace UnityEngine
{
    public enum ParticleSystemAnimationType
    {
        WholeSheet = 0,
        SingleRow = 1
    }
}
namespace UnityEngine
{
    public enum ParticleSystemAnimationRowMode
    {
        Custom = 0,
        Random = 1,
        MeshIndex = 2
    }
}
namespace UnityEngine
{
    public enum ParticleSystemCollisionType
    {
        Planes = 0,
        World = 1
    }
}
namespace UnityEngine
{
    public enum ParticleSystemCollisionMode
    {
        Collision3D = 0,
        Collision2D = 1
    }
}
namespace UnityEngine
{
    public enum ParticleSystemOverlapAction
    {
        Ignore = 0,
        Kill = 1,
        Callback = 2
    }
}
namespace UnityEngine
{
    public enum ParticleSystemColliderQueryMode
    {
        Disabled = 0,
        One = 1,
        All = 2
    }
}
namespace UnityEngine
{
    public enum ParticleSystemSimulationSpace
    {
        Local = 0,
        World = 1,
        Custom = 2
    }
}
namespace UnityEngine
{
    public enum ParticleSystemStopBehavior
    {
        StopEmittingAndClear = 0,
        StopEmitting = 1
    }
}
namespace UnityEngine
{
    public enum ParticleSystemScalingMode
    {
        Hierarchy = 0,
        Local = 1,
        Shape = 2
    }
}
namespace UnityEngine
{
    public enum ParticleSystemStopAction
    {
        None = 0,
        Disable = 1,
        Destroy = 2,
        Callback = 3
    }
}
namespace UnityEngine
{
    public enum ParticleSystemCullingMode
    {
        Automatic = 0,
        PauseAndCatchup = 1,
        Pause = 2,
        AlwaysSimulate = 3
    }
}
namespace UnityEngine
{
    public enum ParticleSystemEmitterVelocityMode
    {
        Transform = 0,
        Rigidbody = 1
    }
}
namespace UnityEngine
{
    public enum ParticleSystemInheritVelocityMode
    {
        Initial = 0,
        Current = 1
    }
}
namespace UnityEngine
{
    public enum ParticleSystemTriggerEventType
    {
        Inside = 0,
        Outside = 1,
        Enter = 2,
        Exit = 3
    }
}
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    public enum ParticleSystemVertexStream
    {
        Position = 0,
        Normal = 1,
        Tangent = 2,
        Color = 3,
        UV = 4,
        UV2 = 5,
        UV3 = 6,
        UV4 = 7,
        AnimBlend = 8,
        AnimFrame = 9,
        Center = 10,
        VertexID = 11,
        SizeX = 12,
        SizeXY = 13,
        SizeXYZ = 14,
        Rotation = 15,
        Rotation3D = 16,
        RotationSpeed = 17,
        RotationSpeed3D = 18,
        Velocity = 19,
        Speed = 20,
        AgePercent = 21,
        InvStartLifetime = 22,
        StableRandomX = 23,
        StableRandomXY = 24,
        StableRandomXYZ = 25,
        StableRandomXYZW = 26,
        VaryingRandomX = 27,
        VaryingRandomXY = 28,
        VaryingRandomXYZ = 29,
        VaryingRandomXYZW = 30,
        Custom1X = 31,
        Custom1XY = 32,
        Custom1XYZ = 33,
        Custom1XYZW = 34,
        Custom2X = 35,
        Custom2XY = 36,
        Custom2XYZ = 37,
        Custom2XYZW = 38,
        NoiseSumX = 39,
        NoiseSumXY = 40,
        NoiseSumXYZ = 41,
        NoiseImpulseX = 42,
        NoiseImpulseXY = 43,
        NoiseImpulseXYZ = 44,
        MeshIndex = 45
    }
}
namespace UnityEngine
{
    public enum ParticleSystemCustomData
    {
        Custom1 = 0,
        Custom2 = 1
    }
}
namespace UnityEngine
{
    public enum ParticleSystemCustomDataMode
    {
        Disabled = 0,
        Vector = 1,
        Color = 2
    }
}
namespace UnityEngine
{
    public enum ParticleSystemNoiseQuality
    {
        Low = 0,
        Medium = 1,
        High = 2
    }
}
namespace UnityEngine
{
    public enum ParticleSystemSubEmitterType
    {
        Birth = 0,
        Collision = 1,
        Death = 2,
        Trigger = 3,
        Manual = 4
    }
}
using System;

namespace UnityEngine
{
    [Flags]
    public enum ParticleSystemSubEmitterProperties
    {
        InheritNothing = 0,
        InheritEverything = 31,
        InheritColor = 1,
        InheritSize = 2,
        InheritRotation = 4,
        InheritLifetime = 8,
        InheritDuration = 16
    }
}
namespace UnityEngine
{
    public enum ParticleSystemTrailMode
    {
        PerParticle = 0,
        Ribbon = 1
    }
}
namespace UnityEngine
{
    public enum ParticleSystemTrailTextureMode
    {
        Stretch = 0,
        Tile = 1,
        DistributePerSegment = 2,
        RepeatPerSegment = 3
    }
}
namespace UnityEngine
{
    public enum ParticleSystemShapeMultiModeValue
    {
        Random = 0,
        Loop = 1,
        PingPong = 2,
        BurstSpread = 3
    }
}
namespace UnityEngine
{
    public enum ParticleSystemRingBufferMode
    {
        Disabled = 0,
        PauseUntilReplaced = 1,
        LoopUntilReplaced = 2
    }
}
namespace UnityEngine
{
    public enum ParticleSystemGameObjectFilter
    {
        LayerMask = 0,
        List = 1,
        LayerMaskAndList = 2
    }
}
namespace UnityEngine
{
    public enum ParticleSystemForceFieldShape
    {
        Sphere = 0,
        Hemisphere = 1,
        Cylinder = 2,
        Box = 3
    }
}
using System;

namespace UnityEngine
{
    [Flags]
    [Obsolete("ParticleSystemVertexStreams is deprecated. Please use ParticleSystemVertexStream instead.", False)]
    public enum ParticleSystemVertexStreams
    {
        Position = 1,
        Normal = 2,
        Tangent = 4,
        Color = 8,
        UV = 16,
        UV2BlendAndFrame = 32,
        CenterAndVertexID = 64,
        Size = 128,
        Rotation = 256,
        Velocity = 512,
        Lifetime = 1024,
        Custom1 = 2048,
        Custom2 = 4096,
        Random = 8192,
        None = 0,
        All = 2147483647
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [RequireComponent(typeof(Transform))]
    [NativeHeader("Modules/ParticleSystem/ScriptBindings/ParticleSystemRendererScriptBindings.h")]
    [NativeHeader("Modules/ParticleSystem/ParticleSystemRenderer.h")]
    [NativeHeader("ParticleSystemScriptingClasses.h")]
    public sealed class ParticleSystemRenderer : Renderer
    {
        public ParticleSystemRenderer();

        [NativeName("RenderAlignment")]
        public ParticleSystemRenderSpace alignment { get; set; }
        public ParticleSystemRenderMode renderMode { get; set; }
        public ParticleSystemSortMode sortMode { get; set; }
        public float lengthScale { get; set; }
        public float velocityScale { get; set; }
        public float cameraVelocityScale { get; set; }
        public float normalDirection { get; set; }
        public float shadowBias { get; set; }
        public float sortingFudge { get; set; }
        public float minParticleSize { get; set; }
        public float maxParticleSize { get; set; }
        public Vector3 pivot { get; set; }
        public Vector3 flip { get; set; }
        public SpriteMaskInteraction maskInteraction { get; set; }
        public Material trailMaterial { get; set; }
        public bool enableGPUInstancing { get; set; }
        public bool allowRoll { get; set; }
        public bool freeformStretching { get; set; }
        public bool rotateWithStretchDirection { get; set; }
        public Mesh mesh { get; set; }
        public int meshCount { get; }
        public int activeVertexStreamsCount { get; }
        public bool supportsMeshInstancing { get; }

        [Obsolete("EnableVertexStreams is deprecated.Use SetActiveVertexStreams instead.", False)]
        public void EnableVertexStreams(ParticleSystemVertexStreams streams);
        [Obsolete("DisableVertexStreams is deprecated.Use SetActiveVertexStreams instead.", False)]
        public void DisableVertexStreams(ParticleSystemVertexStreams streams);
        [Obsolete("AreVertexStreamsEnabled is deprecated.Use GetActiveVertexStreams instead.", False)]
        public bool AreVertexStreamsEnabled(ParticleSystemVertexStreams streams);
        [Obsolete("GetEnabledVertexStreams is deprecated.Use GetActiveVertexStreams instead.", False)]
        public ParticleSystemVertexStreams GetEnabledVertexStreams(ParticleSystemVertexStreams streams);
        [RequiredByNativeCode]
        [FreeFunction(Name = "ParticleSystemRendererScriptBindings::GetMeshes", HasExplicitThis = True)]
        public int GetMeshes([NotNull("ArgumentNullException")] out Mesh[] meshes);
        [FreeFunction(Name = "ParticleSystemRendererScriptBindings::SetMeshes", HasExplicitThis = True)]
        public void SetMeshes([NotNull("ArgumentNullException")] Mesh[] meshes, int size);
        public void SetMeshes(Mesh[] meshes);
        public void BakeMesh(Mesh mesh, bool useTransform = False);
        public void BakeMesh([NotNull("ArgumentNullException")] Mesh mesh, [NotNull("ArgumentNullException")] Camera camera, bool useTransform = False);
        public void BakeTrailsMesh(Mesh mesh, bool useTransform = False);
        public void BakeTrailsMesh([NotNull("ArgumentNullException")] Mesh mesh, [NotNull("ArgumentNullException")] Camera camera, bool useTransform = False);
        [FreeFunction(Name = "ParticleSystemRendererScriptBindings::SetActiveVertexStreams", HasExplicitThis = True)]
        public void SetActiveVertexStreams([NotNull("ArgumentNullException")] List<ParticleSystemVertexStream> streams);
        [FreeFunction(Name = "ParticleSystemRendererScriptBindings::GetActiveVertexStreams", HasExplicitThis = True)]
        public void GetActiveVertexStreams([NotNull("ArgumentNullException")] List<ParticleSystemVertexStream> streams);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/ParticleSystem/ParticleSystem.h")]
    [NativeHeader("Modules/ParticleSystem/ParticleSystemForceField.h")]
    [NativeHeader("Modules/ParticleSystem/ParticleSystemForceFieldManager.h")]
    [NativeHeader("Modules/ParticleSystem/ScriptBindings/ParticleSystemScriptBindings.h")]
    [RequireComponent(typeof(Transform))]
    [NativeHeader("ParticleSystemScriptingClasses.h")]
    public class ParticleSystemForceField : Behaviour
    {
        public ParticleSystemForceField();

        [NativeName("ForceShape")]
        public ParticleSystemForceFieldShape shape { get; set; }
        public float startRange { get; set; }
        public float endRange { get; set; }
        public float length { get; set; }
        public float gravityFocus { get; set; }
        public Vector2 rotationRandomness { get; set; }
        public bool multiplyDragByParticleSize { get; set; }
        public bool multiplyDragByParticleVelocity { get; set; }
        public Texture3D vectorField { get; set; }
        public ParticleSystem.MinMaxCurve directionX { get; set; }
        public ParticleSystem.MinMaxCurve directionY { get; set; }
        public ParticleSystem.MinMaxCurve directionZ { get; set; }
        public ParticleSystem.MinMaxCurve gravity { get; set; }
        public ParticleSystem.MinMaxCurve rotationSpeed { get; set; }
        public ParticleSystem.MinMaxCurve rotationAttraction { get; set; }
        public ParticleSystem.MinMaxCurve drag { get; set; }
        public ParticleSystem.MinMaxCurve vectorFieldSpeed { get; set; }
        public ParticleSystem.MinMaxCurve vectorFieldAttraction { get; set; }

        [NativeMethod("GetForceFields")]
        [StaticAccessor("GetParticleSystemForceFieldManager()", Dot)]
        public static ParticleSystemForceField[] FindAll();
    }
}
using System;

namespace UnityEngine.Rendering
{
    [Flags]
    public enum UVChannelFlags
    {
        UV0 = 1,
        UV1 = 2,
        UV2 = 4,
        UV3 = 8
    }
}
using Unity.Jobs.LowLevel.Unsafe;

namespace UnityEngine.ParticleSystemJobs
{
    [JobProducerType(typeof(ParticleSystemJobStruct<>))]
    public interface IJobParticleSystem
    {
        void Execute(ParticleSystemJobData jobData);
    }
}
using Unity.Jobs.LowLevel.Unsafe;

namespace UnityEngine.ParticleSystemJobs
{
    [JobProducerType(typeof(ParticleSystemParallelForJobStruct<>))]
    public interface IJobParticleSystemParallelFor
    {
        void Execute(ParticleSystemJobData jobData, int index);
    }
}
using Unity.Jobs.LowLevel.Unsafe;

namespace UnityEngine.ParticleSystemJobs
{
    [JobProducerType(typeof(ParticleSystemParallelForBatchJobStruct<>))]
    public interface IJobParticleSystemParallelForBatch
    {
        void Execute(ParticleSystemJobData jobData, int startIndex, int count);
    }
}
using Unity.Jobs;

namespace UnityEngine.ParticleSystemJobs
{
    public static class IParticleSystemJobExtensions
    {
        public static JobHandle Schedule<T>(this T jobData, ParticleSystem ps, JobHandle dependsOn = null) where T : IJobParticleSystem, struct;
        public static JobHandle Schedule<T>(this T jobData, ParticleSystem ps, int minIndicesPerJobCount, JobHandle dependsOn = null) where T : IJobParticleSystemParallelFor, struct;
        public static JobHandle ScheduleBatch<T>(this T jobData, ParticleSystem ps, int innerLoopBatchCount, JobHandle dependsOn = null) where T : IJobParticleSystemParallelForBatch, struct;
    }
}
using System.Reflection;
using Unity.Collections;

namespace UnityEngine.ParticleSystemJobs
{
    [DefaultMember("Item")]
    public struct ParticleSystemNativeArray3
    {
        public NativeArray<float> x;
        public NativeArray<float> y;
        public NativeArray<float> z;

        public Vector3 this[int index] { get; set; }
    }
}
using System.Reflection;
using Unity.Collections;

namespace UnityEngine.ParticleSystemJobs
{
    [DefaultMember("Item")]
    public struct ParticleSystemNativeArray4
    {
        public NativeArray<float> x;
        public NativeArray<float> y;
        public NativeArray<float> z;
        public NativeArray<float> w;

        public Vector4 this[int index] { get; set; }
    }
}
using Unity.Collections;

namespace UnityEngine.ParticleSystemJobs
{
    public struct ParticleSystemJobData
    {
        public int count { get; }
        public ParticleSystemNativeArray3 positions { get; }
        public ParticleSystemNativeArray3 velocities { get; }
        public ParticleSystemNativeArray3 axisOfRotations { get; }
        public ParticleSystemNativeArray3 rotations { get; }
        public ParticleSystemNativeArray3 rotationalSpeeds { get; }
        public ParticleSystemNativeArray3 sizes { get; }
        public NativeArray<Color32> startColors { get; }
        public NativeArray<float> aliveTimePercent { get; }
        public NativeArray<float> inverseStartLifetimes { get; }
        public NativeArray<uint> randomSeeds { get; }
        public ParticleSystemNativeArray4 customData1 { get; }
        public ParticleSystemNativeArray4 customData2 { get; }
        public NativeArray<int> meshIndices { get; }
    }
}
-------- {UnityEngine.PerformanceReportingModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.PerformanceReportingModule.dll)}:    0 --------
using UnityEngine.Bindings;

namespace UnityEngine.Analytics
{
    [StaticAccessor("GetPerformanceReportingManager()", Dot)]
    [NativeHeader("Modules/PerformanceReporting/PerformanceReportingManager.h")]
    public static class PerformanceReporting
    {
        public static bool enabled { get; set; }
        public static long graphicsInitializationFinishTime { get; }
    }
}
-------- {UnityEngine.PhysicsModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.PhysicsModule.dll)}:   53 --------
namespace UnityEngine
{
    public enum RigidbodyConstraints
    {
        None = 0,
        FreezePositionX = 2,
        FreezePositionY = 4,
        FreezePositionZ = 8,
        FreezeRotationX = 16,
        FreezeRotationY = 32,
        FreezeRotationZ = 64,
        FreezePosition = 14,
        FreezeRotation = 112,
        FreezeAll = 126
    }
}
namespace UnityEngine
{
    public enum ForceMode
    {
        Force = 0,
        Acceleration = 5,
        Impulse = 1,
        VelocityChange = 2
    }
}
using System;

namespace UnityEngine
{
    [Obsolete("JointDriveMode is no longer supported")]
    [Flags]
    public enum JointDriveMode
    {
        [Obsolete("JointDriveMode.None is no longer supported")]
        None = 0,
        [Obsolete("JointDriveMode.Position is no longer supported")]
        Position = 1,
        [Obsolete("JointDriveMode.Velocity is no longer supported")]
        Velocity = 2,
        [Obsolete("JointDriveMode.PositionAndvelocity is no longer supported")]
        PositionAndVelocity = 3
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    public enum JointProjectionMode
    {
        None = 0,
        PositionAndRotation = 1,
        [EditorBrowsable(Never)]
        [Obsolete("JointProjectionMode.PositionOnly is no longer supported", True)]
        PositionOnly = 2
    }
}
using System;

namespace UnityEngine
{
    [Flags]
    public enum MeshColliderCookingOptions
    {
        None = 0,
        [Obsolete("No longer used because the problem this was trying to solve is gone since Unity 2018.3", True)]
        InflateConvexMesh = 1,
        CookForFasterSimulation = 2,
        EnableMeshCleaning = 4,
        WeldColocatedVertices = 8,
        UseFastMidphase = 16
    }
}
namespace UnityEngine
{
    public struct WheelFrictionCurve
    {
        public float extremumSlip { get; set; }
        public float extremumValue { get; set; }
        public float asymptoteSlip { get; set; }
        public float asymptoteValue { get; set; }
        public float stiffness { get; set; }
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    public struct SoftJointLimit
    {
        public float limit { get; set; }
        [Obsolete("Spring has been moved to SoftJointLimitSpring class in Unity 5", True)]
        [EditorBrowsable(Never)]
        public float spring { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("Damper has been moved to SoftJointLimitSpring class in Unity 5", True)]
        public float damper { get; set; }
        public float bounciness { get; set; }
        public float contactDistance { get; set; }
        [Obsolete("Use SoftJointLimit.bounciness instead", True)]
        [EditorBrowsable(Never)]
        public float bouncyness { get; set; }
    }
}
namespace UnityEngine
{
    public struct SoftJointLimitSpring
    {
        public float spring { get; set; }
        public float damper { get; set; }
    }
}
using System;

namespace UnityEngine
{
    public struct JointDrive
    {
        [Obsolete("JointDriveMode is obsolete")]
        public JointDriveMode mode { get; set; }
        public float positionSpring { get; set; }
        public float positionDamper { get; set; }
        public float maximumForce { get; set; }
    }
}
namespace UnityEngine
{
    public enum RigidbodyInterpolation
    {
        None = 0,
        Interpolate = 1,
        Extrapolate = 2
    }
}
namespace UnityEngine
{
    public struct JointMotor
    {
        public float targetVelocity { get; set; }
        public float force { get; set; }
        public bool freeSpin { get; set; }
    }
}
namespace UnityEngine
{
    public struct JointSpring
    {
        public float spring;
        public float damper;
        public float targetPosition;
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    public struct JointLimits
    {
        [EditorBrowsable(Never)]
        [Obsolete("minBounce and maxBounce are replaced by a single JointLimits.bounciness for both limit ends.", True)]
        public float minBounce;
        [EditorBrowsable(Never)]
        [Obsolete("minBounce and maxBounce are replaced by a single JointLimits.bounciness for both limit ends.", True)]
        public float maxBounce;

        public float min { get; set; }
        public float max { get; set; }
        public float bounciness { get; set; }
        public float bounceMinVelocity { get; set; }
        public float contactDistance { get; set; }
    }
}
using UnityEngine.Scripting;

namespace UnityEngine
{
    [RequiredByNativeCode]
    public class ControllerColliderHit
    {
        public ControllerColliderHit();

        public CharacterController controller { get; }
        public Collider collider { get; }
        public Rigidbody rigidbody { get; }
        public GameObject gameObject { get; }
        public Transform transform { get; }
        public Vector3 point { get; }
        public Vector3 normal { get; }
        public Vector3 moveDirection { get; }
        public float moveLength { get; }
    }
}
namespace UnityEngine
{
    public enum PhysicMaterialCombine
    {
        Average = 0,
        Minimum = 2,
        Multiply = 1,
        Maximum = 3
    }
}
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [RequiredByNativeCode]
    public class Collision
    {
        public Collision();

        public Vector3 relativeVelocity { get; }
        public Rigidbody rigidbody { get; }
        public ArticulationBody articulationBody { get; }
        public Component body { get; }
        public Collider collider { get; }
        public Transform transform { get; }
        public GameObject gameObject { get; }
        public int contactCount { get; }
        public ContactPoint[] contacts { get; }
        public Vector3 impulse { get; }
        [Obsolete("Use Collision.relativeVelocity instead.", False)]
        public Vector3 impactForceSum { get; }
        [Obsolete("Will always return zero.", False)]
        public Vector3 frictionForceSum { get; }
        [Obsolete("Please use Collision.rigidbody, Collision.transform or Collision.collider instead", False)]
        public Component other { get; }

        public ContactPoint GetContact(int index);
        public int GetContacts(ContactPoint[] contacts);
        public int GetContacts(List<ContactPoint> contacts);
        [Obsolete("Do not use Collision.GetEnumerator(), enumerate using non-allocating array returned by Collision.GetContacts() or enumerate using Collision.GetContact(index) instead.", False)]
        public virtual IEnumerator GetEnumerator();
    }
}
namespace UnityEngine
{
    public enum CollisionFlags
    {
        None = 0,
        Sides = 1,
        Above = 2,
        Below = 4,
        CollidedSides = 1,
        CollidedAbove = 2,
        CollidedBelow = 4
    }
}
namespace UnityEngine
{
    public enum QueryTriggerInteraction
    {
        UseGlobal = 0,
        Ignore = 1,
        Collide = 2
    }
}
namespace UnityEngine
{
    public enum CollisionDetectionMode
    {
        Discrete = 0,
        Continuous = 1,
        ContinuousDynamic = 2,
        ContinuousSpeculative = 3
    }
}
namespace UnityEngine
{
    public enum ConfigurableJointMotion
    {
        Locked = 0,
        Limited = 1,
        Free = 2
    }
}
namespace UnityEngine
{
    public enum RotationDriveMode
    {
        XYAndZ = 0,
        Slerp = 1
    }
}
using System;
using System.ComponentModel;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics/PhysicMaterial.h")]
    public class PhysicMaterial : Object
    {
        public PhysicMaterial();
        public PhysicMaterial(string name);

        public float bounciness { get; set; }
        public float dynamicFriction { get; set; }
        public float staticFriction { get; set; }
        public PhysicMaterialCombine frictionCombine { get; set; }
        public PhysicMaterialCombine bounceCombine { get; set; }
        [Obsolete("Use PhysicMaterial.bounciness instead (UnityUpgradable) -> bounciness")]
        public float bouncyness { get; set; }
        [Obsolete("Anisotropic friction is no longer supported since Unity 5.0.", True)]
        [EditorBrowsable(Never)]
        public Vector3 frictionDirection2 { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("Anisotropic friction is no longer supported since Unity 5.0.", True)]
        public float dynamicFriction2 { get; set; }
        [Obsolete("Anisotropic friction is no longer supported since Unity 5.0.", True)]
        [EditorBrowsable(Never)]
        public float staticFriction2 { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("Anisotropic friction is no longer supported since Unity 5.0.", True)]
        public Vector3 frictionDirection { get; set; }
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("PhysicsScriptingClasses.h")]
    [NativeHeader("Modules/Physics/RaycastHit.h")]
    [UsedByNativeCode]
    [NativeHeader("Runtime/Interfaces/IRaycast.h")]
    public struct RaycastHit
    {
        public Collider collider { get; }
        public Vector3 point { get; set; }
        public Vector3 normal { get; set; }
        public Vector3 barycentricCoordinate { get; set; }
        public float distance { get; set; }
        public int triangleIndex { get; }
        public Vector2 textureCoord { get; }
        public Vector2 textureCoord2 { get; }
        [Obsolete("Use textureCoord2 instead. (UnityUpgradable) -> textureCoord2")]
        public Vector2 textureCoord1 { get; }
        public Transform transform { get; }
        public Rigidbody rigidbody { get; }
        public ArticulationBody articulationBody { get; }
        public Vector2 lightmapCoord { get; }
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Internal;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics/Rigidbody.h")]
    [RequireComponent(typeof(Transform))]
    public class Rigidbody : Component
    {
        public Rigidbody();

        public Vector3 velocity { get; set; }
        public Vector3 angularVelocity { get; set; }
        public float drag { get; set; }
        public float angularDrag { get; set; }
        public float mass { get; set; }
        public bool useGravity { get; set; }
        public float maxDepenetrationVelocity { get; set; }
        public bool isKinematic { get; set; }
        public bool freezeRotation { get; set; }
        public RigidbodyConstraints constraints { get; set; }
        public CollisionDetectionMode collisionDetectionMode { get; set; }
        public Vector3 centerOfMass { get; set; }
        public Vector3 worldCenterOfMass { get; }
        public Quaternion inertiaTensorRotation { get; set; }
        public Vector3 inertiaTensor { get; set; }
        public bool detectCollisions { get; set; }
        public Vector3 position { get; set; }
        public Quaternion rotation { get; set; }
        public RigidbodyInterpolation interpolation { get; set; }
        public int solverIterations { get; set; }
        public float sleepThreshold { get; set; }
        public float maxAngularVelocity { get; set; }
        public int solverVelocityIterations { get; set; }
        [Obsolete("The sleepVelocity is no longer supported. Use sleepThreshold. Note that sleepThreshold is energy but not velocity.")]
        public float sleepVelocity { get; set; }
        [Obsolete("The sleepAngularVelocity is no longer supported. Set Use sleepThreshold to specify energy.")]
        public float sleepAngularVelocity { get; set; }
        [Obsolete("Cone friction is no longer supported.")]
        public bool useConeFriction { get; set; }
        [Obsolete("Please use Rigidbody.solverIterations instead. (UnityUpgradable) -> solverIterations")]
        public int solverIterationCount { get; set; }
        [Obsolete("Please use Rigidbody.solverVelocityIterations instead. (UnityUpgradable) -> solverVelocityIterations")]
        public int solverVelocityIterationCount { get; set; }

        public void SetDensity(float density);
        public void MovePosition(Vector3 position);
        public void MoveRotation(Quaternion rot);
        public void Sleep();
        public bool IsSleeping();
        public void WakeUp();
        public void ResetCenterOfMass();
        public void ResetInertiaTensor();
        public Vector3 GetRelativePointVelocity(Vector3 relativePoint);
        public Vector3 GetPointVelocity(Vector3 worldPoint);
        [Obsolete("Use Rigidbody.maxAngularVelocity instead.")]
        public void SetMaxAngularVelocity(float a);
        public void AddForce(Vector3 force, [DefaultValue("ForceMode.Force")] ForceMode mode);
        [ExcludeFromDocs]
        public void AddForce(Vector3 force);
        public void AddForce(float x, float y, float z, [DefaultValue("ForceMode.Force")] ForceMode mode);
        [ExcludeFromDocs]
        public void AddForce(float x, float y, float z);
        public void AddRelativeForce(Vector3 force, [DefaultValue("ForceMode.Force")] ForceMode mode);
        [ExcludeFromDocs]
        public void AddRelativeForce(Vector3 force);
        public void AddRelativeForce(float x, float y, float z, [DefaultValue("ForceMode.Force")] ForceMode mode);
        [ExcludeFromDocs]
        public void AddRelativeForce(float x, float y, float z);
        public void AddTorque(Vector3 torque, [DefaultValue("ForceMode.Force")] ForceMode mode);
        [ExcludeFromDocs]
        public void AddTorque(Vector3 torque);
        public void AddTorque(float x, float y, float z, [DefaultValue("ForceMode.Force")] ForceMode mode);
        [ExcludeFromDocs]
        public void AddTorque(float x, float y, float z);
        public void AddRelativeTorque(Vector3 torque, [DefaultValue("ForceMode.Force")] ForceMode mode);
        [ExcludeFromDocs]
        public void AddRelativeTorque(Vector3 torque);
        public void AddRelativeTorque(float x, float y, float z, [DefaultValue("ForceMode.Force")] ForceMode mode);
        [ExcludeFromDocs]
        public void AddRelativeTorque(float x, float y, float z);
        public void AddForceAtPosition(Vector3 force, Vector3 position, [DefaultValue("ForceMode.Force")] ForceMode mode);
        [ExcludeFromDocs]
        public void AddForceAtPosition(Vector3 force, Vector3 position);
        public void AddExplosionForce(float explosionForce, Vector3 explosionPosition, float explosionRadius, [DefaultValue("0.0f")] float upwardsModifier, [DefaultValue("ForceMode.Force)")] ForceMode mode);
        [ExcludeFromDocs]
        public void AddExplosionForce(float explosionForce, Vector3 explosionPosition, float explosionRadius, float upwardsModifier);
        [ExcludeFromDocs]
        public void AddExplosionForce(float explosionForce, Vector3 explosionPosition, float explosionRadius);
        public Vector3 ClosestPointOnBounds(Vector3 position);
        public bool SweepTest(Vector3 direction, out RaycastHit hitInfo, [DefaultValue("Mathf.Infinity")] float maxDistance, [DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [ExcludeFromDocs]
        public bool SweepTest(Vector3 direction, out RaycastHit hitInfo, float maxDistance);
        [ExcludeFromDocs]
        public bool SweepTest(Vector3 direction, out RaycastHit hitInfo);
        public RaycastHit[] SweepTestAll(Vector3 direction, [DefaultValue("Mathf.Infinity")] float maxDistance, [DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [ExcludeFromDocs]
        public RaycastHit[] SweepTestAll(Vector3 direction, float maxDistance);
        [ExcludeFromDocs]
        public RaycastHit[] SweepTestAll(Vector3 direction);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics/Collider.h")]
    [RequireComponent(typeof(Transform))]
    [RequiredByNativeCode]
    public class Collider : Component
    {
        public Collider();

        public bool enabled { get; set; }
        public Rigidbody attachedRigidbody { get; }
        public ArticulationBody attachedArticulationBody { get; }
        public bool isTrigger { get; set; }
        public float contactOffset { get; set; }
        public Bounds bounds { get; }
        [NativeMethod("Material")]
        public PhysicMaterial sharedMaterial { get; set; }
        public PhysicMaterial material { get; set; }

        public Vector3 ClosestPoint(Vector3 position);
        public bool Raycast(Ray ray, out RaycastHit hitInfo, float maxDistance);
        public Vector3 ClosestPointOnBounds(Vector3 position);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics/CharacterController.h")]
    public class CharacterController : Collider
    {
        public CharacterController();

        public Vector3 velocity { get; }
        public bool isGrounded { get; }
        public CollisionFlags collisionFlags { get; }
        public float radius { get; set; }
        public float height { get; set; }
        public Vector3 center { get; set; }
        public float slopeLimit { get; set; }
        public float stepOffset { get; set; }
        public float skinWidth { get; set; }
        public float minMoveDistance { get; set; }
        public bool detectCollisions { get; set; }
        public bool enableOverlapRecovery { get; set; }

        public bool SimpleMove(Vector3 speed);
        public CollisionFlags Move(Vector3 motion);
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics/MeshCollider.h")]
    [NativeHeader("Runtime/Graphics/Mesh/Mesh.h")]
    [RequiredByNativeCode]
    public class MeshCollider : Collider
    {
        public MeshCollider();

        public Mesh sharedMesh { get; set; }
        public bool convex { get; set; }
        [Obsolete("MeshCollider.inflateMesh is no longer supported. The new cooking algorithm doesn't need inflation to be used.")]
        public bool inflateMesh { get; set; }
        public MeshColliderCookingOptions cookingOptions { get; set; }
        [Obsolete("MeshCollider.skinWidth is no longer used.")]
        public float skinWidth { get; set; }
        [Obsolete("Configuring smooth sphere collisions is no longer needed.")]
        public bool smoothSphereCollisions { get; set; }
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics/CapsuleCollider.h")]
    [RequiredByNativeCode]
    public class CapsuleCollider : Collider
    {
        public CapsuleCollider();

        public Vector3 center { get; set; }
        public float radius { get; set; }
        public float height { get; set; }
        public int direction { get; set; }
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics/BoxCollider.h")]
    [RequiredByNativeCode]
    public class BoxCollider : Collider
    {
        public BoxCollider();

        public Vector3 center { get; set; }
        public Vector3 size { get; set; }
        [Obsolete("Use BoxCollider.size instead.")]
        public Vector3 extents { get; set; }
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics/SphereCollider.h")]
    [RequiredByNativeCode]
    public class SphereCollider : Collider
    {
        public SphereCollider();

        public Vector3 center { get; set; }
        public float radius { get; set; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [RequireComponent(typeof(Rigidbody))]
    [NativeHeader("Modules/Physics/ConstantForce.h")]
    public class ConstantForce : Behaviour
    {
        public ConstantForce();

        public Vector3 force { get; set; }
        public Vector3 relativeForce { get; set; }
        public Vector3 torque { get; set; }
        public Vector3 relativeTorque { get; set; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [RequireComponent(typeof(Rigidbody))]
    [NativeClass("Unity::Joint")]
    [NativeHeader("Modules/Physics/Joint.h")]
    public class Joint : Component
    {
        public Joint();

        public Rigidbody connectedBody { get; set; }
        public ArticulationBody connectedArticulationBody { get; set; }
        public Vector3 axis { get; set; }
        public Vector3 anchor { get; set; }
        public Vector3 connectedAnchor { get; set; }
        public bool autoConfigureConnectedAnchor { get; set; }
        public float breakForce { get; set; }
        public float breakTorque { get; set; }
        public bool enableCollision { get; set; }
        public bool enablePreprocessing { get; set; }
        public float massScale { get; set; }
        public float connectedMassScale { get; set; }
        public Vector3 currentForce { get; }
        public Vector3 currentTorque { get; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeClass("Unity::HingeJoint")]
    [NativeHeader("Modules/Physics/HingeJoint.h")]
    public class HingeJoint : Joint
    {
        public HingeJoint();

        public JointMotor motor { get; set; }
        public JointLimits limits { get; set; }
        public JointSpring spring { get; set; }
        public bool useMotor { get; set; }
        public bool useLimits { get; set; }
        public bool useSpring { get; set; }
        public float velocity { get; }
        public float angle { get; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics/SpringJoint.h")]
    [NativeClass("Unity::SpringJoint")]
    public class SpringJoint : Joint
    {
        public SpringJoint();

        public float spring { get; set; }
        public float damper { get; set; }
        public float minDistance { get; set; }
        public float maxDistance { get; set; }
        public float tolerance { get; set; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics/FixedJoint.h")]
    [NativeClass("Unity::FixedJoint")]
    public class FixedJoint : Joint
    {
        public FixedJoint();
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics/CharacterJoint.h")]
    [NativeClass("Unity::CharacterJoint")]
    public class CharacterJoint : Joint
    {
        [Obsolete("TargetRotation not in use for Unity 5 and assumed disabled.", True)]
        public Quaternion targetRotation;
        [Obsolete("TargetAngularVelocity not in use for Unity 5 and assumed disabled.", True)]
        public Vector3 targetAngularVelocity;
        [Obsolete("RotationDrive not in use for Unity 5 and assumed disabled.")]
        public JointDrive rotationDrive;

        public CharacterJoint();

        public Vector3 swingAxis { get; set; }
        public SoftJointLimitSpring twistLimitSpring { get; set; }
        public SoftJointLimitSpring swingLimitSpring { get; set; }
        public SoftJointLimit lowTwistLimit { get; set; }
        public SoftJointLimit highTwistLimit { get; set; }
        public SoftJointLimit swing1Limit { get; set; }
        public SoftJointLimit swing2Limit { get; set; }
        public bool enableProjection { get; set; }
        public float projectionDistance { get; set; }
        public float projectionAngle { get; set; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics/ConfigurableJoint.h")]
    [NativeClass("Unity::ConfigurableJoint")]
    public class ConfigurableJoint : Joint
    {
        public ConfigurableJoint();

        public Vector3 secondaryAxis { get; set; }
        public ConfigurableJointMotion xMotion { get; set; }
        public ConfigurableJointMotion yMotion { get; set; }
        public ConfigurableJointMotion zMotion { get; set; }
        public ConfigurableJointMotion angularXMotion { get; set; }
        public ConfigurableJointMotion angularYMotion { get; set; }
        public ConfigurableJointMotion angularZMotion { get; set; }
        public SoftJointLimitSpring linearLimitSpring { get; set; }
        public SoftJointLimitSpring angularXLimitSpring { get; set; }
        public SoftJointLimitSpring angularYZLimitSpring { get; set; }
        public SoftJointLimit linearLimit { get; set; }
        public SoftJointLimit lowAngularXLimit { get; set; }
        public SoftJointLimit highAngularXLimit { get; set; }
        public SoftJointLimit angularYLimit { get; set; }
        public SoftJointLimit angularZLimit { get; set; }
        public Vector3 targetPosition { get; set; }
        public Vector3 targetVelocity { get; set; }
        public JointDrive xDrive { get; set; }
        public JointDrive yDrive { get; set; }
        public JointDrive zDrive { get; set; }
        public Quaternion targetRotation { get; set; }
        public Vector3 targetAngularVelocity { get; set; }
        public RotationDriveMode rotationDriveMode { get; set; }
        public JointDrive angularXDrive { get; set; }
        public JointDrive angularYZDrive { get; set; }
        public JointDrive slerpDrive { get; set; }
        public JointProjectionMode projectionMode { get; set; }
        public float projectionDistance { get; set; }
        public float projectionAngle { get; set; }
        public bool configuredInWorldSpace { get; set; }
        public bool swapBodies { get; set; }
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    [NativeHeader("Modules/Physics/MessageParameters.h")]
    public struct ContactPoint
    {
        public Vector3 point { get; }
        public Vector3 normal { get; }
        public Collider thisCollider { get; }
        public Collider otherCollider { get; }
        public float separation { get; }
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Internal;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics/Public/PhysicsSceneHandle.h")]
    public struct PhysicsScene : IEquatable<PhysicsScene>
    {
        public override string ToString();
        public override int GetHashCode();
        public override bool Equals(object other);
        public bool Equals(PhysicsScene other);
        public bool IsValid();
        public bool IsEmpty();
        public void Simulate(float step);
        public bool Raycast(Vector3 origin, Vector3 direction, [DefaultValue("Mathf.Infinity")] float maxDistance = InfinityF, [DefaultValue("Physics.DefaultRaycastLayers")] int layerMask = -5, [DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction = UseGlobal);
        public bool Raycast(Vector3 origin, Vector3 direction, out RaycastHit hitInfo, [DefaultValue("Mathf.Infinity")] float maxDistance = InfinityF, [DefaultValue("Physics.DefaultRaycastLayers")] int layerMask = -5, [DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction = UseGlobal);
        public int Raycast(Vector3 origin, Vector3 direction, RaycastHit[] raycastHits, [DefaultValue("Mathf.Infinity")] float maxDistance = InfinityF, [DefaultValue("Physics.DefaultRaycastLayers")] int layerMask = -5, [DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction = UseGlobal);
        public bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, out RaycastHit hitInfo, [DefaultValue("Mathf.Infinity")] float maxDistance = InfinityF, [DefaultValue("DefaultRaycastLayers")] int layerMask = -5, [DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction = UseGlobal);
        public int CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit[] results, [DefaultValue("Mathf.Infinity")] float maxDistance = InfinityF, [DefaultValue("DefaultRaycastLayers")] int layerMask = -5, [DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction = UseGlobal);
        public int OverlapCapsule(Vector3 point0, Vector3 point1, float radius, Collider[] results, [DefaultValue("AllLayers")] int layerMask = -1, [DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction = UseGlobal);
        public bool SphereCast(Vector3 origin, float radius, Vector3 direction, out RaycastHit hitInfo, [DefaultValue("Mathf.Infinity")] float maxDistance = InfinityF, [DefaultValue("DefaultRaycastLayers")] int layerMask = -5, [DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction = UseGlobal);
        public int SphereCast(Vector3 origin, float radius, Vector3 direction, RaycastHit[] results, [DefaultValue("Mathf.Infinity")] float maxDistance = InfinityF, [DefaultValue("DefaultRaycastLayers")] int layerMask = -5, [DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction = UseGlobal);
        public int OverlapSphere(Vector3 position, float radius, Collider[] results, [DefaultValue("AllLayers")] int layerMask, [DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        public bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, out RaycastHit hitInfo, [DefaultValue("Quaternion.identity")] Quaternion orientation, [DefaultValue("Mathf.Infinity")] float maxDistance = InfinityF, [DefaultValue("DefaultRaycastLayers")] int layerMask = -5, [DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction = UseGlobal);
        [ExcludeFromDocs]
        public bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, out RaycastHit hitInfo);
        public int OverlapBox(Vector3 center, Vector3 halfExtents, Collider[] results, [DefaultValue("Quaternion.identity")] Quaternion orientation, [DefaultValue("DefaultRaycastLayers")] int layerMask = -5, [DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction = UseGlobal);
        [ExcludeFromDocs]
        public int OverlapBox(Vector3 center, Vector3 halfExtents, Collider[] results);
        public int BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit[] results, [DefaultValue("Quaternion.identity")] Quaternion orientation, [DefaultValue("Mathf.Infinity")] float maxDistance = InfinityF, [DefaultValue("DefaultRaycastLayers")] int layerMask = -5, [DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction = UseGlobal);
        [ExcludeFromDocs]
        public int BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit[] results);

        public static bool operator ==(PhysicsScene lhs, PhysicsScene rhs);
        public static bool operator !=(PhysicsScene lhs, PhysicsScene rhs);
    }
}
using UnityEngine.SceneManagement;

namespace UnityEngine
{
    public static class PhysicsSceneExtensions
    {
        public static PhysicsScene GetPhysicsScene(this Scene scene);
    }
}
namespace UnityEngine
{
    public enum ArticulationJointType
    {
        FixedJoint = 0,
        PrismaticJoint = 1,
        RevoluteJoint = 2,
        SphericalJoint = 3
    }
}
namespace UnityEngine
{
    public enum ArticulationDofLock
    {
        LockedMotion = 0,
        LimitedMotion = 1,
        FreeMotion = 2
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics/ArticulationBody.h")]
    public struct ArticulationDrive
    {
        public float lowerLimit;
        public float upperLimit;
        public float stiffness;
        public float damping;
        public float forceLimit;
        public float target;
        public float targetVelocity;
    }
}
using System.Reflection;
using System.Runtime.CompilerServices;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics/ArticulationBody.h")]
    [DefaultMember("Item")]
    public struct ArticulationReducedSpace
    {
        public int dofCount;

        public ArticulationReducedSpace(float a);
        public ArticulationReducedSpace(float a, float b);
        public ArticulationReducedSpace(float a, float b, float c);

        public float this[int i] { get; set; }

        [CompilerGenerated]
        [UnsafeValueType]
        public struct <x>e__FixedBuffer
        {
            public float FixedElementField;
        }
    }
}
using System.Collections.Generic;
using System.Reflection;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics/ArticulationBody.h")]
    [DefaultMember("Item")]
    public struct ArticulationJacobian
    {
        public ArticulationJacobian(int rows, int cols);

        public float this[int row, int col] { get; set; }
        public int rows { get; set; }
        public int columns { get; set; }
        public List<float> elements { get; set; }
    }
}
using System.Collections.Generic;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeClass("Unity::ArticulationBody")]
    [NativeHeader("Modules/Physics/ArticulationBody.h")]
    public class ArticulationBody : Behaviour
    {
        public ArticulationBody();

        public ArticulationJointType jointType { get; set; }
        public Vector3 anchorPosition { get; set; }
        public Vector3 parentAnchorPosition { get; set; }
        public Quaternion anchorRotation { get; set; }
        public Quaternion parentAnchorRotation { get; set; }
        public bool isRoot { get; }
        public ArticulationDofLock linearLockX { get; set; }
        public ArticulationDofLock linearLockY { get; set; }
        public ArticulationDofLock linearLockZ { get; set; }
        public ArticulationDofLock swingYLock { get; set; }
        public ArticulationDofLock swingZLock { get; set; }
        public ArticulationDofLock twistLock { get; set; }
        public ArticulationDrive xDrive { get; set; }
        public ArticulationDrive yDrive { get; set; }
        public ArticulationDrive zDrive { get; set; }
        public bool immovable { get; set; }
        public bool useGravity { get; set; }
        public float linearDamping { get; set; }
        public float angularDamping { get; set; }
        public float jointFriction { get; set; }
        public Vector3 velocity { get; set; }
        public Vector3 angularVelocity { get; set; }
        public float mass { get; set; }
        public Vector3 centerOfMass { get; set; }
        public Vector3 worldCenterOfMass { get; }
        public Vector3 inertiaTensor { get; set; }
        public Quaternion inertiaTensorRotation { get; set; }
        public float sleepThreshold { get; set; }
        public int solverIterations { get; set; }
        public int solverVelocityIterations { get; set; }
        public float maxAngularVelocity { get; set; }
        public float maxLinearVelocity { get; set; }
        public float maxJointVelocity { get; set; }
        public float maxDepenetrationVelocity { get; set; }
        public ArticulationReducedSpace jointPosition { get; set; }
        public ArticulationReducedSpace jointVelocity { get; set; }
        public ArticulationReducedSpace jointAcceleration { get; set; }
        public ArticulationReducedSpace jointForce { get; set; }
        public int dofCount { get; }
        public int index { get; }
        public CollisionDetectionMode collisionDetectionMode { get; set; }

        public void AddForce(Vector3 force);
        public void AddRelativeForce(Vector3 force);
        public void AddTorque(Vector3 torque);
        public void AddRelativeTorque(Vector3 torque);
        public void AddForceAtPosition(Vector3 force, Vector3 position);
        public void ResetCenterOfMass();
        public void ResetInertiaTensor();
        public void Sleep();
        public bool IsSleeping();
        public void WakeUp();
        public void TeleportRoot(Vector3 position, Quaternion rotation);
        public Vector3 GetClosestPoint(Vector3 point);
        public Vector3 GetRelativePointVelocity(Vector3 relativePoint);
        public Vector3 GetPointVelocity(Vector3 worldPoint);
        public int GetDenseJacobian(ref ArticulationJacobian jacobian);
        public int GetJointPositions(List<float> positions);
        public void SetJointPositions(List<float> positions);
        public int GetJointVelocities(List<float> velocities);
        public void SetJointVelocities(List<float> velocities);
        public int GetJointAccelerations(List<float> accelerations);
        public void SetJointAccelerations(List<float> accelerations);
        public int GetJointForces(List<float> forces);
        public void SetJointForces(List<float> forces);
        public int GetDriveTargets(List<float> targets);
        public void SetDriveTargets(List<float> targets);
        public int GetDriveTargetVelocities(List<float> targetVelocities);
        public void SetDriveTargetVelocities(List<float> targetVelocities);
        public int GetDofStartIndices(List<int> dofStartIndices);
    }
}
using System;
using System.ComponentModel;
using UnityEngine.Bindings;
using UnityEngine.Internal;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics/PhysicsManager.h")]
    [StaticAccessor("GetPhysicsManager()", Dot)]
    public class Physics
    {
        public const int IgnoreRaycastLayer = 4;
        public const int DefaultRaycastLayers = -5;
        public const int AllLayers = -1;
        [Obsolete("Please use Physics.IgnoreRaycastLayer instead. (UnityUpgradable) -> IgnoreRaycastLayer", True)]
        [EditorBrowsable(Never)]
        public const int kIgnoreRaycastLayer = 4;
        [Obsolete("Please use Physics.DefaultRaycastLayers instead. (UnityUpgradable) -> DefaultRaycastLayers", True)]
        [EditorBrowsable(Never)]
        public const int kDefaultRaycastLayers = -5;
        [Obsolete("Please use Physics.AllLayers instead. (UnityUpgradable) -> AllLayers", True)]
        [EditorBrowsable(Never)]
        public const int kAllLayers = -1;

        public Physics();

        [EditorBrowsable(Never)]
        [Obsolete("Use Physics.defaultContactOffset or Collider.contactOffset instead.", True)]
        public static float minPenetrationForPenalty { get; set; }
        public static Vector3 gravity { get; set; }
        public static float defaultContactOffset { get; set; }
        public static float sleepThreshold { get; set; }
        public static bool queriesHitTriggers { get; set; }
        public static bool queriesHitBackfaces { get; set; }
        public static float bounceThreshold { get; set; }
        public static float defaultMaxDepenetrationVelocity { get; set; }
        public static int defaultSolverIterations { get; set; }
        public static int defaultSolverVelocityIterations { get; set; }
        [Obsolete("Please use bounceThreshold instead.")]
        public static float bounceTreshold { get; set; }
        [Obsolete("The sleepVelocity is no longer supported. Use sleepThreshold. Note that sleepThreshold is energy but not velocity.")]
        public static float sleepVelocity { get; set; }
        [Obsolete("The sleepAngularVelocity is no longer supported. Use sleepThreshold. Note that sleepThreshold is energy but not velocity.")]
        public static float sleepAngularVelocity { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("Use Rigidbody.maxAngularVelocity instead.", True)]
        public static float maxAngularVelocity { get; set; }
        [Obsolete("Please use Physics.defaultSolverIterations instead. (UnityUpgradable) -> defaultSolverIterations")]
        public static int solverIterationCount { get; set; }
        [Obsolete("Please use Physics.defaultSolverVelocityIterations instead. (UnityUpgradable) -> defaultSolverVelocityIterations")]
        public static int solverVelocityIterationCount { get; set; }
        [Obsolete("penetrationPenaltyForce has no effect.")]
        public static float penetrationPenaltyForce { get; set; }
        public static float defaultMaxAngularSpeed { get; set; }
        [NativeProperty("DefaultPhysicsSceneHandle")]
        public static PhysicsScene defaultPhysicsScene { get; }
        public static bool autoSimulation { get; set; }
        public static bool autoSyncTransforms { get; set; }
        public static bool reuseCollisionCallbacks { get; set; }
        [StaticAccessor("GetPhysicsManager()")]
        public static float interCollisionDistance { get; set; }
        [StaticAccessor("GetPhysicsManager()")]
        public static float interCollisionStiffness { get; set; }
        [StaticAccessor("GetPhysicsManager()")]
        public static bool interCollisionSettingsToggle { get; set; }
        public static Vector3 clothGravity { get; set; }

        public static void IgnoreCollision([NotNull("NullExceptionObject")] Collider collider1, [NotNull("NullExceptionObject")] Collider collider2, [UnityEngine.Internal.DefaultValue("true")] bool ignore);
        [ExcludeFromDocs]
        public static void IgnoreCollision(Collider collider1, Collider collider2);
        [NativeName("IgnoreCollision")]
        public static void IgnoreLayerCollision(int layer1, int layer2, [UnityEngine.Internal.DefaultValue("true")] bool ignore);
        [ExcludeFromDocs]
        public static void IgnoreLayerCollision(int layer1, int layer2);
        public static bool GetIgnoreLayerCollision(int layer1, int layer2);
        public static bool GetIgnoreCollision([NotNull("NullExceptionObject")] Collider collider1, [NotNull("NullExceptionObject")] Collider collider2);
        public static bool Raycast(Vector3 origin, Vector3 direction, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDistance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [ExcludeFromDocs]
        public static bool Raycast(Vector3 origin, Vector3 direction, float maxDistance, int layerMask);
        [ExcludeFromDocs]
        public static bool Raycast(Vector3 origin, Vector3 direction, float maxDistance);
        [ExcludeFromDocs]
        public static bool Raycast(Vector3 origin, Vector3 direction);
        public static bool Raycast(Vector3 origin, Vector3 direction, out RaycastHit hitInfo, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction);
        [RequiredByNativeCode]
        [ExcludeFromDocs]
        public static bool Raycast(Vector3 origin, Vector3 direction, out RaycastHit hitInfo, float maxDistance, int layerMask);
        [ExcludeFromDocs]
        public static bool Raycast(Vector3 origin, Vector3 direction, out RaycastHit hitInfo, float maxDistance);
        [ExcludeFromDocs]
        public static bool Raycast(Vector3 origin, Vector3 direction, out RaycastHit hitInfo);
        public static bool Raycast(Ray ray, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDistance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [ExcludeFromDocs]
        public static bool Raycast(Ray ray, float maxDistance, int layerMask);
        [ExcludeFromDocs]
        public static bool Raycast(Ray ray, float maxDistance);
        [ExcludeFromDocs]
        public static bool Raycast(Ray ray);
        public static bool Raycast(Ray ray, out RaycastHit hitInfo, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDistance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [ExcludeFromDocs]
        public static bool Raycast(Ray ray, out RaycastHit hitInfo, float maxDistance, int layerMask);
        [ExcludeFromDocs]
        public static bool Raycast(Ray ray, out RaycastHit hitInfo, float maxDistance);
        [ExcludeFromDocs]
        public static bool Raycast(Ray ray, out RaycastHit hitInfo);
        public static bool Linecast(Vector3 start, Vector3 end, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [ExcludeFromDocs]
        public static bool Linecast(Vector3 start, Vector3 end, int layerMask);
        [ExcludeFromDocs]
        public static bool Linecast(Vector3 start, Vector3 end);
        public static bool Linecast(Vector3 start, Vector3 end, out RaycastHit hitInfo, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [ExcludeFromDocs]
        public static bool Linecast(Vector3 start, Vector3 end, out RaycastHit hitInfo, int layerMask);
        [ExcludeFromDocs]
        public static bool Linecast(Vector3 start, Vector3 end, out RaycastHit hitInfo);
        public static bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDistance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [ExcludeFromDocs]
        public static bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, float maxDistance, int layerMask);
        [ExcludeFromDocs]
        public static bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, float maxDistance);
        [ExcludeFromDocs]
        public static bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction);
        public static bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, out RaycastHit hitInfo, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDistance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [ExcludeFromDocs]
        public static bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, out RaycastHit hitInfo, float maxDistance, int layerMask);
        [ExcludeFromDocs]
        public static bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, out RaycastHit hitInfo, float maxDistance);
        [ExcludeFromDocs]
        public static bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, out RaycastHit hitInfo);
        public static bool SphereCast(Vector3 origin, float radius, Vector3 direction, out RaycastHit hitInfo, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDistance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [ExcludeFromDocs]
        public static bool SphereCast(Vector3 origin, float radius, Vector3 direction, out RaycastHit hitInfo, float maxDistance, int layerMask);
        [ExcludeFromDocs]
        public static bool SphereCast(Vector3 origin, float radius, Vector3 direction, out RaycastHit hitInfo, float maxDistance);
        [ExcludeFromDocs]
        public static bool SphereCast(Vector3 origin, float radius, Vector3 direction, out RaycastHit hitInfo);
        public static bool SphereCast(Ray ray, float radius, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDistance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [ExcludeFromDocs]
        public static bool SphereCast(Ray ray, float radius, float maxDistance, int layerMask);
        [ExcludeFromDocs]
        public static bool SphereCast(Ray ray, float radius, float maxDistance);
        [ExcludeFromDocs]
        public static bool SphereCast(Ray ray, float radius);
        public static bool SphereCast(Ray ray, float radius, out RaycastHit hitInfo, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDistance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [ExcludeFromDocs]
        public static bool SphereCast(Ray ray, float radius, out RaycastHit hitInfo, float maxDistance, int layerMask);
        [ExcludeFromDocs]
        public static bool SphereCast(Ray ray, float radius, out RaycastHit hitInfo, float maxDistance);
        [ExcludeFromDocs]
        public static bool SphereCast(Ray ray, float radius, out RaycastHit hitInfo);
        public static bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, [UnityEngine.Internal.DefaultValue("Quaternion.identity")] Quaternion orientation, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDistance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [ExcludeFromDocs]
        public static bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation, float maxDistance, int layerMask);
        [ExcludeFromDocs]
        public static bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation, float maxDistance);
        [ExcludeFromDocs]
        public static bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation);
        [ExcludeFromDocs]
        public static bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction);
        public static bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, out RaycastHit hitInfo, [UnityEngine.Internal.DefaultValue("Quaternion.identity")] Quaternion orientation, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDistance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [ExcludeFromDocs]
        public static bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, out RaycastHit hitInfo, Quaternion orientation, float maxDistance, int layerMask);
        [ExcludeFromDocs]
        public static bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, out RaycastHit hitInfo, Quaternion orientation, float maxDistance);
        [ExcludeFromDocs]
        public static bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, out RaycastHit hitInfo, Quaternion orientation);
        [ExcludeFromDocs]
        public static bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, out RaycastHit hitInfo);
        public static RaycastHit[] RaycastAll(Vector3 origin, Vector3 direction, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDistance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [ExcludeFromDocs]
        public static RaycastHit[] RaycastAll(Vector3 origin, Vector3 direction, float maxDistance, int layerMask);
        [ExcludeFromDocs]
        public static RaycastHit[] RaycastAll(Vector3 origin, Vector3 direction, float maxDistance);
        [ExcludeFromDocs]
        public static RaycastHit[] RaycastAll(Vector3 origin, Vector3 direction);
        public static RaycastHit[] RaycastAll(Ray ray, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDistance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [RequiredByNativeCode]
        [ExcludeFromDocs]
        public static RaycastHit[] RaycastAll(Ray ray, float maxDistance, int layerMask);
        [ExcludeFromDocs]
        public static RaycastHit[] RaycastAll(Ray ray, float maxDistance);
        [ExcludeFromDocs]
        public static RaycastHit[] RaycastAll(Ray ray);
        public static int RaycastNonAlloc(Ray ray, RaycastHit[] results, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDistance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [ExcludeFromDocs]
        [RequiredByNativeCode]
        public static int RaycastNonAlloc(Ray ray, RaycastHit[] results, float maxDistance, int layerMask);
        [ExcludeFromDocs]
        public static int RaycastNonAlloc(Ray ray, RaycastHit[] results, float maxDistance);
        [ExcludeFromDocs]
        public static int RaycastNonAlloc(Ray ray, RaycastHit[] results);
        public static int RaycastNonAlloc(Vector3 origin, Vector3 direction, RaycastHit[] results, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDistance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [ExcludeFromDocs]
        public static int RaycastNonAlloc(Vector3 origin, Vector3 direction, RaycastHit[] results, float maxDistance, int layerMask);
        [ExcludeFromDocs]
        public static int RaycastNonAlloc(Vector3 origin, Vector3 direction, RaycastHit[] results, float maxDistance);
        [ExcludeFromDocs]
        public static int RaycastNonAlloc(Vector3 origin, Vector3 direction, RaycastHit[] results);
        public static RaycastHit[] CapsuleCastAll(Vector3 point1, Vector3 point2, float radius, Vector3 direction, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDistance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [ExcludeFromDocs]
        public static RaycastHit[] CapsuleCastAll(Vector3 point1, Vector3 point2, float radius, Vector3 direction, float maxDistance, int layerMask);
        [ExcludeFromDocs]
        public static RaycastHit[] CapsuleCastAll(Vector3 point1, Vector3 point2, float radius, Vector3 direction, float maxDistance);
        [ExcludeFromDocs]
        public static RaycastHit[] CapsuleCastAll(Vector3 point1, Vector3 point2, float radius, Vector3 direction);
        public static RaycastHit[] SphereCastAll(Vector3 origin, float radius, Vector3 direction, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDistance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [ExcludeFromDocs]
        public static RaycastHit[] SphereCastAll(Vector3 origin, float radius, Vector3 direction, float maxDistance, int layerMask);
        [ExcludeFromDocs]
        public static RaycastHit[] SphereCastAll(Vector3 origin, float radius, Vector3 direction, float maxDistance);
        [ExcludeFromDocs]
        public static RaycastHit[] SphereCastAll(Vector3 origin, float radius, Vector3 direction);
        public static RaycastHit[] SphereCastAll(Ray ray, float radius, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDistance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [ExcludeFromDocs]
        public static RaycastHit[] SphereCastAll(Ray ray, float radius, float maxDistance, int layerMask);
        [ExcludeFromDocs]
        public static RaycastHit[] SphereCastAll(Ray ray, float radius, float maxDistance);
        [ExcludeFromDocs]
        public static RaycastHit[] SphereCastAll(Ray ray, float radius);
        public static Collider[] OverlapCapsule(Vector3 point0, Vector3 point1, float radius, [UnityEngine.Internal.DefaultValue("AllLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [ExcludeFromDocs]
        public static Collider[] OverlapCapsule(Vector3 point0, Vector3 point1, float radius, int layerMask);
        [ExcludeFromDocs]
        public static Collider[] OverlapCapsule(Vector3 point0, Vector3 point1, float radius);
        public static Collider[] OverlapSphere(Vector3 position, float radius, [UnityEngine.Internal.DefaultValue("AllLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [ExcludeFromDocs]
        public static Collider[] OverlapSphere(Vector3 position, float radius, int layerMask);
        [ExcludeFromDocs]
        public static Collider[] OverlapSphere(Vector3 position, float radius);
        public static void Simulate(float step);
        public static void SyncTransforms();
        public static bool ComputePenetration(Collider colliderA, Vector3 positionA, Quaternion rotationA, Collider colliderB, Vector3 positionB, Quaternion rotationB, out Vector3 direction, out float distance);
        public static Vector3 ClosestPoint(Vector3 point, Collider collider, Vector3 position, Quaternion rotation);
        public static int OverlapSphereNonAlloc(Vector3 position, float radius, Collider[] results, [UnityEngine.Internal.DefaultValue("AllLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [ExcludeFromDocs]
        public static int OverlapSphereNonAlloc(Vector3 position, float radius, Collider[] results, int layerMask);
        [ExcludeFromDocs]
        public static int OverlapSphereNonAlloc(Vector3 position, float radius, Collider[] results);
        public static bool CheckSphere(Vector3 position, float radius, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [ExcludeFromDocs]
        public static bool CheckSphere(Vector3 position, float radius, int layerMask);
        [ExcludeFromDocs]
        public static bool CheckSphere(Vector3 position, float radius);
        public static int CapsuleCastNonAlloc(Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit[] results, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDistance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [ExcludeFromDocs]
        public static int CapsuleCastNonAlloc(Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit[] results, float maxDistance, int layerMask);
        [ExcludeFromDocs]
        public static int CapsuleCastNonAlloc(Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit[] results, float maxDistance);
        [ExcludeFromDocs]
        public static int CapsuleCastNonAlloc(Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit[] results);
        public static int SphereCastNonAlloc(Vector3 origin, float radius, Vector3 direction, RaycastHit[] results, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDistance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [ExcludeFromDocs]
        public static int SphereCastNonAlloc(Vector3 origin, float radius, Vector3 direction, RaycastHit[] results, float maxDistance, int layerMask);
        [ExcludeFromDocs]
        public static int SphereCastNonAlloc(Vector3 origin, float radius, Vector3 direction, RaycastHit[] results, float maxDistance);
        [ExcludeFromDocs]
        public static int SphereCastNonAlloc(Vector3 origin, float radius, Vector3 direction, RaycastHit[] results);
        public static int SphereCastNonAlloc(Ray ray, float radius, RaycastHit[] results, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDistance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [ExcludeFromDocs]
        public static int SphereCastNonAlloc(Ray ray, float radius, RaycastHit[] results, float maxDistance, int layerMask);
        [ExcludeFromDocs]
        public static int SphereCastNonAlloc(Ray ray, float radius, RaycastHit[] results, float maxDistance);
        [ExcludeFromDocs]
        public static int SphereCastNonAlloc(Ray ray, float radius, RaycastHit[] results);
        public static bool CheckCapsule(Vector3 start, Vector3 end, float radius, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [ExcludeFromDocs]
        public static bool CheckCapsule(Vector3 start, Vector3 end, float radius, int layerMask);
        [ExcludeFromDocs]
        public static bool CheckCapsule(Vector3 start, Vector3 end, float radius);
        public static bool CheckBox(Vector3 center, Vector3 halfExtents, [UnityEngine.Internal.DefaultValue("Quaternion.identity")] Quaternion orientation, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layermask, [UnityEngine.Internal.DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [ExcludeFromDocs]
        public static bool CheckBox(Vector3 center, Vector3 halfExtents, Quaternion orientation, int layerMask);
        [ExcludeFromDocs]
        public static bool CheckBox(Vector3 center, Vector3 halfExtents, Quaternion orientation);
        [ExcludeFromDocs]
        public static bool CheckBox(Vector3 center, Vector3 halfExtents);
        public static Collider[] OverlapBox(Vector3 center, Vector3 halfExtents, [UnityEngine.Internal.DefaultValue("Quaternion.identity")] Quaternion orientation, [UnityEngine.Internal.DefaultValue("AllLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [ExcludeFromDocs]
        public static Collider[] OverlapBox(Vector3 center, Vector3 halfExtents, Quaternion orientation, int layerMask);
        [ExcludeFromDocs]
        public static Collider[] OverlapBox(Vector3 center, Vector3 halfExtents, Quaternion orientation);
        [ExcludeFromDocs]
        public static Collider[] OverlapBox(Vector3 center, Vector3 halfExtents);
        public static int OverlapBoxNonAlloc(Vector3 center, Vector3 halfExtents, Collider[] results, [UnityEngine.Internal.DefaultValue("Quaternion.identity")] Quaternion orientation, [UnityEngine.Internal.DefaultValue("AllLayers")] int mask, [UnityEngine.Internal.DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [ExcludeFromDocs]
        public static int OverlapBoxNonAlloc(Vector3 center, Vector3 halfExtents, Collider[] results, Quaternion orientation, int mask);
        [ExcludeFromDocs]
        public static int OverlapBoxNonAlloc(Vector3 center, Vector3 halfExtents, Collider[] results, Quaternion orientation);
        [ExcludeFromDocs]
        public static int OverlapBoxNonAlloc(Vector3 center, Vector3 halfExtents, Collider[] results);
        public static int BoxCastNonAlloc(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit[] results, [UnityEngine.Internal.DefaultValue("Quaternion.identity")] Quaternion orientation, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDistance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [ExcludeFromDocs]
        public static int BoxCastNonAlloc(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit[] results, Quaternion orientation);
        [ExcludeFromDocs]
        public static int BoxCastNonAlloc(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit[] results, Quaternion orientation, float maxDistance);
        [ExcludeFromDocs]
        public static int BoxCastNonAlloc(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit[] results, Quaternion orientation, float maxDistance, int layerMask);
        [ExcludeFromDocs]
        public static int BoxCastNonAlloc(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit[] results);
        public static RaycastHit[] BoxCastAll(Vector3 center, Vector3 halfExtents, Vector3 direction, [UnityEngine.Internal.DefaultValue("Quaternion.identity")] Quaternion orientation, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDistance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [ExcludeFromDocs]
        public static RaycastHit[] BoxCastAll(Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation, float maxDistance, int layerMask);
        [ExcludeFromDocs]
        public static RaycastHit[] BoxCastAll(Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation, float maxDistance);
        [ExcludeFromDocs]
        public static RaycastHit[] BoxCastAll(Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation);
        [ExcludeFromDocs]
        public static RaycastHit[] BoxCastAll(Vector3 center, Vector3 halfExtents, Vector3 direction);
        public static int OverlapCapsuleNonAlloc(Vector3 point0, Vector3 point1, float radius, Collider[] results, [UnityEngine.Internal.DefaultValue("AllLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("QueryTriggerInteraction.UseGlobal")] QueryTriggerInteraction queryTriggerInteraction);
        [ExcludeFromDocs]
        public static int OverlapCapsuleNonAlloc(Vector3 point0, Vector3 point1, float radius, Collider[] results, int layerMask);
        [ExcludeFromDocs]
        public static int OverlapCapsuleNonAlloc(Vector3 point0, Vector3 point1, float radius, Collider[] results);
        public static void RebuildBroadphaseRegions(Bounds worldBounds, int subdivisions);
        [StaticAccessor("GetPhysicsManager()")]
        [ThreadSafe]
        public static void BakeMesh(int meshID, bool convex);
    }
}
using Unity.Collections;
using Unity.Jobs;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Jobs/ScriptBindings/JobsBindingsTypes.h")]
    [NativeHeader("Modules/Physics/BatchCommands/RaycastCommand.h")]
    public struct RaycastCommand
    {
        public RaycastCommand(Vector3 from, Vector3 direction, float distance = 3.402823E+38, int layerMask = -5, int maxHits = 1);

        public Vector3 from { get; set; }
        public Vector3 direction { get; set; }
        public float distance { get; set; }
        public int layerMask { get; set; }
        public int maxHits { get; set; }

        public static JobHandle ScheduleBatch(NativeArray<RaycastCommand> commands, NativeArray<RaycastHit> results, int minCommandsPerJob, JobHandle dependsOn = null);
    }
}
using Unity.Collections;
using Unity.Jobs;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Jobs/ScriptBindings/JobsBindingsTypes.h")]
    [NativeHeader("Modules/Physics/BatchCommands/SpherecastCommand.h")]
    public struct SpherecastCommand
    {
        public SpherecastCommand(Vector3 origin, float radius, Vector3 direction, float distance = 3.402823E+38, int layerMask = -5);

        public Vector3 origin { get; set; }
        public float radius { get; set; }
        public Vector3 direction { get; set; }
        public float distance { get; set; }
        public int layerMask { get; set; }

        public static JobHandle ScheduleBatch(NativeArray<SpherecastCommand> commands, NativeArray<RaycastHit> results, int minCommandsPerJob, JobHandle dependsOn = null);
    }
}
using Unity.Collections;
using Unity.Jobs;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Jobs/ScriptBindings/JobsBindingsTypes.h")]
    [NativeHeader("Modules/Physics/BatchCommands/CapsulecastCommand.h")]
    public struct CapsulecastCommand
    {
        public CapsulecastCommand(Vector3 p1, Vector3 p2, float radius, Vector3 direction, float distance = 3.402823E+38, int layerMask = -5);

        public Vector3 point1 { get; set; }
        public Vector3 point2 { get; set; }
        public float radius { get; set; }
        public Vector3 direction { get; set; }
        public float distance { get; set; }
        public int layerMask { get; set; }

        public static JobHandle ScheduleBatch(NativeArray<CapsulecastCommand> commands, NativeArray<RaycastHit> results, int minCommandsPerJob, JobHandle dependsOn = null);
    }
}
using Unity.Collections;
using Unity.Jobs;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Runtime/Jobs/ScriptBindings/JobsBindingsTypes.h")]
    [NativeHeader("Modules/Physics/BatchCommands/BoxcastCommand.h")]
    public struct BoxcastCommand
    {
        public BoxcastCommand(Vector3 center, Vector3 halfExtents, Quaternion orientation, Vector3 direction, float distance = 3.402823E+38, int layerMask = -5);

        public Vector3 center { get; set; }
        public Vector3 halfExtents { get; set; }
        public Quaternion orientation { get; set; }
        public Vector3 direction { get; set; }
        public float distance { get; set; }
        public int layerMask { get; set; }

        public static JobHandle ScheduleBatch(NativeArray<BoxcastCommand> commands, NativeArray<RaycastHit> results, int minCommandsPerJob, JobHandle dependsOn = null);
    }
}
-------- {UnityEngine.Physics2DModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.Physics2DModule.dll)}:   54 --------
using System;
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Internal;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics2D/Public/PhysicsSceneHandle2D.h")]
    public struct PhysicsScene2D : IEquatable<PhysicsScene2D>
    {
        public override string ToString();
        public override int GetHashCode();
        public override bool Equals(object other);
        public bool Equals(PhysicsScene2D other);
        public bool IsValid();
        public bool IsEmpty();
        public bool Simulate(float step);
        public RaycastHit2D Linecast(Vector2 start, Vector2 end, [DefaultValue("Physics2D.DefaultRaycastLayers")] int layerMask = -5);
        public RaycastHit2D Linecast(Vector2 start, Vector2 end, ContactFilter2D contactFilter);
        public int Linecast(Vector2 start, Vector2 end, RaycastHit2D[] results, [DefaultValue("Physics2D.DefaultRaycastLayers")] int layerMask = -5);
        public int Linecast(Vector2 start, Vector2 end, ContactFilter2D contactFilter, RaycastHit2D[] results);
        public int Linecast(Vector2 start, Vector2 end, ContactFilter2D contactFilter, List<RaycastHit2D> results);
        public RaycastHit2D Raycast(Vector2 origin, Vector2 direction, float distance, [DefaultValue("Physics2D.DefaultRaycastLayers")] int layerMask = -5);
        public RaycastHit2D Raycast(Vector2 origin, Vector2 direction, float distance, ContactFilter2D contactFilter);
        public int Raycast(Vector2 origin, Vector2 direction, float distance, RaycastHit2D[] results, [DefaultValue("Physics2D.DefaultRaycastLayers")] int layerMask = -5);
        public int Raycast(Vector2 origin, Vector2 direction, float distance, ContactFilter2D contactFilter, RaycastHit2D[] results);
        public int Raycast(Vector2 origin, Vector2 direction, float distance, ContactFilter2D contactFilter, List<RaycastHit2D> results);
        public RaycastHit2D CircleCast(Vector2 origin, float radius, Vector2 direction, float distance, [DefaultValue("Physics2D.DefaultRaycastLayers")] int layerMask = -5);
        public RaycastHit2D CircleCast(Vector2 origin, float radius, Vector2 direction, float distance, ContactFilter2D contactFilter);
        public int CircleCast(Vector2 origin, float radius, Vector2 direction, float distance, RaycastHit2D[] results, [DefaultValue("Physics2D.DefaultRaycastLayers")] int layerMask = -5);
        public int CircleCast(Vector2 origin, float radius, Vector2 direction, float distance, ContactFilter2D contactFilter, RaycastHit2D[] results);
        public int CircleCast(Vector2 origin, float radius, Vector2 direction, float distance, ContactFilter2D contactFilter, List<RaycastHit2D> results);
        public RaycastHit2D BoxCast(Vector2 origin, Vector2 size, float angle, Vector2 direction, float distance, [DefaultValue("Physics2D.DefaultRaycastLayers")] int layerMask = -5);
        public RaycastHit2D BoxCast(Vector2 origin, Vector2 size, float angle, Vector2 direction, float distance, ContactFilter2D contactFilter);
        public int BoxCast(Vector2 origin, Vector2 size, float angle, Vector2 direction, float distance, RaycastHit2D[] results, [DefaultValue("Physics2D.DefaultRaycastLayers")] int layerMask = -5);
        public int BoxCast(Vector2 origin, Vector2 size, float angle, Vector2 direction, float distance, ContactFilter2D contactFilter, RaycastHit2D[] results);
        public int BoxCast(Vector2 origin, Vector2 size, float angle, Vector2 direction, float distance, ContactFilter2D contactFilter, List<RaycastHit2D> results);
        public RaycastHit2D CapsuleCast(Vector2 origin, Vector2 size, CapsuleDirection2D capsuleDirection, float angle, Vector2 direction, float distance, [DefaultValue("Physics2D.DefaultRaycastLayers")] int layerMask = -5);
        public RaycastHit2D CapsuleCast(Vector2 origin, Vector2 size, CapsuleDirection2D capsuleDirection, float angle, Vector2 direction, float distance, ContactFilter2D contactFilter);
        public int CapsuleCast(Vector2 origin, Vector2 size, CapsuleDirection2D capsuleDirection, float angle, Vector2 direction, float distance, RaycastHit2D[] results, [DefaultValue("Physics2D.DefaultRaycastLayers")] int layerMask = -5);
        public int CapsuleCast(Vector2 origin, Vector2 size, CapsuleDirection2D capsuleDirection, float angle, Vector2 direction, float distance, ContactFilter2D contactFilter, RaycastHit2D[] results);
        public int CapsuleCast(Vector2 origin, Vector2 size, CapsuleDirection2D capsuleDirection, float angle, Vector2 direction, float distance, ContactFilter2D contactFilter, List<RaycastHit2D> results);
        public RaycastHit2D GetRayIntersection(Ray ray, float distance, [DefaultValue("Physics2D.DefaultRaycastLayers")] int layerMask = -5);
        public int GetRayIntersection(Ray ray, float distance, RaycastHit2D[] results, [DefaultValue("Physics2D.DefaultRaycastLayers")] int layerMask = -5);
        public Collider2D OverlapPoint(Vector2 point, [DefaultValue("Physics2D.DefaultRaycastLayers")] int layerMask = -5);
        public Collider2D OverlapPoint(Vector2 point, ContactFilter2D contactFilter);
        public int OverlapPoint(Vector2 point, Collider2D[] results, [DefaultValue("Physics2D.DefaultRaycastLayers")] int layerMask = -5);
        public int OverlapPoint(Vector2 point, ContactFilter2D contactFilter, Collider2D[] results);
        public int OverlapPoint(Vector2 point, ContactFilter2D contactFilter, List<Collider2D> results);
        public Collider2D OverlapCircle(Vector2 point, float radius, [DefaultValue("Physics2D.DefaultRaycastLayers")] int layerMask = -5);
        public Collider2D OverlapCircle(Vector2 point, float radius, ContactFilter2D contactFilter);
        public int OverlapCircle(Vector2 point, float radius, Collider2D[] results, [DefaultValue("Physics2D.DefaultRaycastLayers")] int layerMask = -5);
        public int OverlapCircle(Vector2 point, float radius, ContactFilter2D contactFilter, Collider2D[] results);
        public int OverlapCircle(Vector2 point, float radius, ContactFilter2D contactFilter, List<Collider2D> results);
        public Collider2D OverlapBox(Vector2 point, Vector2 size, float angle, [DefaultValue("Physics2D.DefaultRaycastLayers")] int layerMask = -5);
        public Collider2D OverlapBox(Vector2 point, Vector2 size, float angle, ContactFilter2D contactFilter);
        public int OverlapBox(Vector2 point, Vector2 size, float angle, Collider2D[] results, [DefaultValue("Physics2D.DefaultRaycastLayers")] int layerMask = -5);
        public int OverlapBox(Vector2 point, Vector2 size, float angle, ContactFilter2D contactFilter, Collider2D[] results);
        public int OverlapBox(Vector2 point, Vector2 size, float angle, ContactFilter2D contactFilter, List<Collider2D> results);
        public Collider2D OverlapArea(Vector2 pointA, Vector2 pointB, [DefaultValue("Physics2D.DefaultRaycastLayers")] int layerMask = -5);
        public Collider2D OverlapArea(Vector2 pointA, Vector2 pointB, ContactFilter2D contactFilter);
        public int OverlapArea(Vector2 pointA, Vector2 pointB, Collider2D[] results, [DefaultValue("Physics2D.DefaultRaycastLayers")] int layerMask = -5);
        public int OverlapArea(Vector2 pointA, Vector2 pointB, ContactFilter2D contactFilter, Collider2D[] results);
        public int OverlapArea(Vector2 pointA, Vector2 pointB, ContactFilter2D contactFilter, List<Collider2D> results);
        public Collider2D OverlapCapsule(Vector2 point, Vector2 size, CapsuleDirection2D direction, float angle, [DefaultValue("Physics2D.DefaultRaycastLayers")] int layerMask = -5);
        public Collider2D OverlapCapsule(Vector2 point, Vector2 size, CapsuleDirection2D direction, float angle, ContactFilter2D contactFilter);
        public int OverlapCapsule(Vector2 point, Vector2 size, CapsuleDirection2D direction, float angle, Collider2D[] results, [DefaultValue("Physics2D.DefaultRaycastLayers")] int layerMask = -5);
        public int OverlapCapsule(Vector2 point, Vector2 size, CapsuleDirection2D direction, float angle, ContactFilter2D contactFilter, Collider2D[] results);
        public int OverlapCapsule(Vector2 point, Vector2 size, CapsuleDirection2D direction, float angle, ContactFilter2D contactFilter, List<Collider2D> results);
        public static int OverlapCollider(Collider2D collider, Collider2D[] results, [DefaultValue("Physics2D.DefaultRaycastLayers")] int layerMask = -5);
        public static int OverlapCollider(Collider2D collider, ContactFilter2D contactFilter, Collider2D[] results);
        public static int OverlapCollider(Collider2D collider, ContactFilter2D contactFilter, List<Collider2D> results);

        public static bool operator ==(PhysicsScene2D lhs, PhysicsScene2D rhs);
        public static bool operator !=(PhysicsScene2D lhs, PhysicsScene2D rhs);
    }
}
using UnityEngine.SceneManagement;

namespace UnityEngine
{
    public static class PhysicsSceneExtensions2D
    {
        public static PhysicsScene2D GetPhysicsScene2D(this Scene scene);
    }
}
using System;
using System.Collections.Generic;
using System.ComponentModel;
using UnityEngine.Bindings;
using UnityEngine.Internal;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Physics2DScriptingClasses.h")]
    [NativeHeader("Modules/Physics2D/PhysicsManager2D.h")]
    [StaticAccessor("GetPhysicsManager2D()", Arrow)]
    [NativeHeader("Physics2DScriptingClasses.h")]
    public class Physics2D
    {
        public const int IgnoreRaycastLayer = 4;
        public const int DefaultRaycastLayers = -5;
        public const int AllLayers = -1;

        public Physics2D();

        public static PhysicsScene2D defaultPhysicsScene { get; }
        [StaticAccessor("GetPhysics2DSettings()")]
        public static int velocityIterations { get; set; }
        [StaticAccessor("GetPhysics2DSettings()")]
        public static int positionIterations { get; set; }
        [StaticAccessor("GetPhysics2DSettings()")]
        public static Vector2 gravity { get; set; }
        [StaticAccessor("GetPhysics2DSettings()")]
        public static bool queriesHitTriggers { get; set; }
        [StaticAccessor("GetPhysics2DSettings()")]
        public static bool queriesStartInColliders { get; set; }
        [StaticAccessor("GetPhysics2DSettings()")]
        public static bool callbacksOnDisable { get; set; }
        [StaticAccessor("GetPhysics2DSettings()")]
        public static bool reuseCollisionCallbacks { get; set; }
        [StaticAccessor("GetPhysics2DSettings()")]
        public static bool autoSyncTransforms { get; set; }
        [StaticAccessor("GetPhysics2DSettings()")]
        public static SimulationMode2D simulationMode { get; set; }
        [StaticAccessor("GetPhysics2DSettings()")]
        public static PhysicsJobOptions2D jobOptions { get; set; }
        [StaticAccessor("GetPhysics2DSettings()")]
        public static float velocityThreshold { get; set; }
        [StaticAccessor("GetPhysics2DSettings()")]
        public static float maxLinearCorrection { get; set; }
        [StaticAccessor("GetPhysics2DSettings()")]
        public static float maxAngularCorrection { get; set; }
        [StaticAccessor("GetPhysics2DSettings()")]
        public static float maxTranslationSpeed { get; set; }
        [StaticAccessor("GetPhysics2DSettings()")]
        public static float maxRotationSpeed { get; set; }
        [StaticAccessor("GetPhysics2DSettings()")]
        public static float defaultContactOffset { get; set; }
        [StaticAccessor("GetPhysics2DSettings()")]
        public static float baumgarteScale { get; set; }
        [StaticAccessor("GetPhysics2DSettings()")]
        public static float baumgarteTOIScale { get; set; }
        [StaticAccessor("GetPhysics2DSettings()")]
        public static float timeToSleep { get; set; }
        [StaticAccessor("GetPhysics2DSettings()")]
        public static float linearSleepTolerance { get; set; }
        [StaticAccessor("GetPhysics2DSettings()")]
        public static float angularSleepTolerance { get; set; }
        [StaticAccessor("GetPhysics2DSettings()")]
        public static bool alwaysShowColliders { get; set; }
        [StaticAccessor("GetPhysics2DSettings()")]
        public static bool showColliderSleep { get; set; }
        [StaticAccessor("GetPhysics2DSettings()")]
        public static bool showColliderContacts { get; set; }
        [StaticAccessor("GetPhysics2DSettings()")]
        public static bool showColliderAABB { get; set; }
        [StaticAccessor("GetPhysics2DSettings()")]
        public static float contactArrowScale { get; set; }
        [StaticAccessor("GetPhysics2DSettings()")]
        public static Color colliderAwakeColor { get; set; }
        [StaticAccessor("GetPhysics2DSettings()")]
        public static Color colliderAsleepColor { get; set; }
        [StaticAccessor("GetPhysics2DSettings()")]
        public static Color colliderContactColor { get; set; }
        [StaticAccessor("GetPhysics2DSettings()")]
        public static Color colliderAABBColor { get; set; }
        [Obsolete("Physics2D.raycastsHitTriggers is deprecated. Use Physics2D.queriesHitTriggers instead. (UnityUpgradable) -> queriesHitTriggers", True)]
        [EditorBrowsable(Never)]
        public static bool raycastsHitTriggers { get; set; }
        [Obsolete("Physics2D.raycastsStartInColliders is deprecated. Use Physics2D.queriesStartInColliders instead. (UnityUpgradable) -> queriesStartInColliders", True)]
        [EditorBrowsable(Never)]
        public static bool raycastsStartInColliders { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("Physics2D.deleteStopsCallbacks is deprecated.(UnityUpgradable) -> changeStopsCallbacks", True)]
        public static bool deleteStopsCallbacks { get; set; }
        [Obsolete("Physics2D.changeStopsCallbacks is deprecated and will always return false.", False)]
        public static bool changeStopsCallbacks { get; set; }
        [Obsolete("Physics2D.minPenetrationForPenalty is deprecated. Use Physics2D.defaultContactOffset instead. (UnityUpgradable) -> defaultContactOffset", False)]
        public static float minPenetrationForPenalty { get; set; }
        [Obsolete("Physics2D.autoSimulation is deprecated. Use Physics2D.simulationMode instead.", False)]
        [EditorBrowsable(Never)]
        public static bool autoSimulation { get; set; }

        public static bool Simulate(float step);
        public static void SyncTransforms();
        [ExcludeFromDocs]
        public static void IgnoreCollision([Writable] Collider2D collider1, [Writable] Collider2D collider2);
        [NativeMethod("IgnoreCollision_Binding")]
        [StaticAccessor("PhysicsScene2D", DoubleColon)]
        public static void IgnoreCollision([Writable][NotNull("ArgumentNullException")] Collider2D collider1, [NotNull("ArgumentNullException")][Writable] Collider2D collider2, [UnityEngine.Internal.DefaultValue("true")] bool ignore);
        [StaticAccessor("PhysicsScene2D", DoubleColon)]
        [NativeMethod("GetIgnoreCollision_Binding")]
        public static bool GetIgnoreCollision([Writable][NotNull("ArgumentNullException")] Collider2D collider1, [NotNull("ArgumentNullException")][Writable] Collider2D collider2);
        [ExcludeFromDocs]
        public static void IgnoreLayerCollision(int layer1, int layer2);
        public static void IgnoreLayerCollision(int layer1, int layer2, bool ignore);
        public static bool GetIgnoreLayerCollision(int layer1, int layer2);
        public static void SetLayerCollisionMask(int layer, int layerMask);
        public static int GetLayerCollisionMask(int layer);
        [StaticAccessor("PhysicsQuery2D", DoubleColon)]
        public static bool IsTouching([Writable][NotNull("ArgumentNullException")] Collider2D collider1, [NotNull("ArgumentNullException")][Writable] Collider2D collider2);
        public static bool IsTouching([Writable] Collider2D collider1, [Writable] Collider2D collider2, ContactFilter2D contactFilter);
        public static bool IsTouching([Writable] Collider2D collider, ContactFilter2D contactFilter);
        [ExcludeFromDocs]
        public static bool IsTouchingLayers([Writable] Collider2D collider);
        [StaticAccessor("PhysicsQuery2D", DoubleColon)]
        public static bool IsTouchingLayers([Writable][NotNull("ArgumentNullException")] Collider2D collider, [UnityEngine.Internal.DefaultValue("Physics2D.AllLayers")] int layerMask);
        public static ColliderDistance2D Distance([Writable] Collider2D colliderA, [Writable] Collider2D colliderB);
        public static Vector2 ClosestPoint(Vector2 position, Collider2D collider);
        public static Vector2 ClosestPoint(Vector2 position, Rigidbody2D rigidbody);
        [ExcludeFromDocs]
        public static RaycastHit2D Linecast(Vector2 start, Vector2 end);
        [ExcludeFromDocs]
        public static RaycastHit2D Linecast(Vector2 start, Vector2 end, int layerMask);
        [ExcludeFromDocs]
        public static RaycastHit2D Linecast(Vector2 start, Vector2 end, int layerMask, float minDepth);
        public static RaycastHit2D Linecast(Vector2 start, Vector2 end, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("-Mathf.Infinity")] float minDepth, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDepth);
        public static int Linecast(Vector2 start, Vector2 end, ContactFilter2D contactFilter, RaycastHit2D[] results);
        public static int Linecast(Vector2 start, Vector2 end, ContactFilter2D contactFilter, List<RaycastHit2D> results);
        [ExcludeFromDocs]
        public static RaycastHit2D[] LinecastAll(Vector2 start, Vector2 end);
        [ExcludeFromDocs]
        public static RaycastHit2D[] LinecastAll(Vector2 start, Vector2 end, int layerMask);
        [ExcludeFromDocs]
        public static RaycastHit2D[] LinecastAll(Vector2 start, Vector2 end, int layerMask, float minDepth);
        public static RaycastHit2D[] LinecastAll(Vector2 start, Vector2 end, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("-Mathf.Infinity")] float minDepth, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDepth);
        [ExcludeFromDocs]
        public static int LinecastNonAlloc(Vector2 start, Vector2 end, RaycastHit2D[] results);
        [ExcludeFromDocs]
        public static int LinecastNonAlloc(Vector2 start, Vector2 end, RaycastHit2D[] results, int layerMask);
        [ExcludeFromDocs]
        public static int LinecastNonAlloc(Vector2 start, Vector2 end, RaycastHit2D[] results, int layerMask, float minDepth);
        public static int LinecastNonAlloc(Vector2 start, Vector2 end, RaycastHit2D[] results, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("-Mathf.Infinity")] float minDepth, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDepth);
        [ExcludeFromDocs]
        public static RaycastHit2D Raycast(Vector2 origin, Vector2 direction);
        [ExcludeFromDocs]
        public static RaycastHit2D Raycast(Vector2 origin, Vector2 direction, float distance);
        [ExcludeFromDocs]
        [RequiredByNativeCode]
        public static RaycastHit2D Raycast(Vector2 origin, Vector2 direction, float distance, int layerMask);
        [ExcludeFromDocs]
        public static RaycastHit2D Raycast(Vector2 origin, Vector2 direction, float distance, int layerMask, float minDepth);
        public static RaycastHit2D Raycast(Vector2 origin, Vector2 direction, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float distance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("-Mathf.Infinity")] float minDepth, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDepth);
        [ExcludeFromDocs]
        public static int Raycast(Vector2 origin, Vector2 direction, ContactFilter2D contactFilter, RaycastHit2D[] results);
        public static int Raycast(Vector2 origin, Vector2 direction, ContactFilter2D contactFilter, RaycastHit2D[] results, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float distance);
        public static int Raycast(Vector2 origin, Vector2 direction, ContactFilter2D contactFilter, List<RaycastHit2D> results, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float distance = InfinityF);
        [ExcludeFromDocs]
        public static int RaycastNonAlloc(Vector2 origin, Vector2 direction, RaycastHit2D[] results);
        [ExcludeFromDocs]
        public static int RaycastNonAlloc(Vector2 origin, Vector2 direction, RaycastHit2D[] results, float distance);
        [ExcludeFromDocs]
        public static int RaycastNonAlloc(Vector2 origin, Vector2 direction, RaycastHit2D[] results, float distance, int layerMask);
        [ExcludeFromDocs]
        public static int RaycastNonAlloc(Vector2 origin, Vector2 direction, RaycastHit2D[] results, float distance, int layerMask, float minDepth);
        public static int RaycastNonAlloc(Vector2 origin, Vector2 direction, RaycastHit2D[] results, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float distance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("-Mathf.Infinity")] float minDepth, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDepth);
        [ExcludeFromDocs]
        public static RaycastHit2D[] RaycastAll(Vector2 origin, Vector2 direction);
        [ExcludeFromDocs]
        public static RaycastHit2D[] RaycastAll(Vector2 origin, Vector2 direction, float distance);
        [ExcludeFromDocs]
        public static RaycastHit2D[] RaycastAll(Vector2 origin, Vector2 direction, float distance, int layerMask);
        [ExcludeFromDocs]
        public static RaycastHit2D[] RaycastAll(Vector2 origin, Vector2 direction, float distance, int layerMask, float minDepth);
        public static RaycastHit2D[] RaycastAll(Vector2 origin, Vector2 direction, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float distance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("-Mathf.Infinity")] float minDepth, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDepth);
        [ExcludeFromDocs]
        public static RaycastHit2D CircleCast(Vector2 origin, float radius, Vector2 direction);
        [ExcludeFromDocs]
        public static RaycastHit2D CircleCast(Vector2 origin, float radius, Vector2 direction, float distance);
        [ExcludeFromDocs]
        public static RaycastHit2D CircleCast(Vector2 origin, float radius, Vector2 direction, float distance, int layerMask);
        [ExcludeFromDocs]
        public static RaycastHit2D CircleCast(Vector2 origin, float radius, Vector2 direction, float distance, int layerMask, float minDepth);
        public static RaycastHit2D CircleCast(Vector2 origin, float radius, Vector2 direction, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float distance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("-Mathf.Infinity")] float minDepth, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDepth);
        [ExcludeFromDocs]
        public static int CircleCast(Vector2 origin, float radius, Vector2 direction, ContactFilter2D contactFilter, RaycastHit2D[] results);
        public static int CircleCast(Vector2 origin, float radius, Vector2 direction, ContactFilter2D contactFilter, RaycastHit2D[] results, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float distance);
        public static int CircleCast(Vector2 origin, float radius, Vector2 direction, ContactFilter2D contactFilter, List<RaycastHit2D> results, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float distance = InfinityF);
        [ExcludeFromDocs]
        public static RaycastHit2D[] CircleCastAll(Vector2 origin, float radius, Vector2 direction);
        [ExcludeFromDocs]
        public static RaycastHit2D[] CircleCastAll(Vector2 origin, float radius, Vector2 direction, float distance);
        [ExcludeFromDocs]
        public static RaycastHit2D[] CircleCastAll(Vector2 origin, float radius, Vector2 direction, float distance, int layerMask);
        [ExcludeFromDocs]
        public static RaycastHit2D[] CircleCastAll(Vector2 origin, float radius, Vector2 direction, float distance, int layerMask, float minDepth);
        public static RaycastHit2D[] CircleCastAll(Vector2 origin, float radius, Vector2 direction, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float distance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("-Mathf.Infinity")] float minDepth, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDepth);
        [ExcludeFromDocs]
        public static int CircleCastNonAlloc(Vector2 origin, float radius, Vector2 direction, RaycastHit2D[] results);
        [ExcludeFromDocs]
        public static int CircleCastNonAlloc(Vector2 origin, float radius, Vector2 direction, RaycastHit2D[] results, float distance);
        [ExcludeFromDocs]
        public static int CircleCastNonAlloc(Vector2 origin, float radius, Vector2 direction, RaycastHit2D[] results, float distance, int layerMask);
        [ExcludeFromDocs]
        public static int CircleCastNonAlloc(Vector2 origin, float radius, Vector2 direction, RaycastHit2D[] results, float distance, int layerMask, float minDepth);
        public static int CircleCastNonAlloc(Vector2 origin, float radius, Vector2 direction, RaycastHit2D[] results, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float distance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("-Mathf.Infinity")] float minDepth, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDepth);
        [ExcludeFromDocs]
        public static RaycastHit2D BoxCast(Vector2 origin, Vector2 size, float angle, Vector2 direction);
        [ExcludeFromDocs]
        public static RaycastHit2D BoxCast(Vector2 origin, Vector2 size, float angle, Vector2 direction, float distance);
        [ExcludeFromDocs]
        public static RaycastHit2D BoxCast(Vector2 origin, Vector2 size, float angle, Vector2 direction, float distance, int layerMask);
        [ExcludeFromDocs]
        public static RaycastHit2D BoxCast(Vector2 origin, Vector2 size, float angle, Vector2 direction, float distance, int layerMask, float minDepth);
        public static RaycastHit2D BoxCast(Vector2 origin, Vector2 size, float angle, Vector2 direction, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float distance, [UnityEngine.Internal.DefaultValue("Physics2D.AllLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("-Mathf.Infinity")] float minDepth, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDepth);
        [ExcludeFromDocs]
        public static int BoxCast(Vector2 origin, Vector2 size, float angle, Vector2 direction, ContactFilter2D contactFilter, RaycastHit2D[] results);
        public static int BoxCast(Vector2 origin, Vector2 size, float angle, Vector2 direction, ContactFilter2D contactFilter, RaycastHit2D[] results, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float distance);
        public static int BoxCast(Vector2 origin, Vector2 size, float angle, Vector2 direction, ContactFilter2D contactFilter, List<RaycastHit2D> results, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float distance = InfinityF);
        [ExcludeFromDocs]
        public static RaycastHit2D[] BoxCastAll(Vector2 origin, Vector2 size, float angle, Vector2 direction);
        [ExcludeFromDocs]
        public static RaycastHit2D[] BoxCastAll(Vector2 origin, Vector2 size, float angle, Vector2 direction, float distance);
        [ExcludeFromDocs]
        public static RaycastHit2D[] BoxCastAll(Vector2 origin, Vector2 size, float angle, Vector2 direction, float distance, int layerMask);
        [ExcludeFromDocs]
        public static RaycastHit2D[] BoxCastAll(Vector2 origin, Vector2 size, float angle, Vector2 direction, float distance, int layerMask, float minDepth);
        public static RaycastHit2D[] BoxCastAll(Vector2 origin, Vector2 size, float angle, Vector2 direction, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float distance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("-Mathf.Infinity")] float minDepth, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDepth);
        [ExcludeFromDocs]
        public static int BoxCastNonAlloc(Vector2 origin, Vector2 size, float angle, Vector2 direction, RaycastHit2D[] results);
        [ExcludeFromDocs]
        public static int BoxCastNonAlloc(Vector2 origin, Vector2 size, float angle, Vector2 direction, RaycastHit2D[] results, float distance);
        [ExcludeFromDocs]
        public static int BoxCastNonAlloc(Vector2 origin, Vector2 size, float angle, Vector2 direction, RaycastHit2D[] results, float distance, int layerMask);
        [ExcludeFromDocs]
        public static int BoxCastNonAlloc(Vector2 origin, Vector2 size, float angle, Vector2 direction, RaycastHit2D[] results, float distance, int layerMask, float minDepth);
        public static int BoxCastNonAlloc(Vector2 origin, Vector2 size, float angle, Vector2 direction, RaycastHit2D[] results, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float distance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("-Mathf.Infinity")] float minDepth, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDepth);
        [ExcludeFromDocs]
        public static RaycastHit2D CapsuleCast(Vector2 origin, Vector2 size, CapsuleDirection2D capsuleDirection, float angle, Vector2 direction);
        [ExcludeFromDocs]
        public static RaycastHit2D CapsuleCast(Vector2 origin, Vector2 size, CapsuleDirection2D capsuleDirection, float angle, Vector2 direction, float distance);
        [ExcludeFromDocs]
        public static RaycastHit2D CapsuleCast(Vector2 origin, Vector2 size, CapsuleDirection2D capsuleDirection, float angle, Vector2 direction, float distance, int layerMask);
        [ExcludeFromDocs]
        public static RaycastHit2D CapsuleCast(Vector2 origin, Vector2 size, CapsuleDirection2D capsuleDirection, float angle, Vector2 direction, float distance, int layerMask, float minDepth);
        public static RaycastHit2D CapsuleCast(Vector2 origin, Vector2 size, CapsuleDirection2D capsuleDirection, float angle, Vector2 direction, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float distance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("-Mathf.Infinity")] float minDepth, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDepth);
        [ExcludeFromDocs]
        public static int CapsuleCast(Vector2 origin, Vector2 size, CapsuleDirection2D capsuleDirection, float angle, Vector2 direction, ContactFilter2D contactFilter, RaycastHit2D[] results);
        public static int CapsuleCast(Vector2 origin, Vector2 size, CapsuleDirection2D capsuleDirection, float angle, Vector2 direction, ContactFilter2D contactFilter, RaycastHit2D[] results, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float distance);
        public static int CapsuleCast(Vector2 origin, Vector2 size, CapsuleDirection2D capsuleDirection, float angle, Vector2 direction, ContactFilter2D contactFilter, List<RaycastHit2D> results, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float distance = InfinityF);
        [ExcludeFromDocs]
        public static RaycastHit2D[] CapsuleCastAll(Vector2 origin, Vector2 size, CapsuleDirection2D capsuleDirection, float angle, Vector2 direction);
        [ExcludeFromDocs]
        public static RaycastHit2D[] CapsuleCastAll(Vector2 origin, Vector2 size, CapsuleDirection2D capsuleDirection, float angle, Vector2 direction, float distance);
        [ExcludeFromDocs]
        public static RaycastHit2D[] CapsuleCastAll(Vector2 origin, Vector2 size, CapsuleDirection2D capsuleDirection, float angle, Vector2 direction, float distance, int layerMask);
        [ExcludeFromDocs]
        public static RaycastHit2D[] CapsuleCastAll(Vector2 origin, Vector2 size, CapsuleDirection2D capsuleDirection, float angle, Vector2 direction, float distance, int layerMask, float minDepth);
        public static RaycastHit2D[] CapsuleCastAll(Vector2 origin, Vector2 size, CapsuleDirection2D capsuleDirection, float angle, Vector2 direction, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float distance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("-Mathf.Infinity")] float minDepth, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDepth);
        [ExcludeFromDocs]
        public static int CapsuleCastNonAlloc(Vector2 origin, Vector2 size, CapsuleDirection2D capsuleDirection, float angle, Vector2 direction, RaycastHit2D[] results);
        [ExcludeFromDocs]
        public static int CapsuleCastNonAlloc(Vector2 origin, Vector2 size, CapsuleDirection2D capsuleDirection, float angle, Vector2 direction, RaycastHit2D[] results, float distance);
        [ExcludeFromDocs]
        public static int CapsuleCastNonAlloc(Vector2 origin, Vector2 size, CapsuleDirection2D capsuleDirection, float angle, Vector2 direction, RaycastHit2D[] results, float distance, int layerMask);
        [ExcludeFromDocs]
        public static int CapsuleCastNonAlloc(Vector2 origin, Vector2 size, CapsuleDirection2D capsuleDirection, float angle, Vector2 direction, RaycastHit2D[] results, float distance, int layerMask, float minDepth);
        public static int CapsuleCastNonAlloc(Vector2 origin, Vector2 size, CapsuleDirection2D capsuleDirection, float angle, Vector2 direction, RaycastHit2D[] results, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float distance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("-Mathf.Infinity")] float minDepth, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDepth);
        [ExcludeFromDocs]
        public static RaycastHit2D GetRayIntersection(Ray ray);
        [ExcludeFromDocs]
        public static RaycastHit2D GetRayIntersection(Ray ray, float distance);
        public static RaycastHit2D GetRayIntersection(Ray ray, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float distance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask);
        [ExcludeFromDocs]
        public static RaycastHit2D[] GetRayIntersectionAll(Ray ray);
        [ExcludeFromDocs]
        public static RaycastHit2D[] GetRayIntersectionAll(Ray ray, float distance);
        [RequiredByNativeCode]
        public static RaycastHit2D[] GetRayIntersectionAll(Ray ray, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float distance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask);
        [ExcludeFromDocs]
        public static int GetRayIntersectionNonAlloc(Ray ray, RaycastHit2D[] results);
        [ExcludeFromDocs]
        public static int GetRayIntersectionNonAlloc(Ray ray, RaycastHit2D[] results, float distance);
        [RequiredByNativeCode]
        public static int GetRayIntersectionNonAlloc(Ray ray, RaycastHit2D[] results, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float distance, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask);
        [ExcludeFromDocs]
        public static Collider2D OverlapPoint(Vector2 point);
        [ExcludeFromDocs]
        public static Collider2D OverlapPoint(Vector2 point, int layerMask);
        [ExcludeFromDocs]
        public static Collider2D OverlapPoint(Vector2 point, int layerMask, float minDepth);
        public static Collider2D OverlapPoint(Vector2 point, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("-Mathf.Infinity")] float minDepth, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDepth);
        public static int OverlapPoint(Vector2 point, ContactFilter2D contactFilter, Collider2D[] results);
        public static int OverlapPoint(Vector2 point, ContactFilter2D contactFilter, List<Collider2D> results);
        [ExcludeFromDocs]
        public static Collider2D[] OverlapPointAll(Vector2 point);
        [ExcludeFromDocs]
        public static Collider2D[] OverlapPointAll(Vector2 point, int layerMask);
        [ExcludeFromDocs]
        public static Collider2D[] OverlapPointAll(Vector2 point, int layerMask, float minDepth);
        public static Collider2D[] OverlapPointAll(Vector2 point, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("-Mathf.Infinity")] float minDepth, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDepth);
        [ExcludeFromDocs]
        public static int OverlapPointNonAlloc(Vector2 point, Collider2D[] results);
        [ExcludeFromDocs]
        public static int OverlapPointNonAlloc(Vector2 point, Collider2D[] results, int layerMask);
        [ExcludeFromDocs]
        public static int OverlapPointNonAlloc(Vector2 point, Collider2D[] results, int layerMask, float minDepth);
        public static int OverlapPointNonAlloc(Vector2 point, Collider2D[] results, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("-Mathf.Infinity")] float minDepth, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDepth);
        [ExcludeFromDocs]
        public static Collider2D OverlapCircle(Vector2 point, float radius);
        [ExcludeFromDocs]
        public static Collider2D OverlapCircle(Vector2 point, float radius, int layerMask);
        [ExcludeFromDocs]
        public static Collider2D OverlapCircle(Vector2 point, float radius, int layerMask, float minDepth);
        public static Collider2D OverlapCircle(Vector2 point, float radius, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("-Mathf.Infinity")] float minDepth, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDepth);
        public static int OverlapCircle(Vector2 point, float radius, ContactFilter2D contactFilter, Collider2D[] results);
        public static int OverlapCircle(Vector2 point, float radius, ContactFilter2D contactFilter, List<Collider2D> results);
        [ExcludeFromDocs]
        public static Collider2D[] OverlapCircleAll(Vector2 point, float radius);
        [ExcludeFromDocs]
        public static Collider2D[] OverlapCircleAll(Vector2 point, float radius, int layerMask);
        [ExcludeFromDocs]
        public static Collider2D[] OverlapCircleAll(Vector2 point, float radius, int layerMask, float minDepth);
        public static Collider2D[] OverlapCircleAll(Vector2 point, float radius, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("-Mathf.Infinity")] float minDepth, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDepth);
        [ExcludeFromDocs]
        public static int OverlapCircleNonAlloc(Vector2 point, float radius, Collider2D[] results);
        [ExcludeFromDocs]
        public static int OverlapCircleNonAlloc(Vector2 point, float radius, Collider2D[] results, int layerMask);
        [ExcludeFromDocs]
        public static int OverlapCircleNonAlloc(Vector2 point, float radius, Collider2D[] results, int layerMask, float minDepth);
        public static int OverlapCircleNonAlloc(Vector2 point, float radius, Collider2D[] results, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("-Mathf.Infinity")] float minDepth, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDepth);
        [ExcludeFromDocs]
        public static Collider2D OverlapBox(Vector2 point, Vector2 size, float angle);
        [ExcludeFromDocs]
        public static Collider2D OverlapBox(Vector2 point, Vector2 size, float angle, int layerMask);
        [ExcludeFromDocs]
        public static Collider2D OverlapBox(Vector2 point, Vector2 size, float angle, int layerMask, float minDepth);
        public static Collider2D OverlapBox(Vector2 point, Vector2 size, float angle, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("-Mathf.Infinity")] float minDepth, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDepth);
        public static int OverlapBox(Vector2 point, Vector2 size, float angle, ContactFilter2D contactFilter, Collider2D[] results);
        public static int OverlapBox(Vector2 point, Vector2 size, float angle, ContactFilter2D contactFilter, List<Collider2D> results);
        [ExcludeFromDocs]
        public static Collider2D[] OverlapBoxAll(Vector2 point, Vector2 size, float angle);
        [ExcludeFromDocs]
        public static Collider2D[] OverlapBoxAll(Vector2 point, Vector2 size, float angle, int layerMask);
        [ExcludeFromDocs]
        public static Collider2D[] OverlapBoxAll(Vector2 point, Vector2 size, float angle, int layerMask, float minDepth);
        public static Collider2D[] OverlapBoxAll(Vector2 point, Vector2 size, float angle, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("-Mathf.Infinity")] float minDepth, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDepth);
        [ExcludeFromDocs]
        public static int OverlapBoxNonAlloc(Vector2 point, Vector2 size, float angle, Collider2D[] results);
        [ExcludeFromDocs]
        public static int OverlapBoxNonAlloc(Vector2 point, Vector2 size, float angle, Collider2D[] results, int layerMask);
        [ExcludeFromDocs]
        public static int OverlapBoxNonAlloc(Vector2 point, Vector2 size, float angle, Collider2D[] results, int layerMask, float minDepth);
        public static int OverlapBoxNonAlloc(Vector2 point, Vector2 size, float angle, Collider2D[] results, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("-Mathf.Infinity")] float minDepth, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDepth);
        [ExcludeFromDocs]
        public static Collider2D OverlapArea(Vector2 pointA, Vector2 pointB);
        [ExcludeFromDocs]
        public static Collider2D OverlapArea(Vector2 pointA, Vector2 pointB, int layerMask);
        [ExcludeFromDocs]
        public static Collider2D OverlapArea(Vector2 pointA, Vector2 pointB, int layerMask, float minDepth);
        public static Collider2D OverlapArea(Vector2 pointA, Vector2 pointB, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("-Mathf.Infinity")] float minDepth, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDepth);
        public static int OverlapArea(Vector2 pointA, Vector2 pointB, ContactFilter2D contactFilter, Collider2D[] results);
        public static int OverlapArea(Vector2 pointA, Vector2 pointB, ContactFilter2D contactFilter, List<Collider2D> results);
        [ExcludeFromDocs]
        public static Collider2D[] OverlapAreaAll(Vector2 pointA, Vector2 pointB);
        [ExcludeFromDocs]
        public static Collider2D[] OverlapAreaAll(Vector2 pointA, Vector2 pointB, int layerMask);
        [ExcludeFromDocs]
        public static Collider2D[] OverlapAreaAll(Vector2 pointA, Vector2 pointB, int layerMask, float minDepth);
        public static Collider2D[] OverlapAreaAll(Vector2 pointA, Vector2 pointB, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("-Mathf.Infinity")] float minDepth, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDepth);
        [ExcludeFromDocs]
        public static int OverlapAreaNonAlloc(Vector2 pointA, Vector2 pointB, Collider2D[] results);
        [ExcludeFromDocs]
        public static int OverlapAreaNonAlloc(Vector2 pointA, Vector2 pointB, Collider2D[] results, int layerMask);
        [ExcludeFromDocs]
        public static int OverlapAreaNonAlloc(Vector2 pointA, Vector2 pointB, Collider2D[] results, int layerMask, float minDepth);
        public static int OverlapAreaNonAlloc(Vector2 pointA, Vector2 pointB, Collider2D[] results, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("-Mathf.Infinity")] float minDepth, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDepth);
        [ExcludeFromDocs]
        public static Collider2D OverlapCapsule(Vector2 point, Vector2 size, CapsuleDirection2D direction, float angle);
        [ExcludeFromDocs]
        public static Collider2D OverlapCapsule(Vector2 point, Vector2 size, CapsuleDirection2D direction, float angle, int layerMask);
        [ExcludeFromDocs]
        public static Collider2D OverlapCapsule(Vector2 point, Vector2 size, CapsuleDirection2D direction, float angle, int layerMask, float minDepth);
        public static Collider2D OverlapCapsule(Vector2 point, Vector2 size, CapsuleDirection2D direction, float angle, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("-Mathf.Infinity")] float minDepth, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDepth);
        public static int OverlapCapsule(Vector2 point, Vector2 size, CapsuleDirection2D direction, float angle, ContactFilter2D contactFilter, Collider2D[] results);
        public static int OverlapCapsule(Vector2 point, Vector2 size, CapsuleDirection2D direction, float angle, ContactFilter2D contactFilter, List<Collider2D> results);
        [ExcludeFromDocs]
        public static Collider2D[] OverlapCapsuleAll(Vector2 point, Vector2 size, CapsuleDirection2D direction, float angle);
        [ExcludeFromDocs]
        public static Collider2D[] OverlapCapsuleAll(Vector2 point, Vector2 size, CapsuleDirection2D direction, float angle, int layerMask);
        [ExcludeFromDocs]
        public static Collider2D[] OverlapCapsuleAll(Vector2 point, Vector2 size, CapsuleDirection2D direction, float angle, int layerMask, float minDepth);
        public static Collider2D[] OverlapCapsuleAll(Vector2 point, Vector2 size, CapsuleDirection2D direction, float angle, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("-Mathf.Infinity")] float minDepth, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDepth);
        [ExcludeFromDocs]
        public static int OverlapCapsuleNonAlloc(Vector2 point, Vector2 size, CapsuleDirection2D direction, float angle, Collider2D[] results);
        [ExcludeFromDocs]
        public static int OverlapCapsuleNonAlloc(Vector2 point, Vector2 size, CapsuleDirection2D direction, float angle, Collider2D[] results, int layerMask);
        [ExcludeFromDocs]
        public static int OverlapCapsuleNonAlloc(Vector2 point, Vector2 size, CapsuleDirection2D direction, float angle, Collider2D[] results, int layerMask, float minDepth);
        public static int OverlapCapsuleNonAlloc(Vector2 point, Vector2 size, CapsuleDirection2D direction, float angle, Collider2D[] results, [UnityEngine.Internal.DefaultValue("DefaultRaycastLayers")] int layerMask, [UnityEngine.Internal.DefaultValue("-Mathf.Infinity")] float minDepth, [UnityEngine.Internal.DefaultValue("Mathf.Infinity")] float maxDepth);
        public static int OverlapCollider(Collider2D collider, ContactFilter2D contactFilter, Collider2D[] results);
        public static int OverlapCollider(Collider2D collider, ContactFilter2D contactFilter, List<Collider2D> results);
        public static int GetContacts(Collider2D collider1, Collider2D collider2, ContactFilter2D contactFilter, ContactPoint2D[] contacts);
        public static int GetContacts(Collider2D collider, ContactPoint2D[] contacts);
        public static int GetContacts(Collider2D collider, ContactFilter2D contactFilter, ContactPoint2D[] contacts);
        public static int GetContacts(Collider2D collider, Collider2D[] colliders);
        public static int GetContacts(Collider2D collider, ContactFilter2D contactFilter, Collider2D[] colliders);
        public static int GetContacts(Rigidbody2D rigidbody, ContactPoint2D[] contacts);
        public static int GetContacts(Rigidbody2D rigidbody, ContactFilter2D contactFilter, ContactPoint2D[] contacts);
        public static int GetContacts(Rigidbody2D rigidbody, Collider2D[] colliders);
        public static int GetContacts(Rigidbody2D rigidbody, ContactFilter2D contactFilter, Collider2D[] colliders);
        public static int GetContacts(Collider2D collider1, Collider2D collider2, ContactFilter2D contactFilter, List<ContactPoint2D> contacts);
        public static int GetContacts(Collider2D collider, List<ContactPoint2D> contacts);
        public static int GetContacts(Collider2D collider, ContactFilter2D contactFilter, List<ContactPoint2D> contacts);
        public static int GetContacts(Collider2D collider, List<Collider2D> colliders);
        public static int GetContacts(Collider2D collider, ContactFilter2D contactFilter, List<Collider2D> colliders);
        public static int GetContacts(Rigidbody2D rigidbody, List<ContactPoint2D> contacts);
        public static int GetContacts(Rigidbody2D rigidbody, ContactFilter2D contactFilter, List<ContactPoint2D> contacts);
        public static int GetContacts(Rigidbody2D rigidbody, List<Collider2D> colliders);
        public static int GetContacts(Rigidbody2D rigidbody, ContactFilter2D contactFilter, List<Collider2D> colliders);
    }
}
namespace UnityEngine
{
    public enum SimulationMode2D
    {
        FixedUpdate = 0,
        Update = 1,
        Script = 2
    }
}
namespace UnityEngine
{
    public enum CapsuleDirection2D
    {
        Vertical = 0,
        Horizontal = 1
    }
}
using System;

namespace UnityEngine
{
    [Flags]
    public enum RigidbodyConstraints2D
    {
        None = 0,
        FreezePositionX = 1,
        FreezePositionY = 2,
        FreezeRotation = 4,
        FreezePosition = 3,
        FreezeAll = 7
    }
}
namespace UnityEngine
{
    public enum RigidbodyInterpolation2D
    {
        None = 0,
        Interpolate = 1,
        Extrapolate = 2
    }
}
namespace UnityEngine
{
    public enum RigidbodySleepMode2D
    {
        NeverSleep = 0,
        StartAwake = 1,
        StartAsleep = 2
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    public enum CollisionDetectionMode2D
    {
        [Obsolete("Enum member CollisionDetectionMode2D.None has been deprecated. Use CollisionDetectionMode2D.Discrete instead (UnityUpgradable) -> Discrete", True)]
        [EditorBrowsable(Never)]
        None = 0,
        Discrete = 0,
        Continuous = 1
    }
}
namespace UnityEngine
{
    public enum RigidbodyType2D
    {
        Dynamic = 0,
        Kinematic = 1,
        Static = 2
    }
}
namespace UnityEngine
{
    public enum ForceMode2D
    {
        Force = 0,
        Impulse = 1
    }
}
namespace UnityEngine
{
    public enum JointLimitState2D
    {
        Inactive = 0,
        LowerLimit = 1,
        UpperLimit = 2,
        EqualLimits = 3
    }
}
namespace UnityEngine
{
    public enum EffectorSelection2D
    {
        Rigidbody = 0,
        Collider = 1
    }
}
namespace UnityEngine
{
    public enum EffectorForceMode2D
    {
        Constant = 0,
        InverseLinear = 1,
        InverseSquared = 2
    }
}
namespace UnityEngine
{
    public struct ColliderDistance2D
    {
        public Vector2 pointA { get; set; }
        public Vector2 pointB { get; set; }
        public Vector2 normal { get; }
        public float distance { get; set; }
        public bool isOverlapped { get; }
        public bool isValid { get; set; }
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [RequiredByNativeCode(Optional = True, GenerateProxy = True)]
    [NativeHeader("Modules/Physics2D/Public/Collider2D.h")]
    [NativeClass("ContactFilter", "struct ContactFilter;")]
    public struct ContactFilter2D
    {
        [NativeName("m_UseTriggers")]
        public bool useTriggers;
        [NativeName("m_UseLayerMask")]
        public bool useLayerMask;
        [NativeName("m_UseDepth")]
        public bool useDepth;
        [NativeName("m_UseOutsideDepth")]
        public bool useOutsideDepth;
        [NativeName("m_UseNormalAngle")]
        public bool useNormalAngle;
        [NativeName("m_UseOutsideNormalAngle")]
        public bool useOutsideNormalAngle;
        [NativeName("m_LayerMask")]
        public LayerMask layerMask;
        [NativeName("m_MinDepth")]
        public float minDepth;
        [NativeName("m_MaxDepth")]
        public float maxDepth;
        [NativeName("m_MinNormalAngle")]
        public float minNormalAngle;
        [NativeName("m_MaxNormalAngle")]
        public float maxNormalAngle;
        public const float NormalAngleUpperLimit = 359.9999F;

        public bool isFiltering { get; }

        public ContactFilter2D NoFilter();
        public void ClearLayerMask();
        public void SetLayerMask(LayerMask layerMask);
        public void ClearDepth();
        public void SetDepth(float minDepth, float maxDepth);
        public void ClearNormalAngle();
        public void SetNormalAngle(float minNormalAngle, float maxNormalAngle);
        public bool IsFilteringTrigger([Writable] Collider2D collider);
        public bool IsFilteringLayerMask(GameObject obj);
        public bool IsFilteringDepth(GameObject obj);
        public bool IsFilteringNormalAngle(Vector2 normal);
        public bool IsFilteringNormalAngle(float angle);
    }
}
using System.Collections.Generic;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [RequiredByNativeCode]
    public class Collision2D
    {
        public Collision2D();

        public Collider2D collider { get; }
        public Collider2D otherCollider { get; }
        public Rigidbody2D rigidbody { get; }
        public Rigidbody2D otherRigidbody { get; }
        public Transform transform { get; }
        public GameObject gameObject { get; }
        public Vector2 relativeVelocity { get; }
        public bool enabled { get; }
        public ContactPoint2D[] contacts { get; }
        public int contactCount { get; }

        public ContactPoint2D GetContact(int index);
        public int GetContacts(ContactPoint2D[] contacts);
        public int GetContacts(List<ContactPoint2D> contacts);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeClass("ScriptingContactPoint2D", "struct ScriptingContactPoint2D;")]
    [NativeHeader("Modules/Physics2D/Public/PhysicsScripting2D.h")]
    [RequiredByNativeCode(Optional = False, GenerateProxy = True)]
    public struct ContactPoint2D
    {
        public Vector2 point { get; }
        public Vector2 normal { get; }
        public float separation { get; }
        public float normalImpulse { get; }
        public float tangentImpulse { get; }
        public Vector2 relativeVelocity { get; }
        public Collider2D collider { get; }
        public Collider2D otherCollider { get; }
        public Rigidbody2D rigidbody { get; }
        public Rigidbody2D otherRigidbody { get; }
        public bool enabled { get; }
    }
}
namespace UnityEngine
{
    public struct JointAngleLimits2D
    {
        public float min { get; set; }
        public float max { get; set; }
    }
}
namespace UnityEngine
{
    public struct JointTranslationLimits2D
    {
        public float min { get; set; }
        public float max { get; set; }
    }
}
namespace UnityEngine
{
    public struct JointMotor2D
    {
        public float motorSpeed { get; set; }
        public float maxMotorTorque { get; set; }
    }
}
namespace UnityEngine
{
    public struct JointSuspension2D
    {
        public float dampingRatio { get; set; }
        public float frequency { get; set; }
        public float angle { get; set; }
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [RequiredByNativeCode(Optional = True, GenerateProxy = True)]
    [NativeHeader("Runtime/Interfaces/IPhysics2D.h")]
    [NativeClass("RaycastHit2D", "struct RaycastHit2D;")]
    public struct RaycastHit2D
    {
        public Vector2 centroid { get; set; }
        public Vector2 point { get; set; }
        public Vector2 normal { get; set; }
        public float distance { get; set; }
        public float fraction { get; set; }
        public Collider2D collider { get; }
        public Rigidbody2D rigidbody { get; }
        public Transform transform { get; }

        public int CompareTo(RaycastHit2D other);

        public static implicit operator bool(RaycastHit2D hit);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics2D/Public/Physics2DSettings.h")]
    [RequiredByNativeCode(Optional = True, GenerateProxy = True)]
    [NativeClass("PhysicsJobOptions2D", "struct PhysicsJobOptions2D;")]
    public struct PhysicsJobOptions2D
    {
        public bool useMultithreading { get; set; }
        public bool useConsistencySorting { get; set; }
        public int interpolationPosesPerJob { get; set; }
        public int newContactsPerJob { get; set; }
        public int collideContactsPerJob { get; set; }
        public int clearFlagsPerJob { get; set; }
        public int clearBodyForcesPerJob { get; set; }
        public int syncDiscreteFixturesPerJob { get; set; }
        public int syncContinuousFixturesPerJob { get; set; }
        public int findNearestContactsPerJob { get; set; }
        public int updateTriggerContactsPerJob { get; set; }
        public int islandSolverCostThreshold { get; set; }
        public int islandSolverBodyCostScale { get; set; }
        public int islandSolverContactCostScale { get; set; }
        public int islandSolverJointCostScale { get; set; }
        public int islandSolverBodiesPerJob { get; set; }
        public int islandSolverContactsPerJob { get; set; }
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Internal;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics2D/Public/Rigidbody2D.h")]
    [RequireComponent(typeof(Transform))]
    public sealed class Rigidbody2D : Component
    {
        public Rigidbody2D();

        public Vector2 position { get; set; }
        public float rotation { get; set; }
        public Vector2 velocity { get; set; }
        public float angularVelocity { get; set; }
        public bool useAutoMass { get; set; }
        public float mass { get; set; }
        [NativeMethod("Material")]
        public PhysicsMaterial2D sharedMaterial { get; set; }
        public Vector2 centerOfMass { get; set; }
        public Vector2 worldCenterOfMass { get; }
        public float inertia { get; set; }
        public float drag { get; set; }
        public float angularDrag { get; set; }
        public float gravityScale { get; set; }
        public RigidbodyType2D bodyType { get; set; }
        public bool useFullKinematicContacts { get; set; }
        public bool isKinematic { get; set; }
        [Obsolete("'fixedAngle' is no longer supported. Use constraints instead.", False)]
        [NativeMethod("FreezeRotation")]
        public bool fixedAngle { get; set; }
        public bool freezeRotation { get; set; }
        public RigidbodyConstraints2D constraints { get; set; }
        public bool simulated { get; set; }
        public RigidbodyInterpolation2D interpolation { get; set; }
        public RigidbodySleepMode2D sleepMode { get; set; }
        public CollisionDetectionMode2D collisionDetectionMode { get; set; }
        public int attachedColliderCount { get; }

        public void SetRotation(float angle);
        public void SetRotation(Quaternion rotation);
        public void MovePosition(Vector2 position);
        public void MoveRotation(float angle);
        public void MoveRotation(Quaternion rotation);
        public bool IsSleeping();
        public bool IsAwake();
        public void Sleep();
        [NativeMethod("Wake")]
        public void WakeUp();
        public bool IsTouching([NotNull("ArgumentNullException")][Writable] Collider2D collider);
        public bool IsTouching([Writable] Collider2D collider, ContactFilter2D contactFilter);
        public bool IsTouching(ContactFilter2D contactFilter);
        [ExcludeFromDocs]
        public bool IsTouchingLayers();
        public bool IsTouchingLayers([DefaultValue("Physics2D.AllLayers")] int layerMask);
        public bool OverlapPoint(Vector2 point);
        public ColliderDistance2D Distance([Writable] Collider2D collider);
        public Vector2 ClosestPoint(Vector2 position);
        [ExcludeFromDocs]
        public void AddForce(Vector2 force);
        public void AddForce(Vector2 force, [DefaultValue("ForceMode2D.Force")] ForceMode2D mode);
        [ExcludeFromDocs]
        public void AddRelativeForce(Vector2 relativeForce);
        public void AddRelativeForce(Vector2 relativeForce, [DefaultValue("ForceMode2D.Force")] ForceMode2D mode);
        [ExcludeFromDocs]
        public void AddForceAtPosition(Vector2 force, Vector2 position);
        public void AddForceAtPosition(Vector2 force, Vector2 position, [DefaultValue("ForceMode2D.Force")] ForceMode2D mode);
        [ExcludeFromDocs]
        public void AddTorque(float torque);
        public void AddTorque(float torque, [DefaultValue("ForceMode2D.Force")] ForceMode2D mode);
        public Vector2 GetPoint(Vector2 point);
        public Vector2 GetRelativePoint(Vector2 relativePoint);
        public Vector2 GetVector(Vector2 vector);
        public Vector2 GetRelativeVector(Vector2 relativeVector);
        public Vector2 GetPointVelocity(Vector2 point);
        public Vector2 GetRelativePointVelocity(Vector2 relativePoint);
        public int OverlapCollider(ContactFilter2D contactFilter, out Collider2D[] results);
        public int OverlapCollider(ContactFilter2D contactFilter, List<Collider2D> results);
        public int GetContacts(ContactPoint2D[] contacts);
        public int GetContacts(List<ContactPoint2D> contacts);
        public int GetContacts(ContactFilter2D contactFilter, ContactPoint2D[] contacts);
        public int GetContacts(ContactFilter2D contactFilter, List<ContactPoint2D> contacts);
        public int GetContacts(Collider2D[] colliders);
        public int GetContacts(List<Collider2D> colliders);
        public int GetContacts(ContactFilter2D contactFilter, Collider2D[] colliders);
        public int GetContacts(ContactFilter2D contactFilter, List<Collider2D> colliders);
        public int GetAttachedColliders(out Collider2D[] results);
        public int GetAttachedColliders(List<Collider2D> results);
        [ExcludeFromDocs]
        public int Cast(Vector2 direction, RaycastHit2D[] results);
        public int Cast(Vector2 direction, RaycastHit2D[] results, [DefaultValue("Mathf.Infinity")] float distance);
        public int Cast(Vector2 direction, List<RaycastHit2D> results, [DefaultValue("Mathf.Infinity")] float distance = InfinityF);
        [ExcludeFromDocs]
        public int Cast(Vector2 direction, ContactFilter2D contactFilter, RaycastHit2D[] results);
        public int Cast(Vector2 direction, ContactFilter2D contactFilter, RaycastHit2D[] results, [DefaultValue("Mathf.Infinity")] float distance);
        public int Cast(Vector2 direction, ContactFilter2D contactFilter, List<RaycastHit2D> results, [DefaultValue("Mathf.Infinity")] float distance);
    }
}
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Internal;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [RequiredByNativeCode(Optional = True)]
    [NativeHeader("Modules/Physics2D/Public/Collider2D.h")]
    [RequireComponent(typeof(Transform))]
    public class Collider2D : Behaviour
    {
        public Collider2D();

        public float density { get; set; }
        public bool isTrigger { get; set; }
        public bool usedByEffector { get; set; }
        public bool usedByComposite { get; set; }
        public CompositeCollider2D composite { get; }
        public Vector2 offset { get; set; }
        public Rigidbody2D attachedRigidbody { get; }
        public int shapeCount { get; }
        public Bounds bounds { get; }
        public PhysicsMaterial2D sharedMaterial { get; set; }
        public float friction { get; }
        public float bounciness { get; }

        [NativeMethod("CreateMesh_Binding")]
        public Mesh CreateMesh(bool useBodyPosition, bool useBodyRotation);
        [NativeMethod("GetShapeHash_Binding")]
        public uint GetShapeHash();
        public bool IsTouching([NotNull("ArgumentNullException")][Writable] Collider2D collider);
        public bool IsTouching([Writable] Collider2D collider, ContactFilter2D contactFilter);
        public bool IsTouching(ContactFilter2D contactFilter);
        [ExcludeFromDocs]
        public bool IsTouchingLayers();
        public bool IsTouchingLayers([DefaultValue("Physics2D.AllLayers")] int layerMask);
        public bool OverlapPoint(Vector2 point);
        public ColliderDistance2D Distance([Writable] Collider2D collider);
        public int OverlapCollider(ContactFilter2D contactFilter, Collider2D[] results);
        public int OverlapCollider(ContactFilter2D contactFilter, List<Collider2D> results);
        public int GetContacts(ContactPoint2D[] contacts);
        public int GetContacts(List<ContactPoint2D> contacts);
        public int GetContacts(ContactFilter2D contactFilter, ContactPoint2D[] contacts);
        public int GetContacts(ContactFilter2D contactFilter, List<ContactPoint2D> contacts);
        public int GetContacts(Collider2D[] colliders);
        public int GetContacts(List<Collider2D> colliders);
        public int GetContacts(ContactFilter2D contactFilter, Collider2D[] colliders);
        public int GetContacts(ContactFilter2D contactFilter, List<Collider2D> colliders);
        [ExcludeFromDocs]
        public int Cast(Vector2 direction, RaycastHit2D[] results);
        [ExcludeFromDocs]
        public int Cast(Vector2 direction, RaycastHit2D[] results, float distance);
        public int Cast(Vector2 direction, RaycastHit2D[] results, [DefaultValue("Mathf.Infinity")] float distance, [DefaultValue("true")] bool ignoreSiblingColliders);
        [ExcludeFromDocs]
        public int Cast(Vector2 direction, ContactFilter2D contactFilter, RaycastHit2D[] results);
        [ExcludeFromDocs]
        public int Cast(Vector2 direction, ContactFilter2D contactFilter, RaycastHit2D[] results, float distance);
        public int Cast(Vector2 direction, ContactFilter2D contactFilter, RaycastHit2D[] results, [DefaultValue("Mathf.Infinity")] float distance, [DefaultValue("true")] bool ignoreSiblingColliders);
        public int Cast(Vector2 direction, ContactFilter2D contactFilter, List<RaycastHit2D> results, [DefaultValue("Mathf.Infinity")] float distance = InfinityF, [DefaultValue("true")] bool ignoreSiblingColliders = True);
        [ExcludeFromDocs]
        public int Raycast(Vector2 direction, RaycastHit2D[] results);
        [ExcludeFromDocs]
        public int Raycast(Vector2 direction, RaycastHit2D[] results, float distance);
        [ExcludeFromDocs]
        public int Raycast(Vector2 direction, RaycastHit2D[] results, float distance, int layerMask);
        [ExcludeFromDocs]
        public int Raycast(Vector2 direction, RaycastHit2D[] results, float distance, int layerMask, float minDepth);
        public int Raycast(Vector2 direction, RaycastHit2D[] results, [DefaultValue("Mathf.Infinity")] float distance, [DefaultValue("Physics2D.AllLayers")] int layerMask, [DefaultValue("-Mathf.Infinity")] float minDepth, [DefaultValue("Mathf.Infinity")] float maxDepth);
        [ExcludeFromDocs]
        public int Raycast(Vector2 direction, ContactFilter2D contactFilter, RaycastHit2D[] results);
        public int Raycast(Vector2 direction, ContactFilter2D contactFilter, RaycastHit2D[] results, [DefaultValue("Mathf.Infinity")] float distance);
        public int Raycast(Vector2 direction, ContactFilter2D contactFilter, List<RaycastHit2D> results, [DefaultValue("Mathf.Infinity")] float distance = InfinityF);
        public Vector2 ClosestPoint(Vector2 position);
    }
}
using System;
using System.ComponentModel;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics2D/Public/CircleCollider2D.h")]
    public sealed class CircleCollider2D : Collider2D
    {
        public CircleCollider2D();

        public float radius { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("CircleCollider2D.center has been deprecated. Use CircleCollider2D.offset instead (UnityUpgradable) -> offset", True)]
        public Vector2 center { get; set; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics2D/Public/CapsuleCollider2D.h")]
    public sealed class CapsuleCollider2D : Collider2D
    {
        public CapsuleCollider2D();

        public Vector2 size { get; set; }
        public CapsuleDirection2D direction { get; set; }
    }
}
using System.Collections.Generic;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics2D/Public/EdgeCollider2D.h")]
    public sealed class EdgeCollider2D : Collider2D
    {
        public EdgeCollider2D();

        public float edgeRadius { get; set; }
        public int edgeCount { get; }
        public int pointCount { get; }
        public Vector2[] points { get; set; }
        public bool useAdjacentStartPoint { get; set; }
        public bool useAdjacentEndPoint { get; set; }
        public Vector2 adjacentStartPoint { get; set; }
        public Vector2 adjacentEndPoint { get; set; }

        public void Reset();
        [NativeMethod("GetPoints_Binding")]
        public int GetPoints([NotNull("ArgumentNullException")] List<Vector2> points);
        [NativeMethod("SetPoints_Binding")]
        public bool SetPoints([NotNull("ArgumentNullException")] List<Vector2> points);
    }
}
using System;
using System.ComponentModel;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics2D/Public/BoxCollider2D.h")]
    public sealed class BoxCollider2D : Collider2D
    {
        public BoxCollider2D();

        public Vector2 size { get; set; }
        public float edgeRadius { get; set; }
        public bool autoTiling { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("BoxCollider2D.center has been deprecated. Use BoxCollider2D.offset instead (UnityUpgradable) -> offset", True)]
        public Vector2 center { get; set; }
    }
}
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Internal;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics2D/Public/PolygonCollider2D.h")]
    public sealed class PolygonCollider2D : Collider2D
    {
        public PolygonCollider2D();

        public bool autoTiling { get; set; }
        public Vector2[] points { get; set; }
        public int pathCount { get; set; }

        [NativeMethod("GetPointCount")]
        public int GetTotalPointCount();
        public Vector2[] GetPath(int index);
        public void SetPath(int index, Vector2[] points);
        public int GetPath(int index, List<Vector2> points);
        public void SetPath(int index, List<Vector2> points);
        [ExcludeFromDocs]
        public void CreatePrimitive(int sides);
        [ExcludeFromDocs]
        public void CreatePrimitive(int sides, Vector2 scale);
        public void CreatePrimitive(int sides, [DefaultValue("Vector2.one")] Vector2 scale, [DefaultValue("Vector2.zero")] Vector2 offset);
    }
}
using System.Collections.Generic;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics2D/Public/CompositeCollider2D.h")]
    [RequireComponent(typeof(Rigidbody2D))]
    public sealed class CompositeCollider2D : Collider2D
    {
        public CompositeCollider2D();

        public GeometryType geometryType { get; set; }
        public GenerationType generationType { get; set; }
        public float vertexDistance { get; set; }
        public float edgeRadius { get; set; }
        public float offsetDistance { get; set; }
        public int pathCount { get; }
        public int pointCount { get; }

        public void GenerateGeometry();
        public int GetPathPointCount(int index);
        public int GetPath(int index, Vector2[] points);
        public int GetPath(int index, List<Vector2> points);

        public enum GeometryType
        {
            Outlines = 0,
            Polygons = 1
        }
        public enum GenerationType
        {
            Synchronous = 0,
            Manual = 1
        }
    }
}
using System;
using System.ComponentModel;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [RequireComponent(typeof(Transform), typeof(Rigidbody2D))]
    [NativeHeader("Modules/Physics2D/Joint2D.h")]
    public class Joint2D : Behaviour
    {
        public Joint2D();

        public Rigidbody2D attachedRigidbody { get; }
        public Rigidbody2D connectedBody { get; set; }
        public bool enableCollision { get; set; }
        public float breakForce { get; set; }
        public float breakTorque { get; set; }
        public Vector2 reactionForce { get; }
        public float reactionTorque { get; }
        [Obsolete("Joint2D.collideConnected has been deprecated. Use Joint2D.enableCollision instead (UnityUpgradable) -> enableCollision", True)]
        [EditorBrowsable(Never)]
        public bool collideConnected { get; set; }

        public Vector2 GetReactionForce(float timeStep);
        public float GetReactionTorque(float timeStep);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics2D/AnchoredJoint2D.h")]
    public class AnchoredJoint2D : Joint2D
    {
        public AnchoredJoint2D();

        public Vector2 anchor { get; set; }
        public Vector2 connectedAnchor { get; set; }
        public bool autoConfigureConnectedAnchor { get; set; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics2D/SpringJoint2D.h")]
    public sealed class SpringJoint2D : AnchoredJoint2D
    {
        public SpringJoint2D();

        public bool autoConfigureDistance { get; set; }
        public float distance { get; set; }
        public float dampingRatio { get; set; }
        public float frequency { get; set; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics2D/DistanceJoint2D.h")]
    public sealed class DistanceJoint2D : AnchoredJoint2D
    {
        public DistanceJoint2D();

        public bool autoConfigureDistance { get; set; }
        public float distance { get; set; }
        public bool maxDistanceOnly { get; set; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics2D/FrictionJoint2D.h")]
    public sealed class FrictionJoint2D : AnchoredJoint2D
    {
        public FrictionJoint2D();

        public float maxForce { get; set; }
        public float maxTorque { get; set; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics2D/HingeJoint2D.h")]
    public sealed class HingeJoint2D : AnchoredJoint2D
    {
        public HingeJoint2D();

        public bool useMotor { get; set; }
        public bool useLimits { get; set; }
        public JointMotor2D motor { get; set; }
        public JointAngleLimits2D limits { get; set; }
        public JointLimitState2D limitState { get; }
        public float referenceAngle { get; }
        public float jointAngle { get; }
        public float jointSpeed { get; }

        public float GetMotorTorque(float timeStep);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics2D/RelativeJoint2D.h")]
    public sealed class RelativeJoint2D : Joint2D
    {
        public RelativeJoint2D();

        public float maxForce { get; set; }
        public float maxTorque { get; set; }
        public float correctionScale { get; set; }
        public bool autoConfigureOffset { get; set; }
        public Vector2 linearOffset { get; set; }
        public float angularOffset { get; set; }
        public Vector2 target { get; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics2D/SliderJoint2D.h")]
    public sealed class SliderJoint2D : AnchoredJoint2D
    {
        public SliderJoint2D();

        public bool autoConfigureAngle { get; set; }
        public float angle { get; set; }
        public bool useMotor { get; set; }
        public bool useLimits { get; set; }
        public JointMotor2D motor { get; set; }
        public JointTranslationLimits2D limits { get; set; }
        public JointLimitState2D limitState { get; }
        public float referenceAngle { get; }
        public float jointTranslation { get; }
        public float jointSpeed { get; }

        public float GetMotorForce(float timeStep);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics2D/TargetJoint2D.h")]
    public sealed class TargetJoint2D : Joint2D
    {
        public TargetJoint2D();

        public Vector2 anchor { get; set; }
        public Vector2 target { get; set; }
        public bool autoConfigureTarget { get; set; }
        public float maxForce { get; set; }
        public float dampingRatio { get; set; }
        public float frequency { get; set; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics2D/FixedJoint2D.h")]
    public sealed class FixedJoint2D : AnchoredJoint2D
    {
        public FixedJoint2D();

        public float dampingRatio { get; set; }
        public float frequency { get; set; }
        public float referenceAngle { get; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics2D/WheelJoint2D.h")]
    public sealed class WheelJoint2D : AnchoredJoint2D
    {
        public WheelJoint2D();

        public JointSuspension2D suspension { get; set; }
        public bool useMotor { get; set; }
        public JointMotor2D motor { get; set; }
        public float jointTranslation { get; }
        public float jointLinearSpeed { get; }
        public float jointSpeed { get; }
        public float jointAngle { get; }

        public float GetMotorTorque(float timeStep);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics2D/Effector2D.h")]
    public class Effector2D : Behaviour
    {
        public Effector2D();

        public bool useColliderMask { get; set; }
        public int colliderMask { get; set; }
    }
}
using System;
using System.ComponentModel;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics2D/AreaEffector2D.h")]
    public class AreaEffector2D : Effector2D
    {
        public AreaEffector2D();

        public float forceAngle { get; set; }
        public bool useGlobalAngle { get; set; }
        public float forceMagnitude { get; set; }
        public float forceVariation { get; set; }
        public float drag { get; set; }
        public float angularDrag { get; set; }
        public EffectorSelection2D forceTarget { get; set; }
        [Obsolete("AreaEffector2D.forceDirection has been deprecated. Use AreaEffector2D.forceAngle instead (UnityUpgradable) -> forceAngle", True)]
        [EditorBrowsable(Never)]
        public float forceDirection { get; set; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics2D/BuoyancyEffector2D.h")]
    public class BuoyancyEffector2D : Effector2D
    {
        public BuoyancyEffector2D();

        public float surfaceLevel { get; set; }
        public float density { get; set; }
        public float linearDrag { get; set; }
        public float angularDrag { get; set; }
        public float flowAngle { get; set; }
        public float flowMagnitude { get; set; }
        public float flowVariation { get; set; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics2D/PointEffector2D.h")]
    public class PointEffector2D : Effector2D
    {
        public PointEffector2D();

        public float forceMagnitude { get; set; }
        public float forceVariation { get; set; }
        public float distanceScale { get; set; }
        public float drag { get; set; }
        public float angularDrag { get; set; }
        public EffectorSelection2D forceSource { get; set; }
        public EffectorSelection2D forceTarget { get; set; }
        public EffectorForceMode2D forceMode { get; set; }
    }
}
using System;
using System.ComponentModel;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics2D/PlatformEffector2D.h")]
    public class PlatformEffector2D : Effector2D
    {
        public PlatformEffector2D();

        public bool useOneWay { get; set; }
        public bool useOneWayGrouping { get; set; }
        public bool useSideFriction { get; set; }
        public bool useSideBounce { get; set; }
        public float surfaceArc { get; set; }
        public float sideArc { get; set; }
        public float rotationalOffset { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("PlatformEffector2D.oneWay has been deprecated. Use PlatformEffector2D.useOneWay instead (UnityUpgradable) -> useOneWay", True)]
        public bool oneWay { get; set; }
        [Obsolete("PlatformEffector2D.sideFriction has been deprecated. Use PlatformEffector2D.useSideFriction instead (UnityUpgradable) -> useSideFriction", True)]
        [EditorBrowsable(Never)]
        public bool sideFriction { get; set; }
        [Obsolete("PlatformEffector2D.sideBounce has been deprecated. Use PlatformEffector2D.useSideBounce instead (UnityUpgradable) -> useSideBounce", True)]
        [EditorBrowsable(Never)]
        public bool sideBounce { get; set; }
        [Obsolete("PlatformEffector2D.sideAngleVariance has been deprecated. Use PlatformEffector2D.sideArc instead (UnityUpgradable) -> sideArc", True)]
        [EditorBrowsable(Never)]
        public float sideAngleVariance { get; set; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics2D/SurfaceEffector2D.h")]
    public class SurfaceEffector2D : Effector2D
    {
        public SurfaceEffector2D();

        public float speed { get; set; }
        public float speedVariation { get; set; }
        public float forceScale { get; set; }
        public bool useContactForce { get; set; }
        public bool useFriction { get; set; }
        public bool useBounce { get; set; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics2D/PhysicsUpdateBehaviour2D.h")]
    public class PhysicsUpdateBehaviour2D : Behaviour
    {
        public PhysicsUpdateBehaviour2D();
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [RequireComponent(typeof(Rigidbody2D))]
    [NativeHeader("Modules/Physics2D/ConstantForce2D.h")]
    public sealed class ConstantForce2D : PhysicsUpdateBehaviour2D
    {
        public ConstantForce2D();

        public Vector2 force { get; set; }
        public Vector2 relativeForce { get; set; }
        public float torque { get; set; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Physics2D/Public/PhysicsMaterial2D.h")]
    public sealed class PhysicsMaterial2D : Object
    {
        public PhysicsMaterial2D();
        public PhysicsMaterial2D(string name);

        public float bounciness { get; set; }
        public float friction { get; set; }
    }
}
-------- {UnityEngine.ProfilerModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.ProfilerModule.dll)}:   -1 --------
-------- {UnityEngine.RuntimeInitializeOnLoadManagerInitializerModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.RuntimeInitializeOnLoadManagerInitializerModule.dll)}:   -1 --------
-------- {UnityEngine.ScreenCaptureModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.ScreenCaptureModule.dll)}:    1 --------
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/ScreenCapture/Public/CaptureScreenshot.h")]
    public static class ScreenCapture
    {
        public static void CaptureScreenshot(string filename);
        public static void CaptureScreenshot(string filename, int superSize);
        public static void CaptureScreenshot(string filename, StereoScreenCaptureMode stereoCaptureMode);
        public static Texture2D CaptureScreenshotAsTexture();
        public static Texture2D CaptureScreenshotAsTexture(int superSize);
        public static Texture2D CaptureScreenshotAsTexture(StereoScreenCaptureMode stereoCaptureMode);
        public static void CaptureScreenshotIntoRenderTexture(RenderTexture renderTexture);

        public enum StereoScreenCaptureMode
        {
            LeftEye = 1,
            RightEye = 2,
            BothEyes = 3
        }
    }
}
-------- {UnityEngine.SharedInternalsModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.SharedInternalsModule.dll)}:   42 --------
-------- {UnityEngine.SpriteMaskModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.SpriteMaskModule.dll)}:    0 --------
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeType(Header = "Modules/SpriteMask/Public/SpriteMask.h")]
    [RejectDragAndDropMaterial]
    public sealed class SpriteMask : Renderer
    {
        public SpriteMask();

        public int frontSortingLayerID { get; set; }
        public int frontSortingOrder { get; set; }
        public int backSortingLayerID { get; set; }
        public int backSortingOrder { get; set; }
        public float alphaCutoff { get; set; }
        public Sprite sprite { get; set; }
        public bool isCustomRangeActive { get; set; }
        public SpriteSortPoint spriteSortPoint { get; set; }
    }
}
-------- {UnityEngine.SpriteShapeModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.SpriteShapeModule.dll)}:    7 --------
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.U2D
{
    [MovedFrom("UnityEngine.Experimental.U2D")]
    public struct SpriteShapeParameters
    {
        public Matrix4x4 transform;
        public Texture2D fillTexture;
        public uint fillScale;
        public uint splineDetail;
        public float angleThreshold;
        public float borderPivot;
        public float bevelCutoff;
        public float bevelSize;
        public bool carpet;
        public bool smartSprite;
        public bool adaptiveUV;
        public bool spriteBorders;
        public bool stretchUV;
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.U2D
{
    [MovedFrom("UnityEngine.Experimental.U2D")]
    public struct SpriteShapeSegment
    {
        public int geomIndex { get; set; }
        public int indexCount { get; set; }
        public int vertexCount { get; set; }
        public int spriteIndex { get; set; }
    }
}
using Unity.Collections;
using Unity.Jobs;
using UnityEngine.Bindings;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.U2D
{
    [MovedFrom("UnityEngine.Experimental.U2D")]
    [NativeType(Header = "Modules/SpriteShape/Public/SpriteShapeRenderer.h")]
    public class SpriteShapeRenderer : Renderer
    {
        public SpriteShapeRenderer();

        public Color color { get; set; }
        public SpriteMaskInteraction maskInteraction { get; set; }

        public void Prepare(JobHandle handle, SpriteShapeParameters shapeParams, Sprite[] sprites);
        public NativeArray<Bounds> GetBounds();
        public NativeArray<SpriteShapeSegment> GetSegments(int dataSize);
        public void GetChannels(int dataSize, out NativeArray<ushort> indices, out NativeSlice<Vector3> vertices, out NativeSlice<Vector2> texcoords);
        public void GetChannels(int dataSize, out NativeArray<ushort> indices, out NativeSlice<Vector3> vertices, out NativeSlice<Vector2> texcoords, out NativeSlice<Vector4> tangents);
        public void GetChannels(int dataSize, out NativeArray<ushort> indices, out NativeSlice<Vector3> vertices, out NativeSlice<Vector2> texcoords, out NativeSlice<Vector4> tangents, out NativeSlice<Vector3> normals);
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.U2D
{
    [MovedFrom("UnityEngine.Experimental.U2D")]
    public struct SpriteShapeMetaData
    {
        public float height;
        public float bevelCutoff;
        public float bevelSize;
        public uint spriteIndex;
        public bool corner;
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.U2D
{
    [MovedFrom("UnityEngine.Experimental.U2D")]
    public struct ShapeControlPoint
    {
        public Vector3 position;
        public Vector3 leftTangent;
        public Vector3 rightTangent;
        public int mode;
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.U2D
{
    [MovedFrom("UnityEngine.Experimental.U2D")]
    public struct AngleRangeInfo
    {
        public float start;
        public float end;
        public uint order;
        public int[] sprites;
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.U2D
{
    [MovedFrom("UnityEngine.Experimental.U2D")]
    [NativeHeader("Modules/SpriteShape/Public/SpriteShapeUtility.h")]
    public class SpriteShapeUtility
    {
        public SpriteShapeUtility();

        [FreeFunction("SpriteShapeUtility::Generate")]
        [NativeThrows]
        public static int[] Generate(Mesh mesh, SpriteShapeParameters shapeParams, ShapeControlPoint[] points, SpriteShapeMetaData[] metaData, AngleRangeInfo[] angleRange, Sprite[] sprites, Sprite[] corners);
        [NativeThrows]
        [FreeFunction("SpriteShapeUtility::GenerateSpriteShape")]
        public static void GenerateSpriteShape(SpriteShapeRenderer renderer, SpriteShapeParameters shapeParams, ShapeControlPoint[] points, SpriteShapeMetaData[] metaData, AngleRangeInfo[] angleRange, Sprite[] sprites, Sprite[] corners);
    }
}
-------- {UnityEngine.StreamingModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.StreamingModule.dll)}:    0 --------
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Streaming/StreamingController.h")]
    [RequireComponent(typeof(Camera))]
    public class StreamingController : Behaviour
    {
        public StreamingController();

        public float streamingMipmapBias { get; set; }

        public void SetPreloading(float timeoutSeconds = 0, bool activateCameraOnTimeout = False, Camera disableCameraCuttingFrom = null);
        public void CancelPreloading();
        public bool IsPreloading();
    }
}
-------- {UnityEngine.SubstanceModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.SubstanceModule.dll)}:    7 --------
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [Obsolete("Built-in support for Substance Designer materials has been removed from Unity. To continue using Substance Designer materials, you will need to install Allegorithmic's external importer from the Asset Store.", True)]
    [ExcludeFromPreset]
    [EditorBrowsable(Never)]
    public sealed class ProceduralMaterial : Material
    {
        public ProceduralCacheSize cacheSize { get; set; }
        public int animationUpdateRate { get; set; }
        public bool isProcessing { get; }
        public bool isCachedDataAvailable { get; }
        public bool isLoadTimeGenerated { get; set; }
        public ProceduralLoadingBehavior loadingBehavior { get; }
        public static bool isSupported { get; }
        public static ProceduralProcessorUsage substanceProcessorUsage { get; set; }
        public string preset { get; set; }
        public bool isReadable { get; set; }
        public bool isFrozen { get; }

        public ProceduralPropertyDescription[] GetProceduralPropertyDescriptions();
        public bool HasProceduralProperty(string inputName);
        public bool GetProceduralBoolean(string inputName);
        public bool IsProceduralPropertyVisible(string inputName);
        public void SetProceduralBoolean(string inputName, bool value);
        public float GetProceduralFloat(string inputName);
        public void SetProceduralFloat(string inputName, float value);
        public Vector4 GetProceduralVector(string inputName);
        public void SetProceduralVector(string inputName, Vector4 value);
        public Color GetProceduralColor(string inputName);
        public void SetProceduralColor(string inputName, Color value);
        public int GetProceduralEnum(string inputName);
        public void SetProceduralEnum(string inputName, int value);
        public Texture2D GetProceduralTexture(string inputName);
        public void SetProceduralTexture(string inputName, Texture2D value);
        public string GetProceduralString(string inputName);
        public void SetProceduralString(string inputName, string value);
        public bool IsProceduralPropertyCached(string inputName);
        public void CacheProceduralProperty(string inputName, bool value);
        public void ClearCache();
        public void RebuildTextures();
        public void RebuildTexturesImmediately();
        public static void StopRebuilds();
        public Texture[] GetGeneratedTextures();
        public ProceduralTexture GetGeneratedTexture(string textureName);
        public void FreezeAndReleaseSourceData();
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [Obsolete("Built-in support for Substance Designer materials has been removed from Unity. To continue using Substance Designer materials, you will need to install Allegorithmic's external importer from the Asset Store.", True)]
    [EditorBrowsable(Never)]
    public enum ProceduralProcessorUsage
    {
        Unsupported = 0,
        One = 1,
        Half = 2,
        All = 3
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [Obsolete("Built-in support for Substance Designer materials has been removed from Unity. To continue using Substance Designer materials, you will need to install Allegorithmic's external importer from the Asset Store.", True)]
    [EditorBrowsable(Never)]
    public enum ProceduralCacheSize
    {
        Tiny = 0,
        Medium = 1,
        Heavy = 2,
        NoLimit = 3,
        None = 4
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [Obsolete("Built-in support for Substance Designer materials has been removed from Unity. To continue using Substance Designer materials, you will need to install Allegorithmic's external importer from the Asset Store.", True)]
    [EditorBrowsable(Never)]
    public enum ProceduralLoadingBehavior
    {
        DoNothing = 0,
        Generate = 1,
        BakeAndKeep = 2,
        BakeAndDiscard = 3,
        Cache = 4,
        DoNothingAndCache = 5
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [Obsolete("Built-in support for Substance Designer materials has been removed from Unity. To continue using Substance Designer materials, you will need to install Allegorithmic's external importer from the Asset Store.", True)]
    [EditorBrowsable(Never)]
    public enum ProceduralPropertyType
    {
        Boolean = 0,
        Float = 1,
        Vector2 = 2,
        Vector3 = 3,
        Vector4 = 4,
        Color3 = 5,
        Color4 = 6,
        Enum = 7,
        Texture = 8,
        String = 9
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [EditorBrowsable(Never)]
    [Obsolete("Built-in support for Substance Designer materials has been removed from Unity. To continue using Substance Designer materials, you will need to install Allegorithmic's external importer from the Asset Store.", True)]
    public enum ProceduralOutputType
    {
        Unknown = 0,
        Diffuse = 1,
        Normal = 2,
        Height = 3,
        Emissive = 4,
        Specular = 5,
        Opacity = 6,
        Smoothness = 7,
        AmbientOcclusion = 8,
        DetailMask = 9,
        Metallic = 10,
        Roughness = 11
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [Obsolete("Built-in support for Substance Designer materials has been removed from Unity. To continue using Substance Designer materials, you will need to install Allegorithmic's external importer from the Asset Store.", True)]
    [EditorBrowsable(Never)]
    public sealed class ProceduralPropertyDescription
    {
        public string name;
        public string label;
        public string group;
        public ProceduralPropertyType type;
        public bool hasRange;
        public float minimum;
        public float maximum;
        public float step;
        public string[] enumOptions;
        public string[] componentLabels;

        public ProceduralPropertyDescription();
    }
}
using System;

namespace UnityEngine
{
    [Obsolete("Built-in support for Substance Designer materials has been removed from Unity. To continue using Substance Designer materials, you will need to install Allegorithmic's external importer from the Asset Store.", True)]
    [ExcludeFromPreset]
    public sealed class ProceduralTexture : Texture
    {
        public bool hasAlpha { get; }
        public TextureFormat format { get; }

        public ProceduralOutputType GetProceduralOutputType();
        public Color32[] GetPixels32(int x, int y, int blockWidth, int blockHeight);
    }
}
-------- {UnityEngine.SubsystemsModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.SubsystemsModule.dll)}:   26 --------
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Modules/Subsystems/Subsystem.h")]
    [UsedByNativeCode]
    public class IntegratedSubsystem : ISubsystem
    {
        public IntegratedSubsystem();

        public bool running { get; }

        public void Start();
        public void Stop();
        public void Destroy();
    }
}
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode("Subsystem_TSubsystemDescriptor")]
    public class IntegratedSubsystem<TSubsystemDescriptor> : IntegratedSubsystem where TSubsystemDescriptor : ISubsystemDescriptor
    {
        public IntegratedSubsystem();

        public TSubsystemDescriptor subsystemDescriptor { get; }
        public TSubsystemDescriptor SubsystemDescriptor { get; }
    }
}
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode("SubsystemDescriptorBase")]
    public abstract class IntegratedSubsystemDescriptor : ISubsystemDescriptorImpl, ISubsystemDescriptor
    {
        protected IntegratedSubsystemDescriptor();

        public string id { get; }
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode("SubsystemDescriptor")]
    [NativeHeader("Modules/Subsystems/SubsystemDescriptor.h")]
    public class IntegratedSubsystemDescriptor<TSubsystem> : IntegratedSubsystemDescriptor where TSubsystem : IntegratedSubsystem
    {
        public IntegratedSubsystemDescriptor();

        public TSubsystem Create();
    }
}
namespace UnityEngine
{
    public interface ISubsystem
    {
        bool running { get; }

        void Start();
        void Stop();
        void Destroy();
    }
}
namespace UnityEngine
{
    public interface ISubsystemDescriptor
    {
        string id { get; }

        ISubsystem Create();
    }
}
namespace UnityEngine
{
    public abstract class Subsystem : ISubsystem
    {
        protected Subsystem();

        public abstract bool running { get; }

        public abstract void Start();
        public abstract void Stop();
        public void Destroy();
        protected abstract void OnDestroy();
    }
}
namespace UnityEngine
{
    public abstract class Subsystem<TSubsystemDescriptor> : Subsystem where TSubsystemDescriptor : ISubsystemDescriptor
    {
        protected Subsystem();

        public TSubsystemDescriptor SubsystemDescriptor { get; }
    }
}
using System;

namespace UnityEngine
{
    public abstract class SubsystemDescriptor : ISubsystemDescriptor
    {
        protected SubsystemDescriptor();

        public string id { get; set; }
        public Type subsystemImplementationType { get; set; }
    }
}
namespace UnityEngine
{
    public class SubsystemDescriptor<TSubsystem> : SubsystemDescriptor where TSubsystem : Subsystem
    {
        public SubsystemDescriptor();

        public TSubsystem Create();
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Subsystems/SubsystemManager.h")]
    public static class SubsystemManager
    {
        public static event Action beforeReloadSubsystems;
        public static event Action afterReloadSubsystems;
        public static event Action reloadSubsytemsStarted;
        public static event Action reloadSubsytemsCompleted;

        public static void GetAllSubsystemDescriptors(List<ISubsystemDescriptor> descriptors);
        public static void GetSubsystemDescriptors<T>(List<T> descriptors) where T : ISubsystemDescriptor;
        public static void GetSubsystems<T>(List<T> subsystems) where T : ISubsystem;
        public static void GetInstances<T>(List<T> subsystems) where T : ISubsystem;
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Subsystems
{
    [NativeType(Header = "Modules/Subsystems/Example/ExampleSubsystem.h")]
    [UsedByNativeCode]
    public class ExampleSubsystem : IntegratedSubsystem<ExampleSubsystemDescriptor>
    {
        public ExampleSubsystem();

        public void PrintExample();
        public bool GetBool();
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Subsystems
{
    [NativeType(Header = "Modules/Subsystems/Example/ExampleSubsystemDescriptor.h")]
    [UsedByNativeCode]
    public class ExampleSubsystemDescriptor : IntegratedSubsystemDescriptor<ExampleSubsystem>
    {
        public ExampleSubsystemDescriptor();

        public bool supportsEditorMode { get; }
        public bool disableBackbufferMSAA { get; }
        public bool stereoscopicBackbuffer { get; }
        public bool usePBufferEGL { get; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.SubsystemsImplementation
{
    [NativeHeader("Modules/Subsystems/SubsystemManager.h")]
    public static class SubsystemDescriptorStore
    {
        public static void RegisterDescriptor(SubsystemDescriptorWithProvider descriptor);
    }
}
using System;

namespace UnityEngine.SubsystemsImplementation
{
    public abstract class SubsystemDescriptorWithProvider : ISubsystemDescriptor
    {
        protected SubsystemDescriptorWithProvider();

        public string id { get; set; }
        protected internal Type providerType { get; set; }
        protected internal Type subsystemTypeOverride { get; set; }
    }
}
namespace UnityEngine.SubsystemsImplementation
{
    public class SubsystemDescriptorWithProvider<TSubsystem, TProvider> : SubsystemDescriptorWithProvider where TSubsystem : SubsystemWithProvider, new() where TProvider : SubsystemProvider<TSubsystem>
    {
        public SubsystemDescriptorWithProvider();

        public TSubsystem Create();
    }
}
namespace UnityEngine.SubsystemsImplementation
{
    public abstract class SubsystemProvider
    {
        protected SubsystemProvider();

        public bool running { get; }
    }
}
namespace UnityEngine.SubsystemsImplementation
{
    public abstract class SubsystemProvider<TSubsystem> : SubsystemProvider where TSubsystem : SubsystemWithProvider, new()
    {
        protected SubsystemProvider();

        protected internal virtual bool TryInitialize();
        public abstract void Start();
        public abstract void Stop();
        public abstract void Destroy();
    }
}
namespace UnityEngine.SubsystemsImplementation
{
    public class SubsystemProxy<TSubsystem, TProvider> where TSubsystem : SubsystemWithProvider, new() where TProvider : SubsystemProvider<TSubsystem>
    {
        public TProvider provider { get; }
        public bool running { get; set; }
    }
}
namespace UnityEngine.SubsystemsImplementation
{
    public abstract class SubsystemWithProvider : ISubsystem
    {
        protected SubsystemWithProvider();

        public bool running { get; }

        public void Start();
        protected abstract void OnStart();
        public void Stop();
        protected abstract void OnStop();
        public void Destroy();
        protected abstract void OnDestroy();
    }
}
namespace UnityEngine.SubsystemsImplementation
{
    public abstract class SubsystemWithProvider<TSubsystem, TSubsystemDescriptor, TProvider> : SubsystemWithProvider where TSubsystem : SubsystemWithProvider, new() where TSubsystemDescriptor : SubsystemDescriptorWithProvider where TProvider : SubsystemProvider<TSubsystem>
    {
        protected SubsystemWithProvider();

        public TSubsystemDescriptor subsystemDescriptor { get; }
        protected internal TProvider provider { get; }

        protected virtual void OnCreate();
        protected override void OnStart();
        protected override void OnStop();
        protected override void OnDestroy();
    }
}
namespace UnityEngine.SubsystemsImplementation.Extensions
{
    public static class SubsystemDescriptorExtensions
    {
        public static SubsystemProxy<TSubsystem, TProvider> CreateProxy<TSubsystem, TProvider>(this SubsystemDescriptorWithProvider<TSubsystem, TProvider> descriptor) where TSubsystem : SubsystemWithProvider, new() where TProvider : SubsystemProvider<TSubsystem>;
    }
}
namespace UnityEngine.SubsystemsImplementation.Extensions
{
    public static class SubsystemExtensions
    {
        public static TProvider GetProvider<TSubsystem, TDescriptor, TProvider>(this SubsystemWithProvider<TSubsystem, TDescriptor, TProvider> subsystem) where TSubsystem : SubsystemWithProvider, new() where TDescriptor : SubsystemDescriptorWithProvider<TSubsystem, TProvider> where TProvider : SubsystemProvider<TSubsystem>;
    }
}
-------- {UnityEngine.TLSModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.TLSModule.dll)}:   10 --------
-------- {UnityEngine.TerrainModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.TerrainModule.dll)}:   47 --------
using System;

namespace UnityEngine
{
    [Flags]
    public enum TerrainChangedFlags
    {
        Heightmap = 1,
        TreeInstances = 2,
        DelayedHeightmapUpdate = 4,
        FlushEverythingImmediately = 8,
        RemoveDirtyDetailsImmediately = 16,
        HeightmapResolution = 32,
        Holes = 64,
        DelayedHolesUpdate = 128,
        WillBeDestroyed = 256
    }
}
using System;

namespace UnityEngine
{
    [Flags]
    public enum TerrainRenderFlags
    {
        [Obsolete("TerrainRenderFlags.heightmap is obsolete, use TerrainRenderFlags.Heightmap instead. (UnityUpgradable) -> Heightmap")]
        heightmap = 1,
        [Obsolete("TerrainRenderFlags.trees is obsolete, use TerrainRenderFlags.Trees instead. (UnityUpgradable) -> Trees")]
        trees = 2,
        [Obsolete("TerrainRenderFlags.details is obsolete, use TerrainRenderFlags.Details instead. (UnityUpgradable) -> Details")]
        details = 4,
        [Obsolete("TerrainRenderFlags.all is obsolete, use TerrainRenderFlags.All instead. (UnityUpgradable) -> All")]
        all = 7,
        Heightmap = 1,
        Trees = 2,
        Details = 4,
        All = 7
    }
}
using System;
using System.Collections.Generic;
using System.ComponentModel;
using UnityEngine.Bindings;
using UnityEngine.Experimental.Rendering;
using UnityEngine.Rendering;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    [NativeHeader("Modules/Terrain/Public/Terrain.h")]
    [NativeHeader("TerrainScriptingClasses.h")]
    [StaticAccessor("GetITerrainManager()", Arrow)]
    [NativeHeader("Runtime/Interfaces/ITerrainManager.h")]
    public sealed class Terrain : Behaviour
    {
        public Terrain();

        public TerrainData terrainData { get; set; }
        public float treeDistance { get; set; }
        public float treeBillboardDistance { get; set; }
        public float treeCrossFadeLength { get; set; }
        public int treeMaximumFullLODCount { get; set; }
        public float detailObjectDistance { get; set; }
        public float detailObjectDensity { get; set; }
        public float heightmapPixelError { get; set; }
        public int heightmapMaximumLOD { get; set; }
        public float basemapDistance { get; set; }
        [NativeProperty("StaticLightmapIndexInt")]
        public int lightmapIndex { get; set; }
        [NativeProperty("DynamicLightmapIndexInt")]
        public int realtimeLightmapIndex { get; set; }
        [NativeProperty("StaticLightmapST")]
        public Vector4 lightmapScaleOffset { get; set; }
        [NativeProperty("DynamicLightmapST")]
        public Vector4 realtimeLightmapScaleOffset { get; set; }
        [NativeProperty("GarbageCollectCameraData")]
        public bool freeUnusedRenderingResources { get; set; }
        public ShadowCastingMode shadowCastingMode { get; set; }
        public ReflectionProbeUsage reflectionProbeUsage { get; set; }
        public Material materialTemplate { get; set; }
        public bool drawHeightmap { get; set; }
        public bool allowAutoConnect { get; set; }
        public int groupingID { get; set; }
        public bool drawInstanced { get; set; }
        public RenderTexture normalmapTexture { get; }
        public bool drawTreesAndFoliage { get; set; }
        public Vector3 patchBoundsMultiplier { get; set; }
        public float treeLODBiasMultiplier { get; set; }
        public bool collectDetailPatches { get; set; }
        public TerrainRenderFlags editorRenderFlags { get; set; }
        public bool bakeLightProbesForTrees { get; set; }
        public bool deringLightProbesForTrees { get; set; }
        public bool preserveTreePrototypeLayers { get; set; }
        [StaticAccessor("Terrain", DoubleColon)]
        public static GraphicsFormat heightmapFormat { get; }
        public static TextureFormat heightmapTextureFormat { get; }
        public static RenderTextureFormat heightmapRenderTextureFormat { get; }
        [StaticAccessor("Terrain", DoubleColon)]
        public static GraphicsFormat normalmapFormat { get; }
        public static TextureFormat normalmapTextureFormat { get; }
        public static RenderTextureFormat normalmapRenderTextureFormat { get; }
        [StaticAccessor("Terrain", DoubleColon)]
        public static GraphicsFormat holesFormat { get; }
        public static RenderTextureFormat holesRenderTextureFormat { get; }
        [StaticAccessor("Terrain", DoubleColon)]
        public static GraphicsFormat compressedHolesFormat { get; }
        public static TextureFormat compressedHolesTextureFormat { get; }
        public static Terrain activeTerrain { get; }
        [NativeProperty("ActiveTerrainsScriptingArray")]
        public static Terrain[] activeTerrains { get; }
        public Terrain leftNeighbor { get; }
        public Terrain rightNeighbor { get; }
        public Terrain topNeighbor { get; }
        public Terrain bottomNeighbor { get; }
        public uint renderingLayerMask { get; set; }
        [Obsolete("splatmapDistance is deprecated, please use basemapDistance instead. (UnityUpgradable) -> basemapDistance", True)]
        [EditorBrowsable(Never)]
        public float splatmapDistance { get; set; }
        [Obsolete("castShadows is deprecated, please use shadowCastingMode instead.")]
        public bool castShadows { get; set; }
        [Obsolete("Property materialType is not used any more. Set materialTemplate directly.", False)]
        public MaterialType materialType { get; set; }
        [Obsolete("Property legacySpecular is not used any more. Set materialTemplate directly.", False)]
        public Color legacySpecular { get; set; }
        [Obsolete("Property legacyShininess is not used any more. Set materialTemplate directly.", False)]
        public float legacyShininess { get; set; }

        public void GetClosestReflectionProbes(List<ReflectionProbeBlendInfo> result);
        public float SampleHeight(Vector3 worldPosition);
        public void AddTreeInstance(TreeInstance instance);
        public void SetNeighbors(Terrain left, Terrain top, Terrain right, Terrain bottom);
        public Vector3 GetPosition();
        public void Flush();
        [NativeMethod("CopySplatMaterialCustomProps")]
        public void SetSplatMaterialPropertyBlock(MaterialPropertyBlock properties);
        public void GetSplatMaterialPropertyBlock(MaterialPropertyBlock dest);
        public static void SetConnectivityDirty();
        [UsedByNativeCode]
        public static GameObject CreateTerrainGameObject(TerrainData assignTerrain);
        [Obsolete("Use TerrainData.SyncHeightmap to notify all Terrain instances using the TerrainData.", False)]
        public void ApplyDelayedHeightmapModification();

        [Obsolete("Enum type MaterialType is not used any more.", False)]
        public enum MaterialType
        {
            BuiltInStandard = 0,
            BuiltInLegacyDiffuse = 1,
            BuiltInLegacySpecular = 2,
            Custom = 3
        }
    }
}
namespace UnityEngine
{
    public static class TerrainExtensions
    {
        public static void UpdateGIMaterials(this Terrain terrain);
        public static void UpdateGIMaterials(this Terrain terrain, int x, int y, int width, int height);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Terrain/Public/Tree.h")]
    [ExcludeFromPreset]
    public sealed class Tree : Component
    {
        public Tree();

        [NativeProperty("TreeData")]
        public ScriptableObject data { get; set; }
        public bool hasSpeedTreeWind { get; }
    }
}
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    public sealed class TreePrototype
    {
        public TreePrototype();
        public TreePrototype(TreePrototype other);

        public GameObject prefab { get; set; }
        public float bendFactor { get; set; }
        public int navMeshLod { get; set; }

        public override bool Equals(object obj);
        public override int GetHashCode();
    }
}
namespace UnityEngine
{
    public enum DetailRenderMode
    {
        GrassBillboard = 0,
        VertexLit = 1,
        Grass = 2
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("Modules/Terrain/Public/TerrainDataScriptingInterface.h")]
    [NativeHeader("TerrainScriptingClasses.h")]
    [UsedByNativeCode]
    public sealed class DetailPrototype
    {
        public DetailPrototype();
        public DetailPrototype(DetailPrototype other);

        public GameObject prototype { get; set; }
        public Texture2D prototypeTexture { get; set; }
        public float minWidth { get; set; }
        public float maxWidth { get; set; }
        public float minHeight { get; set; }
        public float maxHeight { get; set; }
        public float noiseSpread { get; set; }
        [Obsolete("bendFactor has no effect and is deprecated.", False)]
        public float bendFactor { get; set; }
        public float holeEdgePadding { get; set; }
        public Color healthyColor { get; set; }
        public Color dryColor { get; set; }
        public DetailRenderMode renderMode { get; set; }
        public bool usePrototypeMesh { get; set; }

        public override bool Equals(object obj);
        public override int GetHashCode();
        public bool Validate();
        public bool Validate(out string errorMessage);
    }
}
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    public sealed class SplatPrototype
    {
        public SplatPrototype();

        public Texture2D texture { get; set; }
        public Texture2D normalMap { get; set; }
        public Vector2 tileSize { get; set; }
        public Vector2 tileOffset { get; set; }
        public Color specular { get; set; }
        public float metallic { get; set; }
        public float smoothness { get; set; }
    }
}
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    public struct TreeInstance
    {
        public Vector3 position;
        public float widthScale;
        public float heightScale;
        public float rotation;
        public Color32 color;
        public Color32 lightmapColor;
        public int prototypeIndex;
    }
}
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    public struct PatchExtents
    {
        public float min { get; set; }
        public float max { get; set; }
    }
}
namespace UnityEngine
{
    public enum TerrainHeightmapSyncControl
    {
        None = 0,
        HeightOnly = 1,
        HeightAndLod = 2
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("TerrainScriptingClasses.h")]
    [NativeHeader("Modules/Terrain/Public/TerrainDataScriptingInterface.h")]
    [UsedByNativeCode]
    public sealed class TerrainData : Object
    {
        public TerrainData();

        [Obsolete("Please use heightmapResolution instead. (UnityUpgradable) -> heightmapResolution", False)]
        public int heightmapWidth { get; }
        [Obsolete("Please use heightmapResolution instead. (UnityUpgradable) -> heightmapResolution", False)]
        public int heightmapHeight { get; }
        public RenderTexture heightmapTexture { get; }
        public int heightmapResolution { get; set; }
        public Vector3 heightmapScale { get; }
        public Texture holesTexture { get; }
        public bool enableHolesTextureCompression { get; set; }
        public int holesResolution { get; }
        public Vector3 size { get; set; }
        public Bounds bounds { get; }
        [Obsolete("Terrain thickness is no longer required by the physics engine. Set appropriate continuous collision detection modes to fast moving bodies.")]
        public float thickness { get; set; }
        public float wavingGrassStrength { get; set; }
        public float wavingGrassAmount { get; set; }
        public float wavingGrassSpeed { get; set; }
        public Color wavingGrassTint { get; set; }
        public int detailWidth { get; }
        public int detailHeight { get; }
        public int detailPatchCount { get; }
        public int detailResolution { get; }
        public int detailResolutionPerPatch { get; }
        public DetailPrototype[] detailPrototypes { get; set; }
        public TreeInstance[] treeInstances { get; set; }
        public int treeInstanceCount { get; }
        public TreePrototype[] treePrototypes { get; set; }
        public int alphamapLayers { get; }
        public int alphamapResolution { get; set; }
        public int alphamapWidth { get; }
        public int alphamapHeight { get; }
        public int baseMapResolution { get; set; }
        public int alphamapTextureCount { get; }
        public Texture2D[] alphamapTextures { get; }
        [Obsolete("Please use the terrainLayers API instead.", False)]
        public SplatPrototype[] splatPrototypes { get; set; }
        public TerrainLayer[] terrainLayers { get; set; }
        public static string AlphamapTextureName { get; }
        public static string HolesTextureName { get; }

        [Obsolete("Please use DirtyHeightmapRegion instead.", False)]
        public void UpdateDirtyRegion(int x, int y, int width, int height, bool syncHeightmapTextureImmediately);
        [NativeName("GetHeightmap().GetHeight")]
        public float GetHeight(int x, int y);
        [NativeName("GetHeightmap().GetInterpolatedHeight")]
        public float GetInterpolatedHeight(float x, float y);
        public float[] GetInterpolatedHeights(float xBase, float yBase, int xCount, int yCount, float xInterval, float yInterval);
        public void GetInterpolatedHeights(float[] results, int resultXOffset, int resultYOffset, float xBase, float yBase, int xCount, int yCount, float xInterval, float yInterval);
        public float[] GetHeights(int xBase, int yBase, int width, int height);
        public void SetHeights(int xBase, int yBase, float[] heights);
        [FreeFunction("TerrainDataScriptingInterface::GetPatchMinMaxHeights", HasExplicitThis = True)]
        public PatchExtents[] GetPatchMinMaxHeights();
        [FreeFunction("TerrainDataScriptingInterface::OverrideMinMaxPatchHeights", HasExplicitThis = True)]
        public void OverrideMinMaxPatchHeights(PatchExtents[] minMaxHeights);
        [FreeFunction("TerrainDataScriptingInterface::GetMaximumHeightError", HasExplicitThis = True)]
        public float[] GetMaximumHeightError();
        [FreeFunction("TerrainDataScriptingInterface::OverrideMaximumHeightError", HasExplicitThis = True)]
        public void OverrideMaximumHeightError(float[] maxError);
        public void SetHeightsDelayLOD(int xBase, int yBase, float[] heights);
        public bool IsHole(int x, int y);
        public bool[] GetHoles(int xBase, int yBase, int width, int height);
        public void SetHoles(int xBase, int yBase, bool[] holes);
        public void SetHolesDelayLOD(int xBase, int yBase, bool[] holes);
        [NativeName("GetHeightmap().GetSteepness")]
        public float GetSteepness(float x, float y);
        [NativeName("GetHeightmap().GetInterpolatedNormal")]
        public Vector3 GetInterpolatedNormal(float x, float y);
        public void SetDetailResolution(int detailResolution, int resolutionPerPatch);
        [FreeFunction("TerrainDataScriptingInterface::RefreshPrototypes", HasExplicitThis = True)]
        public void RefreshPrototypes();
        [FreeFunction("TerrainDataScriptingInterface::GetSupportedLayers", HasExplicitThis = True)]
        public int[] GetSupportedLayers(int xBase, int yBase, int totalWidth, int totalHeight);
        [FreeFunction("TerrainDataScriptingInterface::GetDetailLayer", HasExplicitThis = True)]
        public int[] GetDetailLayer(int xBase, int yBase, int width, int height, int layer);
        public void SetDetailLayer(int xBase, int yBase, int layer, int[] details);
        [FreeFunction("TerrainDataScriptingInterface::GetClampedDetailPatches", HasExplicitThis = True)]
        public Vector2Int[] GetClampedDetailPatches(float density);
        [FreeFunction("TerrainDataScriptingInterface::SetTreeInstances", HasExplicitThis = True)]
        public void SetTreeInstances([NotNull("ArgumentNullException")] TreeInstance[] instances, bool snapToHeightmap);
        public TreeInstance GetTreeInstance(int index);
        [NativeThrows]
        [FreeFunction("TerrainDataScriptingInterface::SetTreeInstance", HasExplicitThis = True)]
        public void SetTreeInstance(int index, TreeInstance instance);
        public float[] GetAlphamaps(int x, int y, int width, int height);
        public void SetAlphamaps(int x, int y, float[] map);
        [NativeName("GetSplatDatabase().SetBaseMapsDirty")]
        public void SetBaseMapDirty();
        [NativeName("GetSplatDatabase().GetAlphaTexture")]
        public Texture2D GetAlphamapTexture(int index);
        public void SetTerrainLayersRegisterUndo(TerrainLayer[] terrainLayers, string undoName);
        [NativeName("GetHeightmap().SyncHeightmapGPUModifications")]
        public void SyncHeightmap();
        public void CopyActiveRenderTextureToHeightmap(RectInt sourceRect, Vector2Int dest, TerrainHeightmapSyncControl syncControl);
        public void DirtyHeightmapRegion(RectInt region, TerrainHeightmapSyncControl syncControl);
        public void CopyActiveRenderTextureToTexture(string textureName, int textureIndex, RectInt sourceRect, Vector2Int dest, bool allowDelayedCPUSync);
        public void DirtyTextureRegion(string textureName, RectInt region, bool allowDelayedCPUSync);
        public void SyncTexture(string textureName);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [NativeHeader("TerrainScriptingClasses.h")]
    [NativeHeader("Modules/Terrain/Public/TerrainLayerScriptingInterface.h")]
    [UsedByNativeCode]
    public sealed class TerrainLayer : Object
    {
        public TerrainLayer();

        public Texture2D diffuseTexture { get; set; }
        public Texture2D normalMapTexture { get; set; }
        public Texture2D maskMapTexture { get; set; }
        public Vector2 tileSize { get; set; }
        public Vector2 tileOffset { get; set; }
        [NativeProperty("SpecularColor")]
        public Color specular { get; set; }
        public float metallic { get; set; }
        public float smoothness { get; set; }
        public float normalScale { get; set; }
        public Vector4 diffuseRemapMin { get; set; }
        public Vector4 diffuseRemapMax { get; set; }
        public Vector4 maskMapRemapMin { get; set; }
        public Vector4 maskMapRemapMax { get; set; }
    }
}
namespace UnityEngine.Experimental.TerrainAPI
{
    public struct BrushTransform
    {
        public BrushTransform(Vector2 brushOrigin, Vector2 brushU, Vector2 brushV);

        public Vector2 brushOrigin { get; }
        public Vector2 brushU { get; }
        public Vector2 brushV { get; }
        public Vector2 targetOrigin { get; }
        public Vector2 targetX { get; }
        public Vector2 targetY { get; }

        public Rect GetBrushXYBounds();
        public static BrushTransform FromRect(Rect brushRect);
        public Vector2 ToBrushUV(Vector2 targetXY);
        public Vector2 FromBrushUV(Vector2 brushUV);
    }
}
using System;

namespace UnityEngine.Experimental.TerrainAPI
{
    public class PaintContext
    {
        public PaintContext(Terrain terrain, RectInt pixelRect, int targetTextureWidth, int targetTextureHeight, bool texelPadding = True);

        public Terrain originTerrain { get; }
        public RectInt pixelRect { get; }
        public int targetTextureWidth { get; }
        public int targetTextureHeight { get; }
        public Vector2 pixelSize { get; }
        public RenderTexture sourceRenderTexture { get; }
        public RenderTexture destinationRenderTexture { get; }
        public RenderTexture oldRenderTexture { get; }
        public int terrainCount { get; }
        public float heightWorldSpaceMin { get; }
        public float heightWorldSpaceSize { get; }
        public static float kNormalizedHeightScale { get; }

        public Terrain GetTerrain(int terrainIndex);
        public RectInt GetClippedPixelRectInTerrainPixels(int terrainIndex);
        public RectInt GetClippedPixelRectInRenderTexturePixels(int terrainIndex);
        public static PaintContext CreateFromBounds(Terrain terrain, Rect boundsInTerrainSpace, int inputTextureWidth, int inputTextureHeight, int extraBorderPixels = 0, bool texelPadding = True);
        public void CreateRenderTargets(RenderTextureFormat colorFormat);
        public void Cleanup(bool restoreRenderTexture = True);
        public void Gather(Func<ITerrainInfo, Texture> terrainSource, Color defaultColor, Material blitMaterial = null, int blitPass = 0, Action<ITerrainInfo> beforeBlit = null, Action<ITerrainInfo> afterBlit = null);
        public void Scatter(Func<ITerrainInfo, RenderTexture> terrainDest, Material blitMaterial = null, int blitPass = 0, Action<ITerrainInfo> beforeBlit = null, Action<ITerrainInfo> afterBlit = null);
        public void GatherHeightmap();
        public void ScatterHeightmap(string editorUndoName);
        public void GatherHoles();
        public void ScatterHoles(string editorUndoName);
        public void GatherNormals();
        public void GatherAlphamap(TerrainLayer inputLayer, bool addLayerIfDoesntExist = True);
        public void ScatterAlphamap(string editorUndoName);
        public static void ApplyDelayedActions();

        public interface ITerrainInfo
        {
            Terrain terrain { get; }
            RectInt clippedTerrainPixels { get; }
            RectInt clippedPCPixels { get; }
            bool gatherEnable { get; set; }
            bool scatterEnable { get; set; }
            object userData { get; set; }
        }
    }
}
namespace UnityEngine.Experimental.TerrainAPI
{
    public static class TerrainCallbacks
    {
        public static event HeightmapChangedCallback heightmapChanged;
        public static event TextureChangedCallback textureChanged;

        public delegate void HeightmapChangedCallback(Terrain terrain, RectInt heightRegion, bool synched);
        public delegate void TextureChangedCallback(Terrain terrain, string textureName, RectInt texelRegion, bool synched);
    }
}
namespace UnityEngine.Experimental.TerrainAPI
{
    public static class TerrainPaintUtility
    {
        public static Material GetBuiltinPaintMaterial();
        public static void GetBrushWorldSizeLimits(out float minBrushWorldSize, out float maxBrushWorldSize, float terrainTileWorldSize, int terrainTileTextureResolutionPixels, int minBrushResolutionPixels = 1, int maxBrushResolutionPixels = 8192);
        public static BrushTransform CalculateBrushTransform(Terrain terrain, Vector2 brushCenterTerrainUV, float brushSize, float brushRotationDegrees);
        public static void BuildTransformPaintContextUVToPaintContextUV(PaintContext src, PaintContext dst, out Vector4 scaleOffset);
        public static void SetupTerrainToolMaterialProperties(PaintContext paintContext, BrushTransform brushXform, Material material);
        public static void ReleaseContextResources(PaintContext ctx);
        public static PaintContext BeginPaintHeightmap(Terrain terrain, Rect boundsInTerrainSpace, int extraBorderPixels = 0);
        public static void EndPaintHeightmap(PaintContext ctx, string editorUndoName);
        public static PaintContext BeginPaintHoles(Terrain terrain, Rect boundsInTerrainSpace, int extraBorderPixels = 0);
        public static void EndPaintHoles(PaintContext ctx, string editorUndoName);
        public static PaintContext CollectNormals(Terrain terrain, Rect boundsInTerrainSpace, int extraBorderPixels = 0);
        public static PaintContext BeginPaintTexture(Terrain terrain, Rect boundsInTerrainSpace, TerrainLayer inputLayer, int extraBorderPixels = 0);
        public static void EndPaintTexture(PaintContext ctx, string editorUndoName);
        public static Material GetBlitMaterial();
        public static Material GetHeightBlitMaterial();
        public static Material GetCopyTerrainLayerMaterial();
        public static Texture2D GetTerrainAlphaMapChecked(Terrain terrain, int mapIndex);
        public static int FindTerrainLayerIndex(Terrain terrain, TerrainLayer inputLayer);

        public enum BuiltinPaintMaterialPasses
        {
            RaiseLowerHeight = 0,
            StampHeight = 1,
            SetHeights = 2,
            SmoothHeights = 3,
            PaintTexture = 4,
            PaintHoles = 5
        }
    }
}
using System.Collections.Generic;
using UnityEngine.Scripting;

namespace UnityEngine.Experimental.TerrainAPI
{
    public static class TerrainUtility
    {
        [RequiredByNativeCode]
        public static void AutoConnect();

        public class TerrainMap
        {
            public ErrorCode m_errorCode;
            public Dictionary<TileCoord, Terrain> m_terrainTiles;

            public TerrainMap();

            public Terrain GetTerrain(int tileX, int tileZ);
            public static TerrainMap CreateFromConnectedNeighbors(Terrain originTerrain, TerrainFilter filter = null, bool fullValidation = True);
            public static TerrainMap CreateFromPlacement(Terrain originTerrain, TerrainFilter filter = null, bool fullValidation = True);
            public static TerrainMap CreateFromPlacement(Vector2 gridOrigin, Vector2 gridSize, TerrainFilter filter = null, bool fullValidation = True);

            public delegate bool TerrainFilter(Terrain terrain);
            public struct TileCoord
            {
                public readonly int tileX;
                public readonly int tileZ;

                public TileCoord(int tileX, int tileZ);
            }
            public enum ErrorCode
            {
                OK = 0,
                Overlapping = 1,
                SizeMismatch = 4,
                EdgeAlignmentMismatch = 8
            }
        }
        public class TerrainGroups : Dictionary<int, TerrainMap>
        {
            public TerrainGroups();
        }
    }
}
-------- {UnityEngine.TerrainPhysicsModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.TerrainPhysicsModule.dll)}:    0 --------
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Terrain/Public/TerrainData.h")]
    [NativeHeader("Modules/TerrainPhysics/TerrainCollider.h")]
    public class TerrainCollider : Collider
    {
        public TerrainCollider();

        public TerrainData terrainData { get; set; }
    }
}
-------- {UnityEngine.TextCoreModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.TextCoreModule.dll)}:   80 --------
using UnityEngine.Scripting;

namespace UnityEngine.TextCore
{
    [UsedByNativeCode]
    public struct FaceInfo
    {
        public string familyName { get; set; }
        public string styleName { get; set; }
        public int pointSize { get; set; }
        public float scale { get; set; }
        public float lineHeight { get; set; }
        public float ascentLine { get; set; }
        public float capLine { get; set; }
        public float meanLine { get; set; }
        public float baseline { get; set; }
        public float descentLine { get; set; }
        public float superscriptOffset { get; set; }
        public float superscriptSize { get; set; }
        public float subscriptOffset { get; set; }
        public float subscriptSize { get; set; }
        public float underlineOffset { get; set; }
        public float underlineThickness { get; set; }
        public float strikethroughOffset { get; set; }
        public float strikethroughThickness { get; set; }
        public float tabWidth { get; set; }

        public bool Compare(FaceInfo other);
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine.TextCore
{
    [UsedByNativeCode]
    public struct GlyphRect : IEquatable<GlyphRect>
    {
        public GlyphRect(int x, int y, int width, int height);
        public GlyphRect(Rect rect);

        public int x { get; set; }
        public int y { get; set; }
        public int width { get; set; }
        public int height { get; set; }
        public static GlyphRect zero { get; }

        public override int GetHashCode();
        public override bool Equals(object obj);
        public bool Equals(GlyphRect other);

        public static bool operator ==(GlyphRect lhs, GlyphRect rhs);
        public static bool operator !=(GlyphRect lhs, GlyphRect rhs);
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine.TextCore
{
    [UsedByNativeCode]
    public struct GlyphMetrics : IEquatable<GlyphMetrics>
    {
        public GlyphMetrics(float width, float height, float bearingX, float bearingY, float advance);

        public float width { get; set; }
        public float height { get; set; }
        public float horizontalBearingX { get; set; }
        public float horizontalBearingY { get; set; }
        public float horizontalAdvance { get; set; }

        public override int GetHashCode();
        public override bool Equals(object obj);
        public bool Equals(GlyphMetrics other);

        public static bool operator ==(GlyphMetrics lhs, GlyphMetrics rhs);
        public static bool operator !=(GlyphMetrics lhs, GlyphMetrics rhs);
    }
}
using UnityEngine.Scripting;

namespace UnityEngine.TextCore
{
    [UsedByNativeCode]
    public class Glyph
    {
        public Glyph();
        public Glyph(Glyph glyph);
        public Glyph(uint index, GlyphMetrics metrics, GlyphRect glyphRect);
        public Glyph(uint index, GlyphMetrics metrics, GlyphRect glyphRect, float scale, int atlasIndex);

        public uint index { get; set; }
        public GlyphMetrics metrics { get; set; }
        public GlyphRect glyphRect { get; set; }
        public float scale { get; set; }
        public int atlasIndex { get; set; }

        public bool Compare(Glyph other);
    }
}
using System;

namespace UnityEngine.TextCore.LowLevel
{
    [Flags]
    public enum FontFeatureLookupFlags
    {
        None = 0,
        IgnoreLigatures = 4,
        IgnoreSpacingAdjustments = 256
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine.TextCore.LowLevel
{
    [UsedByNativeCode]
    public struct GlyphValueRecord : IEquatable<GlyphValueRecord>
    {
        public GlyphValueRecord(float xPlacement, float yPlacement, float xAdvance, float yAdvance);

        public float xPlacement { get; set; }
        public float yPlacement { get; set; }
        public float xAdvance { get; set; }
        public float yAdvance { get; set; }

        public override int GetHashCode();
        public override bool Equals(object obj);
        public bool Equals(GlyphValueRecord other);

        public static GlyphValueRecord operator +(GlyphValueRecord a, GlyphValueRecord b);
        public static bool operator ==(GlyphValueRecord lhs, GlyphValueRecord rhs);
        public static bool operator !=(GlyphValueRecord lhs, GlyphValueRecord rhs);
    }
}
using UnityEngine.Scripting;

namespace UnityEngine.TextCore.LowLevel
{
    [UsedByNativeCode]
    public struct GlyphAdjustmentRecord
    {
        public GlyphAdjustmentRecord(uint glyphIndex, GlyphValueRecord glyphValueRecord);

        public uint glyphIndex { get; set; }
        public GlyphValueRecord glyphValueRecord { get; set; }
    }
}
using System.Diagnostics;
using UnityEngine.Scripting;

namespace UnityEngine.TextCore.LowLevel
{
    [DebuggerDisplay("First glyphIndex = {m_FirstAdjustmentRecord.m_GlyphIndex},  Second glyphIndex = {m_SecondAdjustmentRecord.m_GlyphIndex}")]
    [UsedByNativeCode]
    public struct GlyphPairAdjustmentRecord
    {
        public GlyphPairAdjustmentRecord(GlyphAdjustmentRecord firstAdjustmentRecord, GlyphAdjustmentRecord secondAdjustmentRecord);

        public GlyphAdjustmentRecord firstAdjustmentRecord { get; set; }
        public GlyphAdjustmentRecord secondAdjustmentRecord { get; set; }
        public FontFeatureLookupFlags featureLookupFlags { get; set; }
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine.TextCore.LowLevel
{
    [Flags]
    [UsedByNativeCode]
    public enum GlyphLoadFlags
    {
        LOAD_DEFAULT = 0,
        LOAD_NO_SCALE = 1,
        LOAD_NO_HINTING = 2,
        LOAD_RENDER = 4,
        LOAD_NO_BITMAP = 8,
        LOAD_FORCE_AUTOHINT = 32,
        LOAD_MONOCHROME = 4096,
        LOAD_NO_AUTOHINT = 32768,
        LOAD_COMPUTE_METRICS = 2097152,
        LOAD_BITMAP_METRICS_ONLY = 4194304
    }
}
namespace UnityEngine.TextCore.LowLevel
{
    public enum FontEngineError
    {
        Success = 0,
        Invalid_File_Path = 1,
        Invalid_File_Format = 2,
        Invalid_File_Structure = 3,
        Invalid_File = 4,
        Invalid_Table = 8,
        Invalid_Glyph_Index = 16,
        Invalid_Character_Code = 17,
        Invalid_Pixel_Size = 23,
        Invalid_Library = 33,
        Invalid_Face = 35,
        Invalid_Library_or_Face = 41,
        Atlas_Generation_Cancelled = 100,
        Invalid_SharedTextureData = 101
    }
}
using UnityEngine.Scripting;

namespace UnityEngine.TextCore.LowLevel
{
    [UsedByNativeCode]
    public enum GlyphRenderMode
    {
        SMOOTH_HINTED = 4121,
        SMOOTH = 4117,
        RASTER_HINTED = 4122,
        RASTER = 4118,
        SDF = 4134,
        SDF8 = 8230,
        SDF16 = 16422,
        SDF32 = 32806,
        SDFAA_HINTED = 4169,
        SDFAA = 4165
    }
}
using UnityEngine.Scripting;

namespace UnityEngine.TextCore.LowLevel
{
    [UsedByNativeCode]
    public enum GlyphPackingMode
    {
        BestShortSideFit = 0,
        BestLongSideFit = 1,
        BestAreaFit = 2,
        BottomLeftRule = 3,
        ContactPointRule = 4
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.TextCore.LowLevel
{
    [NativeHeader("Modules/TextCore/Native/FontEngine/FontEngine.h")]
    public sealed class FontEngine
    {
        public static FontEngineError InitializeFontEngine();
        public static FontEngineError DestroyFontEngine();
        public static FontEngineError LoadFontFace(string filePath);
        public static FontEngineError LoadFontFace(string filePath, int pointSize);
        public static FontEngineError LoadFontFace(string filePath, int pointSize, int faceIndex);
        public static FontEngineError LoadFontFace(byte[] sourceFontFile);
        public static FontEngineError LoadFontFace(byte[] sourceFontFile, int pointSize);
        public static FontEngineError LoadFontFace(byte[] sourceFontFile, int pointSize, int faceIndex);
        public static FontEngineError LoadFontFace(Font font);
        public static FontEngineError LoadFontFace(Font font, int pointSize);
        public static FontEngineError LoadFontFace(Font font, int pointSize, int faceIndex);
        public static FontEngineError LoadFontFace(string familyName, string styleName);
        public static FontEngineError LoadFontFace(string familyName, string styleName, int pointSize);
        public static FontEngineError UnloadFontFace();
        public static FontEngineError UnloadAllFontFaces();
        public static string[] GetSystemFontNames();
        public static FontEngineError SetFaceSize(int pointSize);
        public static FaceInfo GetFaceInfo();
        public static string[] GetFontFaces();
        [NativeMethod(Name = "TextCore::FontEngine::TryGetGlyphIndex", IsThreadSafe = True, IsFreeFunction = True)]
        public static bool TryGetGlyphIndex(uint unicode, out uint glyphIndex);
        public static bool TryGetGlyphWithUnicodeValue(uint unicode, GlyphLoadFlags flags, out Glyph glyph);
        public static bool TryGetGlyphWithIndexValue(uint glyphIndex, GlyphLoadFlags flags, out Glyph glyph);
    }
}
-------- {UnityEngine.TextRenderingModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.TextRenderingModule.dll)}:   15 --------
namespace UnityEngine
{
    public enum FontStyle
    {
        Normal = 0,
        Bold = 1,
        Italic = 2,
        BoldAndItalic = 3
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine
{
    [ExcludeFromObjectFactory]
    [EditorBrowsable(Never)]
    [ExcludeFromPreset]
    [Obsolete("GUIText has been removed. Use UI.Text instead.", True)]
    public sealed class GUIText
    {
        public GUIText();

        [Obsolete("GUIText has been removed. Use UI.Text instead.", True)]
        public bool text { get; set; }
        [Obsolete("GUIText has been removed. Use UI.Text instead.", True)]
        public Material material { get; set; }
        [Obsolete("GUIText has been removed. Use UI.Text instead.", True)]
        public Font font { get; set; }
        [Obsolete("GUIText has been removed. Use UI.Text instead.", True)]
        public TextAlignment alignment { get; set; }
        [Obsolete("GUIText has been removed. Use UI.Text instead.", True)]
        public TextAnchor anchor { get; set; }
        [Obsolete("GUIText has been removed. Use UI.Text instead.", True)]
        public float lineSpacing { get; set; }
        [Obsolete("GUIText has been removed. Use UI.Text instead.", True)]
        public float tabSize { get; set; }
        [Obsolete("GUIText has been removed. Use UI.Text instead.", True)]
        public int fontSize { get; set; }
        [Obsolete("GUIText has been removed. Use UI.Text instead.", True)]
        public FontStyle fontStyle { get; set; }
        [Obsolete("GUIText has been removed. Use UI.Text instead.", True)]
        public bool richText { get; set; }
        [Obsolete("GUIText has been removed. Use UI.Text instead.", True)]
        public Color color { get; set; }
        [Obsolete("GUIText has been removed. Use UI.Text instead.", True)]
        public Vector2 pixelOffset { get; set; }
    }
}
namespace UnityEngine
{
    public struct TextGenerationSettings
    {
        public Font font;
        public Color color;
        public int fontSize;
        public float lineSpacing;
        public bool richText;
        public float scaleFactor;
        public FontStyle fontStyle;
        public TextAnchor textAnchor;
        public bool alignByGeometry;
        public bool resizeTextForBestFit;
        public int resizeTextMinSize;
        public int resizeTextMaxSize;
        public bool updateBounds;
        public VerticalWrapMode verticalOverflow;
        public HorizontalWrapMode horizontalOverflow;
        public Vector2 generationExtents;
        public Vector2 pivot;
        public bool generateOutOfBounds;

        public bool Equals(TextGenerationSettings other);
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    [NativeHeader("Modules/TextRendering/TextGenerator.h")]
    public sealed class TextGenerator : IDisposable
    {
        public TextGenerator();
        public TextGenerator(int initialCapacity);

        ~TextGenerator();

        public int characterCountVisible { get; }
        public IList<UIVertex> verts { get; }
        public IList<UICharInfo> characters { get; }
        public IList<UILineInfo> lines { get; }
        public Rect rectExtents { get; }
        public int vertexCount { get; }
        public int characterCount { get; }
        public int lineCount { get; }
        [NativeProperty("FontSizeFoundForBestFit", False, Function)]
        public int fontSizeUsedForBestFit { get; }

        public void Invalidate();
        public void GetCharacters(List<UICharInfo> characters);
        public void GetLines(List<UILineInfo> lines);
        public void GetVertices(List<UIVertex> vertices);
        public float GetPreferredWidth(string str, TextGenerationSettings settings);
        public float GetPreferredHeight(string str, TextGenerationSettings settings);
        public bool PopulateWithErrors(string str, TextGenerationSettings settings, GameObject context);
        public bool Populate(string str, TextGenerationSettings settings);
        public UIVertex[] GetVerticesArray();
        public UICharInfo[] GetCharactersArray();
        public UILineInfo[] GetLinesArray();
    }
}
namespace UnityEngine
{
    public enum TextAlignment
    {
        Left = 0,
        Center = 1,
        Right = 2
    }
}
namespace UnityEngine
{
    public enum TextAnchor
    {
        UpperLeft = 0,
        UpperCenter = 1,
        UpperRight = 2,
        MiddleLeft = 3,
        MiddleCenter = 4,
        MiddleRight = 5,
        LowerLeft = 6,
        LowerCenter = 7,
        LowerRight = 8
    }
}
namespace UnityEngine
{
    public enum HorizontalWrapMode
    {
        Wrap = 0,
        Overflow = 1
    }
}
namespace UnityEngine
{
    public enum VerticalWrapMode
    {
        Truncate = 0,
        Overflow = 1
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/TextRendering/Public/TextMesh.h")]
    [NativeClass("TextRenderingPrivate::TextMesh")]
    [RequireComponent(typeof(Transform), typeof(MeshRenderer))]
    public sealed class TextMesh : Component
    {
        public TextMesh();

        public string text { get; set; }
        public Font font { get; set; }
        public int fontSize { get; set; }
        public FontStyle fontStyle { get; set; }
        public float offsetZ { get; set; }
        public TextAlignment alignment { get; set; }
        public TextAnchor anchor { get; set; }
        public float characterSize { get; set; }
        public float lineSpacing { get; set; }
        public float tabSize { get; set; }
        public bool richText { get; set; }
        public Color color { get; set; }
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    public struct CharacterInfo
    {
        public int index;
        [Obsolete("CharacterInfo.uv is deprecated. Use uvBottomLeft, uvBottomRight, uvTopRight or uvTopLeft instead.")]
        public Rect uv;
        [Obsolete("CharacterInfo.vert is deprecated. Use minX, maxX, minY, maxY instead.")]
        public Rect vert;
        [Obsolete("CharacterInfo.width is deprecated. Use advance instead.")]
        [NativeName("advance")]
        public float width;
        public int size;
        public FontStyle style;
        [Obsolete("CharacterInfo.flipped is deprecated. Use uvBottomLeft, uvBottomRight, uvTopRight or uvTopLeft instead, which will be correct regardless of orientation.")]
        public bool flipped;

        public int advance { get; set; }
        public int glyphWidth { get; set; }
        public int glyphHeight { get; set; }
        public int bearing { get; set; }
        public int minY { get; set; }
        public int maxY { get; set; }
        public int minX { get; set; }
        public int maxX { get; set; }
        public Vector2 uvBottomLeft { get; set; }
        public Vector2 uvBottomRight { get; set; }
        public Vector2 uvTopRight { get; set; }
        public Vector2 uvTopLeft { get; set; }
    }
}
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    public struct UICharInfo
    {
        public Vector2 cursorPos;
        public float charWidth;
    }
}
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    public struct UILineInfo
    {
        public int startCharIdx;
        public int height;
        public float topY;
        public float leading;
    }
}
using UnityEngine.Scripting;

namespace UnityEngine
{
    [UsedByNativeCode]
    public struct UIVertex
    {
        public Vector3 position;
        public Vector3 normal;
        public Vector4 tangent;
        public Color32 color;
        public Vector4 uv0;
        public Vector4 uv1;
        public Vector4 uv2;
        public Vector4 uv3;
        public static UIVertex simpleVert;
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Internal;

namespace UnityEngine
{
    [NativeHeader("Modules/TextRendering/Public/Font.h")]
    [NativeClass("TextRendering::Font")]
    [NativeHeader("Modules/TextRendering/Public/FontImpl.h")]
    [StaticAccessor("TextRenderingPrivate", DoubleColon)]
    public sealed class Font : Object
    {
        public Font();
        public Font(string name);

        public Material material { get; set; }
        public string[] fontNames { get; set; }
        public bool dynamic { get; }
        public int ascent { get; }
        public int fontSize { get; }
        public CharacterInfo[] characterInfo { get; set; }
        [NativeProperty("LineSpacing", False, Function)]
        public int lineHeight { get; }
        [Obsolete("Font.textureRebuildCallback has been deprecated. Use Font.textureRebuilt instead.")]
        public FontTextureRebuildCallback textureRebuildCallback { get; set; }

        public static event Action<Font> textureRebuilt;

        public static Font CreateDynamicFontFromOSFont(string fontname, int size);
        public static Font CreateDynamicFontFromOSFont(string[] fontnames, int size);
        public static int GetMaxVertsForString(string str);
        public bool HasCharacter(char c);
        public static string[] GetOSInstalledFontNames();
        public static string[] GetPathsToOSFonts();
        [FreeFunction("TextRenderingPrivate::GetCharacterInfo", HasExplicitThis = True)]
        public bool GetCharacterInfo(char ch, out CharacterInfo info, [DefaultValue("0")] int size, [DefaultValue("FontStyle.Normal")] FontStyle style);
        [ExcludeFromDocs]
        public bool GetCharacterInfo(char ch, out CharacterInfo info, int size);
        [ExcludeFromDocs]
        public bool GetCharacterInfo(char ch, out CharacterInfo info);
        public void RequestCharactersInTexture(string characters, [DefaultValue("0")] int size, [DefaultValue("FontStyle.Normal")] FontStyle style);
        [ExcludeFromDocs]
        public void RequestCharactersInTexture(string characters, int size);
        [ExcludeFromDocs]
        public void RequestCharactersInTexture(string characters);

        public delegate void FontTextureRebuildCallback();
    }
}
-------- {UnityEngine.TilemapModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.TilemapModule.dll)}:   19 --------
using System;

namespace UnityEngine
{
    [AttributeUsage(Class)]
    public class CustomGridBrushAttribute : Attribute
    {
        public CustomGridBrushAttribute();
        public CustomGridBrushAttribute(bool hideAssetInstances, bool hideDefaultInstance, bool defaultBrush, string defaultName);

        public bool hideAssetInstances { get; }
        public bool hideDefaultInstance { get; }
        public bool defaultBrush { get; }
        public string defaultName { get; }
    }
}
namespace UnityEngine
{
    public abstract class GridBrushBase : ScriptableObject
    {
        protected GridBrushBase();

        public virtual void Paint(GridLayout gridLayout, GameObject brushTarget, Vector3Int position);
        public virtual void Erase(GridLayout gridLayout, GameObject brushTarget, Vector3Int position);
        public virtual void BoxFill(GridLayout gridLayout, GameObject brushTarget, BoundsInt position);
        public virtual void BoxErase(GridLayout gridLayout, GameObject brushTarget, BoundsInt position);
        public virtual void Select(GridLayout gridLayout, GameObject brushTarget, BoundsInt position);
        public virtual void FloodFill(GridLayout gridLayout, GameObject brushTarget, Vector3Int position);
        public virtual void Rotate(RotationDirection direction, GridLayout.CellLayout layout);
        public virtual void Flip(FlipAxis flip, GridLayout.CellLayout layout);
        public virtual void Pick(GridLayout gridLayout, GameObject brushTarget, BoundsInt position, Vector3Int pivot);
        public virtual void Move(GridLayout gridLayout, GameObject brushTarget, BoundsInt from, BoundsInt to);
        public virtual void MoveStart(GridLayout gridLayout, GameObject brushTarget, BoundsInt position);
        public virtual void MoveEnd(GridLayout gridLayout, GameObject brushTarget, BoundsInt position);
        public virtual void ChangeZPosition(int change);
        public virtual void ResetZPosition();

        public enum Tool
        {
            Select = 0,
            Move = 1,
            Paint = 2,
            Box = 3,
            Pick = 4,
            Erase = 5,
            FloodFill = 6
        }
        public enum RotationDirection
        {
            Clockwise = 0,
            CounterClockwise = 1
        }
        public enum FlipAxis
        {
            X = 0,
            Y = 1
        }
    }
}
using UnityEngine.Scripting;

namespace UnityEngine.Tilemaps
{
    [RequiredByNativeCode]
    public class ITilemap
    {
        public Vector3Int origin { get; }
        public Vector3Int size { get; }
        public Bounds localBounds { get; }
        public BoundsInt cellBounds { get; }

        public virtual Sprite GetSprite(Vector3Int position);
        public virtual Color GetColor(Vector3Int position);
        public virtual Matrix4x4 GetTransformMatrix(Vector3Int position);
        public virtual TileFlags GetTileFlags(Vector3Int position);
        public virtual TileBase GetTile(Vector3Int position);
        public virtual T GetTile<T>(Vector3Int position) where T : TileBase;
        public void RefreshTile(Vector3Int position);
        public T GetComponent<T>();
    }
}
using UnityEngine.Scripting;

namespace UnityEngine.Tilemaps
{
    [RequiredByNativeCode]
    [HelpURL("https://docs.unity3d.com/Manual/Tilemap-TileAsset.html")]
    public class Tile : TileBase
    {
        public Tile();

        public Sprite sprite { get; set; }
        public Color color { get; set; }
        public Matrix4x4 transform { get; set; }
        public GameObject gameObject { get; set; }
        public TileFlags flags { get; set; }
        public ColliderType colliderType { get; set; }

        public override void GetTileData(Vector3Int position, ITilemap tilemap, ref TileData tileData);

        public enum ColliderType
        {
            None = 0,
            Sprite = 1,
            Grid = 2
        }
    }
}
using UnityEngine.Scripting;

namespace UnityEngine.Tilemaps
{
    [RequiredByNativeCode]
    public abstract class TileBase : ScriptableObject
    {
        protected TileBase();

        [RequiredByNativeCode]
        public virtual void RefreshTile(Vector3Int position, ITilemap tilemap);
        [RequiredByNativeCode]
        public virtual void GetTileData(Vector3Int position, ITilemap tilemap, ref TileData tileData);
        [RequiredByNativeCode]
        public virtual bool GetTileAnimationData(Vector3Int position, ITilemap tilemap, ref TileAnimationData tileAnimationData);
        [RequiredByNativeCode]
        public virtual bool StartUp(Vector3Int position, ITilemap tilemap, GameObject go);
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Tilemaps
{
    [RequireComponent(typeof(Transform))]
    [NativeHeader("Modules/Grid/Public/GridMarshalling.h")]
    [NativeHeader("Modules/Grid/Public/Grid.h")]
    [NativeHeader("Runtime/Graphics/SpriteFrame.h")]
    [NativeHeader("Modules/Tilemap/Public/TilemapTile.h")]
    [NativeHeader("Modules/Tilemap/Public/TilemapMarshalling.h")]
    [NativeType(Header = "Modules/Tilemap/Public/Tilemap.h")]
    public sealed class Tilemap : GridLayout
    {
        public Tilemap();

        public Grid layoutGrid { get; }
        public BoundsInt cellBounds { get; }
        [NativeProperty("TilemapBoundsScripting")]
        public Bounds localBounds { get; }
        public float animationFrameRate { get; set; }
        public Color color { get; set; }
        public Vector3Int origin { get; set; }
        public Vector3Int size { get; set; }
        [NativeProperty(Name = "TileAnchorScripting")]
        public Vector3 tileAnchor { get; set; }
        public Orientation orientation { get; set; }
        public Matrix4x4 orientationMatrix { get; set; }
        public Vector3Int editorPreviewOrigin { get; }
        public Vector3Int editorPreviewSize { get; }

        public static event Action<Tilemap, SyncTile[]> tilemapTileChanged;

        public Vector3 GetCellCenterLocal(Vector3Int position);
        public Vector3 GetCellCenterWorld(Vector3Int position);
        public TileBase GetTile(Vector3Int position);
        public T GetTile<T>(Vector3Int position) where T : TileBase;
        public TileBase[] GetTilesBlock(BoundsInt bounds);
        public void SetTile(Vector3Int position, TileBase tile);
        public void SetTiles(Vector3Int[] positionArray, TileBase[] tileArray);
        public void SetTilesBlock(BoundsInt position, TileBase[] tileArray);
        public bool HasTile(Vector3Int position);
        [NativeMethod(Name = "RefreshTileAsset")]
        public void RefreshTile(Vector3Int position);
        [NativeMethod(Name = "RefreshAllTileAssets")]
        public void RefreshAllTiles();
        public void SwapTile(TileBase changeTile, TileBase newTile);
        public bool ContainsTile(TileBase tileAsset);
        public int GetUsedTilesCount();
        public int GetUsedTilesNonAlloc(TileBase[] usedTiles);
        public Sprite GetSprite(Vector3Int position);
        public Matrix4x4 GetTransformMatrix(Vector3Int position);
        public void SetTransformMatrix(Vector3Int position, Matrix4x4 transform);
        [NativeMethod(Name = "GetTileColor")]
        public Color GetColor(Vector3Int position);
        [NativeMethod(Name = "SetTileColor")]
        public void SetColor(Vector3Int position, Color color);
        public TileFlags GetTileFlags(Vector3Int position);
        public void SetTileFlags(Vector3Int position, TileFlags flags);
        public void AddTileFlags(Vector3Int position, TileFlags flags);
        public void RemoveTileFlags(Vector3Int position, TileFlags flags);
        [NativeMethod(Name = "GetTileInstantiatedObject")]
        public GameObject GetInstantiatedObject(Vector3Int position);
        [NativeMethod(Name = "GetTileObjectToInstantiate")]
        public GameObject GetObjectToInstantiate(Vector3Int position);
        [NativeMethod(Name = "SetTileColliderType")]
        public void SetColliderType(Vector3Int position, Tile.ColliderType colliderType);
        [NativeMethod(Name = "GetTileColliderType")]
        public Tile.ColliderType GetColliderType(Vector3Int position);
        public void FloodFill(Vector3Int position, TileBase tile);
        public void BoxFill(Vector3Int position, TileBase tile, int startX, int startY, int endX, int endY);
        public void InsertCells(Vector3Int position, Vector3Int insertCells);
        public void InsertCells(Vector3Int position, int numColumns, int numRows, int numLayers);
        public void DeleteCells(Vector3Int position, Vector3Int deleteCells);
        public void DeleteCells(Vector3Int position, int numColumns, int numRows, int numLayers);
        public void ClearAllTiles();
        public void ResizeBounds();
        public void CompressBounds();
        public TileBase GetEditorPreviewTile(Vector3Int position);
        public T GetEditorPreviewTile<T>(Vector3Int position) where T : TileBase;
        public void SetEditorPreviewTile(Vector3Int position, TileBase tile);
        public bool HasEditorPreviewTile(Vector3Int position);
        public Sprite GetEditorPreviewSprite(Vector3Int position);
        public Matrix4x4 GetEditorPreviewTransformMatrix(Vector3Int position);
        public void SetEditorPreviewTransformMatrix(Vector3Int position, Matrix4x4 transform);
        [NativeMethod(Name = "GetEditorPreviewTileColor")]
        public Color GetEditorPreviewColor(Vector3Int position);
        [NativeMethod(Name = "SetEditorPreviewTileColor")]
        public void SetEditorPreviewColor(Vector3Int position, Color color);
        public TileFlags GetEditorPreviewTileFlags(Vector3Int position);
        public void EditorPreviewFloodFill(Vector3Int position, TileBase tile);
        public void EditorPreviewBoxFill(Vector3Int position, Object tile, int startX, int startY, int endX, int endY);
        [NativeMethod(Name = "ClearAllEditorPreviewTileAssets")]
        public void ClearAllEditorPreviewTiles();

        public enum Orientation
        {
            XY = 0,
            XZ = 1,
            YX = 2,
            YZ = 3,
            ZX = 4,
            ZY = 5,
            Custom = 6
        }
        [RequiredByNativeCode]
        public struct SyncTile
        {
            public Vector3Int position { get; }
            public TileBase tile { get; }
            public TileData tileData { get; }
        }
    }
}
using System;

namespace UnityEngine.Tilemaps
{
    [Flags]
    public enum TileFlags
    {
        None = 0,
        LockColor = 1,
        LockTransform = 2,
        InstantiateGameObjectRuntimeOnly = 4,
        LockAll = 3
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Tilemaps
{
    [NativeHeader("Modules/Tilemap/Public/TilemapMarshalling.h")]
    [RequireComponent(typeof(Tilemap))]
    [NativeHeader("Modules/Grid/Public/GridMarshalling.h")]
    [NativeHeader("Modules/Tilemap/TilemapRendererJobs.h")]
    [NativeType(Header = "Modules/Tilemap/Public/TilemapRenderer.h")]
    public sealed class TilemapRenderer : Renderer
    {
        public TilemapRenderer();

        public Vector3Int chunkSize { get; set; }
        public Vector3 chunkCullingBounds { get; set; }
        public int maxChunkCount { get; set; }
        public int maxFrameAge { get; set; }
        public SortOrder sortOrder { get; set; }
        [NativeProperty("RenderMode")]
        public Mode mode { get; set; }
        public DetectChunkCullingBounds detectChunkCullingBounds { get; set; }
        public SpriteMaskInteraction maskInteraction { get; set; }

        public enum SortOrder
        {
            BottomLeft = 0,
            BottomRight = 1,
            TopLeft = 2,
            TopRight = 3
        }
        public enum Mode
        {
            Chunk = 0,
            Individual = 1
        }
        public enum DetectChunkCullingBounds
        {
            Auto = 0,
            Manual = 1
        }
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Tilemaps
{
    [RequiredByNativeCode]
    [NativeType(Header = "Modules/Tilemap/TilemapScripting.h")]
    public struct TileData
    {
        public Sprite sprite { get; set; }
        public Color color { get; set; }
        public Matrix4x4 transform { get; set; }
        public GameObject gameObject { get; set; }
        public TileFlags flags { get; set; }
        public Tile.ColliderType colliderType { get; set; }
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Tilemaps
{
    [RequiredByNativeCode]
    [NativeType(Header = "Modules/Tilemap/TilemapScripting.h")]
    public struct TileAnimationData
    {
        public Sprite[] animatedSprites { get; set; }
        public float animationSpeed { get; set; }
        public float animationStartTime { get; set; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Tilemaps
{
    [NativeType(Header = "Modules/Tilemap/Public/TilemapCollider2D.h")]
    [RequireComponent(typeof(Tilemap))]
    public sealed class TilemapCollider2D : Collider2D
    {
        public TilemapCollider2D();

        public uint maximumTileChangeCount { get; set; }
        public float extrusionFactor { get; set; }
        public bool hasTilemapChanges { get; }

        [NativeMethod(Name = "ProcessTileChangeQueue")]
        public void ProcessTilemapChanges();
    }
}
-------- {UnityEngine.UIModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.UIModule.dll)}:   10 --------
namespace UnityEngine
{
    public interface ICanvasRaycastFilter
    {
        bool IsRaycastLocationValid(Vector2 sp, Camera eventCamera);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/UI/CanvasGroup.h")]
    [NativeClass("UI::CanvasGroup")]
    public sealed class CanvasGroup : Behaviour, ICanvasRaycastFilter
    {
        public CanvasGroup();

        [NativeProperty("Alpha", False, Function)]
        public float alpha { get; set; }
        [NativeProperty("Interactable", False, Function)]
        public bool interactable { get; set; }
        [NativeProperty("BlocksRaycasts", False, Function)]
        public bool blocksRaycasts { get; set; }
        [NativeProperty("IgnoreParentGroups", False, Function)]
        public bool ignoreParentGroups { get; set; }

        public bool IsRaycastLocationValid(Vector2 sp, Camera eventCamera);
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeClass("UI::CanvasRenderer")]
    [NativeHeader("Modules/UI/CanvasRenderer.h")]
    public sealed class CanvasRenderer : Component
    {
        public CanvasRenderer();

        public bool hasPopInstruction { get; set; }
        public int materialCount { get; set; }
        public int popMaterialCount { get; set; }
        public int absoluteDepth { get; }
        public bool hasMoved { get; }
        public bool cullTransparentMesh { get; set; }
        [NativeProperty("RectClipping", False, Function)]
        public bool hasRectClipping { get; }
        [NativeProperty("Depth", False, Function)]
        public int relativeDepth { get; }
        [NativeProperty("ShouldCull", False, Function)]
        public bool cull { get; set; }
        [Obsolete("isMask is no longer supported.See EnableClipping for vertex clipping configuration", False)]
        public bool isMask { get; set; }
        public Vector2 clippingSoftness { get; set; }

        public static event OnRequestRebuild onRequestRebuild;

        public void SetColor(Color color);
        public Color GetColor();
        public void EnableRectClipping(Rect rect);
        public void DisableRectClipping();
        public void SetMaterial(Material material, int index);
        public Material GetMaterial(int index);
        public void SetPopMaterial(Material material, int index);
        public Material GetPopMaterial(int index);
        public void SetTexture(Texture texture);
        public void SetAlphaTexture(Texture texture);
        public void SetMesh(Mesh mesh);
        public void Clear();
        public float GetAlpha();
        public void SetAlpha(float alpha);
        public float GetInheritedAlpha();
        public void SetMaterial(Material material, Texture texture);
        public Material GetMaterial();
        public static void SplitUIVertexStreams(List<UIVertex> verts, List<Vector3> positions, List<Color32> colors, List<Vector4> uv0S, List<Vector4> uv1S, List<Vector3> normals, List<Vector4> tangents, List<int> indices);
        public static void SplitUIVertexStreams(List<UIVertex> verts, List<Vector3> positions, List<Color32> colors, List<Vector4> uv0S, List<Vector4> uv1S, List<Vector4> uv2S, List<Vector4> uv3S, List<Vector3> normals, List<Vector4> tangents, List<int> indices);
        public static void CreateUIVertexStream(List<UIVertex> verts, List<Vector3> positions, List<Color32> colors, List<Vector4> uv0S, List<Vector4> uv1S, List<Vector3> normals, List<Vector4> tangents, List<int> indices);
        public static void CreateUIVertexStream(List<UIVertex> verts, List<Vector3> positions, List<Color32> colors, List<Vector4> uv0S, List<Vector4> uv1S, List<Vector4> uv2S, List<Vector4> uv3S, List<Vector3> normals, List<Vector4> tangents, List<int> indices);
        public static void AddUIVertexStream(List<UIVertex> verts, List<Vector3> positions, List<Color32> colors, List<Vector4> uv0S, List<Vector4> uv1S, List<Vector3> normals, List<Vector4> tangents);
        public static void AddUIVertexStream(List<UIVertex> verts, List<Vector3> positions, List<Color32> colors, List<Vector4> uv0S, List<Vector4> uv1S, List<Vector4> uv2S, List<Vector4> uv3S, List<Vector3> normals, List<Vector4> tangents);
        [Obsolete("UI System now uses meshes.Generate a mesh and use 'SetMesh' instead", False)]
        public void SetVertices(List<UIVertex> vertices);
        [Obsolete("UI System now uses meshes.Generate a mesh and use 'SetMesh' instead", False)]
        public void SetVertices(UIVertex[] vertices, int size);

        public delegate void OnRequestRebuild();
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/UI/Canvas.h")]
    [NativeHeader("Runtime/Camera/Camera.h")]
    [NativeHeader("Modules/UI/RectTransformUtil.h")]
    [NativeHeader("Runtime/Transform/RectTransform.h")]
    [StaticAccessor("UI", DoubleColon)]
    public sealed class RectTransformUtility
    {
        public static Vector2 PixelAdjustPoint(Vector2 point, Transform elementTransform, Canvas canvas);
        public static Rect PixelAdjustRect(RectTransform rectTransform, Canvas canvas);
        public static bool RectangleContainsScreenPoint(RectTransform rect, Vector2 screenPoint);
        public static bool RectangleContainsScreenPoint(RectTransform rect, Vector2 screenPoint, Camera cam);
        public static bool RectangleContainsScreenPoint(RectTransform rect, Vector2 screenPoint, Camera cam, Vector4 offset);
        public static bool ScreenPointToWorldPointInRectangle(RectTransform rect, Vector2 screenPoint, Camera cam, out Vector3 worldPoint);
        public static bool ScreenPointToLocalPointInRectangle(RectTransform rect, Vector2 screenPoint, Camera cam, out Vector2 localPoint);
        public static Ray ScreenPointToRay(Camera cam, Vector2 screenPos);
        public static Vector2 WorldToScreenPoint(Camera cam, Vector3 worldPoint);
        public static Bounds CalculateRelativeRectTransformBounds(Transform root, Transform child);
        public static Bounds CalculateRelativeRectTransformBounds(Transform trans);
        public static void FlipLayoutOnAxis(RectTransform rect, int axis, bool keepPositioning, bool recursive);
        public static void FlipLayoutAxes(RectTransform rect, bool keepPositioning, bool recursive);
    }
}
namespace UnityEngine
{
    public enum RenderMode
    {
        ScreenSpaceOverlay = 0,
        ScreenSpaceCamera = 1,
        WorldSpace = 2
    }
}
using System;

namespace UnityEngine
{
    [Flags]
    public enum AdditionalCanvasShaderChannels
    {
        None = 0,
        TexCoord1 = 1,
        TexCoord2 = 2,
        TexCoord3 = 4,
        Normal = 8,
        Tangent = 16
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/UI/UIStructs.h")]
    [NativeClass("UI::Canvas")]
    [RequireComponent(typeof(RectTransform))]
    [NativeHeader("Modules/UI/Canvas.h")]
    public sealed class Canvas : Behaviour
    {
        public Canvas();

        public RenderMode renderMode { get; set; }
        public bool isRootCanvas { get; }
        public Rect pixelRect { get; }
        public float scaleFactor { get; set; }
        public float referencePixelsPerUnit { get; set; }
        public bool overridePixelPerfect { get; set; }
        public bool pixelPerfect { get; set; }
        public float planeDistance { get; set; }
        public int renderOrder { get; }
        public bool overrideSorting { get; set; }
        public int sortingOrder { get; set; }
        public int targetDisplay { get; set; }
        public int sortingLayerID { get; set; }
        public int cachedSortingLayerValue { get; }
        public AdditionalCanvasShaderChannels additionalShaderChannels { get; set; }
        public string sortingLayerName { get; set; }
        public Canvas rootCanvas { get; }
        public Vector2 renderingDisplaySize { get; }
        [NativeProperty("Camera", False, Function)]
        public Camera worldCamera { get; set; }
        [NativeProperty("SortingBucketNormalizedSize", False, Function)]
        public float normalizedSortingGridSize { get; set; }
        [NativeProperty("SortingBucketNormalizedSize", False, Function)]
        [Obsolete("Setting normalizedSize via a int is not supported. Please use normalizedSortingGridSize", False)]
        public int sortingGridNormalizedSize { get; set; }

        public static event WillRenderCanvases preWillRenderCanvases;
        public static event WillRenderCanvases willRenderCanvases;

        [Obsolete("Shared default material now used for text and general UI elements, call Canvas.GetDefaultCanvasMaterial()", False)]
        [FreeFunction("UI::GetDefaultUIMaterial")]
        public static Material GetDefaultCanvasTextMaterial();
        [FreeFunction("UI::GetDefaultUIMaterial")]
        public static Material GetDefaultCanvasMaterial();
        [FreeFunction("UI::GetETC1SupportedCanvasMaterial")]
        public static Material GetETC1SupportedCanvasMaterial();
        public static void ForceUpdateCanvases();

        public delegate void WillRenderCanvases();
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [StaticAccessor("UI::SystemProfilerApi", DoubleColon)]
    [NativeHeader("Modules/UI/Canvas.h")]
    public static class UISystemProfilerApi
    {
        public static void BeginSample(SampleType type);
        public static void EndSample(SampleType type);
        public static void AddMarker(string name, Object obj);

        public enum SampleType
        {
            Layout = 0,
            Render = 1
        }
    }
}
-------- {UnityEngine.UIElementsModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.UIElementsModule.dll)}:  693 --------
namespace UnityEngine.UIElements
{
    public class BindableElement : VisualElement, IBindable
    {
        public BindableElement();

        public IBinding binding { get; set; }
        public string bindingPath { get; set; }

        public class UxmlFactory : UxmlFactory<BindableElement, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : VisualElement.UxmlTraits
        {
            public UxmlTraits();

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
using System;

namespace UnityEngine.UIElements
{
    public class Clickable : PointerManipulator
    {
        public Clickable(Action handler, long delay, long interval);
        public Clickable(Action<EventBase> handler);
        public Clickable(Action handler);

        protected bool active { get; set; }
        public Vector2 lastMousePosition { get; }

        public event Action<EventBase> clickedWithEventInfo;
        public event Action clicked;

        protected override void RegisterCallbacksOnTarget();
        protected override void UnregisterCallbacksFromTarget();
        protected void Invoke(EventBase evt);
        protected void OnMouseDown(MouseDownEvent evt);
        protected void OnMouseMove(MouseMoveEvent evt);
        protected void OnMouseUp(MouseUpEvent evt);
        protected virtual void ProcessDownEvent(EventBase evt, Vector2 localPosition, int pointerId);
        protected virtual void ProcessMoveEvent(EventBase evt, Vector2 localPosition);
        protected virtual void ProcessUpEvent(EventBase evt, Vector2 localPosition, int pointerId);
    }
}
namespace UnityEngine.UIElements
{
    public abstract class ContextualMenuManager
    {
        protected ContextualMenuManager();

        public abstract void DisplayMenuIfEventMatches(EventBase evt, IEventHandler eventHandler);
        public void DisplayMenu(EventBase triggerEvent, IEventHandler target);
        protected internal abstract void DoDisplayMenu(DropdownMenu menu, EventBase triggerEvent);
    }
}
using System;

namespace UnityEngine.UIElements
{
    public class ContextualMenuManipulator : MouseManipulator
    {
        public ContextualMenuManipulator(Action<ContextualMenuPopulateEvent> menuBuilder);

        protected override void RegisterCallbacksOnTarget();
        protected override void UnregisterCallbacksFromTarget();
    }
}
using System;

namespace UnityEngine.UIElements
{
    public struct Cursor : IEquatable<Cursor>
    {
        public Texture2D texture { get; set; }
        public Vector2 hotspot { get; set; }

        public override bool Equals(object obj);
        public bool Equals(Cursor other);
        public override int GetHashCode();
        public override string ToString();

        public static bool operator ==(Cursor style1, Cursor style2);
        public static bool operator !=(Cursor style1, Cursor style2);
    }
}
namespace UnityEngine.UIElements
{
    public class DropdownMenuEventInfo
    {
        public DropdownMenuEventInfo(EventBase e);

        public EventModifiers modifiers { get; }
        public Vector2 mousePosition { get; }
        public Vector2 localMousePosition { get; }
    }
}
namespace UnityEngine.UIElements
{
    public abstract class DropdownMenuItem
    {
        protected DropdownMenuItem();
    }
}
namespace UnityEngine.UIElements
{
    public class DropdownMenuSeparator : DropdownMenuItem
    {
        public DropdownMenuSeparator(string subMenuPath);

        public string subMenuPath { get; }
    }
}
using System;

namespace UnityEngine.UIElements
{
    public class DropdownMenuAction : DropdownMenuItem
    {
        public DropdownMenuAction(string actionName, Action<DropdownMenuAction> actionCallback, Func<DropdownMenuAction, Status> actionStatusCallback, object userData = null);

        public string name { get; }
        public Status status { get; }
        public DropdownMenuEventInfo eventInfo { get; }
        public object userData { get; }

        public static Status AlwaysEnabled(DropdownMenuAction a);
        public static Status AlwaysDisabled(DropdownMenuAction a);
        public void UpdateActionStatus(DropdownMenuEventInfo eventInfo);
        public void Execute();

        [Flags]
        public enum Status
        {
            None = 0,
            Normal = 1,
            Disabled = 2,
            Checked = 4,
            Hidden = 8
        }
    }
}
using System;
using System.Collections.Generic;

namespace UnityEngine.UIElements
{
    public class DropdownMenu
    {
        public DropdownMenu();

        public List<DropdownMenuItem> MenuItems();
        public void AppendAction(string actionName, Action<DropdownMenuAction> action, Func<DropdownMenuAction, DropdownMenuAction.Status> actionStatusCallback, object userData = null);
        public void AppendAction(string actionName, Action<DropdownMenuAction> action, DropdownMenuAction.Status status = Normal);
        public void InsertAction(int atIndex, string actionName, Action<DropdownMenuAction> action, Func<DropdownMenuAction, DropdownMenuAction.Status> actionStatusCallback, object userData = null);
        public void InsertAction(int atIndex, string actionName, Action<DropdownMenuAction> action, DropdownMenuAction.Status status = Normal);
        public void AppendSeparator(string subMenuPath = null);
        public void InsertSeparator(string subMenuPath, int atIndex);
        public void RemoveItemAt(int index);
        public void PrepareForDisplay(EventBase e);
    }
}
using System;

namespace UnityEngine.UIElements
{
    public struct EventDispatcherGate : IDisposable, IEquatable<EventDispatcherGate>
    {
        public EventDispatcherGate(EventDispatcher d);

        public void Dispose();
        public bool Equals(EventDispatcherGate other);
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static bool operator ==(EventDispatcherGate left, EventDispatcherGate right);
        public static bool operator !=(EventDispatcherGate left, EventDispatcherGate right);
    }
}
namespace UnityEngine.UIElements
{
    public sealed class EventDispatcher
    {
    }
}
namespace UnityEngine.UIElements
{
    public abstract class Focusable : CallbackEventHandler
    {
        protected Focusable();

        public abstract FocusController focusController { get; }
        public bool focusable { get; set; }
        public int tabIndex { get; set; }
        public bool delegatesFocus { get; set; }
        public virtual bool canGrabFocus { get; }

        public virtual void Focus();
        public virtual void Blur();
        protected override void ExecuteDefaultAction(EventBase evt);
    }
}
using System;

namespace UnityEngine.UIElements
{
    public class FocusChangeDirection : IDisposable
    {
        protected FocusChangeDirection(int value);

        public static FocusChangeDirection unspecified { get; }
        public static FocusChangeDirection none { get; }
        protected static FocusChangeDirection lastValue { get; }

        protected virtual void Dispose();

        public static implicit operator int(FocusChangeDirection fcd);
    }
}
namespace UnityEngine.UIElements
{
    public interface IFocusRing
    {
        FocusChangeDirection GetFocusChangeDirection(Focusable currentFocusable, EventBase e);
        Focusable GetNextFocusable(Focusable currentFocusable, FocusChangeDirection direction);
    }
}
namespace UnityEngine.UIElements
{
    public class FocusController
    {
        public FocusController(IFocusRing focusRing);

        public Focusable focusedElement { get; }
    }
}
using System;
using System.Collections.Generic;

namespace UnityEngine.UIElements
{
    public class IMGUIContainer : VisualElement, IDisposable
    {
        public static readonly string ussClassName;

        public IMGUIContainer();
        public IMGUIContainer(Action onGUIHandler);

        public Action onGUIHandler { get; set; }
        public bool cullingEnabled { get; set; }
        public ContextType contextType { get; set; }
        public override bool canGrabFocus { get; }

        public void MarkDirtyLayout();
        public override void HandleEvent(EventBase evt);
        protected override void ExecuteDefaultAction(EventBase evt);
        protected internal override Vector2 DoMeasure(float desiredWidth, VisualElement.MeasureMode widthMode, float desiredHeight, VisualElement.MeasureMode heightMode);
        public void Dispose();
        protected virtual void Dispose(bool disposeManaged);

        public class UxmlFactory : UxmlFactory<IMGUIContainer, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : VisualElement.UxmlTraits
        {
            public UxmlTraits();

            public override IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription { get; }
        }
    }
}
namespace UnityEngine.UIElements
{
    public abstract class ImmediateModeElement : VisualElement
    {
        public ImmediateModeElement();

        public bool cullingEnabled { get; set; }

        protected abstract void ImmediateRepaint();
    }
}
namespace UnityEngine.UIElements
{
    public enum SelectionType
    {
        None = 0,
        Single = 1,
        Multiple = 2
    }
}
namespace UnityEngine.UIElements
{
    public interface ITransform
    {
        Vector3 position { get; set; }
        Quaternion rotation { get; set; }
        Vector3 scale { get; set; }
        Matrix4x4 matrix { get; }
    }
}
using System;

namespace UnityEngine.UIElements
{
    public struct ManipulatorActivationFilter : IEquatable<ManipulatorActivationFilter>
    {
        public MouseButton button { get; set; }
        public EventModifiers modifiers { get; set; }
        public int clickCount { get; set; }

        public override bool Equals(object obj);
        public bool Equals(ManipulatorActivationFilter other);
        public override int GetHashCode();
        public bool Matches(IMouseEvent e);
        public bool Matches(IPointerEvent e);

        public static bool operator ==(ManipulatorActivationFilter filter1, ManipulatorActivationFilter filter2);
        public static bool operator !=(ManipulatorActivationFilter filter1, ManipulatorActivationFilter filter2);
    }
}
namespace UnityEngine.UIElements
{
    public interface IManipulator
    {
        VisualElement target { get; set; }
    }
}
namespace UnityEngine.UIElements
{
    public abstract class Manipulator : IManipulator
    {
        protected Manipulator();

        public VisualElement target { get; set; }

        protected abstract void RegisterCallbacksOnTarget();
        protected abstract void UnregisterCallbacksFromTarget();
    }
}
namespace UnityEngine.UIElements
{
    public enum MouseButton
    {
        LeftMouse = 0,
        RightMouse = 1,
        MiddleMouse = 2
    }
}
namespace UnityEngine.UIElements
{
    public static class MouseCaptureController
    {
        public static bool IsMouseCaptured();
        public static bool HasMouseCapture(this IEventHandler handler);
        public static void CaptureMouse(this IEventHandler handler);
        public static void ReleaseMouse(this IEventHandler handler);
        public static void ReleaseMouse();
    }
}
using System.Collections.Generic;

namespace UnityEngine.UIElements
{
    public abstract class MouseManipulator : Manipulator
    {
        protected MouseManipulator();

        public List<ManipulatorActivationFilter> activators { get; }

        protected bool CanStartManipulation(IMouseEvent e);
        protected bool CanStopManipulation(IMouseEvent e);
    }
}
namespace UnityEngine.UIElements
{
    public enum ContextType
    {
        Player = 0,
        Editor = 1
    }
}
using System;

namespace UnityEngine.UIElements
{
    [Flags]
    public enum UsageHints
    {
        None = 0,
        DynamicTransform = 1,
        GroupTransform = 2
    }
}
using System;
using System.Collections.Generic;

namespace UnityEngine.UIElements
{
    public interface IPanel : IDisposable
    {
        VisualElement visualTree { get; }
        EventDispatcher dispatcher { get; }
        ContextType contextType { get; }
        FocusController focusController { get; }
        ContextualMenuManager contextualMenuManager { get; }

        VisualElement Pick(Vector2 point);
        VisualElement PickAll(Vector2 point, List<VisualElement> picked);
    }
}
namespace UnityEngine.UIElements
{
    public static class PointerCaptureHelper
    {
        public static bool HasPointerCapture(this IEventHandler handler, int pointerId);
        public static void CapturePointer(this IEventHandler handler, int pointerId);
        public static void ReleasePointer(this IEventHandler handler, int pointerId);
        public static IEventHandler GetCapturingElement(this IPanel panel, int pointerId);
        public static void ReleasePointer(this IPanel panel, int pointerId);
    }
}
namespace UnityEngine.UIElements
{
    public abstract class PointerManipulator : MouseManipulator
    {
        protected PointerManipulator();

        protected bool CanStartManipulation(IPointerEvent e);
        protected bool CanStopManipulation(IPointerEvent e);
    }
}
using System;

namespace UnityEngine.UIElements
{
    public struct TimerState : IEquatable<TimerState>
    {
        public long start { get; set; }
        public long now { get; set; }
        public long deltaTime { get; }

        public override bool Equals(object obj);
        public bool Equals(TimerState other);
        public override int GetHashCode();

        public static bool operator ==(TimerState state1, TimerState state2);
        public static bool operator !=(TimerState state1, TimerState state2);
    }
}
namespace UnityEngine.UIElements
{
    public enum Position
    {
        Relative = 0,
        Absolute = 1
    }
}
namespace UnityEngine.UIElements
{
    public enum Overflow
    {
        Visible = 0,
        Hidden = 1
    }
}
namespace UnityEngine.UIElements
{
    public enum OverflowClipBox
    {
        PaddingBox = 0,
        ContentBox = 1
    }
}
namespace UnityEngine.UIElements
{
    public enum FlexDirection
    {
        Column = 0,
        ColumnReverse = 1,
        Row = 2,
        RowReverse = 3
    }
}
namespace UnityEngine.UIElements
{
    public enum Wrap
    {
        NoWrap = 0,
        Wrap = 1,
        WrapReverse = 2
    }
}
namespace UnityEngine.UIElements
{
    public enum Align
    {
        Auto = 0,
        FlexStart = 1,
        Center = 2,
        FlexEnd = 3,
        Stretch = 4
    }
}
namespace UnityEngine.UIElements
{
    public enum Justify
    {
        FlexStart = 0,
        Center = 1,
        FlexEnd = 2,
        SpaceBetween = 3,
        SpaceAround = 4
    }
}
namespace UnityEngine.UIElements
{
    public enum TextOverflowPosition
    {
        End = 0,
        Start = 1,
        Middle = 2
    }
}
namespace UnityEngine.UIElements
{
    public enum TextOverflow
    {
        Clip = 0,
        Ellipsis = 1
    }
}
namespace UnityEngine.UIElements
{
    public enum Visibility
    {
        Visible = 0,
        Hidden = 1
    }
}
namespace UnityEngine.UIElements
{
    public enum WhiteSpace
    {
        Normal = 0,
        NoWrap = 1
    }
}
namespace UnityEngine.UIElements
{
    public enum DisplayStyle
    {
        Flex = 0,
        None = 1
    }
}
using System.Collections.Generic;

namespace UnityEngine.UIElements
{
    public class TemplateContainer : BindableElement
    {
        public TemplateContainer();
        public TemplateContainer(string templateId);

        public string templateId { get; }
        public override VisualElement contentContainer { get; }

        public class UxmlFactory : UxmlFactory<TemplateContainer, UxmlTraits>
        {
            public UxmlFactory();

            public override string uxmlName { get; }
            public override string uxmlQualifiedName { get; }
        }
        public class UxmlTraits : BindableElement.UxmlTraits
        {
            public UxmlTraits();

            public override IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription { get; }

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
using System.Collections.Generic;

namespace UnityEngine.UIElements
{
    public class TextElement : BindableElement, INotifyValueChanged<string>, ITextElement
    {
        public static readonly string ussClassName;

        public TextElement();

        public virtual string text { get; set; }
        public bool displayTooltipWhenElided { get; set; }
        public bool isElided { get; }

        public Vector2 MeasureTextSize(string textToMeasure, float width, VisualElement.MeasureMode widthMode, float height, VisualElement.MeasureMode heightMode);
        protected internal override Vector2 DoMeasure(float desiredWidth, VisualElement.MeasureMode widthMode, float desiredHeight, VisualElement.MeasureMode heightMode);

        public class UxmlFactory : UxmlFactory<TextElement, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : BindableElement.UxmlTraits
        {
            public UxmlTraits();

            public override IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription { get; }

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
namespace UnityEngine.UIElements
{
    public static class UQuery
    {
    }
}
using System;
using System.Collections.Generic;

namespace UnityEngine.UIElements
{
    public struct UQueryState<T> : IEquatable<UQueryState<T>> where T : VisualElement
    {
        public UQueryState<T> RebuildOn(VisualElement element);
        public T First();
        public T Last();
        public void ToList(List<T> results);
        public List<T> ToList();
        public T AtIndex(int index);
        public void ForEach(Action<T> funcCall);
        public void ForEach<T2>(List<T2> result, Func<T, T2> funcCall);
        public List<T2> ForEach<T2>(Func<T, T2> funcCall);
        public bool Equals(UQueryState<T> other);
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static bool operator ==(UQueryState<T> state1, UQueryState<T> state2);
        public static bool operator !=(UQueryState<T> state1, UQueryState<T> state2);
    }
}
using System;
using System.Collections.Generic;

namespace UnityEngine.UIElements
{
    public struct UQueryBuilder<T> : IEquatable<UQueryBuilder<T>> where T : VisualElement
    {
        public UQueryBuilder(VisualElement visualElement);

        public UQueryBuilder<T> Class(string classname);
        public UQueryBuilder<T> Name(string id);
        public UQueryBuilder<T2> Descendents<T2>(string name = null, params string[] classNames) where T2 : VisualElement;
        public UQueryBuilder<T2> Descendents<T2>(string name = null, string classname = null) where T2 : VisualElement;
        public UQueryBuilder<T2> Children<T2>(string name = null, params string[] classes) where T2 : VisualElement;
        public UQueryBuilder<T2> Children<T2>(string name = null, string className = null) where T2 : VisualElement;
        public UQueryBuilder<T2> OfType<T2>(string name = null, params string[] classes) where T2 : VisualElement;
        public UQueryBuilder<T2> OfType<T2>(string name = null, string className = null) where T2 : VisualElement;
        public UQueryBuilder<T> Where(Func<T, bool> selectorPredicate);
        public UQueryBuilder<T> Active();
        public UQueryBuilder<T> NotActive();
        public UQueryBuilder<T> Visible();
        public UQueryBuilder<T> NotVisible();
        public UQueryBuilder<T> Hovered();
        public UQueryBuilder<T> NotHovered();
        public UQueryBuilder<T> Checked();
        public UQueryBuilder<T> NotChecked();
        [Obsolete("Use Checked() instead")]
        public UQueryBuilder<T> Selected();
        [Obsolete("Use NotChecked() instead")]
        public UQueryBuilder<T> NotSelected();
        public UQueryBuilder<T> Enabled();
        public UQueryBuilder<T> NotEnabled();
        public UQueryBuilder<T> Focused();
        public UQueryBuilder<T> NotFocused();
        public UQueryState<T> Build();
        public T First();
        public T Last();
        public List<T> ToList();
        public void ToList(List<T> results);
        public T AtIndex(int index);
        public void ForEach<T2>(List<T2> result, Func<T, T2> funcCall);
        public List<T2> ForEach<T2>(Func<T, T2> funcCall);
        public void ForEach(Action<T> funcCall);
        public bool Equals(UQueryBuilder<T> other);
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static bool operator ==(UQueryBuilder<T> builder1, UQueryBuilder<T> builder2);
        public static bool operator !=(UQueryBuilder<T> builder1, UQueryBuilder<T> builder2);

        public static implicit operator T(UQueryBuilder<T> s);
    }
}
namespace UnityEngine.UIElements
{
    public static class UQueryExtensions
    {
        public static T Q<T>(this VisualElement e, string name = null, params string[] classes) where T : VisualElement;
        public static VisualElement Q(this VisualElement e, string name = null, params string[] classes);
        public static T Q<T>(this VisualElement e, string name = null, string className = null) where T : VisualElement;
        public static VisualElement Q(this VisualElement e, string name = null, string className = null);
        public static UQueryBuilder<VisualElement> Query(this VisualElement e, string name = null, params string[] classes);
        public static UQueryBuilder<VisualElement> Query(this VisualElement e, string name = null, string className = null);
        public static UQueryBuilder<T> Query<T>(this VisualElement e, string name = null, params string[] classes) where T : VisualElement;
        public static UQueryBuilder<T> Query<T>(this VisualElement e, string name = null, string className = null) where T : VisualElement;
        public static UQueryBuilder<VisualElement> Query(this VisualElement e);
    }
}
namespace UnityEngine.UIElements
{
    public enum PickingMode
    {
        Position = 0,
        Ignore = 1
    }
}
using System;
using System.Collections.Generic;
using System.Reflection;
using UnityEngine.UIElements.Experimental;

namespace UnityEngine.UIElements
{
    [DefaultMember("Item")]
    public class VisualElement : Focusable, IResolvedStyle, IExperimentalFeatures, ITransitionAnimations, IVisualElementScheduler, ITransform
    {
        public static readonly string disabledUssClassName;

        public VisualElement();

        public VisualElement this[int key] { get; }
        public string viewDataKey { get; set; }
        public object userData { get; set; }
        public override bool canGrabFocus { get; }
        public override FocusController focusController { get; }
        public UsageHints usageHints { get; set; }
        public ITransform transform { get; }
        public Rect layout { get; }
        public Rect contentRect { get; }
        protected Rect paddingRect { get; }
        public Rect worldBound { get; }
        public Rect localBound { get; }
        public Matrix4x4 worldTransform { get; }
        public PickingMode pickingMode { get; set; }
        public string name { get; set; }
        public bool enabledInHierarchy { get; }
        public bool enabledSelf { get; }
        public bool visible { get; set; }
        public Action<MeshGenerationContext> generateVisualContent { get; set; }
        public IExperimentalFeatures experimental { get; }
        public Hierarchy hierarchy { get; }
        [Obsolete("VisualElement.cacheAsBitmap is deprecated and has no effect")]
        public bool cacheAsBitmap { get; set; }
        public VisualElement parent { get; }
        public IPanel panel { get; }
        public virtual VisualElement contentContainer { get; }
        public int childCount { get; }
        public IVisualElementScheduler schedule { get; }
        public IStyle style { get; }
        public ICustomStyle customStyle { get; }
        public VisualElementStyleSheetSet styleSheets { get; }
        public string tooltip { get; set; }
        public IResolvedStyle resolvedStyle { get; }

        protected override void ExecuteDefaultAction(EventBase evt);
        public sealed override void Focus();
        public sealed override void SendEvent(EventBase e);
        [Obsolete("SetEnabledFromHierarchy is deprecated and will be removed in a future release. Please use SetEnabled instead.")]
        protected internal bool SetEnabledFromHierarchy(bool state);
        public void SetEnabled(bool value);
        public void MarkDirtyRepaint();
        public virtual bool ContainsPoint(Vector2 localPoint);
        public virtual bool Overlaps(Rect rectangle);
        protected internal virtual Vector2 DoMeasure(float desiredWidth, MeasureMode widthMode, float desiredHeight, MeasureMode heightMode);
        public override string ToString();
        public IEnumerable<string> GetClasses();
        public void ClearClassList();
        public void AddToClassList(string className);
        public void RemoveFromClassList(string className);
        public void ToggleInClassList(string className);
        public void EnableInClassList(string className, bool enable);
        public bool ClassListContains(string cls);
        public object FindAncestorUserData();
        public void Add(VisualElement child);
        public void Insert(int index, VisualElement element);
        public void Remove(VisualElement element);
        public void RemoveAt(int index);
        public void Clear();
        public VisualElement ElementAt(int index);
        public int IndexOf(VisualElement element);
        public IEnumerable<VisualElement> Children();
        public void Sort(Comparison<VisualElement> comp);
        public void BringToFront();
        public void SendToBack();
        public void PlaceBehind(VisualElement sibling);
        public void PlaceInFront(VisualElement sibling);
        public void RemoveFromHierarchy();
        public T GetFirstOfType<T>() where T : class;
        public T GetFirstAncestorOfType<T>() where T : class;
        public bool Contains(VisualElement child);
        public VisualElement FindCommonAncestor(VisualElement other);

        public class UxmlFactory : UxmlFactory<VisualElement, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : UnityEngine.UIElements.UxmlTraits
        {
            protected UxmlStringAttributeDescription m_Name;
            protected UxmlEnumAttributeDescription<PickingMode> m_PickingMode;

            public UxmlTraits();

            protected UxmlIntAttributeDescription focusIndex { get; set; }
            protected UxmlBoolAttributeDescription focusable { get; set; }
            public override IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription { get; }

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
        public enum MeasureMode
        {
            Undefined = 0,
            Exactly = 1,
            AtMost = 2
        }
        [DefaultMember("Item")]
        public struct Hierarchy
        {
            public VisualElement this[int key] { get; }
            public VisualElement parent { get; }
            public int childCount { get; }

            public void Add(VisualElement child);
            public void Insert(int index, VisualElement child);
            public void Remove(VisualElement child);
            public void RemoveAt(int index);
            public void Clear();
            public int IndexOf(VisualElement element);
            public VisualElement ElementAt(int index);
            public IEnumerable<VisualElement> Children();
            public void Sort(Comparison<VisualElement> comp);
            public bool Equals(Hierarchy other);
            public override bool Equals(object obj);
            public override int GetHashCode();

            public static bool operator ==(Hierarchy x, Hierarchy y);
            public static bool operator !=(Hierarchy x, Hierarchy y);
        }
    }
}
namespace UnityEngine.UIElements
{
    public static class VisualElementExtensions
    {
        public static Vector2 WorldToLocal(this VisualElement ele, Vector2 p);
        public static Vector2 LocalToWorld(this VisualElement ele, Vector2 p);
        public static Rect WorldToLocal(this VisualElement ele, Rect r);
        public static Rect LocalToWorld(this VisualElement ele, Rect r);
        public static Vector2 ChangeCoordinatesTo(this VisualElement src, VisualElement dest, Vector2 point);
        public static Rect ChangeCoordinatesTo(this VisualElement src, VisualElement dest, Rect rect);
        public static void StretchToParentSize(this VisualElement elem);
        public static void StretchToParentWidth(this VisualElement elem);
        public static void AddManipulator(this VisualElement ele, IManipulator manipulator);
        public static void RemoveManipulator(this VisualElement ele, IManipulator manipulator);
    }
}
using UnityEngine.UIElements.Experimental;

namespace UnityEngine.UIElements
{
    public interface IExperimentalFeatures
    {
        ITransitionAnimations animation { get; }
    }
}
namespace UnityEngine.UIElements
{
    public class VisualElementFocusChangeDirection : FocusChangeDirection
    {
        protected VisualElementFocusChangeDirection(int value);

        public static FocusChangeDirection left { get; }
        public static FocusChangeDirection right { get; }
        protected static VisualElementFocusChangeDirection lastValue { get; }
    }
}
namespace UnityEngine.UIElements
{
    public class VisualElementFocusRing : IFocusRing
    {
        public VisualElementFocusRing(VisualElement root, DefaultFocusOrder dfo = ChildOrder);

        public DefaultFocusOrder defaultFocusOrder { get; set; }

        public FocusChangeDirection GetFocusChangeDirection(Focusable currentFocusable, EventBase e);
        public Focusable GetNextFocusable(Focusable currentFocusable, FocusChangeDirection direction);

        public enum DefaultFocusOrder
        {
            ChildOrder = 0,
            PositionXY = 1,
            PositionYX = 2
        }
    }
}
using System;

namespace UnityEngine.UIElements
{
    public interface IVisualElementScheduledItem
    {
        VisualElement element { get; }
        bool isActive { get; }

        void Resume();
        void Pause();
        void ExecuteLater(long delayMs);
        IVisualElementScheduledItem StartingIn(long delayMs);
        IVisualElementScheduledItem Every(long intervalMs);
        IVisualElementScheduledItem Until(Func<bool> stopCondition);
        IVisualElementScheduledItem ForDuration(long durationMs);
    }
}
using System;

namespace UnityEngine.UIElements
{
    public interface IVisualElementScheduler
    {
        IVisualElementScheduledItem Execute(Action<TimerState> timerUpdateEvent);
        IVisualElementScheduledItem Execute(Action updateEvent);
    }
}
using System;
using System.Reflection;

namespace UnityEngine.UIElements
{
    [DefaultMember("Item")]
    public struct VisualElementStyleSheetSet : IEquatable<VisualElementStyleSheetSet>
    {
        public StyleSheet this[int index] { get; }
        public int count { get; }

        public void Add(StyleSheet styleSheet);
        public void Clear();
        public bool Remove(StyleSheet styleSheet);
        public bool Contains(StyleSheet styleSheet);
        public bool Equals(VisualElementStyleSheetSet other);
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static bool operator ==(VisualElementStyleSheetSet left, VisualElementStyleSheetSet right);
        public static bool operator !=(VisualElementStyleSheetSet left, VisualElementStyleSheetSet right);
    }
}
namespace UnityEngine.UIElements
{
    public abstract class BaseField<TValueType> : BindableElement, INotifyValueChanged<TValueType>
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;
        public static readonly string noLabelVariantUssClassName;
        public static readonly string labelDraggerVariantUssClassName;

        protected BaseField(string label, VisualElement visualInput);

        protected TValueType rawValue { get; set; }
        public virtual TValueType value { get; set; }
        public Label labelElement { get; }
        public string label { get; set; }

        public virtual void SetValueWithoutNotify(TValueType newValue);

        public class UxmlTraits : BindableElement.UxmlTraits
        {
            public UxmlTraits();

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
namespace UnityEngine.UIElements
{
    public class BaseFieldTraits<TValueType, TValueUxmlAttributeType> : BaseField<TValueType>.UxmlTraits where TValueUxmlAttributeType : TypedUxmlAttributeDescription<TValueType>, new()
    {
        public BaseFieldTraits();

        public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
    }
}
namespace UnityEngine.UIElements
{
    public enum SliderDirection
    {
        Horizontal = 0,
        Vertical = 1
    }
}
using System;

namespace UnityEngine.UIElements
{
    public abstract class BaseSlider<TValueType> : BaseField<TValueType> where TValueType : IComparable<TValueType>
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;
        public static readonly string horizontalVariantUssClassName;
        public static readonly string verticalVariantUssClassName;
        public static readonly string dragContainerUssClassName;
        public static readonly string trackerUssClassName;
        public static readonly string draggerUssClassName;
        public static readonly string draggerBorderUssClassName;
        public static readonly string textFieldClassName;

        public TValueType lowValue { get; set; }
        public TValueType highValue { get; set; }
        public TValueType range { get; }
        public virtual float pageSize { get; set; }
        public virtual bool showInputField { get; set; }
        public override TValueType value { get; set; }
        public SliderDirection direction { get; set; }

        public override void SetValueWithoutNotify(TValueType newValue);
        protected static float GetClosestPowerOfTen(float positiveNumber);
        protected static float RoundToMultipleOf(float value, float roundingValue);
        public void AdjustDragElement(float factor);
        protected override void ExecuteDefaultAction(EventBase evt);
    }
}
namespace UnityEngine.UIElements
{
    public interface IBindable
    {
        IBinding binding { get; set; }
        string bindingPath { get; set; }
    }
}
namespace UnityEngine.UIElements
{
    public interface IBinding
    {
        void PreUpdate();
        void Update();
        void Release();
    }
}
namespace UnityEngine.UIElements
{
    public static class IBindingExtensions
    {
        public static bool IsBound(this IBindable control);
    }
}
namespace UnityEngine.UIElements
{
    public class Box : VisualElement
    {
        public static readonly string ussClassName;

        public Box();

        public class UxmlFactory : UxmlFactory<Box>
        {
            public UxmlFactory();
        }
    }
}
using System;

namespace UnityEngine.UIElements
{
    public class Button : TextElement
    {
        public static readonly string ussClassName;

        public Button();
        public Button(Action clickEvent);

        public Clickable clickable { get; set; }

        [Obsolete("onClick is obsolete. Use clicked instead (UnityUpgradable) -> clicked", True)]
        public event Action onClick;
        public event Action clicked;

        protected internal override Vector2 DoMeasure(float desiredWidth, VisualElement.MeasureMode widthMode, float desiredHeight, VisualElement.MeasureMode heightMode);
        protected override void ExecuteDefaultActionAtTarget(EventBase evt);

        public class UxmlFactory : UxmlFactory<Button, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : TextElement.UxmlTraits
        {
            public UxmlTraits();
        }
    }
}
namespace UnityEngine.UIElements
{
    public class Foldout : BindableElement, INotifyValueChanged<bool>
    {
        public static readonly string ussClassName;
        public static readonly string toggleUssClassName;
        public static readonly string contentUssClassName;

        public Foldout();

        public override VisualElement contentContainer { get; }
        public string text { get; set; }
        public bool value { get; set; }

        public void SetValueWithoutNotify(bool newValue);

        public class UxmlFactory : UxmlFactory<Foldout, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : BindableElement.UxmlTraits
        {
            public UxmlTraits();

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
namespace UnityEngine.UIElements
{
    public enum HelpBoxMessageType
    {
        None = 0,
        Info = 1,
        Warning = 2,
        Error = 3
    }
}
namespace UnityEngine.UIElements
{
    public class HelpBox : VisualElement
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string iconUssClassName;
        public static readonly string iconInfoUssClassName;
        public static readonly string iconwarningUssClassName;
        public static readonly string iconErrorUssClassName;

        public HelpBox();
        public HelpBox(string text, HelpBoxMessageType messageType);

        public string text { get; set; }
        public HelpBoxMessageType messageType { get; set; }

        public class UxmlFactory : UxmlFactory<HelpBox, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : VisualElement.UxmlTraits
        {
            public UxmlTraits();

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
using System.Collections.Generic;

namespace UnityEngine.UIElements
{
    public class Image : VisualElement
    {
        public static readonly string ussClassName;

        public Image();

        public Texture image { get; set; }
        public VectorImage vectorImage { get; set; }
        public Rect sourceRect { get; set; }
        public Rect uv { get; set; }
        public ScaleMode scaleMode { get; set; }
        public Color tintColor { get; set; }

        protected internal override Vector2 DoMeasure(float desiredWidth, VisualElement.MeasureMode widthMode, float desiredHeight, VisualElement.MeasureMode heightMode);

        public class UxmlFactory : UxmlFactory<Image, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : VisualElement.UxmlTraits
        {
            public UxmlTraits();

            public override IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription { get; }
        }
    }
}
namespace UnityEngine.UIElements
{
    public interface INotifyValueChanged<T>
    {
        T value { get; set; }

        void SetValueWithoutNotify(T newValue);
    }
}
namespace UnityEngine.UIElements
{
    public static class INotifyValueChangedExtensions
    {
        public static bool RegisterValueChangedCallback<T>(this INotifyValueChanged<T> control, EventCallback<ChangeEvent<T>> callback);
        public static bool UnregisterValueChangedCallback<T>(this INotifyValueChanged<T> control, EventCallback<ChangeEvent<T>> callback);
    }
}
namespace UnityEngine.UIElements
{
    public class Label : TextElement
    {
        public static readonly string ussClassName;

        public Label();
        public Label(string text);

        public class UxmlFactory : UxmlFactory<Label, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : TextElement.UxmlTraits
        {
            public UxmlTraits();
        }
    }
}
namespace UnityEngine.UIElements
{
    public enum AlternatingRowBackground
    {
        None = 0,
        ContentOnly = 1,
        All = 2
    }
}
using System;
using System.Collections;
using System.Collections.Generic;

namespace UnityEngine.UIElements
{
    public class ListView : BindableElement, ISerializationCallbackReceiver
    {
        public static readonly string ussClassName;
        public static readonly string borderUssClassName;
        public static readonly string itemUssClassName;
        public static readonly string dragHoverBarUssClassName;
        public static readonly string itemDragHoverUssClassName;
        public static readonly string itemSelectedVariantUssClassName;
        public static readonly string itemAlternativeBackgroundUssClassName;

        public ListView();
        public ListView(IList itemsSource, int itemHeight, Func<VisualElement> makeItem, Action<VisualElement, int> bindItem);

        public IList itemsSource { get; set; }
        public Func<VisualElement> makeItem { get; set; }
        public Action<VisualElement, int> unbindItem { get; set; }
        public Action<VisualElement, int> bindItem { get; set; }
        public float resolvedItemHeight { get; }
        public int itemHeight { get; set; }
        public bool showBorder { get; set; }
        public bool reorderable { get; set; }
        public int selectedIndex { get; set; }
        public IEnumerable<int> selectedIndices { get; }
        public object selectedItem { get; }
        public IEnumerable<object> selectedItems { get; }
        public override VisualElement contentContainer { get; }
        public SelectionType selectionType { get; set; }
        public AlternatingRowBackground showAlternatingRowBackgrounds { get; set; }
        public bool showBoundCollectionSize { get; set; }
        public bool horizontalScrollingEnabled { get; set; }

        [Obsolete("onItemChosen is obsolete, use onItemsChosen instead")]
        public event Action<object> onItemChosen;
        public event Action<IEnumerable<object>> onItemsChosen;
        [Obsolete("onSelectionChanged is obsolete, use onSelectionChange instead")]
        public event Action<List<object>> onSelectionChanged;
        public event Action<IEnumerable<object>> onSelectionChange;

        public void OnKeyDown(KeyDownEvent evt);
        protected override void ExecuteDefaultActionAtTarget(EventBase evt);
        public void ScrollToItem(int index);
        public void AddToSelection(int index);
        public void RemoveFromSelection(int index);
        public void SetSelection(int index);
        public void SetSelection(IEnumerable<int> indices);
        public void SetSelectionWithoutNotify(IEnumerable<int> indices);
        public void ClearSelection();
        public void ScrollTo(VisualElement visualElement);
        protected override void ExecuteDefaultAction(EventBase evt);
        public void Refresh();

        public class UxmlFactory : UxmlFactory<ListView, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : BindableElement.UxmlTraits
        {
            public UxmlTraits();

            public override IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription { get; }

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
namespace UnityEngine.UIElements
{
    public class MinMaxSlider : BaseField<Vector2>
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;
        public static readonly string trackerUssClassName;
        public static readonly string draggerUssClassName;
        public static readonly string minThumbUssClassName;
        public static readonly string maxThumbUssClassName;

        public MinMaxSlider();
        public MinMaxSlider(float minValue, float maxValue, float minLimit, float maxLimit);
        public MinMaxSlider(string label, float minValue = 0, float maxValue = 10, float minLimit = -3.402823E+38, float maxLimit = 3.402823E+38);

        public float minValue { get; set; }
        public float maxValue { get; set; }
        public override Vector2 value { get; set; }
        public float range { get; }
        public float lowLimit { get; set; }
        public float highLimit { get; set; }

        public override void SetValueWithoutNotify(Vector2 newValue);
        protected override void ExecuteDefaultAction(EventBase evt);

        public class UxmlFactory : UxmlFactory<MinMaxSlider, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : BaseField<Vector2>.UxmlTraits
        {
            public UxmlTraits();

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
using System.Collections.Generic;

namespace UnityEngine.UIElements
{
    public class PopupWindow : TextElement
    {
        public static readonly string ussClassName;
        public static readonly string contentUssClassName;

        public PopupWindow();

        public override VisualElement contentContainer { get; }

        public class UxmlFactory : UxmlFactory<PopupWindow, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : TextElement.UxmlTraits
        {
            public UxmlTraits();

            public override IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription { get; }
        }
    }
}
using System;

namespace UnityEngine.UIElements
{
    public class RepeatButton : TextElement
    {
        public static readonly string ussClassName;

        public RepeatButton();
        public RepeatButton(Action clickEvent, long delay, long interval);

        public void SetAction(Action clickEvent, long delay, long interval);

        public class UxmlFactory : UxmlFactory<RepeatButton, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : TextElement.UxmlTraits
        {
            public UxmlTraits();

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
using System;
using System.Collections.Generic;

namespace UnityEngine.UIElements
{
    public class Scroller : VisualElement
    {
        public static readonly string ussClassName;
        public static readonly string horizontalVariantUssClassName;
        public static readonly string verticalVariantUssClassName;
        public static readonly string sliderUssClassName;
        public static readonly string lowButtonUssClassName;
        public static readonly string highButtonUssClassName;

        public Scroller();
        public Scroller(float lowValue, float highValue, Action<float> valueChanged, SliderDirection direction = Vertical);

        public Slider slider { get; }
        public RepeatButton lowButton { get; }
        public RepeatButton highButton { get; }
        public float value { get; set; }
        public float lowValue { get; set; }
        public float highValue { get; set; }
        public SliderDirection direction { get; set; }

        public event Action<float> valueChanged;

        public void Adjust(float factor);
        public void ScrollPageUp();
        public void ScrollPageDown();
        public void ScrollPageUp(float factor);
        public void ScrollPageDown(float factor);

        public class UxmlFactory : UxmlFactory<Scroller, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : VisualElement.UxmlTraits
        {
            public UxmlTraits();

            public override IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription { get; }

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
namespace UnityEngine.UIElements
{
    public enum ScrollViewMode
    {
        Vertical = 0,
        Horizontal = 1,
        VerticalAndHorizontal = 2
    }
}
namespace UnityEngine.UIElements
{
    public class ScrollView : VisualElement
    {
        public static readonly string ussClassName;
        public static readonly string viewportUssClassName;
        public static readonly string contentUssClassName;
        public static readonly string hScrollerUssClassName;
        public static readonly string vScrollerUssClassName;
        public static readonly string horizontalVariantUssClassName;
        public static readonly string verticalVariantUssClassName;
        public static readonly string verticalHorizontalVariantUssClassName;
        public static readonly string scrollVariantUssClassName;

        public ScrollView();
        public ScrollView(ScrollViewMode scrollViewMode);

        public bool showHorizontal { get; set; }
        public bool showVertical { get; set; }
        public Vector2 scrollOffset { get; set; }
        public float horizontalPageSize { get; set; }
        public float verticalPageSize { get; set; }
        public float scrollDecelerationRate { get; set; }
        public float elasticity { get; set; }
        public TouchScrollBehavior touchScrollBehavior { get; set; }
        public VisualElement contentViewport { get; }
        public Scroller horizontalScroller { get; }
        public Scroller verticalScroller { get; }
        public override VisualElement contentContainer { get; }

        public void ScrollTo(VisualElement child);

        public class UxmlFactory : UxmlFactory<ScrollView, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : VisualElement.UxmlTraits
        {
            public UxmlTraits();

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
        public enum TouchScrollBehavior
        {
            Unrestricted = 0,
            Elastic = 1,
            Clamped = 2
        }
    }
}
namespace UnityEngine.UIElements
{
    public class Slider : BaseSlider<float>
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;

        public Slider();
        public Slider(float start, float end, SliderDirection direction = Horizontal, float pageSize = 0);
        public Slider(string label, float start = 0, float end = 10, SliderDirection direction = Horizontal, float pageSize = 0);

        public class UxmlFactory : UxmlFactory<Slider, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : BaseFieldTraits<float, UxmlFloatAttributeDescription>
        {
            public UxmlTraits();

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
namespace UnityEngine.UIElements
{
    public class SliderInt : BaseSlider<int>
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;

        public SliderInt();
        public SliderInt(int start, int end, SliderDirection direction = Horizontal, float pageSize = 0);
        public SliderInt(string label, int start = 0, int end = 10, SliderDirection direction = Horizontal, float pageSize = 0);

        public override float pageSize { get; set; }

        public class UxmlFactory : UxmlFactory<SliderInt, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : BaseFieldTraits<int, UxmlIntAttributeDescription>
        {
            public UxmlTraits();

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
namespace UnityEngine.UIElements
{
    public class TextField : TextInputBaseField<string>
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;

        public TextField();
        public TextField(int maxLength, bool multiline, bool isPasswordField, char maskChar);
        public TextField(string label);
        public TextField(string label, int maxLength, bool multiline, bool isPasswordField, char maskChar);

        public bool multiline { get; set; }
        public override string value { get; set; }

        public void SelectRange(int rangeCursorIndex, int selectionIndex);
        public override void SetValueWithoutNotify(string newValue);

        public class UxmlFactory : UxmlFactory<TextField, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : TextInputBaseField<string>.UxmlTraits
        {
            public UxmlTraits();

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
using System;

namespace UnityEngine.UIElements
{
    public abstract class TextInputBaseField<TValueType> : BaseField<TValueType>
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;
        public static readonly string textInputUssName;

        protected TextInputBaseField(int maxLength, char maskChar, TextInputBase textInputBase);
        protected TextInputBaseField(string label, int maxLength, char maskChar, TextInputBase textInputBase);

        protected TextInputBase textInputBase { get; }
        public string text { get; protected set; }
        public bool isReadOnly { get; set; }
        public bool isPasswordField { get; set; }
        public Color selectionColor { get; }
        public Color cursorColor { get; }
        public int cursorIndex { get; }
        public int selectIndex { get; }
        public int maxLength { get; set; }
        public bool doubleClickSelectsWord { get; set; }
        public bool tripleClickSelectsLine { get; set; }
        public bool isDelayed { get; set; }
        public char maskChar { get; set; }

        protected event Action<bool> onIsReadOnlyChanged;

        public void SelectAll();
        protected override void ExecuteDefaultActionAtTarget(EventBase evt);

        public class UxmlTraits : BaseFieldTraits<string, UxmlStringAttributeDescription>
        {
            public UxmlTraits();

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
        protected abstract class TextInputBase : VisualElement, ITextInputField, ITextElement
        {
            public int cursorIndex { get; }
            public int selectIndex { get; }
            public bool isReadOnly { get; set; }
            public int maxLength { get; set; }
            public char maskChar { get; set; }
            public virtual bool isPasswordField { get; set; }
            public bool doubleClickSelectsWord { get; set; }
            public bool tripleClickSelectsLine { get; set; }
            public Color selectionColor { get; }
            public Color cursorColor { get; }
            public string text { get; set; }

            public void SelectAll();
            protected virtual TValueType StringToValue(string str);
            protected virtual void BuildContextualMenu(ContextualMenuPopulateEvent evt);
            protected internal override Vector2 DoMeasure(float desiredWidth, VisualElement.MeasureMode widthMode, float desiredHeight, VisualElement.MeasureMode heightMode);
            protected override void ExecuteDefaultActionAtTarget(EventBase evt);
            protected override void ExecuteDefaultAction(EventBase evt);
        }
    }
}
namespace UnityEngine.UIElements
{
    public class Toggle : BaseField<bool>
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;
        public static readonly string noTextVariantUssClassName;
        public static readonly string checkmarkUssClassName;
        public static readonly string textUssClassName;

        public Toggle();
        public Toggle(string label);

        public string text { get; set; }

        public override void SetValueWithoutNotify(bool newValue);
        protected override void ExecuteDefaultActionAtTarget(EventBase evt);

        public class UxmlFactory : UxmlFactory<Toggle, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : BaseFieldTraits<bool, UxmlBoolAttributeDescription>
        {
            public UxmlTraits();

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
using System.Collections.Generic;

namespace UnityEngine.UIElements
{
    public class TwoPaneSplitView : VisualElement
    {
        public TwoPaneSplitView();
        public TwoPaneSplitView(int fixedPaneIndex, float fixedPaneStartDimension, TwoPaneSplitViewOrientation orientation);

        public VisualElement fixedPane { get; }
        public VisualElement flexedPane { get; }
        public int fixedPaneIndex { get; set; }
        public float fixedPaneInitialDimension { get; set; }
        public TwoPaneSplitViewOrientation orientation { get; set; }
        public override VisualElement contentContainer { get; }

        public void CollapseChild(int index);
        public void UnCollapse();

        public class UxmlFactory : UxmlFactory<TwoPaneSplitView, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : VisualElement.UxmlTraits
        {
            public UxmlTraits();

            public override IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription { get; }

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
namespace UnityEngine.UIElements
{
    public enum TwoPaneSplitViewOrientation
    {
        Horizontal = 0,
        Vertical = 1
    }
}
namespace UnityEngine.UIElements
{
    public interface IPointerCaptureEvent
    {
    }
}
namespace UnityEngine.UIElements
{
    public abstract class PointerCaptureEventBase<T> : EventBase<T>, IPointerCaptureEvent where T : PointerCaptureEventBase<T>, new()
    {
        protected PointerCaptureEventBase();

        public IEventHandler relatedTarget { get; }
        public int pointerId { get; }

        protected override void Init();
        public static T GetPooled(IEventHandler target, IEventHandler relatedTarget, int pointerId);
    }
}
namespace UnityEngine.UIElements
{
    public class PointerCaptureOutEvent : PointerCaptureEventBase<PointerCaptureOutEvent>
    {
        public PointerCaptureOutEvent();
    }
}
namespace UnityEngine.UIElements
{
    public class PointerCaptureEvent : PointerCaptureEventBase<PointerCaptureEvent>
    {
        public PointerCaptureEvent();
    }
}
namespace UnityEngine.UIElements
{
    public interface IMouseCaptureEvent
    {
    }
}
namespace UnityEngine.UIElements
{
    public abstract class MouseCaptureEventBase<T> : PointerCaptureEventBase<T>, IMouseCaptureEvent where T : MouseCaptureEventBase<T>, new()
    {
        protected MouseCaptureEventBase();

        public IEventHandler relatedTarget { get; }

        public static T GetPooled(IEventHandler target, IEventHandler relatedTarget);
        protected override void Init();
    }
}
namespace UnityEngine.UIElements
{
    public class MouseCaptureOutEvent : MouseCaptureEventBase<MouseCaptureOutEvent>
    {
        public MouseCaptureOutEvent();
    }
}
namespace UnityEngine.UIElements
{
    public class MouseCaptureEvent : MouseCaptureEventBase<MouseCaptureEvent>
    {
        public MouseCaptureEvent();
    }
}
namespace UnityEngine.UIElements
{
    public interface IChangeEvent
    {
    }
}
namespace UnityEngine.UIElements
{
    public class ChangeEvent<T> : EventBase<ChangeEvent<T>>, IChangeEvent
    {
        public ChangeEvent();

        public T previousValue { get; protected set; }
        public T newValue { get; protected set; }

        protected override void Init();
        public static ChangeEvent<T> GetPooled(T previousValue, T newValue);
    }
}
namespace UnityEngine.UIElements
{
    public interface ICommandEvent
    {
        string commandName { get; }
    }
}
namespace UnityEngine.UIElements
{
    public abstract class CommandEventBase<T> : EventBase<T>, ICommandEvent where T : CommandEventBase<T>, new()
    {
        protected CommandEventBase();

        public string commandName { get; protected set; }

        protected override void Init();
        public static T GetPooled(Event systemEvent);
        public static T GetPooled(string commandName);
    }
}
namespace UnityEngine.UIElements
{
    public class ValidateCommandEvent : CommandEventBase<ValidateCommandEvent>
    {
        public ValidateCommandEvent();
    }
}
namespace UnityEngine.UIElements
{
    public class ExecuteCommandEvent : CommandEventBase<ExecuteCommandEvent>
    {
        public ExecuteCommandEvent();
    }
}
namespace UnityEngine.UIElements
{
    public interface IDragAndDropEvent
    {
    }
}
namespace UnityEngine.UIElements
{
    public abstract class DragAndDropEventBase<T> : MouseEventBase<T>, IDragAndDropEvent where T : DragAndDropEventBase<T>, new()
    {
        protected DragAndDropEventBase();
    }
}
namespace UnityEngine.UIElements
{
    public class DragExitedEvent : DragAndDropEventBase<DragExitedEvent>
    {
        public DragExitedEvent();

        protected override void Init();
        public static DragExitedEvent GetPooled(Event systemEvent);
        protected internal override void PostDispatch(IPanel panel);
    }
}
namespace UnityEngine.UIElements
{
    public class DragEnterEvent : DragAndDropEventBase<DragEnterEvent>
    {
        public DragEnterEvent();

        protected override void Init();
    }
}
namespace UnityEngine.UIElements
{
    public class DragLeaveEvent : DragAndDropEventBase<DragLeaveEvent>
    {
        public DragLeaveEvent();

        protected override void Init();
    }
}
namespace UnityEngine.UIElements
{
    public class DragUpdatedEvent : DragAndDropEventBase<DragUpdatedEvent>
    {
        public DragUpdatedEvent();

        public static DragUpdatedEvent GetPooled(Event systemEvent);
        protected internal override void PostDispatch(IPanel panel);
    }
}
namespace UnityEngine.UIElements
{
    public class DragPerformEvent : DragAndDropEventBase<DragPerformEvent>
    {
        public DragPerformEvent();
    }
}
using System;

namespace UnityEngine.UIElements
{
    public abstract class EventBase : IDisposable
    {
        protected EventBase();

        public virtual long eventTypeId { get; }
        public long timestamp { get; }
        public bool bubbles { get; protected set; }
        public bool tricklesDown { get; protected set; }
        public IEventHandler target { get; set; }
        public bool isPropagationStopped { get; }
        public bool isImmediatePropagationStopped { get; }
        public bool isDefaultPrevented { get; }
        public PropagationPhase propagationPhase { get; }
        public virtual IEventHandler currentTarget { get; }
        public bool dispatch { get; }
        public Event imguiEvent { get; protected set; }
        public Vector2 originalMousePosition { get; }
        protected bool pooled { get; set; }

        protected static long RegisterEventType();
        [Obsolete("Override PreDispatch(IPanel panel) instead.")]
        protected virtual void PreDispatch();
        protected internal virtual void PreDispatch(IPanel panel);
        [Obsolete("Override PostDispatch(IPanel panel) instead.")]
        protected virtual void PostDispatch();
        protected internal virtual void PostDispatch(IPanel panel);
        public void StopPropagation();
        public void StopImmediatePropagation();
        public void PreventDefault();
        protected virtual void Init();
        public abstract void Dispose();
    }
}
namespace UnityEngine.UIElements
{
    public abstract class EventBase<T> : EventBase where T : EventBase<T>, new()
    {
        protected EventBase();

        public override long eventTypeId { get; }

        public static long TypeId();
        protected override void Init();
        public static T GetPooled();
        public sealed override void Dispose();
    }
}
namespace UnityEngine.UIElements
{
    public delegate void EventCallback<TEventType>(TEventType evt);
}
namespace UnityEngine.UIElements
{
    public delegate void EventCallback<TEventType, TCallbackArgs>(TEventType evt, TCallbackArgs userArgs);
}
namespace UnityEngine.UIElements
{
    public enum TrickleDown
    {
        NoTrickleDown = 0,
        TrickleDown = 1
    }
}
namespace UnityEngine.UIElements
{
    public interface IEventHandler
    {
        void SendEvent(EventBase e);
        void HandleEvent(EventBase evt);
        bool HasTrickleDownHandlers();
        bool HasBubbleUpHandlers();
    }
}
namespace UnityEngine.UIElements
{
    public abstract class CallbackEventHandler : IEventHandler
    {
        protected CallbackEventHandler();

        public void RegisterCallback<TEventType>(EventCallback<TEventType> callback, TrickleDown useTrickleDown = NoTrickleDown) where TEventType : EventBase<TEventType>, new();
        public void RegisterCallback<TEventType, TUserArgsType>(EventCallback<TEventType, TUserArgsType> callback, TUserArgsType userArgs, TrickleDown useTrickleDown = NoTrickleDown) where TEventType : EventBase<TEventType>, new();
        public void UnregisterCallback<TEventType>(EventCallback<TEventType> callback, TrickleDown useTrickleDown = NoTrickleDown) where TEventType : EventBase<TEventType>, new();
        public void UnregisterCallback<TEventType, TUserArgsType>(EventCallback<TEventType, TUserArgsType> callback, TrickleDown useTrickleDown = NoTrickleDown) where TEventType : EventBase<TEventType>, new();
        public abstract void SendEvent(EventBase e);
        public virtual void HandleEvent(EventBase evt);
        public bool HasTrickleDownHandlers();
        public bool HasBubbleUpHandlers();
        protected virtual void ExecuteDefaultActionAtTarget(EventBase evt);
        protected virtual void ExecuteDefaultAction(EventBase evt);
    }
}
namespace UnityEngine.UIElements
{
    public interface IFocusEvent
    {
        Focusable relatedTarget { get; }
        FocusChangeDirection direction { get; }
    }
}
namespace UnityEngine.UIElements
{
    public abstract class FocusEventBase<T> : EventBase<T>, IFocusEvent where T : FocusEventBase<T>, new()
    {
        protected FocusEventBase();

        public Focusable relatedTarget { get; }
        public FocusChangeDirection direction { get; }
        protected FocusController focusController { get; }

        protected override void Init();
        public static T GetPooled(IEventHandler target, Focusable relatedTarget, FocusChangeDirection direction, FocusController focusController, bool bIsFocusDelegated = False);
    }
}
namespace UnityEngine.UIElements
{
    public class FocusOutEvent : FocusEventBase<FocusOutEvent>
    {
        public FocusOutEvent();

        protected override void Init();
    }
}
namespace UnityEngine.UIElements
{
    public class BlurEvent : FocusEventBase<BlurEvent>
    {
        public BlurEvent();

        protected internal override void PreDispatch(IPanel panel);
    }
}
namespace UnityEngine.UIElements
{
    public class FocusInEvent : FocusEventBase<FocusInEvent>
    {
        public FocusInEvent();

        protected override void Init();
    }
}
namespace UnityEngine.UIElements
{
    public class FocusEvent : FocusEventBase<FocusEvent>
    {
        public FocusEvent();

        protected internal override void PreDispatch(IPanel panel);
    }
}
namespace UnityEngine.UIElements
{
    public enum PropagationPhase
    {
        None = 0,
        TrickleDown = 1,
        AtTarget = 2,
        DefaultActionAtTarget = 5,
        BubbleUp = 3,
        DefaultAction = 4
    }
}
namespace UnityEngine.UIElements
{
    public class InputEvent : EventBase<InputEvent>
    {
        public InputEvent();

        public string previousData { get; protected set; }
        public string newData { get; protected set; }

        protected override void Init();
        public static InputEvent GetPooled(string previousData, string newData);
    }
}
namespace UnityEngine.UIElements
{
    public interface IKeyboardEvent
    {
        EventModifiers modifiers { get; }
        char character { get; }
        KeyCode keyCode { get; }
        bool shiftKey { get; }
        bool ctrlKey { get; }
        bool commandKey { get; }
        bool altKey { get; }
        bool actionKey { get; }
    }
}
namespace UnityEngine.UIElements
{
    public abstract class KeyboardEventBase<T> : EventBase<T>, IKeyboardEvent where T : KeyboardEventBase<T>, new()
    {
        protected KeyboardEventBase();

        public EventModifiers modifiers { get; protected set; }
        public char character { get; protected set; }
        public KeyCode keyCode { get; protected set; }
        public bool shiftKey { get; }
        public bool ctrlKey { get; }
        public bool commandKey { get; }
        public bool altKey { get; }
        public bool actionKey { get; }

        protected override void Init();
        public static T GetPooled(char c, KeyCode keyCode, EventModifiers modifiers);
        public static T GetPooled(Event systemEvent);
    }
}
namespace UnityEngine.UIElements
{
    public class KeyDownEvent : KeyboardEventBase<KeyDownEvent>
    {
        public KeyDownEvent();
    }
}
namespace UnityEngine.UIElements
{
    public class KeyUpEvent : KeyboardEventBase<KeyUpEvent>
    {
        public KeyUpEvent();
    }
}
namespace UnityEngine.UIElements
{
    public class GeometryChangedEvent : EventBase<GeometryChangedEvent>
    {
        public GeometryChangedEvent();

        public Rect oldRect { get; }
        public Rect newRect { get; }

        public static GeometryChangedEvent GetPooled(Rect oldRect, Rect newRect);
        protected override void Init();
    }
}
namespace UnityEngine.UIElements
{
    public interface IMouseEvent
    {
        EventModifiers modifiers { get; }
        Vector2 mousePosition { get; }
        Vector2 localMousePosition { get; }
        Vector2 mouseDelta { get; }
        int clickCount { get; }
        int button { get; }
        int pressedButtons { get; }
        bool shiftKey { get; }
        bool ctrlKey { get; }
        bool commandKey { get; }
        bool altKey { get; }
        bool actionKey { get; }
    }
}
namespace UnityEngine.UIElements
{
    public abstract class MouseEventBase<T> : EventBase<T>, IMouseEvent, IMouseEventInternal where T : MouseEventBase<T>, new()
    {
        protected MouseEventBase();

        public EventModifiers modifiers { get; protected set; }
        public Vector2 mousePosition { get; protected set; }
        public Vector2 localMousePosition { get; }
        public Vector2 mouseDelta { get; protected set; }
        public int clickCount { get; protected set; }
        public int button { get; protected set; }
        public int pressedButtons { get; protected set; }
        public bool shiftKey { get; }
        public bool ctrlKey { get; }
        public bool commandKey { get; }
        public bool altKey { get; }
        public bool actionKey { get; }
        public override IEventHandler currentTarget { get; }

        protected override void Init();
        protected internal override void PreDispatch(IPanel panel);
        protected internal override void PostDispatch(IPanel panel);
        public static T GetPooled(Event systemEvent);
        public static T GetPooled(Vector2 position, int button, int clickCount, Vector2 delta, EventModifiers modifiers = None);
        public static T GetPooled(IMouseEvent triggerEvent);
        protected static T GetPooled(IPointerEvent pointerEvent);
    }
}
namespace UnityEngine.UIElements
{
    public class MouseDownEvent : MouseEventBase<MouseDownEvent>
    {
        public MouseDownEvent();

        public static MouseDownEvent GetPooled(Event systemEvent);
    }
}
namespace UnityEngine.UIElements
{
    public class MouseUpEvent : MouseEventBase<MouseUpEvent>
    {
        public MouseUpEvent();

        public static MouseUpEvent GetPooled(Event systemEvent);
    }
}
namespace UnityEngine.UIElements
{
    public class MouseMoveEvent : MouseEventBase<MouseMoveEvent>
    {
        public MouseMoveEvent();

        public static MouseMoveEvent GetPooled(Event systemEvent);
    }
}
namespace UnityEngine.UIElements
{
    public class ContextClickEvent : MouseEventBase<ContextClickEvent>
    {
        public ContextClickEvent();
    }
}
namespace UnityEngine.UIElements
{
    public class WheelEvent : MouseEventBase<WheelEvent>
    {
        public WheelEvent();

        public Vector3 delta { get; }

        public static WheelEvent GetPooled(Event systemEvent);
        protected override void Init();
    }
}
namespace UnityEngine.UIElements
{
    public class MouseEnterEvent : MouseEventBase<MouseEnterEvent>
    {
        public MouseEnterEvent();

        protected override void Init();
    }
}
namespace UnityEngine.UIElements
{
    public class MouseLeaveEvent : MouseEventBase<MouseLeaveEvent>
    {
        public MouseLeaveEvent();

        protected override void Init();
    }
}
namespace UnityEngine.UIElements
{
    public class MouseEnterWindowEvent : MouseEventBase<MouseEnterWindowEvent>
    {
        public MouseEnterWindowEvent();

        protected override void Init();
        protected internal override void PostDispatch(IPanel panel);
    }
}
namespace UnityEngine.UIElements
{
    public class MouseLeaveWindowEvent : MouseEventBase<MouseLeaveWindowEvent>
    {
        public MouseLeaveWindowEvent();

        protected override void Init();
        public static MouseLeaveWindowEvent GetPooled(Event systemEvent);
        protected internal override void PostDispatch(IPanel panel);
    }
}
namespace UnityEngine.UIElements
{
    public class MouseOverEvent : MouseEventBase<MouseOverEvent>
    {
        public MouseOverEvent();
    }
}
namespace UnityEngine.UIElements
{
    public class MouseOutEvent : MouseEventBase<MouseOutEvent>
    {
        public MouseOutEvent();
    }
}
namespace UnityEngine.UIElements
{
    public class ContextualMenuPopulateEvent : MouseEventBase<ContextualMenuPopulateEvent>
    {
        public ContextualMenuPopulateEvent();

        public DropdownMenu menu { get; }
        public EventBase triggerEvent { get; }

        public static ContextualMenuPopulateEvent GetPooled(EventBase triggerEvent, DropdownMenu menu, IEventHandler target, ContextualMenuManager menuManager);
        protected override void Init();
        protected internal override void PostDispatch(IPanel panel);
    }
}
namespace UnityEngine.UIElements
{
    public interface IPanelChangedEvent
    {
    }
}
namespace UnityEngine.UIElements
{
    public abstract class PanelChangedEventBase<T> : EventBase<T>, IPanelChangedEvent where T : PanelChangedEventBase<T>, new()
    {
        protected PanelChangedEventBase();

        public IPanel originPanel { get; }
        public IPanel destinationPanel { get; }

        protected override void Init();
        public static T GetPooled(IPanel originPanel, IPanel destinationPanel);
    }
}
namespace UnityEngine.UIElements
{
    public class AttachToPanelEvent : PanelChangedEventBase<AttachToPanelEvent>
    {
        public AttachToPanelEvent();
    }
}
namespace UnityEngine.UIElements
{
    public class DetachFromPanelEvent : PanelChangedEventBase<DetachFromPanelEvent>
    {
        public DetachFromPanelEvent();
    }
}
namespace UnityEngine.UIElements
{
    public static class PointerType
    {
        public static readonly string mouse;
        public static readonly string touch;
        public static readonly string pen;
        public static readonly string unknown;
    }
}
namespace UnityEngine.UIElements
{
    public static class PointerId
    {
        public static readonly int maxPointers;
        public static readonly int invalidPointerId;
        public static readonly int mousePointerId;
        public static readonly int touchPointerIdBase;
        public static readonly int touchPointerCount;
        public static readonly int penPointerIdBase;
        public static readonly int penPointerCount;
    }
}
namespace UnityEngine.UIElements
{
    public interface IPointerEvent
    {
        int pointerId { get; }
        string pointerType { get; }
        bool isPrimary { get; }
        int button { get; }
        int pressedButtons { get; }
        Vector3 position { get; }
        Vector3 localPosition { get; }
        Vector3 deltaPosition { get; }
        float deltaTime { get; }
        int clickCount { get; }
        float pressure { get; }
        float tangentialPressure { get; }
        float altitudeAngle { get; }
        float azimuthAngle { get; }
        float twist { get; }
        Vector2 radius { get; }
        Vector2 radiusVariance { get; }
        EventModifiers modifiers { get; }
        bool shiftKey { get; }
        bool ctrlKey { get; }
        bool commandKey { get; }
        bool altKey { get; }
        bool actionKey { get; }
    }
}
namespace UnityEngine.UIElements
{
    public abstract class PointerEventBase<T> : EventBase<T>, IPointerEvent, IPointerEventInternal where T : PointerEventBase<T>, new()
    {
        protected PointerEventBase();

        public int pointerId { get; protected set; }
        public string pointerType { get; protected set; }
        public bool isPrimary { get; protected set; }
        public int button { get; protected set; }
        public int pressedButtons { get; protected set; }
        public Vector3 position { get; protected set; }
        public Vector3 localPosition { get; protected set; }
        public Vector3 deltaPosition { get; protected set; }
        public float deltaTime { get; protected set; }
        public int clickCount { get; protected set; }
        public float pressure { get; protected set; }
        public float tangentialPressure { get; protected set; }
        public float altitudeAngle { get; protected set; }
        public float azimuthAngle { get; protected set; }
        public float twist { get; protected set; }
        public Vector2 radius { get; protected set; }
        public Vector2 radiusVariance { get; protected set; }
        public EventModifiers modifiers { get; protected set; }
        public bool shiftKey { get; }
        public bool ctrlKey { get; }
        public bool commandKey { get; }
        public bool altKey { get; }
        public bool actionKey { get; }
        public override IEventHandler currentTarget { get; }

        protected override void Init();
        public static T GetPooled(Event systemEvent);
        public static T GetPooled(Touch touch, EventModifiers modifiers = None);
        public static T GetPooled(IPointerEvent triggerEvent);
        protected internal override void PreDispatch(IPanel panel);
        protected internal override void PostDispatch(IPanel panel);
    }
}
namespace UnityEngine.UIElements
{
    public sealed class PointerDownEvent : PointerEventBase<PointerDownEvent>
    {
        public PointerDownEvent();

        protected override void Init();
        protected internal override void PostDispatch(IPanel panel);
    }
}
namespace UnityEngine.UIElements
{
    public sealed class PointerMoveEvent : PointerEventBase<PointerMoveEvent>
    {
        public PointerMoveEvent();

        protected override void Init();
        protected internal override void PostDispatch(IPanel panel);
    }
}
namespace UnityEngine.UIElements
{
    public sealed class PointerStationaryEvent : PointerEventBase<PointerStationaryEvent>
    {
        public PointerStationaryEvent();

        protected override void Init();
    }
}
namespace UnityEngine.UIElements
{
    public sealed class PointerUpEvent : PointerEventBase<PointerUpEvent>
    {
        public PointerUpEvent();

        protected override void Init();
        protected internal override void PostDispatch(IPanel panel);
    }
}
namespace UnityEngine.UIElements
{
    public sealed class PointerCancelEvent : PointerEventBase<PointerCancelEvent>
    {
        public PointerCancelEvent();

        protected override void Init();
        protected internal override void PostDispatch(IPanel panel);
    }
}
namespace UnityEngine.UIElements
{
    public sealed class ClickEvent : PointerEventBase<ClickEvent>
    {
        public ClickEvent();
    }
}
namespace UnityEngine.UIElements
{
    public sealed class PointerEnterEvent : PointerEventBase<PointerEnterEvent>
    {
        public PointerEnterEvent();

        protected override void Init();
    }
}
namespace UnityEngine.UIElements
{
    public sealed class PointerLeaveEvent : PointerEventBase<PointerLeaveEvent>
    {
        public PointerLeaveEvent();

        protected override void Init();
    }
}
namespace UnityEngine.UIElements
{
    public sealed class PointerOverEvent : PointerEventBase<PointerOverEvent>
    {
        public PointerOverEvent();
    }
}
namespace UnityEngine.UIElements
{
    public sealed class PointerOutEvent : PointerEventBase<PointerOutEvent>
    {
        public PointerOutEvent();
    }
}
namespace UnityEngine.UIElements
{
    public class CustomStyleResolvedEvent : EventBase<CustomStyleResolvedEvent>
    {
        public CustomStyleResolvedEvent();

        public ICustomStyle customStyle { get; }
    }
}
namespace UnityEngine.UIElements
{
    public class TooltipEvent : EventBase<TooltipEvent>
    {
        public TooltipEvent();

        public string tooltip { get; set; }
        public Rect rect { get; set; }

        protected override void Init();
    }
}
namespace UnityEngine.UIElements
{
    public class IMGUIEvent : EventBase<IMGUIEvent>
    {
        public IMGUIEvent();

        public static IMGUIEvent GetPooled(Event systemEvent);
        protected override void Init();
    }
}
namespace UnityEngine.UIElements
{
    public struct Vertex
    {
        public static readonly float nearZ;
        public Vector3 position;
        public Color32 tint;
        public Vector2 uv;
    }
}
using Unity.Collections;

namespace UnityEngine.UIElements
{
    public class MeshWriteData
    {
        public int vertexCount { get; }
        public int indexCount { get; }
        public Rect uvRegion { get; }

        public void SetNextVertex(Vertex vertex);
        public void SetNextIndex(ushort index);
        public void SetAllVertices(Vertex[] vertices);
        public void SetAllVertices(NativeSlice<Vertex> vertices);
        public void SetAllIndices(ushort[] indices);
        public void SetAllIndices(NativeSlice<ushort> indices);
    }
}
namespace UnityEngine.UIElements
{
    public class MeshGenerationContext
    {
        public VisualElement visualElement { get; }

        public MeshWriteData Allocate(int vertexCount, int indexCount, Texture texture = null);
    }
}
using System;

namespace UnityEngine.UIElements
{
    public struct Background : IEquatable<Background>
    {
        [Obsolete("Use Background.FromTexture2D instead")]
        public Background(Texture2D t);

        public Texture2D texture { get; set; }
        public VectorImage vectorImage { get; set; }

        public static Background FromTexture2D(Texture2D t);
        public static Background FromVectorImage(VectorImage vi);
        public bool Equals(Background other);
        public override bool Equals(object obj);
        public override int GetHashCode();
        public override string ToString();

        public static bool operator ==(Background lhs, Background rhs);
        public static bool operator !=(Background lhs, Background rhs);
    }
}
using System;

namespace UnityEngine.UIElements
{
    public struct CustomStyleProperty<T> : IEquatable<CustomStyleProperty<T>>
    {
        public CustomStyleProperty(string propertyName);

        public string name { get; }

        public override bool Equals(object obj);
        public bool Equals(CustomStyleProperty<T> other);
        public override int GetHashCode();

        public static bool operator ==(CustomStyleProperty<T> a, CustomStyleProperty<T> b);
        public static bool operator !=(CustomStyleProperty<T> a, CustomStyleProperty<T> b);
    }
}
namespace UnityEngine.UIElements
{
    public interface ICustomStyle
    {
        bool TryGetValue(CustomStyleProperty<float> property, out float value);
        bool TryGetValue(CustomStyleProperty<int> property, out int value);
        bool TryGetValue(CustomStyleProperty<bool> property, out bool value);
        bool TryGetValue(CustomStyleProperty<Color> property, out Color value);
        bool TryGetValue(CustomStyleProperty<Texture2D> property, out Texture2D value);
        bool TryGetValue(CustomStyleProperty<VectorImage> property, out VectorImage value);
        bool TryGetValue(CustomStyleProperty<string> property, out string value);
    }
}
namespace UnityEngine.UIElements
{
    public enum LengthUnit
    {
        Pixel = 0,
        Percent = 1
    }
}
using System;

namespace UnityEngine.UIElements
{
    public struct Length : IEquatable<Length>
    {
        public Length(float value);
        public Length(float value, LengthUnit unit);

        public float value { get; set; }
        public LengthUnit unit { get; set; }

        public static Length Percent(float value);
        public bool Equals(Length other);
        public override bool Equals(object obj);
        public override int GetHashCode();
        public override string ToString();

        public static bool operator ==(Length lhs, Length rhs);
        public static bool operator !=(Length lhs, Length rhs);

        public static implicit operator Length(float value);
    }
}
using System;

namespace UnityEngine.UIElements
{
    public struct StyleBackground : IEquatable<StyleBackground>, IStyleValue<Background>
    {
        public StyleBackground(Background v);
        public StyleBackground(Texture2D v);
        public StyleBackground(VectorImage v);
        public StyleBackground(StyleKeyword keyword);

        public Background value { get; set; }
        public StyleKeyword keyword { get; set; }

        public bool Equals(StyleBackground other);
        public override bool Equals(object obj);
        public override int GetHashCode();
        public override string ToString();

        public static bool operator ==(StyleBackground lhs, StyleBackground rhs);
        public static bool operator !=(StyleBackground lhs, StyleBackground rhs);

        public static implicit operator StyleBackground(StyleKeyword keyword);
        public static implicit operator StyleBackground(Background v);
        public static implicit operator StyleBackground(Texture2D v);
    }
}
using System;

namespace UnityEngine.UIElements
{
    public struct StyleColor : IEquatable<StyleColor>, IStyleValue<Color>
    {
        public StyleColor(Color v);
        public StyleColor(StyleKeyword keyword);

        public Color value { get; set; }
        public StyleKeyword keyword { get; set; }

        public bool Equals(StyleColor other);
        public override bool Equals(object obj);
        public override int GetHashCode();
        public override string ToString();

        public static bool operator ==(StyleColor lhs, StyleColor rhs);
        public static bool operator !=(StyleColor lhs, StyleColor rhs);
        public static bool operator ==(StyleColor lhs, Color rhs);
        public static bool operator !=(StyleColor lhs, Color rhs);

        public static implicit operator StyleColor(StyleKeyword keyword);
        public static implicit operator StyleColor(Color v);
    }
}
using System;

namespace UnityEngine.UIElements
{
    public struct StyleCursor : IEquatable<StyleCursor>, IStyleValue<Cursor>
    {
        public StyleCursor(Cursor v);
        public StyleCursor(StyleKeyword keyword);

        public Cursor value { get; set; }
        public StyleKeyword keyword { get; set; }

        public bool Equals(StyleCursor other);
        public override bool Equals(object obj);
        public override int GetHashCode();
        public override string ToString();

        public static bool operator ==(StyleCursor lhs, StyleCursor rhs);
        public static bool operator !=(StyleCursor lhs, StyleCursor rhs);

        public static implicit operator StyleCursor(StyleKeyword keyword);
        public static implicit operator StyleCursor(Cursor v);
    }
}
using System;

namespace UnityEngine.UIElements
{
    public struct StyleEnum<T> : IEquatable<StyleEnum<T>>, IStyleValue<T> where T : IConvertible, struct
    {
        public StyleEnum(T v);
        public StyleEnum(StyleKeyword keyword);

        public T value { get; set; }
        public StyleKeyword keyword { get; set; }

        public bool Equals(StyleEnum<T> other);
        public override bool Equals(object obj);
        public override int GetHashCode();
        public override string ToString();

        public static bool operator ==(StyleEnum<T> lhs, StyleEnum<T> rhs);
        public static bool operator !=(StyleEnum<T> lhs, StyleEnum<T> rhs);

        public static implicit operator StyleEnum<T>(StyleKeyword keyword);
        public static implicit operator StyleEnum<T>(T v);
    }
}
using System;

namespace UnityEngine.UIElements
{
    public struct StyleFloat : IEquatable<StyleFloat>, IStyleValue<float>
    {
        public StyleFloat(float v);
        public StyleFloat(StyleKeyword keyword);

        public float value { get; set; }
        public StyleKeyword keyword { get; set; }

        public bool Equals(StyleFloat other);
        public override bool Equals(object obj);
        public override int GetHashCode();
        public override string ToString();

        public static bool operator ==(StyleFloat lhs, StyleFloat rhs);
        public static bool operator !=(StyleFloat lhs, StyleFloat rhs);

        public static implicit operator StyleFloat(StyleKeyword keyword);
        public static implicit operator StyleFloat(float v);
    }
}
using System;

namespace UnityEngine.UIElements
{
    public struct StyleFont : IEquatable<StyleFont>, IStyleValue<Font>
    {
        public StyleFont(Font v);
        public StyleFont(StyleKeyword keyword);

        public Font value { get; set; }
        public StyleKeyword keyword { get; set; }

        public bool Equals(StyleFont other);
        public override bool Equals(object obj);
        public override int GetHashCode();
        public override string ToString();

        public static bool operator ==(StyleFont lhs, StyleFont rhs);
        public static bool operator !=(StyleFont lhs, StyleFont rhs);

        public static implicit operator StyleFont(StyleKeyword keyword);
        public static implicit operator StyleFont(Font v);
    }
}
using System;

namespace UnityEngine.UIElements
{
    public struct StyleInt : IEquatable<StyleInt>, IStyleValue<int>
    {
        public StyleInt(int v);
        public StyleInt(StyleKeyword keyword);

        public int value { get; set; }
        public StyleKeyword keyword { get; set; }

        public bool Equals(StyleInt other);
        public override bool Equals(object obj);
        public override int GetHashCode();
        public override string ToString();

        public static bool operator ==(StyleInt lhs, StyleInt rhs);
        public static bool operator !=(StyleInt lhs, StyleInt rhs);

        public static implicit operator StyleInt(StyleKeyword keyword);
        public static implicit operator StyleInt(int v);
    }
}
using System;

namespace UnityEngine.UIElements
{
    public struct StyleLength : IEquatable<StyleLength>, IStyleValue<Length>
    {
        public StyleLength(float v);
        public StyleLength(Length v);
        public StyleLength(StyleKeyword keyword);

        public Length value { get; set; }
        public StyleKeyword keyword { get; set; }

        public bool Equals(StyleLength other);
        public override bool Equals(object obj);
        public override int GetHashCode();
        public override string ToString();

        public static bool operator ==(StyleLength lhs, StyleLength rhs);
        public static bool operator !=(StyleLength lhs, StyleLength rhs);

        public static implicit operator StyleLength(StyleKeyword keyword);
        public static implicit operator StyleLength(float v);
        public static implicit operator StyleLength(Length v);
    }
}
namespace UnityEngine.UIElements
{
    public enum StyleKeyword
    {
        Undefined = 0,
        Null = 1,
        Auto = 2,
        None = 3,
        Initial = 4
    }
}
namespace UnityEngine.UIElements
{
    public interface IResolvedStyle
    {
        Align alignContent { get; }
        Align alignItems { get; }
        Align alignSelf { get; }
        Color backgroundColor { get; }
        Background backgroundImage { get; }
        Color borderBottomColor { get; }
        float borderBottomLeftRadius { get; }
        float borderBottomRightRadius { get; }
        float borderBottomWidth { get; }
        Color borderLeftColor { get; }
        float borderLeftWidth { get; }
        Color borderRightColor { get; }
        float borderRightWidth { get; }
        Color borderTopColor { get; }
        float borderTopLeftRadius { get; }
        float borderTopRightRadius { get; }
        float borderTopWidth { get; }
        float bottom { get; }
        Color color { get; }
        DisplayStyle display { get; }
        StyleFloat flexBasis { get; }
        FlexDirection flexDirection { get; }
        float flexGrow { get; }
        float flexShrink { get; }
        Wrap flexWrap { get; }
        float fontSize { get; }
        float height { get; }
        Justify justifyContent { get; }
        float left { get; }
        float marginBottom { get; }
        float marginLeft { get; }
        float marginRight { get; }
        float marginTop { get; }
        StyleFloat maxHeight { get; }
        StyleFloat maxWidth { get; }
        StyleFloat minHeight { get; }
        StyleFloat minWidth { get; }
        float opacity { get; }
        float paddingBottom { get; }
        float paddingLeft { get; }
        float paddingRight { get; }
        float paddingTop { get; }
        Position position { get; }
        float right { get; }
        TextOverflow textOverflow { get; }
        float top { get; }
        Color unityBackgroundImageTintColor { get; }
        ScaleMode unityBackgroundScaleMode { get; }
        Font unityFont { get; }
        FontStyle unityFontStyleAndWeight { get; }
        int unitySliceBottom { get; }
        int unitySliceLeft { get; }
        int unitySliceRight { get; }
        int unitySliceTop { get; }
        TextAnchor unityTextAlign { get; }
        TextOverflowPosition unityTextOverflowPosition { get; }
        Visibility visibility { get; }
        WhiteSpace whiteSpace { get; }
        float width { get; }
    }
}
namespace UnityEngine.UIElements
{
    public interface IStyle
    {
        StyleEnum<Align> alignContent { get; set; }
        StyleEnum<Align> alignItems { get; set; }
        StyleEnum<Align> alignSelf { get; set; }
        StyleColor backgroundColor { get; set; }
        StyleBackground backgroundImage { get; set; }
        StyleColor borderBottomColor { get; set; }
        StyleLength borderBottomLeftRadius { get; set; }
        StyleLength borderBottomRightRadius { get; set; }
        StyleFloat borderBottomWidth { get; set; }
        StyleColor borderLeftColor { get; set; }
        StyleFloat borderLeftWidth { get; set; }
        StyleColor borderRightColor { get; set; }
        StyleFloat borderRightWidth { get; set; }
        StyleColor borderTopColor { get; set; }
        StyleLength borderTopLeftRadius { get; set; }
        StyleLength borderTopRightRadius { get; set; }
        StyleFloat borderTopWidth { get; set; }
        StyleLength bottom { get; set; }
        StyleColor color { get; set; }
        StyleCursor cursor { get; set; }
        StyleEnum<DisplayStyle> display { get; set; }
        StyleLength flexBasis { get; set; }
        StyleEnum<FlexDirection> flexDirection { get; set; }
        StyleFloat flexGrow { get; set; }
        StyleFloat flexShrink { get; set; }
        StyleEnum<Wrap> flexWrap { get; set; }
        StyleLength fontSize { get; set; }
        StyleLength height { get; set; }
        StyleEnum<Justify> justifyContent { get; set; }
        StyleLength left { get; set; }
        StyleLength marginBottom { get; set; }
        StyleLength marginLeft { get; set; }
        StyleLength marginRight { get; set; }
        StyleLength marginTop { get; set; }
        StyleLength maxHeight { get; set; }
        StyleLength maxWidth { get; set; }
        StyleLength minHeight { get; set; }
        StyleLength minWidth { get; set; }
        StyleFloat opacity { get; set; }
        StyleEnum<Overflow> overflow { get; set; }
        StyleLength paddingBottom { get; set; }
        StyleLength paddingLeft { get; set; }
        StyleLength paddingRight { get; set; }
        StyleLength paddingTop { get; set; }
        StyleEnum<Position> position { get; set; }
        StyleLength right { get; set; }
        StyleEnum<TextOverflow> textOverflow { get; set; }
        StyleLength top { get; set; }
        StyleColor unityBackgroundImageTintColor { get; set; }
        StyleEnum<ScaleMode> unityBackgroundScaleMode { get; set; }
        StyleFont unityFont { get; set; }
        StyleEnum<FontStyle> unityFontStyleAndWeight { get; set; }
        StyleEnum<OverflowClipBox> unityOverflowClipBox { get; set; }
        StyleInt unitySliceBottom { get; set; }
        StyleInt unitySliceLeft { get; set; }
        StyleInt unitySliceRight { get; set; }
        StyleInt unitySliceTop { get; set; }
        StyleEnum<TextAnchor> unityTextAlign { get; set; }
        StyleEnum<TextOverflowPosition> unityTextOverflowPosition { get; set; }
        StyleEnum<Visibility> visibility { get; set; }
        StyleEnum<WhiteSpace> whiteSpace { get; set; }
        StyleLength width { get; set; }
    }
}
namespace UnityEngine.UIElements
{
    public class StyleSheet : ScriptableObject
    {
        public StyleSheet();

        public int contentHash { get; set; }
    }
}
namespace UnityEngine.UIElements
{
    public class ThemeStyleSheet : StyleSheet
    {
        public ThemeStyleSheet();
    }
}
namespace UnityEngine.UIElements
{
    public interface IUxmlAttributes
    {
        bool TryGetAttributeValue(string attributeName, out string value);
    }
}
namespace UnityEngine.UIElements
{
    public class UxmlRootElementFactory : UxmlFactory<VisualElement, UxmlRootElementTraits>
    {
        public UxmlRootElementFactory();

        public override string uxmlName { get; }
        public override string uxmlQualifiedName { get; }
        public override string substituteForTypeName { get; }
        public override string substituteForTypeNamespace { get; }
        public override string substituteForTypeQualifiedName { get; }

        public override VisualElement Create(IUxmlAttributes bag, CreationContext cc);
    }
}
using System.Collections.Generic;

namespace UnityEngine.UIElements
{
    public class UxmlRootElementTraits : UxmlTraits
    {
        protected UxmlStringAttributeDescription m_Name;

        public UxmlRootElementTraits();

        public override IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription { get; }
    }
}
namespace UnityEngine.UIElements
{
    public class UxmlStyleFactory : UxmlFactory<VisualElement, UxmlStyleTraits>
    {
        public UxmlStyleFactory();

        public override string uxmlName { get; }
        public override string uxmlQualifiedName { get; }
        public override string substituteForTypeName { get; }
        public override string substituteForTypeNamespace { get; }
        public override string substituteForTypeQualifiedName { get; }

        public override VisualElement Create(IUxmlAttributes bag, CreationContext cc);
    }
}
using System.Collections.Generic;

namespace UnityEngine.UIElements
{
    public class UxmlStyleTraits : UxmlTraits
    {
        public UxmlStyleTraits();

        public override IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription { get; }
    }
}
namespace UnityEngine.UIElements
{
    public class UxmlTemplateFactory : UxmlFactory<VisualElement, UxmlTemplateTraits>
    {
        public UxmlTemplateFactory();

        public override string uxmlName { get; }
        public override string uxmlQualifiedName { get; }
        public override string substituteForTypeName { get; }
        public override string substituteForTypeNamespace { get; }
        public override string substituteForTypeQualifiedName { get; }

        public override VisualElement Create(IUxmlAttributes bag, CreationContext cc);
    }
}
using System.Collections.Generic;

namespace UnityEngine.UIElements
{
    public class UxmlTemplateTraits : UxmlTraits
    {
        public UxmlTemplateTraits();

        public override IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription { get; }
    }
}
namespace UnityEngine.UIElements
{
    public class UxmlAttributeOverridesFactory : UxmlFactory<VisualElement, UxmlAttributeOverridesTraits>
    {
        public UxmlAttributeOverridesFactory();

        public override string uxmlName { get; }
        public override string uxmlQualifiedName { get; }
        public override string substituteForTypeName { get; }
        public override string substituteForTypeNamespace { get; }
        public override string substituteForTypeQualifiedName { get; }

        public override VisualElement Create(IUxmlAttributes bag, CreationContext cc);
    }
}
using System.Collections.Generic;

namespace UnityEngine.UIElements
{
    public class UxmlAttributeOverridesTraits : UxmlTraits
    {
        public UxmlAttributeOverridesTraits();

        public override IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription { get; }
    }
}
using System;
using System.Collections.Generic;

namespace UnityEngine.UIElements
{
    public abstract class UxmlAttributeDescription
    {
        protected const string xmlSchemaNamespace = "http://www.w3.org/2001/XMLSchema";

        protected UxmlAttributeDescription();

        public string name { get; set; }
        public IEnumerable<string> obsoleteNames { get; set; }
        public string type { get; protected set; }
        public string typeNamespace { get; protected set; }
        public abstract string defaultValueAsString { get; }
        public Use use { get; set; }
        public UxmlTypeRestriction restriction { get; set; }

        protected bool TryGetValueFromBag<T>(IUxmlAttributes bag, CreationContext cc, Func<string, T, T> converterFunc, T defaultValue, ref T value);
        protected T GetValueFromBag<T>(IUxmlAttributes bag, CreationContext cc, Func<string, T, T> converterFunc, T defaultValue);

        public enum Use
        {
            None = 0,
            Optional = 1,
            Prohibited = 2,
            Required = 3
        }
    }
}
namespace UnityEngine.UIElements
{
    public abstract class TypedUxmlAttributeDescription<T> : UxmlAttributeDescription
    {
        protected TypedUxmlAttributeDescription();

        public T defaultValue { get; set; }
        public override string defaultValueAsString { get; }

        public abstract T GetValueFromBag(IUxmlAttributes bag, CreationContext cc);
    }
}
namespace UnityEngine.UIElements
{
    public class UxmlStringAttributeDescription : TypedUxmlAttributeDescription<string>
    {
        public UxmlStringAttributeDescription();

        public override string defaultValueAsString { get; }

        public override string GetValueFromBag(IUxmlAttributes bag, CreationContext cc);
        public bool TryGetValueFromBag(IUxmlAttributes bag, CreationContext cc, ref string value);
    }
}
namespace UnityEngine.UIElements
{
    public class UxmlFloatAttributeDescription : TypedUxmlAttributeDescription<float>
    {
        public UxmlFloatAttributeDescription();

        public override string defaultValueAsString { get; }

        public override float GetValueFromBag(IUxmlAttributes bag, CreationContext cc);
        public bool TryGetValueFromBag(IUxmlAttributes bag, CreationContext cc, ref float value);
    }
}
namespace UnityEngine.UIElements
{
    public class UxmlDoubleAttributeDescription : TypedUxmlAttributeDescription<double>
    {
        public UxmlDoubleAttributeDescription();

        public override string defaultValueAsString { get; }

        public override double GetValueFromBag(IUxmlAttributes bag, CreationContext cc);
        public bool TryGetValueFromBag(IUxmlAttributes bag, CreationContext cc, ref double value);
    }
}
namespace UnityEngine.UIElements
{
    public class UxmlIntAttributeDescription : TypedUxmlAttributeDescription<int>
    {
        public UxmlIntAttributeDescription();

        public override string defaultValueAsString { get; }

        public override int GetValueFromBag(IUxmlAttributes bag, CreationContext cc);
        public bool TryGetValueFromBag(IUxmlAttributes bag, CreationContext cc, ref int value);
    }
}
namespace UnityEngine.UIElements
{
    public class UxmlLongAttributeDescription : TypedUxmlAttributeDescription<long>
    {
        public UxmlLongAttributeDescription();

        public override string defaultValueAsString { get; }

        public override long GetValueFromBag(IUxmlAttributes bag, CreationContext cc);
        public bool TryGetValueFromBag(IUxmlAttributes bag, CreationContext cc, ref long value);
    }
}
namespace UnityEngine.UIElements
{
    public class UxmlBoolAttributeDescription : TypedUxmlAttributeDescription<bool>
    {
        public UxmlBoolAttributeDescription();

        public override string defaultValueAsString { get; }

        public override bool GetValueFromBag(IUxmlAttributes bag, CreationContext cc);
        public bool TryGetValueFromBag(IUxmlAttributes bag, CreationContext cc, ref bool value);
    }
}
namespace UnityEngine.UIElements
{
    public class UxmlColorAttributeDescription : TypedUxmlAttributeDescription<Color>
    {
        public UxmlColorAttributeDescription();

        public override string defaultValueAsString { get; }

        public override Color GetValueFromBag(IUxmlAttributes bag, CreationContext cc);
        public bool TryGetValueFromBag(IUxmlAttributes bag, CreationContext cc, ref Color value);
    }
}
using System;

namespace UnityEngine.UIElements
{
    public class UxmlTypeAttributeDescription<TBase> : TypedUxmlAttributeDescription<Type>
    {
        public UxmlTypeAttributeDescription();

        public override string defaultValueAsString { get; }

        public override Type GetValueFromBag(IUxmlAttributes bag, CreationContext cc);
        public bool TryGetValueFromBag(IUxmlAttributes bag, CreationContext cc, ref Type value);
    }
}
using System;

namespace UnityEngine.UIElements
{
    public class UxmlEnumAttributeDescription<T> : TypedUxmlAttributeDescription<T> where T : IConvertible, struct
    {
        public UxmlEnumAttributeDescription();

        public override string defaultValueAsString { get; }

        public override T GetValueFromBag(IUxmlAttributes bag, CreationContext cc);
        public bool TryGetValueFromBag(IUxmlAttributes bag, CreationContext cc, ref T value);
    }
}
using System;

namespace UnityEngine.UIElements
{
    public class UxmlChildElementDescription
    {
        public UxmlChildElementDescription(Type t);

        public string elementName { get; protected set; }
        public string elementNamespace { get; protected set; }
    }
}
using System.Collections.Generic;

namespace UnityEngine.UIElements
{
    public abstract class UxmlTraits
    {
        protected UxmlTraits();

        public bool canHaveAnyAttribute { get; protected set; }
        public virtual IEnumerable<UxmlAttributeDescription> uxmlAttributesDescription { get; }
        public virtual IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription { get; }

        public virtual void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
    }
}
using System.Collections.Generic;

namespace UnityEngine.UIElements
{
    public interface IUxmlFactory
    {
        string uxmlName { get; }
        string uxmlNamespace { get; }
        string uxmlQualifiedName { get; }
        bool canHaveAnyAttribute { get; }
        IEnumerable<UxmlAttributeDescription> uxmlAttributesDescription { get; }
        IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription { get; }
        string substituteForTypeName { get; }
        string substituteForTypeNamespace { get; }
        string substituteForTypeQualifiedName { get; }

        bool AcceptsAttributeBag(IUxmlAttributes bag, CreationContext cc);
        VisualElement Create(IUxmlAttributes bag, CreationContext cc);
    }
}
using System.Collections.Generic;

namespace UnityEngine.UIElements
{
    public class UxmlFactory<TCreatedType, TTraits> : IUxmlFactory where TCreatedType : VisualElement, new() where TTraits : UxmlTraits, new()
    {
        protected UxmlFactory();

        public virtual string uxmlName { get; }
        public virtual string uxmlNamespace { get; }
        public virtual string uxmlQualifiedName { get; }
        public bool canHaveAnyAttribute { get; }
        public virtual IEnumerable<UxmlAttributeDescription> uxmlAttributesDescription { get; }
        public virtual IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription { get; }
        public virtual string substituteForTypeName { get; }
        public virtual string substituteForTypeNamespace { get; }
        public virtual string substituteForTypeQualifiedName { get; }

        public virtual bool AcceptsAttributeBag(IUxmlAttributes bag, CreationContext cc);
        public virtual VisualElement Create(IUxmlAttributes bag, CreationContext cc);
    }
}
namespace UnityEngine.UIElements
{
    public class UxmlFactory<TCreatedType> : UxmlFactory<TCreatedType, VisualElement.UxmlTraits> where TCreatedType : VisualElement, new()
    {
        public UxmlFactory();
    }
}
using System;

namespace UnityEngine.UIElements
{
    public abstract class UxmlTypeRestriction : IEquatable<UxmlTypeRestriction>
    {
        protected UxmlTypeRestriction();

        public virtual bool Equals(UxmlTypeRestriction other);
    }
}
namespace UnityEngine.UIElements
{
    public class UxmlValueMatches : UxmlTypeRestriction
    {
        public UxmlValueMatches();

        public string regex { get; set; }

        public override bool Equals(UxmlTypeRestriction other);
    }
}
namespace UnityEngine.UIElements
{
    public class UxmlValueBounds : UxmlTypeRestriction
    {
        public UxmlValueBounds();

        public string min { get; set; }
        public string max { get; set; }
        public bool excludeMin { get; set; }
        public bool excludeMax { get; set; }

        public override bool Equals(UxmlTypeRestriction other);
    }
}
using System.Collections.Generic;

namespace UnityEngine.UIElements
{
    public class UxmlEnumeration : UxmlTypeRestriction
    {
        public UxmlEnumeration();

        public IEnumerable<string> values { get; set; }

        public override bool Equals(UxmlTypeRestriction other);
    }
}
namespace UnityEngine.UIElements
{
    public class VectorImage : ScriptableObject
    {
        public VectorImage();
    }
}
using System.Collections.Generic;

namespace UnityEngine.UIElements
{
    public class VisualTreeAsset : ScriptableObject
    {
        public VisualTreeAsset();

        public IEnumerable<VisualTreeAsset> templateDependencies { get; }
        public IEnumerable<StyleSheet> stylesheets { get; }
        public int contentHash { get; set; }

        public TemplateContainer Instantiate();
        public TemplateContainer Instantiate(string bindingPath);
        public TemplateContainer CloneTree();
        public TemplateContainer CloneTree(string bindingPath);
        public void CloneTree(VisualElement target);
        public void CloneTree(VisualElement target, out int firstElementIndex, out int elementAddedCount);
    }
}
using System;
using System.Collections.Generic;

namespace UnityEngine.UIElements
{
    public struct CreationContext : IEquatable<CreationContext>
    {
        public static readonly CreationContext Default;

        public VisualElement target { get; }
        public VisualTreeAsset visualTreeAsset { get; }
        public Dictionary<string, VisualElement> slotInsertionPoints { get; }

        public override bool Equals(object obj);
        public bool Equals(CreationContext other);
        public override int GetHashCode();

        public static bool operator ==(CreationContext context1, CreationContext context2);
        public static bool operator !=(CreationContext context1, CreationContext context2);
    }
}
namespace UnityEngine.UIElements.Experimental
{
    public static class Easing
    {
        public static float Step(float t);
        public static float Linear(float t);
        public static float InSine(float t);
        public static float OutSine(float t);
        public static float InOutSine(float t);
        public static float InQuad(float t);
        public static float OutQuad(float t);
        public static float InOutQuad(float t);
        public static float InCubic(float t);
        public static float OutCubic(float t);
        public static float InOutCubic(float t);
        public static float InPower(float t, int power);
        public static float OutPower(float t, int power);
        public static float InOutPower(float t, int power);
        public static float InBounce(float t);
        public static float OutBounce(float t);
        public static float InOutBounce(float t);
        public static float InElastic(float t);
        public static float OutElastic(float t);
        public static float InOutElastic(float t);
        public static float InBack(float t);
        public static float OutBack(float t);
        public static float InOutBack(float t);
        public static float InBack(float t, float s);
        public static float OutBack(float t, float s);
        public static float InOutBack(float t, float s);
        public static float InCirc(float t);
        public static float OutCirc(float t);
        public static float InOutCirc(float t);
    }
}
namespace UnityEngine.UIElements.Experimental
{
    public struct StyleValues
    {
        public float top { get; set; }
        public float left { get; set; }
        public float width { get; set; }
        public float height { get; set; }
        public float right { get; set; }
        public float bottom { get; set; }
        public Color color { get; set; }
        public Color backgroundColor { get; set; }
        public Color unityBackgroundImageTintColor { get; set; }
        public Color borderColor { get; set; }
        public float marginLeft { get; set; }
        public float marginTop { get; set; }
        public float marginRight { get; set; }
        public float marginBottom { get; set; }
        public float paddingLeft { get; set; }
        public float paddingTop { get; set; }
        public float paddingRight { get; set; }
        public float paddingBottom { get; set; }
        public float borderLeftWidth { get; set; }
        public float borderRightWidth { get; set; }
        public float borderTopWidth { get; set; }
        public float borderBottomWidth { get; set; }
        public float borderTopLeftRadius { get; set; }
        public float borderTopRightRadius { get; set; }
        public float borderBottomLeftRadius { get; set; }
        public float borderBottomRightRadius { get; set; }
        public float opacity { get; set; }
        public float flexGrow { get; set; }
        public float flexShrink { get; set; }
    }
}
using System;

namespace UnityEngine.UIElements.Experimental
{
    public interface ITransitionAnimations
    {
        ValueAnimation<float> Start(float from, float to, int durationMs, Action<VisualElement, float> onValueChanged);
        ValueAnimation<Rect> Start(Rect from, Rect to, int durationMs, Action<VisualElement, Rect> onValueChanged);
        ValueAnimation<Color> Start(Color from, Color to, int durationMs, Action<VisualElement, Color> onValueChanged);
        ValueAnimation<Vector3> Start(Vector3 from, Vector3 to, int durationMs, Action<VisualElement, Vector3> onValueChanged);
        ValueAnimation<Vector2> Start(Vector2 from, Vector2 to, int durationMs, Action<VisualElement, Vector2> onValueChanged);
        ValueAnimation<Quaternion> Start(Quaternion from, Quaternion to, int durationMs, Action<VisualElement, Quaternion> onValueChanged);
        ValueAnimation<StyleValues> Start(StyleValues from, StyleValues to, int durationMs);
        ValueAnimation<StyleValues> Start(StyleValues to, int durationMs);
        ValueAnimation<float> Start(Func<VisualElement, float> fromValueGetter, float to, int durationMs, Action<VisualElement, float> onValueChanged);
        ValueAnimation<Rect> Start(Func<VisualElement, Rect> fromValueGetter, Rect to, int durationMs, Action<VisualElement, Rect> onValueChanged);
        ValueAnimation<Color> Start(Func<VisualElement, Color> fromValueGetter, Color to, int durationMs, Action<VisualElement, Color> onValueChanged);
        ValueAnimation<Vector3> Start(Func<VisualElement, Vector3> fromValueGetter, Vector3 to, int durationMs, Action<VisualElement, Vector3> onValueChanged);
        ValueAnimation<Vector2> Start(Func<VisualElement, Vector2> fromValueGetter, Vector2 to, int durationMs, Action<VisualElement, Vector2> onValueChanged);
        ValueAnimation<Quaternion> Start(Func<VisualElement, Quaternion> fromValueGetter, Quaternion to, int durationMs, Action<VisualElement, Quaternion> onValueChanged);
        ValueAnimation<Rect> Layout(Rect to, int durationMs);
        ValueAnimation<Vector2> TopLeft(Vector2 to, int durationMs);
        ValueAnimation<Vector2> Size(Vector2 to, int durationMs);
        ValueAnimation<float> Scale(float to, int duration);
        ValueAnimation<Vector3> Position(Vector3 to, int duration);
        ValueAnimation<Quaternion> Rotation(Quaternion to, int duration);
    }
}
namespace UnityEngine.UIElements.Experimental
{
    public interface IValueAnimation
    {
        bool isRunning { get; }
        int durationMs { get; set; }

        void Start();
        void Stop();
        void Recycle();
    }
}
using System;

namespace UnityEngine.UIElements.Experimental
{
    public sealed class ValueAnimation<T> : IValueAnimationUpdate, IValueAnimation
    {
        public ValueAnimation();

        public int durationMs { get; set; }
        public Func<float, float> easingCurve { get; set; }
        public bool isRunning { get; }
        public Action onAnimationCompleted { get; set; }
        public bool autoRecycle { get; set; }
        public Action<VisualElement, T> valueUpdated { get; set; }
        public Func<VisualElement, T> initialValue { get; set; }
        public Func<T, T, float, T> interpolator { get; set; }
        public T from { get; set; }
        public T to { get; set; }

        public void Start();
        public void Stop();
        public void Recycle();
        public static ValueAnimation<T> Create(VisualElement e, Func<T, T, float, T> interpolator);
        public ValueAnimation<T> Ease(Func<float, float> easing);
        public ValueAnimation<T> OnCompleted(Action callback);
        public ValueAnimation<T> KeepAlive();
    }
}
-------- {UnityEngine.UIElementsNativeModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.UIElementsNativeModule.dll)}:   41 --------
-------- {UnityEngine.UNETModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.UNETModule.dll)}:   48 --------
using System;
using System.Net;
using UnityEngine.Bindings;
using UnityEngine.Networking.Types;

namespace UnityEngine.Networking
{
    [NativeHeader("Modules/UNET/UNETManager.h")]
    [NativeHeader("Modules/UNET/UNETConfiguration.h")]
    [NativeConditional("ENABLE_NETWORK && ENABLE_UNET", True)]
    [Obsolete("The UNET transport will be removed in the future as soon a replacement is ready.")]
    [NativeHeader("Modules/UNET/UNetTypes.h")]
    public sealed class NetworkTransport
    {
        public static bool IsStarted { get; }

        public static bool DoesEndPointUsePlatformProtocols(EndPoint endPoint);
        public static int ConnectEndPoint(int hostId, EndPoint endPoint, int exceptionConnectionId, out byte error);
        public static void Init();
        public static void Init(GlobalConfig config);
        public static void Shutdown();
        [Obsolete("This function has been deprecated. Use AssetDatabase utilities instead.")]
        public static string GetAssetId(GameObject go);
        public static void AddSceneId(int id);
        public static int GetNextSceneId();
        public static int AddHostWithSimulator(HostTopology topology, int minTimeout, int maxTimeout, int port, string ip);
        public static int AddHostWithSimulator(HostTopology topology, int minTimeout, int maxTimeout, int port);
        public static int AddHostWithSimulator(HostTopology topology, int minTimeout, int maxTimeout);
        public static int AddHost(HostTopology topology, int port, string ip);
        public static int AddHost(HostTopology topology, int port);
        public static int AddHost(HostTopology topology);
        public static int AddWebsocketHost(HostTopology topology, int port, string ip);
        public static int AddWebsocketHost(HostTopology topology, int port);
        public static void ConnectAsNetworkHost(int hostId, string address, int port, NetworkID network, SourceID source, NodeID node, out byte error);
        [FreeFunction("UNETManager::Get()->DisconnectNetworkHost", ThrowsException = True)]
        public static void DisconnectNetworkHost(int hostId, out byte error);
        public static NetworkEventType ReceiveRelayEventFromHost(int hostId, out byte error);
        public static int ConnectToNetworkPeer(int hostId, string address, int port, int exceptionConnectionId, int relaySlotId, NetworkID network, SourceID source, NodeID node, int bytesPerSec, float bucketSizeFactor, out byte error);
        public static int ConnectToNetworkPeer(int hostId, string address, int port, int exceptionConnectionId, int relaySlotId, NetworkID network, SourceID source, NodeID node, out byte error);
        [Obsolete("GetCurrentIncomingMessageAmount has been deprecated.")]
        public static int GetCurrentIncomingMessageAmount();
        [Obsolete("GetCurrentOutgoingMessageAmount has been deprecated.")]
        public static int GetCurrentOutgoingMessageAmount();
        [FreeFunction("UNETManager::Get()->GetIncomingMessageQueueSize", ThrowsException = True)]
        public static int GetIncomingMessageQueueSize(int hostId, out byte error);
        [FreeFunction("UNETManager::Get()->GetOutgoingMessageQueueSize", ThrowsException = True)]
        public static int GetOutgoingMessageQueueSize(int hostId, out byte error);
        [FreeFunction("UNETManager::Get()->GetCurrentRTT", ThrowsException = True)]
        public static int GetCurrentRTT(int hostId, int connectionId, out byte error);
        [Obsolete("GetCurrentRtt() has been deprecated.")]
        public static int GetCurrentRtt(int hostId, int connectionId, out byte error);
        [FreeFunction("UNETManager::Get()->GetIncomingPacketLossCount", ThrowsException = True)]
        public static int GetIncomingPacketLossCount(int hostId, int connectionId, out byte error);
        [Obsolete("GetNetworkLostPacketNum() has been deprecated.")]
        public static int GetNetworkLostPacketNum(int hostId, int connectionId, out byte error);
        [FreeFunction("UNETManager::Get()->GetIncomingPacketCount", ThrowsException = True)]
        public static int GetIncomingPacketCount(int hostId, int connectionId, out byte error);
        [FreeFunction("UNETManager::Get()->GetOutgoingPacketNetworkLossPercent", ThrowsException = True)]
        public static int GetOutgoingPacketNetworkLossPercent(int hostId, int connectionId, out byte error);
        [FreeFunction("UNETManager::Get()->GetOutgoingPacketOverflowLossPercent", ThrowsException = True)]
        public static int GetOutgoingPacketOverflowLossPercent(int hostId, int connectionId, out byte error);
        [FreeFunction("UNETManager::Get()->GetMaxAllowedBandwidth", ThrowsException = True)]
        public static int GetMaxAllowedBandwidth(int hostId, int connectionId, out byte error);
        [FreeFunction("UNETManager::Get()->GetAckBufferCount", ThrowsException = True)]
        public static int GetAckBufferCount(int hostId, int connectionId, out byte error);
        [FreeFunction("UNETManager::Get()->GetIncomingPacketDropCountForAllHosts", ThrowsException = True)]
        public static int GetIncomingPacketDropCountForAllHosts();
        [FreeFunction("UNETManager::Get()->GetIncomingPacketCountForAllHosts", ThrowsException = True)]
        public static int GetIncomingPacketCountForAllHosts();
        [FreeFunction("UNETManager::Get()->GetOutgoingPacketCount", ThrowsException = True)]
        public static int GetOutgoingPacketCount();
        [FreeFunction("UNETManager::Get()->GetOutgoingPacketCount", ThrowsException = True)]
        public static int GetOutgoingPacketCountForHost(int hostId, out byte error);
        [FreeFunction("UNETManager::Get()->GetOutgoingPacketCount", ThrowsException = True)]
        public static int GetOutgoingPacketCountForConnection(int hostId, int connectionId, out byte error);
        [FreeFunction("UNETManager::Get()->GetOutgoingMessageCount", ThrowsException = True)]
        public static int GetOutgoingMessageCount();
        [FreeFunction("UNETManager::Get()->GetOutgoingMessageCount", ThrowsException = True)]
        public static int GetOutgoingMessageCountForHost(int hostId, out byte error);
        [FreeFunction("UNETManager::Get()->GetOutgoingMessageCount", ThrowsException = True)]
        public static int GetOutgoingMessageCountForConnection(int hostId, int connectionId, out byte error);
        [FreeFunction("UNETManager::Get()->GetOutgoingUserBytesCount", ThrowsException = True)]
        public static int GetOutgoingUserBytesCount();
        [FreeFunction("UNETManager::Get()->GetOutgoingUserBytesCount", ThrowsException = True)]
        public static int GetOutgoingUserBytesCountForHost(int hostId, out byte error);
        [FreeFunction("UNETManager::Get()->GetOutgoingUserBytesCount", ThrowsException = True)]
        public static int GetOutgoingUserBytesCountForConnection(int hostId, int connectionId, out byte error);
        [FreeFunction("UNETManager::Get()->GetOutgoingSystemBytesCount", ThrowsException = True)]
        public static int GetOutgoingSystemBytesCount();
        [FreeFunction("UNETManager::Get()->GetOutgoingSystemBytesCount", ThrowsException = True)]
        public static int GetOutgoingSystemBytesCountForHost(int hostId, out byte error);
        [FreeFunction("UNETManager::Get()->GetOutgoingSystemBytesCount", ThrowsException = True)]
        public static int GetOutgoingSystemBytesCountForConnection(int hostId, int connectionId, out byte error);
        [FreeFunction("UNETManager::Get()->GetOutgoingFullBytesCount", ThrowsException = True)]
        public static int GetOutgoingFullBytesCount();
        [FreeFunction("UNETManager::Get()->GetOutgoingFullBytesCount", ThrowsException = True)]
        public static int GetOutgoingFullBytesCountForHost(int hostId, out byte error);
        [FreeFunction("UNETManager::Get()->GetOutgoingFullBytesCount", ThrowsException = True)]
        public static int GetOutgoingFullBytesCountForConnection(int hostId, int connectionId, out byte error);
        [Obsolete("GetPacketSentRate has been deprecated.")]
        public static int GetPacketSentRate(int hostId, int connectionId, out byte error);
        [Obsolete("GetPacketReceivedRate has been deprecated.")]
        public static int GetPacketReceivedRate(int hostId, int connectionId, out byte error);
        [Obsolete("GetRemotePacketReceivedRate has been deprecated.")]
        public static int GetRemotePacketReceivedRate(int hostId, int connectionId, out byte error);
        [Obsolete("GetNetIOTimeuS has been deprecated.")]
        public static int GetNetIOTimeuS();
        [FreeFunction("UNETManager::Get()->GetConnectionInfo", ThrowsException = True)]
        public static string GetConnectionInfo(int hostId, int connectionId, out int port, out ulong network, out ushort dstNode, out byte error);
        public static void GetConnectionInfo(int hostId, int connectionId, out string address, out int port, out NetworkID network, out NodeID dstNode, out byte error);
        [FreeFunction("UNETManager::Get()->GetNetworkTimestamp", ThrowsException = True)]
        public static int GetNetworkTimestamp();
        [FreeFunction("UNETManager::Get()->GetRemoteDelayTimeMS", ThrowsException = True)]
        public static int GetRemoteDelayTimeMS(int hostId, int connectionId, int remoteTime, out byte error);
        public static bool StartSendMulticast(int hostId, int channelId, byte[] buffer, int size, out byte error);
        [FreeFunction("UNETManager::Get()->SendMulticast", ThrowsException = True)]
        public static bool SendMulticast(int hostId, int connectionId, out byte error);
        [FreeFunction("UNETManager::Get()->FinishSendMulticast", ThrowsException = True)]
        public static bool FinishSendMulticast(int hostId, out byte error);
        [FreeFunction("UNETManager::Get()->RemoveHost", ThrowsException = True)]
        public static bool RemoveHost(int hostId);
        [FreeFunction("UNETManager::Get()->Connect", ThrowsException = True)]
        public static int Connect(int hostId, string address, int port, int exeptionConnectionId, out byte error);
        public static int ConnectWithSimulator(int hostId, string address, int port, int exeptionConnectionId, out byte error, ConnectionSimulatorConfig conf);
        [FreeFunction("UNETManager::Get()->Disconnect", ThrowsException = True)]
        public static bool Disconnect(int hostId, int connectionId, out byte error);
        public static bool Send(int hostId, int connectionId, int channelId, byte[] buffer, int size, out byte error);
        public static bool QueueMessageForSending(int hostId, int connectionId, int channelId, byte[] buffer, int size, out byte error);
        [FreeFunction("UNETManager::Get()->SendQueuedMessages", ThrowsException = True)]
        public static bool SendQueuedMessages(int hostId, int connectionId, out byte error);
        public static NetworkEventType Receive(out int hostId, out int connectionId, out int channelId, byte[] buffer, int bufferSize, out int receivedSize, out byte error);
        public static NetworkEventType ReceiveFromHost(int hostId, out int connectionId, out int channelId, byte[] buffer, int bufferSize, out int receivedSize, out byte error);
        [FreeFunction("UNETManager::Get()->SetPacketStat", ThrowsException = True)]
        public static void SetPacketStat(int direction, int packetStatId, int numMsgs, int numBytes);
        [FreeFunction("UNETManager::Get()->NotifyWhenConnectionReadyForSend", ThrowsException = True)]
        public static bool NotifyWhenConnectionReadyForSend(int hostId, int connectionId, int notificationLevel, out byte error);
        [FreeFunction("UNETManager::Get()->GetHostPort", ThrowsException = True)]
        public static int GetHostPort(int hostId);
        public static bool StartBroadcastDiscovery(int hostId, int broadcastPort, int key, int version, int subversion, byte[] buffer, int size, int timeout, out byte error);
        [FreeFunction("UNETManager::Get()->StopBroadcastDiscovery", ThrowsException = True)]
        public static void StopBroadcastDiscovery();
        [FreeFunction("UNETManager::Get()->IsBroadcastDiscoveryRunning", ThrowsException = True)]
        public static bool IsBroadcastDiscoveryRunning();
        [FreeFunction("UNETManager::Get()->SetBroadcastCredentials", ThrowsException = True)]
        public static void SetBroadcastCredentials(int hostId, int key, int version, int subversion, out byte error);
        [FreeFunction("UNETManager::Get()->GetBroadcastConnectionInfoInternal", ThrowsException = True)]
        public static string GetBroadcastConnectionInfo(int hostId, out int port, out byte error);
        public static void GetBroadcastConnectionInfo(int hostId, out string address, out int port, out byte error);
        public static void GetBroadcastConnectionMessage(int hostId, byte[] buffer, int bufferSize, out int receivedSize, out byte error);
        [FreeFunction("UNETManager::SetMulticastLock")]
        public static void SetMulticastLock(bool enabled);
        public static bool LoadEncryptionLibrary(string libraryName);
        public static void UnloadEncryptionLibrary();
        public static bool IsEncryptionActive();
        public static short GetEncryptionSafeMaxPacketSize(short maxPacketSize);
    }
}
namespace UnityEngine.Networking
{
    public enum NetworkEventType
    {
        DataEvent = 0,
        ConnectEvent = 1,
        DisconnectEvent = 2,
        Nothing = 3,
        BroadcastEvent = 4
    }
}
namespace UnityEngine.Networking
{
    public enum QosType
    {
        Unreliable = 0,
        UnreliableFragmented = 1,
        UnreliableSequenced = 2,
        Reliable = 3,
        ReliableFragmented = 4,
        ReliableSequenced = 5,
        StateUpdate = 6,
        ReliableStateUpdate = 7,
        AllCostDelivery = 8,
        UnreliableFragmentedSequenced = 9,
        ReliableFragmentedSequenced = 10
    }
}
namespace UnityEngine.Networking
{
    public enum NetworkError
    {
        Ok = 0,
        WrongHost = 1,
        WrongConnection = 2,
        WrongChannel = 3,
        NoResources = 4,
        BadMessage = 5,
        Timeout = 6,
        MessageToLong = 7,
        WrongOperation = 8,
        VersionMismatch = 9,
        CRCMismatch = 10,
        DNSFailure = 11,
        UsageError = 12
    }
}
namespace UnityEngine.Networking
{
    public enum ReactorModel
    {
        SelectReactor = 0,
        FixRateReactor = 1
    }
}
namespace UnityEngine.Networking
{
    public enum ConnectionAcksType
    {
        Acks32 = 1,
        Acks64 = 2,
        Acks96 = 3,
        Acks128 = 4
    }
}
using System;

namespace UnityEngine.Networking
{
    [Obsolete("The UNET transport will be removed in the future as soon a replacement is ready.")]
    public class ChannelQOS
    {
        public ChannelQOS(QosType value);
        public ChannelQOS();
        public ChannelQOS(ChannelQOS channel);

        public QosType QOS { get; }
        public bool BelongsToSharedOrderChannel { get; }
    }
}
using System;
using System.Collections.Generic;

namespace UnityEngine.Networking
{
    [Obsolete("The UNET transport will be removed in the future as soon a replacement is ready.")]
    public class ConnectionConfig
    {
        public ConnectionConfig();
        public ConnectionConfig(ConnectionConfig config);

        public ushort PacketSize { get; set; }
        public ushort FragmentSize { get; set; }
        public uint ResendTimeout { get; set; }
        public uint DisconnectTimeout { get; set; }
        public uint ConnectTimeout { get; set; }
        public uint MinUpdateTimeout { get; set; }
        public uint PingTimeout { get; set; }
        public uint ReducedPingTimeout { get; set; }
        public uint AllCostTimeout { get; set; }
        public byte NetworkDropThreshold { get; set; }
        public byte OverflowDropThreshold { get; set; }
        public byte MaxConnectionAttempt { get; set; }
        public uint AckDelay { get; set; }
        public uint SendDelay { get; set; }
        public ushort MaxCombinedReliableMessageSize { get; set; }
        public ushort MaxCombinedReliableMessageCount { get; set; }
        public ushort MaxSentMessageQueueSize { get; set; }
        public ConnectionAcksType AcksType { get; set; }
        [Obsolete("IsAcksLong is deprecated. Use AcksType = ConnectionAcksType.Acks64", False)]
        public bool IsAcksLong { get; set; }
        public bool UsePlatformSpecificProtocols { get; set; }
        public uint InitialBandwidth { get; set; }
        public float BandwidthPeakFactor { get; set; }
        public ushort WebSocketReceiveBufferMaxSize { get; set; }
        public uint UdpSocketReceiveBufferMaxSize { get; set; }
        public string SSLCertFilePath { get; set; }
        public string SSLPrivateKeyFilePath { get; set; }
        public string SSLCAFilePath { get; set; }
        public int ChannelCount { get; }
        public int SharedOrderChannelCount { get; }
        public List<ChannelQOS> Channels { get; }

        public static void Validate(ConnectionConfig config);
        public byte AddChannel(QosType value);
        public void MakeChannelsSharedOrder(List<byte> channelIndices);
        public QosType GetChannel(byte idx);
        public IList<byte> GetSharedOrderChannels(byte idx);
    }
}
using System;
using System.Collections.Generic;

namespace UnityEngine.Networking
{
    [Obsolete("The UNET transport will be removed in the future as soon a replacement is ready.")]
    public class HostTopology
    {
        public HostTopology(ConnectionConfig defaultConfig, int maxDefaultConnections);

        public ConnectionConfig DefaultConfig { get; }
        public int MaxDefaultConnections { get; }
        public int SpecialConnectionConfigsCount { get; }
        public List<ConnectionConfig> SpecialConnectionConfigs { get; }
        public ushort ReceivedMessagePoolSize { get; set; }
        public ushort SentMessagePoolSize { get; set; }
        public float MessagePoolSizeGrowthFactor { get; set; }

        public ConnectionConfig GetSpecialConnectionConfig(int i);
        public int AddSpecialConnectionConfig(ConnectionConfig config);
    }
}
using System;

namespace UnityEngine.Networking
{
    [Obsolete("The UNET transport will be removed in the future as soon a replacement is ready.")]
    public class GlobalConfig
    {
        public GlobalConfig();

        public uint ThreadAwakeTimeout { get; set; }
        public ReactorModel ReactorModel { get; set; }
        public ushort ReactorMaximumReceivedMessages { get; set; }
        public ushort ReactorMaximumSentMessages { get; set; }
        public ushort MaxPacketSize { get; set; }
        public ushort MaxHosts { get; set; }
        public byte ThreadPoolSize { get; set; }
        public uint MinTimerTimeout { get; set; }
        public uint MaxTimerTimeout { get; set; }
        public uint MinNetSimulatorTimeout { get; set; }
        public uint MaxNetSimulatorTimeout { get; set; }
        public Action<int> NetworkEventAvailable { get; set; }
        public Action<int, int> ConnectionReadyForSend { get; set; }
    }
}
using System;

namespace UnityEngine.Networking
{
    [Obsolete("The UNET transport will be removed in the future as soon a replacement is ready.")]
    public class ConnectionSimulatorConfig : IDisposable
    {
        public ConnectionSimulatorConfig(int outMinDelay, int outAvgDelay, int inMinDelay, int inAvgDelay, float packetLossPercentage);

        ~ConnectionSimulatorConfig();

        [ThreadAndSerializationSafe]
        public void Dispose();
    }
}
using System;
using System.ComponentModel;
using UnityEngine.Networking.Types;

namespace UnityEngine.Networking
{
    public class Utility
    {
        [Obsolete("This property is unused and should not be referenced in code.", True)]
        public static bool useRandomSourceID { get; set; }

        public static SourceID GetSourceID();
        [EditorBrowsable(Never)]
        [Obsolete("This function is unused and should not be referenced in code. Please sign in and setup your project in the editor instead.", True)]
        public static void SetAppID(AppID newAppID);
        [Obsolete("This function is unused and should not be referenced in code. Please sign in and setup your project in the editor instead.", True)]
        [EditorBrowsable(Never)]
        public static AppID GetAppID();
        public static void SetAccessTokenForNetwork(NetworkID netId, NetworkAccessToken accessToken);
        public static NetworkAccessToken GetAccessTokenForNetwork(NetworkID netId);
    }
}
using System.ComponentModel;

namespace UnityEngine.Networking.Types
{
    [DefaultValue(Invalid)]
    public enum NetworkAccessLevel
    {
        Invalid = 0,
        User = 1,
        Owner = 2,
        Admin = 4
    }
}
using System.ComponentModel;

namespace UnityEngine.Networking.Types
{
    [DefaultValue(Invalid)]
    public enum AppID
    {
        Invalid = 18446744073709551615
    }
}
using System.ComponentModel;

namespace UnityEngine.Networking.Types
{
    [DefaultValue(Invalid)]
    public enum SourceID
    {
        Invalid = 18446744073709551615
    }
}
using System.ComponentModel;

namespace UnityEngine.Networking.Types
{
    [DefaultValue(Invalid)]
    public enum NetworkID
    {
        Invalid = 18446744073709551615
    }
}
using System.ComponentModel;

namespace UnityEngine.Networking.Types
{
    [DefaultValue(Invalid)]
    public enum NodeID
    {
        Invalid = 0
    }
}
using System.ComponentModel;

namespace UnityEngine.Networking.Types
{
    [DefaultValue(Invalid)]
    public enum HostPriority
    {
        Invalid = 2147483647
    }
}
namespace UnityEngine.Networking.Types
{
    public class NetworkAccessToken
    {
        public byte[] array;

        public NetworkAccessToken();
        public NetworkAccessToken(byte[] array);
        public NetworkAccessToken(string strArray);

        public string GetByteString();
        public bool IsValid();
    }
}
using System;
using UnityEngine.Networking.Types;

namespace UnityEngine.Networking.Match
{
    [Obsolete("The matchmaker and relay feature will be removed in the future, minimal support will continue until this can be safely done.")]
    public class MatchInfo
    {
        public MatchInfo();

        public string address { get; }
        public int port { get; }
        public int domain { get; }
        public NetworkID networkId { get; }
        public NetworkAccessToken accessToken { get; }
        public NodeID nodeId { get; }
        public bool usingRelay { get; }

        public override string ToString();
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.Networking.Types;

namespace UnityEngine.Networking.Match
{
    [Obsolete("The matchmaker and relay feature will be removed in the future, minimal support will continue until this can be safely done.")]
    public class MatchInfoSnapshot
    {
        public MatchInfoSnapshot();

        public NetworkID networkId { get; }
        public NodeID hostNodeId { get; }
        public string name { get; }
        public int averageEloScore { get; }
        public int maxSize { get; }
        public int currentSize { get; }
        public bool isPrivate { get; }
        public Dictionary<string, long> matchAttributes { get; }
        public List<MatchInfoDirectConnectSnapshot> directConnectInfos { get; }

        public class MatchInfoDirectConnectSnapshot
        {
            public MatchInfoDirectConnectSnapshot();

            public NodeID nodeId { get; }
            public string publicAddress { get; }
            public string privateAddress { get; }
            public HostPriority hostPriority { get; }
        }
    }
}
using System;
using System.Collections.Generic;
using System.ComponentModel;
using UnityEngine.Networking.Types;

namespace UnityEngine.Networking.Match
{
    [Obsolete("The matchmaker and relay feature will be removed in the future, minimal support will continue until this can be safely done.")]
    public class NetworkMatch : MonoBehaviour
    {
        public NetworkMatch();

        public Uri baseUri { get; set; }

        [EditorBrowsable(Never)]
        [Obsolete("This function is not used any longer to interface with the matchmaker. Please set up your project by logging in through the editor connect dialog.", True)]
        public void SetProgramAppID(AppID programAppID);
        public Coroutine CreateMatch(string matchName, uint matchSize, bool matchAdvertise, string matchPassword, string publicClientAddress, string privateClientAddress, int eloScoreForMatch, int requestDomain, DataResponseDelegate<MatchInfo> callback);
        public Coroutine JoinMatch(NetworkID netId, string matchPassword, string publicClientAddress, string privateClientAddress, int eloScoreForClient, int requestDomain, DataResponseDelegate<MatchInfo> callback);
        public Coroutine DestroyMatch(NetworkID netId, int requestDomain, BasicResponseDelegate callback);
        public Coroutine DropConnection(NetworkID netId, NodeID dropNodeId, int requestDomain, BasicResponseDelegate callback);
        public Coroutine ListMatches(int startPageNumber, int resultPageSize, string matchNameFilter, bool filterOutPrivateMatchesFromResults, int eloScoreTarget, int requestDomain, DataResponseDelegate<List<MatchInfoSnapshot>> callback);
        public Coroutine SetMatchAttributes(NetworkID networkId, bool isListed, int requestDomain, BasicResponseDelegate callback);

        public delegate void BasicResponseDelegate(bool success, string extendedInfo);
        public delegate void DataResponseDelegate<T>(bool success, string extendedInfo, T responseData);
    }
}
-------- {UnityEngine.UmbraModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.UmbraModule.dll)}:   -1 --------
-------- {UnityEngine.UnityAnalyticsModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.UnityAnalyticsModule.dll)}:   16 --------
using System;
using System.Collections.Generic;
using System.ComponentModel;
using UnityEngine.Bindings;
using UnityEngine.Internal;

namespace UnityEngine
{
    [NativeHeader("UnityAnalyticsScriptingClasses.h")]
    [NativeHeader("Modules/UnityAnalytics/RemoteSettings/RemoteSettings.h")]
    public static class RemoteSettings
    {
        public static event UpdatedEventHandler Updated;
        public static event Action BeforeFetchFromServer;
        public static event Action<bool, bool, int> Completed;

        [EditorBrowsable(Never)]
        [Obsolete("Calling CallOnUpdate() is not necessary any more and should be removed. Use RemoteSettingsUpdated instead", True)]
        public static void CallOnUpdate();
        public static void ForceUpdate();
        public static bool WasLastUpdatedFromServer();
        [ExcludeFromDocs]
        public static int GetInt(string key);
        public static int GetInt(string key, [UnityEngine.Internal.DefaultValue("0")] int defaultValue);
        [ExcludeFromDocs]
        public static long GetLong(string key);
        public static long GetLong(string key, [UnityEngine.Internal.DefaultValue("0")] long defaultValue);
        [ExcludeFromDocs]
        public static float GetFloat(string key);
        public static float GetFloat(string key, [UnityEngine.Internal.DefaultValue("0.0F")] float defaultValue);
        [ExcludeFromDocs]
        public static string GetString(string key);
        public static string GetString(string key, [UnityEngine.Internal.DefaultValue("\"\"")] string defaultValue);
        [ExcludeFromDocs]
        public static bool GetBool(string key);
        public static bool GetBool(string key, [UnityEngine.Internal.DefaultValue("false")] bool defaultValue);
        public static bool HasKey(string key);
        public static int GetCount();
        public static string[] GetKeys();
        public static T GetObject<T>(string key = "");
        public static object GetObject(Type type, string key = "");
        public static object GetObject(string key, object defaultValue);
        public static IDictionary<string, object> GetDictionary(string key = "");

        public delegate void UpdatedEventHandler();
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Internal;

namespace UnityEngine
{
    [NativeHeader("Modules/UnityAnalytics/RemoteSettings/RemoteSettings.h")]
    [NativeHeader("UnityAnalyticsScriptingClasses.h")]
    [ExcludeFromDocs]
    public class RemoteConfigSettings : IDisposable
    {
        public RemoteConfigSettings(string configKey);

        ~RemoteConfigSettings();

        public event Action<bool> Updated;

        public void Dispose();
        public static bool QueueConfig(string name, object param, int ver = 1, string prefix = "");
        public static bool SendDeviceInfoInConfigRequest();
        public static void AddSessionTag(string tag);
        public void ForceUpdate();
        public bool WasLastUpdatedFromServer();
        [ExcludeFromDocs]
        public int GetInt(string key);
        public int GetInt(string key, [DefaultValue("0")] int defaultValue);
        [ExcludeFromDocs]
        public long GetLong(string key);
        public long GetLong(string key, [DefaultValue("0")] long defaultValue);
        [ExcludeFromDocs]
        public float GetFloat(string key);
        public float GetFloat(string key, [DefaultValue("0.0F")] float defaultValue);
        [ExcludeFromDocs]
        public string GetString(string key);
        public string GetString(string key, [DefaultValue("\"\"")] string defaultValue);
        [ExcludeFromDocs]
        public bool GetBool(string key);
        public bool GetBool(string key, [DefaultValue("false")] bool defaultValue);
        public bool HasKey(string key);
        public int GetCount();
        public string[] GetKeys();
        public T GetObject<T>(string key = "");
        public object GetObject(Type type, string key = "");
        public object GetObject(string key, object defaultValue);
        public IDictionary<string, object> GetDictionary(string key = "");
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Internal;
using UnityEngine.Scripting;

namespace UnityEngine.Analytics
{
    [ExcludeFromDocs]
    [NativeHeader("Modules/UnityAnalytics/ContinuousEvent/Manager.h")]
    [NativeHeader("Modules/UnityAnalytics/Public/UnityAnalytics.h")]
    [RequiredByNativeCode]
    public class ContinuousEvent
    {
        public ContinuousEvent();

        public static AnalyticsResult RegisterCollector<T>(string metricName, Func<T> del) where T : IComparable<T>, IEquatable<T>, struct;
        public static AnalyticsResult SetEventHistogramThresholds<T>(string eventName, int count, T[] data, int ver = 1, string prefix = "") where T : IComparable<T>, IEquatable<T>, struct;
        public static AnalyticsResult SetCustomEventHistogramThresholds<T>(string eventName, int count, T[] data) where T : IComparable<T>, IEquatable<T>, struct;
        public static AnalyticsResult ConfigureCustomEvent(string customEventName, string metricName, float interval, float period, bool enabled = True);
        public static AnalyticsResult ConfigureEvent(string eventName, string metricName, float interval, float period, bool enabled = True, int ver = 1, string prefix = "");
    }
}
using UnityEngine.Scripting;

namespace UnityEngine.Analytics
{
    [RequiredByNativeCode]
    public enum AnalyticsSessionState
    {
        kSessionStopped = 0,
        kSessionStarted = 1,
        kSessionPaused = 2,
        kSessionResumed = 3
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Analytics
{
    [NativeHeader("Modules/UnityAnalytics/Public/UnityAnalytics.h")]
    [RequiredByNativeCode]
    [NativeHeader("UnityAnalyticsScriptingClasses.h")]
    public static class AnalyticsSessionInfo
    {
        public static AnalyticsSessionState sessionState { get; }
        public static long sessionId { get; }
        public static long sessionCount { get; }
        public static long sessionElapsedTime { get; }
        public static bool sessionFirstRun { get; }
        public static string userId { get; }
        public static string customUserId { get; set; }
        public static string customDeviceId { get; set; }
        public static string identityToken { get; }

        public static event SessionStateChanged sessionStateChanged;
        public static event IdentityTokenChanged identityTokenChanged;

        public delegate void SessionStateChanged(AnalyticsSessionState sessionState, long sessionId, long sessionElapsedTime, bool sessionChanged);
        public delegate void IdentityTokenChanged(string token);
    }
}
using System.Collections.Generic;
using UnityEngine.Bindings;

namespace UnityEngine.Analytics
{
    [NativeHeader("Modules/UnityAnalytics/Public/UnityAnalytics.h")]
    [NativeHeader("Modules/UnityAnalytics/Public/Events/UserCustomEvent.h")]
    [NativeHeader("Modules/UnityConnect/UnityConnectSettings.h")]
    public static class Analytics
    {
        public static bool initializeOnStartup { get; set; }
        public static bool playerOptedOut { get; }
        public static string eventUrl { get; }
        public static string dashboardUrl { get; }
        public static string configUrl { get; }
        public static bool limitUserTracking { get; set; }
        public static bool deviceStatsEnabled { get; set; }
        public static bool enabled { get; set; }

        public static AnalyticsResult ResumeInitialization();
        public static AnalyticsResult FlushEvents();
        public static AnalyticsResult SetUserId(string userId);
        public static AnalyticsResult SetUserGender(Gender gender);
        public static AnalyticsResult SetUserBirthYear(int birthYear);
        public static AnalyticsResult Transaction(string productId, decimal amount, string currency);
        public static AnalyticsResult Transaction(string productId, decimal amount, string currency, string receiptPurchaseData, string signature);
        public static AnalyticsResult Transaction(string productId, decimal amount, string currency, string receiptPurchaseData, string signature, bool usingIAPService);
        public static AnalyticsResult CustomEvent(string customEventName);
        public static AnalyticsResult CustomEvent(string customEventName, Vector3 position);
        public static AnalyticsResult CustomEvent(string customEventName, IDictionary<string, object> eventData);
        public static AnalyticsResult EnableCustomEvent(string customEventName, bool enabled);
        public static AnalyticsResult IsCustomEventEnabled(string customEventName);
        public static AnalyticsResult RegisterEvent(string eventName, int maxEventPerHour, int maxItems, string vendorKey = "", string prefix = "");
        public static AnalyticsResult RegisterEvent(string eventName, int maxEventPerHour, int maxItems, string vendorKey, int ver, string prefix = "");
        public static AnalyticsResult SendEvent(string eventName, object parameters, int ver = 1, string prefix = "");
        public static AnalyticsResult SetEventEndPoint(string eventName, string endPoint, int ver = 1, string prefix = "");
        public static AnalyticsResult SetEventPriority(string eventName, AnalyticsEventPriority eventPriority, int ver = 1, string prefix = "");
        public static AnalyticsResult EnableEvent(string eventName, bool enabled, int ver = 1, string prefix = "");
        public static AnalyticsResult IsEventEnabled(string eventName, int ver = 1, string prefix = "");
    }
}
namespace UnityEngine.Analytics
{
    public enum Gender
    {
        Male = 0,
        Female = 1,
        Unknown = 2
    }
}
namespace UnityEngine.Analytics
{
    public enum AnalyticsResult
    {
        Ok = 0,
        NotInitialized = 1,
        AnalyticsDisabled = 2,
        TooManyItems = 3,
        SizeLimitReached = 4,
        TooManyRequests = 5,
        InvalidData = 6,
        UnsupportedPlatform = 7
    }
}
using System;

namespace UnityEngine.Analytics
{
    [Flags]
    public enum AnalyticsEventPriority
    {
        FlushQueueFlag = 1,
        CacheImmediatelyFlag = 2,
        AllowInStopModeFlag = 4,
        SendImmediateFlag = 8,
        NoCachingFlag = 16,
        NoRetryFlag = 32,
        NormalPriorityEvent = 0,
        NormalPriorityEvent_WithCaching = 2,
        NormalPriorityEvent_NoRetryNoCaching = 48,
        HighPriorityEvent = 1,
        HighPriorityEvent_InStopMode = 5,
        HighestPriorityEvent = 9,
        HighestPriorityEvent_NoRetryNoCaching = 49
    }
}
-------- {UnityEngine.UnityConnectModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.UnityConnectModule.dll)}:    1 --------
-------- {UnityEngine.UnityCurlModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.UnityCurlModule.dll)}:    2 --------
-------- {UnityEngine.UnityTestProtocolModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.UnityTestProtocolModule.dll)}:   -1 --------
-------- {UnityEngine.UnityWebRequestModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.UnityWebRequestModule.dll)}:   18 --------
using System.Collections.Generic;
using System.Text;
using UnityEngine.Internal;

namespace UnityEngine
{
    public class WWWForm
    {
        public WWWForm();

        public Dictionary<string, string> headers { get; }
        public byte[] data { get; }

        public void AddField(string fieldName, string value);
        public void AddField(string fieldName, string value, Encoding e);
        public void AddField(string fieldName, int i);
        [ExcludeFromDocs]
        public void AddBinaryData(string fieldName, byte[] contents);
        [ExcludeFromDocs]
        public void AddBinaryData(string fieldName, byte[] contents, string fileName);
        public void AddBinaryData(string fieldName, byte[] contents, [DefaultValue("null")] string fileName, [DefaultValue("null")] string mimeType);
    }
}
namespace UnityEngine.Networking
{
    public interface IMultipartFormSection
    {
        string sectionName { get; }
        byte[] sectionData { get; }
        string fileName { get; }
        string contentType { get; }
    }
}
using System.Text;

namespace UnityEngine.Networking
{
    public class MultipartFormDataSection : IMultipartFormSection
    {
        public MultipartFormDataSection(string name, byte[] data, string contentType);
        public MultipartFormDataSection(string name, byte[] data);
        public MultipartFormDataSection(byte[] data);
        public MultipartFormDataSection(string name, string data, Encoding encoding, string contentType);
        public MultipartFormDataSection(string name, string data, string contentType);
        public MultipartFormDataSection(string name, string data);
        public MultipartFormDataSection(string data);

        public string sectionName { get; }
        public byte[] sectionData { get; }
        public string fileName { get; }
        public string contentType { get; }
    }
}
using System.Text;

namespace UnityEngine.Networking
{
    public class MultipartFormFileSection : IMultipartFormSection
    {
        public MultipartFormFileSection(string name, byte[] data, string fileName, string contentType);
        public MultipartFormFileSection(byte[] data);
        public MultipartFormFileSection(string fileName, byte[] data);
        public MultipartFormFileSection(string name, string data, Encoding dataEncoding, string fileName);
        public MultipartFormFileSection(string data, Encoding dataEncoding, string fileName);
        public MultipartFormFileSection(string data, string fileName);

        public string sectionName { get; }
        public byte[] sectionData { get; }
        public string fileName { get; }
        public string contentType { get; }
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Networking
{
    [UsedByNativeCode]
    [NativeHeader("Modules/UnityWebRequest/Public/UnityWebRequestAsyncOperation.h")]
    [NativeHeader("UnityWebRequestScriptingClasses.h")]
    public class UnityWebRequestAsyncOperation : AsyncOperation
    {
        public UnityWebRequestAsyncOperation();

        public UnityWebRequest webRequest { get; }
    }
}
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Text;
using UnityEngine.Bindings;

namespace UnityEngine.Networking
{
    [NativeHeader("Modules/UnityWebRequest/Public/UnityWebRequest.h")]
    public class UnityWebRequest : IDisposable
    {
        public const string kHttpVerbGET = "GET";
        public const string kHttpVerbHEAD = "HEAD";
        public const string kHttpVerbPOST = "POST";
        public const string kHttpVerbPUT = "PUT";
        public const string kHttpVerbCREATE = "CREATE";
        public const string kHttpVerbDELETE = "DELETE";

        public UnityWebRequest();
        public UnityWebRequest(string url);
        public UnityWebRequest(Uri uri);
        public UnityWebRequest(string url, string method);
        public UnityWebRequest(Uri uri, string method);
        public UnityWebRequest(string url, string method, DownloadHandler downloadHandler, UploadHandler uploadHandler);
        public UnityWebRequest(Uri uri, string method, DownloadHandler downloadHandler, UploadHandler uploadHandler);

        ~UnityWebRequest();

        public bool disposeCertificateHandlerOnDispose { get; set; }
        public bool disposeDownloadHandlerOnDispose { get; set; }
        public bool disposeUploadHandlerOnDispose { get; set; }
        public string method { get; set; }
        public string error { get; }
        public bool useHttpContinue { get; set; }
        public string url { get; set; }
        public Uri uri { get; set; }
        public long responseCode { get; }
        public float uploadProgress { get; }
        public bool isModifiable { get; }
        public bool isDone { get; }
        [Obsolete("UnityWebRequest.isNetworkError is deprecated. Use (UnityWebRequest.result == UnityWebRequest.Result.ConnectionError) instead.", False)]
        public bool isNetworkError { get; }
        [Obsolete("UnityWebRequest.isHttpError is deprecated. Use (UnityWebRequest.result == UnityWebRequest.Result.ProtocolError) instead.", False)]
        public bool isHttpError { get; }
        public Result result { get; }
        public float downloadProgress { get; }
        public ulong uploadedBytes { get; }
        public ulong downloadedBytes { get; }
        public int redirectLimit { get; set; }
        [Obsolete("HTTP/2 and many HTTP/1.1 servers don't support this; we recommend leaving it set to false (default).", False)]
        public bool chunkedTransfer { get; set; }
        public UploadHandler uploadHandler { get; set; }
        public DownloadHandler downloadHandler { get; set; }
        public CertificateHandler certificateHandler { get; set; }
        public int timeout { get; set; }
        [Obsolete("UnityWebRequest.isError has been renamed to isNetworkError for clarity. (UnityUpgradable) -> isNetworkError", False)]
        public bool isError { get; }

        public static void ClearCookieCache();
        public static void ClearCookieCache(Uri uri);
        public void Dispose();
        [Obsolete("Use SendWebRequest.  It returns a UnityWebRequestAsyncOperation which contains a reference to the WebRequest object.", False)]
        public AsyncOperation Send();
        public UnityWebRequestAsyncOperation SendWebRequest();
        [NativeMethod(IsThreadSafe = True)]
        public void Abort();
        public string GetRequestHeader(string name);
        public void SetRequestHeader(string name, string value);
        public string GetResponseHeader(string name);
        public Dictionary<string, string> GetResponseHeaders();
        public static UnityWebRequest Get(string uri);
        public static UnityWebRequest Get(Uri uri);
        public static UnityWebRequest Delete(string uri);
        public static UnityWebRequest Delete(Uri uri);
        public static UnityWebRequest Head(string uri);
        public static UnityWebRequest Head(Uri uri);
        [Obsolete("UnityWebRequest.GetTexture is obsolete. Use UnityWebRequestTexture.GetTexture instead (UnityUpgradable) -> [UnityEngine] UnityWebRequestTexture.GetTexture(*)", True)]
        [EditorBrowsable(Never)]
        public static UnityWebRequest GetTexture(string uri);
        [EditorBrowsable(Never)]
        [Obsolete("UnityWebRequest.GetTexture is obsolete. Use UnityWebRequestTexture.GetTexture instead (UnityUpgradable) -> [UnityEngine] UnityWebRequestTexture.GetTexture(*)", True)]
        public static UnityWebRequest GetTexture(string uri, bool nonReadable);
        [Obsolete("UnityWebRequest.GetAudioClip is obsolete. Use UnityWebRequestMultimedia.GetAudioClip instead (UnityUpgradable) -> [UnityEngine] UnityWebRequestMultimedia.GetAudioClip(*)", True)]
        [EditorBrowsable(Never)]
        public static UnityWebRequest GetAudioClip(string uri, AudioType audioType);
        [EditorBrowsable(Never)]
        [Obsolete("UnityWebRequest.GetAssetBundle is obsolete. Use UnityWebRequestAssetBundle.GetAssetBundle instead (UnityUpgradable) -> [UnityEngine] UnityWebRequestAssetBundle.GetAssetBundle(*)", True)]
        public static UnityWebRequest GetAssetBundle(string uri);
        [Obsolete("UnityWebRequest.GetAssetBundle is obsolete. Use UnityWebRequestAssetBundle.GetAssetBundle instead (UnityUpgradable) -> [UnityEngine] UnityWebRequestAssetBundle.GetAssetBundle(*)", True)]
        [EditorBrowsable(Never)]
        public static UnityWebRequest GetAssetBundle(string uri, uint crc);
        [EditorBrowsable(Never)]
        [Obsolete("UnityWebRequest.GetAssetBundle is obsolete. Use UnityWebRequestAssetBundle.GetAssetBundle instead (UnityUpgradable) -> [UnityEngine] UnityWebRequestAssetBundle.GetAssetBundle(*)", True)]
        public static UnityWebRequest GetAssetBundle(string uri, uint version, uint crc);
        [EditorBrowsable(Never)]
        [Obsolete("UnityWebRequest.GetAssetBundle is obsolete. Use UnityWebRequestAssetBundle.GetAssetBundle instead (UnityUpgradable) -> [UnityEngine] UnityWebRequestAssetBundle.GetAssetBundle(*)", True)]
        public static UnityWebRequest GetAssetBundle(string uri, Hash128 hash, uint crc);
        [Obsolete("UnityWebRequest.GetAssetBundle is obsolete. Use UnityWebRequestAssetBundle.GetAssetBundle instead (UnityUpgradable) -> [UnityEngine] UnityWebRequestAssetBundle.GetAssetBundle(*)", True)]
        [EditorBrowsable(Never)]
        public static UnityWebRequest GetAssetBundle(string uri, CachedAssetBundle cachedAssetBundle, uint crc);
        public static UnityWebRequest Put(string uri, byte[] bodyData);
        public static UnityWebRequest Put(Uri uri, byte[] bodyData);
        public static UnityWebRequest Put(string uri, string bodyData);
        public static UnityWebRequest Put(Uri uri, string bodyData);
        public static UnityWebRequest Post(string uri, string postData);
        public static UnityWebRequest Post(Uri uri, string postData);
        public static UnityWebRequest Post(string uri, WWWForm formData);
        public static UnityWebRequest Post(Uri uri, WWWForm formData);
        public static UnityWebRequest Post(string uri, List<IMultipartFormSection> multipartFormSections);
        public static UnityWebRequest Post(Uri uri, List<IMultipartFormSection> multipartFormSections);
        public static UnityWebRequest Post(string uri, List<IMultipartFormSection> multipartFormSections, byte[] boundary);
        public static UnityWebRequest Post(Uri uri, List<IMultipartFormSection> multipartFormSections, byte[] boundary);
        public static UnityWebRequest Post(string uri, Dictionary<string, string> formFields);
        public static UnityWebRequest Post(Uri uri, Dictionary<string, string> formFields);
        public static string EscapeURL(string s);
        public static string EscapeURL(string s, Encoding e);
        public static string UnEscapeURL(string s);
        public static string UnEscapeURL(string s, Encoding e);
        public static byte[] SerializeFormSections(List<IMultipartFormSection> multipartFormSections, byte[] boundary);
        public static byte[] GenerateBoundary();
        public static byte[] SerializeSimpleForm(Dictionary<string, string> formFields);

        public enum Result
        {
            InProgress = 0,
            Success = 1,
            ConnectionError = 2,
            ProtocolError = 3,
            DataProcessingError = 4
        }
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEngine.Networking
{
    [NativeHeader("Modules/UnityWebRequest/Public/CertificateHandler/CertificateHandlerScript.h")]
    public class CertificateHandler : IDisposable
    {
        protected CertificateHandler();

        ~CertificateHandler();

        protected virtual bool ValidateCertificate(byte[] certificateData);
        public void Dispose();
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Networking
{
    [NativeHeader("Modules/UnityWebRequest/Public/DownloadHandler/DownloadHandler.h")]
    public class DownloadHandler : IDisposable
    {
        ~DownloadHandler();

        public bool isDone { get; }
        public string error { get; }
        public byte[] data { get; }
        public string text { get; }

        public void Dispose();
        protected virtual byte[] GetData();
        protected virtual string GetText();
        [UsedByNativeCode]
        protected virtual bool ReceiveData(byte[] data, int dataLength);
        [RequiredByNativeCode]
        protected virtual void ReceiveContentLengthHeader(ulong contentLength);
        [Obsolete("Use ReceiveContentLengthHeader")]
        protected virtual void ReceiveContentLength(int contentLength);
        [UsedByNativeCode]
        protected virtual void CompleteContent();
        [UsedByNativeCode]
        protected virtual float GetProgress();
        protected static T GetCheckedDownloader<T>(UnityWebRequest www) where T : DownloadHandler;
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Networking
{
    [NativeHeader("Modules/UnityWebRequest/Public/DownloadHandler/DownloadHandlerBuffer.h")]
    public sealed class DownloadHandlerBuffer : DownloadHandler
    {
        public DownloadHandlerBuffer();

        protected override byte[] GetData();
        public static string GetContent(UnityWebRequest www);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Networking
{
    [NativeHeader("Modules/UnityWebRequest/Public/DownloadHandler/DownloadHandlerScript.h")]
    public class DownloadHandlerScript : DownloadHandler
    {
        public DownloadHandlerScript();
        public DownloadHandlerScript(byte[] preallocatedBuffer);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Networking
{
    [NativeHeader("Modules/UnityWebRequest/Public/DownloadHandler/DownloadHandlerVFS.h")]
    public sealed class DownloadHandlerFile : DownloadHandler
    {
        public DownloadHandlerFile(string path);
        public DownloadHandlerFile(string path, bool append);

        public bool removeFileOnAbort { get; set; }

        protected override byte[] GetData();
        protected override string GetText();
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEngine.Networking
{
    [NativeHeader("Modules/UnityWebRequest/Public/UploadHandler/UploadHandler.h")]
    public class UploadHandler : IDisposable
    {
        ~UploadHandler();

        public byte[] data { get; }
        public string contentType { get; set; }
        public float progress { get; }

        public void Dispose();
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Networking
{
    [NativeHeader("Modules/UnityWebRequest/Public/UploadHandler/UploadHandlerRaw.h")]
    public sealed class UploadHandlerRaw : UploadHandler
    {
        public UploadHandlerRaw(byte[] data);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Networking
{
    [NativeHeader("Modules/UnityWebRequest/Public/UploadHandler/UploadHandlerFile.h")]
    public sealed class UploadHandlerFile : UploadHandler
    {
        public UploadHandlerFile(string filePath);
    }
}
-------- {UnityEngine.UnityWebRequestAssetBundleModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.UnityWebRequestAssetBundleModule.dll)}:    1 --------
using System;

namespace UnityEngine.Networking
{
    public static class UnityWebRequestAssetBundle
    {
        public static UnityWebRequest GetAssetBundle(string uri);
        public static UnityWebRequest GetAssetBundle(Uri uri);
        public static UnityWebRequest GetAssetBundle(string uri, uint crc);
        public static UnityWebRequest GetAssetBundle(Uri uri, uint crc);
        public static UnityWebRequest GetAssetBundle(string uri, uint version, uint crc);
        public static UnityWebRequest GetAssetBundle(Uri uri, uint version, uint crc);
        public static UnityWebRequest GetAssetBundle(string uri, Hash128 hash, uint crc = 0);
        public static UnityWebRequest GetAssetBundle(Uri uri, Hash128 hash, uint crc = 0);
        public static UnityWebRequest GetAssetBundle(string uri, CachedAssetBundle cachedAssetBundle, uint crc = 0);
        public static UnityWebRequest GetAssetBundle(Uri uri, CachedAssetBundle cachedAssetBundle, uint crc = 0);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Networking
{
    [NativeHeader("Modules/UnityWebRequestAssetBundle/Public/DownloadHandlerAssetBundle.h")]
    public sealed class DownloadHandlerAssetBundle : DownloadHandler
    {
        public DownloadHandlerAssetBundle(string url, uint crc);
        public DownloadHandlerAssetBundle(string url, uint version, uint crc);
        public DownloadHandlerAssetBundle(string url, Hash128 hash, uint crc);
        public DownloadHandlerAssetBundle(string url, string name, Hash128 hash, uint crc);
        public DownloadHandlerAssetBundle(string url, CachedAssetBundle cachedBundle, uint crc);

        public AssetBundle assetBundle { get; }
        public bool autoLoadAssetBundle { get; set; }
        public bool isDownloadComplete { get; }

        protected override byte[] GetData();
        protected override string GetText();
        public static AssetBundle GetContent(UnityWebRequest www);
    }
}
-------- {UnityEngine.UnityWebRequestAudioModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.UnityWebRequestAudioModule.dll)}:    2 --------
using System;

namespace UnityEngine.Networking
{
    public static class UnityWebRequestMultimedia
    {
        public static UnityWebRequest GetAudioClip(string uri, AudioType audioType);
        public static UnityWebRequest GetAudioClip(Uri uri, AudioType audioType);
        [Obsolete("MovieTexture is deprecated. Use VideoPlayer instead.", True)]
        public static UnityWebRequest GetMovieTexture(string uri);
        [Obsolete("MovieTexture is deprecated. Use VideoPlayer instead.", True)]
        public static UnityWebRequest GetMovieTexture(Uri uri);
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEngine.Networking
{
    [NativeHeader("Modules/UnityWebRequestAudio/Public/DownloadHandlerAudioClip.h")]
    public sealed class DownloadHandlerAudioClip : DownloadHandler
    {
        public DownloadHandlerAudioClip(string url, AudioType audioType);
        public DownloadHandlerAudioClip(Uri uri, AudioType audioType);

        [NativeThrows]
        public AudioClip audioClip { get; }
        public bool streamAudio { get; set; }
        public bool compressed { get; set; }

        protected override byte[] GetData();
        protected override string GetText();
        public static AudioClip GetContent(UnityWebRequest www);
    }
}
using System;

namespace UnityEngine.Networking
{
    [Obsolete("MovieTexture is deprecated. Use VideoPlayer instead.", True)]
    public sealed class DownloadHandlerMovieTexture : DownloadHandler
    {
        public DownloadHandlerMovieTexture();

        public MovieTexture movieTexture { get; }

        protected override byte[] GetData();
        protected override string GetText();
        public static MovieTexture GetContent(UnityWebRequest uwr);
    }
}
-------- {UnityEngine.UnityWebRequestTextureModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.UnityWebRequestTextureModule.dll)}:    1 --------
using System;

namespace UnityEngine.Networking
{
    public static class UnityWebRequestTexture
    {
        public static UnityWebRequest GetTexture(string uri);
        public static UnityWebRequest GetTexture(Uri uri);
        public static UnityWebRequest GetTexture(string uri, bool nonReadable);
        public static UnityWebRequest GetTexture(Uri uri, bool nonReadable);
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Networking
{
    [NativeHeader("Modules/UnityWebRequestTexture/Public/DownloadHandlerTexture.h")]
    public sealed class DownloadHandlerTexture : DownloadHandler
    {
        public DownloadHandlerTexture();
        public DownloadHandlerTexture(bool readable);

        public Texture2D texture { get; }

        protected override byte[] GetData();
        public static Texture2D GetContent(UnityWebRequest www);
    }
}
-------- {UnityEngine.UnityWebRequestWWWModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.UnityWebRequestWWWModule.dll)}:    2 --------
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Text;

namespace UnityEngine
{
    [Obsolete("Use UnityWebRequest, a fully featured replacement which is more efficient and has additional features")]
    public class WWW : CustomYieldInstruction, IDisposable
    {
        public WWW(string url);
        public WWW(string url, WWWForm form);
        public WWW(string url, byte[] postData);
        [Obsolete("This overload is deprecated. Use UnityEngine.WWW.WWW(string, byte[], System.Collections.Generic.Dictionary<string, string>) instead.")]
        public WWW(string url, byte[] postData, Hashtable headers);
        public WWW(string url, byte[] postData, Dictionary<string, string> headers);

        public AssetBundle assetBundle { get; }
        [EditorBrowsable(Never)]
        [Obsolete("Obsolete msg (UnityUpgradable) -> * UnityEngine.WWW.GetAudioClip()", True)]
        public Object audioClip { get; }
        public byte[] bytes { get; }
        [EditorBrowsable(Never)]
        [Obsolete("Obsolete msg (UnityUpgradable) -> * UnityEngine.WWW.GetMovieTexture()", True)]
        public Object movie { get; }
        [Obsolete("WWW.size is obsolete. Please use WWW.bytesDownloaded instead")]
        public int size { get; }
        public int bytesDownloaded { get; }
        public string error { get; }
        public bool isDone { get; }
        [EditorBrowsable(Never)]
        [Obsolete("Obsolete msg (UnityUpgradable) -> * UnityEngine.WWW.GetAudioClip()", True)]
        public Object oggVorbis { get; }
        public float progress { get; }
        public Dictionary<string, string> responseHeaders { get; }
        [Obsolete("Please use WWW.text instead. (UnityUpgradable) -> text", True)]
        [EditorBrowsable(Never)]
        public string data { get; }
        public string text { get; }
        public Texture2D texture { get; }
        public Texture2D textureNonReadable { get; }
        public ThreadPriority threadPriority { get; set; }
        public float uploadProgress { get; }
        public string url { get; }
        public override bool keepWaiting { get; }

        public static string EscapeURL(string s);
        public static string EscapeURL(string s, Encoding e);
        public static string UnEscapeURL(string s);
        public static string UnEscapeURL(string s, Encoding e);
        public static WWW LoadFromCacheOrDownload(string url, int version);
        public static WWW LoadFromCacheOrDownload(string url, int version, uint crc);
        public static WWW LoadFromCacheOrDownload(string url, Hash128 hash);
        public static WWW LoadFromCacheOrDownload(string url, Hash128 hash, uint crc);
        public static WWW LoadFromCacheOrDownload(string url, CachedAssetBundle cachedBundle, uint crc = 0);
        public void LoadImageIntoTexture(Texture2D texture);
        public void Dispose();
        public AudioClip GetAudioClip();
        public AudioClip GetAudioClip(bool threeD);
        public AudioClip GetAudioClip(bool threeD, bool stream);
        public AudioClip GetAudioClip(bool threeD, bool stream, AudioType audioType);
        public AudioClip GetAudioClipCompressed();
        public AudioClip GetAudioClipCompressed(bool threeD);
        public AudioClip GetAudioClipCompressed(bool threeD, AudioType audioType);
        [EditorBrowsable(Never)]
        [Obsolete("MovieTexture is deprecated. Use VideoPlayer instead.", False)]
        public MovieTexture GetMovieTexture();
    }
}
using System;

namespace UnityEngine
{
    public static class WWWAudioExtensions
    {
        [Obsolete("WWWAudioExtensions.GetAudioClip extension method has been replaced by WWW.GetAudioClip instance method. (UnityUpgradable) -> WWW.GetAudioClip()", True)]
        public static AudioClip GetAudioClip(this WWW www);
        [Obsolete("WWWAudioExtensions.GetAudioClip extension method has been replaced by WWW.GetAudioClip instance method. (UnityUpgradable) -> WWW.GetAudioClip([mscorlib] System.Boolean)", True)]
        public static AudioClip GetAudioClip(this WWW www, bool threeD);
        [Obsolete("WWWAudioExtensions.GetAudioClip extension method has been replaced by WWW.GetAudioClip instance method. (UnityUpgradable) -> WWW.GetAudioClip([mscorlib] System.Boolean, [mscorlib] System.Boolean)", True)]
        public static AudioClip GetAudioClip(this WWW www, bool threeD, bool stream);
        [Obsolete("WWWAudioExtensions.GetAudioClip extension method has been replaced by WWW.GetAudioClip instance method. (UnityUpgradable) -> WWW.GetAudioClip([mscorlib] System.Boolean, [mscorlib] System.Boolean, UnityEngine.AudioType)", True)]
        public static AudioClip GetAudioClip(this WWW www, bool threeD, bool stream, AudioType audioType);
        [Obsolete("WWWAudioExtensions.GetAudioClipCompressed extension method has been replaced by WWW.GetAudioClipCompressed instance method. (UnityUpgradable) -> WWW.GetAudioClipCompressed()", True)]
        public static AudioClip GetAudioClipCompressed(this WWW www);
        [Obsolete("WWWAudioExtensions.GetAudioClipCompressed extension method has been replaced by WWW.GetAudioClipCompressed instance method. (UnityUpgradable) -> WWW.GetAudioClipCompressed([mscorlib] System.Boolean)", True)]
        public static AudioClip GetAudioClipCompressed(this WWW www, bool threeD);
        [Obsolete("WWWAudioExtensions.GetAudioClipCompressed extension method has been replaced by WWW.GetAudioClipCompressed instance method. (UnityUpgradable) -> WWW.GetAudioClipCompressed([mscorlib] System.Boolean, UnityEngine.AudioType)", True)]
        public static AudioClip GetAudioClipCompressed(this WWW www, bool threeD, AudioType audioType);
        [Obsolete("WWWAudioExtensions.GetMovieTexture extension method has been replaced by WWW.GetMovieTexture instance method. (UnityUpgradable) -> WWW.GetMovieTexture()", True)]
        public static MovieTexture GetMovieTexture(this WWW www);
    }
}
-------- {UnityEngine.VFXModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.VFXModule.dll)}:   23 --------
using System;

namespace UnityEngine.VFX
{
    [Flags]
    public enum VFXCameraBufferTypes
    {
        None = 0,
        Depth = 1,
        Color = 2,
        Normal = 4
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.VFX
{
    [RequiredByNativeCode]
    [NativeType(Header = "Modules/VFX/Public/VFXEventAttribute.h")]
    public sealed class VFXEventAttribute : IDisposable
    {
        public VFXEventAttribute(VFXEventAttribute original);

        ~VFXEventAttribute();

        public void Dispose();
        [NativeName("HasValueFromScript<bool>")]
        public bool HasBool(int nameID);
        [NativeName("HasValueFromScript<int>")]
        public bool HasInt(int nameID);
        [NativeName("HasValueFromScript<UInt32>")]
        public bool HasUint(int nameID);
        [NativeName("HasValueFromScript<float>")]
        public bool HasFloat(int nameID);
        [NativeName("HasValueFromScript<Vector2f>")]
        public bool HasVector2(int nameID);
        [NativeName("HasValueFromScript<Vector3f>")]
        public bool HasVector3(int nameID);
        [NativeName("HasValueFromScript<Vector4f>")]
        public bool HasVector4(int nameID);
        [NativeName("HasValueFromScript<Matrix4x4f>")]
        public bool HasMatrix4x4(int nameID);
        [NativeName("SetValueFromScript<bool>")]
        public void SetBool(int nameID, bool b);
        [NativeName("SetValueFromScript<int>")]
        public void SetInt(int nameID, int i);
        [NativeName("SetValueFromScript<UInt32>")]
        public void SetUint(int nameID, uint i);
        [NativeName("SetValueFromScript<float>")]
        public void SetFloat(int nameID, float f);
        [NativeName("SetValueFromScript<Vector2f>")]
        public void SetVector2(int nameID, Vector2 v);
        [NativeName("SetValueFromScript<Vector3f>")]
        public void SetVector3(int nameID, Vector3 v);
        [NativeName("SetValueFromScript<Vector4f>")]
        public void SetVector4(int nameID, Vector4 v);
        [NativeName("SetValueFromScript<Matrix4x4f>")]
        public void SetMatrix4x4(int nameID, Matrix4x4 v);
        [NativeName("GetValueFromScript<bool>")]
        public bool GetBool(int nameID);
        [NativeName("GetValueFromScript<int>")]
        public int GetInt(int nameID);
        [NativeName("GetValueFromScript<UInt32>")]
        public uint GetUint(int nameID);
        [NativeName("GetValueFromScript<float>")]
        public float GetFloat(int nameID);
        [NativeName("GetValueFromScript<Vector2f>")]
        public Vector2 GetVector2(int nameID);
        [NativeName("GetValueFromScript<Vector3f>")]
        public Vector3 GetVector3(int nameID);
        [NativeName("GetValueFromScript<Vector4f>")]
        public Vector4 GetVector4(int nameID);
        [NativeName("GetValueFromScript<Matrix4x4f>")]
        public Matrix4x4 GetMatrix4x4(int nameID);
        public bool HasBool(string name);
        public bool HasInt(string name);
        public bool HasUint(string name);
        public bool HasFloat(string name);
        public bool HasVector2(string name);
        public bool HasVector3(string name);
        public bool HasVector4(string name);
        public bool HasMatrix4x4(string name);
        public void SetBool(string name, bool b);
        public void SetInt(string name, int i);
        public void SetUint(string name, uint i);
        public void SetFloat(string name, float f);
        public void SetVector2(string name, Vector2 v);
        public void SetVector3(string name, Vector3 v);
        public void SetVector4(string name, Vector4 v);
        public void SetMatrix4x4(string name, Matrix4x4 v);
        public bool GetBool(string name);
        public int GetInt(string name);
        public uint GetUint(string name);
        public float GetFloat(string name);
        public Vector2 GetVector2(string name);
        public Vector3 GetVector3(string name);
        public Vector4 GetVector4(string name);
        public Matrix4x4 GetMatrix4x4(string name);
        public void CopyValuesFrom([NotNull("ArgumentNullException")] VFXEventAttribute eventAttibute);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.VFX
{
    [RequiredByNativeCode]
    [NativeType(Header = "Modules/VFX/Public/VFXExpressionValues.h")]
    public class VFXExpressionValues
    {
        [NativeName("GetValueFromScript<bool>")]
        [NativeThrows]
        public bool GetBool(int nameID);
        [NativeName("GetValueFromScript<int>")]
        [NativeThrows]
        public int GetInt(int nameID);
        [NativeName("GetValueFromScript<UInt32>")]
        [NativeThrows]
        public uint GetUInt(int nameID);
        [NativeName("GetValueFromScript<float>")]
        [NativeThrows]
        public float GetFloat(int nameID);
        [NativeName("GetValueFromScript<Vector2f>")]
        [NativeThrows]
        public Vector2 GetVector2(int nameID);
        [NativeName("GetValueFromScript<Vector3f>")]
        [NativeThrows]
        public Vector3 GetVector3(int nameID);
        [NativeThrows]
        [NativeName("GetValueFromScript<Vector4f>")]
        public Vector4 GetVector4(int nameID);
        [NativeThrows]
        [NativeName("GetValueFromScript<Matrix4x4f>")]
        public Matrix4x4 GetMatrix4x4(int nameID);
        [NativeThrows]
        [NativeName("GetValueFromScript<Texture*>")]
        public Texture GetTexture(int nameID);
        [NativeThrows]
        [NativeName("GetValueFromScript<Mesh*>")]
        public Mesh GetMesh(int nameID);
        public AnimationCurve GetAnimationCurve(int nameID);
        public Gradient GetGradient(int nameID);
        public bool GetBool(string name);
        public int GetInt(string name);
        public uint GetUInt(string name);
        public float GetFloat(string name);
        public Vector2 GetVector2(string name);
        public Vector3 GetVector3(string name);
        public Vector4 GetVector4(string name);
        public Matrix4x4 GetMatrix4x4(string name);
        public Texture GetTexture(string name);
        public AnimationCurve GetAnimationCurve(string name);
        public Gradient GetGradient(string name);
        public Mesh GetMesh(string name);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Rendering;
using UnityEngine.Scripting;

namespace UnityEngine.VFX
{
    [StaticAccessor("GetVFXManager()", Dot)]
    [NativeHeader("Modules/VFX/Public/VFXManager.h")]
    [RequiredByNativeCode]
    public static class VFXManager
    {
        public static float fixedTimeStep { get; set; }
        public static float maxDeltaTime { get; set; }

        public static VisualEffect[] GetComponents();
        public static void ProcessCamera(Camera cam);
        public static void PrepareCamera([NotNull("NullExceptionObject")] Camera cam);
        public static void ProcessCameraCommand([NotNull("NullExceptionObject")] Camera cam, CommandBuffer cmd);
        public static VFXCameraBufferTypes IsCameraBufferNeeded([NotNull("NullExceptionObject")] Camera cam);
        public static void SetCameraBuffer([NotNull("NullExceptionObject")] Camera cam, VFXCameraBufferTypes type, Texture buffer, int x, int y, int width, int height);
    }
}
using UnityEngine.Scripting;

namespace UnityEngine.VFX
{
    [RequiredByNativeCode]
    public abstract class VFXSpawnerCallbacks : ScriptableObject
    {
        protected VFXSpawnerCallbacks();

        public abstract void OnPlay(VFXSpawnerState state, VFXExpressionValues vfxValues, VisualEffect vfxComponent);
        public abstract void OnUpdate(VFXSpawnerState state, VFXExpressionValues vfxValues, VisualEffect vfxComponent);
        public abstract void OnStop(VFXSpawnerState state, VFXExpressionValues vfxValues, VisualEffect vfxComponent);
    }
}
namespace UnityEngine.VFX
{
    public enum VFXSpawnerLoopState
    {
        Finished = 0,
        DelayingBeforeLoop = 1,
        Looping = 2,
        DelayingAfterLoop = 3
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.VFX
{
    [NativeType(Header = "Modules/VFX/Public/VFXSpawnerState.h")]
    [RequiredByNativeCode]
    public sealed class VFXSpawnerState : IDisposable
    {
        public VFXSpawnerState();

        ~VFXSpawnerState();

        public bool playing { get; set; }
        public bool newLoop { get; }
        public VFXSpawnerLoopState loopState { get; set; }
        public float spawnCount { get; set; }
        public float deltaTime { get; set; }
        public float totalTime { get; set; }
        public float delayBeforeLoop { get; set; }
        public float loopDuration { get; set; }
        public float delayAfterLoop { get; set; }
        public int loopIndex { get; set; }
        public int loopCount { get; set; }
        public VFXEventAttribute vfxEventAttribute { get; }

        public void Dispose();
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEngine.VFX
{
    [UsedByNativeCode]
    public struct VFXExposedProperty
    {
        public string name;
        public Type type;
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.VFX
{
    [UsedByNativeCode]
    [NativeHeader("Modules/VFX/Public/ScriptBindings/VisualEffectAssetBindings.h")]
    [NativeHeader("VFXScriptingClasses.h")]
    [NativeHeader("Modules/VFX/Public/VisualEffectAsset.h")]
    public abstract class VisualEffectObject : Object
    {
        protected VisualEffectObject();
    }
}
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Rendering;
using UnityEngine.Scripting;

namespace UnityEngine.VFX
{
    [UsedByNativeCode]
    [NativeHeader("Modules/VFX/Public/VisualEffectAsset.h")]
    [NativeHeader("VFXScriptingClasses.h")]
    public class VisualEffectAsset : VisualEffectObject
    {
        public const string PlayEventName = "OnPlay";
        public const string StopEventName = "OnStop";
        public static readonly int PlayEventID;
        public static readonly int StopEventID;

        public VisualEffectAsset();

        [FreeFunction(Name = "VisualEffectAssetBindings::GetTextureDimension", HasExplicitThis = True)]
        public TextureDimension GetTextureDimension(int nameID);
        [FreeFunction(Name = "VisualEffectAssetBindings::GetExposedProperties", HasExplicitThis = True)]
        public void GetExposedProperties([NotNull("ArgumentNullException")] List<VFXExposedProperty> exposedProperties);
        [FreeFunction(Name = "VisualEffectAssetBindings::GetEvents", HasExplicitThis = True)]
        public void GetEvents([NotNull("ArgumentNullException")] List<string> names);
        public TextureDimension GetTextureDimension(string name);
    }
}
namespace UnityEngine.VFX
{
    public struct VFXOutputEventArgs
    {
        public VFXOutputEventArgs(int nameId, VFXEventAttribute eventAttribute);

        public int nameId { get; }
        public VFXEventAttribute eventAttribute { get; }
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Rendering;

namespace UnityEngine.VFX
{
    [RequireComponent(typeof(Transform))]
    [NativeHeader("Modules/VFX/Public/VisualEffect.h")]
    [NativeHeader("Modules/VFX/Public/ScriptBindings/VisualEffectBindings.h")]
    public class VisualEffect : Behaviour
    {
        public Action<VFXOutputEventArgs> outputEventReceived;

        public VisualEffect();

        public bool pause { get; set; }
        public float playRate { get; set; }
        public uint startSeed { get; set; }
        public bool resetSeedOnPlay { get; set; }
        public int initialEventID { get; set; }
        public string initialEventName { get; set; }
        public bool culled { get; }
        public VisualEffectAsset visualEffectAsset { get; set; }
        public int aliveParticleCount { get; }

        public VFXEventAttribute CreateVFXEventAttribute();
        public void SendEvent(int eventNameID, VFXEventAttribute eventAttribute);
        public void SendEvent(string eventName, VFXEventAttribute eventAttribute);
        public void SendEvent(int eventNameID);
        public void SendEvent(string eventName);
        public void Play(VFXEventAttribute eventAttribute);
        public void Play();
        public void Stop(VFXEventAttribute eventAttribute);
        public void Stop();
        public void Reinit();
        public void AdvanceOneFrame();
        [FreeFunction(Name = "VisualEffectBindings::ResetOverrideFromScript", HasExplicitThis = True)]
        public void ResetOverride(int nameID);
        [FreeFunction(Name = "VisualEffectBindings::GetTextureDimensionFromScript", HasExplicitThis = True)]
        public TextureDimension GetTextureDimension(int nameID);
        [FreeFunction(Name = "VisualEffectBindings::HasValueFromScript<bool>", HasExplicitThis = True)]
        public bool HasBool(int nameID);
        [FreeFunction(Name = "VisualEffectBindings::HasValueFromScript<int>", HasExplicitThis = True)]
        public bool HasInt(int nameID);
        [FreeFunction(Name = "VisualEffectBindings::HasValueFromScript<UInt32>", HasExplicitThis = True)]
        public bool HasUInt(int nameID);
        [FreeFunction(Name = "VisualEffectBindings::HasValueFromScript<float>", HasExplicitThis = True)]
        public bool HasFloat(int nameID);
        [FreeFunction(Name = "VisualEffectBindings::HasValueFromScript<Vector2f>", HasExplicitThis = True)]
        public bool HasVector2(int nameID);
        [FreeFunction(Name = "VisualEffectBindings::HasValueFromScript<Vector3f>", HasExplicitThis = True)]
        public bool HasVector3(int nameID);
        [FreeFunction(Name = "VisualEffectBindings::HasValueFromScript<Vector4f>", HasExplicitThis = True)]
        public bool HasVector4(int nameID);
        [FreeFunction(Name = "VisualEffectBindings::HasValueFromScript<Matrix4x4f>", HasExplicitThis = True)]
        public bool HasMatrix4x4(int nameID);
        [FreeFunction(Name = "VisualEffectBindings::HasValueFromScript<Texture*>", HasExplicitThis = True)]
        public bool HasTexture(int nameID);
        [FreeFunction(Name = "VisualEffectBindings::HasValueFromScript<AnimationCurve*>", HasExplicitThis = True)]
        public bool HasAnimationCurve(int nameID);
        [FreeFunction(Name = "VisualEffectBindings::HasValueFromScript<Gradient*>", HasExplicitThis = True)]
        public bool HasGradient(int nameID);
        [FreeFunction(Name = "VisualEffectBindings::HasValueFromScript<Mesh*>", HasExplicitThis = True)]
        public bool HasMesh(int nameID);
        [FreeFunction(Name = "VisualEffectBindings::SetValueFromScript<bool>", HasExplicitThis = True)]
        public void SetBool(int nameID, bool b);
        [FreeFunction(Name = "VisualEffectBindings::SetValueFromScript<int>", HasExplicitThis = True)]
        public void SetInt(int nameID, int i);
        [FreeFunction(Name = "VisualEffectBindings::SetValueFromScript<UInt32>", HasExplicitThis = True)]
        public void SetUInt(int nameID, uint i);
        [FreeFunction(Name = "VisualEffectBindings::SetValueFromScript<float>", HasExplicitThis = True)]
        public void SetFloat(int nameID, float f);
        [FreeFunction(Name = "VisualEffectBindings::SetValueFromScript<Vector2f>", HasExplicitThis = True)]
        public void SetVector2(int nameID, Vector2 v);
        [FreeFunction(Name = "VisualEffectBindings::SetValueFromScript<Vector3f>", HasExplicitThis = True)]
        public void SetVector3(int nameID, Vector3 v);
        [FreeFunction(Name = "VisualEffectBindings::SetValueFromScript<Vector4f>", HasExplicitThis = True)]
        public void SetVector4(int nameID, Vector4 v);
        [FreeFunction(Name = "VisualEffectBindings::SetValueFromScript<Matrix4x4f>", HasExplicitThis = True)]
        public void SetMatrix4x4(int nameID, Matrix4x4 v);
        [FreeFunction(Name = "VisualEffectBindings::SetValueFromScript<Texture*>", HasExplicitThis = True)]
        public void SetTexture(int nameID, [NotNull("ArgumentNullException")] Texture t);
        [FreeFunction(Name = "VisualEffectBindings::SetValueFromScript<AnimationCurve*>", HasExplicitThis = True)]
        public void SetAnimationCurve(int nameID, [NotNull("ArgumentNullException")] AnimationCurve c);
        [FreeFunction(Name = "VisualEffectBindings::SetValueFromScript<Gradient*>", HasExplicitThis = True)]
        public void SetGradient(int nameID, [NotNull("ArgumentNullException")] Gradient g);
        [FreeFunction(Name = "VisualEffectBindings::SetValueFromScript<Mesh*>", HasExplicitThis = True)]
        public void SetMesh(int nameID, [NotNull("ArgumentNullException")] Mesh m);
        [FreeFunction(Name = "VisualEffectBindings::GetValueFromScript<bool>", HasExplicitThis = True)]
        public bool GetBool(int nameID);
        [FreeFunction(Name = "VisualEffectBindings::GetValueFromScript<int>", HasExplicitThis = True)]
        public int GetInt(int nameID);
        [FreeFunction(Name = "VisualEffectBindings::GetValueFromScript<UInt32>", HasExplicitThis = True)]
        public uint GetUInt(int nameID);
        [FreeFunction(Name = "VisualEffectBindings::GetValueFromScript<float>", HasExplicitThis = True)]
        public float GetFloat(int nameID);
        [FreeFunction(Name = "VisualEffectBindings::GetValueFromScript<Vector2f>", HasExplicitThis = True)]
        public Vector2 GetVector2(int nameID);
        [FreeFunction(Name = "VisualEffectBindings::GetValueFromScript<Vector3f>", HasExplicitThis = True)]
        public Vector3 GetVector3(int nameID);
        [FreeFunction(Name = "VisualEffectBindings::GetValueFromScript<Vector4f>", HasExplicitThis = True)]
        public Vector4 GetVector4(int nameID);
        [FreeFunction(Name = "VisualEffectBindings::GetValueFromScript<Matrix4x4f>", HasExplicitThis = True)]
        public Matrix4x4 GetMatrix4x4(int nameID);
        [FreeFunction(Name = "VisualEffectBindings::GetValueFromScript<Texture*>", HasExplicitThis = True)]
        public Texture GetTexture(int nameID);
        [FreeFunction(Name = "VisualEffectBindings::GetValueFromScript<Mesh*>", HasExplicitThis = True)]
        public Mesh GetMesh(int nameID);
        public Gradient GetGradient(int nameID);
        public AnimationCurve GetAnimationCurve(int nameID);
        [FreeFunction(Name = "VisualEffectBindings::HasSystemFromScript", HasExplicitThis = True)]
        public bool HasSystem(int nameID);
        [FreeFunction(Name = "VisualEffectBindings::GetParticleSystemInfo", HasExplicitThis = True, ThrowsException = True)]
        public VFXParticleSystemInfo GetParticleSystemInfo(int nameID);
        public void GetSpawnSystemInfo(int nameID, VFXSpawnerState spawnState);
        public VFXSpawnerState GetSpawnSystemInfo(int nameID);
        [FreeFunction(Name = "VisualEffectBindings::GetSystemNamesFromScript", HasExplicitThis = True)]
        public void GetSystemNames([NotNull("ArgumentNullException")] List<string> names);
        [FreeFunction(Name = "VisualEffectBindings::GetParticleSystemNamesFromScript", HasExplicitThis = True)]
        public void GetParticleSystemNames([NotNull("ArgumentNullException")] List<string> names);
        [FreeFunction(Name = "VisualEffectBindings::GetOutputEventNamesFromScript", HasExplicitThis = True)]
        public void GetOutputEventNames([NotNull("ArgumentNullException")] List<string> names);
        [FreeFunction(Name = "VisualEffectBindings::GetSpawnSystemNamesFromScript", HasExplicitThis = True)]
        public void GetSpawnSystemNames([NotNull("ArgumentNullException")] List<string> names);
        public void ResetOverride(string name);
        public bool HasInt(string name);
        public bool HasUInt(string name);
        public bool HasFloat(string name);
        public bool HasVector2(string name);
        public bool HasVector3(string name);
        public bool HasVector4(string name);
        public bool HasMatrix4x4(string name);
        public bool HasTexture(string name);
        public TextureDimension GetTextureDimension(string name);
        public bool HasAnimationCurve(string name);
        public bool HasGradient(string name);
        public bool HasMesh(string name);
        public bool HasBool(string name);
        public void SetInt(string name, int i);
        public void SetUInt(string name, uint i);
        public void SetFloat(string name, float f);
        public void SetVector2(string name, Vector2 v);
        public void SetVector3(string name, Vector3 v);
        public void SetVector4(string name, Vector4 v);
        public void SetMatrix4x4(string name, Matrix4x4 v);
        public void SetTexture(string name, Texture t);
        public void SetAnimationCurve(string name, AnimationCurve c);
        public void SetGradient(string name, Gradient g);
        public void SetMesh(string name, Mesh m);
        public void SetBool(string name, bool b);
        public int GetInt(string name);
        public uint GetUInt(string name);
        public float GetFloat(string name);
        public Vector2 GetVector2(string name);
        public Vector3 GetVector3(string name);
        public Vector4 GetVector4(string name);
        public Matrix4x4 GetMatrix4x4(string name);
        public Texture GetTexture(string name);
        public Mesh GetMesh(string name);
        public bool GetBool(string name);
        public AnimationCurve GetAnimationCurve(string name);
        public Gradient GetGradient(string name);
        public bool HasSystem(string name);
        public VFXParticleSystemInfo GetParticleSystemInfo(string name);
        public VFXSpawnerState GetSpawnSystemInfo(string name);
        public void Simulate(float stepDeltaTime, uint stepCount = 1);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.VFX
{
    [NativeHeader("Modules/VFX/Public/VFXSystem.h")]
    [UsedByNativeCode]
    public struct VFXParticleSystemInfo
    {
        public uint aliveCount;
        public uint capacity;
        public bool sleeping;
        public Bounds bounds;

        public VFXParticleSystemInfo(uint aliveCount, uint capacity, bool sleeping, Bounds bounds);
    }
}
-------- {UnityEngine.VRModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.VRModule.dll)}:    9 --------
using System;
using UnityEngine.XR.WSA;

namespace UnityEngineInternal.XR.WSA
{
    public class RemoteSpeechAccess
    {
        public RemoteSpeechAccess();

        [Obsolete("Support for built-in VR will be removed in Unity 2020.2. Please update to the new Unity XR Plugin System. More information about the new XR Plugin System can be found at https://docs.unity3d.com/2019.3/Documentation/Manual/XR.html.", False)]
        public static void EnableRemoteSpeech(RemoteDeviceVersion version);
        [Obsolete("Support for built-in VR will be removed in Unity 2020.2. Please update to the new Unity XR Plugin System. More information about the new XR Plugin System can be found at https://docs.unity3d.com/2019.3/Documentation/Manual/XR.html.", False)]
        public static void DisableRemoteSpeech();
    }
}
namespace UnityEngine.XR
{
    public enum GameViewRenderMode
    {
        None = 0,
        LeftEye = 1,
        RightEye = 2,
        BothEyes = 3,
        OcclusionMesh = 4
    }
}
using UnityEngine.Bindings;
using UnityEngine.Rendering;

namespace UnityEngine.XR
{
    [NativeHeader("Modules/VR/VRModule.h")]
    [NativeHeader("Runtime/GfxDevice/GfxDeviceTypes.h")]
    [NativeHeader("Modules/VR/ScriptBindings/XR.bindings.h")]
    [NativeHeader("Runtime/Interfaces/IVRDevice.h")]
    [NativeConditional("ENABLE_VR")]
    public static class XRSettings
    {
        public static bool enabled { get; set; }
        [StaticAccessor("GetIVRDeviceScripting()", ArrowWithDefaultReturnIfNull)]
        public static GameViewRenderMode gameViewRenderMode { get; set; }
        [StaticAccessor("GetIVRDeviceScripting()", ArrowWithDefaultReturnIfNull)]
        [NativeName("Active")]
        public static bool isDeviceActive { get; }
        [StaticAccessor("GetIVRDeviceScripting()", ArrowWithDefaultReturnIfNull)]
        public static bool showDeviceView { get; set; }
        [NativeName("RenderScale")]
        [StaticAccessor("GetIVRDeviceScripting()", ArrowWithDefaultReturnIfNull)]
        public static float eyeTextureResolutionScale { get; set; }
        [StaticAccessor("GetIVRDeviceScripting()", ArrowWithDefaultReturnIfNull)]
        public static int eyeTextureWidth { get; }
        [StaticAccessor("GetIVRDeviceScripting()", ArrowWithDefaultReturnIfNull)]
        public static int eyeTextureHeight { get; }
        [NativeConditional("ENABLE_VR", "RenderTextureDesc()")]
        [StaticAccessor("GetIVRDeviceScripting()", ArrowWithDefaultReturnIfNull)]
        [NativeName("IntermediateEyeTextureDesc")]
        public static RenderTextureDescriptor eyeTextureDesc { get; }
        [NativeName("DeviceEyeTextureDimension")]
        [StaticAccessor("GetIVRDeviceScripting()", ArrowWithDefaultReturnIfNull)]
        public static TextureDimension deviceEyeTextureDimension { get; }
        public static float renderViewportScale { get; set; }
        [StaticAccessor("GetIVRDevice()", ArrowWithDefaultReturnIfNull)]
        public static float occlusionMaskScale { get; set; }
        [StaticAccessor("GetIVRDevice()", ArrowWithDefaultReturnIfNull)]
        public static bool useOcclusionMesh { get; set; }
        [StaticAccessor("GetIVRDeviceScripting()", ArrowWithDefaultReturnIfNull)]
        [NativeName("DeviceName")]
        public static string loadedDeviceName { get; }
        public static string[] supportedDevices { get; }
        [StaticAccessor("GetIVRDeviceScripting()", ArrowWithDefaultReturnIfNull)]
        public static StereoRenderingMode stereoRenderingMode { get; }

        public static void LoadDeviceByName(string deviceName);
        public static void LoadDeviceByName(string[] prioritizedDeviceNameList);

        public enum StereoRenderingMode
        {
            MultiPass = 0,
            SinglePass = 1,
            SinglePassInstanced = 2,
            SinglePassMultiview = 3
        }
    }
}
using System;

namespace UnityEngine.XR
{
    [Obsolete("This is obsolete, and should no longer be used.  Please use InputTrackingModeFlags.")]
    public enum TrackingSpaceType
    {
        Stationary = 0,
        RoomScale = 1
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEngine.XR
{
    [NativeConditional("ENABLE_VR")]
    public static class XRDevice
    {
        [Obsolete("This is obsolete, and should no longer be used. Instead, find the active XRDisplaySubsystem and check that the running property is true (for details, see XRDevice.isPresent documentation).", True)]
        public static bool isPresent { get; }
        [StaticAccessor("GetIVRDeviceScripting()", ArrowWithDefaultReturnIfNull)]
        [NativeName("DeviceRefreshRate")]
        public static float refreshRate { get; }
        public static float fovZoomFactor { get; set; }

        public static event Action<string> deviceLoaded;

        [StaticAccessor("GetIVRDeviceScripting()", ArrowWithDefaultReturnIfNull)]
        public static IntPtr GetNativePtr();
        [StaticAccessor("GetIVRDevice()", ArrowWithDefaultReturnIfNull)]
        [Obsolete("This is obsolete, and should no longer be used.  Please use XRInputSubsystem.GetTrackingOriginMode.")]
        public static TrackingSpaceType GetTrackingSpaceType();
        [StaticAccessor("GetIVRDevice()", ArrowWithDefaultReturnIfNull)]
        [Obsolete("This is obsolete, and should no longer be used.  Please use XRInputSubsystem.TrySetTrackingOriginMode.")]
        public static bool SetTrackingSpaceType(TrackingSpaceType trackingSpaceType);
        [NativeName("DisableAutoVRCameraTracking")]
        [StaticAccessor("GetIVRDevice()", ArrowWithDefaultReturnIfNull)]
        public static void DisableAutoXRCameraTracking([NotNull("ArgumentNullException")] Camera camera, bool disabled);
        [NativeName("UpdateEyeTextureMSAASetting")]
        [StaticAccessor("GetIVRDeviceScripting()", ArrowWithDefaultReturnIfNull)]
        public static void UpdateEyeTextureMSAASetting();
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.XR
{
    [NativeConditional("ENABLE_VR")]
    public static class XRStats
    {
        [StaticAccessor("GetIVRDeviceScripting()", ArrowWithDefaultReturnIfNull)]
        public static bool TryGetGPUTimeLastFrame(out float gpuTimeLastFrame);
        [StaticAccessor("GetIVRDeviceScripting()", ArrowWithDefaultReturnIfNull)]
        public static bool TryGetDroppedFrameCount(out int droppedFrameCount);
        [StaticAccessor("GetIVRDeviceScripting()", ArrowWithDefaultReturnIfNull)]
        public static bool TryGetFramePresentCount(out int framePresentCount);
    }
}
namespace UnityEngine.XR.WSA
{
    public enum RemoteDeviceVersion
    {
        V1 = 0,
        V2 = 1
    }
}
-------- {UnityEngine.VehiclesModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.VehiclesModule.dll)}:    1 --------
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Vehicles/WheelCollider.h")]
    public struct WheelHit
    {
        public Collider collider { get; set; }
        public Vector3 point { get; set; }
        public Vector3 normal { get; set; }
        public Vector3 forwardDir { get; set; }
        public Vector3 sidewaysDir { get; set; }
        public float force { get; set; }
        public float forwardSlip { get; set; }
        public float sidewaysSlip { get; set; }
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Vehicles/WheelCollider.h")]
    [NativeHeader("PhysicsScriptingClasses.h")]
    public class WheelCollider : Collider
    {
        public WheelCollider();

        public Vector3 center { get; set; }
        public float radius { get; set; }
        public float suspensionDistance { get; set; }
        public JointSpring suspensionSpring { get; set; }
        public bool suspensionExpansionLimited { get; set; }
        public float forceAppPointDistance { get; set; }
        public float mass { get; set; }
        public float wheelDampingRate { get; set; }
        public WheelFrictionCurve forwardFriction { get; set; }
        public WheelFrictionCurve sidewaysFriction { get; set; }
        public float motorTorque { get; set; }
        public float brakeTorque { get; set; }
        public float steerAngle { get; set; }
        public bool isGrounded { get; }
        public float rpm { get; }
        public float sprungMass { get; set; }

        public void ResetSprungMasses();
        public void ConfigureVehicleSubsteps(float speedThreshold, int stepsBelowThreshold, int stepsAboveThreshold);
        public void GetWorldPose(out Vector3 pos, out Quaternion quat);
        public bool GetGroundHit(out WheelHit hit);
    }
}
-------- {UnityEngine.VideoModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.VideoModule.dll)}:   22 --------
using System;
using System.ComponentModel;
using UnityEngine.Bindings;
using UnityEngine.Playables;
using UnityEngine.Scripting;
using UnityEngine.Video;

namespace UnityEngine.Experimental.Video
{
    [StaticAccessor("VideoClipPlayableBindings", DoubleColon)]
    [NativeHeader("Runtime/Director/Core/HPlayable.h")]
    [NativeHeader("Modules/Video/Public/Director/VideoClipPlayable.h")]
    [NativeHeader("Modules/Video/Public/ScriptBindings/VideoClipPlayable.bindings.h")]
    [NativeHeader("Modules/Video/Public/VideoClip.h")]
    [RequiredByNativeCode]
    public struct VideoClipPlayable : IEquatable<VideoClipPlayable>, IPlayable
    {
        public static VideoClipPlayable Create(PlayableGraph graph, VideoClip clip, bool looping);
        public PlayableHandle GetHandle();
        public bool Equals(VideoClipPlayable other);
        public VideoClip GetClip();
        public void SetClip(VideoClip value);
        public bool GetLooped();
        public void SetLooped(bool value);
        public bool IsPlaying();
        public double GetStartDelay();
        public double GetPauseDelay();
        public void Seek(double startTime, double startDelay);
        public void Seek(double startTime, double startDelay, [DefaultValue("0")] double duration);

        public static implicit operator Playable(VideoClipPlayable playable);
        public static explicit operator VideoClipPlayable(Playable playable);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Experimental.Audio;
using UnityEngine.Video;

namespace UnityEngine.Experimental.Video
{
    [NativeHeader("VideoScriptingClasses.h")]
    [NativeHeader("Modules/Video/Public/VideoPlayer.h")]
    [StaticAccessor("VideoPlayerExtensionsBindings", DoubleColon)]
    [NativeHeader("Modules/Video/Public/ScriptBindings/VideoPlayerExtensions.bindings.h")]
    public static class VideoPlayerExtensions
    {
        public static AudioSampleProvider GetAudioSampleProvider(this VideoPlayer vp, ushort trackIndex);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Video
{
    [NativeHeader("Modules/Video/Public/VideoClip.h")]
    [RequiredByNativeCode]
    public sealed class VideoClip : Object
    {
        public string originalPath { get; }
        public ulong frameCount { get; }
        public double frameRate { get; }
        [NativeName("Duration")]
        public double length { get; }
        public uint width { get; }
        public uint height { get; }
        public uint pixelAspectRatioNumerator { get; }
        public uint pixelAspectRatioDenominator { get; }
        public bool sRGB { get; }
        public ushort audioTrackCount { get; }

        public ushort GetAudioChannelCount(ushort audioTrackIdx);
        public uint GetAudioSampleRate(ushort audioTrackIdx);
        public string GetAudioLanguage(ushort audioTrackIdx);
    }
}
using UnityEngine.Scripting;

namespace UnityEngine.Video
{
    [RequiredByNativeCode]
    public enum VideoRenderMode
    {
        CameraFarPlane = 0,
        CameraNearPlane = 1,
        RenderTexture = 2,
        MaterialOverride = 3,
        APIOnly = 4
    }
}
using UnityEngine.Scripting;

namespace UnityEngine.Video
{
    [RequiredByNativeCode]
    public enum Video3DLayout
    {
        No3D = 0,
        SideBySide3D = 1,
        OverUnder3D = 2
    }
}
using UnityEngine.Scripting;

namespace UnityEngine.Video
{
    [RequiredByNativeCode]
    public enum VideoAspectRatio
    {
        NoScaling = 0,
        FitVertically = 1,
        FitHorizontally = 2,
        FitInside = 3,
        FitOutside = 4,
        Stretch = 5
    }
}
using UnityEngine.Scripting;

namespace UnityEngine.Video
{
    [RequiredByNativeCode]
    public enum VideoTimeSource
    {
        AudioDSPTimeSource = 0,
        GameTimeSource = 1
    }
}
using UnityEngine.Scripting;

namespace UnityEngine.Video
{
    [RequiredByNativeCode]
    public enum VideoTimeReference
    {
        Freerun = 0,
        InternalTime = 1,
        ExternalTime = 2
    }
}
using UnityEngine.Scripting;

namespace UnityEngine.Video
{
    [RequiredByNativeCode]
    public enum VideoSource
    {
        VideoClip = 0,
        Url = 1
    }
}
using UnityEngine.Scripting;

namespace UnityEngine.Video
{
    [RequiredByNativeCode]
    public enum VideoAudioOutputMode
    {
        None = 0,
        AudioSource = 1,
        Direct = 2,
        APIOnly = 3
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Video
{
    [RequireComponent(typeof(Transform))]
    [NativeHeader("Modules/Video/Public/VideoPlayer.h")]
    [RequiredByNativeCode]
    public sealed class VideoPlayer : Behaviour
    {
        public VideoPlayer();

        public VideoSource source { get; set; }
        [NativeName("VideoUrl")]
        public string url { get; set; }
        [NativeName("VideoClip")]
        public VideoClip clip { get; set; }
        public VideoRenderMode renderMode { get; set; }
        [NativeHeader("Runtime/Camera/Camera.h")]
        public Camera targetCamera { get; set; }
        [NativeHeader("Runtime/Graphics/RenderTexture.h")]
        public RenderTexture targetTexture { get; set; }
        [NativeHeader("Runtime/Graphics/Renderer.h")]
        public Renderer targetMaterialRenderer { get; set; }
        public string targetMaterialProperty { get; set; }
        public VideoAspectRatio aspectRatio { get; set; }
        public float targetCameraAlpha { get; set; }
        public Video3DLayout targetCamera3DLayout { get; set; }
        [NativeHeader("Runtime/Graphics/Texture.h")]
        public Texture texture { get; }
        public bool isPrepared { get; }
        public bool waitForFirstFrame { get; set; }
        public bool playOnAwake { get; set; }
        public bool isPlaying { get; }
        public bool isPaused { get; }
        public bool canSetTime { get; }
        [NativeName("SecPosition")]
        public double time { get; set; }
        [NativeName("FramePosition")]
        public long frame { get; set; }
        public double clockTime { get; }
        public bool canStep { get; }
        public bool canSetPlaybackSpeed { get; }
        public float playbackSpeed { get; set; }
        [NativeName("Loop")]
        public bool isLooping { get; set; }
        public bool canSetTimeSource { get; }
        public VideoTimeSource timeSource { get; set; }
        public VideoTimeReference timeReference { get; set; }
        public double externalReferenceTime { get; set; }
        public bool canSetSkipOnDrop { get; }
        public bool skipOnDrop { get; set; }
        public ulong frameCount { get; }
        public float frameRate { get; }
        [NativeName("Duration")]
        public double length { get; }
        public uint width { get; }
        public uint height { get; }
        public uint pixelAspectRatioNumerator { get; }
        public uint pixelAspectRatioDenominator { get; }
        public ushort audioTrackCount { get; }
        public static ushort controlledAudioTrackMaxCount { get; }
        public ushort controlledAudioTrackCount { get; set; }
        public VideoAudioOutputMode audioOutputMode { get; set; }
        public bool canSetDirectAudioVolume { get; }
        public bool sendFrameReadyEvents { get; set; }

        public event EventHandler prepareCompleted;
        public event EventHandler loopPointReached;
        public event EventHandler started;
        public event EventHandler frameDropped;
        public event ErrorEventHandler errorReceived;
        public event EventHandler seekCompleted;
        public event TimeEventHandler clockResyncOccurred;
        public event FrameReadyEventHandler frameReady;

        public void Prepare();
        public void Play();
        public void Pause();
        public void Stop();
        public void StepForward();
        public string GetAudioLanguageCode(ushort trackIndex);
        public ushort GetAudioChannelCount(ushort trackIndex);
        public uint GetAudioSampleRate(ushort trackIndex);
        public void EnableAudioTrack(ushort trackIndex, bool enabled);
        public bool IsAudioTrackEnabled(ushort trackIndex);
        public float GetDirectAudioVolume(ushort trackIndex);
        public void SetDirectAudioVolume(ushort trackIndex, float volume);
        public bool GetDirectAudioMute(ushort trackIndex);
        public void SetDirectAudioMute(ushort trackIndex, bool mute);
        [NativeHeader("Modules/Audio/Public/AudioSource.h")]
        public AudioSource GetTargetAudioSource(ushort trackIndex);
        public void SetTargetAudioSource(ushort trackIndex, AudioSource source);

        public delegate void EventHandler(VideoPlayer source);
        public delegate void ErrorEventHandler(VideoPlayer source, string message);
        public delegate void FrameReadyEventHandler(VideoPlayer source, long frameIdx);
        public delegate void TimeEventHandler(VideoPlayer source, double seconds);
    }
}
-------- {UnityEngine.VirtualTexturingModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.VirtualTexturingModule.dll)}:   22 --------
using UnityEngine.Bindings;

namespace UnityEngine.Rendering.VirtualTexturing
{
    [StaticAccessor("VirtualTexturing::System", DoubleColon)]
    [NativeHeader("Modules/VirtualTexturing/ScriptBindings/VirtualTexturing.bindings.h")]
    public static class System
    {
        public const int AllMips = 2147483647;

        [NativeThrows]
        public static void Update();
    }
}
using UnityEngine.Bindings;
using UnityEngine.Experimental.Rendering;

namespace UnityEngine.Rendering.VirtualTexturing
{
    [StaticAccessor("VirtualTexturing::Editor", DoubleColon)]
    [NativeConditional("UNITY_EDITOR")]
    [NativeHeader("Modules/VirtualTexturing/ScriptBindings/VirtualTexturing.bindings.h")]
    public static class EditorHelpers
    {
        [NativeThrows]
        public static bool ValidateTextureStack([NotNull("ArgumentNullException")] Texture[] textures, out string errorMessage);
        [NativeConditional("UNITY_EDITOR", "{}")]
        [NativeThrows]
        public static GraphicsFormat[] QuerySupportedFormats();
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.Rendering.VirtualTexturing
{
    [StaticAccessor("VirtualTexturing::Debugging", DoubleColon)]
    [NativeHeader("Modules/VirtualTexturing/ScriptBindings/VirtualTexturing.bindings.h")]
    public static class Debugging
    {
        [NativeThrows]
        public static bool debugTilesEnabled { get; set; }
        [NativeThrows]
        public static bool resolvingEnabled { get; set; }
        [NativeThrows]
        public static bool flushEveryTickEnabled { get; set; }

        [NativeThrows]
        public static int GetNumHandles();
        [NativeThrows]
        public static void GrabHandleInfo(out Handle debugHandle, int index);
        [NativeThrows]
        public static string GetInfoDump();

        [NativeHeader("Modules/VirtualTexturing/Public/VirtualTexturingDebugHandle.h")]
        [UsedByNativeCode]
        public struct Handle
        {
            public long handle;
            public string group;
            public string name;
            public int numLayers;
            public Material material;
        }
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEngine.Rendering.VirtualTexturing
{
    [NativeHeader("Modules/VirtualTexturing/Public/VirtualTextureResolver.h")]
    public class Resolver : IDisposable
    {
        public Resolver();

        ~Resolver();

        public int CurrentWidth { get; }
        public int CurrentHeight { get; }

        public void Dispose();
        protected virtual void Dispose(bool disposing);
        public void UpdateSize(int width, int height);
        public void Process(CommandBuffer cmd, RenderTargetIdentifier rt);
        public void Process(CommandBuffer cmd, RenderTargetIdentifier rt, int x, int width, int y, int height, int mip, int slice);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Experimental.Rendering;
using UnityEngine.Scripting;

namespace UnityEngine.Rendering.VirtualTexturing
{
    [NativeHeader("Modules/VirtualTexturing/Public/VirtualTexturingSettings.h")]
    [UsedByNativeCode]
    public struct GPUCacheSetting
    {
        public GraphicsFormat format;
        public uint sizeInMegaBytes;
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Rendering.VirtualTexturing
{
    [NativeHeader("Modules/VirtualTexturing/Public/VirtualTexturingFilterMode.h")]
    public enum FilterMode
    {
        Bilinear = 1,
        Trilinear = 2
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.Rendering.VirtualTexturing
{
    [NativeHeader("Modules/VirtualTexturing/ScriptBindings/VirtualTexturing.bindings.h")]
    [StaticAccessor("VirtualTexturing::Streaming", DoubleColon)]
    public static class Streaming
    {
        [NativeThrows]
        public static void RequestRegion([NotNull("ArgumentNullException")] Material mat, int stackNameId, Rect r, int mipMap, int numMips);
        [NativeThrows]
        public static void GetTextureStackSize([NotNull("ArgumentNullException")] Material mat, int stackNameId, out int width, out int height);
        [NativeThrows]
        public static void SetCPUCacheSize(int sizeInMegabytes);
        [NativeThrows]
        public static void SetGPUCacheSettings(GPUCacheSetting[] cacheSettings);
    }
}
using System;
using Unity.Collections;
using UnityEngine.Bindings;
using UnityEngine.Experimental.Rendering;
using UnityEngine.Scripting;

namespace UnityEngine.Rendering.VirtualTexturing
{
    [StaticAccessor("VirtualTexturing::Procedural", DoubleColon)]
    [NativeHeader("Modules/VirtualTexturing/ScriptBindings/VirtualTexturing.bindings.h")]
    public static class Procedural
    {
        [NativeThrows]
        public static void SetCPUCacheSize(int sizeInMegabytes);
        [NativeThrows]
        public static int GetCPUCacheSize();
        [NativeThrows]
        public static void SetGPUCacheSettings(GPUCacheSetting[] cacheSettings);
        [NativeThrows]
        public static GPUCacheSetting[] GetGPUCacheSettings();

        [NativeHeader("Modules/VirtualTexturing/ScriptBindings/VirtualTexturing.bindings.h")]
        public struct CreationParameters
        {
            public const int MaxNumLayers = 4;
            public const int MaxRequestsPerFrameSupported = 4095;
            public int width;
            public int height;
            public int maxActiveRequests;
            public int tilesize;
            public GraphicsFormat[] layers;
            public FilterMode filterMode;
        }
        public struct TextureStackRequestHandle<T> : IEquatable<TextureStackRequestHandle<T>> where T : struct
        {
            public override bool Equals(object obj);
            public bool Equals(TextureStackRequestHandle<T> other);
            public override int GetHashCode();
            public void CompleteRequest(RequestStatus status);
            public void CompleteRequest(RequestStatus status, CommandBuffer fenceBuffer);
            public static void CompleteRequests(NativeSlice<TextureStackRequestHandle<T>> requestHandles, NativeSlice<RequestStatus> status);
            public static void CompleteRequests(NativeSlice<TextureStackRequestHandle<T>> requestHandles, NativeSlice<RequestStatus> status, CommandBuffer fenceBuffer);
            public T GetRequestParameters();
            public static void GetRequestParameters(NativeSlice<TextureStackRequestHandle<T>> handles, NativeSlice<T> requests);

            public static bool operator !=(TextureStackRequestHandle<T> h1, TextureStackRequestHandle<T> h2);
            public static bool operator ==(TextureStackRequestHandle<T> h1, TextureStackRequestHandle<T> h2);
        }
        [UsedByNativeCode]
        [NativeHeader("Modules/VirtualTexturing/ScriptBindings/VirtualTexturing.bindings.h")]
        public struct GPUTextureStackRequestLayerParameters
        {
            public int destX;
            public int destY;
            public RenderTargetIdentifier dest;

            public int GetWidth();
            public int GetHeight();
        }
        [UsedByNativeCode]
        [NativeHeader("Modules/VirtualTexturing/ScriptBindings/VirtualTexturing.bindings.h")]
        public struct CPUTextureStackRequestLayerParameters
        {
            public int scanlineSize { get; }
            public int mipScanlineSize { get; }
            public bool requiresCachedMip { get; }

            public NativeArray<T> GetData<T>() where T : struct;
            public NativeArray<T> GetMipData<T>() where T : struct;
        }
        [UsedByNativeCode]
        [NativeHeader("Modules/VirtualTexturing/ScriptBindings/VirtualTexturing.bindings.h")]
        public struct GPUTextureStackRequestParameters
        {
            public int level;
            public int x;
            public int y;
            public int width;
            public int height;
            public int numLayers;

            public GPUTextureStackRequestLayerParameters GetLayer(int index);
        }
        [UsedByNativeCode]
        [NativeHeader("Modules/VirtualTexturing/ScriptBindings/VirtualTexturing.bindings.h")]
        public struct CPUTextureStackRequestParameters
        {
            public int level;
            public int x;
            public int y;
            public int width;
            public int height;
            public int numLayers;

            public CPUTextureStackRequestLayerParameters GetLayer(int index);
        }
        public enum RequestStatus
        {
            Dropped = 65539,
            Generated = 65538
        }
        public class TextureStackBase<T> : IDisposable where T : struct
        {
            public static readonly int borderSize;
            public const int AllMips = 2147483647;

            public TextureStackBase(string _name, CreationParameters _creationParams, bool gpuGeneration);

            public int PopRequests(NativeSlice<TextureStackRequestHandle<T>> requestHandles);
            public bool IsValid();
            public void Dispose();
            public void BindToMaterialPropertyBlock(MaterialPropertyBlock mpb);
            public void BindToMaterial(Material mat);
            public void BindGlobally();
            public void RequestRegion(Rect r, int mipMap, int numMips);
            public void InvalidateRegion(Rect r, int mipMap, int numMips);
            public void EvictRegion(Rect r, int mipMap, int numMips);
        }
        public sealed class GPUTextureStack : TextureStackBase<GPUTextureStackRequestParameters>
        {
            public GPUTextureStack(string _name, CreationParameters creationParams);
        }
        public sealed class CPUTextureStack : TextureStackBase<CPUTextureStackRequestParameters>
        {
            public CPUTextureStack(string _name, CreationParameters creationParams);
        }
    }
}
-------- {UnityEngine.WindModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.WindModule.dll)}:    1 --------
namespace UnityEngine
{
    public enum WindZoneMode
    {
        Directional = 0,
        Spherical = 1
    }
}
using UnityEngine.Bindings;

namespace UnityEngine
{
    [NativeHeader("Modules/Wind/Public/Wind.h")]
    public class WindZone : Component
    {
        public WindZone();

        public WindZoneMode mode { get; set; }
        public float radius { get; set; }
        public float windMain { get; set; }
        public float windTurbulence { get; set; }
        public float windPulseMagnitude { get; set; }
        public float windPulseFrequency { get; set; }
    }
}
-------- {UnityEngine.XRModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEngine.XRModule.dll)}:   47 --------
using System;
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.XR
{
    [StaticAccessor("XRInputTrackingFacade::Get()", Dot)]
    [NativeHeader("Modules/XR/Subsystems/Input/Public/XRInputTrackingFacade.h")]
    [NativeConditional("ENABLE_VR")]
    [RequiredByNativeCode]
    public static class InputTracking
    {
        [Obsolete("This API is obsolete, and should no longer be used. Please use the TrackedPoseDriver in the Legacy Input Helpers package for controlling a camera in XR.")]
        [NativeConditional("ENABLE_VR")]
        public static bool disablePositionalTracking { get; set; }

        public static event Action<XRNodeState> trackingAcquired;
        public static event Action<XRNodeState> trackingLost;
        public static event Action<XRNodeState> nodeAdded;
        public static event Action<XRNodeState> nodeRemoved;

        [Obsolete("This API is obsolete, and should no longer be used. Please use InputDevice.TryGetFeatureValue with the CommonUsages.devicePosition usage instead.")]
        [NativeConditional("ENABLE_VR", "Vector3f::zero")]
        public static Vector3 GetLocalPosition(XRNode node);
        [Obsolete("This API is obsolete, and should no longer be used. Please use InputDevice.TryGetFeatureValue with the CommonUsages.deviceRotation usage instead.")]
        [NativeConditional("ENABLE_VR", "Quaternionf::identity()")]
        public static Quaternion GetLocalRotation(XRNode node);
        [NativeConditional("ENABLE_VR")]
        [Obsolete("This API is obsolete, and should no longer be used. Please use XRInputSubsystem.TryRecenter() instead.")]
        public static void Recenter();
        [NativeConditional("ENABLE_VR")]
        [Obsolete("This API is obsolete, and should no longer be used. Please use InputDevice.name with the device associated with that tracking data instead.")]
        public static string GetNodeName(ulong uniqueId);
        public static void GetNodeStates(List<XRNodeState> nodeStates);
    }
}
namespace UnityEngine.XR
{
    public enum XRNode
    {
        LeftEye = 0,
        RightEye = 1,
        CenterEye = 2,
        Head = 3,
        LeftHand = 4,
        RightHand = 5,
        GameController = 6,
        TrackingReference = 7,
        HardwareTracker = 8
    }
}
using UnityEngine.Scripting;

namespace UnityEngine.XR
{
    [UsedByNativeCode]
    public struct XRNodeState
    {
        public ulong uniqueID { get; set; }
        public XRNode nodeType { get; set; }
        public bool tracked { get; set; }
        public Vector3 position { set; }
        public Quaternion rotation { set; }
        public Vector3 velocity { set; }
        public Vector3 angularVelocity { set; }
        public Vector3 acceleration { set; }
        public Vector3 angularAcceleration { set; }

        public bool TryGetPosition(out Vector3 position);
        public bool TryGetRotation(out Quaternion rotation);
        public bool TryGetVelocity(out Vector3 velocity);
        public bool TryGetAngularVelocity(out Vector3 angularVelocity);
        public bool TryGetAcceleration(out Vector3 acceleration);
        public bool TryGetAngularAcceleration(out Vector3 angularAcceleration);
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEngine.XR
{
    [NativeConditional("ENABLE_VR")]
    public struct HapticCapabilities : IEquatable<HapticCapabilities>
    {
        public uint numChannels { get; }
        public bool supportsImpulse { get; }
        public bool supportsBuffer { get; }
        public uint bufferFrequencyHz { get; }
        public uint bufferMaxSize { get; }
        public uint bufferOptimalSize { get; }

        public override bool Equals(object obj);
        public bool Equals(HapticCapabilities other);
        public override int GetHashCode();

        public static bool operator ==(HapticCapabilities a, HapticCapabilities b);
        public static bool operator !=(HapticCapabilities a, HapticCapabilities b);
    }
}
namespace UnityEngine.XR
{
    public enum InputDeviceRole
    {
        Unknown = 0,
        Generic = 1,
        LeftHanded = 2,
        RightHanded = 3,
        GameController = 4,
        TrackingReference = 5,
        HardwareTracker = 6,
        LegacyController = 7
    }
}
using System;

namespace UnityEngine.XR
{
    [Flags]
    public enum InputDeviceCharacteristics
    {
        None = 0,
        HeadMounted = 1,
        Camera = 2,
        HeldInHand = 4,
        HandTracking = 8,
        EyeTracking = 16,
        TrackedDevice = 32,
        Controller = 64,
        TrackingReference = 128,
        Left = 256,
        Right = 512,
        Simulated6DOF = 1024
    }
}
using System;

namespace UnityEngine.XR
{
    [Flags]
    public enum InputTrackingState
    {
        None = 0,
        Position = 1,
        Rotation = 2,
        Velocity = 4,
        AngularVelocity = 8,
        Acceleration = 16,
        AngularAcceleration = 32,
        All = 63
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.XR
{
    [NativeConditional("ENABLE_VR")]
    [NativeHeader("Modules/XR/Subsystems/Input/Public/XRInputDevices.h")]
    [RequiredByNativeCode]
    public struct InputFeatureUsage : IEquatable<InputFeatureUsage>
    {
        public string name { get; }
        public Type type { get; }

        public override bool Equals(object obj);
        public bool Equals(InputFeatureUsage other);
        public override int GetHashCode();
        public InputFeatureUsage<T> As<T>();

        public static bool operator ==(InputFeatureUsage a, InputFeatureUsage b);
        public static bool operator !=(InputFeatureUsage a, InputFeatureUsage b);
    }
}
using System;

namespace UnityEngine.XR
{
    public struct InputFeatureUsage<T> : IEquatable<InputFeatureUsage<T>>
    {
        public InputFeatureUsage(string usageName);

        public string name { get; set; }

        public override bool Equals(object obj);
        public bool Equals(InputFeatureUsage<T> other);
        public override int GetHashCode();

        public static bool operator ==(InputFeatureUsage<T> a, InputFeatureUsage<T> b);
        public static bool operator !=(InputFeatureUsage<T> a, InputFeatureUsage<T> b);

        public static explicit operator InputFeatureUsage(InputFeatureUsage<T> self);
    }
}
using System;

namespace UnityEngine.XR
{
    public static class CommonUsages
    {
        public static InputFeatureUsage<bool> isTracked;
        public static InputFeatureUsage<bool> primaryButton;
        public static InputFeatureUsage<bool> primaryTouch;
        public static InputFeatureUsage<bool> secondaryButton;
        public static InputFeatureUsage<bool> secondaryTouch;
        public static InputFeatureUsage<bool> gripButton;
        public static InputFeatureUsage<bool> triggerButton;
        public static InputFeatureUsage<bool> menuButton;
        public static InputFeatureUsage<bool> primary2DAxisClick;
        public static InputFeatureUsage<bool> primary2DAxisTouch;
        public static InputFeatureUsage<bool> secondary2DAxisClick;
        public static InputFeatureUsage<bool> secondary2DAxisTouch;
        public static InputFeatureUsage<bool> userPresence;
        public static InputFeatureUsage<InputTrackingState> trackingState;
        public static InputFeatureUsage<float> batteryLevel;
        public static InputFeatureUsage<float> trigger;
        public static InputFeatureUsage<float> grip;
        public static InputFeatureUsage<Vector2> primary2DAxis;
        public static InputFeatureUsage<Vector2> secondary2DAxis;
        public static InputFeatureUsage<Vector3> devicePosition;
        public static InputFeatureUsage<Vector3> leftEyePosition;
        public static InputFeatureUsage<Vector3> rightEyePosition;
        public static InputFeatureUsage<Vector3> centerEyePosition;
        public static InputFeatureUsage<Vector3> colorCameraPosition;
        public static InputFeatureUsage<Vector3> deviceVelocity;
        public static InputFeatureUsage<Vector3> deviceAngularVelocity;
        public static InputFeatureUsage<Vector3> leftEyeVelocity;
        public static InputFeatureUsage<Vector3> leftEyeAngularVelocity;
        public static InputFeatureUsage<Vector3> rightEyeVelocity;
        public static InputFeatureUsage<Vector3> rightEyeAngularVelocity;
        public static InputFeatureUsage<Vector3> centerEyeVelocity;
        public static InputFeatureUsage<Vector3> centerEyeAngularVelocity;
        public static InputFeatureUsage<Vector3> colorCameraVelocity;
        public static InputFeatureUsage<Vector3> colorCameraAngularVelocity;
        public static InputFeatureUsage<Vector3> deviceAcceleration;
        public static InputFeatureUsage<Vector3> deviceAngularAcceleration;
        public static InputFeatureUsage<Vector3> leftEyeAcceleration;
        public static InputFeatureUsage<Vector3> leftEyeAngularAcceleration;
        public static InputFeatureUsage<Vector3> rightEyeAcceleration;
        public static InputFeatureUsage<Vector3> rightEyeAngularAcceleration;
        public static InputFeatureUsage<Vector3> centerEyeAcceleration;
        public static InputFeatureUsage<Vector3> centerEyeAngularAcceleration;
        public static InputFeatureUsage<Vector3> colorCameraAcceleration;
        public static InputFeatureUsage<Vector3> colorCameraAngularAcceleration;
        public static InputFeatureUsage<Quaternion> deviceRotation;
        public static InputFeatureUsage<Quaternion> leftEyeRotation;
        public static InputFeatureUsage<Quaternion> rightEyeRotation;
        public static InputFeatureUsage<Quaternion> centerEyeRotation;
        public static InputFeatureUsage<Quaternion> colorCameraRotation;
        public static InputFeatureUsage<Hand> handData;
        public static InputFeatureUsage<Eyes> eyesData;
        [Obsolete("CommonUsages.dPad is not used by any XR platform and will be removed.")]
        public static InputFeatureUsage<Vector2> dPad;
        [Obsolete("CommonUsages.indexFinger is not used by any XR platform and will be removed.")]
        public static InputFeatureUsage<float> indexFinger;
        [Obsolete("CommonUsages.MiddleFinger is not used by any XR platform and will be removed.")]
        public static InputFeatureUsage<float> middleFinger;
        [Obsolete("CommonUsages.RingFinger is not used by any XR platform and will be removed.")]
        public static InputFeatureUsage<float> ringFinger;
        [Obsolete("CommonUsages.PinkyFinger is not used by any XR platform and will be removed.")]
        public static InputFeatureUsage<float> pinkyFinger;
        [Obsolete("CommonUsages.thumbrest is Oculus only, and is being moved to their package. Please use OculusUsages.thumbrest. These will still function until removed.")]
        public static InputFeatureUsage<bool> thumbrest;
        [Obsolete("CommonUsages.indexTouch is Oculus only, and is being moved to their package.  Please use OculusUsages.indexTouch. These will still function until removed.")]
        public static InputFeatureUsage<float> indexTouch;
        [Obsolete("CommonUsages.thumbTouch is Oculus only, and is being moved to their package.  Please use OculusUsages.thumbTouch. These will still function until removed.")]
        public static InputFeatureUsage<float> thumbTouch;
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.XR
{
    [NativeConditional("ENABLE_VR")]
    [UsedByNativeCode]
    public struct InputDevice : IEquatable<InputDevice>
    {
        public XRInputSubsystem subsystem { get; }
        public bool isValid { get; }
        public string name { get; }
        [Obsolete("This API has been marked as deprecated and will be removed in future versions. Please use InputDevice.characteristics instead.")]
        public InputDeviceRole role { get; }
        public string manufacturer { get; }
        public string serialNumber { get; }
        public InputDeviceCharacteristics characteristics { get; }

        public bool SendHapticImpulse(uint channel, float amplitude, float duration = 1);
        public bool SendHapticBuffer(uint channel, byte[] buffer);
        public bool TryGetHapticCapabilities(out HapticCapabilities capabilities);
        public void StopHaptics();
        public bool TryGetFeatureUsages(List<InputFeatureUsage> featureUsages);
        public bool TryGetFeatureValue(InputFeatureUsage<bool> usage, out bool value);
        public bool TryGetFeatureValue(InputFeatureUsage<uint> usage, out uint value);
        public bool TryGetFeatureValue(InputFeatureUsage<float> usage, out float value);
        public bool TryGetFeatureValue(InputFeatureUsage<Vector2> usage, out Vector2 value);
        public bool TryGetFeatureValue(InputFeatureUsage<Vector3> usage, out Vector3 value);
        public bool TryGetFeatureValue(InputFeatureUsage<Quaternion> usage, out Quaternion value);
        public bool TryGetFeatureValue(InputFeatureUsage<Hand> usage, out Hand value);
        public bool TryGetFeatureValue(InputFeatureUsage<Bone> usage, out Bone value);
        public bool TryGetFeatureValue(InputFeatureUsage<Eyes> usage, out Eyes value);
        public bool TryGetFeatureValue(InputFeatureUsage<byte[]> usage, byte[] value);
        public bool TryGetFeatureValue(InputFeatureUsage<InputTrackingState> usage, out InputTrackingState value);
        public bool TryGetFeatureValue(InputFeatureUsage<bool> usage, DateTime time, out bool value);
        public bool TryGetFeatureValue(InputFeatureUsage<uint> usage, DateTime time, out uint value);
        public bool TryGetFeatureValue(InputFeatureUsage<float> usage, DateTime time, out float value);
        public bool TryGetFeatureValue(InputFeatureUsage<Vector2> usage, DateTime time, out Vector2 value);
        public bool TryGetFeatureValue(InputFeatureUsage<Vector3> usage, DateTime time, out Vector3 value);
        public bool TryGetFeatureValue(InputFeatureUsage<Quaternion> usage, DateTime time, out Quaternion value);
        public bool TryGetFeatureValue(InputFeatureUsage<InputTrackingState> usage, DateTime time, out InputTrackingState value);
        public override bool Equals(object obj);
        public bool Equals(InputDevice other);
        public override int GetHashCode();

        public static bool operator ==(InputDevice a, InputDevice b);
        public static bool operator !=(InputDevice a, InputDevice b);
    }
}
namespace UnityEngine.XR
{
    public enum HandFinger
    {
        Thumb = 0,
        Index = 1,
        Middle = 2,
        Ring = 3,
        Pinky = 4
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.XR
{
    [NativeHeader("XRScriptingClasses.h")]
    [NativeHeader("Modules/XR/Subsystems/Input/Public/XRInputDevices.h")]
    [RequiredByNativeCode]
    [NativeHeader("Modules/XR/XRPrefix.h")]
    [NativeConditional("ENABLE_VR")]
    [StaticAccessor("XRInputDevices::Get()", Dot)]
    public struct Hand : IEquatable<Hand>
    {
        public bool TryGetRootBone(out Bone boneOut);
        public bool TryGetFingerBones(HandFinger finger, List<Bone> bonesOut);
        public override bool Equals(object obj);
        public bool Equals(Hand other);
        public override int GetHashCode();

        public static bool operator ==(Hand a, Hand b);
        public static bool operator !=(Hand a, Hand b);
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.XR
{
    [RequiredByNativeCode]
    [NativeHeader("XRScriptingClasses.h")]
    [NativeConditional("ENABLE_VR")]
    [StaticAccessor("XRInputDevices::Get()", Dot)]
    [NativeHeader("Modules/XR/XRPrefix.h")]
    [NativeHeader("Modules/XR/Subsystems/Input/Public/XRInputDevices.h")]
    public struct Eyes : IEquatable<Eyes>
    {
        public bool TryGetLeftEyePosition(out Vector3 position);
        public bool TryGetRightEyePosition(out Vector3 position);
        public bool TryGetLeftEyeRotation(out Quaternion rotation);
        public bool TryGetRightEyeRotation(out Quaternion rotation);
        public bool TryGetFixationPoint(out Vector3 fixationPoint);
        public bool TryGetLeftEyeOpenAmount(out float openAmount);
        public bool TryGetRightEyeOpenAmount(out float openAmount);
        public override bool Equals(object obj);
        public bool Equals(Eyes other);
        public override int GetHashCode();

        public static bool operator ==(Eyes a, Eyes b);
        public static bool operator !=(Eyes a, Eyes b);
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.XR
{
    [NativeHeader("XRScriptingClasses.h")]
    [NativeConditional("ENABLE_VR")]
    [RequiredByNativeCode]
    [NativeHeader("Modules/XR/XRPrefix.h")]
    [NativeHeader("Modules/XR/Subsystems/Input/Public/XRInputDevices.h")]
    [StaticAccessor("XRInputDevices::Get()", Dot)]
    public struct Bone : IEquatable<Bone>
    {
        public bool TryGetPosition(out Vector3 position);
        public bool TryGetRotation(out Quaternion rotation);
        public bool TryGetParentBone(out Bone parentBone);
        public bool TryGetChildBones(List<Bone> childBones);
        public override bool Equals(object obj);
        public bool Equals(Bone other);
        public override int GetHashCode();

        public static bool operator ==(Bone a, Bone b);
        public static bool operator !=(Bone a, Bone b);
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.XR
{
    [UsedByNativeCode]
    [NativeConditional("ENABLE_VR")]
    [StaticAccessor("XRInputDevices::Get()", Dot)]
    [NativeHeader("Modules/XR/Subsystems/Input/Public/XRInputDevices.h")]
    public class InputDevices
    {
        public InputDevices();

        public static event Action<InputDevice> deviceConnected;
        public static event Action<InputDevice> deviceDisconnected;
        public static event Action<InputDevice> deviceConfigChanged;

        public static InputDevice GetDeviceAtXRNode(XRNode node);
        public static void GetDevicesAtXRNode(XRNode node, List<InputDevice> inputDevices);
        public static void GetDevices(List<InputDevice> inputDevices);
        [Obsolete("This API has been marked as deprecated and will be removed in future versions. Please use InputDevices.GetDevicesWithCharacteristics instead.")]
        public static void GetDevicesWithRole(InputDeviceRole role, List<InputDevice> inputDevices);
        public static void GetDevicesWithCharacteristics(InputDeviceCharacteristics desiredCharacteristics, List<InputDevice> inputDevices);
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Rendering;
using UnityEngine.Scripting;

namespace UnityEngine.XR
{
    [NativeConditional("ENABLE_XR")]
    [NativeType(Header = "Modules/XR/Subsystems/Display/XRDisplaySubsystem.h")]
    [UsedByNativeCode]
    [NativeHeader("Modules/XR/XRPrefix.h")]
    public class XRDisplaySubsystem : IntegratedSubsystem<XRDisplaySubsystemDescriptor>
    {
        public XRDisplaySubsystem();

        [Obsolete("singlePassRenderingDisabled{get;set;} is deprecated. Use textureLayout and supportedTextureLayouts instead.", False)]
        public bool singlePassRenderingDisabled { get; set; }
        public bool displayOpaque { get; }
        public bool contentProtectionEnabled { get; set; }
        public float scaleOfAllViewports { get; set; }
        public float scaleOfAllRenderTargets { get; set; }
        public float zNear { get; set; }
        public float zFar { get; set; }
        public bool sRGB { get; set; }
        public TextureLayout textureLayout { get; set; }
        public TextureLayout supportedTextureLayouts { get; }
        public ReprojectionMode reprojectionMode { get; set; }
        public bool disableLegacyRenderer { get; set; }

        public event Action<bool> displayFocusChanged;

        public void MarkTransformLateLatched(Transform transform, LateLatchNode nodeType);
        public void SetFocusPlane(Vector3 point, Vector3 normal, Vector3 velocity);
        public void SetMSAALevel(int level);
        public int GetRenderPassCount();
        public void GetRenderPass(int renderPassIndex, out XRRenderPass renderPass);
        public void EndRecordingIfLateLatched(Camera camera);
        public void BeginRecordingIfLateLatched(Camera camera);
        public void GetCullingParameters(Camera camera, int cullingPassIndex, out ScriptableCullingParameters scriptableCullingParameters);
        [NativeMethod("TryGetAppGPUTimeLastFrame")]
        public bool TryGetAppGPUTimeLastFrame(out float gpuTimeLastFrame);
        [NativeMethod("TryGetCompositorGPUTimeLastFrame")]
        public bool TryGetCompositorGPUTimeLastFrame(out float gpuTimeLastFrameCompositor);
        [NativeMethod("TryGetDroppedFrameCount")]
        public bool TryGetDroppedFrameCount(out int droppedFrameCount);
        [NativeMethod("TryGetFramePresentCount")]
        public bool TryGetFramePresentCount(out int framePresentCount);
        [NativeMethod("TryGetDisplayRefreshRate")]
        public bool TryGetDisplayRefreshRate(out float displayRefreshRate);
        [NativeMethod("TryGetMotionToPhoton")]
        public bool TryGetMotionToPhoton(out float motionToPhoton);
        [NativeConditional("ENABLE_XR")]
        [NativeMethod(Name = "GetTextureForRenderPass", IsThreadSafe = False)]
        public RenderTexture GetRenderTextureForRenderPass(int renderPass);
        [NativeConditional("ENABLE_XR")]
        [NativeMethod(Name = "GetPreferredMirrorViewBlitMode", IsThreadSafe = False)]
        public int GetPreferredMirrorBlitMode();
        [NativeConditional("ENABLE_XR")]
        [NativeMethod(Name = "SetPreferredMirrorViewBlitMode", IsThreadSafe = False)]
        public void SetPreferredMirrorBlitMode(int blitMode);
        [Obsolete("GetMirrorViewBlitDesc(RenderTexture, out XRMirrorViewBlitDesc) is deprecated. Use GetMirrorViewBlitDesc(RenderTexture, out XRMirrorViewBlitDesc, int) instead.", False)]
        public bool GetMirrorViewBlitDesc(RenderTexture mirrorRt, out XRMirrorViewBlitDesc outDesc);
        [NativeMethod(Name = "QueryMirrorViewBlitDesc", IsThreadSafe = False)]
        [NativeConditional("ENABLE_XR")]
        public bool GetMirrorViewBlitDesc(RenderTexture mirrorRt, out XRMirrorViewBlitDesc outDesc, int mode);
        [Obsolete("AddGraphicsThreadMirrorViewBlit(CommandBuffer, bool) is deprecated. Use AddGraphicsThreadMirrorViewBlit(CommandBuffer, bool, int) instead.", False)]
        public bool AddGraphicsThreadMirrorViewBlit(CommandBuffer cmd, bool allowGraphicsStateInvalidate);
        [NativeHeader("Runtime/Graphics/CommandBuffer/RenderingCommandBuffer.h")]
        [NativeMethod(Name = "AddGraphicsThreadMirrorViewBlit", IsThreadSafe = False)]
        [NativeConditional("ENABLE_XR")]
        public bool AddGraphicsThreadMirrorViewBlit(CommandBuffer cmd, bool allowGraphicsStateInvalidate, int mode);

        public enum LateLatchNode
        {
            Head = 0,
            LeftHand = 1,
            RightHand = 2
        }
        [Flags]
        public enum TextureLayout
        {
            Texture2DArray = 1,
            SingleTexture2D = 2,
            SeparateTexture2Ds = 4
        }
        public enum ReprojectionMode
        {
            Unspecified = 0,
            PositionAndOrientation = 1,
            OrientationOnly = 2,
            None = 3
        }
        [NativeHeader("Modules/XR/Subsystems/Display/XRDisplaySubsystem.bindings.h")]
        public struct XRRenderParameter
        {
            public Matrix4x4 view;
            public Matrix4x4 projection;
            public Rect viewport;
            public Mesh occlusionMesh;
            public int textureArraySlice;
            public Matrix4x4 previousView;
            public bool isPreviousViewValid;
        }
        [NativeHeader("Runtime/Graphics/RenderTextureDesc.h")]
        [NativeHeader("Runtime/Graphics/CommandBuffer/RenderingCommandBuffer.h")]
        [NativeHeader("Modules/XR/Subsystems/Display/XRDisplaySubsystem.bindings.h")]
        public struct XRRenderPass
        {
            public int renderPassIndex;
            public RenderTargetIdentifier renderTarget;
            public RenderTextureDescriptor renderTargetDesc;
            public bool hasMotionVectorPass;
            public RenderTargetIdentifier motionVectorRenderTarget;
            public RenderTextureDescriptor motionVectorRenderTargetDesc;
            public bool shouldFillOutDepth;
            public int cullingPassIndex;

            [NativeConditional("ENABLE_XR")]
            [NativeMethod(Name = "XRRenderPassScriptApi::GetRenderParameter", IsFreeFunction = True, HasExplicitThis = True, ThrowsException = True)]
            public void GetRenderParameter(Camera camera, int renderParameterIndex, out XRRenderParameter renderParameter);
            [NativeConditional("ENABLE_XR")]
            [NativeMethod(Name = "XRRenderPassScriptApi::GetRenderParameterCount", IsFreeFunction = True, HasExplicitThis = True)]
            public int GetRenderParameterCount();
        }
        [NativeHeader("Modules/XR/Subsystems/Display/XRDisplaySubsystem.bindings.h")]
        [NativeHeader("Runtime/Graphics/RenderTexture.h")]
        public struct XRBlitParams
        {
            public RenderTexture srcTex;
            public int srcTexArraySlice;
            public Rect srcRect;
            public Rect destRect;
        }
        [NativeHeader("Modules/XR/Subsystems/Display/XRDisplaySubsystem.bindings.h")]
        public struct XRMirrorViewBlitDesc
        {
            public bool nativeBlitAvailable;
            public bool nativeBlitInvalidStates;
            public int blitParamsCount;

            [NativeConditional("ENABLE_XR")]
            [NativeMethod(Name = "XRMirrorViewBlitDescScriptApi::GetBlitParameter", IsFreeFunction = True, HasExplicitThis = True)]
            public void GetBlitParameter(int blitParameterIndex, out XRBlitParams blitParameter);
        }
    }
}
namespace UnityEngine.XR
{
    public struct XRMirrorViewBlitMode
    {
        public const int Default = 0;
        public const int LeftEye = -1;
        public const int RightEye = -2;
        public const int SideBySide = -3;
        public const int SideBySideOcclusionMesh = -4;
        public const int Distort = -5;
        public const int None = -6;
    }
}
using UnityEngine.Bindings;

namespace UnityEngine.XR
{
    [NativeHeader("Modules/XR/XRPrefix.h")]
    [NativeType(Header = "Modules/XR/Subsystems/Display/XRDisplaySubsystemDescriptor.h")]
    public struct XRMirrorViewBlitModeDesc
    {
        public int blitMode;
        public string blitModeDesc;
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.XR
{
    [UsedByNativeCode]
    [NativeType(Header = "Modules/XR/Subsystems/Display/XRDisplaySubsystemDescriptor.h")]
    public class XRDisplaySubsystemDescriptor : IntegratedSubsystemDescriptor<XRDisplaySubsystem>
    {
        public XRDisplaySubsystemDescriptor();

        [NativeConditional("ENABLE_XR")]
        public bool disablesLegacyVr { get; }
        [NativeConditional("ENABLE_XR")]
        public bool enableBackBufferMSAA { get; }

        [NativeMethod("TryGetAvailableMirrorModeCount")]
        [NativeConditional("ENABLE_XR")]
        public int GetAvailableMirrorBlitModeCount();
        [NativeMethod("TryGetMirrorModeByIndex")]
        [NativeConditional("ENABLE_XR")]
        public void GetMirrorBlitModeByIndex(int index, out XRMirrorViewBlitModeDesc mode);
    }
}
namespace UnityEngine.XR
{
    public enum TrackingOriginModeFlags
    {
        Unknown = 0,
        Device = 1,
        Floor = 2,
        TrackingReference = 4,
        Unbounded = 8
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.XR
{
    [NativeConditional("ENABLE_XR")]
    [UsedByNativeCode]
    [NativeType(Header = "Modules/XR/Subsystems/Input/XRInputSubsystem.h")]
    public class XRInputSubsystem : IntegratedSubsystem<XRInputSubsystemDescriptor>
    {
        public XRInputSubsystem();

        public event Action<XRInputSubsystem> trackingOriginUpdated;
        public event Action<XRInputSubsystem> boundaryChanged;

        public bool TryRecenter();
        public bool TryGetInputDevices(List<InputDevice> devices);
        public bool TrySetTrackingOriginMode(TrackingOriginModeFlags origin);
        public TrackingOriginModeFlags GetTrackingOriginMode();
        public TrackingOriginModeFlags GetSupportedTrackingOriginModes();
        public bool TryGetBoundaryPoints(List<Vector3> boundaryPoints);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.XR
{
    [NativeHeader("Modules/XR/XRPrefix.h")]
    [NativeConditional("ENABLE_XR")]
    [UsedByNativeCode]
    [NativeType(Header = "Modules/XR/Subsystems/Input/XRInputSubsystemDescriptor.h")]
    public class XRInputSubsystemDescriptor : IntegratedSubsystemDescriptor<XRInputSubsystem>
    {
        public XRInputSubsystemDescriptor();

        [NativeConditional("ENABLE_XR")]
        public bool disablesLegacyInput { get; }
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.XR
{
    [NativeHeader("Modules/XR/Subsystems/Meshing/XRMeshBindings.h")]
    [UsedByNativeCode]
    public struct MeshId : IEquatable<MeshId>
    {
        public static MeshId InvalidId { get; }

        public override string ToString();
        public override int GetHashCode();
        public override bool Equals(object obj);
        public bool Equals(MeshId other);

        public static bool operator ==(MeshId id1, MeshId id2);
        public static bool operator !=(MeshId id1, MeshId id2);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.XR
{
    [NativeHeader("Modules/XR/Subsystems/Meshing/XRMeshBindings.h")]
    [RequiredByNativeCode]
    public enum MeshGenerationStatus
    {
        Success = 0,
        InvalidMeshId = 1,
        GenerationAlreadyInProgress = 2,
        Canceled = 3,
        UnknownError = 4
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.XR
{
    [RequiredByNativeCode]
    [NativeHeader("Modules/XR/Subsystems/Meshing/XRMeshBindings.h")]
    public struct MeshGenerationResult : IEquatable<MeshGenerationResult>
    {
        public MeshId MeshId { get; }
        public Mesh Mesh { get; }
        public MeshCollider MeshCollider { get; }
        public MeshGenerationStatus Status { get; }
        public MeshVertexAttributes Attributes { get; }

        public override bool Equals(object obj);
        public bool Equals(MeshGenerationResult other);
        public override int GetHashCode();

        public static bool operator ==(MeshGenerationResult lhs, MeshGenerationResult rhs);
        public static bool operator !=(MeshGenerationResult lhs, MeshGenerationResult rhs);
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.XR
{
    [UsedByNativeCode]
    [Flags]
    [NativeHeader("Modules/XR/Subsystems/Meshing/XRMeshBindings.h")]
    public enum MeshVertexAttributes
    {
        None = 0,
        Normals = 1,
        Tangents = 2,
        UVs = 4,
        Colors = 8
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.XR
{
    [UsedByNativeCode]
    [NativeHeader("Modules/XR/Subsystems/Meshing/XRMeshBindings.h")]
    public enum MeshChangeState
    {
        Added = 0,
        Updated = 1,
        Removed = 2,
        Unchanged = 3
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.XR
{
    [UsedByNativeCode]
    [NativeHeader("Modules/XR/Subsystems/Meshing/XRMeshBindings.h")]
    public struct MeshInfo : IEquatable<MeshInfo>
    {
        public MeshId MeshId { get; set; }
        public MeshChangeState ChangeState { get; set; }
        public int PriorityHint { get; set; }

        public override bool Equals(object obj);
        public bool Equals(MeshInfo other);
        public override int GetHashCode();

        public static bool operator ==(MeshInfo lhs, MeshInfo rhs);
        public static bool operator !=(MeshInfo lhs, MeshInfo rhs);
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.XR
{
    [NativeHeader("Modules/XR/Subsystems/Meshing/XRMeshingSubsystem.h")]
    [NativeHeader("Modules/XR/XRPrefix.h")]
    [UsedByNativeCode]
    [NativeConditional("ENABLE_XR")]
    public class XRMeshSubsystem : IntegratedSubsystem<XRMeshSubsystemDescriptor>
    {
        public XRMeshSubsystem();

        public float meshDensity { get; set; }

        public bool TryGetMeshInfos(List<MeshInfo> meshInfosOut);
        public void GenerateMeshAsync(MeshId meshId, Mesh mesh, MeshCollider meshCollider, MeshVertexAttributes attributes, Action<MeshGenerationResult> onMeshGenerationComplete);
        public bool SetBoundingVolume(Vector3 origin, Vector3 extents);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEngine.XR
{
    [NativeHeader("Modules/XR/XRPrefix.h")]
    [NativeType(Header = "Modules/XR/Subsystems/Planes/XRMeshSubsystemDescriptor.h")]
    [UsedByNativeCode]
    public class XRMeshSubsystemDescriptor : IntegratedSubsystemDescriptor<XRMeshSubsystem>
    {
        public XRMeshSubsystemDescriptor();
    }
}
namespace UnityEngine.XR.Provider
{
    public static class XRStats
    {
        public static bool TryGetStat(IntegratedSubsystem xrSubsystem, string tag, out float value);
    }
}
-------- {UnityEditor(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEditor.dll)}:   22 --------
-------- {UnityEditor.CoreModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEditor.CoreModule.dll)}: 5057 --------
using System;

[Obsolete("Use UnityEditor.AssetModificationProcessor")]
public class AssetModificationProcessor
{
    public AssetModificationProcessor();
}
using System;
using System.Collections.Generic;
using UnityEngine;

namespace TreeEditor
{
    public class TreeData : ScriptableObject
    {
        public string materialHash;
        public TreeGroupRoot root;
        public TreeGroupBranch[] branchGroups;
        public TreeGroupLeaf[] leafGroups;
        public TreeNode[] nodes;
        public Mesh mesh;
        public Material optimizedSolidMaterial;
        public Material optimizedCutoutMaterial;
        public bool isInPreviewMode;

        public TreeData();

        public TreeGroup GetGroup(int id);
        public TreeNode GetNode(int id);
        public void ValidateReferences();
        public void ClearReferences();
        public TreeGroup AddGroup(TreeGroup parent, Type type);
        public TreeGroup DuplicateGroup(TreeGroup g);
        public void DeleteGroup(TreeGroup g);
        public void SetGroupParent(TreeGroup g, TreeGroup parent);
        public void LockGroup(TreeGroup g);
        public void UnlockGroup(TreeGroup g);
        public bool IsAncestor(TreeGroup ancestor, TreeGroup g);
        public TreeNode AddNode(TreeGroup g, TreeNode parent);
        public TreeNode AddNode(TreeGroup g, TreeNode parent, bool validate);
        public void SetNodeParent(TreeNode n, TreeNode parent);
        public void DeleteNode(TreeNode n);
        public void DeleteNode(TreeNode n, bool validate);
        public TreeNode DuplicateNode(TreeNode n);
        public void Initialize();
        public void UpdateSeed(int id);
        public void UpdateFrequency(int id);
        public void UpdateDistribution(int id);
        public static int GetAdaptiveHeightSegments(float h, float adaptiveQuality);
        public static int GetAdaptiveRadialSegments(float r, float adaptiveQuality);
        public static List<float> GetAdaptiveSamples(TreeGroup group, TreeNode node, float adaptiveQuality);
        public void PreviewMesh(Matrix4x4 worldToLocalMatrix, out Material[] outMaterials);
        public void UpdateMesh(Matrix4x4 worldToLocalMatrix, out Material[] outMaterials);
        public bool OptimizeMaterial(List<TreeMaterial> materials, List<TreeVertex> vertices, List<TreeTriangle> triangles);
        public bool CheckExternalChanges();
        public void UpdateMesh(Matrix4x4 matrix, List<TreeMaterial> materials, List<TreeVertex> verts, List<TreeTriangle> tris, List<TreeAOSphere> aoSpheres, int buildFlags, float adaptiveQuality, float aoDensity);
    }
}
using UnityEngine;

namespace TreeEditor
{
    public class TreeEditorHelper
    {
        public TreeEditorHelper();

        public void OnEnable(TreeData treeData);
        public bool AreShadersCorrect();
        public static string GetOptimizedShaderName(Shader shader);
        public static bool IsTreeLeafShader(Shader shader);
        public static bool IsTreeBarkShader(Shader shader);
        public bool GUITooManyShaders();
        public bool GUIWrongShader(string uniqueID, Material value, NodeType nodeType);
        public void RefreshAllTreeShaders();
        public bool NodeHasWrongMaterial(TreeGroup group);
        public static GUIContent GetGUIContent(string id);
        public static string ExtractLabel(string uiString);
        public static string ExtractTooltip(string uiString);

        public enum NodeType
        {
            BarkNode = 0,
            LeafNode = 1
        }
    }
}
using UnityEngine;

namespace TreeEditor
{
    public class SmoothRandom
    {
        public SmoothRandom();

        public static Vector3 GetVector3(float speed);
        public static float Get(float speed);
    }
}
namespace TreeEditor
{
    public class Perlin
    {
        public Perlin();

        public float Noise(float arg);
        public float Noise(float x, float y);
        public float Noise(float x, float y, float z);
        public void SetSeed(int seed);
    }
}
namespace TreeEditor
{
    public class FractalNoise
    {
        public FractalNoise(float inH, float inLacunarity, float inOctaves);
        public FractalNoise(float inH, float inLacunarity, float inOctaves, Perlin noise);

        public float HybridMultifractal(float x, float y, float offset);
        public float RidgedMultifractal(float x, float y, float offset, float gain);
        public float BrownianMotion(float x, float y);
    }
}
using System.Collections.Generic;
using UnityEngine;

namespace TreeEditor
{
    public class RingLoop
    {
        public float radius;
        public float baseOffset;

        public RingLoop();

        public static void SetNoiseSeed(int seed);
        public RingLoop Clone();
        public void Reset(float r, Matrix4x4 m, float bOffset, int segs);
        public void SetSurfaceAngle(float angleDeg);
        public void SetAnimationProperties(float primaryFactor, float secondaryFactor, float edgeFactor, float phase);
        public void SetSpread(float top, float bottom);
        public void SetNoise(float scale, float scaleU, float scaleV);
        public void SetFlares(float radius, float noise);
        public void BuildVertices(List<TreeVertex> verts);
        public void Cap(float sphereFactor, float noise, int mappingMode, float mappingScale, List<TreeVertex> verts, List<TreeTriangle> tris, int materialIndex);
        public void Connect(RingLoop other, List<TreeTriangle> tris, int materialIndex, bool flipTris, bool lowres);
    }
}
using UnityEngine;

namespace TreeEditor
{
    public class SplineNode
    {
        public Vector3 point;
        public Quaternion rot;
        public Vector3 normal;
        public Vector3 tangent;
        public float time;

        public SplineNode(Vector3 p, float t);
        public SplineNode(SplineNode o);
    }
}
using System.Collections.Generic;
using UnityEngine;

namespace TreeEditor
{
    public class TextureAtlas
    {
        public int atlasWidth;
        public int atlasHeight;
        public int atlasPadding;
        public List<TextureNode> nodes;

        public TextureAtlas();

        public override int GetHashCode();
        public void AddTexture(string name, Texture2D diffuse, Color diffuseColor, Texture2D normal, Texture2D gloss, Texture2D transtex, Texture2D shadowOffsetTex, float shininess, Vector2 scale, bool tileV, Vector2 uvTiling);
        public Vector2 GetTexTiling(string name);
        public Rect GetUVRect(string name);
        public void Pack(ref int targetWidth, int targetHeight, int padding, bool correctPow2);

        public class TextureNode
        {
            public string name;
            public Texture2D diffuseTexture;
            public Color diffuseColor;
            public Texture2D normalTexture;
            public Texture2D glossTexture;
            public Texture2D translucencyTexture;
            public Texture2D shadowOffsetTexture;
            public float shininess;
            public Vector2 scale;
            public bool tileV;
            public Vector2 uvTiling;
            public Rect sourceRect;
            public Rect packedRect;
            public Rect uvRect;

            public TextureNode();

            public static bool Overlap(TextureNode a, TextureNode b);
            public int CompareTo(TextureNode b);
        }
    }
}
using UnityEngine;

namespace TreeEditor
{
    public class TreeAOSphere
    {
        public bool flag;
        public float area;
        public float radius;
        public float density;
        public Vector3 position;

        public TreeAOSphere(Vector3 pos, float radius, float density);

        public float PointOcclusion(Vector3 pos, Vector3 nor);
    }
}
using System;
using UnityEngine;

namespace TreeEditor
{
    [AttributeUsage(Property, Field)]
    public class TreeAttribute : Attribute
    {
        public string uiLabel;
        public string uiGadget;
        public string uiCurve;
        public string uiRequirement;
        public GUIContent[] uiOptions;
        public float uiCurveMin;
        public float uiCurveMax;
        public float uiMin;
        public float uiMax;

        public TreeAttribute(string uiLabel, string uiGadget, float uiMin, float uiMax);
        public TreeAttribute(string uiLabel, string uiGadget, float uiMin, float uiMax, string uiRequirement);
        public TreeAttribute(string uiLabel, string uiGadget, float uiMin, float uiMax, string uiCurve, float uiCurveMin, float uiCurveMax);
        public TreeAttribute(string uiLabel, string uiGadget, float uiMin, float uiMax, string uiCurve, float uiCurveMin, float uiCurveMax, string uiRequirement);
        public TreeAttribute(string uiLabel, string uiGadget, string uiOptions);
        public TreeAttribute(string uiLabel, string uiGadget, string uiOptions, string uiCurve, float uiCurveMin, float uiCurveMax, string uiRequirement);

        public override string ToString();
    }
}
using System.Collections.Generic;
using UnityEngine;

namespace TreeEditor
{
    public class TreeGroup
    {
        protected static readonly bool GenerateDoubleSidedGeometry;
        protected static readonly float GenerateBendNormalFactor;
        protected static readonly float GenerateBendBillboardNormalFactor;
        public int seed;
        public int distributionFrequency;
        public DistributionMode distributionMode;
        public AnimationCurve distributionCurve;
        public int distributionNodes;
        public float distributionTwirl;
        public float distributionPitch;
        public AnimationCurve distributionPitchCurve;
        public float distributionScale;
        public AnimationCurve distributionScaleCurve;
        public bool showAnimationProps;
        public float animationPrimary;
        public float animationSecondary;
        public float animationEdge;
        public bool visible;
        public int lockFlags;
        public int[] nodeIDs;
        public int parentGroupID;
        public int[] childGroupIDs;

        public TreeGroup();

        public int uniqueID { get; set; }

        public virtual float GetRadiusAtTime(TreeNode node, float t, bool includeModifications);
        public virtual bool CanHaveSubGroups();
        public void Lock();
        public void Unlock();
        public bool CheckExternalChanges();
        public void UpdateFrequency(TreeData owner);
        public void UpdateSeed();
        public Vector2 ComputeWindFactor(TreeNode node, float offset);
        public float GetRootSpread();
        public Matrix4x4 GetRootMatrix();
        public void UpdateDistribution(bool completeUpdate, bool updateSubGroups);
        public virtual void UpdateParameters();
        public virtual void BuildAOSpheres(List<TreeAOSphere> aoSpheres);
        public virtual void UpdateMesh(List<TreeMaterial> materials, List<TreeVertex> verts, List<TreeTriangle> tris, List<TreeAOSphere> aoSpheres, int buildFlags, float adaptiveQuality, float aoDensity);
        public virtual void UpdateMatrix();
        protected static int GetMaterialIndex(Material m, List<TreeMaterial> materials, bool tileV);
        protected static Vector4 CreateTangent(TreeNode node, Quaternion rot, Vector3 normal);
        protected static float ComputeAmbientOcclusion(Vector3 pos, Vector3 nor, List<TreeAOSphere> aoSpheres, float aoDensity);

        public enum LockFlag
        {
            LockPosition = 1,
            LockAlignment = 2,
            LockShape = 4
        }
        public enum BuildFlag
        {
            BuildAmbientOcclusion = 1,
            BuildWeldParts = 2
        }
        public enum DistributionMode
        {
            Random = 0,
            Alternate = 1,
            Opposite = 2,
            Whorled = 3
        }
    }
}
using System.Collections.Generic;
using UnityEngine;

namespace TreeEditor
{
    public class TreeGroupBranch : TreeGroup
    {
        public float lodQualityMultiplier;
        public GeometryMode geometryMode;
        public Material materialBranch;
        public Material materialBreak;
        public Material materialFrond;
        public Vector2 height;
        public float radius;
        public AnimationCurve radiusCurve;
        public bool radiusMode;
        public float capSmoothing;
        public float crinklyness;
        public AnimationCurve crinkCurve;
        public float seekBlend;
        public AnimationCurve seekCurve;
        public float noise;
        public AnimationCurve noiseCurve;
        public float noiseScaleU;
        public float noiseScaleV;
        public float flareSize;
        public float flareHeight;
        public float flareNoise;
        public float weldHeight;
        public float weldSpreadTop;
        public float weldSpreadBottom;
        public float breakingChance;
        public Vector2 breakingSpot;
        public int frondCount;
        public float frondWidth;
        public AnimationCurve frondCurve;
        public Vector2 frondRange;
        public float frondRotation;
        public float frondCrease;

        public TreeGroupBranch();

        public override float GetRadiusAtTime(TreeNode node, float time, bool includeModifications);
        public override void UpdateParameters();
        public void UpdateSplines();
        public override void UpdateMatrix();
        public override void BuildAOSpheres(List<TreeAOSphere> aoSpheres);
        public override void UpdateMesh(List<TreeMaterial> materials, List<TreeVertex> verts, List<TreeTriangle> tris, List<TreeAOSphere> aoSpheres, int buildFlags, float adaptiveQuality, float aoDensity);
        public void UpdateSpline(TreeNode node);

        public enum GeometryMode
        {
            Branch = 0,
            BranchFrond = 1,
            Frond = 2
        }
    }
}
using System.Collections.Generic;
using UnityEngine;

namespace TreeEditor
{
    public class TreeGroupLeaf : TreeGroup
    {
        public int geometryMode;
        public Material materialLeaf;
        public GameObject instanceMesh;
        public Vector2 size;
        public float perpendicularAlign;
        public float horizontalAlign;

        public TreeGroupLeaf();

        public override bool CanHaveSubGroups();
        public override void UpdateParameters();
        public override void UpdateMatrix();
        public override void BuildAOSpheres(List<TreeAOSphere> aoSpheres);
        public override void UpdateMesh(List<TreeMaterial> materials, List<TreeVertex> verts, List<TreeTriangle> tris, List<TreeAOSphere> aoSpheres, int buildFlags, float adaptiveQuality, float aoDensity);

        public enum GeometryMode
        {
            PLANE = 0,
            CROSS = 1,
            TRI_CROSS = 2,
            BILLBOARD = 3,
            MESH = 4
        }
    }
}
using UnityEngine;

namespace TreeEditor
{
    public class TreeGroupRoot : TreeGroup
    {
        public float adaptiveLODQuality;
        public int shadowTextureQuality;
        public bool enableWelding;
        public bool enableAmbientOcclusion;
        public bool enableMaterialOptimize;
        public float aoDensity;
        public float rootSpread;
        public float groundOffset;
        public Matrix4x4 rootMatrix;

        public TreeGroupRoot();

        public void SetRootMatrix(Matrix4x4 m);
        public override bool CanHaveSubGroups();
        public override void UpdateParameters();
    }
}
using UnityEngine;

namespace TreeEditor
{
    public class TreeMaterial
    {
        public Material material;
        public bool tileV;

        public TreeMaterial();
    }
}
using UnityEngine;

namespace TreeEditor
{
    public class TreeNode
    {
        public TreeSpline spline;
        public int seed;
        public float animSeed;
        public bool visible;
        public int triStart;
        public int triEnd;
        public int vertStart;
        public int vertEnd;
        public float capRange;
        public float breakOffset;
        public float size;
        public float scale;
        public float offset;
        public float baseAngle;
        public float angle;
        public float pitch;
        public Quaternion rotation;
        public Matrix4x4 matrix;
        public int parentID;
        public int groupID;

        public TreeNode();

        public int uniqueID { get; set; }

        public float GetScale();
        public float GetSurfaceAngleAtTime(float time);
        public float GetRadiusAtTime(float time);
        public void GetPropertiesAtTime(float time, out Vector3 pos, out Quaternion rot, out float rad);
        public Matrix4x4 GetLocalMatrixAtTime(float time);
    }
}
using UnityEngine;

namespace TreeEditor
{
    public class TreeSpline
    {
        public SplineNode[] nodes;
        public float tension;

        public TreeSpline();
        public TreeSpline(TreeSpline o);

        public void Reset();
        public int GetNodeCount();
        public void SetNodeCount(int c);
        public void RemoveNode(int c);
        public SplineNode[] GetNodes();
        public void AddPoint(Vector3 pos, float timeInSeconds);
        public float GetApproximateLength();
        public void UpdateTime();
        public void UpdateRotations();
        public Quaternion GetRotationAtTime(float timeParam);
        public Vector3 GetPositionAtTime(float timeParam);
    }
}
namespace TreeEditor
{
    public class TreeTriangle
    {
        public bool tileV;
        public bool isBillboard;
        public bool isCutout;
        public int materialIndex;
        public int[] v;

        public TreeTriangle(int material, int v0, int v1, int v2);
        public TreeTriangle(int material, int v0, int v1, int v2, bool isBillboard);
        public TreeTriangle(int material, int v0, int v1, int v2, bool isBillboard, bool tileV, bool isCutout);

        public void flip();
    }
}
using UnityEngine;

namespace TreeEditor
{
    public class TreeVertex
    {
        public Vector3 pos;
        public Vector3 nor;
        public Vector4 tangent;
        public Vector2 uv0;
        public Vector2 uv1;
        public Color color;
        public bool flag;

        public TreeVertex();

        public void SetAnimationProperties(float primaryFactor, float secondaryFactor, float edgeFactor, float phase);
        public void SetAmbientOcclusion(float ao);
        public void Lerp4(TreeVertex[] tv, Vector2 factor);
    }
}
namespace Unity.CodeEditor
{
    public class CodeEditor
    {
        public CodeEditor();

        public static IExternalCodeEditor CurrentEditor { get; }
        public static string CurrentEditorInstallation { get; }

        public static void SetExternalScriptEditor(string path);
        public static void Register(IExternalCodeEditor externalCodeEditor);
        public static void Unregister(IExternalCodeEditor externalCodeEditor);
        public static bool OSOpenFile(string appPath, string arguments);
        public static string ParseArgument(string arguments, string path, int line, int column);

        public struct Installation
        {
            public string Name;
            public string Path;
        }
    }
}
namespace Unity.CodeEditor
{
    public interface IExternalCodeEditor
    {
        CodeEditor.Installation[] Installations { get; }

        bool TryGetInstallationForPath(string editorPath, out CodeEditor.Installation installation);
        void OnGUI();
        void SyncIfNeeded(string[] addedFiles, string[] deletedFiles, string[] movedFiles, string[] movedFromFiles, string[] importedFiles);
        void SyncAll();
        void Initialize(string editorInstallationPath);
        bool OpenProject(string filePath = "", int line = -1, int column = -1);
    }
}
namespace UnityEditorInternal
{
    public sealed class AssetStore
    {
        public AssetStore();

        public static void Open(string assetStoreURL);
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditorInternal
{
    [NativeHeader("Editor/Mono/AssetStore.bindings.h")]
    [StaticAccessor("AssetStoreScriptBindings", DoubleColon)]
    public sealed class AssetStoreToolUtils
    {
        public AssetStoreToolUtils();

        public static bool BuildAssetStoreAssetBundle(Object targetObject, string targetPath);
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditorInternal
{
    [NativeHeader("Editor/Src/Animation/BlendTreePreviewUtility.h")]
    public class BlendTreePreviewUtility
    {
        public BlendTreePreviewUtility();

        public static void GetRootBlendTreeChildWeights([NotNull("NullExceptionObject")] Animator animator, int layerIndex, int stateHash, out float[] weightArray);
        public static void CalculateRootBlendTreeChildWeights([NotNull("NullExceptionObject")] Animator animator, int layerIndex, int stateHash, out float[] weightArray, float blendX, float blendY);
        public static void CalculateBlendTexture(Animator animator, int layerIndex, int stateHash, Texture2D blendTexture, Texture2D[] weightTextures, Rect rect);
        protected static void CalculateBlendTexture([NotNull("NullExceptionObject")] Animator animator, int layerIndex, int stateHash, Texture2D blendTexture, Texture2D[] weightTextures, float minX, float minY, float maxX, float maxY);
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditorInternal
{
    [NativeHeader("Editor/Src/ComponentUtility.bindings.h")]
    [StaticAccessor("ComponentUtilityBindings", DoubleColon)]
    public sealed class ComponentUtility
    {
        public ComponentUtility();

        public static bool MoveComponentUp(Component component);
        public static bool MoveComponentDown(Component component);
        public static bool CopyComponent(Component component);
        public static bool PasteComponentValues(Component component);
        public static bool PasteComponentAsNew([NotNull("NullExceptionObject")] GameObject go);
        public static void DestroyComponentsMatching(GameObject dst, IsDesiredComponent componentFilter);
        public static void ReplaceComponentsIfDifferent(GameObject src, GameObject dst, IsDesiredComponent componentFilter);

        public delegate bool IsDesiredComponent(Component c);
    }
}
using System.Collections.Generic;
using System.IO;
using UnityEngine;

namespace UnityEditorInternal
{
    public class GenerateIconsWithMipLevels
    {
        public GenerateIconsWithMipLevels();

        public static void GenerateAllIconsWithMipLevels();
        public static bool VerifyIconPath(string assetPath, bool logError);
        public static void GenerateSelectedIconsWithMips();
        public static void GenerateIconWithMipLevels(string assetPath, Dictionary<int, Texture2D> mipTextures, FileInfo fileInfo);
        public static int MipLevelForAssetPath(string assetPath, string separator);
    }
}
using System;

namespace UnityEditorInternal
{
    [Obsolete("CanAppendBuild has been deprecated. Use UnityEditor.CanAppendBuild instead (UnityUpgradable) -> [UnityEditor] UnityEditor.CanAppendBuild", True)]
    public enum CanAppendBuild
    {
        Unsupported = 0,
        Yes = 1,
        No = 2
    }
}
namespace UnityEditorInternal
{
    public enum DllType
    {
        Unknown = 0,
        Native = 1,
        UnknownManaged = 2,
        ManagedNET35 = 3,
        ManagedNET40 = 4,
        WinMDNative = 5,
        WinMDNET40 = 6
    }
}
using UnityEngine;
using UnityEngine.Scripting;

namespace UnityEditorInternal
{
    [RequiredByNativeCode]
    public class LoadFileAndForgetOperation : AsyncOperation
    {
        public LoadFileAndForgetOperation();

        public Object Result { get; }
    }
}
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Reflection;
using UnityEditor;
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditorInternal
{
    [NativeHeader("Editor/Src/HierarchyState.h")]
    [NativeHeader("Editor/Src/EditorUserBuildSettings.h")]
    [NativeHeader("Editor/Src/EditorModules.h")]
    [NativeHeader("Editor/Src/EditorWindowController.h")]
    [NativeHeader("Editor/Src/EditorHelper.h")]
    [NativeHeader("Editor/Src/AuxWindowManager.h")]
    [NativeHeader("Editor/Src/DisplayDialog.h")]
    [NativeHeader("Runtime/Utilities/UnityRevision.h")]
    [NativeHeader("Editor/Src/AssetPipeline/UnityExtensions.h")]
    [NativeHeader("Editor/Src/AssetPipeline/ObjectHashGenerator.h")]
    [NativeHeader("Editor/Src/ScriptCompilation/PrecompiledAssemblies.h")]
    [NativeHeader("Editor/Src/AssetPipeline/TextureImporting/BumpMapSettings.h")]
    [NativeHeader("Modules/AssetDatabase/Editor/Public/AssetDatabaseDeprecated.h")]
    [NativeHeader("Modules/AssetDatabase/Editor/Public/AssetDatabase.h")]
    [NativeHeader("Editor/Src/Application/Application.h")]
    [NativeHeader("Editor/Platform/Interface/EditorUtility.h")]
    [NativeHeader("Editor/Platform/Interface/ColorPicker.h")]
    [NativeHeader("Editor/Mono/MonoEditorUtility.h")]
    [NativeHeader("Editor/Src/InternalEditorUtility.bindings.h")]
    [NativeHeader("Editor/Src/DragAndDropForwarding.h")]
    [NativeHeader("Runtime/Utilities/LaunchUtilities.h")]
    [NativeHeader("Editor/Src/InspectorExpandedState.h")]
    [NativeHeader("Runtime/Utilities/Argv.h")]
    [NativeHeader("Runtime/Graphics/ScreenManager.h")]
    [NativeHeader("Runtime/Graphics/Renderer.h")]
    [NativeHeader("Runtime/Transform/RectTransform.h")]
    [NativeHeader("Runtime/Camera/Skybox.h")]
    [NativeHeader("Runtime/Utilities/FileUtilities.h")]
    [NativeHeader("Runtime/Camera/RenderManager.h")]
    [NativeHeader("Runtime/Camera/Camera.h")]
    [NativeHeader("Runtime/BaseClasses/TagManager.h")]
    [NativeHeader("Editor/Src/Utility/GameObjectHierarchyProperty.h")]
    [NativeHeader("Editor/Src/Utility/DiffTool.h")]
    [NativeHeader("Editor/Src/Utility/CustomLighting.h")]
    [NativeHeader("Modules/AssetDatabase/Editor/Public/AssetDatabaseProperty.h")]
    [NativeHeader("Editor/Src/Undo/ObjectUndo.h")]
    [NativeHeader("Editor/Src/ShaderMenu.h")]
    [NativeHeader("Editor/Src/RemoteInput/RemoteInput.h")]
    [NativeHeader("Runtime/Interfaces/ILicensing.h")]
    [NativeHeader("Editor/Src/LoadFileAndForgetOperation.h")]
    [NativeHeader("Runtime/Graphics/SpriteFrame.h")]
    [NativeHeader("Runtime/2D/Common/SpriteTypes.h")]
    [NativeHeader("Runtime/Camera/RenderSettings.h")]
    [NativeHeader("Runtime/Utilities/Word.h")]
    [NativeHeader("Runtime/Serialize/PersistentManager.h")]
    [NativeHeader("Runtime/Threads/ThreadChecks.h")]
    [NativeHeader("Editor/Src/Gizmos/GizmoUtil.h")]
    [NativeHeader("Runtime/Misc/PlayerSettings.h")]
    [NativeHeader("Editor/Src/BuildPipeline/BuildPlayer.h")]
    [NativeHeader("Runtime/Misc/Player.h")]
    [NativeHeader("Runtime/Misc/GameObjectUtility.h")]
    [NativeHeader("Runtime/Shaders/ShaderImpl/FastPropertyName.h")]
    [NativeHeader("Editor/Src/BuildPipeline/BuildTargetPlatformSpecific.h")]
    [NativeHeader("Runtime/Input/Cursor.h")]
    [NativeHeader("Runtime/Graphics/GpuDeviceManager.h")]
    [NativeHeader("Runtime/Graphics/GraphicsHelper.h")]
    [NativeHeader("Runtime/Serialize/PersistentManager.h")]
    public class InternalEditorUtility
    {
        public InternalEditorUtility();

        public static bool isHumanControllingUs { get; }
        public static bool isApplicationActive { get; }
        public static bool inBatchMode { get; }
        public static int[] expandedProjectWindowItems { get; set; }
        public static string[] tags { get; }
        public static string[] layers { get; }
        public static string unityPreferencesFolder { get; }
        [NativeProperty("defaultScreenWidth", Field)]
        [StaticAccessor("GetPlayerSettings()", Dot)]
        public static float defaultScreenWidth { get; }
        [NativeProperty("defaultScreenHeight", Field)]
        [StaticAccessor("GetPlayerSettings()", Dot)]
        public static float defaultScreenHeight { get; }
        [NativeProperty("defaultWebScreenWidth", Field)]
        [StaticAccessor("GetPlayerSettings()", Dot)]
        public static float defaultWebScreenWidth { get; }
        [NativeProperty("defaultWebScreenHeight", Field)]
        [StaticAccessor("GetPlayerSettings()", Dot)]
        public static float defaultWebScreenHeight { get; }
        public static float remoteScreenWidth { get; }
        public static float remoteScreenHeight { get; }

        [NativeMethod("PerformUnmarkedBumpMapTexturesFixingAfterDialog")]
        [StaticAccessor("BumpMapSettings::Get()", Dot)]
        public static void BumpMapSettingsFixingWindowReportResult(int result);
        [NativeMethod("PerformUnmarkedBumpMapTexturesFixing")]
        [StaticAccessor("BumpMapSettings::Get()", Dot)]
        public static bool PerformUnmarkedBumpMapTexturesFixing();
        [FreeFunction("InternalEditorUtilityBindings::BumpMapTextureNeedsFixingInternal")]
        public static bool BumpMapTextureNeedsFixingInternal([NotNull("NullExceptionObject")] Material material, string propName, bool flaggedAsNormal);
        [FreeFunction("InternalEditorUtilityBindings::FixNormalmapTextureInternal")]
        public static void FixNormalmapTextureInternal([NotNull("ArgumentNullException")] Material material, string propName);
        [FreeFunction("InternalEditorUtilityBindings::GetEditorAssemblyPath")]
        public static string GetEditorAssemblyPath();
        [FreeFunction("InternalEditorUtilityBindings::GetEngineAssemblyPath")]
        public static string GetEngineAssemblyPath();
        [FreeFunction("InternalEditorUtilityBindings::GetEngineCoreModuleAssemblyPath")]
        public static string GetEngineCoreModuleAssemblyPath();
        [FreeFunction("InternalEditorUtilityBindings::CalculateHashForObjectsAndDependencies")]
        public static string CalculateHashForObjectsAndDependencies(UnityEngine.Object[] objects);
        [FreeFunction]
        public static void ExecuteCommandOnKeyWindow(string commandName);
        [FreeFunction("InternalEditorUtilityBindings::InstantiateMaterialsInEditMode")]
        public static Material[] InstantiateMaterialsInEditMode([NotNull("ArgumentNullException")] Renderer renderer);
        [Obsolete("BuildCanBeAppended has been deprecated. Use UnityEditor.BuildPipeline.BuildCanBeAppended instead (UnityUpgradable) -> [UnityEditor] UnityEditor.BuildPipeline.BuildCanBeAppended(*)", True)]
        public static CanAppendBuild BuildCanBeAppended(BuildTarget target, string location);
        [Obsolete("RequestScriptReload has been deprecated. Use UnityEditor.EditorUtility.RequestScriptReload instead (UnityUpgradable) -> [UnityEditor] UnityEditor.EditorUtility.RequestScriptReload(*)")]
        public static void RequestScriptReload();
        [NativeMethod("SwitchSkinAndRepaintAllViews")]
        [StaticAccessor("GetApplication()", Dot)]
        public static void SwitchSkinAndRepaintAllViews();
        [NativeMethod("RequestRepaintAllViews")]
        [StaticAccessor("GetApplication()", Dot)]
        public static void RepaintAllViews();
        [NativeMethod("IsInspectorExpanded")]
        [StaticAccessor("GetInspectorExpandedState()", Dot)]
        public static bool GetIsInspectorExpanded(UnityEngine.Object obj);
        [NativeMethod("SetInspectorExpanded")]
        [StaticAccessor("GetInspectorExpandedState()", Dot)]
        public static void SetIsInspectorExpanded(UnityEngine.Object obj, bool isExpanded);
        public static Assembly LoadAssemblyWrapper(string dllName, string dllLocation);
        public static void SaveToSerializedFileAndForget(UnityEngine.Object[] obj, string path, bool allowTextSerialization);
        [FreeFunction("InternalEditorUtilityBindings::LoadSerializedFileAndForget")]
        public static UnityEngine.Object[] LoadSerializedFileAndForget(string path);
        [FreeFunction("LoadFileAndForgetOperation::LoadSerializedFileAndForgetAsync")]
        public static LoadFileAndForgetOperation LoadSerializedFileAndForgetAsync(string path, long localIdentifierInFile, ulong offsetInFile = 0, long fileSize = -1);
        [FreeFunction("InternalEditorUtilityBindings::ProjectWindowDrag")]
        public static DragAndDropVisualMode ProjectWindowDrag(HierarchyProperty property, bool perform);
        [FreeFunction("InternalEditorUtilityBindings::HierarchyWindowDrag")]
        public static DragAndDropVisualMode HierarchyWindowDrag(HierarchyProperty property, HierarchyDropMode dropMode, Transform parentForDraggedObjects, bool perform);
        [FreeFunction("InternalEditorUtilityBindings::HierarchyWindowDragByID")]
        public static DragAndDropVisualMode HierarchyWindowDragByID(int dropTargetInstanceID, HierarchyDropMode dropMode, Transform parentForDraggedObjects, bool perform);
        [FreeFunction("InternalEditorUtilityBindings::SceneViewDrag")]
        public static DragAndDropVisualMode SceneViewDrag(UnityEngine.Object dropUpon, Vector3 worldPosition, Vector2 viewportPosition, Transform parentForDraggedObjects, bool perform);
        [FreeFunction("InternalEditorUtilityBindings::SetRectTransformTemporaryRect")]
        public static void SetRectTransformTemporaryRect([NotNull("ArgumentNullException")] RectTransform rectTransform, Rect rect);
        [Obsolete("HasTeamLicense always returns true, no need to call it")]
        public static bool HasTeamLicense();
        [FreeFunction("InternalEditorUtilityBindings::HasPro", IsThreadSafe = True)]
        public static bool HasPro();
        [FreeFunction("InternalEditorUtilityBindings::HasFreeLicense", IsThreadSafe = True)]
        public static bool HasFreeLicense();
        [FreeFunction("InternalEditorUtilityBindings::HasEduLicense", IsThreadSafe = True)]
        public static bool HasEduLicense();
        [FreeFunction]
        public static bool HasAdvancedLicenseOnBuildTarget(BuildTarget target);
        public static bool IsMobilePlatform(BuildTarget target);
        [NativeThrows]
        [FreeFunction("InternalEditorUtilityBindings::GetBoundsOfDesktopAtPoint")]
        public static Rect GetBoundsOfDesktopAtPoint(Vector2 pos);
        [StaticAccessor("GetTagManager()", Dot)]
        [NativeMethod("RemoveTag")]
        public static void RemoveTag(string tag);
        [FreeFunction("InternalEditorUtilityBindings::AddTag")]
        public static void AddTag(string tag);
        public static LayerMask ConcatenatedLayersMaskToLayerMask(int concatenatedLayersMask);
        [FreeFunction("TryOpenErrorFileFromConsole")]
        public static bool TryOpenErrorFileFromConsole(string path, int line, int column);
        public static bool TryOpenErrorFileFromConsole(string path, int line);
        public static int LayerMaskToConcatenatedLayersMask(LayerMask mask);
        [FreeFunction("InternalEditorUtilityBindings::GetSpriteOuterUV")]
        public static Vector4 GetSpriteOuterUV([NotNull("ArgumentNullException")] Sprite sprite, bool getAtlasData);
        [FreeFunction("PPtr<Object>")]
        public static UnityEngine.Object GetObjectFromInstanceID(int instanceID);
        [FreeFunction("GetTypeWithoutLoadingObject")]
        public static Type GetTypeWithoutLoadingObject(int instanceID);
        [FreeFunction("Object::IDToPointer")]
        public static UnityEngine.Object GetLoadedObjectFromInstanceID(int instanceID);
        [NativeMethod("LayerToString")]
        [StaticAccessor("GetTagManager()", Dot)]
        public static string GetLayerName(int layer);
        [FreeFunction]
        public static string GetAssetsFolder();
        [FreeFunction]
        public static string GetEditorFolder();
        [FreeFunction]
        public static bool IsInEditorFolder(string path);
        public static void ReloadWindowLayoutMenu();
        public static void RevertFactoryLayoutSettings(bool quitOnCancel);
        public static void LoadDefaultLayout();
        [Obsolete("SetupShaderMenu is obsolete. You can get list of available shaders with ShaderUtil.GetAllShaderInfos", False)]
        [FreeFunction("SetupShaderPopupMenu")]
        public static void SetupShaderMenu([NotNull("ArgumentNullException")] Material material);
        [FreeFunction("GetUnityBuildFullVersion")]
        public static string GetFullUnityVersion();
        public static Version GetUnityVersion();
        [FreeFunction("InternalEditorUtilityBindings::GetUnityVersionDigits")]
        public static string GetUnityVersionDigits();
        [FreeFunction("GetUnityBuildBranchName")]
        public static string GetUnityBuildBranch();
        [FreeFunction("GetUnityBuildHash")]
        public static string GetUnityBuildHash();
        [FreeFunction("GetUnityDisplayVersion")]
        public static string GetUnityDisplayVersion();
        [FreeFunction("GetUnityDisplayVersionVerbose")]
        public static string GetUnityDisplayVersionVerbose();
        [FreeFunction("GetUnityBuildTimeSinceEpoch")]
        public static int GetUnityVersionDate();
        [FreeFunction("GetUnityBuildNumericRevision")]
        public static int GetUnityRevision();
        [FreeFunction("InternalEditorUtilityBindings::IsUnityBeta")]
        public static bool IsUnityBeta();
        [FreeFunction("InternalEditorUtilityBindings::GetUnityCopyright")]
        public static string GetUnityCopyright();
        [FreeFunction("InternalEditorUtilityBindings::GetLicenseInfoText")]
        public static string GetLicenseInfo();
        [FreeFunction("InternalEditorUtilityBindings::GetLicenseFlags")]
        public static int[] GetLicenseFlags();
        [FreeFunction("InternalEditorUtilityBindings::GetAuthToken")]
        public static string GetAuthToken();
        [FreeFunction("InternalEditorUtilityBindings::OpenEditorConsole")]
        public static void OpenEditorConsole();
        [FreeFunction("InternalEditorUtilityBindings::GetGameObjectInstanceIDFromComponent")]
        public static int GetGameObjectInstanceIDFromComponent(int instanceID);
        [FreeFunction("InternalEditorUtilityBindings::ReadScreenPixel")]
        public static Color[] ReadScreenPixel(Vector2 pixelPos, int sizex, int sizey);
        [FreeFunction("InternalEditorUtilityBindings::ReadScreenPixelUnderCursor")]
        public static Color[] ReadScreenPixelUnderCursor(Vector2 cursorPosHint, int sizex, int sizey);
        [NativeMethod("SetDevice")]
        [StaticAccessor("GetGpuDeviceManager()", Dot)]
        public static void SetGpuDeviceAndRecreateGraphics(int index, string name);
        [NativeMethod("IsSupported")]
        [StaticAccessor("GetGpuDeviceManager()", Dot)]
        public static bool IsGpuDeviceSelectionSupported();
        [FreeFunction("InternalEditorUtilityBindings::GetGpuDevices")]
        public static string[] GetGpuDevices();
        [FreeFunction("InternalEditorUtilityBindings::OpenPlayerConsole")]
        public static void OpenPlayerConsole();
        public static string TextifyEvent(Event evt);
        [FreeFunction]
        public static string[] GetAvailableDiffTools();
        [FreeFunction]
        public static string GetNoDiffToolsDetectedMessage();
        [FreeFunction("InternalEditorUtilityBindings::TransformBounds")]
        public static Bounds TransformBounds(Bounds b, Transform t);
        [StaticAccessor("CustomLighting::Get()", Dot)]
        [NativeMethod("SetCustomLighting")]
        public static void SetCustomLightingInternal(Light[] lights, Color ambient);
        public static void SetCustomLighting(Light[] lights, Color ambient);
        [StaticAccessor("CustomLighting::Get()", Dot)]
        [NativeMethod("RestoreSceneLighting")]
        public static void RemoveCustomLighting();
        [StaticAccessor("GetRenderManager()", Dot)]
        public static bool HasFullscreenCamera();
        public static Bounds CalculateSelectionBounds(bool usePivotOnlyForParticles, bool onlyUseActiveSelection);
        [FreeFunction]
        public static Bounds CalculateSelectionBounds(bool usePivotOnlyForParticles, bool onlyUseActiveSelection, bool ignoreEditableField);
        [FreeFunction("SetPlayerFocus")]
        public static void OnGameViewFocus(bool focus);
        [FreeFunction("OpenScriptFile")]
        public static bool OpenFileAtLineExternal(string filename, int line, int column);
        public static bool OpenFileAtLineExternal(string filename, int line);
        [FreeFunction("AssetDatabaseDeprecated::CanConnectToCacheServer")]
        public static bool CanConnectToCacheServer();
        [FreeFunction]
        public static DllType DetectDotNetDll(string path);
        public static bool IsDotNet4Dll(string path);
        [FreeFunction(IsThreadSafe = True)]
        public static bool CurrentThreadIsMainThread();
        [FreeFunction("InternalEditorUtilityBindings::GetCrashReportFolder")]
        public static string GetCrashReportFolder();
        [FreeFunction("InternalEditorUtilityBindings::GetCrashHandlerProcessID")]
        public static uint GetCrashHandlerProcessID();
        [FreeFunction("InternalEditorUtilityBindings::ResetCursor")]
        public static void ResetCursor();
        [FreeFunction("InternalEditorUtilityBindings::VerifyCacheServerIntegrity")]
        public static ulong VerifyCacheServerIntegrity();
        [FreeFunction("InternalEditorUtilityBindings::FixCacheServerIntegrityErrors")]
        public static ulong FixCacheServerIntegrityErrors();
        [FreeFunction]
        public static int DetermineDepthOrder(Transform lhs, Transform rhs);
        [Obsolete("The Module Manager is deprecated", True)]
        [EditorBrowsable(Never)]
        public static void ShowPackageManagerWindow();
        [FreeFunction("InternalEditorUtilityBindings::PassAndReturnVector2")]
        public static Vector2 PassAndReturnVector2(Vector2 v);
        [FreeFunction("InternalEditorUtilityBindings::PassAndReturnColor32")]
        public static Color32 PassAndReturnColor32(Color32 c);
        [FreeFunction("InternalEditorUtilityBindings::SaveCursorToFile")]
        public static bool SaveCursorToFile(string path, Texture2D image, Vector2 hotSpot);
        public static string CountToString(ulong count);
        [StaticAccessor("GetSceneManager()", Dot)]
        [NativeMethod("EnsureUntitledSceneHasBeenSaved")]
        [Obsolete("use EditorSceneManager.EnsureUntitledSceneHasBeenSaved")]
        public static bool EnsureSceneHasBeenSaved(string operation);
        public static Texture2D FindIconForFile(string fileName);
        public static Texture2D GetIconForFile(string fileName);
        public static string[] GetEditorSettingsList(string prefix, int count);
        public static void SaveEditorSettingsList(string prefix, string[] aList, int count);
        public static string TextAreaForDocBrowser(Rect position, string text, GUIStyle style);
        public static Camera[] GetSceneViewCameras();
        public static void ShowGameView();
        public static List<int> GetNewSelection(int clickedInstanceID, List<int> allInstanceIDs, List<int> selectedInstanceIDs, int lastClickedInstanceID, bool keepMultiSelection, bool useShiftAsActionKey, bool allowMultiSelection);
        public static bool IsValidFileName(string filename);
        public static string RemoveInvalidCharsFromFileName(string filename, bool logIfInvalidChars);
        public static string GetDisplayStringOfInvalidCharsOfFileName(string filename);
        public static void SetShowGizmos(bool value);

        public enum HierarchyDropMode
        {
            kHierarchyDragNormal = 0,
            kHierarchyDropUpon = 1,
            kHierarchyDropBetween = 2,
            kHierarchyDropAfterParent = 4,
            kHierarchySearchActive = 8,
            kHierarchyDropAbove = 16
        }
    }
}
namespace UnityEditorInternal
{
    public enum RegistryView
    {
        Default = 0,
        _32 = 1,
        _64 = 2
    }
}
using UnityEngine.Bindings;

namespace UnityEditorInternal
{
    [NativeType(Header = "Editor/Mono/RegistryUtil.bindings.h")]
    public class RegistryUtil
    {
        public RegistryUtil();

        public static uint GetRegistryUInt32Value(string subKey, string valueName, uint defaultValue, RegistryView view);
        public static string GetRegistryStringValue(string subKey, string valueName, string defaultValue, RegistryView view);
    }
}
using System;
using System.Collections.Generic;
using System.ComponentModel;
using UnityEngine;

namespace UnityEditorInternal
{
    public class ScriptEditorUtility
    {
        public ScriptEditorUtility();

        [Obsolete("Use UnityEditor.ScriptEditor.Register()", False)]
        public static void RegisterIde(Func<Installation[]> pathCallBack);
        [Obsolete("This functionality is going to be removed. See IExternalCodeEditor for more information", False)]
        public static ScriptEditor GetScriptEditorFromPath(string path);
        public static string GetExternalScriptEditor();
        [Obsolete("This method has been moved to CodeEditor.SetExternalScriptEditor", False)]
        public static void SetExternalScriptEditor(string path);
        public static string GetExternalScriptEditorArgs();
        [Obsolete("This functionality has been moved to the IExternalCodeEditor packages", True)]
        [EditorBrowsable(Never)]
        public static void SetExternalScriptEditorArgs(string args);
        [Obsolete("Use UnityEditor.ScriptEditor.GetCurrentEditor()", False)]
        public static ScriptEditor GetScriptEditorFromPreferences();
        [Obsolete("This method is being internalized, please use UnityEditorInternal.CodeEditorUtility.GetFoundScriptEditorPaths", False)]
        public static Dictionary<string, string> GetFoundScriptEditorPaths(RuntimePlatform platform);

        public enum ScriptEditor
        {
            SystemDefault = 0,
            MonoDevelop = 1,
            VisualStudio = 2,
            VisualStudioExpress = 3,
            Other = 32
        }
        public struct Installation
        {
            public string Name;
            public string Path;
        }
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditorInternal
{
    [StaticAccessor("SpriteUtilityBindings", DoubleColon)]
    public sealed class InternalSpriteUtility
    {
        public InternalSpriteUtility();

        public static Rect[] GenerateAutomaticSpriteRectangles([NotNull("ArgumentNullException")] Texture2D texture, int minRectSize, int extrudeSize);
        public static Rect[] GenerateGridSpriteRectangles([NotNull("ArgumentNullException")] Texture2D texture, Vector2 offset, Vector2 size, Vector2 padding, bool keepEmptyRects);
        public static Rect[] GenerateGridSpriteRectangles(Texture2D texture, Vector2 offset, Vector2 size, Vector2 padding);
    }
}
using UnityEditor;
using UnityEngine;

namespace UnityEditorInternal
{
    [ExcludeFromPreset]
    public sealed class AssemblyDefinitionImporter : AssetImporter
    {
        public AssemblyDefinitionImporter();
    }
}
using UnityEngine;

namespace UnityEditorInternal
{
    public sealed class AssemblyDefinitionAsset : TextAsset
    {
    }
}
using UnityEditor;
using UnityEngine;

namespace UnityEditorInternal
{
    [ExcludeFromPreset]
    public sealed class AssemblyDefinitionReferenceImporter : AssetImporter
    {
        public AssemblyDefinitionReferenceImporter();
    }
}
using UnityEngine;

namespace UnityEditorInternal
{
    public sealed class AssemblyDefinitionReferenceAsset : TextAsset
    {
    }
}
using System.Collections.Generic;
using System.Diagnostics;

namespace UnityEditorInternal
{
    public abstract class Il2CppNativeCodeBuilder
    {
        public Il2CppNativeCodeBuilder(string baselibLibraryDirectory);

        public abstract string CompilerPlatform { get; }
        public abstract string CompilerArchitecture { get; }
        public string BaselibLibraryDirectory { get; }
        public virtual string CompilerFlags { get; }
        public virtual string LinkerFlags { get; }
        public virtual bool SetsUpEnvironment { get; }
        public virtual string CacheDirectory { get; }
        public virtual string PluginPath { get; }
        public virtual IEnumerable<string> AdditionalIl2CPPArguments { get; }
        public virtual bool LinkLibIl2CppStatically { get; }

        public virtual IEnumerable<string> ConvertIncludesToFullPaths(IEnumerable<string> relativeIncludePaths);
        public virtual string ConvertOutputFileToFullPath(string outputFileRelativePath);
        public void SetupStartInfo(ProcessStartInfo startInfo);
        protected virtual void SetupEnvironment(ProcessStartInfo startInfo);
    }
}
using System.Collections.Generic;
using UnityEditor;

namespace UnityEditorInternal
{
    public static class Il2CppNativeCodeBuilderUtils
    {
        public static IEnumerable<string> AddBuilderArguments(Il2CppNativeCodeBuilder builder, string outputRelativePath, IEnumerable<string> includeRelativePaths, IEnumerable<string> additionalLibs, Il2CppCompilerConfiguration compilerConfiguration);
        public static void ClearAndPrepareCacheDirectory(Il2CppNativeCodeBuilder builder);
        public static void ClearCacheIfEditorVersionDiffers(Il2CppNativeCodeBuilder builder, string currentEditorVersion);
        public static void PrepareCacheDirectory(Il2CppNativeCodeBuilder builder, string currentEditorVersion);
        public static string ObjectFilePathInCacheDirectoryFor(string builderCacheDirectory);
    }
}
using System;
using System.Collections;
using UnityEditor;
using UnityEngine;

namespace UnityEditorInternal
{
    public class ReorderableList
    {
        public HeaderCallbackDelegate drawHeaderCallback;
        public FooterCallbackDelegate drawFooterCallback;
        public ElementCallbackDelegate drawElementCallback;
        public ElementCallbackDelegate drawElementBackgroundCallback;
        public DrawNoneElementCallback drawNoneElementCallback;
        public ElementHeightCallbackDelegate elementHeightCallback;
        public ReorderCallbackDelegateWithDetails onReorderCallbackWithDetails;
        public ReorderCallbackDelegate onReorderCallback;
        public SelectCallbackDelegate onSelectCallback;
        public AddCallbackDelegate onAddCallback;
        public AddDropdownCallbackDelegate onAddDropdownCallback;
        public RemoveCallbackDelegate onRemoveCallback;
        public DragCallbackDelegate onMouseDragCallback;
        public SelectCallbackDelegate onMouseUpCallback;
        public CanRemoveCallbackDelegate onCanRemoveCallback;
        public CanAddCallbackDelegate onCanAddCallback;
        public ChangedCallbackDelegate onChangedCallback;
        public bool displayAdd;
        public bool displayRemove;
        public float elementHeight;
        public float headerHeight;
        public float footerHeight;
        public bool showDefaultBackground;

        public ReorderableList(IList elements, Type elementType);
        public ReorderableList(IList elements, Type elementType, bool draggable, bool displayHeader, bool displayAddButton, bool displayRemoveButton);
        public ReorderableList(SerializedObject serializedObject, SerializedProperty elements);
        public ReorderableList(SerializedObject serializedObject, SerializedProperty elements, bool draggable, bool displayHeader, bool displayAddButton, bool displayRemoveButton);

        public static Defaults defaultBehaviours { get; }
        public SerializedProperty serializedProperty { get; set; }
        public IList list { get; set; }
        public int index { get; set; }
        public bool draggable { get; set; }
        public int count { get; }

        public void DoLayoutList();
        public void DoList(Rect rect);
        public void DoList(Rect rect, Rect visibleRect);
        public float GetHeight();
        public void GrabKeyboardFocus();
        public void ReleaseKeyboardFocus();
        public bool HasKeyboardControl();

        public delegate void HeaderCallbackDelegate(Rect rect);
        public delegate void FooterCallbackDelegate(Rect rect);
        public delegate void ElementCallbackDelegate(Rect rect, int index, bool isActive, bool isFocused);
        public delegate float ElementHeightCallbackDelegate(int index);
        public delegate void DrawNoneElementCallback(Rect rect);
        public delegate void ReorderCallbackDelegateWithDetails(ReorderableList list, int oldIndex, int newIndex);
        public delegate void ReorderCallbackDelegate(ReorderableList list);
        public delegate void SelectCallbackDelegate(ReorderableList list);
        public delegate void AddCallbackDelegate(ReorderableList list);
        public delegate void AddDropdownCallbackDelegate(Rect buttonRect, ReorderableList list);
        public delegate void RemoveCallbackDelegate(ReorderableList list);
        public delegate void ChangedCallbackDelegate(ReorderableList list);
        public delegate bool CanRemoveCallbackDelegate(ReorderableList list);
        public delegate bool CanAddCallbackDelegate(ReorderableList list);
        public delegate void DragCallbackDelegate(ReorderableList list);
        public class Defaults
        {
            public GUIContent iconToolbarPlus;
            public GUIContent iconToolbarPlusMore;
            public GUIContent iconToolbarMinus;
            public readonly GUIStyle draggingHandle;
            public readonly GUIStyle headerBackground;
            public readonly GUIStyle footerBackground;
            public readonly GUIStyle boxBackground;
            public readonly GUIStyle preButton;
            public readonly GUIStyle elementBackground;
            public const int padding = 6;
            public const int dragHandleWidth = 20;

            public Defaults();

            public void DrawFooter(Rect rect, ReorderableList list);
            public void DoAddButton(ReorderableList list);
            public void DoRemoveButton(ReorderableList list);
            public void DrawHeaderBackground(Rect headerRect);
            public void DrawHeader(Rect headerRect, SerializedObject serializedObject, SerializedProperty element, IList elementList);
            public void DrawElementBackground(Rect rect, int index, bool selected, bool focused, bool draggable);
            public void DrawElementDraggingHandle(Rect rect, int index, bool selected, bool focused, bool draggable);
            public void DrawElement(Rect rect, SerializedProperty element, object listItem, bool selected, bool focused, bool draggable);
            public void DrawElement(Rect rect, SerializedProperty element, object listItem, bool selected, bool focused, bool draggable, bool editable);
            public void DrawNoneElement(Rect rect, bool draggable);
            public void DrawOverMaxMultiEditElement(Rect rect, int maxMultiEditElementCount, bool draggable);
        }
    }
}
using System;
using System.ComponentModel;
using UnityEditor;
using UnityEngine;

namespace UnityEditorInternal
{
    [InitializeOnLoad]
    public class EditMode
    {
        public static OnEditModeStopFunc onEditModeEndDelegate;
        public static OnEditModeStartFunc onEditModeStartDelegate;

        public EditMode();

        public static SceneViewEditMode editMode { get; }

        public static bool IsOwner(Editor editor);
        public static void OnSelectionChange();
        public static void QuitEditMode();
        [Obsolete("Obsolete msg (UnityUpgradable) -> UnityEditor.EditorTools.ToolManager.RestorePreviousTool()")]
        [EditorBrowsable(Never)]
        public static void ResetToolToPrevious();
        [Obsolete("Use signature passing Func<Bounds> rather than Bounds.")]
        public static void DoEditModeInspectorModeButton(SceneViewEditMode mode, string label, GUIContent icon, Bounds bounds, Editor caller);
        public static void DoEditModeInspectorModeButton(SceneViewEditMode mode, string label, GUIContent icon, Func<Bounds> getBoundsOfTargets, Editor caller);
        [Obsolete("Use signature passing Func<Bounds> rather than Bounds.")]
        public static void DoInspectorToolbar(SceneViewEditMode[] modes, GUIContent[] guiContents, Bounds bounds, Editor caller);
        public static void DoInspectorToolbar(SceneViewEditMode[] modes, GUIContent[] guiContents, Func<Bounds> getBoundsOfTargets, Editor caller);
        public static void ChangeEditMode(SceneViewEditMode mode, Bounds bounds, Editor caller);

        public delegate void OnEditModeStopFunc(Editor editor);
        public delegate void OnEditModeStartFunc(Editor editor, SceneViewEditMode mode);
        public enum SceneViewEditMode
        {
            None = 0,
            Collider = 1,
            ClothConstraints = 2,
            ClothSelfAndInterCollisionParticles = 3,
            ReflectionProbeBox = 4,
            ReflectionProbeOrigin = 5,
            LightProbeProxyVolumeBox = 6,
            LightProbeProxyVolumeOrigin = 7,
            LightProbeGroup = 8,
            JointAngularLimits = 9,
            GridPainting = 10,
            GridPicking = 11,
            GridEraser = 12,
            GridFloodFill = 13,
            GridBox = 14,
            GridSelect = 15,
            GridMove = 16,
            ParticleSystemCollisionModulePlanesMove = 17,
            ParticleSystemCollisionModulePlanesRotate = 18,
            LineRendererEdit = 19,
            LineRendererCreate = 20,
            ParticleSystemShapeModuleGizmo = 21,
            ParticleSystemShapeModulePosition = 22,
            ParticleSystemShapeModuleRotation = 23,
            ParticleSystemShapeModuleScale = 24
        }
    }
}
using UnityEditor;
using UnityEngine;

namespace UnityEditorInternal
{
    [CustomPropertyDrawer(typeof(ParticleSystem.MinMaxCurve))]
    public class MinMaxCurvePropertyDrawer : PropertyDrawer
    {
        public MinMaxCurvePropertyDrawer();

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label);
    }
}
using UnityEditor;
using UnityEngine;

namespace UnityEditorInternal
{
    [CustomPropertyDrawer(typeof(ParticleSystem.MinMaxGradient))]
    public class MinMaxGradientPropertyDrawer : PropertyDrawer
    {
        public MinMaxGradientPropertyDrawer();

        public override float GetPropertyHeight(SerializedProperty property, GUIContent label);
        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label);
    }
}
using System;
using UnityEditor;
using UnityEngine;
using UnityEngine.Events;

namespace UnityEditorInternal
{
    [CustomPropertyDrawer(typeof(UnityEventBase), True)]
    public class UnityEventDrawer : PropertyDrawer
    {
        public UnityEventDrawer();

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label);
        public override float GetPropertyHeight(SerializedProperty property, GUIContent label);
        public void OnGUI(Rect position);
        protected virtual void SetupReorderableList(ReorderableList list);
        protected virtual void DrawEventHeader(Rect headerRect);
        protected virtual void DrawEvent(Rect rect, int index, bool isActive, bool isFocused);
        protected virtual void OnRemoveEvent(ReorderableList list);
        protected virtual void OnAddEvent(ReorderableList list);
        protected virtual void OnSelectEvent(ReorderableList list);
        protected virtual void OnReorderEvent(ReorderableList list);
        public static bool IsPersistantListenerValid(UnityEventBase dummyEvent, string methodName, UnityEngine.Object uObject, PersistentListenerMode modeEnum, Type argumentType);

        protected class State
        {
            public int lastSelectedIndex;

            public State();
        }
    }
}
using UnityEditor;

namespace UnityEditorInternal
{
    public static class MonoScripts
    {
        public static MonoScript CreateMonoScript(string scriptContents, string className, string nameSpace, string assemblyName, bool isEditorScript);
    }
}
using UnityEditor;
using UnityEngine.Bindings;

namespace UnityEditorInternal
{
    [StaticAccessor("RenderDoc", DoubleColon)]
    [NativeHeader("Editor/Src/RenderDoc/RenderDoc.h")]
    public static class RenderDoc
    {
        public static bool IsInstalled();
        public static bool IsLoaded();
        public static bool IsSupported();
        public static void Load();
        public static void BeginCaptureRenderDoc(EditorWindow window);
        public static void EndCaptureRenderDoc(EditorWindow window);
    }
}
using UnityEditor.IMGUI.Controls;
using UnityEngine;

namespace UnityEditorInternal
{
    public class ProfilerFrameDataMultiColumnHeader : MultiColumnHeader
    {
        public ProfilerFrameDataMultiColumnHeader(MultiColumnHeaderState state, Column[] columns);

        public Column[] columns { get; }
        public int sortedProfilerColumn { get; }
        public bool sortedProfilerColumnAscending { get; }

        public int GetMultiColumnHeaderIndex(int profilerColumn);
        public static int GetMultiColumnHeaderIndex(Column[] columns, int profilerColumn);
        public int GetProfilerColumn(int multiColumnHeaderIndex);

        public struct Column
        {
            public int profilerColumn;
            public GUIContent headerLabel;
        }
    }
}
namespace UnityEditorInternal
{
    public sealed class ObjectMemoryInfo
    {
        public int instanceId;
        public long memorySize;
        public int count;
        public int reason;
        public string name;
        public string className;

        public ObjectMemoryInfo();
    }
}
using UnityEngine.Scripting;

namespace UnityEditorInternal
{
    [RequiredByNativeCode]
    public sealed class ObjectMemoryStackInfo
    {
        public bool expanded;
        public bool sorted;
        public int allocated;
        public int ownedAllocated;
        public ObjectMemoryStackInfo[] callerSites;
        public string name;

        public ObjectMemoryStackInfo();
    }
}
using UnityEngine;

namespace UnityEditorInternal
{
    public struct ProfilerColorDescriptor
    {
        public readonly Color color;
        public readonly bool isBright;

        public ProfilerColorDescriptor(Color color);
    }
}
using System;

namespace UnityEditorInternal
{
    public struct NativeProfilerTimeline_InitializeArgs
    {
        public float ghostAlpha;
        public float nonSelectedAlpha;
        public float lineHeight;
        public float textFadeOutWidth;
        public float textFadeStartWidth;
        public IntPtr guiStyle;
        public ProfilerColorDescriptor[] profilerColorDescriptors;
        public int showFullScriptingMethodNames;

        public void Reset();
    }
}
using UnityEngine;

namespace UnityEditorInternal
{
    public struct NativeProfilerTimeline_DrawArgs
    {
        public int frameIndex;
        public int threadIndex;
        public float timeOffset;
        public Rect threadRect;
        public Rect shownAreaRect;
        public int selectedEntryIndex;
        public int mousedOverEntryIndex;

        public void Reset();
    }
}
using UnityEngine;

namespace UnityEditorInternal
{
    public struct NativeProfilerTimeline_GetEntryAtPositionArgs
    {
        public int frameIndex;
        public int threadIndex;
        public float timeOffset;
        public Rect threadRect;
        public Rect shownAreaRect;
        public Vector2 position;
        public int out_EntryIndex;
        public float out_EntryYMaxPos;
        public string out_EntryName;

        public void Reset();
    }
}
namespace UnityEditorInternal
{
    public struct NativeProfilerTimeline_GetEntryInstanceInfoArgs
    {
        public int frameIndex;
        public int threadIndex;
        public int entryIndex;
        public int out_Id;
        public string out_Path;
        public string out_CallstackInfo;
        public string out_MetaData;

        public void Reset();
    }
}
namespace UnityEditorInternal
{
    public struct NativeProfilerTimeline_GetEntryTimingInfoArgs
    {
        public int frameIndex;
        public int threadIndex;
        public int entryIndex;
        public bool calculateFrameData;
        public float out_LocalStartTime;
        public float out_Duration;
        public float out_TotalDurationForFrame;
        public int out_InstanceCountForFrame;

        public void Reset();
    }
}
using UnityEngine;

namespace UnityEditorInternal
{
    public struct NativeProfilerTimeline_GetEntryPositionInfoArgs
    {
        public int frameIndex;
        public int threadIndex;
        public int sampleIndex;
        public float timeOffset;
        public Rect threadRect;
        public Rect shownAreaRect;
        public Vector2 out_Position;
        public Vector2 out_Size;
        public int out_Depth;

        public void Reset();
    }
}
using UnityEngine.Bindings;

namespace UnityEditorInternal
{
    [NativeHeader("Modules/ProfilerEditor/Timeline/NativeProfilerTimeline.h")]
    public class NativeProfilerTimeline
    {
        public NativeProfilerTimeline();

        [FreeFunction]
        public static void Initialize(ref NativeProfilerTimeline_InitializeArgs args);
        [FreeFunction]
        public static void Draw(ref NativeProfilerTimeline_DrawArgs args);
        [FreeFunction]
        public static bool GetEntryAtPosition(ref NativeProfilerTimeline_GetEntryAtPositionArgs args);
        [FreeFunction]
        public static bool GetEntryInstanceInfo(ref NativeProfilerTimeline_GetEntryInstanceInfoArgs args);
        [FreeFunction]
        public static bool GetEntryTimingInfo(ref NativeProfilerTimeline_GetEntryTimingInfoArgs args);
        [FreeFunction]
        public static bool GetEntryPositionInfo(ref NativeProfilerTimeline_GetEntryPositionInfoArgs args);
    }
}
namespace UnityEditorInternal
{
    public enum MemoryInfoGCReason
    {
        SceneObject = 0,
        BuiltinResource = 1,
        MarkedDontSave = 2,
        AssetMarkedDirtyInEditor = 3,
        SceneAssetReferencedByNativeCodeOnly = 5,
        SceneAssetReferenced = 6,
        AssetReferencedByNativeCodeOnly = 8,
        AssetReferenced = 9,
        NotApplicable = 10
    }
}
using System;

namespace UnityEditorInternal
{
    [Flags]
    public enum ProfilerMemoryRecordMode
    {
        None = 0,
        GCAlloc = 1,
        UnsafeUtilityMalloc = 2,
        JobHandleComplete = 4,
        NativeAlloc = 8
    }
}
using System;

namespace UnityEditorInternal
{
    [Flags]
    public enum InstrumentedAssemblyTypes
    {
        None = 0,
        System = 1,
        Unity = 2,
        Plugins = 4,
        Script = 8,
        All = 2147483647
    }
}
namespace UnityEditorInternal
{
    public enum ProfilerMemoryView
    {
        Simple = 0,
        Detailed = 1
    }
}
using System;

namespace UnityEditorInternal
{
    public enum ProfilerAudioView
    {
        [Obsolete("This has been made obsolete. Audio stats are now shown on every subpane.", True)]
        Stats = 0,
        Channels = 1,
        Groups = 2,
        ChannelsAndGroups = 3,
        DSPGraph = 4,
        Clips = 5
    }
}
namespace UnityEditorInternal
{
    public enum ProfilerCaptureFlags
    {
        None = 0,
        Channels = 1,
        DSPNodes = 2,
        Clips = 4,
        All = 7
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditorInternal
{
    [RequiredByNativeCode]
    [Flags]
    [NativeHeader("Modules/Profiler/Public/ProfilerStatsBase.h")]
    public enum GpuProfilingStatisticsAvailabilityStates
    {
        Gathered = 1,
        Enabled = 2,
        Supported = 4,
        NotSupportedWithEditorProfiling = 8,
        NotSupportedWithLegacyGfxJobs = 16,
        NotSupportedWithNativeGfxJobs = 32,
        NotSupportedByDevice = 64,
        NotSupportedByGraphicsAPI = 128,
        NotSupportedDueToFrameTimingStatsAndDisjointTimerQuery = 256,
        NotSupportedWithVulkan = 512,
        NotSupportedWithMetal = 1024
    }
}
using UnityEngine.Scripting;

namespace UnityEditorInternal
{
    [RequiredByNativeCode]
    public struct EventMarker
    {
        public int objectInstanceId;
        public int nameOffset;
        public int frame;
    }
}
using System;
using UnityEditor.Profiling;
using UnityEngine.Bindings;
using UnityEngine.Profiling;

namespace UnityEditorInternal
{
    [NativeHeader("Modules/Profiler/Runtime/CollectProfilerStats.h")]
    [NativeHeader("Modules/Profiler/Instrumentation/InstrumentationProfiler.h")]
    [NativeHeader("Modules/ProfilerEditor/ProfilerHistory/ProfilerProperty.h")]
    [NativeHeader("Modules/ProfilerEditor/Public/EditorProfilerConnection.h")]
    [NativeHeader("Modules/ProfilerEditor/Public/ProfilerSession.h")]
    [NativeHeader("Runtime/Utilities/MemoryUtilities.h")]
    public static class ProfilerDriver
    {
        public static string directConnectionPort;

        [StaticAccessor("profiling::GetProfilerSessionPtr()->GetProfilerHistory()", Arrow)]
        public static int firstFrameIndex { get; }
        [StaticAccessor("profiling::GetProfilerSessionPtr()->GetProfilerHistory()", Arrow)]
        public static int lastFrameIndex { get; }
        [StaticAccessor("profiling::GetProfilerSessionPtr()->GetProfilerHistory()", Arrow)]
        public static string selectedPropertyPath { get; set; }
        public static bool enabled { get; set; }
        public static bool profileGPU { get; set; }
        [StaticAccessor("profiling::GetProfilerSessionPtr()", Arrow)]
        public static bool profileEditor { get; set; }
        [StaticAccessor("profiling::GetProfilerSessionPtr()", Arrow)]
        public static bool deepProfiling { get; set; }
        [StaticAccessor("profiling::GetProfilerSessionPtr()", Arrow)]
        public static ProfilerMemoryRecordMode memoryRecordMode { get; set; }
        [StaticAccessor("EditorProfilerConnection::Get()", Dot)]
        public static string directConnectionUrl { get; }
        [StaticAccessor("EditorProfilerConnection::Get()", Dot)]
        public static int connectedProfiler { get; set; }
        public static string miniMemoryOverview { get; }
        public static uint usedHeapSize { get; }
        public static uint objectCount { get; }
        [Obsolete("Deprecated, use GetGPUStatisticsAvailabilityState instead.")]
        public static bool isGPUProfilerSupportedByOS { get; }
        [Obsolete("Deprecated, use GetGPUStatisticsAvailabilityState instead.")]
        public static bool isGPUProfilerSupported { get; }
        [Obsolete("Deprecated API, it will always return false, use GetGPUStatisticsAvailabilityState instead.")]
        public static bool isGPUProfilerBuggyOnDriver { get; }

        public static event Action<int, int> NewProfilerFrameRecorded;
        public static event Action profileLoaded;

        [StaticAccessor("profiling::GetProfilerSessionPtr()->GetProfilerHistory()", Arrow)]
        [NativeMethod("CleanupFrameHistory")]
        public static void ClearAllFrames();
        [StaticAccessor("profiling::GetProfilerSessionPtr()->GetProfilerHistory()", Arrow)]
        public static int GetNextFrameIndex(int frame);
        [StaticAccessor("profiling::GetProfilerSessionPtr()->GetProfilerHistory()", Arrow)]
        public static int GetPreviousFrameIndex(int frame);
        [StaticAccessor("profiling::GetProfilerSessionPtr()", Arrow)]
        [NativeMethod("SetProfileArea")]
        public static void SetAreaEnabled(ProfilerArea area, bool enabled);
        [NativeMethod("IsProfilingArea")]
        [StaticAccessor("profiling::GetProfilerSessionPtr()", Arrow)]
        public static bool IsAreaEnabled(ProfilerArea area);
        [StaticAccessor("profiling::GetProfilerSessionPtr()", Arrow)]
        public static void SetMarkerFiltering(string name);
        [StaticAccessor("profiling::GetProfilerSessionPtr()->GetProfilerHistory()", Arrow)]
        [Obsolete("Use GetFormattedCounterValue to get the stats including Profiler Counter data", False)]
        public static string GetFormattedStatisticsValue(int frame, int identifier);
        [StaticAccessor("profiling::GetProfilerSessionPtr()->GetProfilerHistory()", Arrow)]
        public static int GetUISystemEventMarkersCount(int firstFrame, int frameCount);
        [StaticAccessor("profiling::GetProfilerSessionPtr()->GetProfilerHistory()", Arrow)]
        public static void GetUISystemEventMarkersBatch(int firstFrame, int frameCount, out EventMarker[] buffer, out string[] names);
        [StaticAccessor("profiling::GetProfilerSessionPtr()->GetProfilerHistory()", Arrow)]
        [Obsolete("Use GetCounterValuesBatch to read the stats including Profiler Counter data", False)]
        [NativeMethod("GetStatisticsValuesBatch")]
        public static void GetStatisticsValues(int identifier, int firstFrame, float scale, out float[] buffer, out float maxValue);
        [StaticAccessor("profiling::GetProfilerSessionPtr()->GetProfilerHistory()", Arrow)]
        public static string GetFormattedCounterValue(int frame, ProfilerArea area, string name);
        public static string GetFormattedCounterValue(int frame, string category, string name);
        [StaticAccessor("profiling::GetProfilerSessionPtr()->GetProfilerHistory()", Arrow)]
        public static void GetCounterValuesBatch(ProfilerArea area, string name, int firstFrame, float scale, out float[] buffer, out float maxValue);
        public static void GetCounterValuesBatch(string category, string name, int firstFrame, float scale, out float[] buffer, out float maxValue);
        public static void GetGpuStatisticsAvailabilityStates(int firstFrame, out GpuProfilingStatisticsAvailabilityStates[] buffer);
        [NativeMethod("GetGpuStatisticsAvailabilityState")]
        [StaticAccessor("profiling::GetProfilerSessionPtr()->GetProfilerHistory()", Arrow)]
        public static GpuProfilingStatisticsAvailabilityStates GetGpuStatisticsAvailabilityState(int frame);
        public static HierarchyFrameDataView GetHierarchyFrameDataView(int frameIndex, int threadIndex, HierarchyFrameDataView.ViewModes viewMode, int sortColumn, bool sortAscending);
        public static RawFrameDataView GetRawFrameDataView(int frameIndex, int threadIndex);
        [Obsolete("ResetHistory is deprecated, use ClearAllFrames instead.")]
        public static void ResetHistory();
        [StaticAccessor("profiling::GetProfilerSessionPtr()", Arrow)]
        [NativeMethod("SaveToFile")]
        public static void SaveProfile(string filename);
        [NativeMethod("LoadFromFile")]
        [StaticAccessor("profiling::GetProfilerSessionPtr()", Arrow)]
        public static bool LoadProfile(string filename, bool keepExistingData);
        [StaticAccessor("profiling::GetProfilerSessionPtr()->GetProfilerHistory()", Arrow)]
        [NativeMethod("GetAllStatisticsProperties")]
        public static string[] GetAllStatisticsProperties();
        [StaticAccessor("profiling::GetProfilerSessionPtr()->GetProfilerHistory()", Arrow)]
        public static string[] GetGraphStatisticsPropertiesForArea(ProfilerArea area);
        [Obsolete("Use GetStatisticsIdentifierForArea that takes ProfilerArea as first argument", False)]
        public static int GetStatisticsIdentifier(string propertyName);
        [StaticAccessor("profiling::GetProfilerSessionPtr()->GetProfilerHistory()", Arrow)]
        public static void GetStatisticsAvailable(ProfilerArea profilerArea, int firstFrame, out int[] buffer);
        [Obsolete("GetStatisticsAvailable with bool buffer is obsolete, use with int array instead. (x & 1) == 1 is the same as true")]
        public static void GetStatisticsAvailable(ProfilerArea profilerArea, int firstFrame, out bool[] buffer);
        [NativeMethod("GetStatisticsIdentifier")]
        [StaticAccessor("profiling::GetProfilerSessionPtr()->GetProfilerHistory()", Arrow)]
        public static int GetStatisticsIdentifierForArea(ProfilerArea profilerArea, string propertyName);
        [NativeMethod("GetConnectionIdentification")]
        [StaticAccessor("EditorProfilerConnection::Get()", Dot)]
        public static string GetConnectionIdentifier(int guid);
        [StaticAccessor("EditorProfilerConnection::Get()", Dot)]
        public static bool IsIdentifierConnectable(int guid);
        [StaticAccessor("EditorProfilerConnection::Get()", Dot)]
        public static void DirectIPConnect(string IP);
        [StaticAccessor("EditorProfilerConnection::Get()", Dot)]
        public static void DirectURLConnect(string IP);
        [NativeMethod("GetAvailableProfilers")]
        [StaticAccessor("EditorProfilerConnection::Get()", Dot)]
        public static int[] GetAvailableProfilers();
        [NativeMethod("GetOverviewTextForProfilerArea")]
        [StaticAccessor("profiling::GetProfilerSessionPtr()->GetProfilerHistory()", Arrow)]
        public static string GetOverviewText(ProfilerArea profilerArea, int frame);
        public static void RequestMemorySnapshot();
        [StaticAccessor("EditorProfilerConnection::Get()", Dot)]
        [NativeMethod("SendGetObjectMemoryProfile")]
        public static void RequestObjectMemoryInfo(bool gatherObjectReferences);
        [StaticAccessor("EditorProfilerConnection::Get()", Dot)]
        [NativeMethod("SendQueryInstrumentableFunctions")]
        public static void QueryInstrumentableFunctions();
        [NativeMethod("SendQueryFunctionCallees")]
        [StaticAccessor("EditorProfilerConnection::Get()", Dot)]
        public static void QueryFunctionCallees(string fullname);
        public static void SetAutoInstrumentedAssemblies(InstrumentedAssemblyTypes fullname);
        [StaticAccessor("EditorProfilerConnection::Get()", Dot)]
        [NativeMethod("SendSetAudioCaptureFlags")]
        public static void SetAudioCaptureFlags(int flags);
        [StaticAccessor("EditorProfilerConnection::Get()", Dot)]
        [NativeMethod("SendBeginInstrumentFunction")]
        public static void BeginInstrumentFunction(string fullName);
        [StaticAccessor("EditorProfilerConnection::Get()", Dot)]
        [NativeMethod("SendEndInstrumentFunction")]
        public static void EndInstrumentFunction(string fullName);
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEditorInternal
{
    [NativeHeader("Modules/ProfilerEditor/ProfilerHistory/ProfilerFrameData.h")]
    public class ProfilerFrameDataIterator : IDisposable
    {
        public ProfilerFrameDataIterator();

        ~ProfilerFrameDataIterator();

        public int group { get; }
        public int depth { get; }
        public int maxDepth { get; }
        public string path { get; }
        public string name { get; }
        public int sampleId { get; }
        [Obsolete("Use instanceId instead", False)]
        public int id { get; }
        public int instanceId { get; }
        public float frameTimeMS { get; }
        public float frameGpuTimeMS { get; }
        public float startTimeMS { get; }
        public float durationMS { get; }
        public string extraTooltipInfo { get; }

        public void Dispose();
        [NativeMethod("GetNext")]
        public bool Next(bool enterChildren);
        public int GetThreadCount(int frame);
        public double GetFrameStartS(int frame);
        public int GetGroupCount(int frame);
        public string GetGroupName();
        public string GetThreadName();
        public void SetRoot(int frame, int threadIdx);
    }
}
using UnityEngine.Scripting;

namespace UnityEditorInternal
{
    [UsedByNativeCode]
    public struct AudioProfilerGroupInfo
    {
        public int assetInstanceId;
        public int objectInstanceId;
        public int assetNameOffset;
        public int objectNameOffset;
        public int parentId;
        public int uniqueId;
        public int flags;
        public int playCount;
        public float distanceToListener;
        public float volume;
        public float audibility;
        public float minDist;
        public float maxDist;
        public float time;
        public float duration;
        public float frequency;
    }
}
using UnityEngine.Scripting;

namespace UnityEditorInternal
{
    [UsedByNativeCode]
    public struct AudioProfilerDSPInfo
    {
        public int id;
        public int target;
        public int targetPort;
        public int numChannels;
        public int nameOffset;
        public float weight;
        public float cpuLoad;
        public float level1;
        public float level2;
        public int numLevels;
        public int flags;
    }
}
using UnityEngine.Scripting;

namespace UnityEditorInternal
{
    [UsedByNativeCode]
    public struct AudioProfilerClipInfo
    {
        public int assetInstanceId;
        public int assetNameOffset;
        public int loadState;
        public int internalLoadState;
        public int age;
        public int disposed;
        public int numChannelInstances;
        public int numClones;
        public int refCount;
        public ulong instancePtr;
    }
}
using System;

namespace UnityEditorInternal
{
    [Flags]
    public enum BatchBreakingReason
    {
        NoBreaking = 0,
        NotCoplanarWithCanvas = 1,
        CanvasInjectionIndex = 2,
        DifferentMaterialInstance = 4,
        DifferentRectClipping = 8,
        DifferentTexture = 16,
        DifferentA8TextureUsage = 32,
        DifferentClipRect = 64,
        Unknown = 128
    }
}
using UnityEngine.Scripting;

namespace UnityEditorInternal
{
    [UsedByNativeCode]
    public struct UISystemProfilerInfo
    {
        public int objectInstanceId;
        public int objectNameOffset;
        public int parentId;
        public int batchCount;
        public int totalBatchCount;
        public int vertexCount;
        public int totalVertexCount;
        public bool isBatch;
        public BatchBreakingReason batchBreakingReason;
        public int instanceIDsIndex;
        public int instanceIDsCount;
        public int renderDataIndex;
        public int renderDataCount;
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditorInternal
{
    [NativeHeader("Runtime/Interfaces/IUISystem.h")]
    [NativeHeader("Modules/ProfilerEditor/ProfilerHistory/ProfilerProperty.h")]
    public class ProfilerProperty : IDisposable
    {
        public ProfilerProperty();

        ~ProfilerProperty();

        [NativeMethod("FunctionName")]
        public string propertyName { get; }
        public bool HasChildren { get; }
        public bool onlyShowGPUSamples { get; set; }
        public int[] instanceIDs { get; }
        public int depth { get; }
        public string propertyPath { get; }
        public string frameFPS { get; }
        public string frameTime { get; }
        public string frameGpuTime { get; }
        public bool frameDataReady { get; }

        [NativeMethod("CleanupProperty")]
        public void Cleanup();
        [NativeMethod("GetNext")]
        public bool Next(bool enterChildren);
        public void SetRoot(int frame, int profilerSortColumn, int viewType);
        public void ResetToRoot();
        public void InitializeDetailProperty(ProfilerProperty source);
        public string GetTooltip(int column);
        [NativeMethod("GetProfilerColumn")]
        public string GetColumn(int column);
        [NativeMethod("GetProfilerColumnAsSingle")]
        public float GetColumnAsSingle(int colum);
        public AudioProfilerGroupInfo[] GetAudioProfilerGroupInfo();
        public AudioProfilerDSPInfo[] GetAudioProfilerDSPInfo();
        public AudioProfilerClipInfo[] GetAudioProfilerClipInfo();
        public string GetAudioProfilerNameByOffset(int offset);
        public UISystemProfilerInfo[] GetUISystemProfilerInfo();
        public string GetUISystemProfilerNameByOffset(int offset);
        public EventMarker[] GetUISystemEventMarkers();
        public string GetUISystemEventMarkerNameByOffset(int offset);
        public int[] GetUISystemBatchInstanceIDs();
        [StaticAccessor("GetIUISystem()", Arrow)]
        [NativeMethod("ReleaseTexture")]
        public static void ReleaseUISystemProfilerRender(Texture2D t);
        public static Texture2D UISystemProfilerRender(int frameIndex, int renderDataIndex, int renderDataCount, bool renderOverdraw);
        public void Dispose();
    }
}
using UnityEditor;
using UnityEngine.Bindings;

namespace UnityEditorInternal.VR
{
    [NativeHeader("Modules/VREditor/VREditor.bindings.h")]
    public sealed class VREditor
    {
        public VREditor();

        public static bool GetVREnabledOnTargetGroup(BuildTargetGroup targetGroup);
        public static void SetVREnabledOnTargetGroup(BuildTargetGroup targetGroup, bool value);
        [NativeMethod("SetVREnabledDevicesOnTargetGroup")]
        public static void NativeSetVREnabledDevicesOnTargetGroup(BuildTargetGroup targetGroup, string[] devices);
        public static void SetVREnabledDevicesOnTargetGroup(BuildTargetGroup targetGroup, string[] devices);
    }
}
namespace UnityEditorInternal.Profiling.Memory.Experimental
{
    public delegate T GetItem<T>(byte[] data, uint startIndex, uint numBytes);
}
using UnityEditorInternal.Profiling.Memory.Experimental.FileFormat;
using UnityEngine;

namespace UnityEditorInternal.Profiling.Memory.Experimental
{
    public class MemorySnapshotFileReader : ISerializationCallbackReceiver
    {
        public MemorySnapshotFileReader(string filePath);
        public MemorySnapshotFileReader();

        public void Dispose();
        public string GetFilePath();
        public void Open(string filePath);
        public void Close();
        public void OnBeforeSerialize();
        public void OnAfterDeserialize();
        public void GetDataArray<T>(EntryType entryType, uint entryIndex, uint numEntries, ref T[] dataOut, GetItem<T> getItemFunc);
        public T GetDataSingle<T>(EntryType entryType, GetItem<T> getItemFunc);
        public uint GetNumEntries(EntryType entryType);
    }
}
using System;
using UnityEditorInternal.Profiling.Memory.Experimental.FileFormat;
using UnityEngine.Bindings;

namespace UnityEditorInternal.Profiling.Memory.Experimental
{
    [NativeHeader("Modules/Profiler/Public/MemorySnapshot/MemorySnapshotFileWriter.h")]
    public class MemorySnapshotFileWriter : IDisposable
    {
        public MemorySnapshotFileWriter(string filepath);
        public MemorySnapshotFileWriter();

        [NativeThrows]
        public void Open(string filename);
        public void Close();
        public void Dispose();
        public void WriteEntry(EntryType entryType, string data);
        public void WriteEntry<T>(EntryType entryType, T data) where T : struct;
        public void WriteEntryArray<T>(EntryType entryType, T[] data) where T : struct;
    }
}
namespace UnityEditorInternal.Profiling.Memory.Experimental.FileFormat
{
    public enum EntryType
    {
        Metadata_Version = 0,
        Metadata_RecordDate = 1,
        Metadata_UserMetadata = 2,
        Metadata_CaptureFlags = 3,
        Metadata_VirtualMachineInformation = 4,
        NativeTypes_Name = 5,
        NativeTypes_NativeBaseTypeArrayIndex = 6,
        NativeObjects_NativeTypeArrayIndex = 7,
        NativeObjects_HideFlags = 8,
        NativeObjects_Flags = 9,
        NativeObjects_InstanceId = 10,
        NativeObjects_Name = 11,
        NativeObjects_NativeObjectAddress = 12,
        NativeObjects_Size = 13,
        NativeObjects_RootReferenceId = 14,
        GCHandles_Target = 15,
        Connections_From = 16,
        Connections_To = 17,
        ManagedHeapSections_StartAddress = 18,
        ManagedHeapSections_Bytes = 19,
        ManagedStacks_StartAddress = 20,
        ManagedStacks_Bytes = 21,
        TypeDescriptions_Flags = 22,
        TypeDescriptions_Name = 23,
        TypeDescriptions_Assembly = 24,
        TypeDescriptions_FieldIndices = 25,
        TypeDescriptions_StaticFieldBytes = 26,
        TypeDescriptions_BaseOrElementTypeIndex = 27,
        TypeDescriptions_Size = 28,
        TypeDescriptions_TypeInfoAddress = 29,
        TypeDescriptions_TypeIndex = 30,
        FieldDescriptions_Offset = 31,
        FieldDescriptions_TypeIndex = 32,
        FieldDescriptions_Name = 33,
        FieldDescriptions_IsStatic = 34,
        NativeRootReferences_Id = 35,
        NativeRootReferences_AreaName = 36,
        NativeRootReferences_ObjectName = 37,
        NativeRootReferences_AccumulatedSize = 38,
        NativeAllocations_MemoryRegionIndex = 39,
        NativeAllocations_RootReferenceId = 40,
        NativeAllocations_AllocationSiteId = 41,
        NativeAllocations_Address = 42,
        NativeAllocations_Size = 43,
        NativeAllocations_OverheadSize = 44,
        NativeAllocations_PaddingSize = 45,
        NativeMemoryRegions_Name = 46,
        NativeMemoryRegions_ParentIndex = 47,
        NativeMemoryRegions_AddressBase = 48,
        NativeMemoryRegions_AddressSize = 49,
        NativeMemoryRegions_FirstAllocationIndex = 50,
        NativeMemoryRegions_NumAllocations = 51,
        NativeMemoryLabels_Name = 52,
        NativeAllocationSites_Id = 53,
        NativeAllocationSites_MemoryLabelIndex = 54,
        NativeAllocationSites_CallstackSymbols = 55,
        NativeCallstackSymbol_Symbol = 56,
        NativeCallstackSymbol_ReadableStackTrace = 57,
        NativeObjects_GCHandleIndex = 58
    }
}
using UnityEditor;
using UnityEditor.VersionControl;

namespace UnityEditorInternal.VersionControl
{
    public class AssetModificationHook
    {
        public AssetModificationHook();

        public static void FileModeChanged(string[] assets, FileMode mode);
        public static AssetMoveResult OnWillMoveAsset(string from, string to);
        public static AssetDeleteResult OnWillDeleteAsset(string assetPath, RemoveAssetOptions option);
        public static void OnWillDeleteAssets(string[] assetPaths, AssetDeleteResult[] deletionResults, RemoveAssetOptions option);
        public static bool IsOpenForEdit(string assetPath, out string message, StatusQueryOptions statusOptions);
    }
}
using System.Collections.Generic;
using UnityEditor.VersionControl;
using UnityEngine;

namespace UnityEditorInternal.VersionControl
{
    public class ListControl
    {
        public ListControl();

        ~ListControl();

        public ListState listState { get; }
        public ExpandDelegate ExpandEvent { get; set; }
        public DragDelegate DragEvent { get; set; }
        public ActionDelegate ActionEvent { get; set; }
        public ListItem Root { get; }
        public AssetList SelectedAssets { get; }
        public ChangeSets SelectedChangeSets { get; }
        public ChangeSets EmptyChangeSets { get; }
        public bool ReadOnly { get; set; }
        public string MenuFolder { get; set; }
        public string MenuDefault { get; set; }
        public bool DragAcceptOnly { get; set; }
        public int Size { get; }

        public static ListControl FromID(int id);
        public ListItem FindItemWithIdentifier(int identifier);
        public ListItem Add(ListItem parent, string name, Asset asset);
        public ListItem Add(ListItem parent, string name, ChangeSet change);
        public void Clear();
        public void Refresh();
        public void Refresh(bool updateExpanded);
        public void Sync();
        public bool OnGUI(Rect area, bool focus);
        public void SelectedSet(ListItem item);
        public void SelectedAll();
        public void SelectedAdd(ListItem item);

        public enum SelectDirection
        {
            Up = 0,
            Down = 1,
            Current = 2
        }
        public class ListState
        {
            [SerializeField]
            public float Scroll;
            [SerializeField]
            public List<string> Expanded;

            public ListState();
        }
        public delegate void ExpandDelegate(ChangeSet expand, ListItem item);
        public delegate void DragDelegate(ChangeSet target);
        public delegate void ActionDelegate(ListItem item, int actionIdx);
    }
}
using UnityEditor.VersionControl;
using UnityEngine;

namespace UnityEditorInternal.VersionControl
{
    public class ListItem
    {
        public ListItem();

        ~ListItem();

        public Texture Icon { get; set; }
        public int Identifier { get; }
        public string Name { get; set; }
        public int Indent { get; set; }
        public object Item { get; set; }
        public Asset Asset { get; set; }
        public ChangeSet Change { get; set; }
        public bool Expanded { get; set; }
        public bool Exclusive { get; set; }
        public bool Dummy { get; set; }
        public bool Hidden { get; set; }
        public bool HasChildren { get; }
        public bool HasActions { get; }
        public string[] Actions { get; set; }
        public bool CanExpand { get; }
        public bool CanAccept { get; set; }
        public int OpenCount { get; }
        public int ChildCount { get; }
        public ListItem Parent { get; }
        public ListItem FirstChild { get; }
        public ListItem LastChild { get; }
        public ListItem Prev { get; }
        public ListItem Next { get; }
        public ListItem PrevOpen { get; }
        public ListItem NextOpen { get; }
        public ListItem PrevOpenSkip { get; }
        public ListItem NextOpenSkip { get; }
        public ListItem PrevOpenVisible { get; }
        public ListItem NextOpenVisible { get; }

        public bool HasPath();
        public bool IsChildOf(ListItem listItem);
        public void Clear();
        public void Add(ListItem listItem);
        public bool Remove(ListItem listItem);
        public void RemoveAll();
        public ListItem FindWithIdentifierRecurse(int inIdentifier);
    }
}
using UnityEditor.VersionControl;
using UnityEngine;

namespace UnityEditorInternal.VersionControl
{
    public class Overlay
    {
        public Overlay();

        public static Rect GetOverlayRect(Rect itemRect);
        public static void DrawOverlay(Asset asset, Asset metaAsset, Rect itemRect);
        public static void DrawOverlay(Asset asset, Rect itemRect);
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Editor/Src/Utility/ActiveEditorTracker.bindings.h")]
    public sealed class ActiveEditorTracker
    {
        public ActiveEditorTracker();

        ~ActiveEditorTracker();

        public Editor[] activeEditors { get; }
        public bool isDirty { get; }
        public bool isLocked { get; set; }
        public InspectorMode inspectorMode { get; set; }
        public bool hasComponentsWhichCannotBeMultiEdited { get; }
        public static ActiveEditorTracker sharedTracker { get; }

        public override bool Equals(object o);
        public override int GetHashCode();
        public void Destroy();
        public int GetVisible(int index);
        public void SetVisible(int index, int visible);
        public void ClearDirty();
        public void RebuildIfNecessary();
        public void ForceRebuild();
        public void VerifyModifiedMonoBehaviours();
        [Obsolete("Use Editor.CreateEditor instead")]
        public static Editor MakeCustomEditor(UnityEngine.Object obj);
        public static bool HasCustomEditor(UnityEngine.Object obj);
    }
}
using System;
using System.Collections.Generic;

namespace UnityEditor
{
    public static class ArrayUtility
    {
        public static void Add<T>(ref T[] array, T item);
        public static bool ArrayEquals<T>(T[] lhs, T[] rhs);
        public static bool ArrayReferenceEquals<T>(T[] lhs, T[] rhs);
        public static void AddRange<T>(ref T[] array, T[] items);
        public static void Insert<T>(ref T[] array, int index, T item);
        public static void Remove<T>(ref T[] array, T item);
        public static List<T> FindAll<T>(T[] array, Predicate<T> match);
        public static T Find<T>(T[] array, Predicate<T> match);
        public static int FindIndex<T>(T[] array, Predicate<T> match);
        public static int IndexOf<T>(T[] array, T value);
        public static int LastIndexOf<T>(T[] array, T value);
        public static void RemoveAt<T>(ref T[] array, int index);
        public static bool Contains<T>(T[] array, T item);
        public static void Clear<T>(ref T[] array);
    }
}
namespace UnityEditor
{
    public static class AssemblyReloadEvents
    {
        public static event AssemblyReloadCallback beforeAssemblyReload;
        public static event AssemblyReloadCallback afterAssemblyReload;

        public delegate void AssemblyReloadCallback();
    }
}
using System;

namespace UnityEditor
{
    [Flags]
    public enum AssetDeleteResult
    {
        DidNotDelete = 0,
        FailedDelete = 1,
        DidDelete = 2
    }
}
namespace UnityEditor
{
    public class AssetModificationProcessor
    {
        public AssetModificationProcessor();
    }
}
using System;

namespace UnityEditor
{
    [Flags]
    public enum AssetMoveResult
    {
        DidNotMove = 0,
        FailedMove = 1,
        DidMove = 2
    }
}
using System;
using System.ComponentModel;
using UnityEditor.AssetImporters;
using UnityEngine;
using UnityEngine.Internal;

namespace UnityEditor
{
    public class AssetPostprocessor
    {
        public AssetPostprocessor();

        public string assetPath { get; set; }
        public AssetImportContext context { get; }
        public AssetImporter assetImporter { get; }
        [EditorBrowsable(Never)]
        [Obsolete("To set or get the preview, call EditorUtility.SetAssetPreview or AssetPreview.GetAssetPreview instead", True)]
        public Texture2D preview { get; set; }

        [ExcludeFromDocs]
        public void LogWarning(string warning);
        public void LogWarning(string warning, [UnityEngine.Internal.DefaultValue("null")] UnityEngine.Object context);
        [ExcludeFromDocs]
        public void LogError(string warning);
        public void LogError(string warning, [UnityEngine.Internal.DefaultValue("null")] UnityEngine.Object context);
        public virtual uint GetVersion();
        public virtual int GetPostprocessOrder();
    }
}
using System;
using System.ComponentModel;

namespace UnityEditor
{
    [Flags]
    public enum BuildOptions
    {
        None = 0,
        Development = 1,
        AutoRunPlayer = 4,
        ShowBuiltPlayer = 8,
        BuildAdditionalStreamedScenes = 16,
        AcceptExternalModificationsToPlayer = 32,
        InstallInBuildFolder = 64,
        [EditorBrowsable(Never)]
        [Obsolete("WebPlayer has been removed in 5.4", True)]
        WebPlayerOfflineDeployment = 128,
        ConnectWithProfiler = 256,
        AllowDebugging = 512,
        SymlinkLibraries = 1024,
        UncompressedAssetBundle = 2048,
        [Obsolete("Use BuildOptions.Development instead")]
        StripDebugSymbols = 0,
        [Obsolete("Texture Compression is now always enabled")]
        CompressTextures = 0,
        ConnectToHost = 4096,
        EnableHeadlessMode = 16384,
        BuildScriptsOnly = 32768,
        PatchPackage = 65536,
        [Obsolete("BuildOptions.IL2CPP is deprecated and has no effect. Use PlayerSettings.SetScriptingBackend() instead.", True)]
        [EditorBrowsable(Never)]
        Il2CPP = 0,
        ForceEnableAssertions = 131072,
        CompressWithLz4 = 262144,
        CompressWithLz4HC = 524288,
        [Obsolete("Specify IL2CPP optimization level in Player Settings.")]
        ForceOptimizeScriptCompilation = 0,
        ComputeCRC = 1048576,
        StrictMode = 2097152,
        IncludeTestAssemblies = 4194304,
        NoUniqueIdentifier = 8388608,
        WaitForPlayerConnection = 33554432,
        EnableCodeCoverage = 67108864,
        EnableDeepProfilingSupport = 268435456,
        DetailedBuildReport = 536870912,
        ShaderLivelinkSupport = 1073741824
    }
}
using System;

namespace UnityEditor
{
    [Flags]
    public enum BuildAssetBundleOptions
    {
        None = 0,
        UncompressedAssetBundle = 1,
        [Obsolete("This has been made obsolete. It is always enabled in the new AssetBundle build system introduced in 5.0.")]
        CollectDependencies = 2,
        [Obsolete("This has been made obsolete. It is always enabled in the new AssetBundle build system introduced in 5.0.")]
        CompleteAssets = 4,
        DisableWriteTypeTree = 8,
        DeterministicAssetBundle = 16,
        ForceRebuildAssetBundle = 32,
        IgnoreTypeTreeChanges = 64,
        AppendHashToAssetBundleName = 128,
        ChunkBasedCompression = 256,
        StrictMode = 512,
        DryRunBuild = 1024,
        DisableLoadAssetByFileName = 4096,
        DisableLoadAssetByFileNameWithExtension = 8192,
        AssetBundleStripUnityVersion = 32768
    }
}
namespace UnityEditor
{
    public enum CanAppendBuild
    {
        Unsupported = 0,
        Yes = 1,
        No = 2
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    public struct AssetBundleBuild
    {
        public string assetBundleName;
        public string assetBundleVariant;
        public string[] assetNames;
        [NativeName("nameOverrides")]
        public string[] addressableNames;
    }
}
namespace UnityEditor
{
    public struct BuildPlayerOptions
    {
        public string[] scenes { get; set; }
        public string locationPathName { get; set; }
        public string assetBundleManifestPath { get; set; }
        public BuildTargetGroup targetGroup { get; set; }
        public BuildTarget target { get; set; }
        public BuildOptions options { get; set; }
        public string[] extraScriptingDefines { get; set; }
    }
}
namespace UnityEditor
{
    public enum PlayerConnectionInitiateMode
    {
        None = 0,
        PlayerConnectsToHost = 1,
        PlayerListens = 2
    }
}
using System;
using UnityEditor.Build.Reporting;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor
{
    [StaticAccessor("BuildPipeline", DoubleColon)]
    [NativeHeader("Editor/Mono/BuildPipeline.bindings.h")]
    public class BuildPipeline
    {
        public BuildPipeline();

        public static bool isBuildingPlayer { get; }

        [FreeFunction(IsThreadSafe = True)]
        public static BuildTargetGroup GetBuildTargetGroup(BuildTarget platform);
        [FreeFunction("GetBuildTargetUniqueName", IsThreadSafe = True)]
        public static string GetBuildTargetName(BuildTarget targetPlatform);
        [Obsolete("PushAssetDependencies has been made obsolete. Please use the new AssetBundle build system introduced in 5.0 and check BuildAssetBundles documentation for details.")]
        [FreeFunction]
        public static void PushAssetDependencies();
        [FreeFunction]
        [Obsolete("PopAssetDependencies has been made obsolete. Please use the new AssetBundle build system introduced in 5.0 and check BuildAssetBundles documentation for details.")]
        public static void PopAssetDependencies();
        [FreeFunction]
        public static CanAppendBuild BuildCanBeAppended(BuildTarget target, string location);
        public static BuildReport BuildPlayer(EditorBuildSettingsScene[] levels, string locationPathName, BuildTarget target, BuildOptions options);
        public static BuildReport BuildPlayer(string[] levels, string locationPathName, BuildTarget target, BuildOptions options);
        public static BuildReport BuildPlayer(BuildPlayerOptions buildPlayerOptions);
        [Obsolete("BuildStreamedSceneAssetBundle has been made obsolete. Please use the new AssetBundle build system introduced in 5.0 and check BuildAssetBundles documentation for details.")]
        public static string BuildStreamedSceneAssetBundle(string[] levels, string locationPath, BuildTarget target, BuildOptions options);
        [Obsolete("BuildStreamedSceneAssetBundle has been made obsolete. Please use the new AssetBundle build system introduced in 5.0 and check BuildAssetBundles documentation for details.")]
        public static string BuildStreamedSceneAssetBundle(string[] levels, string locationPath, BuildTarget target);
        [Obsolete("BuildStreamedSceneAssetBundle has been made obsolete. Please use the new AssetBundle build system introduced in 5.0 and check BuildAssetBundles documentation for details.")]
        public static string BuildStreamedSceneAssetBundle(string[] levels, string locationPath, BuildTarget target, out uint crc, BuildOptions options);
        [Obsolete("BuildStreamedSceneAssetBundle has been made obsolete. Please use the new AssetBundle build system introduced in 5.0 and check BuildAssetBundles documentation for details.")]
        public static string BuildStreamedSceneAssetBundle(string[] levels, string locationPath, BuildTarget target, out uint crc);
        public static void WriteBootConfig(string outputFile, BuildTarget target, BuildOptions options);
        [Obsolete("BuildAssetBundle has been made obsolete. Please use the new AssetBundle build system introduced in 5.0 and check BuildAssetBundles documentation for details.")]
        public static bool BuildAssetBundle(UnityEngine.Object mainAsset, UnityEngine.Object[] assets, string pathName, BuildAssetBundleOptions assetBundleOptions, BuildTarget targetPlatform);
        [Obsolete("BuildAssetBundle has been made obsolete. Please use the new AssetBundle build system introduced in 5.0 and check BuildAssetBundles documentation for details.")]
        public static bool BuildAssetBundle(UnityEngine.Object mainAsset, UnityEngine.Object[] assets, string pathName, out uint crc, BuildAssetBundleOptions assetBundleOptions, BuildTarget targetPlatform);
        [Obsolete("BuildAssetBundleExplicitAssetNames has been made obsolete. Please use the new AssetBundle build system introduced in 5.0 and check BuildAssetBundles documentation for details.")]
        public static bool BuildAssetBundleExplicitAssetNames(UnityEngine.Object[] assets, string[] assetNames, string pathName, BuildAssetBundleOptions assetBundleOptions, BuildTarget targetPlatform);
        [Obsolete("BuildAssetBundleExplicitAssetNames has been made obsolete. Please use the new AssetBundle build system introduced in 5.0 and check BuildAssetBundles documentation for details.")]
        public static bool BuildAssetBundleExplicitAssetNames(UnityEngine.Object[] assets, string[] assetNames, string pathName, out uint crc, BuildAssetBundleOptions assetBundleOptions, BuildTarget targetPlatform);
        public static AssetBundleManifest BuildAssetBundles(string outputPath, BuildAssetBundleOptions assetBundleOptions, BuildTarget targetPlatform);
        public static AssetBundleManifest BuildAssetBundles(string outputPath, AssetBundleBuild[] builds, BuildAssetBundleOptions assetBundleOptions, BuildTarget targetPlatform);
        [FreeFunction("ExtractCRCFromAssetBundleManifestFile")]
        public static bool GetCRCForAssetBundle(string targetPath, out uint crc);
        [FreeFunction("ExtractHashFromAssetBundleManifestFile")]
        public static bool GetHashForAssetBundle(string targetPath, out Hash128 hash);
        [FreeFunction]
        public static bool IsBuildTargetSupported(BuildTargetGroup buildTargetGroup, BuildTarget target);
        public static string GetPlaybackEngineDirectory(BuildTarget target, BuildOptions options);
        [FreeFunction(IsThreadSafe = True)]
        public static string GetPlaybackEngineDirectory(BuildTargetGroup buildTargetGroup, BuildTarget target, BuildOptions options);
        [RequiredByNativeCode]
        public static PlayerConnectionInitiateMode GetPlayerConnectionInitiateMode(BuildTarget targetPlatform, BuildOptions buildOptions);
    }
}
using System;

namespace UnityEditor
{
    public class BuildPlayerWindow : EditorWindow
    {
        public BuildPlayerWindow();

        public static void ShowBuildPlayerWindow();
        public static string GetPlaybackEngineDownloadURL(string moduleName);
        public static void RegisterGetBuildPlayerOptionsHandler(Func<BuildPlayerOptions, BuildPlayerOptions> func);
        public static void RegisterBuildPlayerHandler(Action<BuildPlayerOptions> func);

        public class BuildMethodException : Exception
        {
            public BuildMethodException();
            public BuildMethodException(string message);
        }
        public static class DefaultBuildMethods
        {
            public static void BuildPlayer(BuildPlayerOptions options);
            public static BuildPlayerOptions GetBuildPlayerOptions(BuildPlayerOptions defaultBuildPlayerOptions);
        }
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType("Runtime/Serialize/SerializationMetaFlags.h")]
    public enum BuildTarget
    {
        StandaloneOSX = 2,
        [Obsolete("Use StandaloneOSX instead (UnityUpgradable) -> StandaloneOSX", True)]
        StandaloneOSXUniversal = 3,
        [Obsolete("StandaloneOSXIntel has been removed in 2017.3")]
        StandaloneOSXIntel = 4,
        StandaloneWindows = 5,
        [Obsolete("WebPlayer has been removed in 5.4", True)]
        WebPlayer = 6,
        [Obsolete("WebPlayerStreamed has been removed in 5.4", True)]
        WebPlayerStreamed = 7,
        iOS = 9,
        [Obsolete("PS3 has been removed in >=5.5")]
        PS3 = 10,
        [Obsolete("XBOX360 has been removed in 5.5")]
        XBOX360 = 11,
        Android = 13,
        [Obsolete("StandaloneLinux has been removed in 2019.2")]
        StandaloneLinux = 17,
        StandaloneWindows64 = 19,
        WebGL = 20,
        WSAPlayer = 21,
        StandaloneLinux64 = 24,
        [Obsolete("StandaloneLinuxUniversal has been removed in 2019.2")]
        StandaloneLinuxUniversal = 25,
        [Obsolete("Use WSAPlayer with Windows Phone 8.1 selected")]
        WP8Player = 26,
        [Obsolete("StandaloneOSXIntel64 has been removed in 2017.3")]
        StandaloneOSXIntel64 = 27,
        [Obsolete("BlackBerry has been removed in 5.4")]
        BlackBerry = 28,
        [Obsolete("Tizen has been removed in 2017.3")]
        Tizen = 29,
        [Obsolete("PSP2 is no longer supported as of Unity 2018.3")]
        PSP2 = 30,
        PS4 = 31,
        [Obsolete("PSM has been removed in >= 5.3")]
        PSM = 32,
        XboxOne = 33,
        [Obsolete("SamsungTV has been removed in 2017.3")]
        SamsungTV = 34,
        [Obsolete("Nintendo 3DS support is unavailable since 2018.1")]
        N3DS = 35,
        [Obsolete("Wii U support was removed in 2018.1")]
        WiiU = 36,
        tvOS = 37,
        Switch = 38,
        Lumin = 39,
        Stadia = 40,
        CloudRendering = 41,
        [Obsolete("GameCoreScarlett is deprecated, please use GameCoreXboxSeries (UnityUpgradable) -> GameCoreXboxSeries", False)]
        GameCoreScarlett = 42,
        GameCoreXboxSeries = 42,
        GameCoreXboxOne = 43,
        PS5 = 44,
        [Obsolete("Use iOS instead (UnityUpgradable) -> iOS", True)]
        iPhone = -1,
        [Obsolete("BlackBerry has been removed in 5.4")]
        BB10 = -1,
        [Obsolete("Use WSAPlayer instead (UnityUpgradable) -> WSAPlayer", True)]
        MetroPlayer = -1,
        NoTarget = -2
    }
}
using System;
using System.ComponentModel;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType(Header = "Editor/Src/BuildPipeline/BuildTargetPlatformSpecific.h")]
    public enum BuildTargetGroup
    {
        Unknown = 0,
        Standalone = 1,
        [Obsolete("WebPlayer was removed in 5.4, consider using WebGL", True)]
        [EditorBrowsable(Never)]
        WebPlayer = 2,
        [EditorBrowsable(Never)]
        [Obsolete("Use iOS instead (UnityUpgradable) -> iOS", True)]
        iPhone = 4,
        iOS = 4,
        [Obsolete("PS3 has been removed in >=5.5")]
        PS3 = 5,
        [Obsolete("XBOX360 has been removed in 5.5")]
        XBOX360 = 6,
        Android = 7,
        WebGL = 13,
        WSA = 14,
        [Obsolete("Use WSA instead")]
        Metro = 14,
        [Obsolete("Use WSA instead")]
        WP8 = 15,
        [Obsolete("BlackBerry has been removed as of 5.4")]
        BlackBerry = 16,
        [Obsolete("Tizen has been removed in 2017.3")]
        Tizen = 17,
        [Obsolete("PSP2 is no longer supported as of Unity 2018.3")]
        PSP2 = 18,
        PS4 = 19,
        [Obsolete("PSM has been removed in >= 5.3")]
        PSM = 20,
        XboxOne = 21,
        [Obsolete("SamsungTV has been removed as of 2017.3")]
        SamsungTV = 22,
        [Obsolete("Nintendo 3DS support is unavailable since 2018.1")]
        N3DS = 23,
        [Obsolete("Wii U support was removed in 2018.1")]
        WiiU = 24,
        tvOS = 25,
        [Obsolete("Facebook support was removed in 2019.3")]
        Facebook = 26,
        Switch = 27,
        Lumin = 28,
        Stadia = 29,
        CloudRendering = 30,
        [Obsolete("GameCoreScarlett is deprecated, please use GameCoreXboxSeries (UnityUpgradable) -> GameCoreXboxSeries", False)]
        GameCoreScarlett = 31,
        GameCoreXboxSeries = 31,
        GameCoreXboxOne = 32,
        PS5 = 33
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEditor
{
    [RequiredByNativeCode]
    public abstract class CallbackOrderAttribute : Attribute
    {
        protected int m_CallbackOrder;

        protected CallbackOrderAttribute();
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEditor
{
    [RequiredByNativeCode]
    [Obsolete("PostProcessAttribute has been renamed to CallbackOrderAttribute.")]
    public abstract class PostProcessAttribute : CallbackOrderAttribute
    {
        [Obsolete("PostProcessAttribute has been renamed. Use m_CallbackOrder of CallbackOrderAttribute.")]
        protected int m_PostprocessOrder;

        protected PostProcessAttribute();
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Modules/AssetPipelineEditor/Public/DefaultImporter.h")]
    public class DefaultAsset : Object
    {
    }
}
namespace UnityEditor
{
    public enum DragAndDropVisualMode
    {
        None = 0,
        Copy = 1,
        Link = 2,
        Move = 16,
        Generic = 4,
        Rejected = 32
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [StaticAccessor("GetDragAndDrop()", Dot)]
    [NativeHeader("Editor/Platform/Interface/DragAndDrop.h")]
    public class DragAndDrop
    {
        public DragAndDrop();

        public static Object[] objectReferences { get; set; }
        public static string[] paths { get; set; }
        public static int activeControlID { get; set; }
        public static DragAndDropVisualMode visualMode { get; set; }

        public static void PrepareStartDrag();
        public static void StartDrag(string title);
        public static object GetGenericData(string type);
        public static void SetGenericData(string type, object data);
        public static void AcceptDrag();
    }
}
using System;

namespace UnityEditor
{
    [Flags]
    public enum GizmoType
    {
        Pickable = 1,
        NotInSelectionHierarchy = 2,
        NonSelected = 32,
        Selected = 4,
        Active = 8,
        InSelectionHierarchy = 16,
        [Obsolete("Use NotInSelectionHierarchy instead (UnityUpgradable) -> NotInSelectionHierarchy")]
        NotSelected = -127,
        [Obsolete("Use InSelectionHierarchy instead (UnityUpgradable) -> InSelectionHierarchy")]
        SelectedOrChild = -127
    }
}
using System;

namespace UnityEditor
{
    public sealed class DrawGizmo : Attribute
    {
        public Type drawnType;
        public GizmoType drawOptions;

        public DrawGizmo(GizmoType gizmo);
        public DrawGizmo(GizmoType gizmo, Type drawnGizmoType);
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [StaticAccessor("EditorApplicationBindings", DoubleColon)]
    [NativeHeader("Editor/Src/ScriptCompilation/ScriptCompilationPipeline.h")]
    [NativeHeader("Runtime/Camera/RenderSettings.h")]
    [NativeHeader("Runtime/Input/TimeManager.h")]
    [NativeHeader("Editor/Src/ProjectVersion.h")]
    [NativeHeader("Editor/Mono/EditorApplication.bindings.h")]
    [NativeHeader("Runtime/BaseClasses/TagManager.h")]
    public sealed class EditorApplication
    {
        public static ProjectWindowItemCallback projectWindowItemOnGUI;
        public static HierarchyWindowItemCallback hierarchyWindowItemOnGUI;
        public static CallbackFunction update;
        public static CallbackFunction delayCall;
        [Obsolete("Use EditorApplication.hierarchyChanged")]
        public static CallbackFunction hierarchyWindowChanged;
        [Obsolete("Use EditorApplication.projectChanged")]
        public static CallbackFunction projectWindowChanged;
        public static CallbackFunction searchChanged;
        public static CallbackFunction modifierKeysChanged;
        [Obsolete("Use EditorApplication.playModeStateChanged and/or EditorApplication.pauseStateChanged")]
        public static CallbackFunction playmodeStateChanged;
        public static SerializedPropertyCallbackFunction contextualPropertyMenu;

        public EditorApplication();

        public static bool isPlaying { get; set; }
        [StaticAccessor("GetApplication()", Dot)]
        public static bool isPlayingOrWillChangePlaymode { get; }
        [StaticAccessor("GetApplication().GetPlayerLoopController()", Dot)]
        public static bool isPaused { get; set; }
        public static bool isCompiling { get; }
        public static bool isUpdating { get; }
        public static bool isRemoteConnected { get; }
        [Obsolete("ScriptingRuntimeVersion has been deprecated in 2019.3 due to the removal of legacy mono")]
        public static ScriptingRuntimeVersion scriptingRuntimeVersion { get; }
        public static string applicationContentsPath { get; }
        public static string applicationPath { get; }
        public static bool isTemporaryProject { get; }
        public static double timeSinceStartup { get; }
        [Obsolete("Use Scene.isDirty instead. Use EditorSceneManager.GetScene API to get each open scene")]
        public static bool isSceneDirty { get; }
        [Obsolete("Use EditorSceneManager to see which scenes are currently loaded")]
        public static string currentScene { get; set; }

        public static event Func<bool> wantsToQuit;
        public static event Action quitting;
        public static event Action hierarchyChanged;
        public static event Action projectChanged;
        public static event Action<PauseState> pauseStateChanged;
        public static event Action<PlayModeStateChange> playModeStateChanged;

        [Obsolete("Use EditorSceneManager.LoadSceneInPlayMode instead.")]
        public static void LoadLevelInPlayMode(string path);
        [Obsolete("Use EditorSceneManager.LoadSceneInPlayMode instead.")]
        public static void LoadLevelAdditiveInPlayMode(string path);
        [Obsolete("Use EditorSceneManager.LoadSceneAsyncInPlayMode instead.")]
        public static AsyncOperation LoadLevelAsyncInPlayMode(string path);
        [Obsolete("Use EditorSceneManager.LoadSceneAsyncInPlayMode instead.")]
        public static AsyncOperation LoadLevelAdditiveAsyncInPlayMode(string path);
        public static void OpenProject(string projectPath, params string[] args);
        [Obsolete("Use AssetDatabase.SaveAssets instead (UnityUpgradable) -> AssetDatabase.SaveAssets()", True)]
        public static void SaveAssets();
        public static void EnterPlaymode();
        public static void ExitPlaymode();
        [StaticAccessor("GetApplication().GetPlayerLoopController()", Dot)]
        public static void Step();
        [StaticAccessor("GetApplication()", Dot)]
        public static void LockReloadAssemblies();
        [StaticAccessor("GetApplication()", Dot)]
        public static void UnlockReloadAssemblies();
        public static bool ExecuteMenuItem(string menuItemPath);
        [NativeThrows]
        public static void SetTemporaryProjectKeepPath(string path);
        public static void Exit(int returnValue);
        public static void QueuePlayerLoopUpdate();
        [FreeFunction("UnityBeep")]
        public static void Beep();
        public static void RepaintProjectWindow();
        public static void RepaintAnimationWindow();
        public static void RepaintHierarchyWindow();
        public static void DirtyHierarchyWindowSorting();
        [Obsolete("Use EditorSceneManager.NewScene (NewSceneSetup.DefaultGameObjects)")]
        public static void NewScene();
        [Obsolete("Use EditorSceneManager.NewScene (NewSceneSetup.EmptyScene)")]
        public static void NewEmptyScene();
        [Obsolete("Use EditorSceneManager.OpenScene")]
        public static bool OpenScene(string path);
        [Obsolete("Use EditorSceneManager.OpenScene")]
        public static void OpenSceneAdditive(string path);
        [Obsolete("Use EditorSceneManager.SaveScene")]
        public static bool SaveScene();
        [Obsolete("Use EditorSceneManager.SaveScene")]
        public static bool SaveScene(string path);
        [Obsolete("Use EditorSceneManager.SaveScene")]
        public static bool SaveScene(string path, bool saveAsCopy);
        [Obsolete("Use EditorSceneManager.SaveCurrentModifiedScenesIfUserWantsTo")]
        public static bool SaveCurrentSceneIfUserWantsTo();
        [Obsolete("Use EditorSceneManager.MarkSceneDirty or EditorSceneManager.MarkAllScenesDirty")]
        public static void MarkSceneDirty();

        public delegate void ProjectWindowItemCallback(string guid, Rect selectionRect);
        public delegate void HierarchyWindowItemCallback(int instanceID, Rect selectionRect);
        public delegate void CallbackFunction();
        public delegate void SerializedPropertyCallbackFunction(GenericMenu menu, SerializedProperty property);
    }
}
namespace UnityEditor
{
    public enum PlayModeStateChange
    {
        EnteredEditMode = 0,
        ExitingEditMode = 1,
        EnteredPlayMode = 2,
        ExitingPlayMode = 3
    }
}
namespace UnityEditor
{
    public enum PauseState
    {
        Paused = 0,
        Unpaused = 1
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEditor
{
    [AttributeUsage(Class)]
    [RequiredByNativeCode]
    public class InitializeOnLoadAttribute : Attribute
    {
        public InitializeOnLoadAttribute();
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEditor
{
    [AttributeUsage(Method)]
    [RequiredByNativeCode]
    public class InitializeOnLoadMethodAttribute : Attribute
    {
        public InitializeOnLoadMethodAttribute();
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEditor
{
    [AttributeUsage(Method)]
    [RequiredByNativeCode]
    public class InitializeOnEnterPlayModeAttribute : Attribute
    {
        public InitializeOnEnterPlayModeAttribute();
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor
{
    [NativeHeader("Editor/Src/EditorBuildSettings.h")]
    [NativeAsStruct]
    [UsedByNativeCode]
    public class EditorBuildSettingsScene : IComparable
    {
        public EditorBuildSettingsScene();
        public EditorBuildSettingsScene(string path, bool enabled);
        public EditorBuildSettingsScene(GUID guid, bool enabled);

        public bool enabled { get; set; }
        public string path { get; set; }
        public GUID guid { get; set; }

        public static string[] GetActiveSceneList(EditorBuildSettingsScene[] scenes);
        public int CompareTo(object obj);
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Editor/Src/EditorBuildSettings.h")]
    public class EditorBuildSettings : UnityEngine.Object
    {
        public static EditorBuildSettingsScene[] scenes { get; set; }

        public static event Action sceneListChanged;

        public static bool RemoveConfigObject(string name);
        public static string[] GetConfigObjectNames();
        public static void AddConfigObject(string name, UnityEngine.Object obj, bool overwrite);
        public static bool TryGetConfigObject<T>(string name, out T result) where T : UnityEngine.Object;
    }
}
using System;
using UnityEngine;
using UnityEngine.Internal;
using UnityEngine.Rendering;

namespace UnityEditor
{
    public sealed class EditorGUI
    {
        public EditorGUI();

        public static bool showMixedValue { get; set; }
        public static bool actionKey { get; }
        public static int indentLevel { get; set; }

        public static void FocusTextInControl(string name);
        public static void BeginDisabledGroup(bool disabled);
        public static void EndDisabledGroup();
        public static void BeginChangeCheck();
        public static bool EndChangeCheck();
        public static void DropShadowLabel(Rect position, string text);
        public static void DropShadowLabel(Rect position, GUIContent content);
        public static void DropShadowLabel(Rect position, string text, GUIStyle style);
        public static void DropShadowLabel(Rect position, GUIContent content, GUIStyle style);
        public static bool Toggle(Rect position, bool value);
        public static bool Toggle(Rect position, string label, bool value);
        public static bool Toggle(Rect position, bool value, GUIStyle style);
        public static bool Toggle(Rect position, string label, bool value, GUIStyle style);
        public static bool Toggle(Rect position, GUIContent label, bool value);
        public static bool Toggle(Rect position, GUIContent label, bool value, GUIStyle style);
        [Obsolete("Use PasswordField instead.")]
        public static string DoPasswordField(int id, Rect position, string password, GUIStyle style);
        [Obsolete("Use PasswordField instead.")]
        public static string DoPasswordField(int id, Rect position, GUIContent label, string password, GUIStyle style);
        public static float Slider(Rect position, float value, float leftValue, float rightValue);
        public static float Slider(Rect position, string label, float value, float leftValue, float rightValue);
        public static float Slider(Rect position, GUIContent label, float value, float leftValue, float rightValue);
        public static void Slider(Rect position, SerializedProperty property, float leftValue, float rightValue);
        public static void Slider(Rect position, SerializedProperty property, float leftValue, float rightValue, string label);
        public static void Slider(Rect position, SerializedProperty property, float leftValue, float rightValue, GUIContent label);
        public static int IntSlider(Rect position, int value, int leftValue, int rightValue);
        public static int IntSlider(Rect position, string label, int value, int leftValue, int rightValue);
        public static int IntSlider(Rect position, GUIContent label, int value, int leftValue, int rightValue);
        public static void IntSlider(Rect position, SerializedProperty property, int leftValue, int rightValue);
        public static void IntSlider(Rect position, SerializedProperty property, int leftValue, int rightValue, string label);
        public static void IntSlider(Rect position, SerializedProperty property, int leftValue, int rightValue, GUIContent label);
        [Obsolete("Switch the order of the first two parameters.")]
        public static void MinMaxSlider(GUIContent label, Rect position, ref float minValue, ref float maxValue, float minLimit, float maxLimit);
        public static void MinMaxSlider(Rect position, string label, ref float minValue, ref float maxValue, float minLimit, float maxLimit);
        public static void MinMaxSlider(Rect position, GUIContent label, ref float minValue, ref float maxValue, float minLimit, float maxLimit);
        public static void MinMaxSlider(Rect position, ref float minValue, ref float maxValue, float minLimit, float maxLimit);
        public static Enum EnumFlagsField(Rect position, Enum enumValue);
        public static Enum EnumFlagsField(Rect position, Enum enumValue, GUIStyle style);
        public static Enum EnumFlagsField(Rect position, string label, Enum enumValue);
        public static Enum EnumFlagsField(Rect position, string label, Enum enumValue, GUIStyle style);
        public static Enum EnumFlagsField(Rect position, GUIContent label, Enum enumValue);
        public static Enum EnumFlagsField(Rect position, GUIContent label, Enum enumValue, GUIStyle style);
        public static Enum EnumFlagsField(Rect position, GUIContent label, Enum enumValue, [DefaultValue("false")] bool includeObsolete, [DefaultValue("null")] GUIStyle style = null);
        public static void ObjectField(Rect position, SerializedProperty property);
        public static void ObjectField(Rect position, SerializedProperty property, GUIContent label);
        public static void ObjectField(Rect position, SerializedProperty property, Type objType);
        public static void ObjectField(Rect position, SerializedProperty property, Type objType, GUIContent label);
        public static UnityEngine.Object ObjectField(Rect position, UnityEngine.Object obj, Type objType, UnityEngine.Object targetBeingEdited);
        public static UnityEngine.Object ObjectField(Rect position, UnityEngine.Object obj, Type objType, bool allowSceneObjects);
        [Obsolete("Check the docs for the usage of the new parameter 'allowSceneObjects'.")]
        public static UnityEngine.Object ObjectField(Rect position, UnityEngine.Object obj, Type objType);
        public static UnityEngine.Object ObjectField(Rect position, string label, UnityEngine.Object obj, Type objType, UnityEngine.Object targetBeingEdited);
        public static UnityEngine.Object ObjectField(Rect position, string label, UnityEngine.Object obj, Type objType, bool allowSceneObjects);
        [Obsolete("Check the docs for the usage of the new parameter 'allowSceneObjects'.")]
        public static UnityEngine.Object ObjectField(Rect position, string label, UnityEngine.Object obj, Type objType);
        public static UnityEngine.Object ObjectField(Rect position, GUIContent label, UnityEngine.Object obj, Type objType, UnityEngine.Object targetBeingEdited);
        public static UnityEngine.Object ObjectField(Rect position, GUIContent label, UnityEngine.Object obj, Type objType, bool allowSceneObjects);
        [Obsolete("Check the docs for the usage of the new parameter 'allowSceneObjects'.")]
        public static UnityEngine.Object ObjectField(Rect position, GUIContent label, UnityEngine.Object obj, Type objType);
        public static Rect IndentedRect(Rect source);
        public static Vector2 Vector2Field(Rect position, string label, Vector2 value);
        public static Vector2 Vector2Field(Rect position, GUIContent label, Vector2 value);
        public static Vector3 Vector3Field(Rect position, string label, Vector3 value);
        public static Vector3 Vector3Field(Rect position, GUIContent label, Vector3 value);
        public static Vector4 Vector4Field(Rect position, string label, Vector4 value);
        public static Vector4 Vector4Field(Rect position, GUIContent label, Vector4 value);
        public static Vector2Int Vector2IntField(Rect position, string label, Vector2Int value);
        public static Vector2Int Vector2IntField(Rect position, GUIContent label, Vector2Int value);
        public static Vector3Int Vector3IntField(Rect position, string label, Vector3Int value);
        public static Vector3Int Vector3IntField(Rect position, GUIContent label, Vector3Int value);
        public static Rect RectField(Rect position, Rect value);
        public static Rect RectField(Rect position, string label, Rect value);
        public static Rect RectField(Rect position, GUIContent label, Rect value);
        public static RectInt RectIntField(Rect position, RectInt value);
        public static RectInt RectIntField(Rect position, string label, RectInt value);
        public static RectInt RectIntField(Rect position, GUIContent label, RectInt value);
        public static Bounds BoundsField(Rect position, Bounds value);
        public static Bounds BoundsField(Rect position, string label, Bounds value);
        public static Bounds BoundsField(Rect position, GUIContent label, Bounds value);
        public static BoundsInt BoundsIntField(Rect position, BoundsInt value);
        public static BoundsInt BoundsIntField(Rect position, string label, BoundsInt value);
        public static BoundsInt BoundsIntField(Rect position, GUIContent label, BoundsInt value);
        public static void MultiFloatField(Rect position, GUIContent label, GUIContent[] subLabels, float[] values);
        public static void MultiFloatField(Rect position, GUIContent[] subLabels, float[] values);
        public static void MultiIntField(Rect position, GUIContent[] subLabels, int[] values);
        public static void MultiPropertyField(Rect position, GUIContent[] subLabels, SerializedProperty valuesIterator, GUIContent label);
        public static void MultiPropertyField(Rect position, GUIContent[] subLabels, SerializedProperty valuesIterator);
        public static Color ColorField(Rect position, Color value);
        public static Color ColorField(Rect position, string label, Color value);
        public static Color ColorField(Rect position, GUIContent label, Color value);
        [Obsolete("Use EditorGUI.ColorField(Rect position, GUIContent label, Color value, bool showEyedropper, bool showAlpha, bool hdr)")]
        public static Color ColorField(Rect position, GUIContent label, Color value, bool showEyedropper, bool showAlpha, bool hdr, ColorPickerHDRConfig hdrConfig);
        public static Color ColorField(Rect position, GUIContent label, Color value, bool showEyedropper, bool showAlpha, bool hdr);
        public static AnimationCurve CurveField(Rect position, AnimationCurve value);
        public static AnimationCurve CurveField(Rect position, string label, AnimationCurve value);
        public static AnimationCurve CurveField(Rect position, GUIContent label, AnimationCurve value);
        public static AnimationCurve CurveField(Rect position, AnimationCurve value, Color color, Rect ranges);
        public static AnimationCurve CurveField(Rect position, string label, AnimationCurve value, Color color, Rect ranges);
        public static AnimationCurve CurveField(Rect position, GUIContent label, AnimationCurve value, Color color, Rect ranges);
        public static void CurveField(Rect position, SerializedProperty property, Color color, Rect ranges);
        public static void CurveField(Rect position, SerializedProperty property, Color color, Rect ranges, GUIContent label);
        public static void InspectorTitlebar(Rect position, UnityEngine.Object[] targetObjs);
        public static bool InspectorTitlebar(Rect position, bool foldout, UnityEngine.Object targetObj, bool expandable);
        public static bool InspectorTitlebar(Rect position, bool foldout, UnityEngine.Object[] targetObjs, bool expandable);
        public static bool InspectorTitlebar(Rect position, bool foldout, Editor editor);
        public static void ProgressBar(Rect position, float value, string text);
        public static void HelpBox(Rect position, string message, MessageType type);
        public static Rect PrefixLabel(Rect totalPosition, GUIContent label);
        public static Rect PrefixLabel(Rect totalPosition, GUIContent label, GUIStyle style);
        public static Rect PrefixLabel(Rect totalPosition, int id, GUIContent label);
        public static Rect PrefixLabel(Rect totalPosition, int id, GUIContent label, GUIStyle style);
        public static GUIContent BeginProperty(Rect totalPosition, GUIContent label, SerializedProperty property);
        public static void EndProperty();
        public static float GetPropertyHeight(SerializedPropertyType type, GUIContent label);
        public static bool CanCacheInspectorGUI(SerializedProperty property);
        public static bool DropdownButton(Rect position, GUIContent content, FocusType focusType);
        public static bool DropdownButton(Rect position, GUIContent content, FocusType focusType, GUIStyle style);
        public static void DrawTextureAlpha(Rect position, Texture image, [DefaultValue("ScaleMode.StretchToFill")] ScaleMode scaleMode, [DefaultValue("0")] float imageAspect, [DefaultValue("-1")] float mipLevel);
        [ExcludeFromDocs]
        public static void DrawTextureAlpha(Rect position, Texture image);
        [ExcludeFromDocs]
        public static void DrawTextureAlpha(Rect position, Texture image, ScaleMode scaleMode);
        [ExcludeFromDocs]
        public static void DrawTextureAlpha(Rect position, Texture image, ScaleMode scaleMode, float imageAspect);
        public static void DrawTextureTransparent(Rect position, Texture image, [DefaultValue("ScaleMode.StretchToFill")] ScaleMode scaleMode, [DefaultValue("0")] float imageAspect, [DefaultValue("-1")] float mipLevel, [DefaultValue("ColorWriteMask.All")] ColorWriteMask colorWriteMask, [DefaultValue("0")] float exposure);
        [ExcludeFromDocs]
        public static void DrawTextureTransparent(Rect position, Texture image, ScaleMode scaleMode);
        [ExcludeFromDocs]
        public static void DrawTextureTransparent(Rect position, Texture image);
        [ExcludeFromDocs]
        public static void DrawTextureTransparent(Rect position, Texture image, ScaleMode scaleMode, float imageAspect);
        [ExcludeFromDocs]
        public static void DrawTextureTransparent(Rect position, Texture image, ScaleMode scaleMode, float imageAspect, float mipLevel);
        [ExcludeFromDocs]
        public static void DrawTextureTransparent(Rect position, Texture image, ScaleMode scaleMode, float imageAspect, float mipLevel, ColorWriteMask colorWriteMask);
        public static void DrawPreviewTexture(Rect position, Texture image, [DefaultValue("null")] Material mat, [DefaultValue("ScaleMode.StretchToFill")] ScaleMode scaleMode, [DefaultValue("0")] float imageAspect, [DefaultValue("-1")] float mipLevel, [DefaultValue("ColorWriteMask.All")] ColorWriteMask colorWriteMask, [DefaultValue("0")] float exposure);
        [ExcludeFromDocs]
        public static void DrawPreviewTexture(Rect position, Texture image, Material mat, ScaleMode scaleMode, float imageAspect, float mipLevel, ColorWriteMask colorWriteMask);
        [ExcludeFromDocs]
        public static void DrawPreviewTexture(Rect position, Texture image, Material mat, ScaleMode scaleMode, float imageAspect, float mipLevel);
        [ExcludeFromDocs]
        public static void DrawPreviewTexture(Rect position, Texture image, Material mat, ScaleMode scaleMode, float imageAspect);
        [ExcludeFromDocs]
        public static void DrawPreviewTexture(Rect position, Texture image, Material mat, ScaleMode scaleMode);
        [ExcludeFromDocs]
        public static void DrawPreviewTexture(Rect position, Texture image, Material mat);
        [ExcludeFromDocs]
        public static void DrawPreviewTexture(Rect position, Texture image);
        [ExcludeFromDocs]
        public static void LabelField(Rect position, string label);
        public static void LabelField(Rect position, string label, [DefaultValue("EditorStyles.label")] GUIStyle style);
        [ExcludeFromDocs]
        public static void LabelField(Rect position, GUIContent label);
        public static void LabelField(Rect position, GUIContent label, [DefaultValue("EditorStyles.label")] GUIStyle style);
        [ExcludeFromDocs]
        public static void LabelField(Rect position, string label, string label2);
        public static void LabelField(Rect position, string label, string label2, [DefaultValue("EditorStyles.label")] GUIStyle style);
        [ExcludeFromDocs]
        public static void LabelField(Rect position, GUIContent label, GUIContent label2);
        public static void LabelField(Rect position, GUIContent label, GUIContent label2, [DefaultValue("EditorStyles.label")] GUIStyle style);
        [ExcludeFromDocs]
        public static bool ToggleLeft(Rect position, string label, bool value);
        public static bool ToggleLeft(Rect position, string label, bool value, [DefaultValue("EditorStyles.label")] GUIStyle labelStyle);
        [ExcludeFromDocs]
        public static bool ToggleLeft(Rect position, GUIContent label, bool value);
        public static bool ToggleLeft(Rect position, GUIContent label, bool value, [DefaultValue("EditorStyles.label")] GUIStyle labelStyle);
        [ExcludeFromDocs]
        public static string TextField(Rect position, string text);
        public static string TextField(Rect position, string text, [DefaultValue("EditorStyles.textField")] GUIStyle style);
        [ExcludeFromDocs]
        public static string TextField(Rect position, string label, string text);
        public static string TextField(Rect position, string label, string text, [DefaultValue("EditorStyles.textField")] GUIStyle style);
        [ExcludeFromDocs]
        public static string TextField(Rect position, GUIContent label, string text);
        public static string TextField(Rect position, GUIContent label, string text, [DefaultValue("EditorStyles.textField")] GUIStyle style);
        [ExcludeFromDocs]
        public static string DelayedTextField(Rect position, string text);
        public static string DelayedTextField(Rect position, string text, [DefaultValue("EditorStyles.textField")] GUIStyle style);
        [ExcludeFromDocs]
        public static string DelayedTextField(Rect position, string label, string text);
        public static string DelayedTextField(Rect position, string label, string text, [DefaultValue("EditorStyles.textField")] GUIStyle style);
        [ExcludeFromDocs]
        public static string DelayedTextField(Rect position, GUIContent label, string text);
        public static string DelayedTextField(Rect position, GUIContent label, string text, [DefaultValue("EditorStyles.textField")] GUIStyle style);
        [ExcludeFromDocs]
        public static void DelayedTextField(Rect position, SerializedProperty property);
        public static void DelayedTextField(Rect position, SerializedProperty property, [DefaultValue("null")] GUIContent label);
        [ExcludeFromDocs]
        public static string DelayedTextField(Rect position, GUIContent label, int controlId, string text);
        public static string DelayedTextField(Rect position, GUIContent label, int controlId, string text, [DefaultValue("EditorStyles.textField")] GUIStyle style);
        [ExcludeFromDocs]
        public static string TextArea(Rect position, string text);
        public static string TextArea(Rect position, string text, [DefaultValue("EditorStyles.textField")] GUIStyle style);
        [ExcludeFromDocs]
        public static void SelectableLabel(Rect position, string text);
        public static void SelectableLabel(Rect position, string text, [DefaultValue("EditorStyles.label")] GUIStyle style);
        [ExcludeFromDocs]
        public static string PasswordField(Rect position, string password);
        public static string PasswordField(Rect position, string password, [DefaultValue("EditorStyles.textField")] GUIStyle style);
        [ExcludeFromDocs]
        public static string PasswordField(Rect position, string label, string password);
        public static string PasswordField(Rect position, string label, string password, [DefaultValue("EditorStyles.textField")] GUIStyle style);
        [ExcludeFromDocs]
        public static string PasswordField(Rect position, GUIContent label, string password);
        public static string PasswordField(Rect position, GUIContent label, string password, [DefaultValue("EditorStyles.textField")] GUIStyle style);
        [ExcludeFromDocs]
        public static float FloatField(Rect position, float value);
        public static float FloatField(Rect position, float value, [DefaultValue("EditorStyles.numberField")] GUIStyle style);
        [ExcludeFromDocs]
        public static float FloatField(Rect position, string label, float value);
        public static float FloatField(Rect position, string label, float value, [DefaultValue("EditorStyles.numberField")] GUIStyle style);
        [ExcludeFromDocs]
        public static float FloatField(Rect position, GUIContent label, float value);
        public static float FloatField(Rect position, GUIContent label, float value, [DefaultValue("EditorStyles.numberField")] GUIStyle style);
        [ExcludeFromDocs]
        public static float DelayedFloatField(Rect position, float value);
        public static float DelayedFloatField(Rect position, float value, [DefaultValue("EditorStyles.numberField")] GUIStyle style);
        [ExcludeFromDocs]
        public static float DelayedFloatField(Rect position, string label, float value);
        public static float DelayedFloatField(Rect position, string label, float value, [DefaultValue("EditorStyles.numberField")] GUIStyle style);
        [ExcludeFromDocs]
        public static float DelayedFloatField(Rect position, GUIContent label, float value);
        public static float DelayedFloatField(Rect position, GUIContent label, float value, [DefaultValue("EditorStyles.numberField")] GUIStyle style);
        [ExcludeFromDocs]
        public static void DelayedFloatField(Rect position, SerializedProperty property);
        public static void DelayedFloatField(Rect position, SerializedProperty property, [DefaultValue("null")] GUIContent label);
        [ExcludeFromDocs]
        public static double DoubleField(Rect position, double value);
        public static double DoubleField(Rect position, double value, [DefaultValue("EditorStyles.numberField")] GUIStyle style);
        [ExcludeFromDocs]
        public static double DoubleField(Rect position, string label, double value);
        public static double DoubleField(Rect position, string label, double value, [DefaultValue("EditorStyles.numberField")] GUIStyle style);
        [ExcludeFromDocs]
        public static double DoubleField(Rect position, GUIContent label, double value);
        public static double DoubleField(Rect position, GUIContent label, double value, [DefaultValue("EditorStyles.numberField")] GUIStyle style);
        [ExcludeFromDocs]
        public static double DelayedDoubleField(Rect position, double value);
        public static double DelayedDoubleField(Rect position, double value, [DefaultValue("EditorStyles.numberField")] GUIStyle style);
        [ExcludeFromDocs]
        public static double DelayedDoubleField(Rect position, string label, double value);
        public static double DelayedDoubleField(Rect position, string label, double value, [DefaultValue("EditorStyles.numberField")] GUIStyle style);
        [ExcludeFromDocs]
        public static double DelayedDoubleField(Rect position, GUIContent label, double value);
        public static double DelayedDoubleField(Rect position, GUIContent label, double value, [DefaultValue("EditorStyles.numberField")] GUIStyle style);
        [ExcludeFromDocs]
        public static int IntField(Rect position, int value);
        public static int IntField(Rect position, int value, [DefaultValue("EditorStyles.numberField")] GUIStyle style);
        [ExcludeFromDocs]
        public static int IntField(Rect position, string label, int value);
        public static int IntField(Rect position, string label, int value, [DefaultValue("EditorStyles.numberField")] GUIStyle style);
        [ExcludeFromDocs]
        public static int IntField(Rect position, GUIContent label, int value);
        public static int IntField(Rect position, GUIContent label, int value, [DefaultValue("EditorStyles.numberField")] GUIStyle style);
        [ExcludeFromDocs]
        public static int DelayedIntField(Rect position, int value);
        public static int DelayedIntField(Rect position, int value, [DefaultValue("EditorStyles.numberField")] GUIStyle style);
        [ExcludeFromDocs]
        public static int DelayedIntField(Rect position, string label, int value);
        public static int DelayedIntField(Rect position, string label, int value, [DefaultValue("EditorStyles.numberField")] GUIStyle style);
        [ExcludeFromDocs]
        public static int DelayedIntField(Rect position, GUIContent label, int value);
        public static int DelayedIntField(Rect position, GUIContent label, int value, [DefaultValue("EditorStyles.numberField")] GUIStyle style);
        [ExcludeFromDocs]
        public static void DelayedIntField(Rect position, SerializedProperty property);
        public static void DelayedIntField(Rect position, SerializedProperty property, [DefaultValue("null")] GUIContent label);
        [ExcludeFromDocs]
        public static long LongField(Rect position, long value);
        public static long LongField(Rect position, long value, [DefaultValue("EditorStyles.numberField")] GUIStyle style);
        [ExcludeFromDocs]
        public static long LongField(Rect position, string label, long value);
        public static long LongField(Rect position, string label, long value, [DefaultValue("EditorStyles.numberField")] GUIStyle style);
        [ExcludeFromDocs]
        public static long LongField(Rect position, GUIContent label, long value);
        public static long LongField(Rect position, GUIContent label, long value, [DefaultValue("EditorStyles.numberField")] GUIStyle style);
        [ExcludeFromDocs]
        public static int Popup(Rect position, int selectedIndex, string[] displayedOptions);
        public static int Popup(Rect position, int selectedIndex, string[] displayedOptions, [DefaultValue("EditorStyles.popup")] GUIStyle style);
        [ExcludeFromDocs]
        public static int Popup(Rect position, int selectedIndex, GUIContent[] displayedOptions);
        public static int Popup(Rect position, int selectedIndex, GUIContent[] displayedOptions, [DefaultValue("EditorStyles.popup")] GUIStyle style);
        [ExcludeFromDocs]
        public static int Popup(Rect position, string label, int selectedIndex, string[] displayedOptions);
        public static int Popup(Rect position, string label, int selectedIndex, string[] displayedOptions, [DefaultValue("EditorStyles.popup")] GUIStyle style);
        [ExcludeFromDocs]
        public static int Popup(Rect position, GUIContent label, int selectedIndex, GUIContent[] displayedOptions);
        public static int Popup(Rect position, GUIContent label, int selectedIndex, GUIContent[] displayedOptions, [DefaultValue("EditorStyles.popup")] GUIStyle style);
        [ExcludeFromDocs]
        public static Enum EnumPopup(Rect position, Enum selected);
        public static Enum EnumPopup(Rect position, Enum selected, [DefaultValue("EditorStyles.popup")] GUIStyle style);
        [ExcludeFromDocs]
        public static Enum EnumPopup(Rect position, string label, Enum selected);
        public static Enum EnumPopup(Rect position, string label, Enum selected, [DefaultValue("EditorStyles.popup")] GUIStyle style);
        [ExcludeFromDocs]
        public static Enum EnumPopup(Rect position, GUIContent label, Enum selected);
        public static Enum EnumPopup(Rect position, GUIContent label, Enum selected, [DefaultValue("EditorStyles.popup")] GUIStyle style);
        public static Enum EnumPopup(Rect position, GUIContent label, Enum selected, [DefaultValue("null")] Func<Enum, bool> checkEnabled, [DefaultValue("false")] bool includeObsolete = False, [DefaultValue("null")] GUIStyle style = null);
        [ExcludeFromDocs]
        public static int IntPopup(Rect position, int selectedValue, string[] displayedOptions, int[] optionValues);
        public static int IntPopup(Rect position, int selectedValue, string[] displayedOptions, int[] optionValues, [DefaultValue("EditorStyles.popup")] GUIStyle style);
        [ExcludeFromDocs]
        public static int IntPopup(Rect position, int selectedValue, GUIContent[] displayedOptions, int[] optionValues);
        public static int IntPopup(Rect position, int selectedValue, GUIContent[] displayedOptions, int[] optionValues, [DefaultValue("EditorStyles.popup")] GUIStyle style);
        [ExcludeFromDocs]
        public static int IntPopup(Rect position, GUIContent label, int selectedValue, GUIContent[] displayedOptions, int[] optionValues);
        public static int IntPopup(Rect position, GUIContent label, int selectedValue, GUIContent[] displayedOptions, int[] optionValues, [DefaultValue("EditorStyles.popup")] GUIStyle style);
        [ExcludeFromDocs]
        public static void IntPopup(Rect position, SerializedProperty property, GUIContent[] displayedOptions, int[] optionValues);
        public static void IntPopup(Rect position, SerializedProperty property, GUIContent[] displayedOptions, int[] optionValues, [DefaultValue("null")] GUIContent label);
        [ExcludeFromDocs]
        public static int IntPopup(Rect position, string label, int selectedValue, string[] displayedOptions, int[] optionValues);
        public static int IntPopup(Rect position, string label, int selectedValue, string[] displayedOptions, int[] optionValues, [DefaultValue("EditorStyles.popup")] GUIStyle style);
        [ExcludeFromDocs]
        public static string TagField(Rect position, string tag);
        public static string TagField(Rect position, string tag, [DefaultValue("EditorStyles.popup")] GUIStyle style);
        [ExcludeFromDocs]
        public static string TagField(Rect position, string label, string tag);
        public static string TagField(Rect position, string label, string tag, [DefaultValue("EditorStyles.popup")] GUIStyle style);
        [ExcludeFromDocs]
        public static string TagField(Rect position, GUIContent label, string tag);
        public static string TagField(Rect position, GUIContent label, string tag, [DefaultValue("EditorStyles.popup")] GUIStyle style);
        [ExcludeFromDocs]
        public static int LayerField(Rect position, int layer);
        public static int LayerField(Rect position, int layer, [DefaultValue("EditorStyles.popup")] GUIStyle style);
        [ExcludeFromDocs]
        public static int LayerField(Rect position, string label, int layer);
        public static int LayerField(Rect position, string label, int layer, [DefaultValue("EditorStyles.popup")] GUIStyle style);
        [ExcludeFromDocs]
        public static int LayerField(Rect position, GUIContent label, int layer);
        public static int LayerField(Rect position, GUIContent label, int layer, [DefaultValue("EditorStyles.popup")] GUIStyle style);
        [ExcludeFromDocs]
        public static int MaskField(Rect position, GUIContent label, int mask, string[] displayedOptions);
        public static int MaskField(Rect position, GUIContent label, int mask, string[] displayedOptions, [DefaultValue("EditorStyles.popup")] GUIStyle style);
        [ExcludeFromDocs]
        public static int MaskField(Rect position, string label, int mask, string[] displayedOptions);
        public static int MaskField(Rect position, string label, int mask, string[] displayedOptions, [DefaultValue("EditorStyles.popup")] GUIStyle style);
        [ExcludeFromDocs]
        public static int MaskField(Rect position, int mask, string[] displayedOptions);
        public static int MaskField(Rect position, int mask, string[] displayedOptions, [DefaultValue("EditorStyles.popup")] GUIStyle style);
        [ExcludeFromDocs]
        public static bool Foldout(Rect position, bool foldout, string content);
        public static bool Foldout(Rect position, bool foldout, string content, [DefaultValue("EditorStyles.foldout")] GUIStyle style);
        [ExcludeFromDocs]
        public static bool Foldout(Rect position, bool foldout, string content, bool toggleOnLabelClick);
        public static bool Foldout(Rect position, bool foldout, string content, bool toggleOnLabelClick, [DefaultValue("EditorStyles.foldout")] GUIStyle style);
        [ExcludeFromDocs]
        public static bool Foldout(Rect position, bool foldout, GUIContent content);
        public static bool Foldout(Rect position, bool foldout, GUIContent content, [DefaultValue("EditorStyles.foldout")] GUIStyle style);
        [ExcludeFromDocs]
        public static bool Foldout(Rect position, bool foldout, GUIContent content, bool toggleOnLabelClick);
        public static bool Foldout(Rect position, bool foldout, GUIContent content, bool toggleOnLabelClick, [DefaultValue("EditorStyles.foldout")] GUIStyle style);
        [ExcludeFromDocs]
        public static void HandlePrefixLabel(Rect totalPosition, Rect labelPosition, GUIContent label, int id);
        [ExcludeFromDocs]
        public static void HandlePrefixLabel(Rect totalPosition, Rect labelPosition, GUIContent label);
        public static void HandlePrefixLabel(Rect totalPosition, Rect labelPosition, GUIContent label, [DefaultValue("0")] int id, [DefaultValue("EditorStyles.label")] GUIStyle style);
        public static float GetPropertyHeight(SerializedProperty property, bool includeChildren);
        [ExcludeFromDocs]
        public static float GetPropertyHeight(SerializedProperty property, GUIContent label);
        [ExcludeFromDocs]
        public static float GetPropertyHeight(SerializedProperty property);
        public static float GetPropertyHeight(SerializedProperty property, [DefaultValue("null")] GUIContent label, [DefaultValue("true")] bool includeChildren);
        [ExcludeFromDocs]
        public static bool PropertyField(Rect position, SerializedProperty property);
        public static bool PropertyField(Rect position, SerializedProperty property, [DefaultValue("false")] bool includeChildren);
        [ExcludeFromDocs]
        public static bool PropertyField(Rect position, SerializedProperty property, GUIContent label);
        public static bool PropertyField(Rect position, SerializedProperty property, GUIContent label, [DefaultValue("false")] bool includeChildren);
        [Obsolete("EnumMaskField has been deprecated. Use EnumFlagsField instead.")]
        public static Enum EnumMaskField(Rect position, Enum enumValue);
        [Obsolete("EnumMaskField has been deprecated. Use EnumFlagsField instead.")]
        public static Enum EnumMaskField(Rect position, Enum enumValue, GUIStyle style);
        [Obsolete("EnumMaskField has been deprecated. Use EnumFlagsField instead.")]
        public static Enum EnumMaskField(Rect position, string label, Enum enumValue);
        [Obsolete("EnumMaskField has been deprecated. Use EnumFlagsField instead.")]
        public static Enum EnumMaskField(Rect position, string label, Enum enumValue, GUIStyle style);
        [Obsolete("EnumMaskField has been deprecated. Use EnumFlagsField instead.")]
        public static Enum EnumMaskField(Rect position, GUIContent label, Enum enumValue);
        [Obsolete("EnumMaskField has been deprecated. Use EnumFlagsField instead.")]
        public static Enum EnumMaskField(Rect position, GUIContent label, Enum enumValue, GUIStyle style);
        [Obsolete("EnumMaskPopup has been deprecated. Use EnumFlagsField instead.")]
        public static Enum EnumMaskPopup(Rect position, string label, Enum selected);
        [Obsolete("EnumMaskPopup has been deprecated. Use EnumFlagsField instead.")]
        public static Enum EnumMaskPopup(Rect position, string label, Enum selected, GUIStyle style);
        [Obsolete("EnumMaskPopup has been deprecated. Use EnumFlagsField instead.")]
        public static Enum EnumMaskPopup(Rect position, GUIContent label, Enum selected);
        [Obsolete("EnumMaskPopup has been deprecated. Use EnumFlagsField instead.")]
        public static Enum EnumMaskPopup(Rect position, GUIContent label, Enum selected, GUIStyle style);
        public static bool BeginFoldoutHeaderGroup(Rect position, bool foldout, string content, [DefaultValue("EditorStyles.foldoutHeader")] GUIStyle style = null, Action<Rect> menuAction = null, GUIStyle menuIcon = null);
        public static bool BeginFoldoutHeaderGroup(Rect position, bool foldout, GUIContent content, [DefaultValue("EditorStyles.foldoutHeader")] GUIStyle style = null, Action<Rect> menuAction = null, GUIStyle menuIcon = null);
        public static void EndFoldoutHeaderGroup();
        public static Gradient GradientField(Rect position, Gradient gradient);
        public static Gradient GradientField(Rect position, string label, Gradient gradient);
        public static Gradient GradientField(Rect position, GUIContent label, Gradient gradient);
        public static Gradient GradientField(Rect position, GUIContent label, Gradient gradient, bool hdr);
        public static Gradient GradientField(Rect position, GUIContent label, Gradient gradient, bool hdr, ColorSpace colorSpace);
        public static void DrawRect(Rect rect, Color color);

        public class DisabledGroupScope : GUI.Scope
        {
            public DisabledGroupScope(bool disabled);

            protected override void CloseScope();
        }
        public struct DisabledScope : IDisposable
        {
            public DisabledScope(bool disabled);

            public void Dispose();
        }
        public class ChangeCheckScope : GUI.Scope
        {
            public ChangeCheckScope();

            public bool changed { get; }

            protected override void CloseScope();
        }
        public class IndentLevelScope : GUI.Scope
        {
            public IndentLevelScope();
            public IndentLevelScope(int increment);

            protected override void CloseScope();
        }
        public class PropertyScope : GUI.Scope
        {
            public PropertyScope(Rect totalPosition, GUIContent label, SerializedProperty property);

            public GUIContent content { get; protected set; }

            protected override void CloseScope();
        }
    }
}
using System;
using System.Collections.Generic;
using UnityEditor.EditorTools;
using UnityEngine;
using UnityEngine.Internal;

namespace UnityEditor
{
    public sealed class EditorGUILayout
    {
        public EditorGUILayout();

        [ExcludeFromDocs]
        public static bool Foldout(bool foldout, string content);
        public static bool Foldout(bool foldout, string content, [DefaultValue("EditorStyles.foldout")] GUIStyle style);
        [ExcludeFromDocs]
        public static bool Foldout(bool foldout, GUIContent content);
        public static bool Foldout(bool foldout, GUIContent content, [DefaultValue("EditorStyles.foldout")] GUIStyle style);
        [ExcludeFromDocs]
        public static bool Foldout(bool foldout, string content, bool toggleOnLabelClick);
        public static bool Foldout(bool foldout, string content, bool toggleOnLabelClick, [DefaultValue("EditorStyles.foldout")] GUIStyle style);
        [ExcludeFromDocs]
        public static bool Foldout(bool foldout, GUIContent content, bool toggleOnLabelClick);
        public static bool Foldout(bool foldout, GUIContent content, bool toggleOnLabelClick, [DefaultValue("EditorStyles.foldout")] GUIStyle style);
        [ExcludeFromDocs]
        public static void PrefixLabel(string label);
        public static void PrefixLabel(string label, [DefaultValue("\"Button\"")] GUIStyle followingStyle);
        public static void PrefixLabel(string label, GUIStyle followingStyle, GUIStyle labelStyle);
        [ExcludeFromDocs]
        public static void PrefixLabel(GUIContent label);
        public static void PrefixLabel(GUIContent label, [DefaultValue("\"Button\"")] GUIStyle followingStyle);
        public static void PrefixLabel(GUIContent label, GUIStyle followingStyle, GUIStyle labelStyle);
        public static void LabelField(string label, params GUILayoutOption[] options);
        public static void LabelField(string label, GUIStyle style, params GUILayoutOption[] options);
        public static void LabelField(GUIContent label, params GUILayoutOption[] options);
        public static void LabelField(GUIContent label, GUIStyle style, params GUILayoutOption[] options);
        public static void LabelField(string label, string label2, params GUILayoutOption[] options);
        public static void LabelField(string label, string label2, GUIStyle style, params GUILayoutOption[] options);
        public static void LabelField(GUIContent label, GUIContent label2, params GUILayoutOption[] options);
        public static void LabelField(GUIContent label, GUIContent label2, GUIStyle style, params GUILayoutOption[] options);
        public static bool Toggle(bool value, params GUILayoutOption[] options);
        public static bool Toggle(string label, bool value, params GUILayoutOption[] options);
        public static bool Toggle(GUIContent label, bool value, params GUILayoutOption[] options);
        public static bool Toggle(bool value, GUIStyle style, params GUILayoutOption[] options);
        public static bool Toggle(string label, bool value, GUIStyle style, params GUILayoutOption[] options);
        public static bool Toggle(GUIContent label, bool value, GUIStyle style, params GUILayoutOption[] options);
        public static bool ToggleLeft(string label, bool value, params GUILayoutOption[] options);
        public static bool ToggleLeft(GUIContent label, bool value, params GUILayoutOption[] options);
        public static bool ToggleLeft(string label, bool value, GUIStyle labelStyle, params GUILayoutOption[] options);
        public static bool ToggleLeft(GUIContent label, bool value, GUIStyle labelStyle, params GUILayoutOption[] options);
        public static string TextField(string text, params GUILayoutOption[] options);
        public static string TextField(string text, GUIStyle style, params GUILayoutOption[] options);
        public static string TextField(string label, string text, params GUILayoutOption[] options);
        public static string TextField(string label, string text, GUIStyle style, params GUILayoutOption[] options);
        public static string TextField(GUIContent label, string text, params GUILayoutOption[] options);
        public static string TextField(GUIContent label, string text, GUIStyle style, params GUILayoutOption[] options);
        public static string DelayedTextField(string text, params GUILayoutOption[] options);
        public static string DelayedTextField(string text, GUIStyle style, params GUILayoutOption[] options);
        public static string DelayedTextField(string label, string text, params GUILayoutOption[] options);
        public static string DelayedTextField(string label, string text, GUIStyle style, params GUILayoutOption[] options);
        public static string DelayedTextField(GUIContent label, string text, params GUILayoutOption[] options);
        public static string DelayedTextField(GUIContent label, string text, GUIStyle style, params GUILayoutOption[] options);
        public static void DelayedTextField(SerializedProperty property, params GUILayoutOption[] options);
        public static void DelayedTextField(SerializedProperty property, GUIContent label, params GUILayoutOption[] options);
        public static string TextArea(string text, params GUILayoutOption[] options);
        public static string TextArea(string text, GUIStyle style, params GUILayoutOption[] options);
        public static void SelectableLabel(string text, params GUILayoutOption[] options);
        public static void SelectableLabel(string text, GUIStyle style, params GUILayoutOption[] options);
        public static string PasswordField(string password, params GUILayoutOption[] options);
        public static string PasswordField(string password, GUIStyle style, params GUILayoutOption[] options);
        public static string PasswordField(string label, string password, params GUILayoutOption[] options);
        public static string PasswordField(string label, string password, GUIStyle style, params GUILayoutOption[] options);
        public static string PasswordField(GUIContent label, string password, params GUILayoutOption[] options);
        public static string PasswordField(GUIContent label, string password, GUIStyle style, params GUILayoutOption[] options);
        public static float FloatField(float value, params GUILayoutOption[] options);
        public static float FloatField(float value, GUIStyle style, params GUILayoutOption[] options);
        public static float FloatField(string label, float value, params GUILayoutOption[] options);
        public static float FloatField(string label, float value, GUIStyle style, params GUILayoutOption[] options);
        public static float FloatField(GUIContent label, float value, params GUILayoutOption[] options);
        public static float FloatField(GUIContent label, float value, GUIStyle style, params GUILayoutOption[] options);
        public static float DelayedFloatField(float value, params GUILayoutOption[] options);
        public static float DelayedFloatField(float value, GUIStyle style, params GUILayoutOption[] options);
        public static float DelayedFloatField(string label, float value, params GUILayoutOption[] options);
        public static float DelayedFloatField(string label, float value, GUIStyle style, params GUILayoutOption[] options);
        public static float DelayedFloatField(GUIContent label, float value, params GUILayoutOption[] options);
        public static float DelayedFloatField(GUIContent label, float value, GUIStyle style, params GUILayoutOption[] options);
        public static void DelayedFloatField(SerializedProperty property, params GUILayoutOption[] options);
        public static void DelayedFloatField(SerializedProperty property, GUIContent label, params GUILayoutOption[] options);
        public static double DoubleField(double value, params GUILayoutOption[] options);
        public static double DoubleField(double value, GUIStyle style, params GUILayoutOption[] options);
        public static double DoubleField(string label, double value, params GUILayoutOption[] options);
        public static double DoubleField(string label, double value, GUIStyle style, params GUILayoutOption[] options);
        public static double DoubleField(GUIContent label, double value, params GUILayoutOption[] options);
        public static double DoubleField(GUIContent label, double value, GUIStyle style, params GUILayoutOption[] options);
        public static double DelayedDoubleField(double value, params GUILayoutOption[] options);
        public static double DelayedDoubleField(double value, GUIStyle style, params GUILayoutOption[] options);
        public static double DelayedDoubleField(string label, double value, params GUILayoutOption[] options);
        public static double DelayedDoubleField(string label, double value, GUIStyle style, params GUILayoutOption[] options);
        public static double DelayedDoubleField(GUIContent label, double value, params GUILayoutOption[] options);
        public static double DelayedDoubleField(GUIContent label, double value, GUIStyle style, params GUILayoutOption[] options);
        public static int IntField(int value, params GUILayoutOption[] options);
        public static int IntField(int value, GUIStyle style, params GUILayoutOption[] options);
        public static int IntField(string label, int value, params GUILayoutOption[] options);
        public static int IntField(string label, int value, GUIStyle style, params GUILayoutOption[] options);
        public static int IntField(GUIContent label, int value, params GUILayoutOption[] options);
        public static int IntField(GUIContent label, int value, GUIStyle style, params GUILayoutOption[] options);
        public static int DelayedIntField(int value, params GUILayoutOption[] options);
        public static int DelayedIntField(int value, GUIStyle style, params GUILayoutOption[] options);
        public static int DelayedIntField(string label, int value, params GUILayoutOption[] options);
        public static int DelayedIntField(string label, int value, GUIStyle style, params GUILayoutOption[] options);
        public static int DelayedIntField(GUIContent label, int value, params GUILayoutOption[] options);
        public static int DelayedIntField(GUIContent label, int value, GUIStyle style, params GUILayoutOption[] options);
        public static void DelayedIntField(SerializedProperty property, params GUILayoutOption[] options);
        public static void DelayedIntField(SerializedProperty property, GUIContent label, params GUILayoutOption[] options);
        public static long LongField(long value, params GUILayoutOption[] options);
        public static long LongField(long value, GUIStyle style, params GUILayoutOption[] options);
        public static long LongField(string label, long value, params GUILayoutOption[] options);
        public static long LongField(string label, long value, GUIStyle style, params GUILayoutOption[] options);
        public static long LongField(GUIContent label, long value, params GUILayoutOption[] options);
        public static long LongField(GUIContent label, long value, GUIStyle style, params GUILayoutOption[] options);
        public static float Slider(float value, float leftValue, float rightValue, params GUILayoutOption[] options);
        public static float Slider(string label, float value, float leftValue, float rightValue, params GUILayoutOption[] options);
        public static float Slider(GUIContent label, float value, float leftValue, float rightValue, params GUILayoutOption[] options);
        public static void Slider(SerializedProperty property, float leftValue, float rightValue, params GUILayoutOption[] options);
        public static void Slider(SerializedProperty property, float leftValue, float rightValue, string label, params GUILayoutOption[] options);
        public static void Slider(SerializedProperty property, float leftValue, float rightValue, GUIContent label, params GUILayoutOption[] options);
        public static int IntSlider(int value, int leftValue, int rightValue, params GUILayoutOption[] options);
        public static int IntSlider(string label, int value, int leftValue, int rightValue, params GUILayoutOption[] options);
        public static int IntSlider(GUIContent label, int value, int leftValue, int rightValue, params GUILayoutOption[] options);
        public static void IntSlider(SerializedProperty property, int leftValue, int rightValue, params GUILayoutOption[] options);
        public static void IntSlider(SerializedProperty property, int leftValue, int rightValue, string label, params GUILayoutOption[] options);
        public static void IntSlider(SerializedProperty property, int leftValue, int rightValue, GUIContent label, params GUILayoutOption[] options);
        public static void MinMaxSlider(ref float minValue, ref float maxValue, float minLimit, float maxLimit, params GUILayoutOption[] options);
        public static void MinMaxSlider(string label, ref float minValue, ref float maxValue, float minLimit, float maxLimit, params GUILayoutOption[] options);
        public static void MinMaxSlider(GUIContent label, ref float minValue, ref float maxValue, float minLimit, float maxLimit, params GUILayoutOption[] options);
        public static int Popup(int selectedIndex, string[] displayedOptions, params GUILayoutOption[] options);
        public static int Popup(int selectedIndex, string[] displayedOptions, GUIStyle style, params GUILayoutOption[] options);
        public static int Popup(int selectedIndex, GUIContent[] displayedOptions, params GUILayoutOption[] options);
        public static int Popup(int selectedIndex, GUIContent[] displayedOptions, GUIStyle style, params GUILayoutOption[] options);
        public static int Popup(string label, int selectedIndex, string[] displayedOptions, params GUILayoutOption[] options);
        public static int Popup(GUIContent label, int selectedIndex, string[] displayedOptions, params GUILayoutOption[] options);
        public static int Popup(string label, int selectedIndex, string[] displayedOptions, GUIStyle style, params GUILayoutOption[] options);
        public static int Popup(GUIContent label, int selectedIndex, GUIContent[] displayedOptions, params GUILayoutOption[] options);
        public static int Popup(GUIContent label, int selectedIndex, GUIContent[] displayedOptions, GUIStyle style, params GUILayoutOption[] options);
        public static Enum EnumPopup(Enum selected, params GUILayoutOption[] options);
        public static Enum EnumPopup(Enum selected, GUIStyle style, params GUILayoutOption[] options);
        public static Enum EnumPopup(string label, Enum selected, params GUILayoutOption[] options);
        public static Enum EnumPopup(string label, Enum selected, GUIStyle style, params GUILayoutOption[] options);
        public static Enum EnumPopup(GUIContent label, Enum selected, params GUILayoutOption[] options);
        public static Enum EnumPopup(GUIContent label, Enum selected, GUIStyle style, params GUILayoutOption[] options);
        public static Enum EnumPopup(GUIContent label, Enum selected, Func<Enum, bool> checkEnabled, bool includeObsolete, params GUILayoutOption[] options);
        public static Enum EnumPopup(GUIContent label, Enum selected, Func<Enum, bool> checkEnabled, bool includeObsolete, GUIStyle style, params GUILayoutOption[] options);
        public static int IntPopup(int selectedValue, string[] displayedOptions, int[] optionValues, params GUILayoutOption[] options);
        public static int IntPopup(int selectedValue, string[] displayedOptions, int[] optionValues, GUIStyle style, params GUILayoutOption[] options);
        public static int IntPopup(int selectedValue, GUIContent[] displayedOptions, int[] optionValues, params GUILayoutOption[] options);
        public static int IntPopup(int selectedValue, GUIContent[] displayedOptions, int[] optionValues, GUIStyle style, params GUILayoutOption[] options);
        public static int IntPopup(string label, int selectedValue, string[] displayedOptions, int[] optionValues, params GUILayoutOption[] options);
        public static int IntPopup(string label, int selectedValue, string[] displayedOptions, int[] optionValues, GUIStyle style, params GUILayoutOption[] options);
        public static int IntPopup(GUIContent label, int selectedValue, GUIContent[] displayedOptions, int[] optionValues, params GUILayoutOption[] options);
        public static int IntPopup(GUIContent label, int selectedValue, GUIContent[] displayedOptions, int[] optionValues, GUIStyle style, params GUILayoutOption[] options);
        public static void IntPopup(SerializedProperty property, GUIContent[] displayedOptions, int[] optionValues, params GUILayoutOption[] options);
        public static void IntPopup(SerializedProperty property, GUIContent[] displayedOptions, int[] optionValues, GUIContent label, params GUILayoutOption[] options);
        [Obsolete("This function is obsolete and the style is not used.")]
        public static void IntPopup(SerializedProperty property, GUIContent[] displayedOptions, int[] optionValues, GUIContent label, GUIStyle style, params GUILayoutOption[] options);
        public static string TagField(string tag, params GUILayoutOption[] options);
        public static string TagField(string tag, GUIStyle style, params GUILayoutOption[] options);
        public static string TagField(string label, string tag, params GUILayoutOption[] options);
        public static string TagField(string label, string tag, GUIStyle style, params GUILayoutOption[] options);
        public static string TagField(GUIContent label, string tag, params GUILayoutOption[] options);
        public static string TagField(GUIContent label, string tag, GUIStyle style, params GUILayoutOption[] options);
        public static int LayerField(int layer, params GUILayoutOption[] options);
        public static int LayerField(int layer, GUIStyle style, params GUILayoutOption[] options);
        public static int LayerField(string label, int layer, params GUILayoutOption[] options);
        public static int LayerField(string label, int layer, GUIStyle style, params GUILayoutOption[] options);
        public static int LayerField(GUIContent label, int layer, params GUILayoutOption[] options);
        public static int LayerField(GUIContent label, int layer, GUIStyle style, params GUILayoutOption[] options);
        public static int MaskField(GUIContent label, int mask, string[] displayedOptions, GUIStyle style, params GUILayoutOption[] options);
        public static int MaskField(string label, int mask, string[] displayedOptions, GUIStyle style, params GUILayoutOption[] options);
        public static int MaskField(GUIContent label, int mask, string[] displayedOptions, params GUILayoutOption[] options);
        public static int MaskField(string label, int mask, string[] displayedOptions, params GUILayoutOption[] options);
        public static int MaskField(int mask, string[] displayedOptions, GUIStyle style, params GUILayoutOption[] options);
        public static int MaskField(int mask, string[] displayedOptions, params GUILayoutOption[] options);
        public static Enum EnumFlagsField(Enum enumValue, params GUILayoutOption[] options);
        public static Enum EnumFlagsField(Enum enumValue, GUIStyle style, params GUILayoutOption[] options);
        public static Enum EnumFlagsField(string label, Enum enumValue, params GUILayoutOption[] options);
        public static Enum EnumFlagsField(string label, Enum enumValue, GUIStyle style, params GUILayoutOption[] options);
        public static Enum EnumFlagsField(GUIContent label, Enum enumValue, params GUILayoutOption[] options);
        public static Enum EnumFlagsField(GUIContent label, Enum enumValue, GUIStyle style, params GUILayoutOption[] options);
        public static Enum EnumFlagsField(GUIContent label, Enum enumValue, bool includeObsolete, params GUILayoutOption[] options);
        public static Enum EnumFlagsField(GUIContent label, Enum enumValue, bool includeObsolete, GUIStyle style, params GUILayoutOption[] options);
        [Obsolete("Check the docs for the usage of the new parameter 'allowSceneObjects'.")]
        public static UnityEngine.Object ObjectField(UnityEngine.Object obj, Type objType, params GUILayoutOption[] options);
        public static UnityEngine.Object ObjectField(UnityEngine.Object obj, Type objType, UnityEngine.Object targetBeingEdited, params GUILayoutOption[] options);
        public static UnityEngine.Object ObjectField(UnityEngine.Object obj, Type objType, bool allowSceneObjects, params GUILayoutOption[] options);
        [Obsolete("Check the docs for the usage of the new parameter 'allowSceneObjects'.")]
        public static UnityEngine.Object ObjectField(string label, UnityEngine.Object obj, Type objType, params GUILayoutOption[] options);
        public static UnityEngine.Object ObjectField(string label, UnityEngine.Object obj, Type objType, UnityEngine.Object targetBeingEdited, params GUILayoutOption[] options);
        public static UnityEngine.Object ObjectField(string label, UnityEngine.Object obj, Type objType, bool allowSceneObjects, params GUILayoutOption[] options);
        [Obsolete("Check the docs for the usage of the new parameter 'allowSceneObjects'.")]
        public static UnityEngine.Object ObjectField(GUIContent label, UnityEngine.Object obj, Type objType, params GUILayoutOption[] options);
        public static UnityEngine.Object ObjectField(GUIContent label, UnityEngine.Object obj, Type objType, UnityEngine.Object targetBeingEdited, params GUILayoutOption[] options);
        public static UnityEngine.Object ObjectField(GUIContent label, UnityEngine.Object obj, Type objType, bool allowSceneObjects, params GUILayoutOption[] options);
        public static void ObjectField(SerializedProperty property, params GUILayoutOption[] options);
        public static void ObjectField(SerializedProperty property, GUIContent label, params GUILayoutOption[] options);
        public static void ObjectField(SerializedProperty property, Type objType, params GUILayoutOption[] options);
        public static void ObjectField(SerializedProperty property, Type objType, GUIContent label, params GUILayoutOption[] options);
        public static Vector2 Vector2Field(string label, Vector2 value, params GUILayoutOption[] options);
        public static Vector2 Vector2Field(GUIContent label, Vector2 value, params GUILayoutOption[] options);
        public static Vector3 Vector3Field(string label, Vector3 value, params GUILayoutOption[] options);
        public static Vector3 Vector3Field(GUIContent label, Vector3 value, params GUILayoutOption[] options);
        public static Vector4 Vector4Field(string label, Vector4 value, params GUILayoutOption[] options);
        public static Vector4 Vector4Field(GUIContent label, Vector4 value, params GUILayoutOption[] options);
        public static Vector2Int Vector2IntField(string label, Vector2Int value, params GUILayoutOption[] options);
        public static Vector2Int Vector2IntField(GUIContent label, Vector2Int value, params GUILayoutOption[] options);
        public static Vector3Int Vector3IntField(string label, Vector3Int value, params GUILayoutOption[] options);
        public static Vector3Int Vector3IntField(GUIContent label, Vector3Int value, params GUILayoutOption[] options);
        public static Rect RectField(Rect value, params GUILayoutOption[] options);
        public static Rect RectField(string label, Rect value, params GUILayoutOption[] options);
        public static Rect RectField(GUIContent label, Rect value, params GUILayoutOption[] options);
        public static RectInt RectIntField(RectInt value, params GUILayoutOption[] options);
        public static RectInt RectIntField(string label, RectInt value, params GUILayoutOption[] options);
        public static RectInt RectIntField(GUIContent label, RectInt value, params GUILayoutOption[] options);
        public static Bounds BoundsField(Bounds value, params GUILayoutOption[] options);
        public static Bounds BoundsField(string label, Bounds value, params GUILayoutOption[] options);
        public static Bounds BoundsField(GUIContent label, Bounds value, params GUILayoutOption[] options);
        public static BoundsInt BoundsIntField(BoundsInt value, params GUILayoutOption[] options);
        public static BoundsInt BoundsIntField(string label, BoundsInt value, params GUILayoutOption[] options);
        public static BoundsInt BoundsIntField(GUIContent label, BoundsInt value, params GUILayoutOption[] options);
        public static Color ColorField(Color value, params GUILayoutOption[] options);
        public static Color ColorField(string label, Color value, params GUILayoutOption[] options);
        public static Color ColorField(GUIContent label, Color value, params GUILayoutOption[] options);
        [Obsolete("Use EditorGUILayout.ColorField(GUIContent label, Color value, bool showEyedropper, bool showAlpha, bool hdr, params GUILayoutOption[] options)")]
        public static Color ColorField(GUIContent label, Color value, bool showEyedropper, bool showAlpha, bool hdr, ColorPickerHDRConfig hdrConfig, params GUILayoutOption[] options);
        public static Color ColorField(GUIContent label, Color value, bool showEyedropper, bool showAlpha, bool hdr, params GUILayoutOption[] options);
        public static AnimationCurve CurveField(AnimationCurve value, params GUILayoutOption[] options);
        public static AnimationCurve CurveField(string label, AnimationCurve value, params GUILayoutOption[] options);
        public static AnimationCurve CurveField(GUIContent label, AnimationCurve value, params GUILayoutOption[] options);
        public static AnimationCurve CurveField(AnimationCurve value, Color color, Rect ranges, params GUILayoutOption[] options);
        public static AnimationCurve CurveField(string label, AnimationCurve value, Color color, Rect ranges, params GUILayoutOption[] options);
        public static AnimationCurve CurveField(GUIContent label, AnimationCurve value, Color color, Rect ranges, params GUILayoutOption[] options);
        public static void CurveField(SerializedProperty property, Color color, Rect ranges, params GUILayoutOption[] options);
        public static void CurveField(SerializedProperty property, Color color, Rect ranges, GUIContent label, params GUILayoutOption[] options);
        public static bool InspectorTitlebar(bool foldout, UnityEngine.Object targetObj);
        public static bool InspectorTitlebar(bool foldout, UnityEngine.Object targetObj, bool expandable);
        public static bool InspectorTitlebar(bool foldout, UnityEngine.Object[] targetObjs);
        public static bool InspectorTitlebar(bool foldout, UnityEngine.Object[] targetObjs, bool expandable);
        public static bool InspectorTitlebar(bool foldout, Editor editor);
        public static void InspectorTitlebar(UnityEngine.Object[] targetObjs);
        public static void HelpBox(string message, MessageType type);
        public static void HelpBox(string message, MessageType type, bool wide);
        public static void HelpBox(GUIContent content, bool wide = True);
        public static void Space();
        public static void Space(float width);
        public static void Space(float width, bool expand);
        public static void Separator();
        public static bool BeginToggleGroup(string label, bool toggle);
        public static bool BeginToggleGroup(GUIContent label, bool toggle);
        public static void EndToggleGroup();
        public static Rect BeginHorizontal(params GUILayoutOption[] options);
        public static Rect BeginHorizontal(GUIStyle style, params GUILayoutOption[] options);
        public static void EndHorizontal();
        public static Rect BeginVertical(params GUILayoutOption[] options);
        public static Rect BeginVertical(GUIStyle style, params GUILayoutOption[] options);
        public static void EndVertical();
        public static Vector2 BeginScrollView(Vector2 scrollPosition, params GUILayoutOption[] options);
        public static Vector2 BeginScrollView(Vector2 scrollPosition, bool alwaysShowHorizontal, bool alwaysShowVertical, params GUILayoutOption[] options);
        public static Vector2 BeginScrollView(Vector2 scrollPosition, GUIStyle horizontalScrollbar, GUIStyle verticalScrollbar, params GUILayoutOption[] options);
        public static Vector2 BeginScrollView(Vector2 scrollPosition, GUIStyle style, params GUILayoutOption[] options);
        public static Vector2 BeginScrollView(Vector2 scrollPosition, bool alwaysShowHorizontal, bool alwaysShowVertical, GUIStyle horizontalScrollbar, GUIStyle verticalScrollbar, GUIStyle background, params GUILayoutOption[] options);
        public static void EndScrollView();
        public static bool PropertyField(SerializedProperty property, params GUILayoutOption[] options);
        public static bool PropertyField(SerializedProperty property, GUIContent label, params GUILayoutOption[] options);
        public static bool PropertyField(SerializedProperty property, bool includeChildren, params GUILayoutOption[] options);
        public static bool PropertyField(SerializedProperty property, GUIContent label, bool includeChildren, params GUILayoutOption[] options);
        public static Rect GetControlRect(params GUILayoutOption[] options);
        public static Rect GetControlRect(bool hasLabel, params GUILayoutOption[] options);
        public static Rect GetControlRect(bool hasLabel, float height, params GUILayoutOption[] options);
        public static Rect GetControlRect(bool hasLabel, float height, GUIStyle style, params GUILayoutOption[] options);
        public static bool BeginFadeGroup(float value);
        public static void EndFadeGroup();
        public static BuildTargetGroup BeginBuildTargetSelectionGrouping();
        public static void EndBuildTargetSelectionGrouping();
        public static bool DropdownButton(GUIContent content, FocusType focusType, params GUILayoutOption[] options);
        public static bool DropdownButton(GUIContent content, FocusType focusType, GUIStyle style, params GUILayoutOption[] options);
        [Obsolete("EnumMaskField has been deprecated. Use EnumFlagsField instead.")]
        public static Enum EnumMaskField(Enum enumValue, params GUILayoutOption[] options);
        [Obsolete("EnumMaskField has been deprecated. Use EnumFlagsField instead.")]
        public static Enum EnumMaskField(Enum enumValue, GUIStyle style, params GUILayoutOption[] options);
        [Obsolete("EnumMaskField has been deprecated. Use EnumFlagsField instead.")]
        public static Enum EnumMaskField(string label, Enum enumValue, params GUILayoutOption[] options);
        [Obsolete("EnumMaskField has been deprecated. Use EnumFlagsField instead.")]
        public static Enum EnumMaskField(string label, Enum enumValue, GUIStyle style, params GUILayoutOption[] options);
        [Obsolete("EnumMaskField has been deprecated. Use EnumFlagsField instead.")]
        public static Enum EnumMaskField(GUIContent label, Enum enumValue, params GUILayoutOption[] options);
        [Obsolete("EnumMaskField has been deprecated. Use EnumFlagsField instead.")]
        public static Enum EnumMaskField(GUIContent label, Enum enumValue, GUIStyle style, params GUILayoutOption[] options);
        [Obsolete("EnumMaskPopup has been deprecated. Use EnumFlagsField instead.")]
        public static Enum EnumMaskPopup(string label, Enum selected, params GUILayoutOption[] options);
        [Obsolete("EnumMaskPopup has been deprecated. Use EnumFlagsField instead.")]
        public static Enum EnumMaskPopup(string label, Enum selected, GUIStyle style, params GUILayoutOption[] options);
        [Obsolete("EnumMaskPopup has been deprecated. Use EnumFlagsField instead.")]
        public static Enum EnumMaskPopup(GUIContent label, Enum selected, params GUILayoutOption[] options);
        [Obsolete("EnumMaskPopup has been deprecated. Use EnumFlagsField instead.")]
        public static Enum EnumMaskPopup(GUIContent label, Enum selected, GUIStyle style, params GUILayoutOption[] options);
        public static bool BeginFoldoutHeaderGroup(bool foldout, string content, [DefaultValue("EditorStyles.foldoutHeader")] GUIStyle style = null, Action<Rect> menuAction = null, GUIStyle menuIcon = null);
        public static bool BeginFoldoutHeaderGroup(bool foldout, GUIContent content, [DefaultValue("EditorStyles.foldoutHeader")] GUIStyle style = null, Action<Rect> menuAction = null, GUIStyle menuIcon = null);
        public static void EndFoldoutHeaderGroup();
        public static Gradient GradientField(Gradient value, params GUILayoutOption[] options);
        public static Gradient GradientField(string label, Gradient value, params GUILayoutOption[] options);
        public static Gradient GradientField(GUIContent label, Gradient value, params GUILayoutOption[] options);
        public static Gradient GradientField(GUIContent label, Gradient value, bool hdr, params GUILayoutOption[] options);
        public static float Knob(Vector2 knobSize, float value, float minValue, float maxValue, string unit, Color backgroundColor, Color activeColor, bool showValue, params GUILayoutOption[] options);
        public static void EditorToolbarForTarget(UnityEngine.Object target);
        public static void EditorToolbarForTarget(GUIContent content, UnityEngine.Object target);
        public static void EditorToolbar(params EditorTool[] tools);
        public static void EditorToolbar<T>(IList<T> tools) where T : EditorTool;

        public class ToggleGroupScope : GUI.Scope
        {
            public ToggleGroupScope(string label, bool toggle);
            public ToggleGroupScope(GUIContent label, bool toggle);

            public bool enabled { get; protected set; }

            protected override void CloseScope();
        }
        public class HorizontalScope : GUI.Scope
        {
            public HorizontalScope(params GUILayoutOption[] options);
            public HorizontalScope(GUIStyle style, params GUILayoutOption[] options);

            public Rect rect { get; protected set; }

            protected override void CloseScope();
        }
        public class VerticalScope : GUI.Scope
        {
            public VerticalScope(params GUILayoutOption[] options);
            public VerticalScope(GUIStyle style, params GUILayoutOption[] options);

            public Rect rect { get; protected set; }

            protected override void CloseScope();
        }
        public class ScrollViewScope : GUI.Scope
        {
            public ScrollViewScope(Vector2 scrollPosition, params GUILayoutOption[] options);
            public ScrollViewScope(Vector2 scrollPosition, bool alwaysShowHorizontal, bool alwaysShowVertical, params GUILayoutOption[] options);
            public ScrollViewScope(Vector2 scrollPosition, GUIStyle horizontalScrollbar, GUIStyle verticalScrollbar, params GUILayoutOption[] options);
            public ScrollViewScope(Vector2 scrollPosition, GUIStyle style, params GUILayoutOption[] options);
            public ScrollViewScope(Vector2 scrollPosition, bool alwaysShowHorizontal, bool alwaysShowVertical, GUIStyle horizontalScrollbar, GUIStyle verticalScrollbar, GUIStyle background, params GUILayoutOption[] options);

            public Vector2 scrollPosition { get; protected set; }
            public bool handleScrollWheel { get; set; }

            protected override void CloseScope();
        }
        public class FadeGroupScope : GUI.Scope
        {
            public FadeGroupScope(float value);

            public bool visible { get; protected set; }

            protected override void CloseScope();
        }
    }
}
namespace UnityEditor
{
    public enum MouseCursor
    {
        Arrow = 0,
        Text = 1,
        ResizeVertical = 2,
        ResizeHorizontal = 3,
        Link = 4,
        SlideArrow = 5,
        ResizeUpRight = 6,
        ResizeUpLeft = 7,
        MoveArrow = 8,
        RotateArrow = 9,
        ScaleArrow = 10,
        ArrowPlus = 11,
        ArrowMinus = 12,
        Pan = 13,
        Orbit = 14,
        Zoom = 15,
        FPS = 16,
        CustomCursor = 17,
        SplitResizeUpDown = 18,
        SplitResizeLeftRight = 19
    }
}
namespace UnityEditor
{
    public enum MessageType
    {
        None = 0,
        Info = 1,
        Warning = 2,
        Error = 3
    }
}
namespace UnityEditor
{
    public enum EditorSkin
    {
        Game = 0,
        Inspector = 1,
        Scene = 2
    }
}
using System;
using System.Collections.Generic;
using System.ComponentModel;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Internal;

namespace UnityEditor
{
    [NativeHeader("Runtime/Graphics/RenderTexture.h")]
    [NativeHeader("Runtime/Graphics/Texture2D.h")]
    [NativeHeader("Editor/Src/EditorResources.h")]
    [NativeHeader("Modules/TextRendering/Public/Font.h")]
    [NativeHeader("Editor/Src/Utility/EditorGUIUtility.h")]
    public sealed class EditorGUIUtility : GUIUtility
    {
        [Obsolete("This field is no longer used by any builtin controls. If passing this field to GetControlID, explicitly use the FocusType enum instead.", False)]
        public static FocusType native;

        public EditorGUIUtility();

        public static Texture2D whiteTexture { get; }
        public static string systemCopyBuffer { get; set; }
        public static float pixelsPerPoint { get; }
        public static float singleLineHeight { get; }
        public static float standardVerticalSpacing { get; }
        public static bool isProSkin { get; }
        public static bool editingTextField { get; set; }
        public static bool textFieldHasSelection { get; }
        public static bool hierarchyMode { get; set; }
        public static bool wideMode { get; set; }
        public static float currentViewWidth { get; }
        public static float labelWidth { get; set; }
        public static float fieldWidth { get; set; }

        public static string SerializeMainMenuToString();
        public static void SetMenuLocalizationTestMode(bool onoff);
        public static void SetIconSize(Vector2 size);
        public static void SetWantsMouseJumping(int wantz);
        public static bool IsDisplayReferencedByCameras(int displayIndex);
        public static void QueueGameViewInputEvent(Event evt);
        [Obsolete("RenderGameViewCameras is no longer supported.Consider rendering cameras manually.", True)]
        [EditorBrowsable(Never)]
        public static void RenderGameViewCameras(RenderTexture target, int targetDisplay, Rect screenRect, Vector2 mousePosition, bool gizmos);
        public static Rect GetMainWindowPosition();
        public static void SetMainWindowPosition(Rect position);
        public static Rect PointsToPixels(Rect rect);
        public static Rect PixelsToPoints(Rect rect);
        public static Vector2 PointsToPixels(Vector2 position);
        public static Vector2 PixelsToPoints(Vector2 position);
        public static List<Rect> GetFlowLayoutedRects(Rect rect, GUIStyle style, float horizontalSpacing, float verticalSpacing, List<string> items);
        public static Texture2D FindTexture(string name);
        [ExcludeFromDocs]
        public static GUIContent TrTextContent(string key, string text, string tooltip, Texture icon);
        [ExcludeFromDocs]
        public static GUIContent TrTextContent(string text, string tooltip = null, Texture icon = null);
        [ExcludeFromDocs]
        public static GUIContent TrTextContent(string text, string tooltip, string iconName);
        [ExcludeFromDocs]
        public static GUIContent TrTextContent(string text, Texture icon);
        [ExcludeFromDocs]
        public static GUIContent TrTextContentWithIcon(string text, Texture icon);
        [ExcludeFromDocs]
        public static GUIContent TrTextContentWithIcon(string text, string iconName);
        [ExcludeFromDocs]
        public static GUIContent TrTextContentWithIcon(string text, string tooltip, string iconName);
        [ExcludeFromDocs]
        public static GUIContent TrTextContentWithIcon(string text, string tooltip, Texture icon);
        [ExcludeFromDocs]
        public static GUIContent TrTextContentWithIcon(string text, string tooltip, MessageType messageType);
        [ExcludeFromDocs]
        public static GUIContent TrTextContentWithIcon(string text, MessageType messageType);
        [ExcludeFromDocs]
        public static GUIContent TrIconContent(string iconName, string tooltip = null);
        [ExcludeFromDocs]
        public static GUIContent TrIconContent(Texture icon, string tooltip = null);
        [ExcludeFromDocs]
        public static GUIContent TrTempContent(string t);
        [ExcludeFromDocs]
        public static GUIContent[] TrTempContent(string[] texts);
        [ExcludeFromDocs]
        public static GUIContent[] TrTempContent(string[] texts, string[] tooltips);
        [ExcludeFromDocs]
        public static GUIContent IconContent(string name);
        public static GUIContent IconContent(string name, [UnityEngine.Internal.DefaultValue("null")] string text);
        public static GUIContent ObjectContent(UnityEngine.Object obj, Type type);
        public static bool HasObjectThumbnail(Type objType);
        public static Vector2 GetIconSize();
        public static GUISkin GetBuiltinSkin(EditorSkin skin);
        public static UnityEngine.Object LoadRequired(string path);
        public static UnityEngine.Object Load(string path);
        public static void PingObject(UnityEngine.Object obj);
        public static void PingObject(int targetInstanceID);
        [Obsolete("RenderGameViewCameras is no longer supported.Consider rendering cameras manually.", True)]
        [EditorBrowsable(Never)]
        public static void RenderGameViewCameras(Rect cameraRect, bool gizmos, bool gui);
        [Obsolete("RenderGameViewCameras is no longer supported.Consider rendering cameras manually.", True)]
        [EditorBrowsable(Never)]
        public static void RenderGameViewCameras(Rect cameraRect, Rect statsRect, bool gizmos, bool gui);
        [Obsolete("LookLikeControls and LookLikeInspector modes are deprecated.Use EditorGUIUtility.labelWidth and EditorGUIUtility.fieldWidth to control label and field widths.", False)]
        public static void LookLikeControls(float _labelWidth, float _fieldWidth);
        [ExcludeFromDocs]
        [Obsolete("LookLikeControls and LookLikeInspector modes are deprecated.Use EditorGUIUtility.labelWidth and EditorGUIUtility.fieldWidth to control label and field widths.", False)]
        public static void LookLikeControls(float _labelWidth);
        [Obsolete("LookLikeControls and LookLikeInspector modes are deprecated.Use EditorGUIUtility.labelWidth and EditorGUIUtility.fieldWidth to control label and field widths.", False)]
        [ExcludeFromDocs]
        public static void LookLikeControls();
        [Obsolete("LookLikeControls and LookLikeInspector modes are deprecated.", False)]
        public static void LookLikeInspector();
        public static Event CommandEvent(string commandName);
        public static void DrawColorSwatch(Rect position, Color color);
        public static void DrawCurveSwatch(Rect position, AnimationCurve curve, SerializedProperty property, Color color, Color bgColor);
        public static void DrawCurveSwatch(Rect position, AnimationCurve curve, SerializedProperty property, Color color, Color bgColor, Color topFillColor, Color bottomFillColor);
        public static void DrawCurveSwatch(Rect position, AnimationCurve curve, SerializedProperty property, Color color, Color bgColor, Color topFillColor, Color bottomFillColor, Rect curveRanges);
        public static void DrawCurveSwatch(Rect position, AnimationCurve curve, SerializedProperty property, Color color, Color bgColor, Rect curveRanges);
        public static void DrawRegionSwatch(Rect position, SerializedProperty property, SerializedProperty property2, Color color, Color bgColor, Rect curveRanges);
        public static void DrawRegionSwatch(Rect position, AnimationCurve curve, AnimationCurve curve2, Color color, Color bgColor, Rect curveRanges);
        [EditorBrowsable(Never)]
        [Obsolete("EditorGUIUtility.RGBToHSV is obsolete. Use Color.RGBToHSV instead (UnityUpgradable) -> [UnityEngine] UnityEngine.Color.RGBToHSV(*)", True)]
        public static void RGBToHSV(Color rgbColor, out float H, out float S, out float V);
        [EditorBrowsable(Never)]
        [Obsolete("EditorGUIUtility.HSVToRGB is obsolete. Use Color.HSVToRGB instead (UnityUpgradable) -> [UnityEngine] UnityEngine.Color.HSVToRGB(*)", True)]
        public static Color HSVToRGB(float H, float S, float V);
        [EditorBrowsable(Never)]
        [Obsolete("EditorGUIUtility.HSVToRGB is obsolete. Use Color.HSVToRGB instead (UnityUpgradable) -> [UnityEngine] UnityEngine.Color.HSVToRGB(*)", True)]
        public static Color HSVToRGB(float H, float S, float V, bool hdr);
        public static void AddCursorRect(Rect position, MouseCursor mouse);
        public static void AddCursorRect(Rect position, MouseCursor mouse, int controlID);
        public static void ShowObjectPicker<T>(UnityEngine.Object obj, bool allowSceneObjects, string searchFilter, int controlID) where T : UnityEngine.Object;
        public static UnityEngine.Object GetObjectPickerObject();
        public static int GetObjectPickerControlID();

        public class IconSizeScope : GUI.Scope
        {
            public IconSizeScope(Vector2 iconSizeWithinScope);

            protected override void CloseScope();
        }
    }
}
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Internal;

namespace UnityEditor
{
    [StaticAccessor("GetInspectorExpandedState().GetSessionState()", Dot)]
    [NativeHeader("Editor/Src/InspectorExpandedState.h")]
    public class SessionState
    {
        [ExcludeFromDocs]
        public SessionState();

        public static void SetBool(string key, bool value);
        public static bool GetBool(string key, bool defaultValue);
        public static void EraseBool(string key);
        public static void SetFloat(string key, float value);
        public static float GetFloat(string key, float defaultValue);
        public static void EraseFloat(string key);
        public static void SetInt(string key, int value);
        public static int GetInt(string key, int defaultValue);
        public static void EraseInt(string key);
        public static void SetString(string key, string value);
        public static string GetString(string key, string defaultValue);
        public static void EraseString(string key);
        public static void SetVector3(string key, Vector3 value);
        public static Vector3 GetVector3(string key, Vector3 defaultValue);
        public static void EraseVector3(string key);
        public static void EraseIntArray(string key);
        public static void SetIntArray(string key, int[] value);
        public static int[] GetIntArray(string key, int[] defaultValue);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Internal;

namespace UnityEditor
{
    [NativeHeader("Runtime/Utilities/PlayerPrefs.h")]
    public sealed class EditorPrefs
    {
        public EditorPrefs();

        public static void SetInt(string key, int value);
        public static int GetInt(string key, [DefaultValue("0")] int defaultValue);
        public static int GetInt(string key);
        public static void SetFloat(string key, float value);
        public static float GetFloat(string key, [DefaultValue("0.0F")] float defaultValue);
        public static float GetFloat(string key);
        public static void SetString(string key, string value);
        public static string GetString(string key, [DefaultValue("\"\"")] string defaultValue);
        public static string GetString(string key);
        public static void SetBool(string key, bool value);
        public static bool GetBool(string key, [DefaultValue("false")] bool defaultValue);
        public static bool GetBool(string key);
        public static bool HasKey(string key);
        public static void DeleteKey(string key);
        public static void DeleteAll();
    }
}
namespace UnityEditor
{
    public enum SerializationMode
    {
        Mixed = 0,
        ForceBinary = 1,
        ForceText = 2
    }
}
namespace UnityEditor
{
    public enum EditorBehaviorMode
    {
        Mode3D = 0,
        Mode2D = 1
    }
}
using System;

namespace UnityEditor
{
    public enum SpritePackerMode
    {
        Disabled = 0,
        [Obsolete("Sprite Packing Tags are deprecated. Please use Sprite Atlas asset.")]
        BuildTimeOnly = 1,
        [Obsolete("Sprite Packing Tags are deprecated. Please use Sprite Atlas asset.")]
        AlwaysOn = 2,
        BuildTimeOnlyAtlas = 3,
        AlwaysOnAtlas = 4,
        SpriteAtlasV2 = 5
    }
}
namespace UnityEditor
{
    public enum LineEndingsMode
    {
        OSNative = 0,
        Unix = 1,
        Windows = 2
    }
}
namespace UnityEditor
{
    public enum AssetPipelineMode
    {
        Version1 = 0,
        Version2 = 1
    }
}
namespace UnityEditor
{
    public enum CacheServerMode
    {
        AsPreferences = 0,
        Enabled = 1,
        Disabled = 2
    }
}
namespace UnityEditor
{
    public enum CacheServerValidationMode
    {
        Disabled = 0,
        UploadOnly = 1,
        Enabled = 2,
        Required = 3
    }
}
using System;

namespace UnityEditor
{
    [Flags]
    public enum EnterPlayModeOptions
    {
        None = 0,
        DisableDomainReload = 1,
        DisableSceneReload = 2
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Editor/Src/VersionControlSettings.h")]
    [NativeHeader("Editor/Src/EditorSettings.h")]
    [NativeHeader("Editor/Src/EditorUserSettings.h")]
    public sealed class EditorSettings : UnityEngine.Object
    {
        public static string unityRemoteDevice { get; set; }
        public static string unityRemoteCompression { get; set; }
        public static string unityRemoteResolution { get; set; }
        public static string unityRemoteJoystickSource { get; set; }
        [Obsolete("Use VersionControlSettings.mode instead.")]
        [StaticAccessor("GetVersionControlSettings()", Dot)]
        public static string externalVersionControl { get; set; }
        [StaticAccessor("GetEditorSettings()", Dot)]
        public static SerializationMode serializationMode { get; set; }
        [StaticAccessor("GetEditorSettings()", Dot)]
        public static LineEndingsMode lineEndingsForNewScripts { get; set; }
        [Obsolete("EditorSettings.webSecurityEmulationEnabled is no longer supported, since the Unity Web Player is no longer supported by Unity.")]
        public static bool webSecurityEmulationEnabled { get; set; }
        [Obsolete("EditorSettings.webSecurityEmulationHostUrl is no longer supported, since the Unity Web Player is no longer supported by Unity.")]
        public static string webSecurityEmulationHostUrl { get; set; }
        [StaticAccessor("GetEditorSettings()", Dot)]
        public static EditorBehaviorMode defaultBehaviorMode { get; set; }
        [StaticAccessor("GetEditorSettings()", Dot)]
        public static SceneAsset prefabRegularEnvironment { get; set; }
        [StaticAccessor("GetEditorSettings()", Dot)]
        public static SceneAsset prefabUIEnvironment { get; set; }
        [StaticAccessor("GetEditorSettings()", Dot)]
        public static bool prefabModeAllowAutoSave { get; set; }
        [StaticAccessor("GetEditorSettings()", Dot)]
        public static SpritePackerMode spritePackerMode { get; set; }
        [StaticAccessor("GetEditorSettings()", Dot)]
        public static int spritePackerPaddingPower { get; set; }
        [StaticAccessor("GetEditorSettings()", Dot)]
        public static int etcTextureCompressorBehavior { get; set; }
        [StaticAccessor("GetEditorSettings()", Dot)]
        public static int etcTextureFastCompressor { get; set; }
        [StaticAccessor("GetEditorSettings()", Dot)]
        public static int etcTextureNormalCompressor { get; set; }
        [StaticAccessor("GetEditorSettings()", Dot)]
        public static int etcTextureBestCompressor { get; set; }
        [StaticAccessor("GetEditorSettings()", Dot)]
        public static bool enableTextureStreamingInEditMode { get; set; }
        [StaticAccessor("GetEditorSettings()", Dot)]
        public static bool enableTextureStreamingInPlayMode { get; set; }
        [StaticAccessor("GetEditorSettings()", Dot)]
        public static bool asyncShaderCompilation { get; set; }
        [StaticAccessor("GetEditorSettings()", Dot)]
        public static bool cachingShaderPreprocessor { get; set; }
        public static string[] projectGenerationUserExtensions { get; set; }
        public static string[] projectGenerationBuiltinExtensions { get; }
        [StaticAccessor("GetEditorSettings()", Dot)]
        public static string projectGenerationRootNamespace { get; set; }
        [StaticAccessor("GetEditorSettings()", Dot)]
        public static bool useLegacyProbeSampleCount { get; set; }
        [StaticAccessor("GetEditorSettings()", Dot)]
        [Obsolete("EditorSettings.disableCookiesInLightmapper is obsolete, please use EditorSettings.enableCookiesInLightmapper instead.", False)]
        public static bool disableCookiesInLightmapper { get; set; }
        public static bool enableCookiesInLightmapper { get; set; }
        [StaticAccessor("GetEditorSettings()", Dot)]
        public static bool enterPlayModeOptionsEnabled { get; set; }
        [StaticAccessor("GetEditorSettings()", Dot)]
        public static EnterPlayModeOptions enterPlayModeOptions { get; set; }
        [StaticAccessor("GetEditorSettings()", Dot)]
        public static bool serializeInlineMappingsOnOneLine { get; set; }
        [StaticAccessor("GetEditorSettings()", Dot)]
        public static AssetPipelineMode assetPipelineMode { get; }
        [StaticAccessor("GetEditorSettings()", Dot)]
        public static CacheServerMode cacheServerMode { get; set; }
        [StaticAccessor("GetEditorSettings()", Dot)]
        public static string cacheServerEndpoint { get; set; }
        [StaticAccessor("GetEditorSettings()", Dot)]
        public static string cacheServerNamespacePrefix { get; set; }
        [StaticAccessor("GetEditorSettings()", Dot)]
        public static bool cacheServerEnableDownload { get; set; }
        [StaticAccessor("GetEditorSettings()", Dot)]
        public static bool cacheServerEnableUpload { get; set; }
        [StaticAccessor("GetEditorSettings()", Dot)]
        public static bool cacheServerEnableAuth { get; set; }
        [StaticAccessor("GetEditorSettings()", Dot)]
        public static bool cacheServerEnableTls { get; set; }
        [StaticAccessor("GetEditorSettings()", Dot)]
        public static CacheServerValidationMode cacheServerValidationMode { get; set; }
        [StaticAccessor("GetEditorSettings()", Dot)]
        public static int gameObjectNamingDigits { get; set; }
        [StaticAccessor("GetEditorSettings()", Dot)]
        public static NamingScheme gameObjectNamingScheme { get; set; }
        [StaticAccessor("GetEditorSettings()", Dot)]
        public static bool assetNamingUsesSpace { get; set; }

        public enum NamingScheme
        {
            SpaceParenthesis = 0,
            Dot = 1,
            Underscore = 2
        }
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType(Header = "Editor/Src/EditorUserBuildSettings.h")]
    public enum PS4BuildSubtarget
    {
        PCHosted = 0,
        Package = 1,
        Iso = 2
    }
}
using System;
using System.ComponentModel;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType(Header = "Editor/Src/EditorUserBuildSettings.h")]
    public enum PS4HardwareTarget
    {
        BaseOnly = 0,
        [Obsolete("Enum member PS4HardwareTarget.NeoAndBase has been deprecated. Use PS4HardwareTarget.ProAndBase instead (UnityUpgradable) -> ProAndBase", True)]
        [EditorBrowsable(Never)]
        NeoAndBase = 1,
        ProAndBase = 1
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType(Header = "Runtime/Serialize/BuildTarget.h")]
    public enum XboxBuildSubtarget
    {
        Development = 0,
        Master = 1,
        Debug = 2
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType(Header = "Runtime/Serialize/BuildTarget.h")]
    public enum XboxOneDeployMethod
    {
        Push = 0,
        RunFromPC = 2,
        Package = 3,
        PackageStreaming = 4
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType(Header = "Runtime/Serialize/BuildTarget.h")]
    public enum XboxOneDeployDrive
    {
        Default = 0,
        Retail = 1,
        Development = 2,
        Ext1 = 3,
        Ext2 = 4,
        Ext3 = 5,
        Ext4 = 6,
        Ext5 = 7,
        Ext6 = 8,
        Ext7 = 9
    }
}
using System;
using System.ComponentModel;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType(Header = "Editor/Src/EditorUserBuildSettings.h")]
    [EditorBrowsable(Never)]
    [Obsolete("UnityEditor.AndroidBuildSubtarget has been deprecated. Use UnityEditor.MobileTextureSubtarget instead (UnityUpgradable)", True)]
    public enum AndroidBuildSubtarget
    {
        Generic = -1,
        DXT = -1,
        PVRTC = -1,
        ATC = -1,
        ETC = -1,
        ETC2 = -1,
        ASTC = -1
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType(Header = "Runtime/Serialize/BuildTarget.h")]
    public enum MobileTextureSubtarget
    {
        Generic = 0,
        DXT = 1,
        PVRTC = 2,
        [Obsolete("UnityEditor.MobileTextureSubtarget.ATC has been deprecated. Use UnityEditor.MobileTextureSubtarget.ETC instead (UnityUpgradable) -> UnityEditor.MobileTextureSubtarget.ETC", True)]
        ATC = 3,
        ETC = 4,
        ETC2 = 5,
        ASTC = 6
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType(Header = "Runtime/Serialize/BuildTarget.h")]
    public enum AndroidETC2Fallback
    {
        Quality32Bit = 0,
        Quality16Bit = 1,
        Quality32BitDownscaled = 2
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType(Header = "Runtime/Serialize/BuildTarget.h")]
    public enum WSASubtarget
    {
        AnyDevice = 0,
        PC = 1,
        Mobile = 2,
        HoloLens = 3
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType(Header = "Editor/Src/EditorUserBuildSettings.h")]
    public enum WSASDK
    {
        SDK80 = 0,
        SDK81 = 1,
        PhoneSDK81 = 2,
        UniversalSDK81 = 3,
        UWP = 4
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType(Header = "Editor/Src/EditorUserBuildSettings.h")]
    public enum WSAUWPBuildType
    {
        XAML = 0,
        D3D = 1,
        ExecutableOnly = 2
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType(Header = "Editor/Src/EditorUserBuildSettings.h")]
    public enum WSABuildAndRunDeployTarget
    {
        LocalMachine = 0,
        WindowsPhone = 1,
        DevicePortal = 2
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType(Header = "Editor/Src/EditorUserBuildSettings.h")]
    public enum WSABuildType
    {
        Debug = 0,
        Release = 1,
        Master = 2
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType(Header = "Editor/Src/EditorUserBuildSettings.h")]
    public enum iOSBuildType
    {
        Debug = 0,
        Release = 1
    }
}
using System;
using System.ComponentModel;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType(Header = "Editor/Src/EditorUserBuildSettings.h")]
    public enum AndroidBuildSystem
    {
        [EditorBrowsable(Never)]
        [Obsolete("Internal build system has been deprecated. Use Gradle instead (UnityUpgradable) -> UnityEditor.AndroidBuildSystem.Gradle", True)]
        Internal = 0,
        Gradle = 1,
        [EditorBrowsable(Never)]
        [Obsolete("ADT/eclipse project export for Android is no longer supported - please use Gradle export instead", True)]
        ADT = 2,
        VisualStudio = 3
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType(Header = "Editor/Src/EditorUserBuildSettings.h")]
    public enum AndroidBuildType
    {
        Debug = 0,
        Development = 1,
        Release = 2
    }
}
using System;

namespace UnityEditor
{
    [Obsolete("AndroidMinification enum is obsolete.", True)]
    public enum AndroidMinification
    {
        None = 0,
        Proguard = 1,
        Gradle = 2
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType(Header = "Editor/Src/EditorUserBuildSettings.h")]
    public enum SwitchRomCompressionType
    {
        None = 0,
        Lz4 = 1
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Editor/Src/EditorUserBuildSettings.h")]
    [StaticAccessor("GetEditorUserBuildSettings()", Dot)]
    public class EditorUserBuildSettings : UnityEngine.Object
    {
        [Obsolete("UnityEditor.activeBuildTargetChanged has been deprecated.Use UnityEditor.Build.IActiveBuildTargetChanged instead.")]
        public static Action activeBuildTargetChanged;

        public static BuildTargetGroup selectedBuildTargetGroup { get; set; }
        public static BuildTarget selectedStandaloneTarget { get; set; }
        public static PS4BuildSubtarget ps4BuildSubtarget { get; set; }
        public static PS4HardwareTarget ps4HardwareTarget { get; set; }
        public static bool explicitNullChecks { get; set; }
        public static bool explicitDivideByZeroChecks { get; set; }
        public static bool explicitArrayBoundsChecks { get; set; }
        public static bool needSubmissionMaterials { get; set; }
        public static bool compressWithPsArc { get; set; }
        public static bool forceInstallation { get; set; }
        public static bool movePackageToDiscOuterEdge { get; set; }
        public static bool compressFilesInPackage { get; set; }
        public static bool enableHeadlessMode { get; set; }
        public static bool buildScriptsOnly { get; set; }
        public static XboxBuildSubtarget xboxBuildSubtarget { get; set; }
        public static int streamingInstallLaunchRange { get; set; }
        public static XboxOneDeployMethod xboxOneDeployMethod { get; set; }
        public static XboxOneDeployDrive xboxOneDeployDrive { get; set; }
        [Obsolete("xboxOneUsername is deprecated, it is unnecessary and non-functional.")]
        public static string xboxOneUsername { get; set; }
        [Obsolete("xboxOneNetworkSharePath is deprecated, it is unnecessary and non-functional.")]
        public static string xboxOneNetworkSharePath { get; set; }
        public static string xboxOneAdditionalDebugPorts { get; set; }
        public static bool xboxOneRebootIfDeployFailsAndRetry { get; set; }
        public static MobileTextureSubtarget androidBuildSubtarget { get; set; }
        public static AndroidETC2Fallback androidETC2Fallback { get; set; }
        public static AndroidBuildSystem androidBuildSystem { get; set; }
        public static AndroidBuildType androidBuildType { get; set; }
        [Obsolete("androidUseLegacySdkTools has been deprecated. It does not have any effect.")]
        public static bool androidUseLegacySdkTools { get; set; }
        public static bool androidCreateSymbolsZip { get; set; }
        public static WSASubtarget wsaSubtarget { get; set; }
        [Obsolete("EditorUserBuildSettings.wsaSDK is obsolete and has no effect.It will be removed in a subsequent Unity release.")]
        public static WSASDK wsaSDK { get; set; }
        public static WSAUWPBuildType wsaUWPBuildType { get; set; }
        public static string wsaUWPSDK { get; set; }
        public static string wsaMinUWPSDK { get; set; }
        public static string wsaArchitecture { get; set; }
        public static string wsaUWPVisualStudioVersion { get; set; }
        public static string windowsDevicePortalAddress { get; set; }
        public static string windowsDevicePortalUsername { get; set; }
        public static string windowsDevicePortalPassword { get; set; }
        public static WSABuildAndRunDeployTarget wsaBuildAndRunDeployTarget { get; set; }
        public static BuildTarget activeBuildTarget { get; }
        public static string[] activeScriptCompilationDefines { get; }
        public static bool development { get; set; }
        [Obsolete("Building with pre-built Engine option is no longer supported.", True)]
        public static bool webGLUsePreBuiltUnityEngine { get; set; }
        public static bool connectProfiler { get; set; }
        public static bool buildWithDeepProfilingSupport { get; set; }
        public static bool allowDebugging { get; set; }
        public static bool waitForPlayerConnection { get; set; }
        public static bool exportAsGoogleAndroidProject { get; set; }
        public static bool buildAppBundle { get; set; }
        public static bool symlinkLibraries { get; set; }
        public static iOSBuildType iOSBuildConfigType { get; set; }
        public static bool switchCreateRomFile { get; set; }
        public static bool switchEnableRomCompression { get; set; }
        public static bool switchSaveADF { get; set; }
        public static SwitchRomCompressionType switchRomCompressionType { get; set; }
        public static int switchRomCompressionLevel { get; set; }
        public static string switchRomCompressionConfig { get; set; }
        public static bool switchNVNGraphicsDebugger { get; set; }
        public static bool generateNintendoSwitchShaderInfo { get; set; }
        public static bool switchNVNShaderDebugging { get; set; }
        [Obsolete("switchNVNDrawValidation is deprecated, use switchNVNDrawValidation_Heavy instead.")]
        public static bool switchNVNDrawValidation { get; set; }
        public static bool switchNVNDrawValidation_Light { get; set; }
        public static bool switchNVNDrawValidation_Heavy { get; set; }
        public static bool switchEnableHeapInspector { get; set; }
        public static bool switchEnableDebugPad { get; set; }
        public static bool switchRedirectWritesToHostMount { get; set; }
        public static bool switchHTCSScriptDebugging { get; set; }
        public static bool switchUseLegacyNvnPoolAllocator { get; set; }
        public static bool installInBuildFolder { get; set; }
        public static bool waitForManagedDebugger { get; set; }
        [Obsolete("forceOptimizeScriptCompilation is obsolete - will always return false. Control script optimization using the 'IL2CPP optimization level' configuration in Player Settings / Other.")]
        public static bool forceOptimizeScriptCompilation { get; }
        [Obsolete("androidDebugMinification is obsolete. Use PlayerSettings.Android.minifyDebug and PlayerSettings.Android.minifyWithR8.")]
        public static AndroidMinification androidDebugMinification { get; set; }
        [Obsolete("androidReleaseMinification is obsolete. Use PlayerSettings.Android.minifyRelease and PlayerSettings.Android.minifyWithR8.")]
        public static AndroidMinification androidReleaseMinification { get; set; }

        [NativeMethod("SwitchActiveBuildTargetSync")]
        public static bool SwitchActiveBuildTarget(BuildTargetGroup targetGroup, BuildTarget target);
        [NativeMethod("SwitchActiveBuildTargetAsync")]
        public static bool SwitchActiveBuildTargetAsync(BuildTargetGroup targetGroup, BuildTarget target);
        public static string GetBuildLocation(BuildTarget target);
        public static void SetBuildLocation(BuildTarget target, string location);
        public static void SetPlatformSettings(string platformName, string name, string value);
        public static void SetPlatformSettings(string buildTargetGroup, string buildTarget, string name, string value);
        public static string GetPlatformSettings(string platformName, string name);
        public static string GetPlatformSettings(string buildTargetGroup, string platformName, string name);
        [Obsolete("Please use SwitchActiveBuildTarget(BuildTargetGroup targetGroup, BuildTarget target)")]
        public static bool SwitchActiveBuildTarget(BuildTarget target);
    }
}
namespace UnityEditor
{
    public enum SemanticMergeMode
    {
        Off = 0,
        Premerge = 1,
        Ask = 2
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [StaticAccessor("GetEditorUserSettings()", Dot)]
    [NativeHeader("Editor/Src/EditorUserSettings.h")]
    public sealed class EditorUserSettings : Object
    {
        [NativeProperty("VCAutomaticAdd")]
        public static bool AutomaticAdd { get; set; }
        [NativeProperty("VCWorkOffline")]
        public static bool WorkOffline { get; set; }
        [NativeProperty("VCShowFailedCheckout")]
        public static bool showFailedCheckout { get; set; }
        [NativeProperty("VCOverwriteFailedCheckoutAssets")]
        public static bool overwriteFailedCheckoutAssets { get; set; }
        [NativeProperty("VCProjectOverlayIcons")]
        public static bool overlayIcons { get; set; }
        [NativeProperty("VCAllowAsyncUpdate")]
        public static bool allowAsyncStatusUpdate { get; set; }
        public static SemanticMergeMode semanticMergeMode { get; set; }

        public static string GetConfigValue(string name);
        public static void SetConfigValue(string name, string value);
    }
}
using System;
using System.ComponentModel;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Internal;
using UnityEngine.SceneManagement;
using UnityEngine.Scripting;

namespace UnityEditor
{
    [NativeHeader("Editor/Mono/EditorUtility.bindings.h")]
    [NativeHeader("Editor/Mono/MonoEditorUtility.h")]
    [NativeHeader("Runtime/Shaders/ShaderImpl/ShaderUtilities.h")]
    public class EditorUtility
    {
        public EditorUtility();

        public static bool audioMasterMute { get; set; }
        public static bool scriptCompilationFailed { get; }

        public static string OpenFilePanel(string title, string directory, string extension);
        public static string OpenFilePanelWithFilters(string title, string directory, string[] filters);
        [FreeFunction("RevealInFinder")]
        public static void RevealInFinder(string path);
        public static bool DisplayDialog(string title, string message, string ok, [UnityEngine.Internal.DefaultValue("\"\"")] string cancel);
        [ExcludeFromDocs]
        public static bool DisplayDialog(string title, string message, string ok);
        [FreeFunction("DisplayDialogComplex")]
        public static int DisplayDialogComplex(string title, string message, string ok, string cancel, string alt);
        [FreeFunction("RunOpenFolderPanel")]
        public static string OpenFolderPanel(string title, string folder, string defaultName);
        [FreeFunction("RunSaveFolderPanel")]
        public static string SaveFolderPanel(string title, string folder, string defaultName);
        [FreeFunction("WarnPrefab")]
        public static bool WarnPrefab(UnityEngine.Object target, string title, string warning, string okButton);
        public static bool IsPersistent(UnityEngine.Object target);
        public static string SaveFilePanel(string title, string directory, string defaultName, string extension);
        public static int NaturalCompare(string a, string b);
        public static UnityEngine.Object InstanceIDToObject(int instanceID);
        public static void CompressTexture([NotNull("ArgumentNullException")] Texture2D texture, TextureFormat format, int quality);
        public static void CompressCubemapTexture([NotNull("ArgumentNullException")] Cubemap texture, TextureFormat format, int quality);
        [FreeFunction("EditorUtility::SetDirtyObjectOrScene")]
        public static void SetDirty([NotNull("ArgumentNullException")] UnityEngine.Object target);
        public static void ClearDirty([NotNull("ArgumentNullException")] UnityEngine.Object target);
        [FreeFunction("InvokeDiffTool")]
        public static string InvokeDiffTool(string leftTitle, string leftFile, string rightTitle, string rightFile, string ancestorTitle, string ancestorFile);
        [FreeFunction("CopySerialized")]
        public static void CopySerialized([NotNull("NullExceptionObject")] UnityEngine.Object source, [NotNull("NullExceptionObject")] UnityEngine.Object dest);
        [FreeFunction("CopyScriptSerialized")]
        public static void CopySerializedManagedFieldsOnly([NotNull("ArgumentNullException")] object source, [NotNull("ArgumentNullException")] object dest);
        [NativeThrows]
        public static UnityEngine.Object[] CollectDependencies(UnityEngine.Object[] roots);
        public static UnityEngine.Object[] CollectDeepHierarchy(UnityEngine.Object[] roots);
        [Obsolete("Use EditorUtility.UnloadUnusedAssetsImmediate instead", False)]
        public static void UnloadUnusedAssets();
        [Obsolete("Use EditorUtility.UnloadUnusedAssetsImmediate instead", False)]
        public static void UnloadUnusedAssetsIgnoreManagedReferences();
        [FreeFunction("FormatBytes")]
        public static string FormatBytes(long bytes);
        [FreeFunction("DisplayProgressbarLegacy")]
        public static void DisplayProgressBar(string title, string info, float progress);
        public static bool DisplayCancelableProgressBar(string title, string info, float progress);
        [FreeFunction("ClearProgressbarLegacy")]
        public static void ClearProgressBar();
        [FreeFunction("GetObjectEnabled")]
        public static int GetObjectEnabled(UnityEngine.Object target);
        [FreeFunction("SetObjectEnabled")]
        public static void SetObjectEnabled(UnityEngine.Object target, bool enabled);
        public static void SetSelectedRenderState(Renderer renderer, EditorSelectedRenderState renderState);
        [EditorBrowsable(Never)]
        [Obsolete("ExtractOggFile has no effect anymore", False)]
        public static bool ExtractOggFile(UnityEngine.Object obj, string path);
        [FreeFunction("OpenWithDefaultApp")]
        public static void OpenWithDefaultApp(string fileName);
        public static void SetCameraAnimateMaterials([NotNull("ArgumentNullException")] Camera camera, bool animate);
        public static void SetCameraAnimateMaterialsTime([NotNull("ArgumentNullException")] Camera camera, float time);
        [FreeFunction("ShaderLab::UpdateGlobalShaderProperties")]
        public static void UpdateGlobalShaderProperties(float time);
        [FreeFunction("FindAssetWithKlass", ThrowsException = True)]
        [Obsolete("Use AssetDatabase.LoadAssetAtPath", False)]
        public static UnityEngine.Object FindAsset(string path, Type type);
        [NativeMethod("GetDirtyIndex")]
        public static int GetDirtyCount(int instanceID);
        public static int GetDirtyCount(UnityEngine.Object target);
        public static bool IsDirty(int instanceID);
        public static bool IsDirty(UnityEngine.Object target);
        [RequiredByNativeCode]
        public static void FocusProjectWindow();
        [StaticAccessor("GetApplication()", Dot)]
        public static void RequestScriptReload();
        [FreeFunction("IsRunningUnderCPUEmulation", IsThreadSafe = True)]
        public static bool IsRunningUnderCPUEmulation();
        public static bool LoadWindowLayout(string path);
        public static void CompressTexture(Texture2D texture, TextureFormat format, TextureCompressionQuality quality);
        public static void CompressCubemapTexture(Cubemap texture, TextureFormat format, TextureCompressionQuality quality);
        public static string SaveFilePanelInProject(string title, string defaultName, string extension, string message);
        public static string SaveFilePanelInProject(string title, string defaultName, string extension, string message, string path);
        public static void CopySerializedIfDifferent(UnityEngine.Object source, UnityEngine.Object dest);
        [Obsolete("Use AssetDatabase.GetAssetPath", False)]
        public static string GetAssetPath(UnityEngine.Object asset);
        public static void UnloadUnusedAssetsImmediate();
        public static void UnloadUnusedAssetsImmediate(bool includeMonoReferencesAsRoots);
        [Obsolete("Use BuildPipeline.BuildAssetBundle instead")]
        public static bool BuildResourceFile(UnityEngine.Object[] selection, string pathName);
        public static bool GetDialogOptOutDecision(DialogOptOutDecisionType dialogOptOutDecisionType, string dialogOptOutDecisionStorageKey);
        public static void SetDialogOptOutDecision(DialogOptOutDecisionType dialogOptOutDecisionType, string dialogOptOutDecisionStorageKey, bool optOutDecision);
        public static bool DisplayDialog(string title, string message, string ok, DialogOptOutDecisionType dialogOptOutDecisionType, string dialogOptOutDecisionStorageKey);
        public static bool DisplayDialog(string title, string message, string ok, [UnityEngine.Internal.DefaultValue("\"\"")] string cancel, DialogOptOutDecisionType dialogOptOutDecisionType, string dialogOptOutDecisionStorageKey);
        public static void DisplayPopupMenu(Rect position, string menuItemPath, MenuCommand command);
        public static void DisplayCustomMenu(Rect position, GUIContent[] options, int selected, SelectMenuItemFunction callback, object userData);
        public static void DisplayCustomMenu(Rect position, GUIContent[] options, int selected, SelectMenuItemFunction callback, object userData, bool showHotkey);
        public static void DisplayCustomMenu(Rect position, GUIContent[] options, Func<int, bool> checkEnabled, int selected, SelectMenuItemFunction callback, object userData, bool showHotkey = False);
        public static string FormatBytes(int bytes);
        [Obsolete("Use EditorUtility.SetSelectedRenderState", False)]
        public static void SetSelectedWireframeHidden(Renderer renderer, bool enabled);
        public static GameObject CreateGameObjectWithHideFlags(string name, HideFlags flags, params Type[] components);
        public static string[] CompileCSharp(string[] sources, string[] references, string[] defines, string outputFile);
        [Obsolete("Use PrefabUtility.InstantiatePrefab", False)]
        public static UnityEngine.Object InstantiatePrefab(UnityEngine.Object target);
        [Obsolete("Use PrefabUtility.SaveAsPrefabAsset with a path instead.", False)]
        public static GameObject ReplacePrefab(GameObject go, UnityEngine.Object targetPrefab, ReplacePrefabOptions options);
        [Obsolete("Use PrefabUtility.SaveAsPrefabAsset or PrefabUtility.SaveAsPrefabAssetAndConnect with a path instead.", False)]
        public static GameObject ReplacePrefab(GameObject go, UnityEngine.Object targetPrefab);
        [Obsolete("The concept of creating a completely empty Prefab has been discontinued. You can however use PrefabUtility.SaveAsPrefabAsset with an empty GameObject.", False)]
        public static UnityEngine.Object CreateEmptyPrefab(string path);
        [Obsolete("Use PrefabUtility.RevertPrefabInstance.", False)]
        public static bool ReconnectToLastPrefab(GameObject go);
        [Obsolete("Use PrefabUtility.GetPrefabAssetType and PrefabUtility.GetPrefabInstanceStatus to get the full picture about Prefab types.", False)]
        public static PrefabType GetPrefabType(UnityEngine.Object target);
        [Obsolete("Use PrefabUtility.GetCorrespondingObjectFromSource.", False)]
        public static UnityEngine.Object GetPrefabParent(UnityEngine.Object source);
        [Obsolete("Use PrefabUtility.GetOutermostPrefabInstanceRoot if source is a Prefab instance or source.transform.root.gameObject if source is a Prefab Asset object.", False)]
        public static GameObject FindPrefabRoot(GameObject source);
        [Obsolete("Use PrefabUtility.RevertObjectOverride.", False)]
        public static bool ResetToPrefabState(UnityEngine.Object source);
        public static void DisplayCustomMenuWithSeparators(Rect position, string[] options, bool[] enabled, bool[] separator, int[] selected, SelectMenuItemFunction callback, object userData);
        public static void SetDefaultParentObject(GameObject defaultParentObject);
        public static void ClearDefaultParentObject(Scene scene);
        public static void ClearDefaultParentObject();

        public delegate void SelectMenuItemFunction(object userData, string[] options, int selected);
    }
}
using System;

namespace UnityEditor
{
    [Flags]
    public enum EditorSelectedRenderState
    {
        Hidden = 0,
        Wireframe = 1,
        Highlight = 2
    }
}
namespace UnityEditor
{
    public enum InteractionMode
    {
        AutomatedAction = 0,
        UserAction = 1
    }
}
namespace UnityEditor
{
    public enum TextureCompressionQuality
    {
        Fast = 0,
        Normal = 50,
        Best = 100
    }
}
namespace UnityEditor
{
    public enum DialogOptOutDecisionType
    {
        ForThisMachine = 0,
        ForThisSession = 1
    }
}
using UnityEngine;

namespace UnityEditor
{
    public class SceneAsset : Object
    {
    }
}
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Internal;
using UnityEngine.Scripting;
using UnityEngine.UIElements;

namespace UnityEditor
{
    [ExcludeFromObjectFactory]
    [NativeHeader("Editor/Src/ContainerWindow.bindings.h")]
    [UsedByNativeCode]
    public class EditorWindow : ScriptableObject
    {
        public EditorWindow();

        public VisualElement rootVisualElement { get; }
        public bool wantsMouseMove { get; set; }
        public bool wantsMouseEnterLeaveWindow { get; set; }
        public bool wantsLessLayoutEvents { get; set; }
        public bool autoRepaintOnSceneChange { get; set; }
        public bool maximized { get; set; }
        public bool hasFocus { get; }
        public bool docked { get; }
        public static EditorWindow focusedWindow { get; }
        public static EditorWindow mouseOverWindow { get; }
        public bool hasUnsavedChanges { get; protected set; }
        public string saveChangesMessage { get; protected set; }
        public Vector2 minSize { get; set; }
        public Vector2 maxSize { get; set; }
        [Obsolete("Use titleContent instead (it supports setting a title icon as well).")]
        public string title { get; set; }
        public GUIContent titleContent { get; set; }
        public int depthBufferBits { get; set; }
        [Obsolete("AA is not supported on EditorWindows", False)]
        public int antiAlias { get; set; }
        public Rect position { get; set; }

        public void BeginWindows();
        public void EndWindows();
        public void ShowNotification(GUIContent notification);
        public void ShowNotification(GUIContent notification, double fadeoutWait);
        public void RemoveNotification();
        public void ShowTab();
        public void Focus();
        public void ShowUtility();
        public void ShowPopup();
        public void ShowModalUtility();
        public void ShowAsDropDown(Rect buttonRect, Vector2 windowSize);
        public void Show();
        public void Show(bool immediateDisplay);
        public void ShowAuxWindow();
        public void ShowModal();
        public static EditorWindow GetWindow(Type t, [DefaultValue("false")] bool utility, [DefaultValue("null")] string title, [DefaultValue("true")] bool focus);
        [ExcludeFromDocs]
        public static EditorWindow GetWindow(Type t, bool utility, string title);
        [ExcludeFromDocs]
        public static EditorWindow GetWindow(Type t, bool utility);
        [ExcludeFromDocs]
        public static EditorWindow GetWindow(Type t);
        public static EditorWindow GetWindowWithRect(Type t, Rect rect, [DefaultValue("false")] bool utility, [DefaultValue("null")] string title);
        [ExcludeFromDocs]
        public static EditorWindow GetWindowWithRect(Type t, Rect rect, bool utility);
        [ExcludeFromDocs]
        public static EditorWindow GetWindowWithRect(Type t, Rect rect);
        public static T GetWindow<T>() where T : EditorWindow;
        public static T GetWindow<T>(bool utility) where T : EditorWindow;
        public static T GetWindow<T>(bool utility, string title) where T : EditorWindow;
        public static T GetWindow<T>(string title) where T : EditorWindow;
        public static T GetWindow<T>(string title, bool focus) where T : EditorWindow;
        public static T GetWindow<T>(bool utility, string title, bool focus) where T : EditorWindow;
        public static T GetWindow<T>(params Type[] desiredDockNextTo) where T : EditorWindow;
        public static T GetWindow<T>(string title, params Type[] desiredDockNextTo) where T : EditorWindow;
        public static T GetWindow<T>(string title, bool focus, params Type[] desiredDockNextTo) where T : EditorWindow;
        public static T CreateWindow<T>(params Type[] desiredDockNextTo) where T : EditorWindow;
        public static T CreateWindow<T>(string title, params Type[] desiredDockNextTo) where T : EditorWindow;
        public static bool HasOpenInstances<T>() where T : EditorWindow;
        public static void FocusWindowIfItsOpen(Type t);
        public static void FocusWindowIfItsOpen<T>() where T : EditorWindow;
        public static T GetWindowWithRect<T>(Rect rect) where T : EditorWindow;
        public static T GetWindowWithRect<T>(Rect rect, bool utility) where T : EditorWindow;
        public static T GetWindowWithRect<T>(Rect rect, bool utility, string title) where T : EditorWindow;
        public static T GetWindowWithRect<T>(Rect rect, bool utility, string title, bool focus) where T : EditorWindow;
        public virtual void SaveChanges();
        public void Close();
        public void Repaint();
        public bool SendEvent(Event e);
        public virtual IEnumerable<Type> GetExtraPaneTypes();
        protected virtual void OnBackingScaleFactorChanged();
    }
}
using System;

namespace UnityEditor
{
    [AttributeUsage(Class)]
    public class EditorWindowTitleAttribute : Attribute
    {
        public EditorWindowTitleAttribute();

        public string title { get; set; }
        public string icon { get; set; }
        public bool useTypeNameAsIconName { get; set; }
    }
}
using System;

namespace UnityEditor
{
    [Flags]
    public enum ExportPackageOptions
    {
        Default = 0,
        Interactive = 1,
        Recurse = 2,
        IncludeDependencies = 4,
        IncludeLibraryAssets = 8
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Editor/Platform/Interface/EditorUtility.h")]
    [NativeHeader("Runtime/Utilities/File.h")]
    [NativeHeader("Runtime/Utilities/FileUtilities.h")]
    public class FileUtil
    {
        public FileUtil();

        public static bool DeleteFileOrDirectory(string path);
        public static void CopyFileOrDirectory(string source, string dest);
        public static void CopyFileOrDirectoryFollowSymlinks(string source, string dest);
        public static void MoveFileOrDirectory(string source, string dest);
        [FreeFunction]
        public static string GetUniqueTempPathInProject();
        [FreeFunction]
        public static string GetProjectRelativePath(string path);
        public static void ReplaceFile(string src, string dst);
        public static void ReplaceDirectory(string src, string dst);
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Editor/Mono/GameObjectUtility.bindings.h")]
    public sealed class GameObjectUtility
    {
        public GameObjectUtility();

        public static StaticEditorFlags GetStaticEditorFlags(GameObject go);
        public static void SetStaticEditorFlags(GameObject go, StaticEditorFlags flags);
        public static bool AreStaticEditorFlagsSet(GameObject go, StaticEditorFlags flags);
        public static int GetNavMeshArea(GameObject go);
        public static void SetNavMeshArea(GameObject go, int areaIndex);
        public static int GetNavMeshAreaFromName(string name);
        public static string[] GetNavMeshAreaNames();
        public static string GetUniqueNameForSibling(Transform parent, string name);
        public static void EnsureUniqueNameForSibling(GameObject self);
        public static void SetParentAndAlign(GameObject child, GameObject parent);
        [FreeFunction]
        public static int GetMonoBehavioursWithMissingScriptCount([NotNull("NullExceptionObject")] GameObject go);
        [FreeFunction]
        public static int RemoveMonoBehavioursWithMissingScript([NotNull("NullExceptionObject")] GameObject go);
        public static ulong ModifyMaskIfGameObjectIsHiddenForPrefabModeInContext(ulong sceneCullingMask, GameObject gameObject);
        [Obsolete("GetNavMeshArea instead.")]
        public static int GetNavMeshLayer(GameObject go);
        [Obsolete("SetNavMeshArea instead.")]
        public static void SetNavMeshLayer(GameObject go, int areaIndex);
        [Obsolete("GetNavMeshAreaFromName instead.")]
        public static int GetNavMeshLayerFromName(string name);
        [Obsolete("GetNavMeshAreaNames instead.")]
        public static string[] GetNavMeshLayerNames();
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Editor/Src/GlobalObjectId.h")]
    public struct GlobalObjectId : IEquatable<GlobalObjectId>
    {
        public ulong targetObjectId { get; }
        public ulong targetPrefabId { get; }
        public GUID assetGUID { get; }
        public int identifierType { get; }

        [FreeFunction]
        public static GlobalObjectId GetGlobalObjectIdSlow(UnityEngine.Object targetObject);
        [FreeFunction]
        public static void GetGlobalObjectIdsSlow(UnityEngine.Object[] objects, out GlobalObjectId[] outputIdentifiers);
        public static GlobalObjectId GetGlobalObjectIdSlow(int instanceId);
        public static void GetGlobalObjectIdsSlow(int[] instanceIds, out GlobalObjectId[] outputIdentifiers);
        public override string ToString();
        public bool Equals(GlobalObjectId other);
        public static bool TryParse(string stringValue, out GlobalObjectId id);
        [FreeFunction]
        public static UnityEngine.Object GlobalObjectIdentifierToObjectSlow(GlobalObjectId id);
        [FreeFunction]
        public static void GlobalObjectIdentifiersToObjectsSlow(GlobalObjectId[] identifiers, out UnityEngine.Object[] outputObjects);
        [FreeFunction]
        public static int GlobalObjectIdentifierToInstanceIDSlow(GlobalObjectId id);
        [FreeFunction]
        public static void GlobalObjectIdentifiersToInstanceIDsSlow(GlobalObjectId[] identifiers, out int[] outputInstanceIDs);
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor
{
    [RequiredByNativeCode]
    [NativeHeader("Runtime/Utilities/GUID.h")]
    public struct GUID : IComparable, IComparable<GUID>, IEquatable<GUID>
    {
        public GUID(string hexRepresentation);

        public override bool Equals(object obj);
        public bool Equals(GUID obj);
        public override int GetHashCode();
        public int CompareTo(object obj);
        public int CompareTo(GUID rhs);
        public bool Empty();
        [Obsolete("Use TryParse instead")]
        public bool ParseExact(string hex);
        public static bool TryParse(string hex, out GUID result);
        public static GUID Generate();
        public override string ToString();

        public static bool operator ==(GUID x, GUID y);
        public static bool operator !=(GUID x, GUID y);
        public static bool operator <(GUID x, GUID y);
        public static bool operator >(GUID x, GUID y);
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Internal;
using UnityEngine.Rendering;

namespace UnityEditor
{
    [NativeHeader("Editor/Src/Handles/Handles.bindings.h")]
    public sealed class Handles
    {
        public Handles();

        [NativeProperty("handles::g_HandleLighting", True, Field)]
        public static bool lighting { get; set; }
        [NativeProperty("handles::g_HandleColor", True, Field)]
        public static Color color { get; set; }
        [NativeProperty("handles::g_HandleZTest", True, Field)]
        public static CompareFunction zTest { get; set; }
        public static Matrix4x4 matrix { get; set; }
        [NativeProperty("handles::g_HandleInverseMatrix", True, Field)]
        public static Matrix4x4 inverseMatrix { get; }
        public static Color xAxisColor { get; }
        public static Color yAxisColor { get; }
        public static Color zAxisColor { get; }
        public static Color centerColor { get; }
        public static Color selectedColor { get; }
        public static Color preselectionColor { get; }
        public static Color secondaryColor { get; }
        public static float lineThickness { get; }
        public Camera currentCamera { get; set; }

        public static void DrawPolyLine(params Vector3[] points);
        [ExcludeFromDocs]
        public static void DrawLine(Vector3 p1, Vector3 p2);
        public static void DrawLine(Vector3 p1, Vector3 p2, [DefaultValue("0.0f")] float thickness);
        public static void DrawLines(Vector3[] lineSegments);
        public static void DrawLines(Vector3[] points, int[] segmentIndices);
        public static void DrawDottedLine(Vector3 p1, Vector3 p2, float screenSpaceSize);
        public static void DrawDottedLines(Vector3[] lineSegments, float screenSpaceSize);
        public static void DrawDottedLines(Vector3[] points, int[] segmentIndices, float screenSpaceSize);
        public static void DrawWireCube(Vector3 center, Vector3 size);
        public static bool ShouldRenderGizmos();
        public static void DrawGizmos(Camera camera);
        public static Quaternion Disc(int id, Quaternion rotation, Vector3 position, Vector3 axis, float size, bool cutoffPlane, float snap);
        public static Quaternion FreeRotateHandle(int id, Quaternion rotation, Vector3 position, float size);
        public static Vector3 Slider(Vector3 position, Vector3 direction);
        public static Vector3 Slider(Vector3 position, Vector3 direction, float size, CapFunction capFunction, float snap);
        public static Vector3 Slider(int controlID, Vector3 position, Vector3 direction, float size, CapFunction capFunction, float snap);
        public static Vector3 Slider(int controlID, Vector3 position, Vector3 offset, Vector3 direction, float size, CapFunction capFunction, float snap);
        public static Vector3 FreeMoveHandle(Vector3 position, Quaternion rotation, float size, Vector3 snap, CapFunction capFunction);
        public static Vector3 FreeMoveHandle(int controlID, Vector3 position, Quaternion rotation, float size, Vector3 snap, CapFunction capFunction);
        public static float ScaleValueHandle(float value, Vector3 position, Quaternion rotation, float size, CapFunction capFunction, float snap);
        public static float ScaleValueHandle(int controlID, float value, Vector3 position, Quaternion rotation, float size, CapFunction capFunction, float snap);
        public static bool Button(Vector3 position, Quaternion direction, float size, float pickSize, CapFunction capFunction);
        public static void CubeHandleCap(int controlID, Vector3 position, Quaternion rotation, float size, EventType eventType);
        public static void SphereHandleCap(int controlID, Vector3 position, Quaternion rotation, float size, EventType eventType);
        public static void ConeHandleCap(int controlID, Vector3 position, Quaternion rotation, float size, EventType eventType);
        public static void CylinderHandleCap(int controlID, Vector3 position, Quaternion rotation, float size, EventType eventType);
        public static void RectangleHandleCap(int controlID, Vector3 position, Quaternion rotation, float size, EventType eventType);
        public static void DotHandleCap(int controlID, Vector3 position, Quaternion rotation, float size, EventType eventType);
        public static void CircleHandleCap(int controlID, Vector3 position, Quaternion rotation, float size, EventType eventType);
        public static void ArrowHandleCap(int controlID, Vector3 position, Quaternion rotation, float size, EventType eventType);
        public static void DrawSelectionFrame(int controlID, Vector3 position, Quaternion rotation, float size, EventType eventType);
        public static Vector3 PositionHandle(Vector3 position, Quaternion rotation);
        public static Quaternion RotationHandle(Quaternion rotation, Vector3 position);
        public static Vector3 ScaleHandle(Vector3 scale, Vector3 position, Quaternion rotation, float size);
        public static float RadiusHandle(Quaternion rotation, Vector3 position, float radius, bool handlesOnly);
        public static float RadiusHandle(Quaternion rotation, Vector3 position, float radius);
        public static Vector3 Slider2D(int id, Vector3 handlePos, Vector3 offset, Vector3 handleDir, Vector3 slideDir1, Vector3 slideDir2, float handleSize, CapFunction capFunction, Vector2 snap);
        public static Vector3 Slider2D(int id, Vector3 handlePos, Vector3 offset, Vector3 handleDir, Vector3 slideDir1, Vector3 slideDir2, float handleSize, CapFunction capFunction, Vector2 snap, [DefaultValue("false")] bool drawHelper);
        public static Vector3 Slider2D(Vector3 handlePos, Vector3 handleDir, Vector3 slideDir1, Vector3 slideDir2, float handleSize, CapFunction capFunction, Vector2 snap);
        public static Vector3 Slider2D(Vector3 handlePos, Vector3 handleDir, Vector3 slideDir1, Vector3 slideDir2, float handleSize, CapFunction capFunction, Vector2 snap, [DefaultValue("false")] bool drawHelper);
        public static Vector3 Slider2D(int id, Vector3 handlePos, Vector3 handleDir, Vector3 slideDir1, Vector3 slideDir2, float handleSize, CapFunction capFunction, Vector2 snap);
        public static Vector3 Slider2D(int id, Vector3 handlePos, Vector3 handleDir, Vector3 slideDir1, Vector3 slideDir2, float handleSize, CapFunction capFunction, Vector2 snap, [DefaultValue("false")] bool drawHelper);
        public static Vector3 Slider2D(Vector3 handlePos, Vector3 handleDir, Vector3 slideDir1, Vector3 slideDir2, float handleSize, CapFunction capFunction, float snap);
        public static Vector3 Slider2D(Vector3 handlePos, Vector3 handleDir, Vector3 slideDir1, Vector3 slideDir2, float handleSize, CapFunction capFunction, float snap, [DefaultValue("false")] bool drawHelper);
        public static Quaternion FreeRotateHandle(Quaternion rotation, Vector3 position, float size);
        public static float ScaleSlider(float scale, Vector3 position, Vector3 direction, Quaternion rotation, float size, float snap);
        public static Quaternion Disc(Quaternion rotation, Vector3 position, Vector3 axis, float size, bool cutoffPlane, float snap);
        public static float SnapValue(float value, float snap);
        public static Vector2 SnapValue(Vector2 value, Vector2 snap);
        public static Vector3 SnapValue(Vector3 value, Vector3 snap);
        public static void SnapToGrid(Transform[] transforms, SnapAxis axis = All);
        public static void SelectionFrame(int controlID, Vector3 position, Quaternion rotation, float size);
        public static void DrawAAPolyLine(params Vector3[] points);
        public static void DrawAAPolyLine(float width, params Vector3[] points);
        public static void DrawAAPolyLine(Texture2D lineTex, params Vector3[] points);
        public static void DrawAAPolyLine(float width, int actualNumberOfPoints, params Vector3[] points);
        public static void DrawAAPolyLine(Texture2D lineTex, float width, params Vector3[] points);
        public static void DrawAAConvexPolygon(params Vector3[] points);
        public static void DrawBezier(Vector3 startPosition, Vector3 endPosition, Vector3 startTangent, Vector3 endTangent, Color color, Texture2D texture, float width);
        [ExcludeFromDocs]
        public static void DrawWireDisc(Vector3 center, Vector3 normal, float radius);
        public static void DrawWireDisc(Vector3 center, Vector3 normal, float radius, [DefaultValue("0.0f")] float thickness);
        [ExcludeFromDocs]
        public static void DrawWireArc(Vector3 center, Vector3 normal, Vector3 from, float angle, float radius);
        public static void DrawWireArc(Vector3 center, Vector3 normal, Vector3 from, float angle, float radius, [DefaultValue("0.0f")] float thickness);
        public static void DrawSolidRectangleWithOutline(Rect rectangle, Color faceColor, Color outlineColor);
        public static void DrawSolidRectangleWithOutline(Vector3[] verts, Color faceColor, Color outlineColor);
        public static void DrawSolidDisc(Vector3 center, Vector3 normal, float radius);
        public static void DrawSolidArc(Vector3 center, Vector3 normal, Vector3 from, float angle, float radius);
        public static void Label(Vector3 position, string text);
        public static void Label(Vector3 position, Texture image);
        public static void Label(Vector3 position, GUIContent content);
        public static void Label(Vector3 position, string text, GUIStyle style);
        public static void Label(Vector3 position, GUIContent content, GUIStyle style);
        public static Vector2 GetMainGameViewSize();
        public static void ClearCamera(Rect position, Camera camera);
        public static void DrawCamera(Rect position, Camera camera);
        public static void DrawCamera(Rect position, Camera camera, [DefaultValue("UnityEditor.DrawCameraMode.Normal")] DrawCameraMode drawMode);
        public static void DrawCamera(Rect position, Camera camera, [DefaultValue("UnityEditor.DrawCameraMode.Normal")] DrawCameraMode drawMode, bool drawGizmos);
        public static void SetCamera(Camera camera);
        public static void SetCamera(Rect position, Camera camera);
        public static void BeginGUI();
        [Obsolete("Please use BeginGUI() with GUILayout.BeginArea(position) / GUILayout.EndArea()")]
        public static void BeginGUI(Rect position);
        public static void EndGUI();
        public static Vector3[] MakeBezierPoints(Vector3 startPosition, Vector3 endPosition, Vector3 startTangent, Vector3 endTangent, int division);
        public static void DrawTexture3DSDF(Texture texture, [DefaultValue("1.0f")] float stepScale = 1, [DefaultValue("0.0f")] float surfaceOffset = 0, [DefaultValue("null")] Gradient customColorRamp = null);
        public static void DrawTexture3DSlice(Texture texture, Vector3 slicePositions, [DefaultValue("FilterMode.Bilinear")] FilterMode filterMode = Bilinear, [DefaultValue("false")] bool useColorRamp = False, [DefaultValue("null")] Gradient customColorRamp = null);
        public static void DrawTexture3DVolume(Texture texture, [DefaultValue("1.0f")] float opacity = 1, [DefaultValue("1.0f")] float qualityModifier = 1, [DefaultValue("FilterMode.Bilinear")] FilterMode filterMode = Bilinear, [DefaultValue("false")] bool useColorRamp = False, [DefaultValue("null")] Gradient customColorRamp = null);
        public static Vector3 DoPositionHandle(Vector3 position, Quaternion rotation);
        public static Quaternion DoRotationHandle(Quaternion rotation, Vector3 position);
        public static Vector3 DoScaleHandle(Vector3 scale, Vector3 position, Quaternion rotation, float size);
        public static void TransformHandle(ref Vector3 position, ref Quaternion rotation, ref Vector3 scale);
        public static void TransformHandle(ref Vector3 position, Quaternion rotation, ref Vector3 scale);
        public static void TransformHandle(Vector3 position, ref Quaternion rotation, ref Vector3 scale);
        public static void TransformHandle(ref Vector3 position, ref Quaternion rotation, ref float uniformScale);
        public static void TransformHandle(ref Vector3 position, Quaternion rotation, ref float uniformScale);
        public static void TransformHandle(Vector3 position, ref Quaternion rotation, ref float uniformScale);
        public static void TransformHandle(ref Vector3 position, ref Quaternion rotation);

        public struct DrawingScope : IDisposable
        {
            public DrawingScope(Color color);
            public DrawingScope(Matrix4x4 matrix);
            public DrawingScope(Color color, Matrix4x4 matrix);

            public Color originalColor { get; }
            public Matrix4x4 originalMatrix { get; }

            public void Dispose();
        }
        public delegate void CapFunction(int controlID, Vector3 position, Quaternion rotation, float size, EventType eventType);
        public delegate float SizeFunction(Vector3 position);
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Editor/Mono/HandleUtility.bindings.h")]
    [StaticAccessor("HandleUtilityBindings", DoubleColon)]
    public sealed class HandleUtility
    {
        public HandleUtility();

        public static float acceleration { get; }
        public static float niceMouseDelta { get; }
        public static float niceMouseDeltaZoom { get; }
        public static int nearestControl { get; set; }
        public static Material handleMaterial { get; }

        public static event PickGameObjectCallback pickGameObjectCustomPasses;
        public static event PlaceObjectDelegate placeObjectCustomPasses;

        public static float DistancePointBezier(Vector3 point, Vector3 startPosition, Vector3 endPosition, Vector3 startTangent, Vector3 endTangent);
        public static float CalcLineTranslation(Vector2 src, Vector2 dest, Vector3 srcPosition, Vector3 constraintDir);
        public static float PointOnLineParameter(Vector3 point, Vector3 linePoint, Vector3 lineDirection);
        public static Vector3 ProjectPointLine(Vector3 point, Vector3 lineStart, Vector3 lineEnd);
        public static float DistancePointLine(Vector3 point, Vector3 lineStart, Vector3 lineEnd);
        public static float DistanceToLine(Vector3 p1, Vector3 p2);
        public static float DistanceToCircle(Vector3 position, float radius);
        public static float DistanceToCone(Vector3 position, Quaternion rotation, float size);
        public static float DistanceToCube(Vector3 position, Quaternion rotation, float size);
        public static float DistanceToRectangle(Vector3 position, Quaternion rotation, float size);
        public static float DistancePointToLine(Vector2 p, Vector2 a, Vector2 b);
        public static float DistancePointToLineSegment(Vector2 p, Vector2 a, Vector2 b);
        public static float DistanceToDisc(Vector3 center, Vector3 normal, float radius);
        public static Vector3 ClosestPointToDisc(Vector3 center, Vector3 normal, float radius);
        public static float DistanceToArc(Vector3 center, Vector3 normal, Vector3 from, float angle, float radius);
        public static Vector3 ClosestPointToArc(Vector3 center, Vector3 normal, Vector3 from, float angle, float radius);
        public static float DistanceToPolyLine(params Vector3[] points);
        public static Vector3 ClosestPointToPolyLine(params Vector3[] vertices);
        public static void AddControl(int controlId, float distance);
        public static void AddDefaultControl(int controlId);
        public static float GetHandleSize(Vector3 position);
        public static Vector2 WorldToGUIPoint(Vector3 world);
        public static Vector3 WorldToGUIPointWithDepth(Vector3 world);
        public static Vector2 GUIPointToScreenPixelCoordinate(Vector2 guiPoint);
        public static Ray GUIPointToWorldRay(Vector2 position);
        public static Rect WorldPointToSizedRect(Vector3 position, GUIContent content, GUIStyle style);
        public static GameObject[] PickRectObjects(Rect rect);
        public static GameObject[] PickRectObjects(Rect rect, bool selectPrefabRootsOnly);
        public static bool FindNearestVertex(Vector2 guiPoint, out Vector3 vertex);
        public static bool FindNearestVertex(Vector2 guiPoint, Transform[] objectsToSearch, out Vector3 vertex);
        public static bool FindNearestVertex(Vector2 guiPoint, Transform[] objectsToSearch, Transform[] objectsToIgnore, out Vector3 vertex);
        public static GameObject PickGameObject(Vector2 position, out int materialIndex);
        public static GameObject PickGameObject(Vector2 position, GameObject[] ignore, out int materialIndex);
        public static GameObject PickGameObject(Vector2 position, bool selectPrefabRoot);
        public static GameObject PickGameObject(Vector2 position, bool selectPrefabRoot, GameObject[] ignore);
        public static GameObject PickGameObject(Vector2 position, bool selectPrefabRoot, GameObject[] ignore, GameObject[] filter);
        public static void PushCamera(Camera camera);
        public static void PopCamera(Camera camera);
        public static object RaySnap(Ray ray);
        public static bool PlaceObject(Vector2 guiPosition, out Vector3 position, out Vector3 normal);
        public static void Repaint();

        public delegate GameObject PickGameObjectCallback(Camera cam, int layers, Vector2 position, GameObject[] ignore, GameObject[] filter, out int materialIndex);
        public delegate bool PlaceObjectDelegate(Vector2 guiPosition, out Vector3 position, out Vector3 normal);
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Editor/Src/Panels/HelpPanel.h")]
    [NativeHeader("Editor/Platform/Interface/EditorUtility.h")]
    [NativeHeader("Editor/Src/Utility/DocUtilities.h")]
    public class Help
    {
        public Help();

        public static bool HasHelpForObject(Object obj);
        public static string GetHelpURLForObject(Object obj);
        public static void ShowHelpForObject(Object obj);
        public static void ShowHelpPage(string page);
        public static void BrowseURL(string url);
    }
}
namespace UnityEditor
{
    public enum InspectorMode
    {
        Normal = 0,
        Debug = 1,
        DebugInternal = 2
    }
}
namespace UnityEditor
{
    public enum HierarchyType
    {
        Assets = 1,
        GameObjects = 2
    }
}
namespace UnityEditor
{
    public enum IconDrawStyle
    {
        NonTexture = 0,
        Texture = 1
    }
}
using UnityEditor.SceneManagement;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.SceneManagement;

namespace UnityEditor
{
    [NativeHeader("Editor/Src/Utility/HierarchyProperty.bindings.h")]
    public sealed class HierarchyProperty : IHierarchyProperty
    {
        public HierarchyProperty(HierarchyType hierarchyType);
        public HierarchyProperty(HierarchyType hierarchyType, bool forceImport);
        public HierarchyProperty(string rootPath);
        public HierarchyProperty(string rootPath, bool forceImport);
        public HierarchyProperty(HierarchyType hierarchyType, string rootPath, bool forceImport);

        ~HierarchyProperty();

        public int instanceID { get; }
        public Object pptrValue { get; }
        public string name { get; }
        public bool hasChildren { get; }
        public int depth { get; }
        public int[] ancestors { get; }
        public int row { get; }
        public int colorCode { get; }
        public string guid { get; }
        public bool alphaSorted { get; set; }
        public bool showSceneHeaders { get; set; }
        public bool isSceneHeader { get; }
        public bool isValid { get; }
        public bool isMainRepresentation { get; }
        public bool hasFullPreviewImage { get; }
        public IconDrawStyle iconDrawStyle { get; }
        public bool isFolder { get; }
        public GUID[] dynamicDependencies { get; }
        public Texture2D icon { get; }

        [FreeFunction("HierarchyPropertyBindings::SetCustomScenes", HasExplicitThis = True)]
        public void SetCustomScenes([NotNull("ArgumentNullException")] int[] sceneHandles);
        [FreeFunction("HierarchyPropertyBindings::SetSubScenes", HasExplicitThis = True)]
        public void SetSubScenes([NotNull("ArgumentNullException")] SceneHierarchyHooks.SubSceneInfo[] subScenes);
        public void Reset();
        [FreeFunction("HierarchyPropertyBindings::GetScene", HasExplicitThis = True, ThrowsException = True)]
        public Scene GetScene();
        [FreeFunction("HierarchyPropertyBindings::IsExpanded", HasExplicitThis = True)]
        public bool IsExpanded(int[] expanded);
        [FreeFunction("HierarchyPropertyBindings::Next", HasExplicitThis = True)]
        public bool Next(int[] expanded);
        [FreeFunction("HierarchyPropertyBindings::NextWithDepthCheck", HasExplicitThis = True)]
        public bool NextWithDepthCheck(int[] expanded, int minDepth);
        [FreeFunction("HierarchyPropertyBindings::Previous", HasExplicitThis = True)]
        public bool Previous(int[] expanded);
        public bool Parent();
        [FreeFunction("HierarchyPropertyBindings::Find", HasExplicitThis = True)]
        public bool Find(int instanceID, int[] expanded);
        [FreeFunction("HierarchyPropertyBindings::Skip", HasExplicitThis = True)]
        public bool Skip(int count, int[] expanded);
        [FreeFunction("HierarchyPropertyBindings::CountRemaining", HasExplicitThis = True)]
        public int CountRemaining(int[] expanded);
        public int GetInstanceIDIfImported();
        public void SetSearchFilter(string searchString, int mode);
        [FreeFunction("HierarchyPropertyBindings::FindAllAncestors", HasExplicitThis = True)]
        public int[] FindAllAncestors(int[] instanceIDs);
        [FreeFunction("HierarchyPropertyBindings::ClearSceneObjectsFilter")]
        public static void ClearSceneObjectsFilter();
        [FreeFunction("HierarchyPropertyBindings::FilterSingleSceneObject")]
        public static void FilterSingleSceneObject(int instanceID, bool otherVisibilityState);
    }
}
namespace UnityEditor
{
    public interface IHasCustomMenu
    {
        void AddItemsToMenu(GenericMenu menu);
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Editor/Mono/LODUtility.bindings.h")]
    public sealed class LODUtility
    {
        public LODUtility();

        public static void CalculateLODGroupBoundingBox(LODGroup group);
    }
}
using System;
using UnityEngine;
using UnityEngine.Rendering;

namespace UnityEditor
{
    public sealed class MaterialProperty
    {
        public MaterialProperty();

        public UnityEngine.Object[] targets { get; }
        public PropType type { get; }
        public string name { get; }
        public string displayName { get; }
        public PropFlags flags { get; }
        public TextureDimension textureDimension { get; }
        public Vector2 rangeLimits { get; }
        public bool hasMixedValue { get; }
        public ApplyPropertyCallback applyPropertyCallback { get; set; }
        public Color colorValue { get; set; }
        public Vector4 vectorValue { get; set; }
        public float floatValue { get; set; }
        public Texture textureValue { get; set; }
        public Vector4 textureScaleAndOffset { get; set; }

        public void ReadFromMaterialPropertyBlock(MaterialPropertyBlock block);
        public void WriteToMaterialPropertyBlock(MaterialPropertyBlock materialblock, int changedPropertyMask);

        public delegate bool ApplyPropertyCallback(MaterialProperty prop, int changeMask, object previousValue);
        public enum PropType
        {
            Color = 0,
            Vector = 1,
            Float = 2,
            Range = 3,
            Texture = 4
        }
        [Flags]
        public enum PropFlags
        {
            None = 0,
            HideInInspector = 1,
            PerRendererData = 2,
            NoScaleOffset = 4,
            Normal = 8,
            HDR = 16,
            Gamma = 32,
            NonModifiableTextureData = 64
        }
        [Obsolete("Use UnityEngine.Rendering.TextureDimension instead.", False)]
        public enum TexDim
        {
            Unknown = -1,
            None = 0,
            Tex2D = 2,
            Tex3D = 3,
            Cube = 4,
            Any = 6
        }
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Editor/Src/MenuController.h")]
    public sealed class Menu
    {
        public Menu();

        [NativeMethod("MenuController::SetChecked", True)]
        public static void SetChecked(string menuPath, bool isChecked);
        [NativeMethod("MenuController::GetChecked", True)]
        public static bool GetChecked(string menuPath);
        [NativeMethod("MenuController::GetEnabled", True)]
        public static bool GetEnabled(string menuPath);
    }
}
using UnityEngine;
using UnityEngine.Scripting;

namespace UnityEditor
{
    [RequiredByNativeCode]
    public sealed class MenuCommand
    {
        public Object context;
        public int userData;

        public MenuCommand(Object inContext, int inUserData);
        public MenuCommand(Object inContext);
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEditor
{
    [RequiredByNativeCode]
    [AttributeUsage(Method, AllowMultiple = True)]
    public sealed class MenuItem : Attribute
    {
        public string menuItem;
        public bool validate;
        public int priority;

        public MenuItem(string itemName);
        public MenuItem(string itemName, bool isValidateFunction);
        public MenuItem(string itemName, bool isValidateFunction, int priority);
    }
}
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [StaticAccessor("MeshUtility", DoubleColon)]
    [NativeHeader("Runtime/Graphics/Texture.h")]
    [NativeHeader("Runtime/Graphics/Mesh/MeshOptimizer.h")]
    [NativeHeader("Editor/Mono/MeshUtility.bindings.h")]
    public class MeshUtility
    {
        public MeshUtility();

        public static void Optimize(Mesh mesh);
        public static void SetMeshCompression(Mesh mesh, ModelImporterMeshCompression compression);
        public static ModelImporterMeshCompression GetMeshCompression(Mesh mesh);
        public static void SetPerTriangleUV2(Mesh src, Vector2[] triUV);
        public static Mesh.MeshDataArray AcquireReadOnlyMeshData(Mesh mesh);
        public static Mesh.MeshDataArray AcquireReadOnlyMeshData(Mesh[] meshes);
        public static Mesh.MeshDataArray AcquireReadOnlyMeshData(List<Mesh> meshes);
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeClass(null)]
    [NativeType("Editor/Mono/MonoScript.bindings.h")]
    [ExcludeFromPreset]
    public class MonoScript : TextAsset
    {
        public MonoScript();

        public Type GetClass();
        public static MonoScript FromMonoBehaviour(MonoBehaviour behaviour);
        public static MonoScript FromScriptableObject(ScriptableObject scriptableObject);
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.SceneManagement;

namespace UnityEditor
{
    [NativeHeader("Editor/Src/ObjectFactory.h")]
    public static class ObjectFactory
    {
        public static event Action<Component> componentWasAdded;

        public static T CreateInstance<T>() where T : UnityEngine.Object;
        public static UnityEngine.Object CreateInstance(Type type);
        public static T AddComponent<T>(GameObject gameObject) where T : Component;
        public static Component AddComponent(GameObject gameObject, Type type);
        public static GameObject CreateGameObject(Scene scene, HideFlags hideFlags, string name, params Type[] types);
        public static GameObject CreateGameObject(string name, params Type[] types);
        public static GameObject CreatePrimitive(PrimitiveType type);
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Editor/Src/Utility/ObjectNames.bindings.h")]
    public sealed class ObjectNames
    {
        public ObjectNames();

        [FreeFunction("NicifyVariableName_Internal")]
        public static string NicifyVariableName(string name);
        [FreeFunction("GetClassName_Internal")]
        public static string GetClassName([NotNull("NullExceptionObject")] UnityEngine.Object obj);
        [FreeFunction]
        public static string GetDragAndDropTitle(UnityEngine.Object obj);
        [FreeFunction("SetObjectNameSmart")]
        public static void SetNameSmart(UnityEngine.Object obj, string name);
        [FreeFunction("GetUniqueName_Internal")]
        public static string GetUniqueName(string[] existingNames, string name);
        public static string GetInspectorTitle(UnityEngine.Object obj);
        [Obsolete("Please use NicifyVariableName instead")]
        public static string MangleVariableName(string name);
        [Obsolete("Please use GetInspectorTitle instead")]
        public static string GetPropertyEditorTitle(UnityEngine.Object obj);
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType(Custom, "MonoPackageInfo", Header = "Editor/Src/PackageUtility.h")]
    public struct PackageInfo
    {
        public string packagePath;
        public string jsonInfo;
        public string iconURL;
    }
}
using System;

namespace UnityEditor
{
    [Obsolete("The Display Resolution Dialog has been removed.", False)]
    public enum ResolutionDialogSetting
    {
        Disabled = 0,
        Enabled = 1,
        HiddenByDefault = 2
    }
}
namespace UnityEditor
{
    public enum ScriptingImplementation
    {
        Mono2x = 0,
        IL2CPP = 1,
        WinRTDotNET = 2
    }
}
namespace UnityEditor
{
    public enum Il2CppCompilerConfiguration
    {
        Debug = 0,
        Release = 1,
        Master = 2
    }
}
namespace UnityEditor
{
    public enum AspectRatio
    {
        AspectOthers = 0,
        Aspect4by3 = 1,
        Aspect5by4 = 2,
        Aspect16by10 = 3,
        Aspect16by9 = 4
    }
}
using System;

namespace UnityEditor
{
    public enum MacFullscreenMode
    {
        [Obsolete("Capture Display mode is deprecated, Use FullscreenWindow instead")]
        CaptureDisplay = 0,
        FullscreenWindow = 1,
        FullscreenWindowWithDockAndMenuBar = 2
    }
}
using System;

namespace UnityEditor
{
    [Obsolete("D3D9 support has been removed")]
    public enum D3D9FullscreenMode
    {
        [Obsolete("D3D9 support has been removed")]
        ExclusiveMode = 0,
        [Obsolete("D3D9 support has been removed")]
        FullscreenWindow = 1
    }
}
namespace UnityEditor
{
    public enum D3D11FullscreenMode
    {
        ExclusiveMode = 0,
        FullscreenWindow = 1
    }
}
namespace UnityEditor
{
    public enum StereoRenderingPath
    {
        MultiPass = 0,
        SinglePass = 1,
        Instancing = 2
    }
}
namespace UnityEditor
{
    public enum StrippingLevel
    {
        Disabled = 0,
        StripAssemblies = 1,
        StripByteCode = 2,
        UseMicroMSCorlib = 3
    }
}
namespace UnityEditor
{
    public enum ScriptCallOptimizationLevel
    {
        SlowAndSafe = 0,
        FastButNoExceptions = 1
    }
}
namespace UnityEditor
{
    public enum UIOrientation
    {
        Portrait = 0,
        PortraitUpsideDown = 1,
        LandscapeRight = 2,
        LandscapeLeft = 3,
        AutoRotation = 4
    }
}
using System;

namespace UnityEditor
{
    [Obsolete("ScriptingRuntimeVersion has been deprecated in 2019.3 now that legacy mono has been removed")]
    public enum ScriptingRuntimeVersion
    {
        Legacy = 0,
        Latest = 1
    }
}
namespace UnityEditor
{
    public enum ApiCompatibilityLevel
    {
        NET_2_0 = 1,
        NET_2_0_Subset = 2,
        NET_4_6 = 3,
        NET_Web = 4,
        NET_Micro = 5,
        NET_Standard_2_0 = 6
    }
}
namespace UnityEditor
{
    public enum ManagedStrippingLevel
    {
        Disabled = 0,
        Low = 1,
        Medium = 2,
        High = 3
    }
}
namespace UnityEditor
{
    public enum ActionOnDotNetUnhandledException
    {
        SilentExit = 0,
        Crash = 1
    }
}
using System;

namespace UnityEditor
{
    [Obsolete("SplashScreenStyle deprecated, Use PlayerSettings.SplashScreen.UnityLogoStyle instead")]
    public enum SplashScreenStyle
    {
        Light = 0,
        Dark = 1
    }
}
namespace UnityEditor
{
    public enum GraphicsJobMode
    {
        Native = 0,
        Legacy = 1
    }
}
namespace UnityEditor
{
    public enum IconKind
    {
        Any = -1,
        Application = 0,
        Settings = 1,
        Notification = 2,
        Spotlight = 3,
        Store = 4
    }
}
namespace UnityEditor
{
    public enum ShaderPrecisionModel
    {
        PlatformDefault = 0,
        Unified = 1
    }
}
namespace UnityEditor
{
    public enum NormalMapEncoding
    {
        XYZ = 0,
        DXT5nm = 1
    }
}
using System;
using System.ComponentModel;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Internal;
using UnityEngine.iOS;
using UnityEngine.Rendering;
using UnityEngine.Scripting;

namespace UnityEditor
{
    [StaticAccessor("GetPlayerSettings()")]
    [NativeHeader("Runtime/Misc/PlayerSettingsSplashScreen.h")]
    [NativeHeader("Runtime/Misc/PlayerSettings.h")]
    [NativeHeader("Runtime/Misc/BuildSettings.h")]
    [NativeHeader("Editor/Mono/PlayerSettings.bindings.h")]
    [NativeClass(null)]
    [NativeHeader("Runtime/Misc/PlayerSettings.h")]
    public sealed class PlayerSettings : UnityEngine.Object
    {
        public static string companyName { get; set; }
        public static string productName { get; set; }
        [Obsolete("Use PlayerSettings.SplashScreen.show instead")]
        [StaticAccessor("GetPlayerSettings().GetSplashScreenSettings()")]
        public static bool showUnitySplashScreen { get; set; }
        [Obsolete("Use PlayerSettings.SplashScreen.unityLogoStyle instead")]
        [StaticAccessor("GetPlayerSettings().GetSplashScreenSettings()")]
        [NativeProperty("SplashScreenLogoStyle")]
        public static SplashScreenStyle splashScreenStyle { get; set; }
        [Obsolete("cloudProjectId is deprecated, use CloudProjectSettings.projectId instead")]
        public static string cloudProjectId { get; }
        public static Guid productGUID { get; }
        public static ColorSpace colorSpace { get; set; }
        public static int defaultScreenWidth { get; set; }
        public static int defaultScreenHeight { get; set; }
        public static int defaultWebScreenWidth { get; set; }
        public static int defaultWebScreenHeight { get; set; }
        [Obsolete("displayResolutionDialog has been removed.", False)]
        public static ResolutionDialogSetting displayResolutionDialog { get; set; }
        [Obsolete("(defaultIsFullScreen is deprecated, use fullScreenMode instead")]
        [StaticAccessor("PlayerSettingsBindings", DoubleColon)]
        public static bool defaultIsFullScreen { get; set; }
        public static bool defaultIsNativeResolution { get; set; }
        public static bool macRetinaSupport { get; set; }
        public static bool runInBackground { get; set; }
        public static bool captureSingleScreen { get; set; }
        public static bool usePlayerLog { get; set; }
        public static bool resizableWindow { get; set; }
        public static bool resetResolutionOnWindowResize { get; set; }
        public static bool bakeCollisionMeshes { get; set; }
        public static bool useMacAppStoreValidation { get; set; }
        [Obsolete("macFullscreenMode is deprecated, use fullScreenMode instead")]
        [StaticAccessor("PlayerSettingsBindings", DoubleColon)]
        public static MacFullscreenMode macFullscreenMode { get; set; }
        [StaticAccessor("PlayerSettingsBindings", DoubleColon)]
        [Obsolete("d3d9FullscreenMode is deprecated, use fullScreenMode instead")]
        public static D3D9FullscreenMode d3d9FullscreenMode { get; set; }
        [StaticAccessor("PlayerSettingsBindings", DoubleColon)]
        [Obsolete("d3d11FullscreenMode is deprecated, use fullScreenMode instead")]
        public static D3D11FullscreenMode d3d11FullscreenMode { get; set; }
        [NativeProperty("FullscreenMode")]
        public static FullScreenMode fullScreenMode { get; set; }
        [StaticAccessor("PlayerSettingsBindings", DoubleColon)]
        [Obsolete("This API is obsolete, and should no longer be used. Please use XRManagerSettings in the XR Management package instead.")]
        public static bool virtualRealitySupported { get; set; }
        public static bool enable360StereoCapture { get; set; }
        [Obsolete("singlePassStereoRendering will be deprecated. Use stereoRenderingPath instead.")]
        public static bool singlePassStereoRendering { get; set; }
        public static StereoRenderingPath stereoRenderingPath { get; set; }
        [Obsolete("protectGraphicsMemory is deprecated. This field has no effect.", False)]
        public static bool protectGraphicsMemory { get; set; }
        public static bool enableFrameTimingStats { get; set; }
        public static bool useHDRDisplay { get; set; }
        public static D3DHDRDisplayBitDepth D3DHDRBitDepth { get; set; }
        public static bool visibleInBackground { get; set; }
        public static bool allowFullscreenSwitch { get; set; }
        public static bool forceSingleInstance { get; set; }
        public static bool useFlipModelSwapchain { get; set; }
        [NativeProperty(TargetType = Field)]
        public static bool openGLRequireES31 { get; set; }
        [NativeProperty(TargetType = Field)]
        public static bool openGLRequireES31AEP { get; set; }
        [NativeProperty(TargetType = Field)]
        public static bool openGLRequireES32 { get; set; }
        [Obsolete("resolutionDialogBanner has been removed.", False)]
        public static Texture2D resolutionDialogBanner { get; set; }
        [StaticAccessor("GetPlayerSettings().GetSplashScreenSettings()")]
        public static Texture2D virtualRealitySplashScreen { get; set; }
        [Obsolete("iPhoneBundleIdentifier is deprecated. Use PlayerSettings.SetApplicationIdentifier(BuildTargetGroup.iOS) instead.")]
        public static string iPhoneBundleIdentifier { get; set; }
        public static bool assemblyVersionValidation { get; set; }
        [Obsolete("ScriptingRuntimeVersion has been deprecated in 2019.3 due to the removal of legacy mono")]
        public static ScriptingRuntimeVersion scriptingRuntimeVersion { get; set; }
        public static bool suppressCommonWarnings { get; set; }
        public static bool allowUnsafeCode { get; set; }
        public static bool useReferenceAssemblies { get; set; }
        public static bool gcIncremental { get; set; }
        public static string keystorePass { get; set; }
        public static string keyaliasPass { get; set; }
        [Obsolete("Xbox 360 has been removed in >=5.5")]
        public static string xboxTitleId { get; set; }
        [Obsolete("Xbox 360 has been removed in >=5.5")]
        public static string xboxImageXexFilePath { get; }
        [Obsolete("Xbox 360 has been removed in >=5.5")]
        public static string xboxSpaFilePath { get; }
        [Obsolete("Xbox 360 has been removed in >=5.5")]
        public static bool xboxGenerateSpa { get; }
        [Obsolete("Xbox 360 has been removed in >=5.5")]
        public static bool xboxEnableGuest { get; }
        [Obsolete("Xbox 360 has been removed in >=5.5")]
        public static bool xboxDeployKinectResources { get; }
        [Obsolete("Xbox 360 has been removed in >=5.5")]
        public static bool xboxDeployKinectHeadOrientation { get; set; }
        [Obsolete("Xbox 360 has been removed in >=5.5")]
        public static bool xboxDeployKinectHeadPosition { get; set; }
        [Obsolete("Xbox 360 has been removed in >=5.5")]
        public static Texture2D xboxSplashScreen { get; }
        [Obsolete("Xbox 360 has been removed in >=5.5")]
        public static int xboxAdditionalTitleMemorySize { get; set; }
        [Obsolete("Xbox 360 has been removed in >=5.5")]
        public static bool xboxEnableKinect { get; }
        [Obsolete("Xbox 360 has been removed in >=5.5")]
        public static bool xboxEnableKinectAutoTracking { get; }
        [Obsolete("Xbox 360 has been removed in >=5.5")]
        public static bool xboxEnableSpeech { get; }
        [Obsolete("Xbox 360 has been removed in >=5.5")]
        public static uint xboxSpeechDB { get; }
        [NativeProperty("GPUSkinning")]
        public static bool gpuSkinning { get; set; }
        public static bool graphicsJobs { get; set; }
        public static GraphicsJobMode graphicsJobMode { get; set; }
        public static bool xboxPIXTextureCapture { get; }
        public static bool xboxEnableAvatar { get; }
        public static int xboxOneResolution { get; }
        public static bool enableInternalProfiler { get; set; }
        public static ActionOnDotNetUnhandledException actionOnDotNetUnhandledException { get; set; }
        public static bool logObjCUncaughtExceptions { get; set; }
        public static bool enableCrashReportAPI { get; set; }
        public static string applicationIdentifier { get; set; }
        [NativeProperty("ApplicationVersion")]
        public static string bundleVersion { get; set; }
        [NativeProperty("UIStatusBarHidden")]
        public static bool statusBarHidden { get; set; }
        [StaticAccessor("PlayerSettingsBindings", DoubleColon)]
        [Obsolete("strippingLevel is deprecated, Use PlayerSettings.GetManagedStrippingLevel()/PlayerSettings.SetManagedStrippingLevel() instead. StripByteCode and UseMicroMSCorlib are no longer supported.")]
        public static StrippingLevel strippingLevel { get; set; }
        public static bool stripEngineCode { get; set; }
        [NativeProperty("DefaultScreenOrientation")]
        public static UIOrientation defaultInterfaceOrientation { get; set; }
        [StaticAccessor("PlayerSettingsBindings", DoubleColon)]
        public static bool allowedAutorotateToPortrait { get; set; }
        [StaticAccessor("PlayerSettingsBindings", DoubleColon)]
        public static bool allowedAutorotateToPortraitUpsideDown { get; set; }
        [StaticAccessor("PlayerSettingsBindings", DoubleColon)]
        public static bool allowedAutorotateToLandscapeRight { get; set; }
        [StaticAccessor("PlayerSettingsBindings", DoubleColon)]
        public static bool allowedAutorotateToLandscapeLeft { get; set; }
        [NativeProperty("UseAnimatedAutoRotation")]
        public static bool useAnimatedAutorotation { get; set; }
        public static bool use32BitDisplayBuffer { get; set; }
        public static bool preserveFramebufferAlpha { get; set; }
        [Obsolete("apiCompatibilityLevel is deprecated. Use PlayerSettings.GetApiCompatibilityLevel()/PlayerSettings.SetApiCompatibilityLevel() instead.")]
        public static ApiCompatibilityLevel apiCompatibilityLevel { get; set; }
        public static bool stripUnusedMeshComponents { get; set; }
        public static bool mipStripping { get; set; }
        [NativeProperty("hasAdvancedVersion", Field)]
        [StaticAccessor("GetBuildSettings()")]
        public static bool advancedLicense { get; }
        public static string aotOptions { get; set; }
        public static Texture2D defaultCursor { get; set; }
        public static Vector2 cursorHotspot { get; set; }
        public static int accelerometerFrequency { get; set; }
        public static bool MTRendering { get; set; }
        [Obsolete("Use UnityEditor.PlayerSettings.SetGraphicsAPIs/GetGraphicsAPIs instead")]
        public static bool useDirect3D11 { get; set; }
        [StaticAccessor("PlayerSettingsBindings", DoubleColon)]
        [Obsolete("Use VREditor.GetStereoDeviceEnabled instead")]
        public static bool stereoscopic3D { get; set; }
        public static bool muteOtherAudioSources { get; set; }
        public static bool legacyClampBlendShapeWeights { get; set; }
        [NativeProperty("MetalAPIValidation")]
        public static bool enableMetalAPIValidation { get; set; }
        [Obsolete("The option alwaysDisplayWatermark is deprecated and is always false", True)]
        [EditorBrowsable(Never)]
        public static bool alwaysDisplayWatermark { get; set; }
        [Obsolete("Use AssetBundles instead for streaming data", True)]
        [EditorBrowsable(Never)]
        public static int firstStreamedLevelWithResources { get; set; }
        [Obsolete("targetGlesGraphics is ignored, use SetGraphicsAPIs/GetGraphicsAPIs APIs", False)]
        public static TargetGlesGraphics targetGlesGraphics { get; set; }
        [Obsolete("targetIOSGraphics is ignored, use SetGraphicsAPIs/GetGraphicsAPIs APIs", False)]
        public static TargetIOSGraphics targetIOSGraphics { get; set; }
        [Obsolete("Use PlayerSettings.iOS.locationUsageDescription instead (UnityUpgradable) -> UnityEditor.PlayerSettings/iOS.locationUsageDescription", False)]
        public static string locationUsageDescription { get; set; }
        [Obsolete("renderingPath is ignored, use UnityEditor.Rendering.TierSettings with UnityEditor.Rendering.SetTierSettings/GetTierSettings instead", False)]
        public static RenderingPath renderingPath { get; set; }
        [Obsolete("mobileRenderingPath is ignored, use UnityEditor.Rendering.TierSettings with UnityEditor.Rendering.SetTierSettings/GetTierSettings instead", False)]
        public static RenderingPath mobileRenderingPath { get; set; }
        [Obsolete("Use PlayerSettings.applicationIdentifier instead (UnityUpgradable) -> UnityEditor.PlayerSettings.applicationIdentifier", True)]
        [EditorBrowsable(Never)]
        public static string bundleIdentifier { get; set; }
        public static bool vulkanEnableSetSRGBWrite { get; set; }
        public static uint vulkanNumSwapchainBuffers { get; set; }
        public static bool vulkanEnableLateAcquireNextImage { get; set; }
        [Obsolete("Vulkan SW command buffers are deprecated, vulkanUseSWCommandBuffers will be ignored.")]
        public static bool vulkanUseSWCommandBuffers { get; set; }
        public static bool vulkanEnablePreTransform { get; set; }

        [Obsolete("Use explicit API instead.")]
        [StaticAccessor("PlayerSettingsBindings", DoubleColon)]
        public static void SetPropertyInt(string name, int value, BuildTargetGroup target);
        [Obsolete("Use explicit API instead.")]
        public static void SetPropertyInt(string name, int value);
        [Obsolete("Use explicit API instead.")]
        public static void SetPropertyInt(string name, int value, BuildTarget target);
        [StaticAccessor("PlayerSettingsBindings", DoubleColon)]
        [Obsolete("Use explicit API instead.")]
        public static int GetPropertyInt(string name, BuildTargetGroup target);
        [Obsolete("Use explicit API instead.")]
        public static int GetPropertyInt(string name);
        [Obsolete("Use explicit API instead.")]
        public static bool GetPropertyOptionalInt(string name, ref int value, BuildTargetGroup target);
        [Obsolete("Use explicit API instead.")]
        public static bool GetPropertyOptionalInt(string name, ref int value);
        [StaticAccessor("PlayerSettingsBindings", DoubleColon)]
        [Obsolete("Use explicit API instead.")]
        public static void SetPropertyBool(string name, bool value, BuildTargetGroup target);
        [Obsolete("Use explicit API instead.")]
        public static void SetPropertyBool(string name, bool value);
        [Obsolete("Use explicit API instead.")]
        public static void SetPropertyBool(string name, bool value, BuildTarget target);
        [Obsolete("Use explicit API instead.")]
        [StaticAccessor("PlayerSettingsBindings", DoubleColon)]
        public static bool GetPropertyBool(string name, BuildTargetGroup target);
        [Obsolete("Use explicit API instead.")]
        public static bool GetPropertyBool(string name);
        [Obsolete("Use explicit API instead.")]
        public static bool GetPropertyOptionalBool(string name, ref bool value, BuildTargetGroup target);
        [Obsolete("Use explicit API instead.")]
        public static bool GetPropertyOptionalBool(string name, ref bool value);
        [Obsolete("Use explicit API instead.")]
        [StaticAccessor("PlayerSettingsBindings", DoubleColon)]
        public static void SetPropertyString(string name, string value, BuildTargetGroup target);
        [Obsolete("Use explicit API instead.")]
        public static void SetPropertyString(string name, string value);
        [Obsolete("Use explicit API instead.")]
        public static void SetPropertyString(string name, string value, BuildTarget target);
        [StaticAccessor("PlayerSettingsBindings", DoubleColon)]
        [Obsolete("Use explicit API instead.")]
        public static string GetPropertyString(string name, BuildTargetGroup target);
        [Obsolete("Use explicit API instead.")]
        public static string GetPropertyString(string name);
        [Obsolete("Use explicit API instead.")]
        public static bool GetPropertyOptionalString(string name, ref string value, BuildTargetGroup target);
        [Obsolete("Use explicit API instead.")]
        public static bool GetPropertyOptionalString(string name, ref string value);
        [NativeMethod("AspectRatioEnabled")]
        public static bool HasAspectRatio(AspectRatio aspectRatio);
        public static void SetAspectRatio(AspectRatio aspectRatio, bool enable);
        public static UnityEngine.Object[] GetPreloadedAssets();
        public static void SetPreloadedAssets(UnityEngine.Object[] assets);
        [NativeMethod("GetPlatformGraphicsAPIs")]
        public static GraphicsDeviceType[] GetGraphicsAPIs(BuildTarget platform);
        public static void SetGraphicsAPIs(BuildTarget platform, GraphicsDeviceType[] apis);
        [NativeMethod("GetPlatformAutomaticGraphicsAPIs")]
        public static bool GetUseDefaultGraphicsAPIs(BuildTarget platform);
        public static void SetUseDefaultGraphicsAPIs(BuildTarget platform, bool automatic);
        public static void SetTemplateCustomValue(string name, string value);
        public static string GetTemplateCustomValue(string name);
        [StaticAccessor("GetPlayerSettings().GetEditorOnly()")]
        [NativeMethod("GetUserScriptingDefineSymbolsForGroup")]
        public static string GetScriptingDefineSymbolsForGroup(BuildTargetGroup targetGroup);
        public static void GetScriptingDefineSymbolsForGroup(BuildTargetGroup targetGroup, out string[] defines);
        public static void SetScriptingDefineSymbolsForGroup(BuildTargetGroup targetGroup, string defines);
        public static void SetScriptingDefineSymbolsForGroup(BuildTargetGroup targetGroup, string[] defines);
        [StaticAccessor("GetPlayerSettings().GetEditorOnly()")]
        [NativeMethod("GetAdditionalCompilerArgumentsForGroup")]
        public static string[] GetAdditionalCompilerArgumentsForGroup(BuildTargetGroup targetGroup);
        public static void SetAdditionalCompilerArgumentsForGroup(BuildTargetGroup targetGroup, string[] additionalCompilerArguments);
        [StaticAccessor("GetPlayerSettings().GetEditorOnly()")]
        [NativeMethod("GetPlatformArchitecture")]
        public static int GetArchitecture(BuildTargetGroup targetGroup);
        [NativeMethod("SetPlatformArchitecture")]
        [StaticAccessor("GetPlayerSettings().GetEditorOnlyForUpdate()")]
        public static void SetArchitecture(BuildTargetGroup targetGroup, int architecture);
        [NativeMethod("GetPlatformScriptingBackend")]
        [StaticAccessor("GetPlayerSettings().GetEditorOnly()")]
        public static ScriptingImplementation GetScriptingBackend(BuildTargetGroup targetGroup);
        [StaticAccessor("GetPlayerSettings().GetEditorOnlyForUpdate()")]
        public static void SetApplicationIdentifier(BuildTargetGroup targetGroup, string identifier);
        [StaticAccessor("GetPlayerSettings().GetEditorOnly()")]
        public static string GetApplicationIdentifier(BuildTargetGroup targetGroup);
        [NativeMethod("SetPlatformScriptingBackend")]
        [StaticAccessor("GetPlayerSettings().GetEditorOnlyForUpdate()")]
        public static void SetScriptingBackend(BuildTargetGroup targetGroup, ScriptingImplementation backend);
        [FreeFunction("GetDefaultScriptingBackendForGroup")]
        public static ScriptingImplementation GetDefaultScriptingBackend(BuildTargetGroup targetGroup);
        public static void SetIl2CppCompilerConfiguration(BuildTargetGroup targetGroup, Il2CppCompilerConfiguration configuration);
        [StaticAccessor("GetPlayerSettings().GetEditorOnly()")]
        public static Il2CppCompilerConfiguration GetIl2CppCompilerConfiguration(BuildTargetGroup targetGroup);
        [NativeMethod("GetPlatformIncrementalIl2CppBuild")]
        [StaticAccessor("GetPlayerSettings().GetEditorOnly()")]
        public static bool GetIncrementalIl2CppBuild(BuildTargetGroup targetGroup);
        [NativeMethod("SetPlatformIncrementalIl2CppBuild")]
        [StaticAccessor("GetPlayerSettings().GetEditorOnlyForUpdate()")]
        public static void SetIncrementalIl2CppBuild(BuildTargetGroup targetGroup, bool enabled);
        [StaticAccessor("GetPlayerSettings().GetEditorOnly().additionalIl2CppArgs")]
        [NativeMethod("c_str")]
        public static string GetAdditionalIl2CppArgs();
        [StaticAccessor("PlayerSettingsBindings", DoubleColon)]
        public static void SetAdditionalIl2CppArgs(string additionalArgs);
        [StaticAccessor("GetPlayerSettings()")]
        public static bool GetWsaHolographicRemotingEnabled();
        [StaticAccessor("GetPlayerSettings()")]
        public static void SetWsaHolographicRemotingEnabled(bool enabled);
        [StaticAccessor("GetPlayerSettings().GetEditorOnlyForUpdate()")]
        public static void SetManagedStrippingLevel(BuildTargetGroup targetGroup, ManagedStrippingLevel level);
        [StaticAccessor("GetPlayerSettings().GetEditorOnly()")]
        public static ManagedStrippingLevel GetManagedStrippingLevel(BuildTargetGroup targetGroup);
        [StaticAccessor("GetPlayerSettings().GetEditorOnly()")]
        public static ApiCompatibilityLevel GetApiCompatibilityLevel(BuildTargetGroup buildTargetGroup);
        [StaticAccessor("GetPlayerSettings().GetEditorOnlyForUpdate()")]
        public static void SetApiCompatibilityLevel(BuildTargetGroup buildTargetGroup, ApiCompatibilityLevel value);
        public static void SetMobileMTRendering(BuildTargetGroup targetGroup, bool enable);
        public static bool GetMobileMTRendering(BuildTargetGroup targetGroup);
        [NativeMethod("GetStackTraceType")]
        public static StackTraceLogType GetStackTraceLogType(LogType logType);
        [NativeMethod("SetStackTraceType")]
        public static void SetStackTraceLogType(LogType logType, StackTraceLogType stackTraceType);
        [NativeMethod("GetVirtualTexturingSupportEnabled")]
        [StaticAccessor("GetPlayerSettings()")]
        public static bool GetVirtualTexturingSupportEnabled();
        [NativeMethod("SetVirtualTexturingSupportEnabled")]
        [StaticAccessor("GetPlayerSettings()")]
        public static void SetVirtualTexturingSupportEnabled(bool enabled);
        [StaticAccessor("GetPlayerSettings().GetEditorOnly()")]
        public static ShaderPrecisionModel GetShaderPrecisionModel();
        [StaticAccessor("GetPlayerSettings().GetEditorOnlyForUpdate()")]
        public static void SetShaderPrecisionModel(ShaderPrecisionModel model);
        [StaticAccessor("GetPlayerSettings().GetEditorOnly()")]
        public static NormalMapEncoding GetNormalMapEncoding(BuildTargetGroup platform);
        [StaticAccessor("GetPlayerSettings().GetEditorOnlyForUpdate()")]
        public static void SetNormalMapEncoding(BuildTargetGroup platform, NormalMapEncoding encoding);
        public static PlatformIcon[] GetPlatformIcons(BuildTargetGroup platform, PlatformIconKind kind);
        public static void SetPlatformIcons(BuildTargetGroup platform, PlatformIconKind kind, PlatformIcon[] icons);
        public static PlatformIconKind[] GetSupportedIconKindsForPlatform(BuildTargetGroup platform);
        public static void SetIconsForTargetGroup(BuildTargetGroup platform, Texture2D[] icons, IconKind kind);
        public static void SetIconsForTargetGroup(BuildTargetGroup platform, Texture2D[] icons);
        public static Texture2D[] GetIconsForTargetGroup(BuildTargetGroup platform, IconKind kind);
        public static Texture2D[] GetIconsForTargetGroup(BuildTargetGroup platform);
        public static int[] GetIconSizesForTargetGroup(BuildTargetGroup platform, IconKind kind);
        public static int[] GetIconSizesForTargetGroup(BuildTargetGroup platform);
        [Obsolete("This API is deprecated and will be removed prior to shipping 2020.2", False)]
        public static bool GetVirtualRealitySupported(BuildTargetGroup targetGroup);
        [Obsolete("This API is deprecated and will be removed prior to shipping 2020.2", False)]
        public static void SetVirtualRealitySupported(BuildTargetGroup targetGroup, bool value);

        [StaticAccessor("GetPlayerSettings()", Dot)]
        [NativeHeader("Runtime/Misc/PlayerSettings.h")]
        public class Android
        {
            public Android();

            [Obsolete("Use targetArchitectures instead. (UnityUpgradable) -> targetArchitectures", False)]
            public static AndroidTargetDevice targetDevice { get; set; }
            public static bool disableDepthAndStencilBuffers { get; set; }
            [Obsolete("use24BitDepthBuffer is deprecated, use disableDepthAndStencilBuffers instead.")]
            public static bool use24BitDepthBuffer { get; set; }
            public static int defaultWindowWidth { get; set; }
            public static int defaultWindowHeight { get; set; }
            public static int minimumWindowWidth { get; set; }
            public static int minimumWindowHeight { get; set; }
            public static bool resizableWindow { get; set; }
            public static FullScreenMode fullscreenMode { get; set; }
            public static int bundleVersionCode { get; set; }
            public static AndroidSdkVersions minSdkVersion { get; set; }
            public static AndroidSdkVersions targetSdkVersion { get; set; }
            public static AndroidPreferredInstallLocation preferredInstallLocation { get; set; }
            public static bool forceInternetPermission { get; set; }
            public static bool forceSDCardPermission { get; set; }
            public static bool androidTVCompatibility { get; set; }
            public static bool androidIsGame { get; set; }
            public static bool ARCoreEnabled { get; set; }
            public static bool chromeosInputEmulation { get; set; }
            public static AndroidArchitecture targetArchitectures { get; set; }
            public static bool buildApkPerCpuArchitecture { get; set; }
            public static AndroidTargetDevices androidTargetDevices { get; set; }
            public static AndroidSplashScreenScale splashScreenScale { get; set; }
            [NativeProperty("androidUseCustomKeystore", Function)]
            public static bool useCustomKeystore { get; set; }
            public static string keystoreName { get; set; }
            public static string keystorePass { get; set; }
            public static string keyaliasName { get; set; }
            public static string keyaliasPass { get; set; }
            public static bool licenseVerification { get; }
            public static bool useAPKExpansionFiles { get; set; }
            public static AndroidShowActivityIndicatorOnLoading showActivityIndicatorOnLoading { get; set; }
            public static AndroidBlitType blitType { get; set; }
            public static float maxAspectRatio { get; set; }
            public static bool startInFullscreen { get; set; }
            public static bool renderOutsideSafeArea { get; set; }
            [NativeProperty("AndroidMinifyWithR8", Function)]
            public static bool minifyWithR8 { get; set; }
            [NativeProperty("AndroidMinifyRelease", Function)]
            public static bool minifyRelease { get; set; }
            [NativeProperty("AndroidMinifyDebug", Function)]
            public static bool minifyDebug { get; set; }
            public static bool optimizedFramePacing { get; set; }
        }
        [StaticAccessor("GetPlayerSettings()", Dot)]
        [NativeHeader("Editor/Src/EditorUserBuildSettings.h")]
        [NativeHeader("Runtime/Misc/PlayerSettings.h")]
        public class iOS
        {
            public iOS();

            [Obsolete("exitOnSuspend is deprecated, use appInBackgroundBehavior", False)]
            public static bool exitOnSuspend { get; set; }
            [EditorBrowsable(Never)]
            [Obsolete("Use Screen.SetResolution at runtime", True)]
            public static iOSTargetResolution targetResolution { get; set; }
            [Obsolete("Use PlayerSettings.muteOtherAudioSources instead (UnityUpgradable) -> UnityEditor.PlayerSettings.muteOtherAudioSources", False)]
            public static bool overrideIPodMusic { get; set; }
            [NativeProperty("ProductName")]
            public static string applicationDisplayName { get; set; }
            public static string buildNumber { get; set; }
            public static bool disableDepthAndStencilBuffers { get; set; }
            public static ScriptCallOptimizationLevel scriptCallOptimization { get; set; }
            public static iOSSdkVersion sdkVersion { get; set; }
            [Obsolete("OBSOLETE warning targetOSVersion is obsolete, use targetOSVersionString")]
            public static iOSTargetOSVersion targetOSVersion { get; set; }
            [NativeProperty("iOSTargetOSVersion")]
            public static string targetOSVersionString { get; set; }
            public static iOSTargetDevice targetDevice { get; set; }
            [NativeProperty("UIPrerenderedIcon")]
            public static bool prerenderedIcon { get; set; }
            [NativeProperty("UIRequiresPersistentWiFi")]
            public static bool requiresPersistentWiFi { get; set; }
            [NativeProperty("UIRequiresFullScreen")]
            public static bool requiresFullScreen { get; set; }
            [NativeProperty("UIStatusBarStyle")]
            public static iOSStatusBarStyle statusBarStyle { get; set; }
            public static SystemGestureDeferMode deferSystemGesturesMode { get; set; }
            [NativeProperty("HideHomeButton")]
            public static bool hideHomeButton { get; set; }
            public static iOSAppInBackgroundBehavior appInBackgroundBehavior { get; set; }
            [NativeProperty("IOSAppInBackgroundBehavior")]
            public static iOSBackgroundMode backgroundModes { get; set; }
            [NativeProperty("IOSMetalForceHardShadows")]
            public static bool forceHardShadowsOnMetal { get; set; }
            [NativeProperty("IOSAllowHTTPDownload")]
            public static bool allowHTTPDownload { get; set; }
            public static string appleDeveloperTeamID { get; set; }
            public static string iOSManualProvisioningProfileID { get; set; }
            public static string tvOSManualProvisioningProfileID { get; set; }
            [NativeProperty("tvOSManualProvisioningProfileType")]
            public static ProvisioningProfileType tvOSManualProvisioningProfileType { get; set; }
            [NativeProperty("iOSManualProvisioningProfileType")]
            public static ProvisioningProfileType iOSManualProvisioningProfileType { get; set; }
            public static bool appleEnableAutomaticSigning { get; set; }
            [NativeProperty("CameraUsageDescription")]
            public static string cameraUsageDescription { get; set; }
            [NativeProperty("LocationUsageDescription")]
            public static string locationUsageDescription { get; set; }
            [NativeProperty("MicrophoneUsageDescription")]
            public static string microphoneUsageDescription { get; set; }
            [NativeProperty("IOSAppInBackgroundBehavior")]
            public static iOSShowActivityIndicatorOnLoading showActivityIndicatorOnLoading { get; set; }
            [NativeProperty("UseOnDemandResources")]
            public static bool useOnDemandResources { get; set; }
            [NativeProperty("iOSURLSchemes", False, Field)]
            public static string[] iOSUrlSchemes { get; set; }

            public static void SetLaunchScreenImage(Texture2D image, iOSLaunchScreenImageType type);
            public static void SetiPhoneLaunchScreenType(iOSLaunchScreenType type);
            public static void SetiPadLaunchScreenType(iOSLaunchScreenType type);
        }
        [Obsolete("Facebook support was removed in 2019.3", True)]
        public class Facebook
        {
            public Facebook();

            public static string sdkVersion { get; set; }
            public static string appId { get; set; }
            public static bool useCookies { get; set; }
            public static bool useStatus { get; set; }
            public static bool useFrictionlessRequests { get; set; }
        }
        [NativeHeader("Runtime/Misc/PlayerSettings.h")]
        public sealed class Lumin
        {
            public Lumin();

            [NativeProperty("LuminIconModelFolderPath")]
            public static string iconModelFolderPath { get; set; }
            [NativeProperty("LuminIconPortalFolderPath")]
            public static string iconPortalFolderPath { get; set; }
            [NativeProperty("LuminCertificatePath")]
            public static string certificatePath { get; set; }
            [NativeProperty("LuminSignPackage")]
            public static bool signPackage { get; set; }
            [NativeProperty("LuminIsChannelApp")]
            public static bool isChannelApp { get; set; }
            [NativeProperty("LuminVersionCode")]
            public static int versionCode { get; set; }
            [NativeProperty("LuminVersionName")]
            public static string versionName { get; set; }
        }
        [NativeHeader("Runtime/Misc/PlayerSettings.h")]
        [StaticAccessor("GetPlayerSettings()", Dot)]
        public class macOS
        {
            public macOS();

            public static string buildNumber { get; set; }
            [NativeProperty("MacAppStoreCategory")]
            public static string applicationCategoryType { get; set; }
            [NativeProperty("CameraUsageDescription")]
            public static string cameraUsageDescription { get; set; }
            [NativeProperty("MicrophoneUsageDescription")]
            public static string microphoneUsageDescription { get; set; }
            [NativeProperty("BluetoothUsageDescription")]
            public static string bluetoothUsageDescription { get; set; }
        }
        [NativeHeader("Runtime/Misc/PlayerSettings.h")]
        [StaticAccessor("GetPlayerSettings().GetEditorOnlyForUpdate()", Dot)]
        public sealed class PS4
        {
            public PS4();

            [NativeProperty("ps4NPTrophyPackPath")]
            public static string npTrophyPackPath { get; set; }
            [NativeProperty("ps4NPAgeRating", False, Field)]
            public static int npAgeRating { get; set; }
            [NativeProperty("ps4NPTitleSecret", False, Function)]
            public static string npTitleSecret { get; set; }
            [NativeProperty("ps4ParentalLevel", False, Field)]
            public static int parentalLevel { get; set; }
            [NativeProperty("ps4ApplicationParam1", False, Field)]
            public static int applicationParameter1 { get; set; }
            [NativeProperty("ps4ApplicationParam2", False, Field)]
            public static int applicationParameter2 { get; set; }
            [NativeProperty("ps4ApplicationParam3", False, Field)]
            public static int applicationParameter3 { get; set; }
            [NativeProperty("ps4ApplicationParam4", False, Field)]
            public static int applicationParameter4 { get; set; }
            [NativeProperty("ps4Passcode", False, Function)]
            public static string passcode { get; set; }
            [NativeProperty("monoEnv", False, Function)]
            public static string monoEnv { get; set; }
            [NativeProperty(TargetType = Field)]
            public static bool playerPrefsSupport { get; set; }
            [NativeProperty(TargetType = Field)]
            public static bool restrictedAudioUsageRights { get; set; }
            [NativeProperty("ps4UseResolutionFallback", False, Field)]
            public static bool useResolutionFallback { get; set; }
            [NativeProperty("ps4ContentID", False, Function)]
            public static string contentID { get; set; }
            [NativeProperty("ps4Category", False, Field)]
            public static PS4AppCategory category { get; set; }
            [NativeProperty("ps4AppType", False, Field)]
            public static int appType { get; set; }
            [NativeProperty("ps4MasterVersion", False, Function)]
            public static string masterVersion { get; set; }
            [NativeProperty("ps4AppVersion", False, Function)]
            public static string appVersion { get; set; }
            [NativeProperty("ps4RemotePlayKeyAssignment", False, Field)]
            public static PS4RemotePlayKeyAssignment remotePlayKeyAssignment { get; set; }
            [NativeProperty("ps4RemotePlayKeyMappingDir", False, Function)]
            public static string remotePlayKeyMappingDir { get; set; }
            [NativeProperty("ps4PlayTogetherPlayerCount", False, Field)]
            public static int playTogetherPlayerCount { get; set; }
            [NativeProperty("ps4EnterButtonAssignment", False, Field)]
            public static PS4EnterButtonAssignment enterButtonAssignment { get; set; }
            [NativeProperty("ps4ParamSfxPath", False, Function)]
            public static string paramSfxPath { get; set; }
            [NativeProperty("ps4VideoOutPixelFormat", False, Field)]
            public static int videoOutPixelFormat { get; set; }
            [NativeProperty("ps4VideoOutInitialWidth", False, Field)]
            public static int videoOutInitialWidth { get; set; }
            [Obsolete("videoOutResolution is deprecated. Use PlayerSettings.PS4.videoOutInitialWidth and PlayerSettings.PS4.videoOutReprojectionRate to control initial display resolution and reprojection rate.")]
            public static int videoOutResolution { get; set; }
            public static string SdkOverride { get; set; }
            [NativeProperty("ps4VideoOutBaseModeInitialWidth", False, Field)]
            public static int videoOutBaseModeInitialWidth { get; set; }
            [NativeProperty("ps4VideoOutReprojectionRate", False, Field)]
            public static int videoOutReprojectionRate { get; set; }
            [NativeProperty("ps4PronunciationXMLPath", False, Function)]
            public static string PronunciationXMLPath { get; set; }
            [NativeProperty("ps4PronunciationSIGPath", False, Function)]
            public static string PronunciationSIGPath { get; set; }
            [NativeProperty("ps4BackgroundImagePath", False, Function)]
            public static string BackgroundImagePath { get; set; }
            [NativeProperty("ps4StartupImagePath", False, Function)]
            public static string StartupImagePath { get; set; }
            [NativeProperty("ps4StartupImagesFolder", False, Function)]
            public static string startupImagesFolder { get; set; }
            [NativeProperty("ps4IconImagesFolder", False, Function)]
            public static string iconImagesFolder { get; set; }
            [NativeProperty("ps4SaveDataImagePath", False, Function)]
            public static string SaveDataImagePath { get; set; }
            [NativeProperty("ps4BGMPath", False, Function)]
            public static string BGMPath { get; set; }
            [NativeProperty("ps4ShareFilePath", False, Function)]
            public static string ShareFilePath { get; set; }
            [NativeProperty("ps4ShareOverlayImagePath", False, Function)]
            public static string ShareOverlayImagePath { get; set; }
            [NativeProperty("ps4PrivacyGuardImagePath", False, Function)]
            public static string PrivacyGuardImagePath { get; set; }
            [NativeProperty("ps4ExtraSceSysFile", False, Function)]
            public static string ExtraSceSysFile { get; set; }
            [NativeProperty("ps4PatchDayOne", False, Field)]
            public static bool patchDayOne { get; set; }
            [NativeProperty("ps4PatchPkgPath", False, Function)]
            public static string PatchPkgPath { get; set; }
            [NativeProperty("ps4PatchLatestPkgPath", False, Function)]
            public static string PatchLatestPkgPath { get; set; }
            [NativeProperty("ps4PatchChangeinfoPath", False, Function)]
            public static string PatchChangeinfoPath { get; set; }
            [NativeProperty("ps4NPtitleDatPath", False, Function)]
            public static string NPtitleDatPath { get; set; }
            [NativeProperty("ps4pnSessions", False, Field)]
            public static bool pnSessions { get; set; }
            [NativeProperty("ps4pnPresence", False, Field)]
            public static bool pnPresence { get; set; }
            [NativeProperty("ps4pnFriends", False, Field)]
            public static bool pnFriends { get; set; }
            [NativeProperty("ps4pnGameCustomData", False, Field)]
            public static bool pnGameCustomData { get; set; }
            [NativeProperty("ps4DownloadDataSize", False, Field)]
            public static int downloadDataSize { get; set; }
            [NativeProperty("ps4GarlicHeapSize", False, Field)]
            public static int garlicHeapSize { get; set; }
            [NativeProperty("ps4ProGarlicHeapSize", False, Field)]
            public static int proGarlicHeapSize { get; set; }
            [NativeProperty("ps4ReprojectionSupport", False, Field)]
            public static bool reprojectionSupport { get; set; }
            [NativeProperty("ps4UseAudio3dBackend", False, Field)]
            public static bool useAudio3dBackend { get; set; }
            [NativeProperty("ps4Audio3dVirtualSpeakerCount", False, Field)]
            public static int audio3dVirtualSpeakerCount { get; set; }
            [NativeProperty("ps4ScriptOptimizationLevel", False, Field)]
            public static int scriptOptimizationLevel { get; set; }
            [NativeProperty("ps4UseLowGarlicFragmentationMode", True, Field)]
            public static bool useLowGarlicFragmentationMode { get; set; }
            [NativeProperty("ps4SocialScreenEnabled", False, Field)]
            public static int socialScreenEnabled { get; set; }
            [NativeProperty("ps4attribUserManagement", False, Field)]
            public static bool attribUserManagement { get; set; }
            [NativeProperty("ps4attribMoveSupport", False, Field)]
            public static bool attribMoveSupport { get; set; }
            [NativeProperty("ps4attrib3DSupport", False, Field)]
            public static bool attrib3DSupport { get; set; }
            [NativeProperty("ps4attribShareSupport", False, Field)]
            public static bool attribShareSupport { get; set; }
            [NativeProperty("ps4attribExclusiveVR", False, Field)]
            public static bool attribExclusiveVR { get; set; }
            [NativeProperty("ps4disableAutoHideSplash", False, Field)]
            public static bool disableAutoHideSplash { get; set; }
            [NativeProperty("ps4attribCpuUsage", False, Field)]
            public static int attribCpuUsage { get; set; }
            [NativeProperty("ps4videoRecordingFeaturesUsed", False, Field)]
            public static bool videoRecordingFeaturesUsed { get; set; }
            [NativeProperty("ps4contentSearchFeaturesUsed", False, Field)]
            public static bool contentSearchFeaturesUsed { get; set; }
            [NativeProperty("ps4attribEyeToEyeDistanceSettingVR", False, Field)]
            public static PlayStationVREyeToEyeDistanceSettings attribEyeToEyeDistanceSettingVR { get; set; }
            [NativeProperty("ps4IncludedModules", False, Field)]
            public static string[] includedModules { get; set; }
            [NativeProperty(TargetType = Field)]
            public static bool enableApplicationExit { get; set; }
            [NativeProperty(TargetType = Field)]
            public static bool resetTempFolder { get; set; }
            [NativeProperty(TargetType = Field)]
            public static int playerPrefsMaxSize { get; set; }
            [NativeProperty("ps4attribVROutputEnabled", False, Field)]
            public static bool attribVROutputEnabled { get; set; }
            [NativeProperty("ps4CompatibilityPS5", False, Field)]
            public static bool compatibilityPS5 { get; set; }
            [NativeProperty("ps4AllowPS5Detection", False, Field)]
            public static bool allowPS5Detection { get; set; }
            [NativeProperty("ps4GPU800MHz", False, Field)]
            public static bool gpu800MHz { get; set; }

            public enum PS4AppCategory
            {
                Application = 0,
                Patch = 1,
                Remaster = 2
            }
            public enum PS4RemotePlayKeyAssignment
            {
                None = -1,
                PatternA = 0,
                PatternB = 1,
                PatternC = 2,
                PatternD = 3,
                PatternE = 4,
                PatternF = 5,
                PatternG = 6,
                PatternH = 7
            }
            public enum PS4EnterButtonAssignment
            {
                CircleButton = 0,
                CrossButton = 1,
                SystemDefined = 2
            }
            public enum PlayStationVREyeToEyeDistanceSettings
            {
                PerUser = 0,
                ForceDefault = 1,
                DynamicModeAtRuntime = 2
            }
        }
        [NativeHeader("Runtime/Misc/PlayerSettingsSplashScreen.h")]
        public struct SplashScreenLogo
        {
            public Sprite logo { get; set; }
            public static Sprite unityLogo { get; }
            public float duration { get; set; }

            [ExcludeFromDocs]
            public static SplashScreenLogo Create(float duration);
            [ExcludeFromDocs]
            public static SplashScreenLogo Create();
            public static SplashScreenLogo Create([UnityEngine.Internal.DefaultValue("k_MinLogoTime")] float duration, [UnityEngine.Internal.DefaultValue("null")] Sprite logo);
            [ExcludeFromDocs]
            public static SplashScreenLogo CreateWithUnityLogo();
            public static SplashScreenLogo CreateWithUnityLogo([UnityEngine.Internal.DefaultValue("k_MinLogoTime")] float duration);
        }
        [NativeHeader("Editor/Mono/PlayerSettingsSplashScreen.bindings.h")]
        [StaticAccessor("GetPlayerSettings().GetSplashScreenSettings()", Dot)]
        public class SplashScreen
        {
            public SplashScreen();

            [NativeName("SplashScreenAnimation")]
            public static AnimationMode animationMode { get; set; }
            [NativeName("SplashScreenBackgroundZoom")]
            public static float animationBackgroundZoom { get; set; }
            [NativeName("SplashScreenLogoZoom")]
            public static float animationLogoZoom { get; set; }
            public static Sprite background { get; set; }
            public static Sprite backgroundPortrait { get; set; }
            public static bool blurBackgroundImage { get; set; }
            [NativeName("SplashScreenBackgroundColor")]
            public static Color backgroundColor { get; set; }
            [NativeName("SplashScreenDrawMode")]
            public static DrawMode drawMode { get; set; }
            [NativeName("SplashScreenLogos")]
            public static SplashScreenLogo[] logos { get; set; }
            [NativeName("SplashScreenOverlayOpacity")]
            public static float overlayOpacity { get; set; }
            [NativeName("ShowUnitySplashScreen")]
            public static bool show { get; set; }
            [NativeName("ShowUnitySplashLogo")]
            public static bool showUnityLogo { get; set; }
            [NativeName("SplashScreenLogoStyle")]
            public static UnityLogoStyle unityLogoStyle { get; set; }

            public enum AnimationMode
            {
                Static = 0,
                Dolly = 1,
                Custom = 2
            }
            public enum DrawMode
            {
                UnityLogoBelow = 0,
                AllSequential = 1
            }
            public enum UnityLogoStyle
            {
                DarkOnLight = 0,
                LightOnDark = 1
            }
        }
        [NativeHeader("Editor/Mono/PlayerSettingsSwitch.bindings.h")]
        [StaticAccessor("GetPlayerSettings().GetEditorOnlyForUpdate()", Dot)]
        public sealed class Switch
        {
            public Switch();

            [NativeProperty("switchSocketMemoryPoolSize", Field)]
            public static int socketMemoryPoolSize { get; set; }
            [NativeProperty("switchSocketAllocatorPoolSize", Field)]
            public static int socketAllocatorPoolSize { get; set; }
            [NativeProperty("switchSocketConcurrencyLimit", Field)]
            public static int socketConcurrencyLimit { get; set; }
            [NativeProperty("switchUseCPUProfiler", Field)]
            public static bool useSwitchCPUProfiler { get; set; }
            [NativeProperty("switchUseGOLDLinker", Field)]
            public static bool useSwitchGOLDLinker { get; set; }
            [NativeProperty("switchSystemResourceMemory", Field)]
            public static int systemResourceMemory { get; set; }
            [StaticAccessor("GetPlayerSettings()", Dot)]
            public static int queueCommandMemory { get; set; }
            [StaticAccessor("PlayerSettings", DoubleColon)]
            public static int defaultSwitchQueueCommandMemory { get; }
            [StaticAccessor("PlayerSettings", DoubleColon)]
            public static int minimumSwitchQueueCommandMemory { get; }
            [StaticAccessor("GetPlayerSettings()", Dot)]
            public static int queueControlMemory { get; set; }
            [StaticAccessor("PlayerSettings", DoubleColon)]
            public static int defaultSwitchQueueControlMemory { get; }
            [StaticAccessor("PlayerSettings", DoubleColon)]
            public static int minimumSwitchQueueControlMemory { get; }
            [StaticAccessor("GetPlayerSettings()", Dot)]
            public static int queueComputeMemory { get; set; }
            [StaticAccessor("PlayerSettings", DoubleColon)]
            public static int defaultSwitchQueueComputeMemory { get; }
            [StaticAccessor("GetPlayerSettings()", Dot)]
            public static int NVNShaderPoolsGranularity { get; set; }
            [StaticAccessor("GetPlayerSettings()", Dot)]
            public static int NVNDefaultPoolsGranularity { get; set; }
            [StaticAccessor("GetPlayerSettings()", Dot)]
            public static int NVNOtherPoolsGranularity { get; set; }
            [StaticAccessor("GetPlayerSettings()", Dot)]
            public static int NVNMaxPublicTextureIDCount { get; set; }
            [StaticAccessor("GetPlayerSettings()", Dot)]
            public static int NVNMaxPublicSamplerIDCount { get; set; }
            [NativeProperty("switchScreenResolutionBehavior", Field)]
            public static ScreenResolutionBehavior screenResolutionBehavior { get; set; }
            public static string NMETAOverride { get; set; }
            public static string NMETAOverrideFullPath { get; }
            [NativeProperty("switchApplicationID", Function)]
            public static string applicationID { get; set; }
            [NativeProperty("switchNSODependencies", Function)]
            public static string nsoDependencies { get; set; }
            public static string[] titleNames { get; set; }
            public static string[] publisherNames { get; set; }
            public static Texture2D[] icons { get; set; }
            public static Texture2D[] smallIcons { get; set; }
            public static string manualHTMLPath { get; set; }
            public static string accessibleURLPath { get; set; }
            public static string legalInformationPath { get; set; }
            [NativeProperty("switchMainThreadStackSize", Field)]
            public static int mainThreadStackSize { get; set; }
            [NativeProperty("switchPresenceGroupId", Function)]
            public static string presenceGroupId { get; set; }
            [NativeProperty("switchLogoHandling", Field)]
            public static LogoHandling logoHandling { get; set; }
            public static string releaseVersion { get; set; }
            [NativeProperty("switchDisplayVersion", Function)]
            public static string displayVersion { get; set; }
            [NativeProperty("switchStartupUserAccount", Field)]
            public static StartupUserAccount startupUserAccount { get; set; }
            [NativeProperty("switchTouchScreenUsage", Field)]
            public static TouchScreenUsage touchScreenUsage { get; set; }
            [NativeProperty("switchSupportedLanguagesMask", Field)]
            public static int supportedLanguages { get; set; }
            [NativeProperty("switchLogoType", Field)]
            public static LogoType logoType { get; set; }
            [NativeProperty("switchApplicationErrorCodeCategory", Function)]
            public static string applicationErrorCodeCategory { get; set; }
            [NativeProperty("switchUserAccountSaveDataSize", Field)]
            public static int userAccountSaveDataSize { get; set; }
            [NativeProperty("switchUserAccountSaveDataJournalSize", Field)]
            public static int userAccountSaveDataJournalSize { get; set; }
            [NativeProperty("switchApplicationAttribute", Field)]
            public static ApplicationAttribute applicationAttribute { get; set; }
            public static int cardSpecSize { get; set; }
            public static int cardSpecClock { get; set; }
            [NativeProperty("switchRatingsMask", Field)]
            public static int ratingsMask { get; set; }
            public static string[] localCommunicationIds { get; set; }
            [NativeProperty("switchParentalControl", Field)]
            public static bool isUnderParentalControl { get; set; }
            [NativeProperty("switchAllowsScreenshot", Field)]
            public static bool isScreenshotEnabled { get; set; }
            [NativeProperty("switchAllowsScreenshot", Field)]
            [Obsolete("isAllowsScreenshot was renamed to isScreenshotEnabled")]
            public static bool isAllowsScreenshot { get; set; }
            [NativeProperty("switchAllowsVideoCapturing", Field)]
            public static bool isVideoCapturingEnabled { get; set; }
            [NativeProperty("switchAllowsRuntimeAddOnContentInstall", Field)]
            public static bool isRuntimeAddOnContentInstallEnabled { get; set; }
            [NativeProperty("switchDataLossConfirmation", Field)]
            public static bool isDataLossConfirmationEnabled { get; set; }
            [NativeProperty("switchUserAccountLockEnabled", Field)]
            public static bool isUserAccountLockEnabled { get; set; }
            [NativeProperty("switchDataLossConfirmation", Field)]
            [Obsolete("isDataLossConfirmation was renamed to isDataLossConfirmationEnabled")]
            public static bool isDataLossConfirmation { get; set; }
            [NativeProperty("switchSupportedNpadStyles", Field)]
            public static SupportedNpadStyle supportedNpadStyles { get; set; }
            public static int[] ratingAgeArray { get; set; }
            [NativeProperty("switchNativeFsCacheSize", Field)]
            public static int nativeFsCacheSize { get; set; }
            [NativeProperty("switchIsHoldTypeHorizontal", Field)]
            public static bool isHoldTypeHorizontal { get; set; }
            [NativeProperty("switchSupportedNpadCount", Field)]
            public static int supportedNpadCount { get; set; }
            [NativeProperty("switchSocketConfigEnabled", Field)]
            public static bool socketConfigEnabled { get; set; }
            [NativeProperty("switchTcpInitialSendBufferSize", Field)]
            public static int tcpInitialSendBufferSize { get; set; }
            [NativeProperty("switchTcpInitialReceiveBufferSize", Field)]
            public static int tcpInitialReceiveBufferSize { get; set; }
            [NativeProperty("switchTcpAutoSendBufferSizeMax", Field)]
            public static int tcpAutoSendBufferSizeMax { get; set; }
            [NativeProperty("switchTcpAutoReceiveBufferSizeMax", Field)]
            public static int tcpAutoReceiveBufferSizeMax { get; set; }
            [NativeProperty("switchUdpSendBufferSize", Field)]
            public static int udpSendBufferSize { get; set; }
            [NativeProperty("switchUdpReceiveBufferSize", Field)]
            public static int udpReceiveBufferSize { get; set; }
            [NativeProperty("switchSocketBufferEfficiency", Field)]
            public static int socketBufferEfficiency { get; set; }
            [NativeProperty("switchSocketInitializeEnabled", Field)]
            public static bool socketInitializeEnabled { get; set; }
            [NativeProperty("switchNetworkInterfaceManagerInitializeEnabled", Field)]
            public static bool networkInterfaceManagerInitializeEnabled { get; set; }
            [NativeProperty("switchPlayerConnectionEnabled", Field)]
            public static bool playerConnectionEnabled { get; set; }
            [NativeProperty("switchUseNewStyleFilepaths", Field)]
            public static bool useNewStyleFilepaths { get; set; }
            [NativeProperty("switchUseMicroSleepForYield", Field)]
            public static bool switchUseMicroSleepForYield { get; set; }
            [NativeProperty("switchMicroSleepForYieldTime", Field)]
            public static int switchMicroSleepForYieldTime { get; set; }
            [NativeProperty("switchEnableRamDiskSupport", Field)]
            public static bool switchEnableRamDiskSupport { get; set; }
            [NativeProperty("switchRamDiskSpaceSize", Field)]
            public static int switchRamDiskSpaceSize { get; set; }

            public static int GetRatingAge(RatingCategories category);

            public enum ScreenResolutionBehavior
            {
                Manual = 0,
                OperationMode = 1,
                PerformanceMode = 2,
                Both = 3
            }
            public enum Languages
            {
                AmericanEnglish = 0,
                BritishEnglish = 1,
                Japanese = 2,
                French = 3,
                German = 4,
                LatinAmericanSpanish = 5,
                Spanish = 6,
                Italian = 7,
                Dutch = 8,
                CanadianFrench = 9,
                Portuguese = 10,
                Russian = 11,
                SimplifiedChinese = 12,
                TraditionalChinese = 13,
                Korean = 14,
                BrazilianPortuguese = 15
            }
            public enum StartupUserAccount
            {
                None = 0,
                Required = 1,
                RequiredWithNetworkServiceAccountAvailable = 2
            }
            public enum TouchScreenUsage
            {
                Supported = 0,
                Required = 1,
                None = 2
            }
            public enum LogoHandling
            {
                Auto = 0,
                Manual = 1
            }
            public enum LogoType
            {
                LicensedByNintendo = 0,
                [Obsolete("This attribute is no longer available as of NintendoSDK 4.3.", True)]
                DistributedByNintendo = 1,
                Nintendo = 2
            }
            public enum ApplicationAttribute
            {
                None = 0,
                Demo = 1
            }
            public enum RatingCategories
            {
                CERO = 0,
                GRACGCRB = 1,
                GSRMR = 2,
                ESRB = 3,
                ClassInd = 4,
                USK = 5,
                PEGI = 6,
                PEGIPortugal = 7,
                PEGIBBFC = 8,
                Russian = 9,
                ACB = 10,
                OFLC = 11,
                IARCGeneric = 12
            }
            [Flags]
            public enum SupportedNpadStyle
            {
                FullKey = 2,
                Handheld = 4,
                JoyDual = 16,
                JoyLeft = 256,
                JoyRight = 65536
            }
        }
        [NativeHeader("Editor/Src/EditorUserBuildSettings.h")]
        [NativeHeader("Runtime/Misc/PlayerSettings.h")]
        [StaticAccessor("GetPlayerSettings()")]
        public class tvOS
        {
            public tvOS();

            public static tvOSSdkVersion sdkVersion { get; set; }
            public static string buildNumber { get; set; }
            [Obsolete("targetOSVersion is obsolete. Use targetOSVersionString instead.", False)]
            public static tvOSTargetOSVersion targetOSVersion { get; set; }
            public static string targetOSVersionString { get; set; }
            public static bool requireExtendedGameController { get; set; }
        }
        [NativeHeader("Editor/Mono/PlayerSettingsWebGL.bindings.h")]
        public sealed class WebGL
        {
            public WebGL();

            [NativeProperty("webGLMemorySize", Field)]
            public static int memorySize { get; set; }
            [NativeProperty("webGLExceptionSupport", Field)]
            public static WebGLExceptionSupport exceptionSupport { get; set; }
            [NativeProperty("webGLDataCaching", Field)]
            public static bool dataCaching { get; set; }
            [NativeProperty("WebGLEmscriptenArgs")]
            public static string emscriptenArgs { get; set; }
            [NativeProperty("WebGLModulesDirectory")]
            public static string modulesDirectory { get; set; }
            [NativeProperty("WebGLTemplate")]
            public static string template { get; set; }
            [NativeProperty("webGLAnalyzeBuildSize", Field)]
            public static bool analyzeBuildSize { get; set; }
            [NativeProperty("webGLUseEmbeddedResources", Field)]
            public static bool useEmbeddedResources { get; set; }
            [Obsolete("useWasm Property deprecated. Use linkerTarget instead")]
            public static bool useWasm { get; set; }
            [NativeProperty("webGLThreadsSupport", Field)]
            public static bool threadsSupport { get; set; }
            [NativeProperty("webGLLinkerTarget", Field)]
            public static WebGLLinkerTarget linkerTarget { get; set; }
            [NativeProperty("webGLCompressionFormat", Field)]
            public static WebGLCompressionFormat compressionFormat { get; set; }
            [NativeProperty("webGLNameFilesAsHashes", Field)]
            public static bool nameFilesAsHashes { get; set; }
            [NativeProperty("webGLDebugSymbols", Field)]
            public static bool debugSymbols { get; set; }
            [Obsolete("wasmStreaming Property deprecated. WebAssembly streaming will be automatically used when decompressionFallback is disabled and vice versa.", True)]
            [NativeProperty("webGLWasmStreaming", Field)]
            public static bool wasmStreaming { get; set; }
            [NativeProperty("webGLDecompressionFallback", Field)]
            public static bool decompressionFallback { get; set; }
            [NativeProperty("webGLWasmArithmeticExceptions", Field)]
            public static WebGLWasmArithmeticExceptions wasmArithmeticExceptions { get; set; }
        }
        public enum WSAApplicationShowName
        {
            NotSet = 0,
            AllLogos = 1,
            NoLogos = 2,
            StandardLogoOnly = 3,
            WideLogoOnly = 4
        }
        public enum WSADefaultTileSize
        {
            NotSet = 0,
            Medium = 1,
            Wide = 2
        }
        public enum WSAApplicationForegroundText
        {
            Light = 1,
            Dark = 2
        }
        public enum WSACapability
        {
            EnterpriseAuthentication = 0,
            InternetClient = 1,
            InternetClientServer = 2,
            MusicLibrary = 3,
            PicturesLibrary = 4,
            PrivateNetworkClientServer = 5,
            RemovableStorage = 6,
            SharedUserCertificates = 7,
            VideosLibrary = 8,
            WebCam = 9,
            Proximity = 10,
            Microphone = 11,
            Location = 12,
            HumanInterfaceDevice = 13,
            AllJoyn = 14,
            BlockedChatMessages = 15,
            Chat = 16,
            CodeGeneration = 17,
            Objects3D = 18,
            PhoneCall = 19,
            UserAccountInformation = 20,
            VoipCall = 21,
            Bluetooth = 22,
            SpatialPerception = 23,
            InputInjectionBrokered = 24,
            Appointments = 25,
            BackgroundMediaPlayback = 26,
            Contacts = 27,
            LowLevelDevices = 28,
            OfflineMapsManagement = 29,
            PhoneCallHistoryPublic = 30,
            PointOfService = 31,
            RecordedCallsFolder = 32,
            RemoteSystem = 33,
            SystemManagement = 34,
            UserDataTasks = 35,
            UserNotificationListener = 36,
            GazeInput = 37
        }
        public enum WSATargetFamily
        {
            Desktop = 0,
            Mobile = 1,
            Xbox = 2,
            Holographic = 3,
            Team = 4,
            IoT = 5,
            IoTHeadless = 6
        }
        public enum WSAImageScale
        {
            _100 = 100,
            _125 = 125,
            _150 = 150,
            _200 = 200,
            _400 = 400,
            Target16 = 16,
            Target24 = 24,
            Target32 = 32,
            Target48 = 48,
            Target256 = 256,
            [Obsolete("Image scale 80 is not used in Universal Windows Platform", False)]
            _80 = 80,
            [Obsolete("Image scale 140 is not used in Universal Windows Platform", False)]
            _140 = 140,
            [Obsolete("Image scale 180 is not used in Universal Windows Platform", False)]
            _180 = 180,
            [Obsolete("Image scale 240 is not used in Universal Windows Platform", False)]
            _240 = 240
        }
        public enum WSAImageType
        {
            PackageLogo = 1,
            SplashScreenImage = 2,
            UWPSquare44x44Logo = 31,
            UWPSquare71x71Logo = 32,
            UWPSquare150x150Logo = 33,
            UWPSquare310x310Logo = 34,
            UWPWide310x150Logo = 35
        }
        public enum WSAInputSource
        {
            CoreWindow = 0,
            IndependentInputSource = 1,
            SwapChainPanel = 2
        }
        [RequiredByNativeCode]
        public struct WSASupportedFileType
        {
            public string contentType;
            public string fileType;
        }
        public struct WSAFileTypeAssociations
        {
            public string name;
            public WSASupportedFileType[] supportedFileTypes;
        }
        [NativeHeader("Editor/Mono/PlayerSettingsWSA.bindings.h")]
        [StaticAccessor("PlayerSettingsBindings::WSA", DoubleColon)]
        [NativeHeader("Runtime/Misc/PlayerSettings.h")]
        public sealed class WSA
        {
            public WSA();

            [StaticAccessor("GetPlayerSettings()", Dot)]
            [NativeProperty("wsaTransparentSwapchain", Field)]
            public static bool transparentSwapchain { get; set; }
            public static string packageName { get; set; }
            public static string packageLogo { get; set; }
            [Obsolete("PlayerSettings.WSA.commandLineArgsFile is deprecated", True)]
            [EditorBrowsable(Never)]
            public static string commandLineArgsFile { get; set; }
            [StaticAccessor("GetPlayerSettings().GetEditorOnly()", Dot)]
            [NativeProperty("metroCertificatePath", Field)]
            public static string certificatePath { get; }
            public static string certificateSubject { get; }
            public static string certificateIssuer { get; }
            public static string applicationDescription { get; set; }
            public static string tileShortName { get; set; }
            [NativeProperty("metroTileShowName", Field)]
            public static WSAApplicationShowName tileShowName { get; set; }
            [NativeProperty("metroMediumTileShowName", Field)]
            public static bool mediumTileShowName { get; set; }
            [NativeProperty("metroLargeTileShowName", Field)]
            public static bool largeTileShowName { get; set; }
            [NativeProperty("metroWideTileShowName", Field)]
            public static bool wideTileShowName { get; set; }
            [NativeProperty("metroDefaultTileSize", Field)]
            public static WSADefaultTileSize defaultTileSize { get; set; }
            [NativeProperty("metroTileForegroundText", Field)]
            public static WSAApplicationForegroundText tileForegroundText { get; set; }
            [NativeProperty("metroTileBackgroundColor", Field)]
            public static Color tileBackgroundColor { get; set; }
            [Obsolete("PlayerSettings.WSA.enableIndependentInputSource is deprecated. Use PlayerSettings.WSA.inputSource.", False)]
            public static bool enableIndependentInputSource { get; set; }
            [StaticAccessor("GetPlayerSettings()", Dot)]
            [NativeProperty("metroInputSource", Field)]
            public static WSAInputSource inputSource { get; set; }
            [NativeProperty("metroSupportStreamingInstall", Field)]
            public static bool supportStreamingInstall { get; set; }
            [NativeProperty("metroLastRequiredScene", Field)]
            public static int lastRequiredScene { get; set; }
            public static string vcxProjDefaultLanguage { get; set; }
            public static Version packageVersion { get; set; }
            public static DateTime? certificateNotAfter { get; }
            public static Color? splashScreenBackgroundColor { get; set; }
            [EditorBrowsable(Never)]
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            public static string storeTileLogo80 { get; set; }
            [EditorBrowsable(Never)]
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            public static string storeTileLogo { get; set; }
            [EditorBrowsable(Never)]
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            public static string storeTileLogo140 { get; set; }
            [EditorBrowsable(Never)]
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            public static string storeTileLogo180 { get; set; }
            [EditorBrowsable(Never)]
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            public static string storeTileWideLogo80 { get; set; }
            [EditorBrowsable(Never)]
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            public static string storeTileWideLogo { get; set; }
            [EditorBrowsable(Never)]
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            public static string storeTileWideLogo140 { get; set; }
            [EditorBrowsable(Never)]
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            public static string storeTileWideLogo180 { get; set; }
            [EditorBrowsable(Never)]
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            public static string storeTileSmallLogo80 { get; set; }
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            [EditorBrowsable(Never)]
            public static string storeTileSmallLogo { get; set; }
            [EditorBrowsable(Never)]
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            public static string storeTileSmallLogo140 { get; set; }
            [EditorBrowsable(Never)]
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            public static string storeTileSmallLogo180 { get; set; }
            [EditorBrowsable(Never)]
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            public static string storeSmallTile80 { get; set; }
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            [EditorBrowsable(Never)]
            public static string storeSmallTile { get; set; }
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            [EditorBrowsable(Never)]
            public static string storeSmallTile140 { get; set; }
            [EditorBrowsable(Never)]
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            public static string storeSmallTile180 { get; set; }
            [EditorBrowsable(Never)]
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            public static string storeLargeTile80 { get; set; }
            [EditorBrowsable(Never)]
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            public static string storeLargeTile { get; set; }
            [EditorBrowsable(Never)]
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            public static string storeLargeTile140 { get; set; }
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            [EditorBrowsable(Never)]
            public static string storeLargeTile180 { get; set; }
            [EditorBrowsable(Never)]
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            public static string storeSplashScreenImage { get; set; }
            [EditorBrowsable(Never)]
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            public static string storeSplashScreenImageScale140 { get; set; }
            [EditorBrowsable(Never)]
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            public static string storeSplashScreenImageScale180 { get; set; }
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            [EditorBrowsable(Never)]
            public static string phoneAppIcon { get; set; }
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            [EditorBrowsable(Never)]
            public static string phoneAppIcon140 { get; set; }
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            [EditorBrowsable(Never)]
            public static string phoneAppIcon240 { get; set; }
            [EditorBrowsable(Never)]
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            public static string phoneSmallTile { get; set; }
            [EditorBrowsable(Never)]
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            public static string phoneSmallTile140 { get; set; }
            [EditorBrowsable(Never)]
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            public static string phoneSmallTile240 { get; set; }
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            [EditorBrowsable(Never)]
            public static string phoneMediumTile { get; set; }
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            [EditorBrowsable(Never)]
            public static string phoneMediumTile140 { get; set; }
            [EditorBrowsable(Never)]
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            public static string phoneMediumTile240 { get; set; }
            [EditorBrowsable(Never)]
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            public static string phoneWideTile { get; set; }
            [EditorBrowsable(Never)]
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            public static string phoneWideTile140 { get; set; }
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            [EditorBrowsable(Never)]
            public static string phoneWideTile240 { get; set; }
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            [EditorBrowsable(Never)]
            public static string phoneSplashScreenImage { get; set; }
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            [EditorBrowsable(Never)]
            public static string phoneSplashScreenImageScale140 { get; set; }
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            [EditorBrowsable(Never)]
            public static string phoneSplashScreenImageScale240 { get; set; }
            [EditorBrowsable(Never)]
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            public static string packageLogo140 { get; set; }
            [EditorBrowsable(Never)]
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            public static string packageLogo180 { get; set; }
            [EditorBrowsable(Never)]
            [Obsolete("Use GetVisualAssetsImage()/SetVisualAssetsImage()", True)]
            public static string packageLogo240 { get; set; }
            [EditorBrowsable(Never)]
            [Obsolete("PlayerSettings.enableLowLatencyPresentationAPI is deprecated. It is now always enabled.", True)]
            public static bool enableLowLatencyPresentationAPI { get; set; }

            [NativeThrows]
            public static bool SetCertificate(string path, string password);
            public static string GetVisualAssetsImage(WSAImageType type, WSAImageScale scale);
            public static void SetVisualAssetsImage(string image, WSAImageType type, WSAImageScale scale);
            public static void SetCapability(WSACapability capability, bool value);
            public static bool GetCapability(WSACapability capability);
            public static void SetTargetDeviceFamily(WSATargetFamily family, bool value);
            public static bool GetTargetDeviceFamily(WSATargetFamily family);

            public static class Declarations
            {
                public static string protocolName { get; set; }
                public static WSAFileTypeAssociations fileTypeAssociations { get; set; }
            }
        }
        [NativeHeader("Runtime/Misc/PlayerSettings.h")]
        [StaticAccessor("GetPlayerSettings().GetEditorOnlyForUpdate()", Dot)]
        public sealed class XboxOne
        {
            public XboxOne();

            [NativeProperty("XboxOneXTitleMemory", Field)]
            public static int XTitleMemory { get; set; }
            [NativeProperty("XboxOneLoggingLevel")]
            [StaticAccessor("GetPlayerSettings()", Dot)]
            public static XboxOneLoggingLevel defaultLoggingLevel { get; set; }
            [NativeProperty("XboxOneProductId", False, Function)]
            public static string ProductId { get; set; }
            [NativeProperty("XboxOneUpdateKey", False, Function)]
            public static string UpdateKey { get; set; }
            [Obsolete("SandboxId is obsolete please remove")]
            [NativeProperty("XboxOneSandboxId", False, Function)]
            public static string SandboxId { get; set; }
            [NativeProperty("XboxOneContentId", False, Function)]
            public static string ContentId { get; set; }
            [NativeProperty("XboxOneTitleId", False, Function)]
            public static string TitleId { get; set; }
            [NativeProperty("XboxOneSCId", False, Function)]
            public static string SCID { get; set; }
            [NativeProperty("XboxOneEnableGPUVariability", Field)]
            public static bool EnableVariableGPU { get; set; }
            [StaticAccessor("GetPlayerSettings()", Dot)]
            [NativeProperty("XboxOnePresentImmediateThreshold")]
            public static uint PresentImmediateThreshold { get; set; }
            [StaticAccessor("GetPlayerSettings()", Dot)]
            [NativeProperty("XboxOneEnable7thCore")]
            public static bool Enable7thCore { get; set; }
            [StaticAccessor("GetPlayerSettings()", Dot)]
            [NativeProperty("XboxOneDisableKinectGpuReservation")]
            public static bool DisableKinectGpuReservation { get; set; }
            [NativeProperty("XboxEnablePIXSampling")]
            [StaticAccessor("GetPlayerSettings()", Dot)]
            public static bool EnablePIXSampling { get; set; }
            [NativeProperty("XboxOneGameOsOverridePath", False, Function)]
            public static string GameOsOverridePath { get; set; }
            [NativeProperty("XboxOnePackagingOverridePath", False, Function)]
            public static string PackagingOverridePath { get; set; }
            [NativeProperty("XboxOnePackageEncryption", Field)]
            public static XboxOneEncryptionLevel PackagingEncryption { get; set; }
            [NativeProperty("XboxOnePackageUpdateGranularity", Field)]
            public static XboxOnePackageUpdateGranularity PackageUpdateGranularity { get; set; }
            [NativeProperty("XboxOneOverrideIdentityName", False, Function)]
            public static string OverrideIdentityName { get; set; }
            [NativeProperty("XboxOneOverrideIdentityPublisher", False, Function)]
            public static string OverrideIdentityPublisher { get; set; }
            [NativeProperty("XboxOneAppManifestOverridePath", False, Function)]
            public static string AppManifestOverridePath { get; set; }
            [NativeProperty("XboxOneIsContentPackage", Field)]
            public static bool IsContentPackage { get; set; }
            [NativeProperty("XboxOneEnhancedXboxCompatibilityMode", Field)]
            public static bool EnhancedXboxCompatibilityMode { get; set; }
            [NativeProperty("XboxOneVersion", False, Function)]
            public static string Version { get; set; }
            [NativeProperty("XboxOneDescription", False, Function)]
            public static string Description { get; set; }
            [StaticAccessor("GetPlayerSettings().GetEditorOnlyForUpdate()", Dot)]
            public static string[] SocketNames { get; }
            [StaticAccessor("GetPlayerSettings().GetEditorOnlyForUpdate()", Dot)]
            public static string[] AllowedProductIds { get; }
            public static uint PersistentLocalStorageSize { get; set; }
            [StaticAccessor("GetPlayerSettings()", Dot)]
            [NativeProperty("XboxOneEnableTypeOptimization")]
            public static bool EnableTypeOptimization { get; set; }
            [StaticAccessor("GetPlayerSettings()", Dot)]
            [NativeProperty("XboxOneMonoLoggingLevel")]
            public static int monoLoggingLevel { get; set; }
            [Obsolete("Mono script compiler is no longer supported.")]
            public static ScriptCompiler scriptCompiler { get; set; }

            [NativeMethod("SetXboxOneCapability")]
            [StaticAccessor("GetPlayerSettings().GetEditorOnlyForUpdate()", Dot)]
            public static void SetCapability(string capability, bool value);
            [StaticAccessor("GetPlayerSettings().GetEditorOnly()", Dot)]
            [NativeMethod("GetXboxOneCapability")]
            public static bool GetCapability(string capability);
            [NativeMethod("SetXboxOneLanguage")]
            [StaticAccessor("GetPlayerSettings().GetEditorOnlyForUpdate()", Dot)]
            public static void SetSupportedLanguage(string language, bool enabled);
            [NativeMethod("GetXboxOneLanguage")]
            [StaticAccessor("GetPlayerSettings().GetEditorOnly()", Dot)]
            public static bool GetSupportedLanguage(string language);
            [NativeMethod("RemoveXboxOneSocketDefinition")]
            [StaticAccessor("GetPlayerSettings().GetEditorOnlyForUpdate()", Dot)]
            public static void RemoveSocketDefinition(string name);
            [NativeMethod("SetXboxOneSocketDefinition")]
            [StaticAccessor("GetPlayerSettings().GetEditorOnlyForUpdate()", Dot)]
            public static void SetSocketDefinition(string name, string port, int protocol, int[] usages, string templateName, int sessionRequirment, int[] deviceUsages);
            public static void GetSocketDefinition(string name, out string port, out int protocol, out int[] usages, out string templateName, out int sessionRequirment, out int[] deviceUsages);
            [StaticAccessor("GetPlayerSettings().GetEditorOnlyForUpdate()", Dot)]
            [NativeMethod("RemoveXboxOneAllowedProductId")]
            public static void RemoveAllowedProductId(string id);
            [NativeMethod("AddXboxOneAllowedProductId")]
            [StaticAccessor("GetPlayerSettings().GetEditorOnlyForUpdate()", Dot)]
            public static bool AddAllowedProductId(string id);
            [NativeMethod("UpdateXboxOneAllowedProductId")]
            [StaticAccessor("GetPlayerSettings().GetEditorOnlyForUpdate()", Dot)]
            public static void UpdateAllowedProductId(int idx, string id);
            [StaticAccessor("GetPlayerSettings().GetEditorOnlyForUpdate()", Dot)]
            [Obsolete("Starting May 11th 2020 any new base game submission releasing digital only, digital and disc, or disc only, should not include a ratings element in the AppxManifest. This ratings policy update applies to all Xbox supported ratings. New base submissions that come in on or after this date will be rejected by your Microsoft Representative if a ratings element is present.", False)]
            [NativeMethod("SetXboxOneGameRating")]
            public static void SetGameRating(string name, int value);
            [StaticAccessor("GetPlayerSettings().GetEditorOnly()", Dot)]
            [Obsolete("Starting May 11th 2020 any new base game submission releasing digital only, digital and disc, or disc only, should not include a ratings element in the AppxManifest. This ratings policy update applies to all Xbox supported ratings. New base submissions that come in on or after this date will be rejected by your Microsoft Representative if a ratings element is present.", False)]
            [NativeMethod("GetXboxOneGameRating")]
            public static int GetGameRating(string name);
        }
        [Obsolete("This API is deprecated and will be removed in 2020.2.", False)]
        public static class VRWindowsMixedReality
        {
            [Obsolete("This API is deprecated and will be removed in 2020.2.", False)]
            public static DepthBufferFormat depthBufferFormat { get; set; }
            [Obsolete("This API is deprecated and will be removed in 2020.2.", False)]
            public static bool depthBufferSharingEnabled { get; set; }

            [Obsolete("This API is deprecated and will be removed in 2020.2.", False)]
            public enum DepthBufferFormat
            {
                DepthBufferFormat16Bit = 0,
                DepthBufferFormat24Bit = 1
            }
        }
    }
}
using System;

namespace UnityEditor
{
    [Obsolete("Use AndroidArchitecture instead. (UnityUpgradable) -> AndroidArchitecture", False)]
    public enum AndroidTargetDevice
    {
        [Obsolete("Use AndroidArchitecture.All instead. (UnityUpgradable) -> AndroidArchitecture.All", False)]
        FAT = 0,
        [Obsolete("Use AndroidArchitecture.ARMv7 instead. (UnityUpgradable) -> AndroidArchitecture.ARMv7", False)]
        ARMv7 = 3
    }
}
using System;

namespace UnityEditor
{
    [Obsolete("TargetGlesGraphics is ignored, use SetGraphicsAPIs/GetGraphicsAPIs APIs", False)]
    public enum TargetGlesGraphics
    {
        OpenGLES_1_x = 0,
        OpenGLES_2_0 = 1,
        OpenGLES_3_0 = 2,
        Automatic = -1
    }
}
using System;

namespace UnityEditor
{
    [Obsolete("TargetIOSGraphics is ignored, use SetGraphicsAPIs/GetGraphicsAPIs APIs", False)]
    public enum TargetIOSGraphics
    {
        OpenGLES_2_0 = 2,
        OpenGLES_3_0 = 3,
        Metal = 4,
        Automatic = -1
    }
}
using System;
using System.ComponentModel;

namespace UnityEditor
{
    [EditorBrowsable(Never)]
    [Obsolete("Use Screen.SetResolution APIs", True)]
    public enum iOSTargetResolution
    {
        Native = 0,
        ResolutionAutoPerformance = 3,
        ResolutionAutoQuality = 4,
        Resolution320p = 5,
        Resolution640p = 6,
        Resolution768p = 7
    }
}
using System;

namespace UnityEditor
{
    [Obsolete("targetOSVersion is obsolete, use targetOSVersionString", False)]
    public enum iOSTargetOSVersion
    {
        iOS_4_0 = 10,
        iOS_4_1 = 12,
        iOS_4_2 = 14,
        iOS_4_3 = 16,
        iOS_5_0 = 18,
        iOS_5_1 = 20,
        iOS_6_0 = 22,
        iOS_7_0 = 24,
        iOS_7_1 = 26,
        iOS_8_0 = 28,
        iOS_8_1 = 30,
        Unknown = 999
    }
}
using System;

namespace UnityEditor
{
    [Obsolete("Use UnityEngine.iOS.SystemGestureDeferMode instead. (UnityUpgradable) -> [UnityEngine] UnityEngine.iOS.SystemGestureDeferMode", True)]
    [Flags]
    public enum iOSSystemGestureDeferMode
    {
        None = 0,
        TopEdge = 1,
        LeftEdge = 2,
        BottomEdge = 4,
        RightEdge = 8,
        All = 15
    }
}
using System;

namespace UnityEditor
{
    [Flags]
    public enum AndroidArchitecture
    {
        None = 0,
        ARMv7 = 1,
        ARM64 = 2,
        X86 = 4,
        X86_64 = 8,
        All = 4294967295
    }
}
namespace UnityEditor
{
    public enum AndroidTargetDevices
    {
        AllDevices = 0,
        PhonesTabletsAndTVDevicesOnly = 1,
        ChromeOSDevicesOnly = 2
    }
}
using System;

namespace UnityEditor
{
    public enum AndroidSdkVersions
    {
        AndroidApiLevelAuto = 0,
        [Obsolete("Minimum supported Android API level is 19 (Android 4.4 KitKat). Please use AndroidApiLevel19 or higher", True)]
        AndroidApiLevel16 = 16,
        [Obsolete("Minimum supported Android API level is 19 (Android 4.4 KitKat). Please use AndroidApiLevel19 or higher", True)]
        AndroidApiLevel17 = 17,
        [Obsolete("Minimum supported Android API level is 19 (Android 4.4 KitKat). Please use AndroidApiLevel19 or higher", True)]
        AndroidApiLevel18 = 18,
        AndroidApiLevel19 = 19,
        AndroidApiLevel21 = 21,
        AndroidApiLevel22 = 22,
        AndroidApiLevel23 = 23,
        AndroidApiLevel24 = 24,
        AndroidApiLevel25 = 25,
        AndroidApiLevel26 = 26,
        AndroidApiLevel27 = 27,
        AndroidApiLevel28 = 28,
        AndroidApiLevel29 = 29,
        AndroidApiLevel30 = 30
    }
}
namespace UnityEditor
{
    public enum AndroidPreferredInstallLocation
    {
        Auto = 0,
        PreferExternal = 1,
        ForceInternal = 2
    }
}
namespace UnityEditor
{
    public enum AndroidShowActivityIndicatorOnLoading
    {
        Large = 0,
        InversedLarge = 1,
        Small = 2,
        InversedSmall = 3,
        DontShow = -1
    }
}
namespace UnityEditor
{
    public enum AndroidGamepadSupportLevel
    {
        SupportsDPad = 0,
        SupportsGamepad = 1,
        RequiresGamepad = 2
    }
}
namespace UnityEditor
{
    public enum AndroidSplashScreenScale
    {
        Center = 0,
        ScaleToFit = 1,
        ScaleToFill = 2
    }
}
namespace UnityEditor
{
    public enum AndroidBlitType
    {
        Always = 0,
        Never = 1,
        Auto = 2
    }
}
using System;
using System.ComponentModel;

namespace UnityEditor
{
    [Flags]
    public enum AppleMobileArchitecture
    {
        [EditorBrowsable(Never)]
        [Obsolete("ARMv7 is no longer supported", True)]
        ARMv7 = 0,
        ARM64 = 1,
        Universal = 2
    }
}
namespace UnityEditor
{
    public enum iOSSdkVersion
    {
        DeviceSDK = 988,
        SimulatorSDK = 989
    }
}
namespace UnityEditor
{
    public enum iOSTargetDevice
    {
        iPhoneOnly = 0,
        iPadOnly = 1,
        iPhoneAndiPad = 2
    }
}
namespace UnityEditor
{
    public enum iOSShowActivityIndicatorOnLoading
    {
        WhiteLarge = 0,
        White = 1,
        Gray = 2,
        DontShow = -1
    }
}
using System;
using System.ComponentModel;

namespace UnityEditor
{
    public enum iOSStatusBarStyle
    {
        Default = 0,
        LightContent = 1,
        [Obsolete("BlackTranslucent has no effect, use LightContent instead (UnityUpgradable) -> LightContent", True)]
        [EditorBrowsable(Never)]
        BlackTranslucent = -1,
        [Obsolete("BlackOpaque has no effect, use LightContent instead (UnityUpgradable) -> LightContent", True)]
        [EditorBrowsable(Never)]
        BlackOpaque = -1
    }
}
using System;

namespace UnityEditor
{
    public enum iOSAppInBackgroundBehavior
    {
        Custom = -1,
        Suspend = 0,
        [Obsolete("UIApplicationExitsOnSuspend is no longer supported in iOS 13, use Custom or Suspend instead (UnityUpgradable) -> Custom", True)]
        Exit = 1
    }
}
using System;

namespace UnityEditor
{
    [Flags]
    public enum iOSBackgroundMode
    {
        None = 0,
        Audio = 1,
        Location = 2,
        VOIP = 4,
        NewsstandContent = 8,
        ExternalAccessory = 16,
        BluetoothCentral = 32,
        BluetoothPeripheral = 64,
        Fetch = 128,
        RemoteNotification = 256
    }
}
namespace UnityEditor
{
    public enum iOSLaunchScreenImageType
    {
        iPhonePortraitImage = 0,
        iPhoneLandscapeImage = 1,
        iPadImage = 2
    }
}
using System;

namespace UnityEditor
{
    public enum iOSLaunchScreenType
    {
        Default = 0,
        ImageAndBackgroundRelative = 1,
        ImageAndBackgroundConstant = 4,
        CustomXib = 2,
        CustomStoryboard = 5,
        [Obsolete("Launch Images are no longer supported by Apple. (UnityUpgradable) -> Default", True)]
        None = 3
    }
}
namespace UnityEditor
{
    public enum ProvisioningProfileType
    {
        Automatic = 0,
        Development = 1,
        Distribution = 2
    }
}
using System.Collections.Generic;

namespace UnityEditor
{
    public class iOSDeviceRequirement
    {
        public iOSDeviceRequirement();

        public IDictionary<string, string> values { get; }
    }
}
namespace UnityEditor
{
    public enum tvOSSdkVersion
    {
        Device = 0,
        Simulator = 1
    }
}
using System;

namespace UnityEditor
{
    [Obsolete("targetOSVersion is obsolete. Use targetOSVersionString instead.", False)]
    public enum tvOSTargetOSVersion
    {
        Unknown = 0,
        tvOS_9_0 = 900,
        tvOS_9_1 = 901
    }
}
namespace UnityEditor
{
    public enum WebGLExceptionSupport
    {
        None = 0,
        ExplicitlyThrownExceptionsOnly = 1,
        FullWithoutStacktrace = 2,
        FullWithStacktrace = 3
    }
}
namespace UnityEditor
{
    public enum WebGLCompressionFormat
    {
        Brotli = 0,
        Gzip = 1,
        Disabled = 2
    }
}
using System;

namespace UnityEditor
{
    public enum WebGLLinkerTarget
    {
        Asm = 0,
        Wasm = 1,
        [Obsolete("WebGLLinkerTarget.Both mode is no longer supported. Instead you can create separate asm.js and WebAssembly builds and download the appropriate one depending on the browser capabilities.", True)]
        Both = 2
    }
}
namespace UnityEditor
{
    public enum WebGLWasmArithmeticExceptions
    {
        Throw = 0,
        Ignore = 1
    }
}
namespace UnityEditor
{
    public enum XboxOneEncryptionLevel
    {
        None = 0,
        DevkitCompatible = 1,
        FullEncryption = 2
    }
}
namespace UnityEditor
{
    public enum XboxOnePackageUpdateGranularity
    {
        Chunk = 1,
        File = 2
    }
}
namespace UnityEditor
{
    public enum XboxOneLoggingLevel
    {
        AllLogging = 4,
        WarningsAndErrors = 2,
        ErrorsOnly = 1
    }
}
using System;

namespace UnityEditor
{
    [Obsolete("Mono script compiler is no longer supported.")]
    public enum ScriptCompiler
    {
        Mono = 0,
        Roslyn = 1
    }
}
using System;

namespace UnityEditor
{
    [Obsolete("Use UnityEditor.AssetModificationProcessor")]
    public class SaveAssetsProcessor : AssetModificationProcessor
    {
        public SaveAssetsProcessor();
    }
}
using System;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace UnityEditor
{
    public class SceneVisibilityManager : ScriptableSingleton<SceneVisibilityManager>
    {
        public SceneVisibilityManager();

        public static event Action visibilityChanged;
        public static event Action pickingChanged;

        public void HideAll();
        public void DisableAllPicking();
        public void Show(GameObject gameObject, bool includeDescendants);
        public void Hide(GameObject gameObject, bool includeDescendants);
        public void DisablePicking(GameObject gameObject, bool includeDescendants);
        public void EnablePicking(GameObject gameObject, bool includeDescendants);
        public void ShowAll();
        public void EnableAllPicking();
        public void Show(Scene scene);
        public void EnablePicking(Scene scene);
        public void Hide(Scene scene);
        public void DisablePicking(Scene scene);
        public bool IsHidden(GameObject gameObject, bool includeDescendants = False);
        public bool IsHidden(Scene scene);
        public bool IsPickingDisabled(GameObject gameObject, bool includeDescendants = False);
        public bool IsPickingDisabled(Scene scene);
        public bool AreAllDescendantsHidden(Scene scene);
        public bool IsPickingDisabledOnAllDescendants(Scene scene);
        public bool AreAnyDescendantsHidden(Scene scene);
        public bool IsPickingDisabledOnAnyDescendant(Scene scene);
        public void Show(GameObject[] gameObjects, bool includeDescendants);
        public void Hide(GameObject[] gameObjects, bool includeDescendants);
        public void DisablePicking(GameObject[] gameObjects, bool includeDescendants);
        public void EnablePicking(GameObject[] gameObjects, bool includeDescendants);
        public void Isolate(GameObject gameObject, bool includeDescendants);
        public void Isolate(GameObject[] gameObjects, bool includeDescendants);
        public void ToggleVisibility(GameObject gameObject, bool includeDescendants);
        public void TogglePicking(GameObject gameObject, bool includeDescendants);
        public bool AreAllDescendantsHidden(GameObject gameObject);
        public bool AreAllDescendantsVisible(GameObject gameObject);
        public bool IsPickingDisabledOnAllDescendants(GameObject gameObject);
        public bool IsPickingEnabledOnAllDescendants(GameObject gameObject);
        public bool IsCurrentStageIsolated();
        public void ExitIsolation();
    }
}
using System;

namespace UnityEditor
{
    [AttributeUsage(Class)]
    public class FilePathAttribute : Attribute
    {
        public FilePathAttribute(string relativePath, Location location);

        public enum Location
        {
            PreferencesFolder = 0,
            ProjectFolder = 1
        }
    }
}
using UnityEngine;

namespace UnityEditor
{
    public class ScriptableSingleton<T> : ScriptableObject where T : ScriptableObject
    {
        protected ScriptableSingleton();

        public static T instance { get; }

        protected virtual void Save(bool saveAsText);
        protected static string GetFilePath();
    }
}
using System;
using UnityEngine.Internal;

namespace UnityEditor
{
    public class ScriptableWizard : EditorWindow
    {
        public ScriptableWizard();

        public string helpString { get; set; }
        public string errorString { get; set; }
        public string createButtonName { get; set; }
        public string otherButtonName { get; set; }
        public bool isValid { get; set; }

        protected virtual bool DrawWizardGUI();
        public static T DisplayWizard<T>(string title) where T : ScriptableWizard;
        public static T DisplayWizard<T>(string title, string createButtonName) where T : ScriptableWizard;
        public static T DisplayWizard<T>(string title, string createButtonName, string otherButtonName) where T : ScriptableWizard;
        [ExcludeFromDocs]
        public static ScriptableWizard DisplayWizard(string title, Type klass, string createButtonName);
        [ExcludeFromDocs]
        public static ScriptableWizard DisplayWizard(string title, Type klass);
        public static ScriptableWizard DisplayWizard(string title, Type klass, [DefaultValue("\"Create\"")] string createButtonName, [DefaultValue("\"\"")] string otherButtonName);
    }
}
using System;

namespace UnityEditor
{
    [Flags]
    public enum SelectionMode
    {
        Unfiltered = 0,
        TopLevel = 1,
        Deep = 2,
        ExcludePrefab = 4,
        Editable = 8,
        Assets = 16,
        DeepAssets = 32,
        [Obsolete("'OnlyUserModifiable' is obsolete. Use 'Editable' instead. (UnityUpgradeable) -> Editable", True)]
        OnlyUserModifiable = 8
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Editor/Src/Selection.bindings.h")]
    [NativeHeader("Editor/Src/SceneInspector.h")]
    [NativeHeader("Editor/Src/Selection.h")]
    [NativeHeader("Editor/Src/Gizmos/GizmoUtil.h")]
    public sealed class Selection
    {
        public static Action selectionChanged;

        public Selection();

        public static Transform[] transforms { get; }
        public static Transform activeTransform { get; set; }
        public static GameObject[] gameObjects { get; }
        public static GameObject activeGameObject { get; set; }
        public static UnityEngine.Object activeObject { get; set; }
        public static UnityEngine.Object activeContext { get; }
        [NativeName("ActiveID")]
        [StaticAccessor("Selection", DoubleColon)]
        public static int activeInstanceID { get; set; }
        [StaticAccessor("SelectionBindings", DoubleColon)]
        public static UnityEngine.Object[] objects { get; set; }
        [StaticAccessor("SelectionBindings", DoubleColon)]
        public static int[] instanceIDs { get; set; }
        [StaticAccessor("SelectionBindings", DoubleColon)]
        public static string[] assetGUIDs { get; }
        [NativeName("SelectionCount")]
        [StaticAccessor("Selection", DoubleColon)]
        public static int count { get; }

        [StaticAccessor("GetSceneTracker()", Dot)]
        [NativeMethod("IsSelected")]
        public static bool Contains(int instanceID);
        [NativeMethod("SetActiveObjectWithContextInternal", True)]
        public static void SetActiveObjectWithContext(UnityEngine.Object obj, UnityEngine.Object context);
        [NativeMethod("GetTransformSelection", True)]
        public static Transform[] GetTransforms(SelectionMode mode);
        public static bool Contains(UnityEngine.Object obj);
        public static T[] GetFiltered<T>(SelectionMode mode);
        public static UnityEngine.Object[] GetFiltered(Type type, SelectionMode mode);
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Editor/Src/Utility/SerializedProperty.h")]
    [NativeHeader("Editor/Src/Utility/SerializedObject.bindings.h")]
    [NativeHeader("Editor/Src/Utility/SerializedObjectCache.h")]
    public class SerializedObject : IDisposable
    {
        public SerializedObject(UnityEngine.Object obj);
        public SerializedObject(UnityEngine.Object obj, UnityEngine.Object context);
        public SerializedObject(UnityEngine.Object[] objs);
        public SerializedObject(UnityEngine.Object[] objs, UnityEngine.Object context);

        ~SerializedObject();

        public UnityEngine.Object targetObject { get; }
        public UnityEngine.Object[] targetObjects { get; }
        [NativeProperty("ContextObject")]
        public UnityEngine.Object context { get; }
        public bool hasModifiedProperties { get; }
        public bool isEditingMultipleObjects { get; }
        public int maxArraySizeForMultiEditing { get; set; }

        [ThreadAndSerializationSafe]
        public void Dispose();
        public SerializedProperty GetIterator();
        public SerializedProperty FindProperty(string propertyPath);
        public bool ApplyModifiedProperties();
        public void SetIsDifferentCacheDirty();
        public void Update();
        [NativeName("UpdateIfRequiredOrScript")]
        [Obsolete("UpdateIfDirtyOrScript has been deprecated. Use UpdateIfRequiredOrScript instead.", False)]
        public void UpdateIfDirtyOrScript();
        public bool UpdateIfRequiredOrScript();
        public bool ApplyModifiedPropertiesWithoutUndo();
        public void CopyFromSerializedProperty(SerializedProperty prop);
        public bool CopyFromSerializedPropertyIfDifferent(SerializedProperty prop);
    }
}
namespace UnityEditor
{
    public enum SerializedPropertyType
    {
        Generic = -1,
        Integer = 0,
        Boolean = 1,
        Float = 2,
        String = 3,
        Color = 4,
        ObjectReference = 5,
        LayerMask = 6,
        Enum = 7,
        Vector2 = 8,
        Vector3 = 9,
        Vector4 = 10,
        Rect = 11,
        ArraySize = 12,
        Character = 13,
        AnimationCurve = 14,
        Bounds = 15,
        Gradient = 16,
        Quaternion = 17,
        ExposedReference = 18,
        FixedBufferSize = 19,
        Vector2Int = 20,
        Vector3Int = 21,
        RectInt = 22,
        BoundsInt = 23,
        ManagedReference = 24
    }
}
using System;
using System.Collections;
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Editor/Src/Utility/SerializedProperty.h")]
    [NativeHeader("Editor/Src/Utility/SerializedProperty.bindings.h")]
    public class SerializedProperty : IDisposable
    {
        ~SerializedProperty();

        public SerializedObject serializedObject { get; }
        public UnityEngine.Object exposedReferenceValue { get; set; }
        public bool hasMultipleDifferentValues { get; }
        public string displayName { get; }
        public string name { get; }
        public string type { get; }
        public string arrayElementType { get; }
        public string tooltip { get; }
        public int depth { get; }
        public string propertyPath { get; }
        public bool editable { get; }
        public bool isAnimated { get; }
        public bool isExpanded { get; set; }
        public bool hasChildren { get; }
        public bool hasVisibleChildren { get; }
        public bool isInstantiatedPrefab { get; }
        public bool prefabOverride { get; set; }
        public bool isDefaultOverride { get; }
        public SerializedPropertyType propertyType { get; }
        public int intValue { get; set; }
        public long longValue { get; set; }
        public bool boolValue { get; set; }
        public float floatValue { get; set; }
        public double doubleValue { get; set; }
        public string stringValue { get; set; }
        public Color colorValue { get; set; }
        public AnimationCurve animationCurveValue { get; set; }
        public UnityEngine.Object objectReferenceValue { get; set; }
        public object managedReferenceValue { set; }
        public string managedReferenceFullTypename { get; }
        public string managedReferenceFieldTypename { get; }
        public int objectReferenceInstanceIDValue { get; set; }
        public int enumValueIndex { get; set; }
        public string[] enumNames { get; }
        public string[] enumDisplayNames { get; }
        public Vector2 vector2Value { get; set; }
        public Vector3 vector3Value { get; set; }
        public Vector4 vector4Value { get; set; }
        public Vector2Int vector2IntValue { get; set; }
        public Vector3Int vector3IntValue { get; set; }
        public Quaternion quaternionValue { get; set; }
        public Rect rectValue { get; set; }
        public RectInt rectIntValue { get; set; }
        public Bounds boundsValue { get; set; }
        public BoundsInt boundsIntValue { get; set; }
        public bool isArray { get; }
        public int arraySize { get; set; }
        public bool isFixedBuffer { get; }
        public int fixedBufferSize { get; }

        public SerializedProperty Copy();
        public SerializedProperty FindPropertyRelative(string relativePropertyPath);
        public IEnumerator GetEnumerator();
        public SerializedProperty GetArrayElementAtIndex(int index);
        public bool NextVisible(bool enterChildren);
        public void ClearArray();
        [ThreadAndSerializationSafe]
        public void Dispose();
        public static bool EqualContents(SerializedProperty x, SerializedProperty y);
        public static bool DataEquals(SerializedProperty x, SerializedProperty y);
        public bool Next(bool enterChildren);
        public void Reset();
        public int CountRemaining();
        public int CountInProperty();
        public bool DuplicateCommand();
        public bool DeleteCommand();
        public SerializedProperty GetEndProperty();
        public SerializedProperty GetEndProperty(bool includeInvisible);
        public void InsertArrayElementAtIndex(int index);
        public void DeleteArrayElementAtIndex(int index);
        public bool MoveArrayElement(int srcIndex, int dstIndex);
        public SerializedProperty GetFixedBufferElementAtIndex(int index);
    }
}
namespace UnityEditor
{
    public enum PreprocessorOverride
    {
        UseProjectSettings = 0,
        ForcePlatformPreprocessor = 1,
        ForceCachingPreprocessor = 2
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor
{
    [NativeHeader("Editor/Src/ShaderMenu.h")]
    [RequiredByNativeCode]
    public struct ShaderInfo
    {
        public string name { get; }
        public bool supported { get; }
        public bool hasErrors { get; }
    }
}
using System;
using UnityEditor.Rendering;

namespace UnityEditor
{
    public struct ShaderMessage : IEquatable<ShaderMessage>
    {
        public ShaderMessage(string msg, ShaderCompilerMessageSeverity sev = Error);

        public string message { get; }
        public string messageDetails { get; }
        public string file { get; }
        public int line { get; }
        public ShaderCompilerPlatform platform { get; }
        public ShaderCompilerMessageSeverity severity { get; }

        public bool Equals(ShaderMessage other);
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static bool operator ==(ShaderMessage left, ShaderMessage right);
        public static bool operator !=(ShaderMessage left, ShaderMessage right);
    }
}
using System;
using UnityEditor.AssetImporters;
using UnityEditor.Rendering;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Experimental.Rendering;
using UnityEngine.Rendering;

namespace UnityEditor
{
    [NativeHeader("Runtime/Shaders/GpuPrograms/GpuProgramManager.h")]
    [NativeHeader("Editor/Src/ShaderMenu.h")]
    [NativeHeader("Editor/Src/ShaderData.h")]
    [NativeHeader("Editor/Mono/ShaderUtil.bindings.h")]
    [NativeHeader("Editor/Mono/ShaderUtil.bindings.h")]
    public sealed class ShaderUtil
    {
        public ShaderUtil();

        public static bool hardwareSupportsRectRenderTexture { get; }
        public static bool anythingCompiling { get; }
        public static bool allowAsyncCompilation { get; set; }

        public static bool HasProceduralInstancing([NotNull("ArgumentNullException")] Shader s);
        public static int GetShaderMessageCount([NotNull("ArgumentNullException")] Shader s);
        public static ShaderMessage[] GetShaderMessages([NotNull("ArgumentNullException")] Shader s);
        public static void ClearShaderMessages([NotNull("ArgumentNullException")] Shader s);
        public static int GetComputeShaderMessageCount([NotNull("ArgumentNullException")] ComputeShader s);
        public static ShaderMessage[] GetComputeShaderMessages([NotNull("ArgumentNullException")] ComputeShader s);
        public static int GetRayTracingShaderMessageCount([NotNull("ArgumentNullException")] RayTracingShader s);
        public static ShaderMessage[] GetRayTracingShaderMessages([NotNull("ArgumentNullException")] RayTracingShader s);
        public static int GetRayGenerationShaderCount([NotNull("ArgumentNullException")] RayTracingShader s);
        public static string GetRayGenerationShaderName([NotNull("ArgumentNullException")] RayTracingShader s, int shaderIndex);
        public static int GetMissShaderCount([NotNull("ArgumentNullException")] RayTracingShader s);
        public static string GetMissShaderName([NotNull("ArgumentNullException")] RayTracingShader s, int shaderIndex);
        public static int GetMissShaderRayPayloadSize([NotNull("ArgumentNullException")] RayTracingShader s, int shaderIndex);
        public static int GetCallableShaderCount([NotNull("ArgumentNullException")] RayTracingShader s);
        public static string GetCallableShaderName([NotNull("ArgumentNullException")] RayTracingShader s, int shaderIndex);
        public static int GetCallableShaderParamSize([NotNull("ArgumentNullException")] RayTracingShader s, int shaderIndex);
        public static void ClearCachedData([NotNull("ArgumentNullException")] Shader s);
        public static Shader CreateShaderAsset(AssetImportContext context, string source, bool compileInitialShaderVariants);
        public static Shader CreateShaderAsset(string source);
        public static Shader CreateShaderAsset(string source, bool compileInitialShaderVariants);
        public static void UpdateShaderAsset(AssetImportContext context, [NotNull("ArgumentNullException")] Shader shader, [NotNull("ArgumentNullException")] string source, bool compileInitialShaderVariants);
        public static void UpdateShaderAsset(Shader shader, string source);
        public static void UpdateShaderAsset(Shader shader, string source, bool compileInitialShaderVariants);
        [FreeFunction("GetScriptMapper().AddShader")]
        public static void RegisterShader([NotNull("NullExceptionObject")] Shader shader);
        [FreeFunction]
        public static ShaderInfo[] GetAllShaderInfo();
        public static void SetAsyncCompilation([NotNull("ArgumentNullException")] CommandBuffer cmd, bool allow);
        public static void RestoreAsyncCompilation([NotNull("ArgumentNullException")] CommandBuffer cmd);
        public static bool IsPassCompiled([NotNull("ArgumentNullException")] Material material, int pass);
        public static void CompilePass([NotNull("ArgumentNullException")] Material material, int pass, bool forceSync = False);
        public static BuiltinShaderDefine[] GetShaderPlatformKeywordsForBuildTarget(ShaderCompilerPlatform shaderCompilerPlatform, BuildTarget buildTarget, GraphicsTier tier);
        public static BuiltinShaderDefine[] GetShaderPlatformKeywordsForBuildTarget(ShaderCompilerPlatform shaderCompilerPlatform, BuildTarget buildTarget);
        [NativeName("ClearShaderMessages")]
        [Obsolete("ClearShaderErrors has been deprecated. Use ClearShaderMessages instead (UnityUpgradable) -> ClearShaderMessages(*)")]
        public static void ClearShaderErrors([NotNull("ArgumentNullException")] Shader s);
        public static int GetPropertyCount(Shader s);
        public static string GetPropertyName(Shader s, int propertyIdx);
        public static ShaderPropertyType GetPropertyType(Shader s, int propertyIdx);
        public static string GetPropertyDescription(Shader s, int propertyIdx);
        public static float GetRangeLimits(Shader s, int propertyIdx, int defminmax);
        public static TextureDimension GetTexDim(Shader s, int propertyIdx);
        public static bool IsShaderPropertyHidden(Shader s, int propertyIdx);
        public static bool IsShaderPropertyNonModifiableTexureProperty(Shader s, int propertyIdx);
        public static ShaderData GetShaderData(Shader shader);
        public static bool ShaderHasError(Shader shader);

        [Obsolete("Use UnityEngine.Rendering.TextureDimension instead.")]
        public enum ShaderPropertyTexDim
        {
            TexDimNone = 0,
            TexDim2D = 2,
            TexDim3D = 3,
            TexDimCUBE = 4,
            TexDimAny = 6
        }
        public enum ShaderPropertyType
        {
            Color = 0,
            Vector = 1,
            Float = 2,
            Range = 3,
            TexEnv = 4
        }
    }
}
using System.Diagnostics;
using UnityEditor.Rendering;
using UnityEngine;
using UnityEngine.Rendering;

namespace UnityEditor
{
    public class ShaderData
    {
        public int ActiveSubshaderIndex { get; }
        public int SubshaderCount { get; }
        public Shader SourceShader { get; }
        public Subshader ActiveSubshader { get; }

        public Subshader GetSubshader(int index);

        public class Subshader
        {
            public int PassCount { get; }

            public Pass GetPass(int passIndex);
        }
        public class Pass
        {
            public string SourceCode { get; }
            public string Name { get; }

            public bool HasShaderStage(ShaderType shaderType);
            public VariantCompileInfo CompileVariant(ShaderType shaderType, string[] keywords, ShaderCompilerPlatform shaderCompilerPlatform, BuildTarget buildTarget);
            public VariantCompileInfo CompileVariant(ShaderType shaderType, string[] keywords, ShaderCompilerPlatform shaderCompilerPlatform, BuildTarget buildTarget, bool forExternalTool);
            public VariantCompileInfo CompileVariant(ShaderType shaderType, string[] keywords, ShaderCompilerPlatform shaderCompilerPlatform, BuildTarget buildTarget, GraphicsTier tier);
            public VariantCompileInfo CompileVariant(ShaderType shaderType, string[] keywords, ShaderCompilerPlatform shaderCompilerPlatform, BuildTarget buildTarget, GraphicsTier tier, bool forExternalTool);
            public VariantCompileInfo CompileVariant(ShaderType shaderType, string[] keywords, ShaderCompilerPlatform shaderCompilerPlatform, BuildTarget buildTarget, BuiltinShaderDefine[] platformKeywords);
            public VariantCompileInfo CompileVariant(ShaderType shaderType, string[] keywords, ShaderCompilerPlatform shaderCompilerPlatform, BuildTarget buildTarget, BuiltinShaderDefine[] platformKeywords, bool forExternalTool);
            public VariantCompileInfo CompileVariant(ShaderType shaderType, string[] keywords, ShaderCompilerPlatform shaderCompilerPlatform, BuildTarget buildTarget, BuiltinShaderDefine[] platformKeywords, GraphicsTier tier);
            public VariantCompileInfo CompileVariant(ShaderType shaderType, string[] keywords, ShaderCompilerPlatform shaderCompilerPlatform, BuildTarget buildTarget, BuiltinShaderDefine[] platformKeywords, GraphicsTier tier, bool forExternalTool);
            public PreprocessedVariant PreprocessVariant(ShaderType shaderType, string[] keywords, ShaderCompilerPlatform shaderCompilerPlatform, BuildTarget buildTarget, bool stripLineDirectives);
            public PreprocessedVariant PreprocessVariant(ShaderType shaderType, string[] keywords, ShaderCompilerPlatform shaderCompilerPlatform, BuildTarget buildTarget, GraphicsTier tier, bool stripLineDirectives);
            public PreprocessedVariant PreprocessVariant(ShaderType shaderType, string[] keywords, ShaderCompilerPlatform shaderCompilerPlatform, BuildTarget buildTarget, BuiltinShaderDefine[] platformKeywords, bool stripLineDirectives);
            public PreprocessedVariant PreprocessVariant(ShaderType shaderType, string[] keywords, ShaderCompilerPlatform shaderCompilerPlatform, BuildTarget buildTarget, BuiltinShaderDefine[] platformKeywords, GraphicsTier tier, bool stripLineDirectives);
        }
        public struct PreprocessedVariant
        {
            public bool Success { get; }
            public ShaderMessage[] Messages { get; }
            public string PreprocessedCode { get; }
        }
        public struct VariantCompileInfo
        {
            public bool Success;
            public ShaderMessage[] Messages;
            public byte[] ShaderData;
            public VertexAttribute[] Attributes;
            public ConstantBufferInfo[] ConstantBuffers;
            public TextureBindingInfo[] TextureBindings;
        }
        [DebuggerDisplay("cbuffer {Name} ({Size} bytes)")]
        public struct ConstantBufferInfo
        {
            public string Name;
            public int Size;
            public ConstantInfo[] Fields;
        }
        [DebuggerDisplay("{ConstantType} {Name} ({DataType} {Columns}x{Rows})")]
        public struct ConstantInfo
        {
            public string Name;
            public int Index;
            public ShaderConstantType ConstantType;
            public ShaderParamType DataType;
            public int Rows;
            public int Columns;
            public int ArraySize;
            public int StructSize;
            public ConstantInfo[] StructFields;
        }
        [DebuggerDisplay("{Dim} {Name}")]
        public struct TextureBindingInfo
        {
            public string Name;
            public int Index;
            public int SamplerIndex;
            public bool Multisampled;
            public int ArraySize;
            public TextureDimension Dim;
        }
    }
}
using System;
using System.ComponentModel;

namespace UnityEditor
{
    [Flags]
    public enum StaticEditorFlags
    {
        [Description("Contribute Global Illumination")]
        ContributeGI = 1,
        OccluderStatic = 2,
        OccludeeStatic = 16,
        BatchingStatic = 4,
        NavigationStatic = 8,
        OffMeshLinkGeneration = 32,
        ReflectionProbeStatic = 64,
        [Obsolete("Enum member StaticEditorFlags.LightmapStatic has been deprecated. Use StaticEditorFlags.ContributeGI instead. (UnityUpgradable) -> ContributeGI", False)]
        LightmapStatic = 1
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Runtime/Camera/RendererScene.h")]
    [NativeHeader("Editor/Src/OcclusionCulling.h")]
    [NativeHeader("Runtime/Camera/OcclusionCullingSettings.h")]
    public static class StaticOcclusionCulling
    {
        public static bool isRunning { get; }
        [StaticAccessor("GetOcclusionCullingSettings()", Dot)]
        [NativeProperty(TargetType = Field)]
        public static float smallestOccluder { get; set; }
        [NativeProperty(TargetType = Field)]
        [StaticAccessor("GetOcclusionCullingSettings()", Dot)]
        public static float smallestHole { get; set; }
        [NativeProperty(TargetType = Field)]
        [StaticAccessor("GetOcclusionCullingSettings()", Dot)]
        public static float backfaceThreshold { get; set; }
        public static bool doesSceneHaveManualPortals { get; }
        [StaticAccessor("GetRendererScene()", Dot)]
        public static int umbraDataSize { get; }

        [NativeName("GenerateTome")]
        public static bool Compute();
        [NativeName("GenerateTomeInBackground")]
        public static bool GenerateInBackground();
        [NativeName("RemoveTempFolder")]
        public static void RemoveCacheFolder();
        public static void Cancel();
        [NativeName("ClearUmbraTome")]
        public static void Clear();
        [StaticAccessor("GetOcclusionCullingSettings()", Dot)]
        public static void SetDefaultOcclusionBakeSettings();
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [StaticAccessor("GetOcclusionCullingVisualization()", Arrow)]
    [NativeHeader("Editor/Src/OcclusionCullingVisualizationState.h")]
    [NativeHeader("Runtime/Camera/Camera.h")]
    public static class StaticOcclusionCullingVisualization
    {
        public static bool showOcclusionCulling { get; set; }
        [NativeName("ShowPreVis")]
        public static bool showPreVisualization { get; set; }
        public static bool showViewVolumes { get; set; }
        public static bool showDynamicObjectBounds { get; set; }
        public static bool showPortals { get; set; }
        public static bool showVisibilityLines { get; set; }
        public static bool showGeometryCulling { get; set; }
        public static bool isPreviewOcclusionCullingCameraInPVS { get; }
        public static Camera previewOcclusionCamera { get; }
        public static Camera previewOcclucionCamera { get; }
    }
}
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Runtime/Mono/TypeCache.h")]
    public static class TypeCache
    {
        [ThreadSafe]
        public static TypeCollection GetTypesWithAttribute(Type attrType);
        [ThreadSafe]
        public static MethodCollection GetMethodsWithAttribute(Type attrType);
        [ThreadSafe]
        public static FieldInfoCollection GetFieldsWithAttribute(Type attrType);
        public static TypeCollection GetTypesWithAttribute<T>() where T : Attribute;
        public static MethodCollection GetMethodsWithAttribute<T>() where T : Attribute;
        public static FieldInfoCollection GetFieldsWithAttribute<T>() where T : Attribute;
        public static TypeCollection GetTypesDerivedFrom<T>();
        public static TypeCollection GetTypesDerivedFrom(Type parentType);

        [DebuggerTypeProxy(typeof(DebugView))]
        [DebuggerDisplay("Count = {count}")]
        [DefaultMember("Item")]
        public struct TypeCollection : IEnumerable, IList<Type>, IList, ICollection<Type>, ICollection, IEnumerable<Type>
        {
            public Type this[int index] { get; set; }
            public int Count { get; }
            public bool IsReadOnly { get; }
            public bool IsFixedSize { get; }
            public bool IsSynchronized { get; }

            public bool Contains(Type item);
            public bool Contains(object item);
            public Enumerator GetEnumerator();
            public void CopyTo(Type[] array, int arrayIndex);
            public void CopyTo(Array array, int arrayIndex);
            public int IndexOf(Type item);
            public int IndexOf(object item);

            public struct Enumerator : IEnumerator<Type>, IEnumerator, IDisposable
            {
                public Type Current { get; }

                public void Dispose();
                public bool MoveNext();
            }
        }
        [DebuggerTypeProxy(typeof(DebugView))]
        [DebuggerDisplay("Count = {count}")]
        [DefaultMember("Item")]
        public struct MethodCollection : IEnumerable, IList<MethodInfo>, IList, ICollection<MethodInfo>, ICollection, IEnumerable<MethodInfo>
        {
            public MethodInfo this[int index] { get; set; }
            public int Count { get; }
            public bool IsReadOnly { get; }
            public bool IsFixedSize { get; }
            public bool IsSynchronized { get; }

            public bool Contains(MethodInfo item);
            public bool Contains(object item);
            public Enumerator GetEnumerator();
            public void CopyTo(MethodInfo[] array, int arrayIndex);
            public void CopyTo(Array array, int arrayIndex);
            public int IndexOf(MethodInfo item);
            public int IndexOf(object item);

            public struct Enumerator : IEnumerator<MethodInfo>, IEnumerator, IDisposable
            {
                public MethodInfo Current { get; }

                public void Dispose();
                public bool MoveNext();
            }
        }
        [DebuggerDisplay("Count = {count}")]
        [DefaultMember("Item")]
        [DebuggerTypeProxy(typeof(DebugView))]
        public struct FieldInfoCollection : IEnumerable, IList<FieldInfo>, IList, ICollection<FieldInfo>, ICollection, IEnumerable<FieldInfo>
        {
            public FieldInfo this[int index] { get; set; }
            public int Count { get; }
            public bool IsReadOnly { get; }
            public bool IsFixedSize { get; }
            public bool IsSynchronized { get; }

            public bool Contains(FieldInfo item);
            public bool Contains(object item);
            public Enumerator GetEnumerator();
            public void CopyTo(FieldInfo[] array, int arrayIndex);
            public void CopyTo(Array array, int arrayIndex);
            public int IndexOf(FieldInfo item);
            public int IndexOf(object item);

            public struct Enumerator : IEnumerator<FieldInfo>, IEnumerator, IDisposable
            {
                public FieldInfo Current { get; }

                public void Dispose();
                public bool MoveNext();
            }
        }
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.SceneManagement;

namespace UnityEditor
{
    [NativeHeader("Editor/Src/Undo/ObjectUndo.h")]
    [NativeHeader("Editor/Mono/Undo/Undo.bindings.h")]
    [NativeHeader("Editor/Src/Undo/Undo.h")]
    [NativeHeader("Editor/Src/Undo/UndoManager.h")]
    [NativeHeader("Editor/Src/Undo/PropertyDiffUndoRecorder.h")]
    public class Undo
    {
        public static UndoRedoCallback undoRedoPerformed;
        public static WillFlushUndoRecord willFlushUndoRecord;
        public static PostprocessModifications postprocessModifications;

        public Undo();

        public static void RegisterCompleteObjectUndo(UnityEngine.Object objectToUndo, string name);
        public static void RegisterCompleteObjectUndo(UnityEngine.Object[] objectsToUndo, string name);
        public static void SetTransformParent(Transform transform, Transform newParent, string name);
        [FreeFunction("SetTransformParentUndo")]
        public static void SetTransformParent([NotNull("NullExceptionObject")] Transform transform, Transform newParent, bool worldPositionStays, string name);
        [StaticAccessor("UndoBindings", DoubleColon)]
        [NativeThrows]
        public static void MoveGameObjectToScene([NotNull("ArgumentNullException")] GameObject go, Scene scene, string name);
        [FreeFunction]
        public static void RegisterCreatedObjectUndo([NotNull("ArgumentNullException")] UnityEngine.Object objectToUndo, string name);
        public static void DestroyObjectImmediate(UnityEngine.Object objectToUndo);
        [StaticAccessor("UndoBindings", DoubleColon)]
        [NativeThrows]
        public static Component AddComponent([NotNull("ArgumentNullException")] GameObject gameObject, Type type);
        public static T AddComponent<T>(GameObject gameObject) where T : Component;
        [StaticAccessor("UndoBindings", DoubleColon)]
        public static void RegisterImporterUndo(string path, string name);
        [FreeFunction("RegisterFullObjectHierarchyUndo")]
        public static void RegisterFullObjectHierarchyUndo([NotNull("ArgumentNullException")] UnityEngine.Object objectToUndo, string name);
        [Obsolete("Use Undo.RegisterFullObjectHierarchyUndo(Object, string) instead")]
        public static void RegisterFullObjectHierarchyUndo(UnityEngine.Object objectToUndo);
        [FreeFunction("RecordUndoDiff")]
        public static void RecordObject(UnityEngine.Object objectToUndo, string name);
        public static void RecordObjects(UnityEngine.Object[] objectsToUndo, string name);
        [StaticAccessor("GetUndoManager()", Dot)]
        [NativeMethod("ClearUndoIdentifier")]
        public static void ClearUndo(UnityEngine.Object identifier);
        [StaticAccessor("GetUndoManager()", Dot)]
        [NativeMethod("Undo")]
        public static void PerformUndo();
        [StaticAccessor("GetUndoManager()", Dot)]
        [NativeMethod("Redo")]
        public static void PerformRedo();
        [StaticAccessor("GetUndoManager()", Dot)]
        public static void IncrementCurrentGroup();
        [StaticAccessor("GetUndoManager()", Dot)]
        public static int GetCurrentGroup();
        [StaticAccessor("GetUndoManager()", Dot)]
        public static string GetCurrentGroupName();
        [StaticAccessor("GetUndoManager()", Dot)]
        public static void SetCurrentGroupName(string name);
        [StaticAccessor("GetUndoManager()", Dot)]
        public static void RevertAllInCurrentGroup();
        [StaticAccessor("GetUndoManager()", Dot)]
        public static void RevertAllDownToGroup(int group);
        [StaticAccessor("GetUndoManager()", Dot)]
        public static void CollapseUndoOperations(int groupIndex);
        [StaticAccessor("GetUndoManager()", Dot)]
        public static void ClearAll();
        [Obsolete("Use Undo.RegisterCompleteObjectUndo instead")]
        public static void RegisterUndo(UnityEngine.Object objectToUndo, string name);
        [Obsolete("Use Undo.RegisterCompleteObjectUndo instead")]
        public static void RegisterUndo(UnityEngine.Object[] objectsToUndo, string name);
        [StaticAccessor("GetPropertyDiffUndoRecorder()", Dot)]
        [NativeMethod("Flush")]
        public static void FlushUndoRecordObjects();
        [Obsolete("Use Undo.RecordObject instead")]
        public static void SetSnapshotTarget(UnityEngine.Object objectToUndo, string name);
        [Obsolete("Use Undo.RecordObject instead")]
        public static void SetSnapshotTarget(UnityEngine.Object[] objectsToUndo, string name);
        [Obsolete("Use Undo.RecordObject instead")]
        public static void ClearSnapshotTarget();
        [Obsolete("Use Undo.RecordObject instead")]
        public static void CreateSnapshot();
        [Obsolete("Use Undo.RecordObject instead")]
        public static void RestoreSnapshot();
        [Obsolete("Use Undo.RecordObject instead")]
        public static void RegisterSnapshot();
        [Obsolete("Use DestroyObjectImmediate, RegisterCreatedObjectUndo or RegisterUndo instead.")]
        public static void RegisterSceneUndo(string name);

        public delegate void UndoRedoCallback();
        public delegate void WillFlushUndoRecord();
        public delegate UndoPropertyModification[] PostprocessModifications(UndoPropertyModification[] modifications);
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Runtime/GfxDevice/GfxDevice.h")]
    [NativeHeader("Runtime/Graphics/RenderTexture.h")]
    [StaticAccessor("GfxDeviceStats::Get().GetLegacyFrameStats()", Dot)]
    [NativeHeader("Runtime/Profiler/MemoryProfilerStats.h")]
    [NativeHeader("Modules/Audio/Public/AudioManager.h")]
    [NativeHeader("Runtime/GfxDevice/GfxDeviceStats.h")]
    public sealed class UnityStats
    {
        public UnityStats();

        public static int batches { get; }
        public static int drawCalls { get; }
        public static int dynamicBatchedDrawCalls { get; }
        public static int staticBatchedDrawCalls { get; }
        public static int instancedBatchedDrawCalls { get; }
        public static int dynamicBatches { get; }
        public static int staticBatches { get; }
        public static int instancedBatches { get; }
        public static int setPassCalls { get; }
        public static int triangles { get; }
        public static int vertices { get; }
        public static int shadowCasters { get; }
        public static int renderTextureChanges { get; }
        [NativeName("MainThreadFrameTime")]
        public static float frameTime { get; }
        [NativeName("RenderThreadFrameTime")]
        public static float renderTime { get; }
        public static float audioLevel { get; }
        public static float audioClippingAmount { get; }
        public static float audioDSPLoad { get; }
        public static float audioStreamLoad { get; }
        public static int renderTextureCount { get; }
        public static int renderTextureBytes { get; }
        public static int usedTextureMemorySize { get; }
        public static int usedTextureCount { get; }
        public static string screenRes { get; }
        public static int screenBytes { get; }
        public static int vboTotal { get; }
        public static int vboTotalBytes { get; }
        public static int vboUploads { get; }
        public static int vboUploadBytes { get; }
        public static int ibUploads { get; }
        public static int ibUploadBytes { get; }
        public static int visibleSkinnedMeshes { get; }
        public static int animationComponentsPlaying { get; }
        public static int animatorComponentsPlaying { get; }
    }
}
using System;
using System.Collections.Generic;
using UnityEditor.Animations;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.SceneManagement;

namespace UnityEditor
{
    [NativeHeader("Editor/Mono/Unsupported.bindings.h")]
    public static class Unsupported
    {
        [StaticAccessor("GetRenderManager()", Dot)]
        public static bool useScriptableRenderPipeline { get; set; }

        [FreeFunction]
        public static void CaptureScreenshotImmediate(string filePath, int x, int y, int width, int height);
        [FreeFunction("MenuController::ExtractSubmenusCommands")]
        public static string[] GetSubmenusCommands(string menuPath);
        public static Type GetTypeFromFullName(string fullName);
        public static string[] GetSubmenus(string menuPath);
        public static string[] GetSubmenusIncludingSeparators(string menuPath);
        public static void PrepareObjectContextMenu(UnityEngine.Object c, int contextUserData);
        public static bool IsDeveloperBuild();
        [FreeFunction]
        public static bool IsDeveloperMode();
        public static bool IsSourceBuild();
        [FreeFunction]
        public static bool IsSourceBuild(bool checkHumanControllingUs);
        public static bool IsBleedingEdgeBuild();
        public static bool IsDestroyScriptableObject(ScriptableObject target);
        public static bool IsNativeCodeBuiltInReleaseMode();
        [FreeFunction]
        public static string GetBaseUnityDeveloperFolder();
        public static void StopPlayingImmediately();
        [FreeFunction("GetSceneTracker().FlushDirty")]
        public static void SceneTrackerFlushDirty();
        [FreeFunction("GetScreenManager().SetAllowCursorHide")]
        public static void SetAllowCursorHide(bool allow);
        [Obsolete("This method has been marked obsolete, use SetOverrideLightingSettings instead (UnityUpgradable) -> SetOverrideLightingSettings(*)", True)]
        public static bool SetOverrideRenderSettings(Scene scene);
        [Obsolete("This method has been marked obsolete, use RestoreOverrideLightingSettings instead (UnityUpgradable) -> RestoreOverrideLightingSettings(*)", True)]
        public static void RestoreOverrideRenderSettings();
        public static bool SetOverrideLightingSettings(Scene scene);
        [NativeThrows]
        public static void RestoreOverrideLightingSettings();
        [FreeFunction("GetRenderSettings().SetUseFogNoDirty")]
        public static void SetRenderSettingsUseFogNoDirty(bool fog);
        [FreeFunction("GetRenderSettings().SetSceneViewDebugModeExposureNoDirty")]
        public static void SetSceneViewDebugModeExposureNoDirty(float exposure);
        [FreeFunction("GetQualitySettings().SetShadowDistanceTemporarily")]
        public static void SetQualitySettingsShadowDistanceTemporarily(float distance);
        [FreeFunction("DeleteGameObjectSelection")]
        public static void DeleteGameObjectSelection();
        [FreeFunction]
        public static void CopyGameObjectsToPasteboard();
        public static void PasteGameObjectsFromPasteboard();
        [FreeFunction("AssetDatabase::GetSingletonAsset")]
        public static UnityEngine.Object GetSerializedAssetInterfaceSingleton(string className);
        [FreeFunction]
        public static void DuplicateGameObjectsUsingPasteboard();
        [FreeFunction]
        public static bool CopyComponentToPasteboard(Component component);
        [FreeFunction]
        public static bool PasteComponentFromPasteboard(GameObject go);
        [FreeFunction]
        public static bool PasteComponentValuesFromPasteboard(Component component);
        [FreeFunction("UnityEditor::StateMachineTransitionCopyPaste::HasParametersInPasteboard")]
        public static bool HasStateMachineTransitionDataInPasteboard();
        public static bool AreAllParametersInDestination(UnityEngine.Object transition, AnimatorController controller, List<string> missingParameters);
        public static bool DestinationHasCompatibleParameterTypes(UnityEngine.Object transition, AnimatorController controller, List<string> mismatchedParameters);
        public static bool CanPasteParametersToTransition(UnityEngine.Object transition, AnimatorController controller);
        [FreeFunction("UnityEditor::StateMachineTransitionCopyPaste::CopyParametersToPasteboard")]
        public static void CopyStateMachineTransitionParametersToPasteboard(UnityEngine.Object transition, AnimatorController controller);
        public static void PasteToStateMachineTransitionParametersFromPasteboard(UnityEngine.Object transition, AnimatorController controller, bool conditions, bool parameters);
        public static void CopyStateMachineDataToPasteboard(UnityEngine.Object stateMachineObject, AnimatorController controller, int layerIndex);
        public static void PasteToStateMachineFromPasteboard(AnimatorStateMachine sm, AnimatorController controller, int layerIndex, Vector3 position);
        [FreeFunction("UnityEditor::StateMachineCopyPaste::HasDataInPasteboard")]
        public static bool HasStateMachineDataInPasteboard();
        [FreeFunction("SmartResetObject")]
        public static void SmartReset([NotNull("NullExceptionObject")] UnityEngine.Object obj);
        [FreeFunction("ResolveSymlinks")]
        public static string ResolveSymlinks(string path);
        [FreeFunction("ResolveRedirectedPath")]
        public static string ResolveRedirectedPath(string path);
        [FreeFunction("AssetDatabaseDeprecated::SetApplicationSettingCompressAssetsOnImport")]
        public static void SetApplicationSettingCompressAssetsOnImport(bool value);
        [StaticAccessor("AssetDatabaseDeprecated", DoubleColon)]
        public static bool GetApplicationSettingCompressAssetsOnImport();
        [Obsolete("GetLocalIdentifierInFile() is deprecated. Use GetLocalIdentifierInFileForPersistentObject() instead.", False)]
        [FreeFunction("GetPersistentManager().GetLocalFileID")]
        public static int GetLocalIdentifierInFile(int instanceID);
        public static ulong GetLocalIdentifierInFileForPersistentObject(UnityEngine.Object obj);
        [FreeFunction]
        public static bool IsHiddenFile(string path);
        [FreeFunction]
        public static void ClearSkinCache();
        public static UnityEngine.Object GetRenderSettings();
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Editor/Mono/Unwrapping.bindings.h")]
    public struct UnwrapParam
    {
        public float angleError;
        public float areaError;
        public float hardAngle;
        public float packMargin;

        [FreeFunction("ResetUnwrapParam")]
        public static void SetDefaults(out UnwrapParam param);
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Editor/Mono/Unwrapping.bindings.h")]
    public static class Unwrapping
    {
        public static Vector2[] GeneratePerTriangleUV(Mesh src);
        public static Vector2[] GeneratePerTriangleUV(Mesh src, UnwrapParam settings);
        public static void GenerateSecondaryUVSet(Mesh src);
        public static void GenerateSecondaryUVSet(Mesh src, UnwrapParam settings);
    }
}
using System;
using UnityEngine.Internal;

namespace UnityEditor
{
    [ExcludeFromDocs]
    public struct ExternalVersionControl
    {
        public static readonly string Disabled;
        public static readonly string AutoDetect;
        public static readonly string Generic;
        [Obsolete("Asset Server VCS support has been removed.")]
        public static readonly string AssetServer;

        public ExternalVersionControl(string value);

        public override string ToString();

        public static implicit operator string(ExternalVersionControl d);
        public static implicit operator ExternalVersionControl(string d);
    }
}
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Internal;

namespace UnityEditor
{
    [NativeHeader("Editor/Src/EditorUserSettings.h")]
    [NativeHeader("Editor/Src/VersionControlSettings.h")]
    public sealed class VersionControlSettings : Object
    {
        [ExcludeFromDocs]
        [StaticAccessor("GetVersionControlSettings()", Dot)]
        public static string mode { get; set; }
    }
}
using System;

namespace UnityEditor
{
    [Flags]
    public enum VertexChannelCompressionFlags
    {
        None = 0,
        Position = 1,
        Normal = 2,
        Tangent = 4,
        Color = 8,
        TexCoord0 = 16,
        TexCoord1 = 32,
        TexCoord2 = 64,
        TexCoord3 = 128,
        [Obsolete("Use Position instead (UnityUpgradable) -> Position", False)]
        kPosition = 1,
        [Obsolete("Use Normal instead (UnityUpgradable) -> Normal", False)]
        kNormal = 2,
        [Obsolete("Use Color instead (UnityUpgradable) -> Color", False)]
        kColor = 4,
        [Obsolete("Use TexCoord0 instead (UnityUpgradable) -> TexCoord0", False)]
        kUV0 = 8,
        [Obsolete("Use TexCoord1 instead (UnityUpgradable) -> TexCoord1", False)]
        kUV1 = 16,
        [Obsolete("Use TexCoord2 instead (UnityUpgradable) -> TexCoord2", False)]
        kUV2 = 32,
        [Obsolete("Use TexCoord3 instead (UnityUpgradable) -> TexCoord3", False)]
        kUV3 = 64,
        [Obsolete("Use Tangent instead (UnityUpgradable) -> Tangent", False)]
        kTangent = 128
    }
}
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor
{
    [NativeType(Custom, "MonoAnimationClipSettings")]
    [NativeAsStruct]
    [RequiredByNativeCode]
    public class AnimationClipSettings
    {
        public AnimationClip additiveReferencePoseClip;
        public float additiveReferencePoseTime;
        public float startTime;
        public float stopTime;
        public float orientationOffsetY;
        public float level;
        public float cycleOffset;
        public bool hasAdditiveReferencePose;
        public bool loopTime;
        public bool loopBlend;
        public bool loopBlendOrientation;
        public bool loopBlendPositionY;
        public bool loopBlendPositionXZ;
        public bool keepOriginalOrientation;
        public bool keepOriginalPositionY;
        public bool keepOriginalPositionXZ;
        public bool heightFromFeet;
        public bool mirror;

        public AnimationClipSettings();
    }
}
using UnityEngine;

namespace UnityEditor
{
    public class AnimationModeDriver : ScriptableObject
    {
        public AnimationModeDriver();
    }
}
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Playables;

namespace UnityEditor
{
    [NativeHeader("Editor/Src/Prefabs/PropertyModification.h")]
    [NativeHeader("Editor/Src/Animation/EditorCurveBinding.bindings.h")]
    [NativeHeader("Editor/Src/Animation/AnimationMode.bindings.h")]
    public class AnimationMode
    {
        public AnimationMode();

        public static Color animatedPropertyColor { get; }
        public static Color recordedPropertyColor { get; }
        public static Color candidatePropertyColor { get; }

        public static bool IsPropertyAnimated(Object target, string propertyPath);
        public static void StopAnimationMode();
        public static void StopAnimationMode(AnimationModeDriver driver);
        public static bool InAnimationMode();
        public static bool InAnimationMode(AnimationModeDriver driver);
        public static void StartAnimationMode();
        public static void StartAnimationMode(AnimationModeDriver driver);
        [NativeThrows]
        public static void BeginSampling();
        [NativeThrows]
        public static void EndSampling();
        [NativeThrows]
        public static void SampleAnimationClip([NotNull("ArgumentNullException")] GameObject gameObject, [NotNull("ArgumentNullException")] AnimationClip clip, float time);
        [NativeThrows]
        public static void SamplePlayableGraph(PlayableGraph graph, int index, float time);
        [NativeThrows]
        public static void AddPropertyModification(EditorCurveBinding binding, PropertyModification modification, bool keepPrefabOverride);
        [NativeThrows]
        public static void AddEditorCurveBinding([NotNull("ArgumentNullException")] GameObject gameObject, EditorCurveBinding binding);
    }
}
using UnityEngine;

namespace UnityEditor
{
    public struct ObjectReferenceKeyframe
    {
        public float time;
        public Object value;
    }
}
using System;
using UnityEngine;

namespace UnityEditor
{
    public class AnimationClipCurveData
    {
        public string path;
        public Type type;
        public string propertyName;
        public AnimationCurve curve;

        public AnimationClipCurveData();
        public AnimationClipCurveData(EditorCurveBinding binding);
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Internal;

namespace UnityEditor
{
    [NativeHeader("Editor/Src/Animation/AnimationUtility.bindings.h")]
    public class AnimationUtility
    {
        public static OnCurveWasModified onCurveWasModified;

        public AnimationUtility();

        [Obsolete("GetAnimationClips(Animation) is deprecated. Use GetAnimationClips(GameObject) instead.")]
        public static AnimationClip[] GetAnimationClips(Animation component);
        public static AnimationClip[] GetAnimationClips(GameObject gameObject);
        public static void SetAnimationClips([NotNull("ArgumentNullException")] Animation animation, AnimationClip[] clips);
        public static EditorCurveBinding[] GetAnimatableBindings(GameObject targetObject, GameObject root);
        public static Type GetEditorCurveValueType(GameObject root, EditorCurveBinding binding);
        public static bool GetFloatValue([NotNull("ArgumentNullException")] GameObject root, EditorCurveBinding binding, out float data);
        public static bool GetObjectReferenceValue(GameObject root, EditorCurveBinding binding, out UnityEngine.Object data);
        public static UnityEngine.Object GetAnimatedObject([NotNull("ArgumentNullException")] GameObject root, EditorCurveBinding binding);
        public static Type PropertyModificationToEditorCurveBinding(PropertyModification modification, GameObject gameObject, out EditorCurveBinding binding);
        public static EditorCurveBinding[] GetCurveBindings([NotNull("ArgumentNullException")] AnimationClip clip);
        public static EditorCurveBinding[] GetObjectReferenceCurveBindings([NotNull("ArgumentNullException")] AnimationClip clip);
        public static ObjectReferenceKeyframe[] GetObjectReferenceCurve([NotNull("ArgumentNullException")] AnimationClip clip, EditorCurveBinding binding);
        public static void SetObjectReferenceCurve(AnimationClip clip, EditorCurveBinding binding, ObjectReferenceKeyframe[] keyframes);
        public static void SetObjectReferenceCurves(AnimationClip clip, EditorCurveBinding[] bindings, ObjectReferenceKeyframe[][] keyframes);
        public static AnimationCurve GetEditorCurve([NotNull("ArgumentNullException")] AnimationClip clip, EditorCurveBinding binding);
        public static void SetEditorCurve(AnimationClip clip, EditorCurveBinding binding, AnimationCurve curve);
        public static void SetEditorCurves(AnimationClip clip, EditorCurveBinding[] bindings, AnimationCurve[] curves);
        [NativeThrows]
        [ThreadSafe]
        public static TangentMode GetKeyLeftTangentMode([NotNull("ArgumentNullException")] AnimationCurve curve, int index);
        [NativeThrows]
        [ThreadSafe]
        public static TangentMode GetKeyRightTangentMode([NotNull("ArgumentNullException")] AnimationCurve curve, int index);
        [NativeThrows]
        public static bool GetKeyBroken([NotNull("ArgumentNullException")] AnimationCurve curve, int index);
        [NativeThrows]
        [ThreadSafe]
        public static void SetKeyLeftTangentMode([NotNull("ArgumentNullException")] AnimationCurve curve, int index, TangentMode tangentMode);
        [ThreadSafe]
        [NativeThrows]
        public static void SetKeyRightTangentMode([NotNull("ArgumentNullException")] AnimationCurve curve, int index, TangentMode tangentMode);
        [NativeThrows]
        public static void SetKeyBroken([NotNull("ArgumentNullException")] AnimationCurve curve, int index, bool broken);
        [Obsolete("GetAllCurves is deprecated. Use GetCurveBindings and GetObjectReferenceCurveBindings instead.")]
        public static AnimationClipCurveData[] GetAllCurves(AnimationClip clip);
        [Obsolete("GetAllCurves is deprecated. Use GetCurveBindings and GetObjectReferenceCurveBindings instead.")]
        public static AnimationClipCurveData[] GetAllCurves(AnimationClip clip, [DefaultValue("true")] bool includeCurveData);
        [Obsolete("This overload is deprecated. Use the one with EditorCurveBinding instead.")]
        public static bool GetFloatValue(GameObject root, string relativePath, Type type, string propertyName, out float data);
        [Obsolete("This overload is deprecated. Use the one with EditorCurveBinding instead.")]
        public static void SetEditorCurve(AnimationClip clip, string relativePath, Type type, string propertyName, AnimationCurve curve);
        [Obsolete("This overload is deprecated. Use the one with EditorCurveBinding instead.")]
        public static AnimationCurve GetEditorCurve(AnimationClip clip, string relativePath, Type type, string propertyName);
        public static AnimationEvent[] GetAnimationEvents([NotNull("ArgumentNullException")] AnimationClip clip);
        [NativeThrows]
        public static void SetAnimationEvents([NotNull("ArgumentNullException")] AnimationClip clip, [NotNull("ArgumentNullException")] AnimationEvent[] events);
        public static string CalculateTransformPath([NotNull("ArgumentNullException")] Transform targetTransform, Transform root);
        public static AnimationClipSettings GetAnimationClipSettings([NotNull("ArgumentNullException")] AnimationClip clip);
        public static void SetAnimationClipSettings([NotNull("ArgumentNullException")] AnimationClip clip, AnimationClipSettings srcClipInfo);
        public static void SetAdditiveReferencePose(AnimationClip clip, AnimationClip referenceClip, float time);
        public static void ConstrainToPolynomialCurve(AnimationCurve curve);
        [Obsolete("This is not used anymore.  Root motion curves are automatically generated if applyRootMotion is enabled on Animator component.")]
        public static bool GetGenerateMotionCurves(AnimationClip clip);
        [Obsolete("This is not used anymore.  Root motion curves are automatically generated if applyRootMotion is enabled on Animator component.")]
        public static void SetGenerateMotionCurves(AnimationClip clip, bool value);
        [Obsolete("Use AnimationMode.InAnimationMode instead.")]
        public static bool InAnimationMode();
        [Obsolete("Use AnimationMode.StartAnimationmode instead.")]
        public static void StartAnimationMode(UnityEngine.Object[] objects);
        [Obsolete("Use AnimationMode.StopAnimationMode instead.")]
        public static void StopAnimationMode();
        [Obsolete("SetAnimationType is no longer supported.")]
        public static void SetAnimationType(AnimationClip clip, ModelImporterAnimationType type);

        public enum CurveModifiedType
        {
            CurveDeleted = 0,
            CurveModified = 1,
            ClipModified = 2
        }
        public enum TangentMode
        {
            Free = 0,
            Auto = 1,
            Linear = 2,
            Constant = 3,
            ClampedAuto = 4
        }
        public delegate void OnCurveWasModified(AnimationClip clip, EditorCurveBinding binding, CurveModifiedType type);
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType(Custom, "MonoEditorCurveBinding")]
    public struct EditorCurveBinding : IEquatable<EditorCurveBinding>
    {
        public string path;
        public string propertyName;

        public bool isPPtrCurve { get; }
        public bool isDiscreteCurve { get; }
        public Type type { get; set; }

        public override int GetHashCode();
        public override bool Equals(object other);
        public bool Equals(EditorCurveBinding other);
        public static EditorCurveBinding FloatCurve(string inPath, Type inType, string inPropertyName);
        public static EditorCurveBinding PPtrCurve(string inPath, Type inType, string inPropertyName);
        public static EditorCurveBinding DiscreteCurve(string inPath, Type inType, string inPropertyName);

        public static bool operator ==(EditorCurveBinding lhs, EditorCurveBinding rhs);
        public static bool operator !=(EditorCurveBinding lhs, EditorCurveBinding rhs);
    }
}
using UnityEngine;

namespace UnityEditor
{
    [EditorWindowTitle(title = "Animation", useTypeNameAsIconName = True)]
    public sealed class AnimationWindow : EditorWindow, IHasCustomMenu
    {
        public AnimationClip animationClip { get; set; }
        public bool previewing { get; set; }
        public bool canPreview { get; }
        public bool recording { get; set; }
        public bool canRecord { get; }
        public bool playing { get; set; }
        public float time { get; set; }
        public int frame { get; set; }

        public void AddItemsToMenu(GenericMenu menu);
    }
}
using System;
using System.ComponentModel;

namespace UnityEditor
{
    public enum DrawCameraMode
    {
        UserDefined = -2147483648,
        Normal = -1,
        Textured = 0,
        Wireframe = 1,
        TexturedWire = 2,
        ShadowCascades = 3,
        RenderPaths = 4,
        AlphaChannel = 5,
        Overdraw = 6,
        Mipmaps = 7,
        DeferredDiffuse = 8,
        DeferredSpecular = 9,
        DeferredSmoothness = 10,
        DeferredNormal = 11,
        [Obsolete("Renamed to better distinguish this mode from new Progressive baked modes. Please use RealtimeCharting instead. (UnityUpgradable) -> RealtimeCharting", True)]
        [EditorBrowsable(Never)]
        Charting = -12,
        RealtimeCharting = 12,
        Systems = 13,
        [Obsolete("Renamed to better distinguish this mode from new Progressive baked modes. Please use RealtimeAlbedo instead. (UnityUpgradable) -> RealtimeAlbedo", True)]
        [EditorBrowsable(Never)]
        Albedo = -14,
        RealtimeAlbedo = 14,
        [Obsolete("Renamed to better distinguish this mode from new Progressive baked modes. Please use RealtimeEmissive instead. (UnityUpgradable) -> RealtimeEmissive", True)]
        [EditorBrowsable(Never)]
        Emissive = -15,
        RealtimeEmissive = 15,
        [Obsolete("Renamed to better distinguish this mode from new Progressive baked modes. Please use RealtimeIndirect instead. (UnityUpgradable) -> RealtimeIndirect", True)]
        [EditorBrowsable(Never)]
        Irradiance = -16,
        RealtimeIndirect = 16,
        [EditorBrowsable(Never)]
        [Obsolete("Renamed to better distinguish this mode from new Progressive baked modes. Please use RealtimeDirectionality instead. (UnityUpgradable) -> RealtimeDirectionality", True)]
        Directionality = -17,
        RealtimeDirectionality = 17,
        [EditorBrowsable(Never)]
        [Obsolete("Renamed to better distinguish this mode from new Progressive baked modes. Please use BakedLightmap instead. (UnityUpgradable) -> BakedLightmap", True)]
        Baked = -18,
        BakedLightmap = 18,
        Clustering = 19,
        LitClustering = 20,
        ValidateAlbedo = 21,
        ValidateMetalSpecular = 22,
        ShadowMasks = 23,
        LightOverlap = 24,
        BakedAlbedo = 25,
        BakedEmissive = 26,
        BakedDirectionality = 27,
        BakedTexelValidity = 28,
        BakedIndices = 29,
        BakedCharting = 30,
        SpriteMask = 31,
        BakedUVOverlap = 32,
        TextureStreaming = 33,
        BakedLightmapCulling = 34,
        GIContributorsReceivers = 35
    }
}
using System;
using UnityEngine;

namespace UnityEditor
{
    public class SceneViewCameraWindow : PopupWindowContent
    {
        public SceneViewCameraWindow(SceneView sceneView);

        public static event Action<SceneView> additionalSettingsGui;

        public override Vector2 GetWindowSize();
        public override void OnGUI(Rect rect);
    }
}
using System;
using System.Collections.Generic;
using System.ComponentModel;
using UnityEditor.AssetImporters;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Internal;
using UnityEngineInternal;

namespace UnityEditor
{
    [NativeHeader("Runtime/Core/PreventExecutionInState.h")]
    [NativeHeader("Modules/AssetDatabase/Editor/Public/AssetDatabasePreventExecution.h")]
    [NativeHeader("Editor/Src/PackageUtility.h")]
    [NativeHeader("Editor/Src/VersionControl/VC_bindings.h")]
    [NativeHeader("Editor/Src/Application/ApplicationFunctions.h")]
    [StaticAccessor("AssetDatabaseBindings", DoubleColon)]
    [NativeHeader("Modules/AssetDatabase/Editor/ScriptBindings/AssetDatabase.bindings.h")]
    [NativeHeader("Modules/AssetDatabase/Editor/Public/AssetDatabaseUtility.h")]
    [NativeHeader("Modules/AssetDatabase/Editor/Public/AssetDatabase.h")]
    public sealed class AssetDatabase
    {
        public static Action<string[]> onImportPackageItemsCompleted;

        public AssetDatabase();

        public static uint GlobalArtifactDependencyVersion { get; }
        public static uint GlobalArtifactProcessedVersion { get; }

        public static event ImportPackageCallback importPackageStarted;
        public static event ImportPackageCallback importPackageCompleted;
        public static event ImportPackageCallback importPackageCancelled;
        public static event ImportPackageFailedCallback importPackageFailed;
        [ExcludeFromDocs]
        public static event Action<CacheServerConnectionChangedParameters> cacheServerConnectionChanged;

        public static void CanOpenForEdit(string[] assetOrMetaFilePaths, List<string> outNotEditablePaths, [UnityEngine.Internal.DefaultValue("StatusQueryOptions.UseCachedIfPossible")] StatusQueryOptions statusQueryOptions = UseCachedIfPossible);
        public static void IsOpenForEdit(string[] assetOrMetaFilePaths, List<string> outNotEditablePaths, [UnityEngine.Internal.DefaultValue("StatusQueryOptions.UseCachedIfPossible")] StatusQueryOptions statusQueryOptions = UseCachedIfPossible);
        public static bool MakeEditable(string path);
        public static bool MakeEditable(string[] paths, string prompt = null, List<string> outNotEditablePaths = null);
        [Obsolete("GetTextMetaDataPathFromAssetPath has been renamed to GetTextMetaFilePathFromAssetPath (UnityUpgradable) -> GetTextMetaFilePathFromAssetPath(*)")]
        public static string GetTextMetaDataPathFromAssetPath(string path);
        public static string[] FindAssets(string filter);
        public static string[] FindAssets(string filter, string[] searchInFolders);
        public static bool Contains(UnityEngine.Object obj);
        public static bool Contains(int instanceID);
        public static string CreateFolder(string parentFolder, string newFolderName);
        public static bool IsMainAsset(UnityEngine.Object obj);
        [FreeFunction("AssetDatabase::IsMainAsset")]
        public static bool IsMainAsset(int instanceID);
        public static bool IsSubAsset(UnityEngine.Object obj);
        [FreeFunction("AssetDatabase::IsSubAsset")]
        public static bool IsSubAsset(int instanceID);
        public static bool IsForeignAsset(UnityEngine.Object obj);
        public static bool IsForeignAsset(int instanceID);
        public static bool IsNativeAsset(UnityEngine.Object obj);
        public static bool IsNativeAsset(int instanceID);
        [FreeFunction]
        public static string GetCurrentCacheServerIp();
        public static string GenerateUniqueAssetPath(string path);
        [FreeFunction("AssetDatabase::StartAssetImporting")]
        public static void StartAssetEditing();
        [FreeFunction("AssetDatabase::StopAssetImporting")]
        public static void StopAssetEditing();
        [FreeFunction("AssetDatabase::UnloadAllFileStreams")]
        public static void ReleaseCachedFileHandles();
        public static string ValidateMoveAsset(string oldPath, string newPath);
        public static string MoveAsset(string oldPath, string newPath);
        [NativeThrows]
        public static string ExtractAsset(UnityEngine.Object asset, string newPath);
        public static string RenameAsset(string pathName, string newName);
        public static bool MoveAssetToTrash(string path);
        public static bool MoveAssetsToTrash(string[] paths, List<string> outFailedPaths);
        public static bool DeleteAsset(string path);
        public static bool DeleteAssets(string[] paths, List<string> outFailedPaths);
        [ExcludeFromDocs]
        public static void ImportAsset(string path);
        public static void ImportAsset(string path, [UnityEngine.Internal.DefaultValue("ImportAssetOptions.Default")] ImportAssetOptions options);
        public static bool CopyAsset(string path, string newPath);
        public static bool WriteImportSettingsIfDirty(string path);
        [NativeThrows]
        public static string[] GetSubFolders([NotNull("ArgumentNullException")] string path);
        [FreeFunction("AssetDatabase::IsFolderAsset")]
        public static bool IsValidFolder(string path);
        [NativeThrows]
        [PreventExecutionInState(kGatheringDependenciesFromSourceFile, PreventExecution_ManagedException, "Assets may not be created during gathering of import dependencies")]
        public static void CreateAsset([NotNull("ArgumentNullException")] UnityEngine.Object asset, string path);
        [NativeThrows]
        public static void AddObjectToAsset([NotNull("ArgumentNullException")] UnityEngine.Object objectToAdd, string path);
        public static void AddObjectToAsset(UnityEngine.Object objectToAdd, UnityEngine.Object assetObject);
        [NativeThrows]
        public static void SetMainObject([NotNull("ArgumentNullException")] UnityEngine.Object mainObject, string assetPath);
        public static string GetAssetPath(UnityEngine.Object assetObject);
        public static string GetAssetPath(int instanceID);
        [FreeFunction("::GetAssetOrScenePath")]
        public static string GetAssetOrScenePath(UnityEngine.Object assetObject);
        [FreeFunction("AssetDatabase::TextMetaFilePathFromAssetPath")]
        public static string GetTextMetaFilePathFromAssetPath(string path);
        [FreeFunction("AssetDatabase::AssetPathFromTextMetaFilePath")]
        public static string GetAssetPathFromTextMetaFilePath(string path);
        [PreventExecutionInState(kDomainBackup, PreventExecution_ManagedException, "Assets may not be loaded while domain backup is running, as this will change the underlying state.")]
        [NativeThrows]
        [TypeInferenceRule(TypeReferencedBySecondArgument)]
        [PreventExecutionInState(kGatheringDependenciesFromSourceFile, PreventExecution_ManagedException, "Assets may not be loaded while dependencies are being gathered, as these assets may not have been imported yet.")]
        public static UnityEngine.Object LoadAssetAtPath(string assetPath, Type type);
        public static T LoadAssetAtPath<T>(string assetPath) where T : UnityEngine.Object;
        [PreventExecutionInState(kGatheringDependenciesFromSourceFile, PreventExecution_ManagedException, "Assets may not be loaded while dependencies are being gathered, as these assets may not have been imported yet.")]
        public static UnityEngine.Object LoadMainAssetAtPath(string assetPath);
        public static Type GetMainAssetTypeAtPath(string assetPath);
        public static Type GetTypeFromPathAndFileID(string assetPath, long localIdentifierInFile);
        public static bool IsMainAssetAtPathLoaded(string assetPath);
        [PreventExecutionInState(kGatheringDependenciesFromSourceFile, PreventExecution_ManagedException, "Assets may not be loaded while dependencies are being gathered, as these assets may not have been imported yet.")]
        public static UnityEngine.Object[] LoadAllAssetRepresentationsAtPath(string assetPath);
        [PreventExecutionInState(kGatheringDependenciesFromSourceFile, PreventExecution_ManagedException, "Assets may not be loaded while dependencies are being gathered, as these assets may not have been imported yet.")]
        public static UnityEngine.Object[] LoadAllAssetsAtPath(string assetPath);
        public static string[] GetAllAssetPaths();
        [Obsolete("Please use AssetDatabase.Refresh instead", True)]
        public static void RefreshDelayed(ImportAssetOptions options);
        [Obsolete("Please use AssetDatabase.Refresh instead", True)]
        public static void RefreshDelayed();
        [ExcludeFromDocs]
        public static void Refresh();
        public static void Refresh([UnityEngine.Internal.DefaultValue("ImportAssetOptions.Default")] ImportAssetOptions options);
        [ExcludeFromDocs]
        public static bool OpenAsset(int instanceID);
        public static bool OpenAsset(int instanceID, [UnityEngine.Internal.DefaultValue("-1")] int lineNumber);
        [FreeFunction("::OpenAsset")]
        public static bool OpenAsset(int instanceID, int lineNumber, int columnNumber);
        [ExcludeFromDocs]
        public static bool OpenAsset(UnityEngine.Object target);
        public static bool OpenAsset(UnityEngine.Object target, [UnityEngine.Internal.DefaultValue("-1")] int lineNumber);
        public static bool OpenAsset(UnityEngine.Object target, int lineNumber, int columnNumber);
        public static bool OpenAsset(UnityEngine.Object[] objects);
        public static string GUIDToAssetPath(string guid);
        public static string GUIDToAssetPath(GUID guid);
        public static GUID GUIDFromAssetPath(string path);
        public static string AssetPathToGUID(string path);
        public static Hash128 GetAssetDependencyHash(GUID guid);
        public static Hash128 GetAssetDependencyHash(string path);
        [FreeFunction("AssetDatabase::SaveAssets")]
        public static void SaveAssets();
        [FreeFunction("AssetDatabase::SaveAssetIfDirty")]
        public static void SaveAssetIfDirty(GUID guid);
        public static void SaveAssetIfDirty(UnityEngine.Object obj);
        public static Texture GetCachedIcon(string path);
        public static void SetLabels(UnityEngine.Object obj, string[] labels);
        public static string[] GetLabels(GUID guid);
        public static string[] GetLabels(UnityEngine.Object obj);
        public static void ClearLabels(UnityEngine.Object obj);
        public static string[] GetAllAssetBundleNames();
        [Obsolete("Method GetAssetBundleNames has been deprecated. Use GetAllAssetBundleNames instead.")]
        public string[] GetAssetBundleNames();
        public static string[] GetUnusedAssetBundleNames();
        [FreeFunction("AssetDatabase::RemoveAssetBundleByName")]
        public static bool RemoveAssetBundleName(string assetBundleName, bool forceRemove);
        [FreeFunction("AssetDatabase::RemoveUnusedAssetBundleNames")]
        public static void RemoveUnusedAssetBundleNames();
        public static string[] GetAssetPathsFromAssetBundle(string assetBundleName);
        public static string[] GetAssetPathsFromAssetBundleAndAssetName(string assetBundleName, string assetName);
        [NativeThrows]
        public static string GetImplicitAssetBundleName(string assetPath);
        [NativeThrows]
        public static string GetImplicitAssetBundleVariantName(string assetPath);
        public static string[] GetAssetBundleDependencies(string assetBundleName, bool recursive);
        public static string[] GetDependencies(string pathName);
        public static string[] GetDependencies(string pathName, bool recursive);
        public static string[] GetDependencies(string[] pathNames);
        public static string[] GetDependencies(string[] pathNames, bool recursive);
        public static void ExportPackage(string assetPathName, string fileName);
        public static void ExportPackage(string assetPathName, string fileName, ExportPackageOptions flags);
        [ExcludeFromDocs]
        public static void ExportPackage(string[] assetPathNames, string fileName);
        [NativeThrows]
        public static void ExportPackage(string[] assetPathNames, string fileName, [UnityEngine.Internal.DefaultValue("ExportPackageOptions.Default")] ExportPackageOptions flags);
        [ExcludeFromDocs]
        public static bool CanOpenForEdit(UnityEngine.Object assetObject);
        public static bool CanOpenForEdit(UnityEngine.Object assetObject, [UnityEngine.Internal.DefaultValue("StatusQueryOptions.UseCachedIfPossible")] StatusQueryOptions statusOptions);
        [ExcludeFromDocs]
        public static bool CanOpenForEdit(string assetOrMetaFilePath);
        public static bool CanOpenForEdit(string assetOrMetaFilePath, [UnityEngine.Internal.DefaultValue("StatusQueryOptions.UseCachedIfPossible")] StatusQueryOptions statusOptions);
        [ExcludeFromDocs]
        public static bool CanOpenForEdit(UnityEngine.Object assetObject, out string message);
        public static bool CanOpenForEdit(UnityEngine.Object assetObject, out string message, [UnityEngine.Internal.DefaultValue("StatusQueryOptions.UseCachedIfPossible")] StatusQueryOptions statusOptions);
        [ExcludeFromDocs]
        public static bool CanOpenForEdit(string assetOrMetaFilePath, out string message);
        public static bool CanOpenForEdit(string assetOrMetaFilePath, out string message, [UnityEngine.Internal.DefaultValue("StatusQueryOptions.UseCachedIfPossible")] StatusQueryOptions statusOptions);
        [ExcludeFromDocs]
        public static bool IsOpenForEdit(UnityEngine.Object assetObject);
        public static bool IsOpenForEdit(UnityEngine.Object assetObject, [UnityEngine.Internal.DefaultValue("StatusQueryOptions.UseCachedIfPossible")] StatusQueryOptions statusOptions);
        [ExcludeFromDocs]
        public static bool IsOpenForEdit(string assetOrMetaFilePath);
        public static bool IsOpenForEdit(string assetOrMetaFilePath, [UnityEngine.Internal.DefaultValue("StatusQueryOptions.UseCachedIfPossible")] StatusQueryOptions statusOptions);
        [ExcludeFromDocs]
        public static bool IsOpenForEdit(UnityEngine.Object assetObject, out string message);
        public static bool IsOpenForEdit(UnityEngine.Object assetObject, out string message, [UnityEngine.Internal.DefaultValue("StatusQueryOptions.UseCachedIfPossible")] StatusQueryOptions statusOptions);
        [ExcludeFromDocs]
        public static bool IsOpenForEdit(string assetOrMetaFilePath, out string message);
        public static bool IsOpenForEdit(string assetOrMetaFilePath, out string message, [UnityEngine.Internal.DefaultValue("StatusQueryOptions.UseCachedIfPossible")] StatusQueryOptions statusOptions);
        [ExcludeFromDocs]
        public static bool IsMetaFileOpenForEdit(UnityEngine.Object assetObject);
        public static bool IsMetaFileOpenForEdit(UnityEngine.Object assetObject, [UnityEngine.Internal.DefaultValue("StatusQueryOptions.UseCachedIfPossible")] StatusQueryOptions statusOptions);
        [ExcludeFromDocs]
        public static bool IsMetaFileOpenForEdit(UnityEngine.Object assetObject, out string message);
        public static bool IsMetaFileOpenForEdit(UnityEngine.Object assetObject, out string message, [UnityEngine.Internal.DefaultValue("StatusQueryOptions.UseCachedIfPossible")] StatusQueryOptions statusOptions);
        public static T GetBuiltinExtraResource<T>(string path) where T : UnityEngine.Object;
        [TypeInferenceRule(TypeReferencedByFirstArgument)]
        [NativeThrows]
        public static UnityEngine.Object GetBuiltinExtraResource(Type type, string path);
        public static void ForceReserializeAssets(IEnumerable<string> assetPaths, ForceReserializeAssetsOptions options = ReserializeAssetsAndMetadata);
        [EditorBrowsable(Never)]
        [Obsolete("Please use the overload of this function that uses a long data type for the localId parameter, because this version can return a localID that has overflowed. This can happen when called on objects that are part of a Prefab.", True)]
        public static bool TryGetGUIDAndLocalFileIdentifier(UnityEngine.Object obj, out string guid, out int localId);
        [EditorBrowsable(Never)]
        [Obsolete("Please use the overload of this function that uses a long data type for the localId parameter, because this version can return a localID that has overflowed. This can happen when called on objects that are part of a Prefab.", True)]
        public static bool TryGetGUIDAndLocalFileIdentifier(int instanceID, out string guid, out int localId);
        public static bool TryGetGUIDAndLocalFileIdentifier(UnityEngine.Object obj, out string guid, out long localId);
        public static bool TryGetGUIDAndLocalFileIdentifier(int instanceID, out string guid, out long localId);
        public static bool TryGetGUIDAndLocalFileIdentifier<T>(LazyLoadReference<T> assetRef, out string guid, out long localId) where T : UnityEngine.Object;
        public static void ForceReserializeAssets();
        [FreeFunction("AssetDatabase::RemoveObjectFromAsset")]
        public static void RemoveObjectFromAsset([NotNull("ArgumentNullException")] UnityEngine.Object objectToRemove);
        public static void ImportPackage(string packagePath, bool interactive);
        [FreeFunction("ApplicationDisallowAutoRefresh")]
        public static void DisallowAutoRefresh();
        [FreeFunction("ApplicationAllowAutoRefresh")]
        public static void AllowAutoRefresh();
        [FreeFunction("AssetDatabase::ClearImporterOverride")]
        public static void ClearImporterOverride(string path);
        [FreeFunction("AssetDatabase::IsCacheServerEnabled")]
        public static bool IsCacheServerEnabled();
        public static void SetImporterOverride<T>(string path) where T : ScriptedImporter;
        [FreeFunction("AssetDatabase::GetImporterOverride")]
        public static Type GetImporterOverride(string path);
        [FreeFunction("AssetDatabase::GetAvailableImporterTypes")]
        public static Type[] GetAvailableImporterTypes(string path);
        [FreeFunction("AcceleratorClientCanConnectTo")]
        public static bool CanConnectToCacheServer(string ip, ushort port);
        [FreeFunction]
        public static void RefreshSettings();
        [FreeFunction("AcceleratorClientIsConnected")]
        public static bool IsConnectedToCacheServer();
        [FreeFunction("AcceleratorClientResetReconnectTimer")]
        public static void ResetCacheServerReconnectTimer();
        [FreeFunction("AcceleratorClientCloseConnection")]
        public static void CloseCacheServerConnection();
        [FreeFunction]
        public static string GetCacheServerAddress();
        [FreeFunction]
        public static ushort GetCacheServerPort();
        [FreeFunction("AssetDatabase::GetCacheServerNamespacePrefix")]
        public static string GetCacheServerNamespacePrefix();
        [FreeFunction("AssetDatabase::GetCacheServerEnableDownload")]
        public static bool GetCacheServerEnableDownload();
        [FreeFunction("AssetDatabase::GetCacheServerEnableUpload")]
        public static bool GetCacheServerEnableUpload();
        [ExcludeFromDocs]
        [FreeFunction("AssetDatabase::IsDirectoryMonitoringEnabled")]
        public static bool IsDirectoryMonitoringEnabled();
        [FreeFunction("AssetDatabase::RegisterCustomDependency")]
        [PreventExecutionInState(kPreventCustomDependencyChanges, PreventExecution_ManagedException, "Custom dependencies can only be removed when the assetdatabase is not importing.")]
        public static void RegisterCustomDependency(string dependency, Hash128 hashOfValue);
        [FreeFunction("AssetDatabase::UnregisterCustomDependencyPrefixFilter")]
        [PreventExecutionInState(kPreventCustomDependencyChanges, PreventExecution_ManagedException, "Custom dependencies can only be removed when the assetdatabase is not importing.")]
        public static uint UnregisterCustomDependencyPrefixFilter(string prefixFilter);
        [FreeFunction("AssetDatabase::IsAssetImportProcess")]
        [ExcludeFromDocs]
        public static bool IsAssetImportWorkerProcess();

        public delegate void ImportPackageCallback(string packageName);
        public delegate void ImportPackageFailedCallback(string packageName, string errorMessage);
    }
}
using System;

namespace UnityEditor
{
    [Obsolete("AssetStatus enum is not used anymore (Asset Server has been removed)")]
    public enum AssetStatus
    {
        Calculating = -1,
        ClientOnly = 0,
        ServerOnly = 1,
        Unchanged = 2,
        Conflict = 3,
        Same = 4,
        NewVersionAvailable = 5,
        NewLocalVersion = 6,
        RestoredFromTrash = 7,
        Ignored = 8,
        BadState = 9
    }
}
using System;

namespace UnityEditor
{
    [Obsolete("AssetsItem class is not used anymore (Asset Server has been removed)")]
    public sealed class AssetsItem
    {
        public string guid;
        public string pathName;
        public string message;
        public string exportedAssetPath;
        public string guidFolder;
        public int enabled;
        public int assetIsDir;
        public int changeFlags;
        public string previewPath;
        public int exists;

        public AssetsItem();
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Editor/Src/Utility/ObjectImages.h")]
    [NativeHeader("Editor/Mono/AssetDatabase/AssetPreview.bindings.h")]
    public sealed class AssetPreview
    {
        public AssetPreview();

        public static Texture2D GetAssetPreview(UnityEngine.Object asset);
        public static bool IsLoadingAssetPreview(int instanceID);
        public static bool IsLoadingAssetPreviews();
        public static void SetPreviewTextureCacheSize(int size);
        public static Texture2D GetMiniThumbnail(UnityEngine.Object obj);
        public static Texture2D GetMiniTypeThumbnail(Type type);
    }
}
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor
{
    [Preserve]
    [UsedByNativeCode]
    [NativeHeader("Editor/Src/AssetPipeline/AssetImporter.h")]
    [ExcludeFromObjectFactory]
    [NativeHeader("Editor/Src/AssetPipeline/AssetImporter.bindings.h")]
    public class AssetImporter : UnityEngine.Object
    {
        public AssetImporter();

        [NativeName("AssetPathName")]
        public string assetPath { get; }
        public bool importSettingsMissing { get; }
        public ulong assetTimeStamp { get; }
        public string userData { get; set; }
        public string assetBundleName { get; set; }
        public string assetBundleVariant { get; set; }

        [NativeName("SetAssetBundleName")]
        public void SetAssetBundleNameAndVariant(string assetBundleName, string assetBundleVariant);
        [FreeFunction("FindAssetImporterAtAssetPath")]
        public static AssetImporter GetAtPath(string path);
        public void SaveAndReimport();
        public void AddRemap(SourceAssetIdentifier identifier, UnityEngine.Object externalObject);
        public bool RemoveRemap(SourceAssetIdentifier identifier);
        public Dictionary<SourceAssetIdentifier, UnityEngine.Object> GetExternalObjectMap();
        [FreeFunction("AssetImporterBindings::SupportsRemappedAssetType", HasExplicitThis = True, IsThreadSafe = True)]
        public bool SupportsRemappedAssetType(Type type);

        [NativeType(Custom, "MonoSourceAssetIdentifier")]
        public struct SourceAssetIdentifier
        {
            public Type type;
            public string name;

            public SourceAssetIdentifier(UnityEngine.Object asset);
            public SourceAssetIdentifier(Type type, string name);
        }
    }
}
using UnityEngine;

namespace UnityEditor
{
    public static class MaterialEditorExtensions
    {
        public static void PerformBumpMapCheck(this Material material);
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Editor/Src/AssetPipeline/ComputeShaderImporter.h")]
    public sealed class ComputeShaderImporter : AssetImporter
    {
        public ComputeShaderImporter();

        [NativeProperty("PreprocessorOverride")]
        public PreprocessorOverride preprocessorOverride { get; set; }
    }
}
using System;
using System.ComponentModel;
using UnityEngine;

namespace UnityEditor
{
    [EditorBrowsable(Never)]
    [Obsolete("DDSImporter is obsolete. Use IHVImageFormatImporter instead (UnityUpgradable) -> IHVImageFormatImporter", True)]
    [NativeClass(null)]
    public sealed class DDSImporter : AssetImporter
    {
        public DDSImporter();

        public bool isReadable { get; set; }
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Editor/Src/AssetPipeline/TextureImporting/IHVImageFormatImporter.h")]
    public sealed class IHVImageFormatImporter : AssetImporter
    {
        public IHVImageFormatImporter();

        public bool isReadable { get; set; }
        public FilterMode filterMode { get; set; }
        public TextureWrapMode wrapMode { get; set; }
        [NativeName("WrapU")]
        public TextureWrapMode wrapModeU { get; set; }
        [NativeName("WrapV")]
        public TextureWrapMode wrapModeV { get; set; }
        [NativeName("WrapW")]
        public TextureWrapMode wrapModeW { get; set; }
        [NativeConditional("ENABLE_TEXTURE_STREAMING")]
        public bool streamingMipmaps { get; set; }
        [NativeConditional("ENABLE_TEXTURE_STREAMING")]
        public int streamingMipmapsPriority { get; set; }
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Editor/Src/AssetPipeline/ShaderImporter.h")]
    public sealed class ShaderImporter : AssetImporter
    {
        public ShaderImporter();

        [NativeProperty("PreprocessorOverride")]
        public PreprocessorOverride preprocessorOverride { get; set; }

        public Shader GetShader();
        public void SetDefaultTextures(string[] name, Texture[] textures);
        public Texture GetDefaultTexture(string name);
        public void SetNonModifiableTextures(string[] name, Texture[] textures);
        public Texture GetNonModifiableTexture(string name);
    }
}
using System;
using System.ComponentModel;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Rendering;

namespace UnityEditor
{
    [NativeHeader("Editor/Src/AssetPipeline/SpeedTreeImporter.h")]
    [NativeHeader("Editor/Src/AssetPipeline/SpeedTreeImporter.bindings.h")]
    [NativeHeader("Runtime/Camera/ReflectionProbeTypes.h")]
    public class SpeedTreeImporter : AssetImporter
    {
        public static readonly string[] windQualityNames;

        public SpeedTreeImporter();

        public bool hasImported { get; }
        public string materialFolderPath { get; }
        public MaterialLocation materialLocation { get; set; }
        public bool isV8 { get; }
        public Shader defaultShader { get; }
        public Shader defaultBillboardShader { get; }
        public float scaleFactor { get; set; }
        public Color mainColor { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("specColor is no longer used and has been deprecated.", True)]
        public Color specColor { get; set; }
        [Obsolete("shininess is no longer used and has been deprecated.", True)]
        [EditorBrowsable(Never)]
        public float shininess { get; set; }
        public Color hueVariation { get; set; }
        public float alphaTestRef { get; set; }
        public bool hasBillboard { get; }
        public bool enableSmoothLODTransition { get; set; }
        public bool animateCrossFading { get; set; }
        public float billboardTransitionCrossFadeWidth { get; set; }
        public float fadeOutWidth { get; set; }
        public float[] LODHeights { get; set; }
        public bool[] castShadows { get; set; }
        public bool[] receiveShadows { get; set; }
        public bool[] useLightProbes { get; set; }
        public ReflectionProbeUsage[] reflectionProbeUsages { get; set; }
        public bool[] enableBump { get; set; }
        public bool[] enableHue { get; set; }
        public bool[] enableSubsurface { get; set; }
        public int bestWindQuality { get; }
        public int[] windQualities { get; set; }

        public void GenerateMaterials();
        public bool SearchAndRemapMaterials(string materialFolderPath);

        public enum MaterialLocation
        {
            External = 0,
            InPrefab = 1
        }
    }
}
using System;
using System.ComponentModel;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor
{
    [NativeHeader("Editor/Src/EditorUserBuildSettings.h")]
    [NativeHeader("Editor/Src/AssetPipeline/TextureImporting/TextureImporterUtils.h")]
    [NativeHeader("Editor/Src/AssetPipeline/TextureImporting/TextureImporter.deprecated.h")]
    [NativeHeader("Editor/Src/AssetPipeline/TextureImporting/TextureImporter.h")]
    public sealed class TextureImporter : AssetImporter
    {
        public TextureImporter();

        [Obsolete("textureFormat is no longer accessible at the TextureImporter level. For old 'simple' formats use the textureCompression property for the equivalent automatic choice (Uncompressed for TrueColor, Compressed and HQCommpressed for 16 bits). For platform specific formats use the [[PlatformTextureSettings]] API. Using this setter will setup various parameters to match the new automatic system as well as possible. Getter will return the last value set.")]
        public TextureImporterFormat textureFormat { get; set; }
        public int maxTextureSize { get; set; }
        [NativeProperty("TextureCompressionQuality", False, Function)]
        public int compressionQuality { get; set; }
        public bool crunchedCompression { get; set; }
        public bool allowAlphaSplitting { get; set; }
        public AndroidETC2FallbackOverride androidETC2FallbackOverride { get; set; }
        public TextureImporterCompression textureCompression { get; set; }
        public TextureImporterAlphaSource alphaSource { get; set; }
        [Obsolete("Use UnityEditor.TextureImporter.alphaSource instead.")]
        public bool grayscaleToAlpha { get; set; }
        public TextureImporterGenerateCubemap generateCubemap { get; set; }
        [NativeProperty("NPOTScale")]
        public TextureImporterNPOTScale npotScale { get; set; }
        public bool isReadable { get; set; }
        [NativeConditional("ENABLE_TEXTURE_STREAMING")]
        public bool streamingMipmaps { get; set; }
        [NativeConditional("ENABLE_TEXTURE_STREAMING")]
        public int streamingMipmapsPriority { get; set; }
        [NativeConditional("ENABLE_VIRTUALTEXTURING")]
        [NativeProperty("VTOnly")]
        public bool vtOnly { get; set; }
        public bool mipmapEnabled { get; set; }
        public bool borderMipmap { get; set; }
        [NativeProperty("sRGBTexture")]
        public bool sRGBTexture { get; set; }
        public bool mipMapsPreserveCoverage { get; set; }
        public float alphaTestReferenceValue { get; set; }
        [NativeProperty("MipmapMode")]
        public TextureImporterMipFilter mipmapFilter { get; set; }
        public bool fadeout { get; set; }
        public int mipmapFadeDistanceStart { get; set; }
        public int mipmapFadeDistanceEnd { get; set; }
        [Obsolete("generateMipsInLinearSpace Property deprecated. Mipmaps are always generated in linear space.")]
        public bool generateMipsInLinearSpace { get; set; }
        [Obsolete("correctGamma Property deprecated. Mipmaps are always generated in linear space.")]
        public bool correctGamma { get; set; }
        [Obsolete("linearTexture Property deprecated. Use sRGBTexture instead.")]
        public bool linearTexture { get; set; }
        [Obsolete("normalmap Property deprecated. Check [[TextureImporterSettings.textureType]] instead. Getter will work as expected. Setter will set textureType to NormalMap if true, nothing otherwise.")]
        public bool normalmap { get; set; }
        [Obsolete("lightmap Property deprecated. Check [[TextureImporterSettings.textureType]] instead. Getter will work as expected. Setter will set textureType to Lightmap if true, nothing otherwise.")]
        public bool lightmap { get; set; }
        public bool convertToNormalmap { get; set; }
        public TextureImporterNormalFilter normalmapFilter { get; set; }
        [NativeProperty("NormalmapHeightScale")]
        public float heightmapScale { get; set; }
        public int anisoLevel { get; set; }
        public FilterMode filterMode { get; set; }
        public TextureWrapMode wrapMode { get; set; }
        [NativeProperty("WrapU")]
        public TextureWrapMode wrapModeU { get; set; }
        [NativeProperty("WrapV")]
        public TextureWrapMode wrapModeV { get; set; }
        [NativeProperty("WrapW")]
        public TextureWrapMode wrapModeW { get; set; }
        public float mipMapBias { get; set; }
        public bool alphaIsTransparency { get; set; }
        public bool qualifiesForSpritePacking { get; }
        [NativeProperty("SpriteMode")]
        public SpriteImportMode spriteImportMode { get; set; }
        [NativeProperty("SpriteMetaDatas")]
        public SpriteMetaData[] spritesheet { get; set; }
        public SecondarySpriteTexture[] secondarySpriteTextures { get; set; }
        public string spritePackingTag { get; set; }
        [NativeProperty("SpritePixelsToUnits")]
        public float spritePixelsPerUnit { get; set; }
        [Obsolete("Use spritePixelsPerUnit property instead.")]
        public float spritePixelsToUnits { get; set; }
        public Vector2 spritePivot { get; set; }
        public Vector4 spriteBorder { get; set; }
        public TextureImporterType textureType { get; set; }
        public TextureImporterShape textureShape { get; set; }
        public bool ignorePngGamma { get; set; }

        [NativeMethod(HasExplicitThis = True)]
        [Obsolete("Use UnityEditor.TextureImporter.GetPlatformTextureSettings() instead.")]
        public bool GetAllowsAlphaSplitting();
        [NativeMethod(HasExplicitThis = True)]
        [Obsolete("Use UnityEditor.TextureImporter.SetPlatformTextureSettings() instead.")]
        public void SetAllowsAlphaSplitting(bool flag);
        public bool GetPlatformTextureSettings(string platform, out int maxTextureSize, out TextureImporterFormat textureFormat, out int compressionQuality, out bool etc1AlphaSplitEnabled);
        public bool GetPlatformTextureSettings(string platform, out int maxTextureSize, out TextureImporterFormat textureFormat, out int compressionQuality);
        public bool GetPlatformTextureSettings(string platform, out int maxTextureSize, out TextureImporterFormat textureFormat);
        public TextureImporterPlatformSettings GetPlatformTextureSettings(string platform);
        public TextureImporterPlatformSettings GetDefaultPlatformTextureSettings();
        public TextureImporterFormat GetAutomaticFormat(string platform);
        [Obsolete("Use UnityEditor.TextureImporter.SetPlatformTextureSettings(TextureImporterPlatformSettings) instead.")]
        public void SetPlatformTextureSettings(string platform, int maxTextureSize, TextureImporterFormat textureFormat, int compressionQuality, bool allowsAlphaSplit);
        [Obsolete("Use UnityEditor.TextureImporter.SetPlatformTextureSettings(TextureImporterPlatformSettings) instead.")]
        public void SetPlatformTextureSettings(string platform, int maxTextureSize, TextureImporterFormat textureFormat);
        [Obsolete("Use UnityEditor.TextureImporter.SetPlatformTextureSettings(TextureImporterPlatformSettings) instead.")]
        public void SetPlatformTextureSettings(string platform, int maxTextureSize, TextureImporterFormat textureFormat, [DefaultValue(False)] bool allowsAlphaSplit);
        public void SetPlatformTextureSettings(TextureImporterPlatformSettings platformSettings);
        public void ClearPlatformTextureSettings(string platform);
        [RequiredByNativeCode]
        public static bool IsPlatformTextureFormatValid(TextureImporterType textureType, BuildTarget target, TextureImporterFormat currentFormat);
        [RequiredByNativeCode]
        public static bool IsDefaultPlatformTextureFormatValid(TextureImporterType textureType, TextureImporterFormat currentFormat);
        public bool DoesSourceTextureHaveAlpha();
        [Obsolete("DoesSourceTextureHaveColor always returns true in Unity.")]
        public bool DoesSourceTextureHaveColor();
        public void ReadTextureSettings(TextureImporterSettings dest);
        public void SetTextureSettings(TextureImporterSettings src);
        public void ReadTextureImportInstructions(BuildTarget target, out TextureFormat desiredFormat, out ColorSpace colorSpace, out int compressionQuality);
    }
}
using System;
using System.ComponentModel;

namespace UnityEditor
{
    public enum TextureImporterFormat
    {
        Automatic = -1,
        [Obsolete("Use textureCompression property instead")]
        AutomaticCompressed = -1,
        [Obsolete("Use textureCompression property instead")]
        Automatic16bit = -2,
        [Obsolete("Use textureCompression property instead")]
        AutomaticTruecolor = -3,
        [Obsolete("Use crunchedCompression property instead")]
        AutomaticCrunched = -5,
        [Obsolete("HDR is handled automatically now")]
        AutomaticHDR = -6,
        [Obsolete("HDR is handled automatically now")]
        AutomaticCompressedHDR = -7,
        DXT1 = 10,
        DXT5 = 12,
        RGB16 = 7,
        RGB24 = 3,
        Alpha8 = 1,
        R16 = 9,
        R8 = 63,
        RG16 = 62,
        ARGB16 = 2,
        RGBA32 = 4,
        ARGB32 = 5,
        RGBA16 = 13,
        RHalf = 15,
        RGHalf = 16,
        RGBAHalf = 17,
        RFloat = 18,
        RGFloat = 19,
        RGBAFloat = 20,
        RGB9E5 = 22,
        BC4 = 26,
        BC5 = 27,
        BC6H = 24,
        BC7 = 25,
        DXT1Crunched = 28,
        DXT5Crunched = 29,
        PVRTC_RGB2 = 30,
        PVRTC_RGBA2 = 31,
        PVRTC_RGB4 = 32,
        PVRTC_RGBA4 = 33,
        ETC_RGB4 = 34,
        [Obsolete("Use ETC_RGB4 (UnityUpgradable) -> ETC_RGB4")]
        ATC_RGB4 = 35,
        [Obsolete("Use ETC2_RGBA8 (UnityUpgradable) -> ETC2_RGBA8")]
        ATC_RGBA8 = 36,
        EAC_R = 41,
        EAC_R_SIGNED = 42,
        EAC_RG = 43,
        EAC_RG_SIGNED = 44,
        ETC2_RGB4 = 45,
        ETC2_RGB4_PUNCHTHROUGH_ALPHA = 46,
        ETC2_RGBA8 = 47,
        ASTC_4x4 = 48,
        ASTC_5x5 = 49,
        ASTC_6x6 = 50,
        ASTC_8x8 = 51,
        ASTC_10x10 = 52,
        ASTC_12x12 = 53,
        [Obsolete("Use ASTC_4x4 (UnityUpgradable) -> ASTC_4x4")]
        [EditorBrowsable(Never)]
        ASTC_RGB_4x4 = 48,
        [EditorBrowsable(Never)]
        [Obsolete("Use ASTC_5x5 (UnityUpgradable) -> ASTC_5x5")]
        ASTC_RGB_5x5 = 49,
        [EditorBrowsable(Never)]
        [Obsolete("Use ASTC_6x6 (UnityUpgradable) -> ASTC_6x6")]
        ASTC_RGB_6x6 = 50,
        [Obsolete("Use ASTC_8x8 (UnityUpgradable) -> ASTC_8x8")]
        [EditorBrowsable(Never)]
        ASTC_RGB_8x8 = 51,
        [Obsolete("Use ASTC_10x10 (UnityUpgradable) -> ASTC_10x10")]
        [EditorBrowsable(Never)]
        ASTC_RGB_10x10 = 52,
        [Obsolete("Use ASTC_12x12 (UnityUpgradable) -> ASTC_12x12")]
        [EditorBrowsable(Never)]
        ASTC_RGB_12x12 = 53,
        [Obsolete("Use ASTC_4x4 (UnityUpgradable) -> ASTC_4x4")]
        [EditorBrowsable(Never)]
        ASTC_RGBA_4x4 = 54,
        [Obsolete("Use ASTC_5x5 (UnityUpgradable) -> ASTC_5x5")]
        [EditorBrowsable(Never)]
        ASTC_RGBA_5x5 = 55,
        [Obsolete("Use ASTC_6x6 (UnityUpgradable) -> ASTC_6x6")]
        [EditorBrowsable(Never)]
        ASTC_RGBA_6x6 = 56,
        [Obsolete("Use ASTC_8x8 (UnityUpgradable) -> ASTC_8x8")]
        [EditorBrowsable(Never)]
        ASTC_RGBA_8x8 = 57,
        [Obsolete("Use ASTC_10x10 (UnityUpgradable) -> ASTC_10x10")]
        [EditorBrowsable(Never)]
        ASTC_RGBA_10x10 = 58,
        [EditorBrowsable(Never)]
        [Obsolete("Use ASTC_12x12 (UnityUpgradable) -> ASTC_12x12")]
        ASTC_RGBA_12x12 = 59,
        [Obsolete("Nintendo 3DS is no longer supported.")]
        ETC_RGB4_3DS = 60,
        [Obsolete("Nintendo 3DS is no longer supported.")]
        ETC_RGBA8_3DS = 61,
        ETC_RGB4Crunched = 64,
        ETC2_RGBA8Crunched = 65,
        ASTC_HDR_4x4 = 66,
        ASTC_HDR_5x5 = 67,
        ASTC_HDR_6x6 = 68,
        ASTC_HDR_8x8 = 69,
        ASTC_HDR_10x10 = 70,
        ASTC_HDR_12x12 = 71,
        RG32 = 72,
        RGB48 = 73,
        RGBA64 = 74
    }
}
namespace UnityEditor
{
    public enum TextureImporterMipFilter
    {
        BoxFilter = 0,
        KaiserFilter = 1
    }
}
using System;

namespace UnityEditor
{
    public enum TextureImporterGenerateCubemap
    {
        [Obsolete("This value is deprecated (use TextureImporter.textureShape instead).")]
        None = 0,
        Spheremap = 1,
        Cylindrical = 2,
        [Obsolete("Obscure shperemap modes are not supported any longer (use TextureImporterGenerateCubemap.Spheremap instead).")]
        SimpleSpheremap = 3,
        [Obsolete("Obscure shperemap modes are not supported any longer (use TextureImporterGenerateCubemap.Spheremap instead).")]
        NiceSpheremap = 4,
        FullCubemap = 5,
        AutoCubemap = 6
    }
}
namespace UnityEditor
{
    public enum TextureImporterNPOTScale
    {
        None = 0,
        ToNearest = 1,
        ToLarger = 2,
        ToSmaller = 3
    }
}
namespace UnityEditor
{
    public enum TextureImporterNormalFilter
    {
        Standard = 0,
        Sobel = 1
    }
}
namespace UnityEditor
{
    public enum TextureImporterAlphaSource
    {
        None = 0,
        FromInput = 1,
        FromGrayScale = 2
    }
}
namespace UnityEditor
{
    public enum TextureImporterSingleChannelComponent
    {
        Alpha = 0,
        Red = 1
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEditor
{
    [RequiredByNativeCode]
    public enum TextureImporterType
    {
        Default = 0,
        [Obsolete("Use Default (UnityUpgradable) -> Default")]
        Image = 0,
        [Obsolete("Use NormalMap (UnityUpgradable) -> NormalMap")]
        Bump = 1,
        NormalMap = 1,
        GUI = 2,
        Sprite = 8,
        Cursor = 7,
        [Obsolete("Use importer.textureShape = TextureImporterShape.TextureCube")]
        Cubemap = 3,
        [Obsolete("Use a texture setup as a cubemap with glossy reflection instead")]
        Reflection = 3,
        Cookie = 4,
        Lightmap = 6,
        [Obsolete("HDRI is not supported anymore")]
        HDRI = 9,
        [Obsolete("Use Default instead. All texture types now have an Advanced foldout (UnityUpgradable) -> Default")]
        Advanced = 5,
        SingleChannel = 10,
        Shadowmask = 11,
        DirectionalLightmap = 12
    }
}
namespace UnityEditor
{
    public enum TextureImporterCompression
    {
        Uncompressed = 0,
        Compressed = 1,
        CompressedHQ = 2,
        CompressedLQ = 3
    }
}
namespace UnityEditor
{
    public enum TextureResizeAlgorithm
    {
        Mitchell = 0,
        Bilinear = 1
    }
}
using System;

namespace UnityEditor
{
    [Flags]
    public enum TextureImporterShape
    {
        Texture2D = 1,
        TextureCube = 2,
        Texture2DArray = 4,
        Texture3D = 8
    }
}
namespace UnityEditor
{
    public enum SpriteImportMode
    {
        None = 0,
        Single = 1,
        Multiple = 2,
        Polygon = 3
    }
}
namespace UnityEditor
{
    public enum AndroidETC2FallbackOverride
    {
        UseBuildSettings = 0,
        Quality32Bit = 1,
        Quality16Bit = 2,
        Quality32BitDownscaled = 3
    }
}
using UnityEngine;

namespace UnityEditor
{
    public struct SpriteMetaData
    {
        public string name;
        public Rect rect;
        public int alignment;
        public Vector2 pivot;
        public Vector4 border;
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeAsStruct]
    [NativeType(Custom, "TextureImporterSettings")]
    [NativeHeader("Editor/Src/AssetPipeline/TextureImporting/TextureImporter.bindings.h")]
    [NativeHeader("Editor/Src/AssetPipeline/TextureImporting/TextureImporterTypes.h")]
    public sealed class TextureImporterSettings
    {
        public TextureImporterSettings();

        public TextureImporterType textureType { get; set; }
        public TextureImporterShape textureShape { get; set; }
        public TextureImporterMipFilter mipmapFilter { get; set; }
        public bool mipmapEnabled { get; set; }
        [Obsolete("Texture mips are now always generated in linear space")]
        public bool generateMipsInLinearSpace { get; set; }
        public bool sRGBTexture { get; set; }
        public bool fadeOut { get; set; }
        public bool borderMipmap { get; set; }
        public bool mipMapsPreserveCoverage { get; set; }
        public float alphaTestReferenceValue { get; set; }
        public int mipmapFadeDistanceStart { get; set; }
        public int mipmapFadeDistanceEnd { get; set; }
        public bool convertToNormalMap { get; set; }
        public float heightmapScale { get; set; }
        public TextureImporterNormalFilter normalMapFilter { get; set; }
        public TextureImporterAlphaSource alphaSource { get; set; }
        public TextureImporterSingleChannelComponent singleChannelComponent { get; set; }
        public int flipbookRows { get; set; }
        public int flipbookColumns { get; set; }
        public bool readable { get; set; }
        public bool streamingMipmaps { get; set; }
        public int streamingMipmapsPriority { get; set; }
        public bool vtOnly { get; set; }
        public TextureImporterNPOTScale npotScale { get; set; }
        public TextureImporterGenerateCubemap generateCubemap { get; set; }
        public TextureImporterCubemapConvolution cubemapConvolution { get; set; }
        public bool seamlessCubemap { get; set; }
        public FilterMode filterMode { get; set; }
        public int aniso { get; set; }
        public float mipmapBias { get; set; }
        public TextureWrapMode wrapMode { get; set; }
        public TextureWrapMode wrapModeU { get; set; }
        public TextureWrapMode wrapModeV { get; set; }
        public TextureWrapMode wrapModeW { get; set; }
        public bool alphaIsTransparency { get; set; }
        public bool ignorePngGamma { get; set; }
        public int spriteMode { get; set; }
        public float spritePixelsPerUnit { get; set; }
        [Obsolete("Use spritePixelsPerUnit property instead.")]
        public float spritePixelsToUnits { get; set; }
        public float spriteTessellationDetail { get; set; }
        public uint spriteExtrude { get; set; }
        public SpriteMeshType spriteMeshType { get; set; }
        public int spriteAlignment { get; set; }
        public Vector2 spritePivot { get; set; }
        public Vector4 spriteBorder { get; set; }
        public bool spriteGenerateFallbackPhysicsShape { get; set; }
        [Obsolete("Use sRGBTexture instead")]
        public bool linearTexture { get; set; }
        [Obsolete("Check importer.textureType against TextureImporterType.NormalMap instead. Getter will work as expected. Setter will set textureType to NormalMap if true, nothing otherwise")]
        public bool normalMap { get; set; }
        [Obsolete("Texture format can only be overridden on a per platform basis. See [[TextureImporterPlatformSettings]]")]
        public TextureImporterFormat textureFormat { get; set; }
        [Obsolete("Texture max size can only be overridden on a per platform basis. See [[TextureImporter.maxTextureSize]] for Default platform or [[TextureImporterPlatformSettings]]")]
        public int maxTextureSize { get; set; }
        [Obsolete("Check importer.textureType against TextureImporterType.Lightmap instead. Getter will work as expected. Setter will set textureType to Lightmap if true, nothing otherwise.")]
        public bool lightmap { get; set; }
        [Obsolete("RGBM is no longer a user's choice but has become an implementation detail hidden to the user.")]
        public TextureImporterRGBMMode rgbm { get; set; }
        [Obsolete("Use UnityEditor.TextureImporter.alphaSource instead")]
        public bool grayscaleToAlpha { get; set; }
        [Obsolete("Not used anymore. The right values are automatically picked by the importer.")]
        public int cubemapConvolutionSteps { get; set; }
        [Obsolete("Not used anymore. The right values are automatically picked by the importer.")]
        public float cubemapConvolutionExponent { get; set; }
        [Obsolete("Texture compression can only be overridden on a per platform basis. See [[TextureImporter.compressionQuality]] for Default platform or [[TextureImporterPlatformSettings]]")]
        public int compressionQuality { get; set; }

        [FreeFunction("TextureImporterBindings::Equal")]
        public static bool Equal(TextureImporterSettings a, TextureImporterSettings b);
        public void CopyTo(TextureImporterSettings target);
        [Obsolete("ApplyTextureType(TextureImporterType, bool) is deprecated, use ApplyTextureType(TextureImporterType)")]
        public void ApplyTextureType(TextureImporterType type, bool applyAll);
        public void ApplyTextureType(TextureImporterType type);
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Editor/Src/AssetPipeline/TextureImporting/TextureImporter.bindings.h")]
    [NativeAsStruct]
    [NativeType(Custom, "TextureImporterPlatformSettings_Marshalling")]
    public sealed class TextureImporterPlatformSettings
    {
        public TextureImporterPlatformSettings();

        public string name { get; set; }
        public bool overridden { get; set; }
        public int maxTextureSize { get; set; }
        public TextureResizeAlgorithm resizeAlgorithm { get; set; }
        public TextureImporterFormat format { get; set; }
        public TextureImporterCompression textureCompression { get; set; }
        public int compressionQuality { get; set; }
        public bool crunchedCompression { get; set; }
        public bool allowsAlphaSplitting { get; set; }
        public AndroidETC2FallbackOverride androidETC2FallbackOverride { get; set; }

        public void CopyTo(TextureImporterPlatformSettings target);
    }
}
using UnityEngine;

namespace UnityEditor
{
    public sealed class AssetStoreAsset
    {
        public int id;
        public string name;
        public string displayName;
        public string staticPreviewURL;
        public string dynamicPreviewURL;
        public string className;
        public string price;
        public int packageID;
        public Texture2D previewImage;

        public AssetStoreAsset();

        public Object Preview { get; }
        public bool HasLivePreview { get; }

        public void Dispose();
    }
}
using UnityEngine;

namespace UnityEditor
{
    public class AudioCurveRendering
    {
        public static readonly Color kAudioOrange;

        public AudioCurveRendering();

        public static Rect BeginCurveFrame(Rect r);
        public static void EndCurveFrame();
        public static Rect DrawCurveFrame(Rect r);
        public static void DrawCurveBackground(Rect r);
        public static void DrawFilledCurve(Rect r, AudioCurveEvaluator eval, Color curveColor);
        public static void DrawFilledCurve(Rect r, AudioCurveAndColorEvaluator eval);
        public static void DrawMinMaxFilledCurve(Rect r, AudioMinMaxCurveAndColorEvaluator eval);
        public static void DrawSymmetricFilledCurve(Rect r, AudioCurveAndColorEvaluator eval);
        public static void DrawCurve(Rect r, AudioCurveEvaluator eval, Color curveColor);
        public static void DrawGradientRect(Rect r, Color c1, Color c2, float blend, bool horizontal);

        public delegate float AudioCurveEvaluator(float x);
        public delegate float AudioCurveAndColorEvaluator(float x, out Color col);
        public delegate void AudioMinMaxCurveAndColorEvaluator(float x, out Color col, out float minValue, out float maxValue);
    }
}
namespace UnityEditor
{
    public abstract class IAudioEffectPlugin
    {
        protected IAudioEffectPlugin();

        public abstract bool SetFloatParameter(string name, float value);
        public abstract bool GetFloatParameter(string name, out float value);
        public abstract bool GetFloatParameterInfo(string name, out float minRange, out float maxRange, out float defaultValue);
        public abstract bool GetFloatBuffer(string name, out float[] data, int numsamples);
        public abstract int GetSampleRate();
        public abstract bool IsPluginEditableAndEnabled();
    }
}
namespace UnityEditor
{
    public abstract class IAudioEffectPluginGUI
    {
        protected IAudioEffectPluginGUI();

        public abstract string Name { get; }
        public abstract string Description { get; }
        public abstract string Vendor { get; }

        public abstract bool OnGUI(IAudioEffectPlugin plugin);
    }
}
using System.Collections.Generic;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor
{
    [MovedFrom("UnityEditor.LinuxStandalone")]
    public abstract class Sysroot
    {
        protected Sysroot();

        public abstract string Name { get; }
        public abstract string HostPlatform { get; }
        public abstract string HostArch { get; }
        public abstract string TargetPlatform { get; }
        public abstract string TargetArch { get; }

        public abstract bool Initialize();
        public abstract IEnumerable<string> GetIl2CppArguments();
    }
}
using UnityEngine;

namespace UnityEditor
{
    public struct CameraProjectionCache
    {
        public CameraProjectionCache(Camera camera);

        public Vector2 WorldToScreenPoint(Vector3 worldPoint);
        public Vector2 WorldToGUIPoint(Vector3 worldPoint);
        public Vector2 GUIToScreenPoint(Vector2 guiPoint);
        public Vector2 ScreenToGUIPoint(Vector2 screenPoint);
    }
}
using UnityEngine.Internal;

namespace UnityEditor
{
    [ExcludeFromDocs]
    public delegate void CommandHandler(CommandExecuteContext context);
}
using System;
using UnityEngine.Internal;

namespace UnityEditor
{
    [AttributeUsage(Method, Inherited = False, AllowMultiple = True)]
    [ExcludeFromDocs]
    public class CommandHandlerAttribute : Attribute
    {
        public CommandHandlerAttribute(string id, string label, CommandHint hint);
        public CommandHandlerAttribute(string id);
        public CommandHandlerAttribute(string id, CommandHint hint);
        public CommandHandlerAttribute(string id, string label);

        public string id { get; }
        public string label { get; }
        public CommandHint hint { get; }
    }
}
using System;
using UnityEngine.Internal;

namespace UnityEditor
{
    [ExcludeFromDocs]
    [Flags]
    public enum CommandHint
    {
        Undefined = -1,
        None = 0,
        Event = 1,
        Menu = 2,
        Shortcut = 4,
        Shelf = 8,
        UI = 1048576,
        OnGUI = 3145728,
        UIElements = 5242880,
        Validate = 1073741824,
        UserDefined = -2147483648,
        Any = -1
    }
}
using UnityEngine.Internal;

namespace UnityEditor
{
    [ExcludeFromDocs]
    public class CommandExecuteContext
    {
        public object[] args;
        public object result;
        public CommandHint hint;

        public CommandExecuteContext();

        public object data { get; }

        public T GetArgument<T>(int index, T defaultValue = null);
    }
}
using UnityEngine.Internal;

namespace UnityEditor
{
    [ExcludeFromDocs]
    public static class CommandService
    {
        public static string GetCommandLabel(string commandId);
        public static void RegisterCommand(string id, string label, CommandHandler handler, CommandHint hint = Any);
        public static void RegisterCommand(string id, CommandHandler handler, CommandHint hint = Any);
        public static bool UnregisterCommand(string id);
        public static bool Exists(string id);
        public static object Execute(string id);
        public static object Execute(string id, CommandHint hint);
        public static object Execute(string id, CommandHint hint, params object[] args);
    }
}
using System;
using UnityEngine.Internal;
using UnityEngine.Scripting;

namespace UnityEditor
{
    [ExcludeFromDocs]
    public static class ModeService
    {
        public static string[] modeNames { get; }
        public static int modeCount { get; }
        public static string currentId { get; }
        public static int currentIndex { get; }

        public static event Action<ModeChangedArgs> modeChanged;

        [RequiredByNativeCode]
        public static void ChangeModeById(string modeId);
        public static void Update();
        public static bool HasContextMenu(string menuId);
        public static void PopupContextMenu(string menuId);

        public struct ModeChangedArgs
        {
            public int prevIndex;
            public int nextIndex;
        }
    }
}
using System;

namespace UnityEditor
{
    public enum GameViewSizeGroupType
    {
        Standalone = 0,
        [Obsolete("WebPlayer has been removed in 5.4")]
        WebPlayer = 1,
        iOS = 2,
        Android = 3,
        [Obsolete("PS3 has been removed in 5.5", False)]
        PS3 = 4,
        [Obsolete("Wii U support was removed in 2018.1", False)]
        WiiU = 5,
        [Obsolete("Tizen has been removed in 2017.3", False)]
        Tizen = 6,
        [Obsolete("Windows Phone 8 was removed in 5.3", False)]
        WP8 = 7,
        [Obsolete("Nintendo 3DS support is unavailable since 2018.1")]
        N3DS = 8,
        HMD = 9
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [ExcludeFromPreset]
    [NativeHeader("Editor/Src/GI/Enlighten/LightingDataAsset.h")]
    public sealed class LightingDataAsset : Object
    {
    }
}
using System;
using System.ComponentModel;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Rendering;

namespace UnityEditor
{
    [NativeHeader("Editor/Src/LightmapEditorSettings.h")]
    public static class LightmapEditorSettings
    {
        [Obsolete("LightmapEditorSettings.lightmapper is obsolete, use Lightmapping.lightingSettings.lightmapper instead. ", False)]
        public static Lightmapper lightmapper { get; set; }
        [Obsolete("LightmapEditorSettings.lightmapsMode is obsolete, use Lightmapping.lightingSettings.directionalityMode instead. ", False)]
        public static LightmapsMode lightmapsMode { get; set; }
        [Obsolete("LightmapEditorSettings.mixedBakeMode is obsolete, use Lightmapping.lightingSettings.mixedBakeMode instead. ", False)]
        public static MixedLightingMode mixedBakeMode { get; set; }
        [Obsolete("LightmapEditorSettings.sampling is obsolete, use Lightmapping.lightingSettings.sampling instead. ", False)]
        public static Sampling sampling { get; set; }
        [Obsolete("LightmapEditorSettings.directSampleCount is obsolete, use Lightmapping.lightingSettings.directSampleCount instead. ", False)]
        public static int directSampleCount { get; set; }
        [Obsolete("LightmapEditorSettings.indirectSampleCount is obsolete, use Lightmapping.lightingSettings.indirectSampleCount instead. ", False)]
        public static int indirectSampleCount { get; set; }
        [Obsolete("LightmapEditorSettings.bounces is obsolete, use Lightmapping.lightingSettings.maxBounces instead. ", False)]
        public static int bounces { get; set; }
        [Obsolete("LightmapEditorSettings.prioritizeView is obsolete, use Lightmapping.lightingSettings.prioritizeView instead. ", False)]
        public static bool prioritizeView { get; set; }
        [Obsolete("LightmapEditorSettings.filteringMode is obsolete, use Lightmapping.lightingSettings.filteringMode instead. ", False)]
        public static FilterMode filteringMode { get; set; }
        [Obsolete("LightmapEditorSettings.denoiserTypeDirect is obsolete, use Lightmapping.lightingSettings.denoiserTypeDirect instead. ", False)]
        public static DenoiserType denoiserTypeDirect { get; set; }
        [Obsolete("LightmapEditorSettings.denoiserTypeIndirect is obsolete, use Lightmapping.lightingSettings.denoiserTypeIndirect instead. ", False)]
        public static DenoiserType denoiserTypeIndirect { get; set; }
        [Obsolete("LightmapEditorSettings.denoiserTypeAO is obsolete, use Lightmapping.lightingSettings.denoiserTypeAO instead. ", False)]
        public static DenoiserType denoiserTypeAO { get; set; }
        [Obsolete("LightmapEditorSettings.filterTypeDirect is obsolete, use Lightmapping.lightingSettings.filterTypeDirect instead. ", False)]
        public static FilterType filterTypeDirect { get; set; }
        [Obsolete("LightmapEditorSettings.filterTypeIndirect is obsolete, use Lightmapping.lightingSettings.filterTypeIndirect instead. ", False)]
        public static FilterType filterTypeIndirect { get; set; }
        [Obsolete("LightmapEditorSettings.filterTypeAO is obsolete, use Lightmapping.lightingSettings.filterTypeAO instead. ", False)]
        public static FilterType filterTypeAO { get; set; }
        [Obsolete("LightmapEditorSettings.filteringGaussRadiusDirect is obsolete, use Lightmapping.lightingSettings.filteringGaussRadiusDirect instead. ", False)]
        public static int filteringGaussRadiusDirect { get; set; }
        [Obsolete("LightmapEditorSettings.filteringGaussRadiusIndirect is obsolete, use Lightmapping.lightingSettings.filteringGaussRadiusIndirect instead. ", False)]
        public static int filteringGaussRadiusIndirect { get; set; }
        [Obsolete("LightmapEditorSettings.filteringGaussRadiusAO is obsolete, use Lightmapping.lightingSettings.filteringGaussRadiusAO instead. ", False)]
        public static int filteringGaussRadiusAO { get; set; }
        [Obsolete("LightmapEditorSettings.filteringAtrousPositionSigmaDirect is obsolete, use Lightmapping.lightingSettings.filteringAtrousPositionSigmaDirect instead. ", False)]
        public static float filteringAtrousPositionSigmaDirect { get; set; }
        [Obsolete("LightmapEditorSettings.filteringAtrousPositionSigmaIndirect is obsolete, use Lightmapping.lightingSettings.filteringAtrousPositionSigmaIndirect instead. ", False)]
        public static float filteringAtrousPositionSigmaIndirect { get; set; }
        [Obsolete("LightmapEditorSettings.filteringAtrousPositionSigmaIndirect is obsolete, use Lightmapping.lightingSettings.filteringAtrousPositionSigmaIndirect instead. ", False)]
        public static float filteringAtrousPositionSigmaAO { get; set; }
        [Obsolete("LightmapEditorSettings.environmentSampleCount is obsolete, use Lightmapping.lightingSettings.environmentSampleCount instead. ", False)]
        public static int environmentSampleCount { get; set; }
        [Obsolete("LightmapEditorSettings.maxAtlasSize is obsolete, use Lightmapping.lightingSettings.lightmapMaxSize instead. ", False)]
        public static int maxAtlasSize { get; set; }
        [Obsolete("LightmapEditorSettings.realtimeResolution is obsolete, use Lightmapping.lightingSettings.indirectResolution instead. ", False)]
        public static float realtimeResolution { get; set; }
        [Obsolete("LightmapEditorSettings.bakeResolution is obsolete, use Lightmapping.lightingSettings.lightmapResolution instead. ", False)]
        public static float bakeResolution { get; set; }
        [Obsolete("LightmapEditorSettings.textureCompression is obsolete, use Lightmapping.lightingSettings.compressLightmaps instead. ", False)]
        public static bool textureCompression { get; set; }
        [StaticAccessor("GetLightmapEditorSettings()")]
        [NativeName("ReflectionCompression")]
        public static ReflectionCubemapCompression reflectionCubemapCompression { get; set; }
        [Obsolete("LightmapEditorSettings.enableAmbientOcclusion is obsolete, use Lightmapping.lightingSettings.ao instead. ", False)]
        public static bool enableAmbientOcclusion { get; set; }
        [Obsolete("LightmapEditorSettings.aoMaxDistance is obsolete, use Lightmapping.lightingSettings.aoMaxDistance instead. ", False)]
        public static float aoMaxDistance { get; set; }
        [Obsolete("LightmapEditorSettings.aoExponentIndirect is obsolete, use Lightmapping.lightingSettings.aoExponentIndirect instead. ", False)]
        public static float aoExponentIndirect { get; set; }
        [Obsolete("LightmapEditorSettings.aoExponentDirect is obsolete, use Lightmapping.lightingSettings.aoExponentDirect instead. ", False)]
        public static float aoExponentDirect { get; set; }
        [Obsolete("LightmapEditorSettings.padding is obsolete, use Lightmapping.lightingSettings.lightmapPadding instead. ", False)]
        public static int padding { get; set; }
        [Obsolete("LightmapEditorSettings.exportTrainingData is obsolete, use Lightmapping.lightingSettings.exportTrainingData instead. ", False)]
        public static bool exportTrainingData { get; set; }
        [Obsolete("LightmapEditorSettings.trainingDataDestination is obsolete, use Lightmapping.lightingSettings.trainingDataDestination instead. ", False)]
        public static string trainingDataDestination { get; set; }
        [Obsolete("LightmapEditorSettings.aoContrast has been deprecated.", False)]
        public static float aoContrast { get; set; }
        [Obsolete("LightmapEditorSettings.aoAmount has been deprecated.", False)]
        public static float aoAmount { get; set; }
        [Obsolete("LightmapEditorSettings.lockAtlas has been deprecated.", False)]
        public static bool lockAtlas { get; set; }
        [Obsolete("LightmapEditorSettings.skyLightColor has been deprecated.", False)]
        public static Color skyLightColor { get; set; }
        [Obsolete("LightmapEditorSettings.skyLightIntensity has been deprecated.", False)]
        public static float skyLightIntensity { get; set; }
        [Obsolete("LightmapEditorSettings.quality has been deprecated.", False)]
        public static LightmapBakeQuality quality { get; set; }
        [Obsolete("LightmapEditorSettings.bounceBoost has been deprecated.", False)]
        public static float bounceBoost { get; set; }
        [Obsolete("LightmapEditorSettings.finalGatherRays has been deprecated.", False)]
        public static int finalGatherRays { get; set; }
        [Obsolete("LightmapEditorSettings.finalGatherContrastThreshold has been deprecated.", False)]
        public static float finalGatherContrastThreshold { get; set; }
        [Obsolete("LightmapEditorSettings.finalGatherGradientThreshold has been deprecated.", False)]
        public static float finalGatherGradientThreshold { get; set; }
        [Obsolete("LightmapEditorSettings.finalGatherInterpolationPoints has been deprecated.", False)]
        public static int finalGatherInterpolationPoints { get; set; }
        [Obsolete("LightmapEditorSettings.lastUsedResolution has been deprecated.", False)]
        public static float lastUsedResolution { get; set; }
        [Obsolete("LightmapEditorSettings.bounceIntensity has been deprecated.", False)]
        public static float bounceIntensity { get; set; }
        [Obsolete("resolution is now called realtimeResolution (UnityUpgradable) -> realtimeResolution", False)]
        public static float resolution { get; set; }
        [Obsolete("The giBakeBackend property has been renamed to lightmapper. (UnityUpgradable) -> lightmapper", False)]
        public static GIBakeBackend giBakeBackend { get; set; }
        [Obsolete("The giPathTracerSampling property has been renamed to sampling. (UnityUpgradable) -> sampling", False)]
        public static PathTracerSampling giPathTracerSampling { get; set; }
        [Obsolete("The giPathTracerFilter property has been deprecated. There are three independent properties to set individual filter types for direct, indirect and AO GI textures: filterTypeDirect, filterTypeIndirect and filterTypeAO.")]
        public static PathTracerFilter giPathTracerFilter { get; set; }
        [Obsolete("LightmapEditorSettings.maxAtlasWidth is now called maxAtlasSize (UnityUpgradable) -> maxAtlasSize", False)]
        public static int maxAtlasWidth { get; set; }
        [Obsolete("LightmapEditorSettings.maxAtlasHeight has been deprecated. Only square atlases are supported, please use the maxAtlasSize instead. ")]
        public static int maxAtlasHeight { get; set; }

        [Obsolete("LightmapEditorSettings.Lightmapper is obsolete. Use LightingSettings.Lightmapper instead. ", False)]
        public enum Lightmapper
        {
            [Obsolete("Use Lightmapper.Enlighten instead. (UnityUpgradable) -> UnityEditor.LightmapEditorSettings/Lightmapper.Enlighten", True)]
            [EditorBrowsable(Never)]
            Radiosity = 0,
            Enlighten = 0,
            [Obsolete("Use Lightmapper.ProgressiveCPU instead. (UnityUpgradable) -> UnityEditor.LightmapEditorSettings/Lightmapper.ProgressiveCPU", True)]
            [EditorBrowsable(Never)]
            PathTracer = 1,
            ProgressiveCPU = 1,
            ProgressiveGPU = 2
        }
        [Obsolete("LightmapEditorSettings.Sampling is obsolete. Use LightingSettings.Sampling instead. ", False)]
        public enum Sampling
        {
            Auto = 0,
            Fixed = 1
        }
        [Obsolete("LightmapEditorSettings.FilterMode is obsolete. Use LightingSettings.FilterMode instead. ", False)]
        public enum FilterMode
        {
            None = 0,
            Auto = 1,
            Advanced = 2
        }
        [Obsolete("LightmapEditorSettings.DenoiserType is obsolete. Use LightingSettings.DenoiserType instead. ", False)]
        public enum DenoiserType
        {
            None = 0,
            Optix = 1,
            OpenImage = 2,
            RadeonPro = 3
        }
        [Obsolete("LightmapEditorSettings.FilterType is obsolete. Use LightingSettings.FilterType instead. ", False)]
        public enum FilterType
        {
            Gaussian = 0,
            ATrous = 1,
            None = 2
        }
        [Obsolete("GIBakeBackend has been renamed to Lightmapper. (UnityUpgradable)", True)]
        public enum GIBakeBackend
        {
            Radiosity = 0,
            PathTracer = 1
        }
        [Obsolete("PathTracerSampling has been renamed to Sampling. (UnityUpgradable) -> UnityEditor.LightmapEditorSettings/Sampling", False)]
        public enum PathTracerSampling
        {
            Auto = 0,
            Fixed = 1
        }
        [Obsolete("PathTracerFilter has been renamed to FilterType. (UnityUpgradable) -> UnityEditor.LightmapEditorSettings/FilterType", False)]
        public enum PathTracerFilter
        {
            Gaussian = 0,
            ATrous = 1
        }
    }
}
using System;

namespace UnityEditor
{
    [Obsolete("LightmapBakeQuality has been deprecated.", False)]
    public enum LightmapBakeQuality
    {
        High = 0,
        Low = 1
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [PreventReadOnlyInstanceModification]
    [NativeHeader("Editor/Src/GI/Enlighten/LightmapParameters.h")]
    public sealed class LightmapParameters : UnityEngine.Object
    {
        public LightmapParameters();

        public float resolution { get; set; }
        public float clusterResolution { get; set; }
        public int irradianceBudget { get; set; }
        public int irradianceQuality { get; set; }
        public float modellingTolerance { get; set; }
        [NativeName("EdgeStitching")]
        public bool stitchEdges { get; set; }
        public bool isTransparent { get; set; }
        public int systemTag { get; set; }
        public int blurRadius { get; set; }
        public int antiAliasingSamples { get; set; }
        public int directLightQuality { get; set; }
        public float pushoff { get; set; }
        public int bakedLightmapTag { get; set; }
        public bool limitLightmapCount { get; set; }
        public int maxLightmapCount { get; set; }
        public int AOQuality { get; set; }
        public int AOAntiAliasingSamples { get; set; }
        public float backFaceTolerance { get; set; }
        [Obsolete("edgeStitching has been deprecated. Use stitchEdges instead")]
        public float edgeStitching { get; set; }

        public static LightmapParameters GetLightmapParametersForLightingSettings(LightingSettings lightingSettings);
        public static void SetLightmapParametersForLightingSettings(LightmapParameters parameters, LightingSettings lightingSettings);
        public void AssignToLightingSettings(LightingSettings lightingSettings);
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.SceneManagement;

namespace UnityEditor
{
    [NativeHeader("Editor/Mono/GI/Lightmapping.bindings.h")]
    public static class Lightmapping
    {
        [Obsolete("OnCompletedFunction.completed is obsolete, please use event bakeCompleted instead. ", False)]
        public static OnCompletedFunction completed;

        public static GIWorkflowMode giWorkflowMode { get; set; }
        public static bool realtimeGI { get; set; }
        public static bool bakedGI { get; set; }
        [Obsolete("Lightmapping.indirectOutputScale is obsolete, use Lightmapping.lightingSettings.indirectScale instead. ", False)]
        public static float indirectOutputScale { get; set; }
        [Obsolete("Lightmapping.bounceBoost is obsolete, use Lightmapping.lightingSettings.albedoBoost instead. ", False)]
        public static float bounceBoost { get; set; }
        public static bool isRunning { get; }
        public static float buildProgress { get; }
        [StaticAccessor("GetLightmapSettings()")]
        public static LightingDataAsset lightingDataAsset { get; set; }
        public static LightingSettings lightingSettings { get; set; }
        [NativeName("LightingSettingsDefaults_Scripting")]
        [StaticAccessor("GetLightmapSettings()")]
        public static LightingSettings lightingSettingsDefaults { get; }
        [Obsolete("lightmapSnapshot has been deprecated. Use lightingDataAsset instead (UnityUpgradable) -> lightingDataAsset", True)]
        public static LightmapSnapshot lightmapSnapshot { get; set; }

        [Obsolete("OnStartedFunction.started is obsolete, please use bakeStarted instead. ", False)]
        public static event OnStartedFunction started;
        public static event Action bakeStarted;
        public static event Action lightingDataUpdated;
        public static event Action lightingDataCleared;
        public static event Action lightingDataAssetCleared;
        public static event Action bakeCompleted;

        [StaticAccessor("GICache", DoubleColon)]
        public static void ClearDiskCache();
        [FreeFunction]
        public static bool BakeAsync();
        [FreeFunction]
        public static bool Bake();
        [FreeFunction("CancelLightmapping")]
        public static void Cancel();
        [FreeFunction]
        public static void ForceStop();
        [FreeFunction]
        public static void Clear();
        [FreeFunction]
        public static void ClearLightingDataAsset();
        public static void Tetrahedralize(Vector3[] positions, out int[] outIndices, out Vector3[] outPositions);
        [FreeFunction]
        public static bool BakeReflectionProbe(ReflectionProbe probe, string path);
        [FreeFunction]
        public static void GetTerrainGIChunks([NotNull("ArgumentNullException")] Terrain terrain, ref int numChunksX, ref int numChunksY);
        public static bool TryGetLightingSettings(out LightingSettings settings);
        [StaticAccessor("GetLightmapSettingsManager()")]
        [NativeName("SetLightingSettingsForScene")]
        public static void SetLightingSettingsForScene(Scene scene, LightingSettings lightingSettings);
        [NativeName("SetLightingSettingsForScenes")]
        [StaticAccessor("GetLightmapSettingsManager()")]
        public static void SetLightingSettingsForScenes(Scene[] scenes, LightingSettings lightingSettings);
        [StaticAccessor("GetLightmapSettingsManager()")]
        [NativeName("GetLightingSettingsForScene")]
        public static LightingSettings GetLightingSettingsForScene(Scene scene);
        public static void BakeMultipleScenes(string[] paths);
        [Obsolete("BakeSelectedAsync has been deprecated. Use BakeAsync instead (UnityUpgradable) -> BakeAsync()", True)]
        public static bool BakeSelectedAsync();
        [Obsolete("BakeSelected has been deprecated. Use Bake instead (UnityUpgradable) -> Bake()", True)]
        public static bool BakeSelected();
        [Obsolete("BakeLightProbesOnlyAsync has been deprecated. Use BakeAsync instead (UnityUpgradable) -> BakeAsync()", True)]
        public static bool BakeLightProbesOnlyAsync();
        [Obsolete("BakeLightProbesOnly has been deprecated. Use Bake instead (UnityUpgradable) -> Bake()", True)]
        public static bool BakeLightProbesOnly();

        [NativeHeader("Runtime/Graphics/LightmapEnums.h")]
        public enum GIWorkflowMode
        {
            Iterative = 0,
            OnDemand = 1,
            Legacy = 2
        }
        public delegate void OnStartedFunction();
        public delegate void OnCompletedFunction();
    }
}
using System;
using UnityEngine;

namespace UnityEditor
{
    [NativeClass(null)]
    [Obsolete("LightmapSnapshot has been deprecated. Use LightingDataAsset instead (UnityUpgradable) -> LightingDataAsset", True)]
    public class LightmapSnapshot : UnityEngine.Object
    {
        public LightmapSnapshot();
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Runtime/Shaders/Material.h")]
    [StaticAccessor("Material", DoubleColon)]
    [NativeHeader("Runtime/Shaders/MaterialIsBackground.h")]
    [NativeHeader("Editor/Mono/Graphics/EditorMaterialUtility.bindings.h")]
    public sealed class EditorMaterialUtility
    {
        public EditorMaterialUtility();

        [FreeFunction("EditorMaterialUtilityBindings::ResetDefaultTextures")]
        public static void ResetDefaultTextures([NotNull("ArgumentNullException")] Material material, bool overrideSetTextures);
        [FreeFunction]
        public static bool IsBackgroundMaterial([NotNull("ArgumentNullException")] Material material);
        [FreeFunction("EditorMaterialUtilityBindings::SetShaderDefaults")]
        public static void SetShaderDefaults([NotNull("ArgumentNullException")] Shader shader, string[] name, Texture[] textures);
        [FreeFunction("EditorMaterialUtilityBindings::SetShaderNonModifiableDefaults")]
        public static void SetShaderNonModifiableDefaults([NotNull("ArgumentNullException")] Shader shader, string[] name, Texture[] textures);
    }
}
using UnityEngine;

namespace UnityEditor
{
    public static class EditorSnapSettings
    {
        public static bool gridSnapEnabled { get; set; }
        public static Vector3 move { get; set; }
        public static float rotate { get; set; }
        public static float scale { get; set; }

        public static void ResetSnapSettings();
    }
}
using System;

namespace UnityEditor
{
    [Obsolete]
    public class ColorPickerHDRConfig
    {
        public float minBrightness;
        public float maxBrightness;
        public float minExposureValue;
        public float maxExposureValue;

        public ColorPickerHDRConfig(float minBrightness, float maxBrightness, float minExposureValue, float maxExposureValue);
    }
}
using System;
using UnityEngine;
using UnityEngine.Internal;

namespace UnityEditor
{
    public sealed class EditorStyles
    {
        public EditorStyles();

        public static GUIStyle label { get; }
        public static GUIStyle miniLabel { get; }
        public static GUIStyle largeLabel { get; }
        public static GUIStyle boldLabel { get; }
        public static GUIStyle miniBoldLabel { get; }
        public static GUIStyle centeredGreyMiniLabel { get; }
        public static GUIStyle wordWrappedMiniLabel { get; }
        public static GUIStyle wordWrappedLabel { get; }
        public static GUIStyle linkLabel { get; }
        public static GUIStyle whiteLabel { get; }
        public static GUIStyle whiteMiniLabel { get; }
        public static GUIStyle whiteLargeLabel { get; }
        public static GUIStyle whiteBoldLabel { get; }
        public static GUIStyle radioButton { get; }
        public static GUIStyle miniButton { get; }
        public static GUIStyle miniButtonLeft { get; }
        public static GUIStyle miniButtonMid { get; }
        public static GUIStyle miniButtonRight { get; }
        public static GUIStyle miniPullDown { get; }
        public static GUIStyle textField { get; }
        public static GUIStyle textArea { get; }
        public static GUIStyle miniTextField { get; }
        public static GUIStyle numberField { get; }
        public static GUIStyle popup { get; }
        [Obsolete("structHeadingLabel is deprecated, use EditorStyles.label instead.")]
        public static GUIStyle structHeadingLabel { get; }
        public static GUIStyle objectField { get; }
        public static GUIStyle objectFieldThumb { get; }
        public static GUIStyle objectFieldMiniThumb { get; }
        public static GUIStyle colorField { get; }
        public static GUIStyle layerMaskField { get; }
        public static GUIStyle toggle { get; }
        public static GUIStyle foldout { get; }
        public static GUIStyle foldoutPreDrop { get; }
        public static GUIStyle foldoutHeader { get; }
        public static GUIStyle foldoutHeaderIcon { get; }
        public static GUIStyle toggleGroup { get; }
        public static Font standardFont { get; }
        public static Font boldFont { get; }
        public static Font miniFont { get; }
        public static Font miniBoldFont { get; }
        public static GUIStyle toolbar { get; }
        public static GUIStyle toolbarButton { get; }
        public static GUIStyle toolbarPopup { get; }
        public static GUIStyle toolbarDropDown { get; }
        public static GUIStyle toolbarTextField { get; }
        public static GUIStyle inspectorDefaultMargins { get; }
        public static GUIStyle inspectorFullWidthMargins { get; }
        public static GUIStyle helpBox { get; }
        public static GUIStyle toolbarSearchField { get; }

        [ExcludeFromDocs]
        public static GUIStyle FromUSS(string ussStyleRuleName, string ussInPlaceStyleOverride = null);
        [ExcludeFromDocs]
        public static GUIStyle FromUSS(GUIStyle baseStyle, string ussStyleRuleName, string ussInPlaceStyleOverride = null);
        [ExcludeFromDocs]
        public static GUIStyle ApplyUSS(GUIStyle style, string ussStyleRuleName, string ussInPlaceStyleOverride = null);
    }
}
using UnityEngine;

namespace UnityEditor
{
    public sealed class GenericMenu
    {
        public GenericMenu();

        public bool allowDuplicateNames { get; set; }

        public void AddItem(GUIContent content, bool on, MenuFunction func);
        public void AddItem(GUIContent content, bool on, MenuFunction2 func, object userData);
        public void AddDisabledItem(GUIContent content);
        public void AddDisabledItem(GUIContent content, bool on);
        public void AddSeparator(string path);
        public int GetItemCount();
        public void ShowAsContext();
        public void DropDown(Rect position);

        public delegate void MenuFunction();
        public delegate void MenuFunction2(object userData);
    }
}
using UnityEngine;

namespace UnityEditor
{
    public abstract class PopupWindowContent
    {
        protected PopupWindowContent();

        public EditorWindow editorWindow { get; }

        public abstract void OnGUI(Rect rect);
        public virtual Vector2 GetWindowSize();
        public virtual void OnOpen();
        public virtual void OnClose();
    }
}
using UnityEngine;

namespace UnityEditor
{
    public class PopupWindow : EditorWindow
    {
        public static void Show(Rect activatorRect, PopupWindowContent windowContent);
        protected virtual void OnEnable();
        protected virtual void OnDisable();
    }
}
namespace UnityEditor
{
    public enum ViewTool
    {
        None = -1,
        Orbit = 0,
        Pan = 1,
        Zoom = 2,
        FPS = 3
    }
}
namespace UnityEditor
{
    public enum PivotMode
    {
        Center = 0,
        Pivot = 1
    }
}
namespace UnityEditor
{
    public enum PivotRotation
    {
        Local = 0,
        Global = 1
    }
}
namespace UnityEditor
{
    public enum Tool
    {
        View = 0,
        Move = 1,
        Rotate = 2,
        Scale = 3,
        Rect = 4,
        Transform = 5,
        Custom = 6,
        None = -1
    }
}
using UnityEngine;

namespace UnityEditor
{
    public sealed class Tools : ScriptableObject
    {
        public Tools();

        public static Tool current { get; set; }
        public static ViewTool viewTool { get; set; }
        public static bool viewToolActive { get; }
        public static Vector3 handlePosition { get; }
        public static Rect handleRect { get; }
        public static Quaternion handleRectRotation { get; }
        public static PivotMode pivotMode { get; set; }
        public static bool rectBlueprintMode { get; set; }
        public static Quaternion handleRotation { get; set; }
        public static PivotRotation pivotRotation { get; set; }
        public static bool hidden { get; set; }
        public static int visibleLayers { get; set; }
        public static int lockedLayers { get; set; }
    }
}
namespace UnityEditor
{
    public enum TextureImporterCubemapConvolution
    {
        None = 0,
        Specular = 1,
        Diffuse = 2
    }
}
namespace UnityEditor
{
    public enum TextureImporterRGBMMode
    {
        Auto = 0,
        On = 1,
        Off = 2,
        Encoded = 3
    }
}
using System.Collections.Generic;
using UnityEngine;

namespace UnityEditor
{
    [CustomEditor(typeof(Camera))]
    [CanEditMultipleObjects]
    public class CameraEditor : Editor
    {
        public CameraEditor();

        protected Camera previewCamera { get; }
        protected Settings settings { get; }

        public void OnEnable();
        public void OnDisable();
        public void OnDestroy();
        public override void OnInspectorGUI();
        public virtual void OnOverlayGUI(Object target, SceneView sceneView);
        public virtual void OnSceneGUI();

        public sealed class Settings
        {
            public Settings(SerializedObject so);

            public static IEnumerable<string> ApertureFormatNames { get; }
            public static IEnumerable<Vector2> ApertureFormatValues { get; }
            public SerializedProperty clearFlags { get; }
            public SerializedProperty backgroundColor { get; }
            public SerializedProperty normalizedViewPortRect { get; }
            public SerializedProperty sensorSize { get; }
            public SerializedProperty lensShift { get; }
            public SerializedProperty focalLength { get; }
            public SerializedProperty gateFit { get; }
            public SerializedProperty verticalFOV { get; }
            public SerializedProperty orthographic { get; }
            public SerializedProperty orthographicSize { get; }
            public SerializedProperty depth { get; }
            public SerializedProperty cullingMask { get; }
            public SerializedProperty renderingPath { get; }
            public SerializedProperty occlusionCulling { get; }
            public SerializedProperty targetTexture { get; }
            public SerializedProperty HDR { get; }
            public SerializedProperty allowMSAA { get; }
            public SerializedProperty allowDynamicResolution { get; }
            public SerializedProperty stereoConvergence { get; }
            public SerializedProperty stereoSeparation { get; }
            public SerializedProperty nearClippingPlane { get; }
            public SerializedProperty farClippingPlane { get; }
            public SerializedProperty fovAxisMode { get; }
            public SerializedProperty targetDisplay { get; }
            public SerializedProperty targetEye { get; }

            public void OnEnable();
            public void Update();
            public void ApplyModifiedProperties();
            public void DrawClearFlags();
            public void DrawBackgroundColor();
            public void DrawCullingMask();
            public void DrawProjection();
            public void DrawClippingPlanes();
            public void DrawNormalizedViewPort();
            public void DrawDepth();
            public void DrawRenderingPath();
            public void DrawTargetTexture(bool deferred);
            public void DrawOcclusionCulling();
            public void DrawHDR();
            public void DrawMSAA();
            public void DrawDynamicResolution();
            public void DrawVR();
            public void DrawMultiDisplay();
            public void DrawTargetEye();
            public static void DrawCameraWarnings(Camera camera);
        }
    }
}
using UnityEngine;

namespace UnityEditor
{
    public static class CameraEditorUtils
    {
        public static float GameViewAspectRatio { get; }

        public static void HandleFrustum(Camera c, int cameraEditorTargetIndex);
        public static void DrawFrustumGizmo(Camera camera);
        public static bool TryGetSensorGateFrustum(Camera camera, Vector3[] near, Vector3[] far, out float frustumAspect);
        public static bool TryGetFrustum(Camera camera, Vector3[] near, Vector3[] far, out float frustumAspect);
        public static bool IsViewportRectValidToRender(Rect normalizedViewPortRect);
        public static float GetFrustumAspectRatio(Camera camera);
        public static Vector3 PerspectiveClipToWorld(Matrix4x4 clipToWorld, Vector3 viewPositionWS, Vector3 positionCS);
        public static void GetFrustumPlaneAt(Matrix4x4 clipToWorld, Vector3 viewPosition, float distance, Vector3[] points);
    }
}
using System;

namespace UnityEditor
{
    public class CustomEditor : Attribute
    {
        public CustomEditor(Type inspectedType);
        public CustomEditor(Type inspectedType, bool editorForChildClasses);

        public bool isFallback { get; set; }
    }
}
using System;

namespace UnityEditor
{
    [AttributeUsage(Class, Inherited = False, AllowMultiple = False)]
    public sealed class CustomPreviewAttribute : Attribute
    {
        public CustomPreviewAttribute(Type type);
    }
}
using UnityEngine;

namespace UnityEditor
{
    public class ObjectPreview : IPreviewable
    {
        protected Object[] m_Targets;
        protected int m_ReferenceTargetIndex;

        public ObjectPreview();

        public virtual Object target { get; }

        public virtual void Initialize(Object[] targets);
        public virtual bool MoveNextTarget();
        public virtual void ResetTarget();
        public virtual bool HasPreviewGUI();
        public virtual GUIContent GetPreviewTitle();
        public virtual void OnPreviewGUI(Rect r, GUIStyle background);
        public virtual void OnInteractivePreviewGUI(Rect r, GUIStyle background);
        public virtual void OnPreviewSettings();
        public virtual string GetInfoString();
        public void DrawPreview(Rect previewArea);
        public virtual void ReloadPreviewInstances();
    }
}
using System;

namespace UnityEditor
{
    [AttributeUsage(Class)]
    public class CustomEditorForRenderPipelineAttribute : CustomEditor
    {
        public CustomEditorForRenderPipelineAttribute(Type inspectedType, Type renderPipeline);
        public CustomEditorForRenderPipelineAttribute(Type inspectedType, Type renderPipeline, bool editorForChildClasses);
    }
}
using System;

namespace UnityEditor
{
    public sealed class CanEditMultipleObjects : Attribute
    {
        public CanEditMultipleObjects();
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Internal;
using UnityEngine.Scripting;
using UnityEngine.UIElements;

namespace UnityEditor
{
    [RequiredByNativeCode]
    [ExcludeFromObjectFactory]
    [NativeHeader("Editor/Mono/Inspector/ScriptBindings/Editor.bindings.h")]
    [StaticAccessor("EditorBindings", DoubleColon)]
    public class Editor : ScriptableObject, IPreviewable, IToolModeOwner
    {
        public Editor();

        public UnityEngine.Object target { get; set; }
        public UnityEngine.Object[] targets { get; }
        public SerializedObject serializedObject { get; }

        public static event Action<Editor> finishedDefaultHeaderGUI;

        public static Editor CreateEditorWithContext(UnityEngine.Object[] targetObjects, UnityEngine.Object context, [DefaultValue("null")] Type editorType);
        [ExcludeFromDocs]
        public static Editor CreateEditorWithContext(UnityEngine.Object[] targetObjects, UnityEngine.Object context);
        public static void CreateCachedEditorWithContext(UnityEngine.Object targetObject, UnityEngine.Object context, Type editorType, ref Editor previousEditor);
        public static void CreateCachedEditorWithContext(UnityEngine.Object[] targetObjects, UnityEngine.Object context, Type editorType, ref Editor previousEditor);
        public static void CreateCachedEditor(UnityEngine.Object targetObject, Type editorType, ref Editor previousEditor);
        public static void CreateCachedEditor(UnityEngine.Object[] targetObjects, Type editorType, ref Editor previousEditor);
        [ExcludeFromDocs]
        public static Editor CreateEditor(UnityEngine.Object targetObject);
        public static Editor CreateEditor(UnityEngine.Object targetObject, [DefaultValue("null")] Type editorType);
        [ExcludeFromDocs]
        public static Editor CreateEditor(UnityEngine.Object[] targetObjects);
        public static Editor CreateEditor(UnityEngine.Object[] targetObjects, [DefaultValue("null")] Type editorType);
        protected internal static void DrawPropertiesExcluding(SerializedObject obj, params string[] propertyToExclude);
        public bool DrawDefaultInspector();
        public void Repaint();
        public virtual void OnInspectorGUI();
        public virtual VisualElement CreateInspectorGUI();
        public virtual bool RequiresConstantRepaint();
        public void DrawHeader();
        protected virtual void OnHeaderGUI();
        protected virtual bool ShouldHideOpenButton();
        public static void DrawFoldoutInspector(UnityEngine.Object target, ref Editor editor);
        public virtual bool HasPreviewGUI();
        public virtual GUIContent GetPreviewTitle();
        public virtual Texture2D RenderStaticPreview(string assetPath, UnityEngine.Object[] subAssets, int width, int height);
        public virtual void OnPreviewGUI(Rect r, GUIStyle background);
        public virtual void OnInteractivePreviewGUI(Rect r, GUIStyle background);
        public virtual void OnPreviewSettings();
        public virtual string GetInfoString();
        public virtual void DrawPreview(Rect previewArea);
        public virtual void ReloadPreviewInstances();
        public virtual bool UseDefaultMargins();
        public void Initialize(UnityEngine.Object[] targets);
        public bool MoveNextTarget();
        public void ResetTarget();
    }
}
using System;
using System.ComponentModel;
using UnityEngine;

namespace UnityEditor
{
    [CustomEditor(typeof(Light))]
    [CanEditMultipleObjects]
    public class LightEditor : Editor
    {
        protected static readonly Color kGizmoLight;
        protected static readonly Color kGizmoDisabledLight;

        public LightEditor();

        protected Settings settings { get; }

        protected virtual void OnEnable();
        protected virtual void OnDestroy();
        public override void OnInspectorGUI();
        protected virtual void OnSceneGUI();

        public sealed class Settings
        {
            public Settings(SerializedObject so);

            public SerializedProperty lightType { get; }
            public SerializedProperty lightShape { get; }
            public SerializedProperty range { get; }
            public SerializedProperty spotAngle { get; }
            public SerializedProperty innerSpotAngle { get; }
            public SerializedProperty cookieSize { get; }
            public SerializedProperty color { get; }
            public SerializedProperty intensity { get; }
            public SerializedProperty bounceIntensity { get; }
            public SerializedProperty colorTemperature { get; }
            public SerializedProperty useColorTemperature { get; }
            public SerializedProperty cookieProp { get; }
            public SerializedProperty shadowsType { get; }
            public SerializedProperty shadowsStrength { get; }
            public SerializedProperty shadowsResolution { get; }
            public SerializedProperty shadowsBias { get; }
            public SerializedProperty shadowsNormalBias { get; }
            public SerializedProperty shadowsNearPlane { get; }
            public SerializedProperty halo { get; }
            public SerializedProperty flare { get; }
            public SerializedProperty renderMode { get; }
            public SerializedProperty cullingMask { get; }
            public SerializedProperty renderingLayerMask { get; }
            public SerializedProperty lightmapping { get; }
            public SerializedProperty areaSizeX { get; }
            public SerializedProperty areaSizeY { get; }
            public SerializedProperty bakedShadowRadiusProp { get; }
            public SerializedProperty bakedShadowAngleProp { get; }
            public bool isRealtime { get; }
            public bool isMixed { get; }
            public bool isCompletelyBaked { get; }
            public bool isBakedOrMixed { get; }
            public bool isAreaLightType { get; }
            public Light light { get; }
            public Texture cookie { get; }

            public void OnEnable();
            public void OnDestroy();
            public void Update();
            public void DrawLightType();
            public void DrawRange();
            [Obsolete("showAreaOptions argument for DrawRange(showAreaOptions) has been removed. Use DrawRange() instead (UnityUpgradable).")]
            [EditorBrowsable(Never)]
            public void DrawRange(bool showAreaOptions);
            public void DrawSpotAngle();
            public void DrawInnerAndOuterSpotAngle();
            public void DrawArea();
            public void DrawColor();
            public void DrawLightmapping();
            public void DrawIntensity();
            public void DrawBounceIntensity();
            public void DrawCookie();
            public void DrawCookieSize();
            public void DrawHalo();
            public void DrawFlare();
            public void DrawRenderMode();
            public void DrawCullingMask();
            public void DrawRenderingLayerMask();
            public void ApplyModifiedProperties();
            public void DrawShadowsType();
            public void DrawBakedShadowRadius();
            public void DrawBakedShadowAngle();
            public void DrawRuntimeShadow();
        }
    }
}
using System;
using UnityEngine;

namespace UnityEditor
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(Material))]
    public class MaterialEditor : Editor
    {
        public const int kMiniTextureFieldLabelIndentLevel = 2;

        public MaterialEditor();

        public bool isVisible { get; }
        public ShaderGUI customShaderGUI { get; }

        public void SetShader(Shader shader);
        public void SetShader(Shader newShader, bool registerUndo);
        public virtual void Awake();
        public override void OnInspectorGUI();
        public void PropertiesChanged();
        protected virtual void OnShaderChanged();
        protected override void OnHeaderGUI();
        [Obsolete("Use GetMaterialProperty instead.")]
        public float GetFloat(string propertyName, out bool hasMixedValue);
        [Obsolete("Use MaterialProperty instead.")]
        public void SetFloat(string propertyName, float value);
        [Obsolete("Use GetMaterialProperty instead.")]
        public Color GetColor(string propertyName, out bool hasMixedValue);
        [Obsolete("Use MaterialProperty instead.")]
        public void SetColor(string propertyName, Color value);
        [Obsolete("Use GetMaterialProperty instead.")]
        public Vector4 GetVector(string propertyName, out bool hasMixedValue);
        [Obsolete("Use MaterialProperty instead.")]
        public void SetVector(string propertyName, Vector4 value);
        [Obsolete("Use GetMaterialProperty instead.")]
        public Texture GetTexture(string propertyName, out bool hasMixedValue);
        [Obsolete("Use MaterialProperty instead.")]
        public void SetTexture(string propertyName, Texture value);
        [Obsolete("Use MaterialProperty instead.")]
        public Vector2 GetTextureScale(string propertyName, out bool hasMixedValueX, out bool hasMixedValueY);
        [Obsolete("Use MaterialProperty instead.")]
        public Vector2 GetTextureOffset(string propertyName, out bool hasMixedValueX, out bool hasMixedValueY);
        [Obsolete("Use MaterialProperty instead.")]
        public void SetTextureScale(string propertyName, Vector2 value, int coord);
        [Obsolete("Use MaterialProperty instead.")]
        public void SetTextureOffset(string propertyName, Vector2 value, int coord);
        public float RangeProperty(MaterialProperty prop, string label);
        public float RangeProperty(Rect position, MaterialProperty prop, string label);
        public float FloatProperty(MaterialProperty prop, string label);
        public float FloatProperty(Rect position, MaterialProperty prop, string label);
        public Color ColorProperty(MaterialProperty prop, string label);
        public Color ColorProperty(Rect position, MaterialProperty prop, string label);
        public Vector4 VectorProperty(MaterialProperty prop, string label);
        public Vector4 VectorProperty(Rect position, MaterialProperty prop, string label);
        public void TextureScaleOffsetProperty(MaterialProperty property);
        public float TextureScaleOffsetProperty(Rect position, MaterialProperty property);
        public float TextureScaleOffsetProperty(Rect position, MaterialProperty property, bool partOfTexturePropertyControl);
        public Texture TextureProperty(MaterialProperty prop, string label);
        public Texture TextureProperty(MaterialProperty prop, string label, bool scaleOffset);
        public bool HelpBoxWithButton(GUIContent messageContent, GUIContent buttonContent);
        public void TextureCompatibilityWarning(MaterialProperty prop);
        public Texture TexturePropertyMiniThumbnail(Rect position, MaterialProperty prop, string label, string tooltip);
        public Rect GetTexturePropertyCustomArea(Rect position);
        public Texture TextureProperty(Rect position, MaterialProperty prop, string label);
        public Texture TextureProperty(Rect position, MaterialProperty prop, string label, bool scaleOffset);
        public Texture TextureProperty(Rect position, MaterialProperty prop, string label, string tooltip, bool scaleOffset);
        public static Vector4 TextureScaleOffsetProperty(Rect position, Vector4 scaleOffset);
        public static Vector4 TextureScaleOffsetProperty(Rect position, Vector4 scaleOffset, bool partOfTexturePropertyControl);
        public float GetPropertyHeight(MaterialProperty prop);
        public float GetPropertyHeight(MaterialProperty prop, string label);
        public static float GetDefaultPropertyHeight(MaterialProperty prop);
        public void BeginAnimatedCheck(Rect totalPosition, MaterialProperty prop);
        public void BeginAnimatedCheck(MaterialProperty prop);
        public void EndAnimatedCheck();
        public void ShaderProperty(MaterialProperty prop, string label);
        public void ShaderProperty(MaterialProperty prop, GUIContent label);
        public void ShaderProperty(MaterialProperty prop, string label, int labelIndent);
        public void ShaderProperty(MaterialProperty prop, GUIContent label, int labelIndent);
        public void ShaderProperty(Rect position, MaterialProperty prop, string label);
        public void ShaderProperty(Rect position, MaterialProperty prop, GUIContent label);
        public void ShaderProperty(Rect position, MaterialProperty prop, string label, int labelIndent);
        public void ShaderProperty(Rect position, MaterialProperty prop, GUIContent label, int labelIndent);
        public void LightmapEmissionProperty();
        public void LightmapEmissionProperty(int labelIndent);
        public void LightmapEmissionProperty(Rect position, int labelIndent);
        public bool EmissionEnabledProperty();
        public static void FixupEmissiveFlag(Material mat);
        public static MaterialGlobalIlluminationFlags FixupEmissiveFlag(Color col, MaterialGlobalIlluminationFlags flags);
        public void LightmapEmissionFlagsProperty(int indent, bool enabled);
        public void LightmapEmissionFlagsProperty(int indent, bool enabled, bool ignoreEmissionColor);
        public void DefaultShaderProperty(MaterialProperty prop, string label);
        public void DefaultShaderProperty(Rect position, MaterialProperty prop, string label);
        [Obsolete("Use RangeProperty with MaterialProperty instead.")]
        public float RangeProperty(string propertyName, string label, float v2, float v3);
        [Obsolete("Use FloatProperty with MaterialProperty instead.")]
        public float FloatProperty(string propertyName, string label);
        [Obsolete("Use ColorProperty with MaterialProperty instead.")]
        public Color ColorProperty(string propertyName, string label);
        [Obsolete("Use VectorProperty with MaterialProperty instead.")]
        public Vector4 VectorProperty(string propertyName, string label);
        [Obsolete("Use TextureProperty with MaterialProperty instead.")]
        public Texture TextureProperty(string propertyName, string label, ShaderUtil.ShaderPropertyTexDim texDim);
        [Obsolete("Use TextureProperty with MaterialProperty instead.")]
        public Texture TextureProperty(string propertyName, string label, ShaderUtil.ShaderPropertyTexDim texDim, bool scaleOffset);
        [Obsolete("Use ShaderProperty that takes MaterialProperty parameter instead.")]
        public void ShaderProperty(Shader shader, int propertyIndex);
        public static MaterialProperty[] GetMaterialProperties(UnityEngine.Object[] mats);
        public static MaterialProperty GetMaterialProperty(UnityEngine.Object[] mats, string name);
        public static MaterialProperty GetMaterialProperty(UnityEngine.Object[] mats, int propertyIndex);
        public static Renderer PrepareMaterialPropertiesForAnimationMode(MaterialProperty[] properties, bool isMaterialEditable);
        public void SetDefaultGUIWidths();
        public bool PropertiesGUI();
        public void PropertiesDefaultGUI(MaterialProperty[] props);
        public static void ApplyMaterialPropertyDrawers(Material material);
        public static void ApplyMaterialPropertyDrawers(UnityEngine.Object[] targets);
        public void RegisterPropertyChangeUndo(string label);
        public override void OnPreviewSettings();
        public void DefaultPreviewSettingsGUI();
        public sealed override Texture2D RenderStaticPreview(string assetPath, UnityEngine.Object[] subAssets, int width, int height);
        public sealed override bool HasPreviewGUI();
        public override bool RequiresConstantRepaint();
        public override void OnInteractivePreviewGUI(Rect r, GUIStyle background);
        public override void OnPreviewGUI(Rect r, GUIStyle background);
        public void DefaultPreviewGUI(Rect r, GUIStyle background);
        public virtual void OnEnable();
        public virtual void UndoRedoPerformed();
        public virtual void OnDisable();
        public void RenderQueueField();
        public void RenderQueueField(Rect r);
        public bool EnableInstancingField();
        public void EnableInstancingField(Rect r);
        public bool IsInstancingEnabled();
        public bool DoubleSidedGIField();
        public Rect TexturePropertySingleLine(GUIContent label, MaterialProperty textureProp);
        public Rect TexturePropertySingleLine(GUIContent label, MaterialProperty textureProp, MaterialProperty extraProperty1);
        public Rect TexturePropertySingleLine(GUIContent label, MaterialProperty textureProp, MaterialProperty extraProperty1, MaterialProperty extraProperty2);
        [Obsolete("Use TexturePropertyWithHDRColor(GUIContent label, MaterialProperty textureProp, MaterialProperty colorProperty, bool showAlpha)")]
        public Rect TexturePropertyWithHDRColor(GUIContent label, MaterialProperty textureProp, MaterialProperty colorProperty, ColorPickerHDRConfig hdrConfig, bool showAlpha);
        public Rect TexturePropertyWithHDRColor(GUIContent label, MaterialProperty textureProp, MaterialProperty colorProperty, bool showAlpha);
        public Rect TexturePropertyTwoLines(GUIContent label, MaterialProperty textureProp, MaterialProperty extraProperty1, GUIContent label2, MaterialProperty extraProperty2);
        public static Rect GetRightAlignedFieldRect(Rect r);
        public static Rect GetLeftAlignedFieldRect(Rect r);
        public static Rect GetFlexibleRectBetweenLabelAndField(Rect r);
        public static Rect GetFlexibleRectBetweenFieldAndRightEdge(Rect r);
        public static Rect GetRectAfterLabelWidth(Rect r);
    }
}
using UnityEngine;

namespace UnityEditor
{
    public abstract class MaterialPropertyDrawer
    {
        protected MaterialPropertyDrawer();

        public virtual void OnGUI(Rect position, MaterialProperty prop, GUIContent label, MaterialEditor editor);
        public virtual void OnGUI(Rect position, MaterialProperty prop, string label, MaterialEditor editor);
        public virtual float GetPropertyHeight(MaterialProperty prop, string label, MaterialEditor editor);
        public virtual void Apply(MaterialProperty prop);
    }
}
using System;
using UnityEngine;

namespace UnityEditor
{
    public class PreviewRenderUtility
    {
        [Obsolete("Use the property camera instead (UnityUpgradable) -> camera", False)]
        public Camera m_Camera;
        [Obsolete("Use the property cameraFieldOfView (UnityUpgradable) -> cameraFieldOfView", False)]
        public float m_CameraFieldOfView;
        [Obsolete("Use the property lights (UnityUpgradable) -> lights", False)]
        public Light[] m_Light;

        public PreviewRenderUtility(bool renderFullScene);
        public PreviewRenderUtility(bool renderFullScene, bool pixelPerfect);
        public PreviewRenderUtility();

        ~PreviewRenderUtility();

        public Camera camera { get; }
        public float cameraFieldOfView { get; set; }
        public Color ambientColor { get; set; }
        public Light[] lights { get; }

        public void Cleanup();
        public void BeginPreview(Rect r, GUIStyle previewBackground);
        public void BeginStaticPreview(Rect r);
        public float GetScaleFactor(float width, float height);
        [Obsolete("This method has been marked obsolete, use BeginStaticPreview() instead (UnityUpgradable) -> BeginStaticPreview(*)", False)]
        public void BeginStaticPreviewHDR(Rect r);
        [Obsolete("This method has been marked obsolete, use BeginPreview() instead (UnityUpgradable) -> BeginPreview(*)", False)]
        public void BeginPreviewHDR(Rect r, GUIStyle previewBackground);
        public Texture EndPreview();
        public void EndAndDrawPreview(Rect r);
        public Texture2D EndStaticPreview();
        [Obsolete("AddSingleGO(GameObject go, bool instantiateAtZero) has been deprecated, use AddSingleGo(GameObject go) instead. instantiateAtZero has no effect and is not supported.")]
        public void AddSingleGO(GameObject go, bool instantiateAtZero);
        public void AddSingleGO(GameObject go);
        public GameObject InstantiatePrefabInScene(GameObject prefab);
        public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material mat, int subMeshIndex);
        public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material mat, int subMeshIndex, MaterialPropertyBlock customProperties);
        public void DrawMesh(Mesh mesh, Matrix4x4 m, Material mat, int subMeshIndex, MaterialPropertyBlock customProperties, Transform probeAnchor, bool useLightProbe);
        public void DrawMesh(Mesh mesh, Vector3 pos, Quaternion rot, Material mat, int subMeshIndex);
        public void DrawMesh(Mesh mesh, Vector3 pos, Quaternion rot, Material mat, int subMeshIndex, MaterialPropertyBlock customProperties);
        public void DrawMesh(Mesh mesh, Vector3 pos, Quaternion rot, Material mat, int subMeshIndex, MaterialPropertyBlock customProperties, Transform probeAnchor);
        public void DrawMesh(Mesh mesh, Vector3 pos, Quaternion rot, Material mat, int subMeshIndex, MaterialPropertyBlock customProperties, Transform probeAnchor, bool useLightProbe);
        public void DrawMesh(Mesh mesh, Vector3 pos, Vector3 scale, Quaternion rot, Material mat, int subMeshIndex, MaterialPropertyBlock customProperties, Transform probeAnchor, bool useLightProbe);
        protected static GameObject CreateLight();
        public void Render(bool allowScriptableRenderPipeline = False, bool updatefov = True);
    }
}
using System;
using UnityEngine;
using UnityEngine.Internal;

namespace UnityEditor
{
    [ExcludeFromDocs]
    public class RootEditorAttribute : Attribute
    {
        public bool supportsAddComponent;

        public RootEditorAttribute(bool supportsAddComponent = False);

        public delegate Type RootEditorHandler(UnityEngine.Object[] objects);
    }
}
using UnityEngine;

namespace UnityEditor
{
    public abstract class ShaderGUI
    {
        protected ShaderGUI();

        public virtual void OnGUI(MaterialEditor materialEditor, MaterialProperty[] properties);
        public virtual void OnMaterialPreviewGUI(MaterialEditor materialEditor, Rect r, GUIStyle background);
        public virtual void OnMaterialInteractivePreviewGUI(MaterialEditor materialEditor, Rect r, GUIStyle background);
        public virtual void OnMaterialPreviewSettingsGUI(MaterialEditor materialEditor);
        public virtual void OnClosed(Material material);
        public virtual void AssignNewShaderToMaterial(Material material, Shader oldShader, Shader newShader);
        protected static MaterialProperty FindProperty(string propertyName, MaterialProperty[] properties);
        protected static MaterialProperty FindProperty(string propertyName, MaterialProperty[] properties, bool propertyIsMandatory);
    }
}
using System;

namespace UnityEditor
{
    [AttributeUsage(Method)]
    [Obsolete("[ShaderIncludePath] attribute is no longer supported. Your shader library must be under the Assets folder or in a package. To include shader headers directly from a package, use #include \"Packages/<package name>/<path to your header file>\"", True)]
    public class ShaderIncludePathAttribute : Attribute
    {
        public ShaderIncludePathAttribute();
    }
}
using UnityEngine;

namespace UnityEditor
{
    public static class TransformUtils
    {
        public static Vector3 GetInspectorRotation(Transform t);
        public static void SetInspectorRotation(Transform t, Vector3 r);
    }
}
namespace UnityEditor
{
    public enum BodyPart
    {
        None = -1,
        Avatar = 0,
        Body = 1,
        Head = 2,
        LeftArm = 3,
        LeftFingers = 4,
        RightArm = 5,
        RightFingers = 6,
        LeftLeg = 7,
        RightLeg = 8,
        Last = 9
    }
}
namespace UnityEditor
{
    public enum BoneState
    {
        None = 0,
        NotFound = 1,
        Duplicate = 2,
        InvalidHierarchy = 3,
        BoneLenghtIsZero = 4,
        Valid = 5
    }
}
using UnityEngine;

namespace UnityEditor
{
    public class PlatformIcon
    {
        public int layerCount { get; set; }
        public int maxLayerCount { get; }
        public int minLayerCount { get; }
        public int width { get; }
        public int height { get; }
        public PlatformIconKind kind { get; }

        public Texture2D GetTexture(int layer = 0);
        public Texture2D[] GetTextures();
        public void SetTexture(Texture2D texture, int layer = 0);
        public void SetTextures(params Texture2D[] textures);
        public override string ToString();
    }
}
namespace UnityEditor
{
    public class PlatformIconKind
    {
        public override bool Equals(object obj);
        public override int GetHashCode();
        public override string ToString();
    }
}
using System;
using System.Collections.Generic;
using UnityEditor.SceneManagement;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.SceneManagement;

namespace UnityEditor
{
    [NativeHeader("Editor/Src/Prefabs/Prefab.h")]
    [NativeHeader("Editor/Src/Prefabs/PrefabCreation.h")]
    [NativeHeader("Editor/Src/Prefabs/PrefabInstance.h")]
    [NativeHeader("Editor/Src/Prefabs/PrefabConnection.h")]
    [NativeHeader("Editor/Mono/Prefabs/PrefabUtility.bindings.h")]
    public sealed class PrefabUtility
    {
        public static PrefabInstanceUpdated prefabInstanceUpdated;

        public PrefabUtility();

        [StaticAccessor("PrefabUtilityBindings", DoubleColon)]
        [Obsolete("Use GetPrefabInstanceHandle for Prefab instances. Handles for Prefab Assets has been discontinued.")]
        public static UnityEngine.Object GetPrefabObject(UnityEngine.Object targetObject);
        [StaticAccessor("PrefabUtilityBindings", DoubleColon)]
        public static UnityEngine.Object GetPrefabInstanceHandle(UnityEngine.Object instanceComponentOrGameObject);
        [StaticAccessor("PrefabUtilityBindings", DoubleColon)]
        public static PropertyModification[] GetPropertyModifications(UnityEngine.Object targetPrefab);
        [StaticAccessor("PrefabUtilityBindings", DoubleColon)]
        public static void SetPropertyModifications(UnityEngine.Object targetPrefab, PropertyModification[] modifications);
        [FreeFunction]
        public static bool HasPrefabInstanceAnyOverrides(GameObject instanceRoot, bool includeDefaultOverrides);
        [NativeHeader("Editor/Src/Prefabs/AttachedPrefabAsset.h")]
        [FreeFunction]
        public static UnityEngine.Object InstantiateAttachedAsset([NotNull("NullExceptionObject")] UnityEngine.Object targetObject);
        [FreeFunction]
        public static void RecordPrefabInstancePropertyModifications([NotNull("NullExceptionObject")] UnityEngine.Object targetObject);
        [NativeThrows]
        [Obsolete("MergeAllPrefabInstances is deprecated. Prefabs are merged automatically. There is no need to call this method.")]
        [StaticAccessor("PrefabUtilityBindings", DoubleColon)]
        public static void MergeAllPrefabInstances(UnityEngine.Object targetObject);
        [FreeFunction]
        [Obsolete("The concept of disconnecting Prefab instances has been deprecated.")]
        public static void DisconnectPrefabInstance(UnityEngine.Object targetObject);
        [NativeThrows]
        [StaticAccessor("PrefabUtilityBindings", DoubleColon)]
        public static GameObject[] UnpackPrefabInstanceAndReturnNewOutermostRoots(GameObject instanceRoot, PrefabUnpackMode unpackMode);
        [StaticAccessor("PrefabUtilityBindings", DoubleColon)]
        [NativeThrows]
        public static void LoadPrefabContentsIntoPreviewScene(string prefabPath, Scene scene);
        [NativeThrows]
        [StaticAccessor("PrefabUtilityBindings", DoubleColon)]
        [Obsolete("Use RevertPrefabInstance. Prefabs instances can no longer be connected to Prefab Assets they are not an instance of to begin with.")]
        public static GameObject ConnectGameObjectToPrefab([NotNull("ArgumentNullException")] GameObject go, [NotNull("ArgumentNullException")] GameObject sourcePrefab);
        [Obsolete("FindRootGameObjectWithSameParentPrefab is deprecated, please use GetOutermostPrefabInstanceRoot instead.")]
        [FreeFunction]
        public static GameObject FindRootGameObjectWithSameParentPrefab([NotNull("NullExceptionObject")] GameObject target);
        [Obsolete("FindValidUploadPrefabInstanceRoot is deprecated, please use GetOutermostPrefabInstanceRoot instead.")]
        [NativeMethod("FindInstanceRootGameObject", IsFreeFunction = True)]
        public static GameObject FindValidUploadPrefabInstanceRoot([NotNull("NullExceptionObject")] GameObject target);
        [FreeFunction]
        [Obsolete("Use RevertPrefabInstance.")]
        public static bool ReconnectToLastPrefab([NotNull("NullExceptionObject")] GameObject go);
        [StaticAccessor("PrefabUtilityBindings", DoubleColon)]
        [Obsolete("Use RevertObjectOverride.")]
        public static bool ResetToPrefabState(UnityEngine.Object obj);
        [FreeFunction]
        public static bool IsAddedComponentOverride([NotNull("ArgumentNullException")] UnityEngine.Object component);
        [Obsolete("Use the overload that takes an InteractionMode parameter.")]
        [FreeFunction]
        public static bool RevertPrefabInstance([NotNull("ArgumentNullException")] GameObject go);
        [Obsolete("Use GetOutermostPrefabInstanceRoot if source is a Prefab instance or source.transform.root.gameObject if source is a Prefab Asset object.")]
        [FreeFunction]
        public static GameObject FindPrefabRoot([NotNull("ArgumentNullException")] GameObject source);
        [FreeFunction]
        public static bool IsPartOfAnyPrefab([NotNull("ArgumentNullException")] UnityEngine.Object componentOrGameObject);
        [FreeFunction]
        public static bool IsPartOfPrefabAsset([NotNull("ArgumentNullException")] UnityEngine.Object componentOrGameObject);
        [FreeFunction]
        public static bool IsPartOfPrefabInstance([NotNull("ArgumentNullException")] UnityEngine.Object componentOrGameObject);
        [FreeFunction]
        public static bool IsPartOfNonAssetPrefabInstance([NotNull("ArgumentNullException")] UnityEngine.Object componentOrGameObject);
        [FreeFunction]
        public static bool IsPartOfRegularPrefab([NotNull("ArgumentNullException")] UnityEngine.Object componentOrGameObject);
        [FreeFunction]
        public static bool IsPartOfModelPrefab([NotNull("ArgumentNullException")] UnityEngine.Object componentOrGameObject);
        [FreeFunction]
        public static bool IsPartOfVariantPrefab([NotNull("ArgumentNullException")] UnityEngine.Object componentOrGameObject);
        [FreeFunction]
        public static bool IsPartOfImmutablePrefab([NotNull("ArgumentNullException")] UnityEngine.Object componentOrGameObject);
        [FreeFunction]
        public static bool IsDisconnectedFromPrefabAsset([NotNull("ArgumentNullException")] UnityEngine.Object componentOrGameObject);
        [FreeFunction]
        public static bool IsPrefabAssetMissing([NotNull("ArgumentNullException")] UnityEngine.Object instanceComponentOrGameObject);
        [FreeFunction]
        public static GameObject GetOutermostPrefabInstanceRoot([NotNull("ArgumentNullException")] UnityEngine.Object componentOrGameObject);
        [FreeFunction]
        public static GameObject GetNearestPrefabInstanceRoot([NotNull("ArgumentNullException")] UnityEngine.Object componentOrGameObject);
        [NativeMethod("PrefabUtilityBindings::IsDefaultOverride", IsFreeFunction = True)]
        public static bool IsDefaultOverride(PropertyModification modification);
        public static void RevertPrefabInstance(GameObject instanceRoot, InteractionMode action);
        public static void ApplyPrefabInstance(GameObject instanceRoot, InteractionMode action);
        public static void ApplyPropertyOverride(SerializedProperty instanceProperty, string assetPath, InteractionMode action);
        public static void RevertPropertyOverride(SerializedProperty instanceProperty, InteractionMode action);
        public static void ApplyObjectOverride(UnityEngine.Object instanceComponentOrGameObject, string assetPath, InteractionMode action);
        public static void RevertObjectOverride(UnityEngine.Object instanceComponentOrGameObject, InteractionMode action);
        public static void ApplyAddedComponent(Component component, string assetPath, InteractionMode action);
        public static void RevertAddedComponent(Component component, InteractionMode action);
        public static void ApplyRemovedComponent(GameObject instanceGameObject, Component assetComponent, InteractionMode action);
        public static void RevertRemovedComponent(GameObject instanceGameObject, Component assetComponent, InteractionMode action);
        public static void ApplyAddedGameObject(GameObject gameObject, string assetPath, InteractionMode action);
        public static void RevertAddedGameObject(GameObject gameObject, InteractionMode action);
        public static List<ObjectOverride> GetObjectOverrides(GameObject prefabInstance, bool includeDefaultOverrides = False);
        public static List<AddedComponent> GetAddedComponents(GameObject prefabInstance);
        public static List<RemovedComponent> GetRemovedComponents(GameObject prefabInstance);
        public static List<AddedGameObject> GetAddedGameObjects(GameObject prefabInstance);
        public static bool IsAnyPrefabInstanceRoot(GameObject gameObject);
        public static bool IsOutermostPrefabInstanceRoot(GameObject gameObject);
        public static string GetPrefabAssetPathOfNearestInstanceRoot(UnityEngine.Object instanceComponentOrGameObject);
        public static Texture2D GetIconForGameObject(GameObject gameObject);
        [Obsolete("Use GetCorrespondingObjectFromSource.")]
        public static UnityEngine.Object GetPrefabParent(UnityEngine.Object obj);
        [Obsolete("The concept of creating a completely empty Prefab has been discontinued. You can however use SaveAsPrefabAsset with an empty GameObject.")]
        public static UnityEngine.Object CreateEmptyPrefab(string path);
        public static GameObject SavePrefabAsset(GameObject asset);
        public static GameObject SavePrefabAsset(GameObject asset, out bool savedSuccessfully);
        public static GameObject SaveAsPrefabAsset(GameObject instanceRoot, string assetPath, out bool success);
        public static GameObject SaveAsPrefabAsset(GameObject instanceRoot, string assetPath);
        public static GameObject SaveAsPrefabAssetAndConnect(GameObject instanceRoot, string assetPath, InteractionMode action);
        public static GameObject SaveAsPrefabAssetAndConnect(GameObject instanceRoot, string assetPath, InteractionMode action, out bool success);
        [Obsolete("Use SaveAsPrefabAsset instead.")]
        public static GameObject CreatePrefab(string path, GameObject go);
        [Obsolete("Use SaveAsPrefabAsset or SaveAsPrefabAssetAndConnect instead.")]
        public static GameObject CreatePrefab(string path, GameObject go, ReplacePrefabOptions options);
        public static UnityEngine.Object InstantiatePrefab(UnityEngine.Object assetComponentOrGameObject);
        public static UnityEngine.Object InstantiatePrefab(UnityEngine.Object assetComponentOrGameObject, Scene destinationScene);
        public static UnityEngine.Object InstantiatePrefab(UnityEngine.Object assetComponentOrGameObject, Transform parent);
        [Obsolete("Use SaveAsPrefabAsset with a path instead.")]
        public static GameObject ReplacePrefab(GameObject go, UnityEngine.Object targetPrefab);
        [Obsolete("Use SaveAsPrefabAsset or SaveAsPrefabAssetAndConnect with a path instead.")]
        public static GameObject ReplacePrefab(GameObject go, UnityEngine.Object targetPrefab, ReplacePrefabOptions replaceOptions);
        public static TObject GetCorrespondingObjectFromSource<TObject>(TObject componentOrGameObject) where TObject : UnityEngine.Object;
        public static TObject GetCorrespondingObjectFromOriginalSource<TObject>(TObject componentOrGameObject) where TObject : UnityEngine.Object;
        public static TObject GetCorrespondingObjectFromSourceAtPath<TObject>(TObject componentOrGameObject, string assetPath) where TObject : UnityEngine.Object;
        [Obsolete("Use GetPrefabAssetType and GetPrefabInstanceStatus to get the full picture about Prefab types.")]
        public static PrefabType GetPrefabType(UnityEngine.Object target);
        public static bool IsAddedGameObjectOverride(GameObject gameObject);
        public static void UnpackPrefabInstance(GameObject instanceRoot, PrefabUnpackMode unpackMode, InteractionMode action);
        public static bool IsPartOfPrefabThatCanBeAppliedTo(UnityEngine.Object gameObjectOrComponent);
        public static PrefabInstanceStatus GetPrefabInstanceStatus(UnityEngine.Object componentOrGameObject);
        public static PrefabAssetType GetPrefabAssetType(UnityEngine.Object componentOrGameObject);
        public static GameObject LoadPrefabContents(string assetPath);
        public static void UnloadPrefabContents(GameObject contentsRoot);

        public delegate void PrefabInstanceUpdated(GameObject instance);
        public struct EditPrefabContentsScope : IDisposable
        {
            public readonly string assetPath;
            public readonly GameObject prefabContentsRoot;

            public EditPrefabContentsScope(string assetPath);

            public void Dispose();
        }
    }
}
namespace UnityEditor
{
    public enum PrefabAssetType
    {
        NotAPrefab = 0,
        Regular = 1,
        Model = 2,
        Variant = 3,
        MissingAsset = 4
    }
}
namespace UnityEditor
{
    public enum PrefabInstanceStatus
    {
        NotAPrefab = 0,
        Connected = 1,
        Disconnected = 2,
        MissingAsset = 3
    }
}
namespace UnityEditor
{
    public enum PrefabUnpackMode
    {
        OutermostRoot = 0,
        Completely = 1
    }
}
using System;

namespace UnityEditor
{
    [Obsolete("PrefabType no longer tells everything about Prefab instance.")]
    public enum PrefabType
    {
        None = 0,
        Prefab = 1,
        ModelPrefab = 2,
        PrefabInstance = 3,
        ModelPrefabInstance = 4,
        MissingPrefabInstance = 5,
        DisconnectedPrefabInstance = 6,
        DisconnectedModelPrefabInstance = 7
    }
}
using System;

namespace UnityEditor
{
    [Obsolete("This has turned into the more explicit APIs, SavePrefabAsset, SaveAsPrefabAsset, SaveAsPrefabAssetAndConnect")]
    [Flags]
    public enum ReplacePrefabOptions
    {
        Default = 0,
        ConnectToPrefab = 1,
        ReplaceNameBased = 2
    }
}
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor
{
    [RequiredByNativeCode]
    [NativeAsStruct]
    public sealed class PropertyModification
    {
        public Object target;
        public string propertyPath;
        public string value;
        public Object objectReference;

        public PropertyModification();
    }
}
using System;

namespace UnityEditor
{
    [AttributeUsage(Method)]
    [Obsolete("[PreferenceItem] is deprecated. Use [SettingsProvider] instead.")]
    public sealed class PreferenceItem : Attribute
    {
        public string name;

        public PreferenceItem(string name);
    }
}
namespace UnityEditor
{
    public enum SaveType
    {
        Binary = 0,
        Text = 1
    }
}
using System;
using System.Collections.Generic;
using System.Diagnostics;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [StaticAccessor("Editor::Progress", DoubleColon)]
    [NativeHeader("Editor/Src/Progress.h")]
    public static class Progress
    {
        public static bool running { get; }
        public static float globalProgress { get; }
        public static TimeSpan globalRemainingTime { get; }

        public static event Action<Item[]> added;
        public static event Action<Item[]> updated;
        public static event Action<Item[]> removed;

        public static int Start(string name, string description = null, Options options = None, int parentId = -1);
        [ThreadSafe]
        public static void Finish(int id, Status status = Succeeded);
        public static int Remove(int id);
        public static int Remove(int id, bool forceSynchronous);
        public static void Report(int id, float progress);
        public static void Report(int id, int currentStep, int totalSteps);
        public static void Report(int id, float progress, string description);
        public static void Report(int id, int currentStep, int totalSteps, string description);
        public static bool Cancel(int id);
        public static void RegisterCancelCallback(int id, Func<bool> callback);
        [ThreadSafe]
        public static void UnregisterCancelCallback(int id);
        public static bool Pause(int id);
        public static bool Resume(int id);
        public static void RegisterPauseCallback(int id, Func<bool, bool> callback);
        [ThreadSafe]
        public static void UnregisterPauseCallback(int id);
        public static int GetCount();
        public static int[] GetCountPerStatus();
        public static float GetProgress(int id);
        public static int GetCurrentStep(int id);
        public static int GetTotalSteps(int id);
        public static string GetName(int id);
        public static string GetDescription(int id);
        [ThreadSafe]
        public static void SetDescription(int id, string description);
        public static long GetStartDateTime(int id);
        public static long GetUpdateDateTime(int id);
        public static int GetParentId(int id);
        public static int GetId(int index);
        public static bool IsCancellable(int id);
        public static bool IsPausable(int id);
        public static Status GetStatus(int id);
        public static Options GetOptions(int id);
        [ThreadSafe]
        public static void SetTimeDisplayMode(int id, TimeDisplayMode displayMode);
        [ThreadSafe]
        public static void SetRemainingTime(int id, long seconds);
        public static void SetPriority(int id, int priority);
        public static void SetPriority(int id, Priority priority);
        public static TimeDisplayMode GetTimeDisplayMode(int id);
        public static bool Exists(int id);
        public static long GetRemainingTime(int id);
        public static int GetPriority(int id);
        public static void ClearRemainingTime(int id);
        [ThreadSafe]
        public static void SetStepLabel(int id, string label);
        public static string GetStepLabel(int id);
        public static void ShowDetails(bool shouldReposition = True);
        public static IEnumerable<Item> EnumerateItems();
        public static Item GetProgressById(int id);
        public static int GetRunningProgressCount();

        [NativeType(Header = "Editor/Src/Progress.h")]
        public enum Status
        {
            Running = 0,
            Succeeded = 1,
            Failed = 2,
            Canceled = 3,
            Paused = 4
        }
        [Flags]
        [NativeType(Header = "Editor/Src/Progress.h")]
        public enum Options
        {
            None = 0,
            Sticky = 1,
            Indefinite = 2,
            Synchronous = 4,
            Managed = 8,
            Unmanaged = 16
        }
        [NativeType(Header = "Editor/Src/Progress.h")]
        public enum TimeDisplayMode
        {
            NoTimeShown = 0,
            ShowRunningTime = 1,
            ShowRemainingTime = 2
        }
        [NativeType(Header = "Editor/Src/Progress.h")]
        public enum Priority
        {
            Unresponsive = 0,
            Idle = 1,
            Low = 2,
            Normal = 6,
            High = 10
        }
        [DebuggerDisplay("name={name}")]
        public class Item
        {
            public string name { get; }
            public string description { get; }
            public int id { get; }
            public float progress { get; }
            public int currentStep { get; }
            public int totalSteps { get; }
            public string stepLabel { get; }
            public int parentId { get; }
            public DateTime startTime { get; }
            public DateTime updateTime { get; }
            public Status status { get; }
            public Options options { get; }
            public TimeDisplayMode timeDisplayMode { get; }
            public int priority { get; }
            public TimeSpan remainingTime { get; }
            public bool finished { get; }
            public bool running { get; }
            public bool paused { get; }
            public bool responding { get; }
            public bool cancellable { get; }
            public bool pausable { get; }
            public bool indefinite { get; }
            public float elapsedTime { get; }
            public bool exists { get; }

            public void Report(float newProgress);
            public void Report(int newCurrentStep, int newTotalSteps);
            public void Report(float newProgress, string newDescription);
            public void Report(int newCurrentStep, int newTotalSteps, string newDescription);
            public bool Cancel();
            public bool Pause();
            public bool Resume();
            public void Finish(Status finishedStatus = Succeeded);
            public int Remove();
            public void RegisterCancelCallback(Func<bool> callback);
            public void UnregisterCancelCallback();
            public void RegisterPauseCallback(Func<bool, bool> callback);
            public void UnregisterPauseCallback();
            public void SetDescription(string newDescription);
            public void SetTimeDisplayMode(TimeDisplayMode mode);
            public void SetRemainingTime(long seconds);
            public void SetPriority(int priority);
            public void SetPriority(Priority priority);
            public void ClearRemainingTime();
            public void SetStepLabel(string label);
        }
    }
}
using UnityEditor.ProjectWindowCallback;
using UnityEngine;
using UnityEngine.Scripting;

namespace UnityEditor
{
    public class ProjectWindowUtil
    {
        public ProjectWindowUtil();

        [MenuItem("Assets/Create/GUI Skin", False, 601)]
        public static void CreateNewGUISkin();
        public static void CreateAsset(Object asset, string pathName);
        public static void CreateFolder();
        public static void CreateScene();
        public static void CreateAssetWithContent(string filename, string content, Texture2D icon = null);
        [RequiredByNativeCode]
        public static void CreateScriptAssetFromTemplateFile(string templatePath, string defaultNewFileName);
        public static void ShowCreatedAsset(Object o);
        public static void StartNameEditingIfProjectWindowExists(int instanceID, EndNameEditAction endAction, string pathName, Texture2D icon, string resourceFile);
        public static int[] GetAncestors(int instanceID);
        public static bool IsFolder(int instanceID);
        public static string GetContainingFolder(string path);
        public static string[] GetBaseFolders(string[] folders);
    }
}
namespace UnityEditor
{
    public class SearchableEditorWindow : EditorWindow
    {
        protected int m_SearchGroup;

        public SearchableEditorWindow();

        public virtual void OnEnable();
        public virtual void OnDisable();

        public enum SearchMode
        {
            All = 0,
            Name = 1,
            Type = 2,
            Label = 3,
            AssetBundleName = 4
        }
        public enum SearchModeHierarchyWindow
        {
            All = 0,
            Name = 1,
            Type = 2
        }
    }
}
using UnityEngine;

namespace UnityEditor
{
    public class DefaultLightingExplorerExtension : ILightingExplorerExtension
    {
        public DefaultLightingExplorerExtension();

        public virtual LightingExplorerTab[] GetContentTabs();
        public virtual void OnEnable();
        public virtual void OnDisable();
        protected virtual Object[] GetLights();
        protected virtual LightingExplorerTableColumn[] GetLightColumns();
        protected virtual Object[] GetReflectionProbes();
        protected virtual LightingExplorerTableColumn[] GetReflectionProbeColumns();
        protected virtual Object[] GetLightProbes();
        protected virtual LightingExplorerTableColumn[] GetLightProbeColumns();
        protected virtual Object[] GetEmissives();
        protected virtual LightingExplorerTableColumn[] GetEmissivesColumns();
    }
}
using System;
using UnityEngine;

namespace UnityEditor
{
    public class LightingExplorerTab
    {
        public LightingExplorerTab(string title, Func<UnityEngine.Object[]> objects, Func<LightingExplorerTableColumn[]> columns);
    }
}
using UnityEngine;

namespace UnityEditor
{
    public sealed class LightingExplorerTableColumn
    {
        public LightingExplorerTableColumn(DataType type, GUIContent headerContent, string propertyName = null, int width = 100, OnGUIDelegate onGUIDelegate = null, ComparePropertiesDelegate compareDelegate = null, CopyPropertiesDelegate copyDelegate = null, int[] dependencyIndices = null);

        public enum DataType
        {
            Name = 0,
            Checkbox = 1,
            Enum = 2,
            Int = 3,
            Float = 4,
            Color = 5,
            Custom = 20
        }
        public delegate void OnGUIDelegate(Rect r, SerializedProperty prop, SerializedProperty[] dependencies);
        public delegate int ComparePropertiesDelegate(SerializedProperty lhs, SerializedProperty rhs);
        public delegate void CopyPropertiesDelegate(SerializedProperty target, SerializedProperty source);
    }
}
using System;
using UnityEditor.Rendering;

namespace UnityEditor
{
    [AttributeUsage(Class)]
    public class LightingExplorerExtensionAttribute : ScriptableRenderPipelineExtensionAttribute
    {
        public LightingExplorerExtensionAttribute(Type renderPipeline);
    }
}
namespace UnityEditor
{
    public interface ILightingExplorerExtension
    {
        LightingExplorerTab[] GetContentTabs();
        void OnEnable();
        void OnDisable();
    }
}
namespace UnityEditor
{
    public abstract class LightingWindowEnvironmentSection
    {
        protected LightingWindowEnvironmentSection();

        public virtual void OnEnable();
        public virtual void OnDisable();
        public virtual void OnInspectorGUI();
    }
}
namespace UnityEditor
{
    public class PhysicsDebugWindow : EditorWindow
    {
        public PhysicsDebugWindow();

        [MenuItem("Window/Analysis/Physics Debugger", False, 11)]
        public static PhysicsDebugWindow ShowWindow();
        public void OnEnable();
        public void OnDisable();
    }
}
using System;
using UnityEngine;

namespace UnityEditor
{
    public static class SceneModeUtility
    {
        public static T[] GetSelectedObjectsOfType<T>(out GameObject[] gameObjects, params Type[] types) where T : UnityEngine.Object;
        public static void SearchForType(Type type);
        public static Type SearchBar(params Type[] types);
        public static bool StaticFlagField(string label, SerializedProperty property, int flag);
        public static bool SetStaticFlags(UnityEngine.Object[] targetObjects, int changedFlags, bool flagValue);
        public static GameObject[] GetObjects(UnityEngine.Object[] gameObjects, bool includeChildren);
    }
}
using System;
using System.Collections;
using System.ComponentModel;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.Scripting;

namespace UnityEditor
{
    [EditorWindowTitle(title = "Scene", useTypeNameAsIconName = True)]
    public class SceneView : SearchableEditorWindow, IHasCustomMenu
    {
        [Obsolete("m_SceneLighting has been deprecated. Use sceneLighting instead (UnityUpgradable) -> UnityEditor.SceneView.sceneLighting", True)]
        [EditorBrowsable(Never)]
        public bool m_SceneLighting;
        [Obsolete("m_AudioPlay has been deprecated. Use audioPlay instead (UnityUpgradable) -> audioPlay", True)]
        public bool m_AudioPlay;
        [EditorBrowsable(Never)]
        [Obsolete("onSceneGUIDelegate has been deprecated. Use duringSceneGui instead.")]
        public static OnSceneFunc onSceneGUIDelegate;
        [Obsolete("Use cameraMode instead", False)]
        public DrawCameraMode m_RenderMode;
        [Obsolete("m_ValidateTrueMetals has been deprecated. Use validateTrueMetals instead (UnityUpgradable) -> validateTrueMetals", True)]
        public bool m_ValidateTrueMetals;

        public SceneView();

        public static SceneView lastActiveSceneView { get; }
        public static SceneView currentDrawingSceneView { get; }
        public static Color selectedOutlineColor { get; }
        public bool drawGizmos { get; set; }
        protected internal Scene customScene { get; set; }
        protected internal Transform customParentForDraggedObjects { get; set; }
        public bool sceneLighting { get; set; }
        public bool in2DMode { get; set; }
        public bool isRotationLocked { get; set; }
        public bool audioPlay { get; set; }
        [Obsolete("Use cameraMode instead", False)]
        public DrawCameraMode renderMode { get; set; }
        public CameraMode cameraMode { get; set; }
        public bool validateTrueMetals { get; set; }
        public SceneViewState sceneViewState { get; set; }
        public bool showGrid { get; set; }
        public CameraSettings cameraSettings { get; set; }
        public Quaternion lastSceneViewRotation { get; set; }
        public float cameraDistance { get; }
        public static ArrayList sceneViews { get; }
        public Camera camera { get; }
        public Vector3 pivot { get; set; }
        public Quaternion rotation { get; set; }
        public float size { get; set; }
        public bool orthographic { get; set; }

        public event Func<CameraMode, bool> onValidateCameraMode;
        public event Action<CameraMode> onCameraModeChanged;
        public event Action<bool> gridVisibilityChanged;
        public static event Action<SceneView> beforeSceneGui;
        public static event Action<SceneView> duringSceneGui;

        public void ResetCameraSettings();
        public void SetSceneViewShaderReplace(Shader shader, string replaceString);
        [RequiredByNativeCode]
        public static bool FrameLastActiveSceneView();
        [RequiredByNativeCode]
        public static bool FrameLastActiveSceneViewWithLock();
        public static Camera[] GetAllSceneCameras();
        public static void RepaintAll();
        public override void OnEnable();
        protected virtual bool SupportsStageHandling();
        public override void OnDisable();
        public void OnDestroy();
        public virtual void AddItemsToMenu(GenericMenu menu);
        public bool IsCameraDrawModeEnabled(CameraMode mode);
        protected virtual void OnGUI();
        public void FixNegativeSize();
        public void LookAt(Vector3 point);
        public void LookAt(Vector3 point, Quaternion direction);
        public void LookAtDirect(Vector3 point, Quaternion direction);
        public void LookAt(Vector3 point, Quaternion direction, float newSize);
        public void LookAtDirect(Vector3 point, Quaternion direction, float newSize);
        public void LookAt(Vector3 point, Quaternion direction, float newSize, bool ortho);
        public void LookAt(Vector3 point, Quaternion direction, float newSize, bool ortho, bool instant);
        public void AlignViewToObject(Transform t);
        public void AlignWithView();
        public void MoveToView();
        public void MoveToView(Transform target);
        public bool FrameSelected();
        public bool FrameSelected(bool lockView);
        public virtual bool FrameSelected(bool lockView, bool instant);
        public bool Frame(Bounds bounds, bool instant = True);
        public static CameraMode AddCameraMode(string name, string section);
        public static void ClearUserDefinedCameraModes();
        public static CameraMode GetBuiltinCameraMode(DrawCameraMode mode);

        public struct CameraMode
        {
            public DrawCameraMode drawMode;
            public string name;
            public string section;

            public override bool Equals(object otherObject);
            public override int GetHashCode();
            public override string ToString();

            public static bool operator ==(CameraMode a, CameraMode z);
            public static bool operator !=(CameraMode a, CameraMode z);
        }
        public class SceneViewState
        {
            public bool showFog;
            public bool showSkybox;
            public bool showFlares;
            public bool showImageEffects;
            public bool showParticleSystems;
            public bool showVisualEffectGraphs;

            public SceneViewState();
            public SceneViewState(SceneViewState other);

            [Obsolete("Obsolete msg (UnityUpgradable) -> alwaysRefresh")]
            [EditorBrowsable(Never)]
            public bool showMaterialUpdate { get; set; }
            public bool alwaysRefresh { get; set; }
            public bool fogEnabled { get; }
            [Obsolete("Obsolete msg (UnityUpgradable) -> alwaysRefreshEnabled")]
            [EditorBrowsable(Never)]
            public bool materialUpdateEnabled { get; }
            public bool alwaysRefreshEnabled { get; }
            public bool skyboxEnabled { get; }
            public bool flaresEnabled { get; }
            public bool imageEffectsEnabled { get; }
            public bool particleSystemsEnabled { get; }
            public bool visualEffectGraphsEnabled { get; }
            public bool allEnabled { get; }
            public bool fxEnabled { get; set; }

            [Obsolete("IsAllOn() has been deprecated. Use allEnabled instead (UnityUpgradable) -> allEnabled")]
            public bool IsAllOn();
            [Obsolete("Toggle() has been deprecated. Use SetAllEnabled() instead (UnityUpgradable) -> SetAllEnabled(*)")]
            public void Toggle(bool value);
            public void SetAllEnabled(bool value);
        }
        [EditorBrowsable(Never)]
        [Obsolete("OnSceneFunc() has been deprecated. Use System.Action instead.")]
        public delegate void OnSceneFunc(SceneView sceneView);
        public class CameraSettings
        {
            public CameraSettings();

            public float speed { get; set; }
            public float speedNormalized { get; set; }
            public float speedMin { get; set; }
            public float speedMax { get; set; }
            public bool easingEnabled { get; set; }
            public float easingDuration { get; set; }
            public bool accelerationEnabled { get; set; }
            public float fieldOfView { get; set; }
            public float nearClip { get; set; }
            public float farClip { get; set; }
            public bool dynamicClip { get; set; }
            public bool occlusionCulling { get; set; }
        }
    }
}
using System;

namespace UnityEditor
{
    [AttributeUsage(Class, Inherited = False, AllowMultiple = True)]
    public sealed class CustomPropertyDrawer : Attribute
    {
        public CustomPropertyDrawer(Type type);
        public CustomPropertyDrawer(Type type, bool useForChildren);
    }
}
using UnityEngine;

namespace UnityEditor
{
    public abstract class DecoratorDrawer : GUIDrawer
    {
        protected DecoratorDrawer();

        public PropertyAttribute attribute { get; }

        public virtual void OnGUI(Rect position);
        public virtual float GetHeight();
        public virtual bool CanCacheInspectorGUI();
    }
}
namespace UnityEditor
{
    public abstract class GUIDrawer
    {
        protected GUIDrawer();
    }
}
using System.Reflection;
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor
{
    public abstract class PropertyDrawer : GUIDrawer
    {
        protected PropertyDrawer();

        public PropertyAttribute attribute { get; }
        public FieldInfo fieldInfo { get; }

        public virtual void OnGUI(Rect position, SerializedProperty property, GUIContent label);
        public virtual VisualElement CreatePropertyGUI(SerializedProperty property);
        public virtual float GetPropertyHeight(SerializedProperty property, GUIContent label);
        public virtual bool CanCacheInspectorGUI(SerializedProperty property);
    }
}
namespace UnityEditor
{
    public enum SettingsScope
    {
        User = 0,
        Project = 1
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.UIElements;

namespace UnityEditor
{
    public class SettingsProvider
    {
        public SettingsProvider(string path, SettingsScope scopes, IEnumerable<string> keywords = null);

        public string label { get; set; }
        public string settingsPath { get; }
        public SettingsScope scope { get; }
        public IEnumerable<string> keywords { get; set; }
        public Action<string> guiHandler { get; set; }
        public Action titleBarGuiHandler { get; set; }
        public Action footerBarGuiHandler { get; set; }
        public Action<string, VisualElement> activateHandler { get; set; }
        public Action deactivateHandler { get; set; }
        public Func<string, bool> hasSearchInterestHandler { get; set; }
        public Action inspectorUpdateHandler { get; set; }

        public virtual void OnActivate(string searchContext, VisualElement rootElement);
        public virtual void OnDeactivate();
        public virtual bool HasSearchInterest(string searchContext);
        public virtual void OnGUI(string searchContext);
        public virtual void OnTitleBarGUI();
        public virtual void OnFooterBarGUI();
        public virtual void OnInspectorUpdate();
        public void Repaint();
        public void PopulateSearchKeywordsFromGUIContentProperties<T>();
        public static IEnumerable<string> GetSearchKeywordsFromGUIContentProperties<T>();
        public static IEnumerable<string> GetSearchKeywordsFromSerializedObject(SerializedObject serializedObject);
        public static IEnumerable<string> GetSearchKeywordsFromPath(string path);
    }
}
using System;

namespace UnityEditor
{
    [AttributeUsage(Method)]
    public sealed class SettingsProviderAttribute : Attribute
    {
        public SettingsProviderAttribute();
    }
}
using System;

namespace UnityEditor
{
    [AttributeUsage(Method)]
    public sealed class SettingsProviderGroupAttribute : Attribute
    {
        public SettingsProviderGroupAttribute();
    }
}
namespace UnityEditor
{
    [InitializeOnLoad]
    public static class SettingsService
    {
        public static EditorWindow OpenProjectSettings(string settingsPath = null);
        public static EditorWindow OpenUserPreferences(string settingsPath = null);
        public static void NotifySettingsProviderChanged();
        public static void RepaintAllSettingsWindow();
    }
}
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor
{
    public class AssetSettingsProvider : SettingsProvider
    {
        public AssetSettingsProvider(string settingsWindowPath, Func<Editor> editorCreator, IEnumerable<string> keywords = null);
        public AssetSettingsProvider(string settingsWindowPath, Func<UnityEngine.Object> settingsGetter);

        public Editor settingsEditor { get; }

        public static AssetSettingsProvider CreateProviderFromAssetPath(string settingsWindowPath, string assetPath, IEnumerable<string> keywords = null);
        public static AssetSettingsProvider CreateProviderFromObject(string settingsWindowPath, UnityEngine.Object settingsObj, IEnumerable<string> keywords = null);
        public static AssetSettingsProvider CreateProviderFromResourcePath(string settingsWindowPath, string resourcePath, IEnumerable<string> keywords = null);
        public override void OnActivate(string searchContext, VisualElement rootElement);
        public override void OnDeactivate();
        public override void OnGUI(string searchContext);
        public override void OnTitleBarGUI();
        public override void OnFooterBarGUI();
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Editor/Src/Highlighter/HighlighterCore.bindings.h")]
    public sealed class Highlighter
    {
        public Highlighter();

        public static string activeText { get; }
        [NativeProperty("s_ActiveRect", False, Field)]
        public static Rect activeRect { get; }
        [NativeProperty("s_ActiveVisible", False, Field)]
        public static bool activeVisible { get; }
        public static bool active { get; }

        public static void Stop();
        public static bool Highlight(string windowTitle, string text);
        public static bool Highlight(string windowTitle, string text, HighlightSearchMode mode);
        public static void HighlightIdentifier(Rect position, string identifier);
    }
}
namespace UnityEditor
{
    public enum HighlightSearchMode
    {
        None = 0,
        Auto = 1,
        Identifier = 2,
        PrefixLabel = 3,
        Content = 4
    }
}
namespace UnityEditor
{
    public enum ObjectChangeKind
    {
        None = 0,
        ChangeScene = 1,
        CreateGameObjectHierarchy = 2,
        ChangeGameObjectStructureHierarchy = 3,
        ChangeGameObjectStructure = 4,
        ChangeGameObjectParent = 5,
        ChangeGameObjectOrComponentProperties = 6,
        DestroyGameObjectHierarchy = 7,
        CreateAssetObject = 8,
        DestroyAssetObject = 9,
        ChangeAssetObjectProperties = 10,
        UpdatePrefabInstances = 11
    }
}
namespace UnityEditor
{
    public static class ObjectChangeEvents
    {
        public static event ObjectChangeEventsHandler changesPublished;

        public delegate void ObjectChangeEventsHandler(ref ObjectChangeEventStream stream);
    }
}
using UnityEngine.SceneManagement;

namespace UnityEditor
{
    public struct ChangeGameObjectParentEventArgs
    {
        public ChangeGameObjectParentEventArgs(int instanceId, Scene previousScene, int previousParentInstanceId, Scene newScene, int newParentInstanceId);

        public int instanceId { get; }
        public int previousParentInstanceId { get; }
        public int newParentInstanceId { get; }
        public Scene previousScene { get; }
        public Scene newScene { get; }
    }
}
using UnityEngine.SceneManagement;

namespace UnityEditor
{
    public struct ChangeSceneEventArgs
    {
        public ChangeSceneEventArgs(Scene scene);

        public Scene scene { get; }
    }
}
using UnityEngine.SceneManagement;

namespace UnityEditor
{
    public struct CreateGameObjectHierarchyEventArgs
    {
        public CreateGameObjectHierarchyEventArgs(int instanceId, Scene scene);

        public int instanceId { get; }
        public Scene scene { get; }
    }
}
using UnityEngine.SceneManagement;

namespace UnityEditor
{
    public struct ChangeGameObjectStructureHierarchyEventArgs
    {
        public ChangeGameObjectStructureHierarchyEventArgs(int instanceId, Scene scene);

        public int instanceId { get; }
        public Scene scene { get; }
    }
}
using UnityEngine.SceneManagement;

namespace UnityEditor
{
    public struct ChangeGameObjectStructureEventArgs
    {
        public ChangeGameObjectStructureEventArgs(int instanceId, Scene scene);

        public int instanceId { get; }
        public Scene scene { get; }
    }
}
using UnityEngine.SceneManagement;

namespace UnityEditor
{
    public struct ChangeGameObjectOrComponentPropertiesEventArgs
    {
        public ChangeGameObjectOrComponentPropertiesEventArgs(int instanceId, Scene scene);

        public int instanceId { get; }
        public Scene scene { get; }
    }
}
using UnityEngine.SceneManagement;

namespace UnityEditor
{
    public struct DestroyGameObjectHierarchyEventArgs
    {
        public DestroyGameObjectHierarchyEventArgs(int instanceId, Scene scene);

        public int instanceId { get; }
        public Scene scene { get; }
    }
}
using UnityEngine.SceneManagement;

namespace UnityEditor
{
    public struct CreateAssetObjectEventArgs
    {
        public CreateAssetObjectEventArgs(GUID guid, int instanceId, Scene scene);

        public GUID guid { get; }
        public int instanceId { get; }
        public Scene scene { get; }
    }
}
using UnityEngine.SceneManagement;

namespace UnityEditor
{
    public struct DestroyAssetObjectEventArgs
    {
        public DestroyAssetObjectEventArgs(GUID guid, int instanceId, Scene scene);

        public GUID guid { get; }
        public int instanceId { get; }
        public Scene scene { get; }
    }
}
using UnityEngine.SceneManagement;

namespace UnityEditor
{
    public struct ChangeAssetObjectPropertiesEventArgs
    {
        public ChangeAssetObjectPropertiesEventArgs(GUID guid, int instanceId, Scene scene);

        public GUID guid { get; }
        public int instanceId { get; }
        public Scene scene { get; }
    }
}
using Unity.Collections;
using UnityEngine.SceneManagement;

namespace UnityEditor
{
    public struct UpdatePrefabInstancesEventArgs
    {
        public UpdatePrefabInstancesEventArgs(Scene scene, NativeArray<int>.ReadOnly instanceIds);

        public Scene scene { get; }
        public NativeArray<int>.ReadOnly instanceIds { get; }
    }
}
using System;
using Unity.Collections;

namespace UnityEditor
{
    public struct ObjectChangeEventStream : IDisposable
    {
        public int length { get; }
        public bool isCreated { get; }

        public ObjectChangeKind GetEventType(int eventIdx);
        public void GetChangeSceneEvent(int eventIdx, out ChangeSceneEventArgs data);
        public void GetCreateGameObjectHierarchyEvent(int eventIdx, out CreateGameObjectHierarchyEventArgs data);
        public void GetDestroyGameObjectHierarchyEvent(int eventIdx, out DestroyGameObjectHierarchyEventArgs data);
        public void GetChangeGameObjectStructureHierarchyEvent(int eventIdx, out ChangeGameObjectStructureHierarchyEventArgs data);
        public void GetChangeGameObjectStructureEvent(int eventIdx, out ChangeGameObjectStructureEventArgs data);
        public void GetChangeGameObjectParentEvent(int eventIdx, out ChangeGameObjectParentEventArgs data);
        public void GetChangeGameObjectOrComponentPropertiesEvent(int eventIdx, out ChangeGameObjectOrComponentPropertiesEventArgs data);
        public void GetCreateAssetObjectEvent(int eventIdx, out CreateAssetObjectEventArgs data);
        public void GetDestroyAssetObjectEvent(int eventIdx, out DestroyAssetObjectEventArgs data);
        public void GetChangeAssetObjectPropertiesEvent(int eventIdx, out ChangeAssetObjectPropertiesEventArgs data);
        public void GetUpdatePrefabInstancesEvent(int eventIdx, out UpdatePrefabInstancesEventArgs data);
        public ObjectChangeEventStream Clone(Allocator allocator);
        public void Dispose();

        public struct Builder : IDisposable
        {
            public Builder(Allocator allocator);

            public int eventCount { get; }

            public ObjectChangeEventStream ToStream(Allocator allocator);
            public void Dispose();
            public void PushChangeSceneEvent(ref ChangeSceneEventArgs data);
            public void PushCreateGameObjectHierarchyEvent(ref CreateGameObjectHierarchyEventArgs data);
            public void PushDestroyGameObjectHierarchyEvent(ref DestroyGameObjectHierarchyEventArgs data);
            public void PushChangeGameObjectStructureHierarchyEvent(ref ChangeGameObjectStructureHierarchyEventArgs data);
            public void PushChangeGameObjectStructureEvent(ref ChangeGameObjectStructureEventArgs data);
            public void PushChangeGameObjectParentEvent(ref ChangeGameObjectParentEventArgs data);
            public void PushChangeGameObjectOrComponentPropertiesEvent(ref ChangeGameObjectOrComponentPropertiesEventArgs data);
            public void PushCreateAssetObjectEvent(ref CreateAssetObjectEventArgs data);
            public void PushDestroyAssetObjectEvent(ref DestroyAssetObjectEventArgs data);
            public void PushChangeAssetObjectPropertiesEvent(ref ChangeAssetObjectPropertiesEventArgs data);
            public void PushUpdatePrefabInstancesEvent(ref UpdatePrefabInstancesEventArgs data);
        }
    }
}
using UnityEngine.Scripting;

namespace UnityEditor
{
    [RequiredByNativeCode]
    public struct UndoPropertyModification
    {
        public PropertyModification previousValue;
        public PropertyModification currentValue;

        public bool keepPrefabOverride { get; set; }
    }
}
using System;
using UnityEngine;

namespace UnityEditor
{
    [Obsolete("Use Undo.RecordObject before modifying the object instead")]
    public class UndoSnapshot
    {
        public UndoSnapshot(UnityEngine.Object[] objectsToUndo);

        public void Restore();
        public void Dispose();
    }
}
using System;

namespace UnityEditor
{
    public class CloudProjectSettings
    {
        public CloudProjectSettings();

        public static string userId { get; }
        public static string userName { get; }
        public static string accessToken { get; }
        public static string projectId { get; }
        public static string projectName { get; }
        public static string organizationId { get; }
        public static string organizationName { get; }

        public static void RefreshAccessToken(Action<bool> refresh);
    }
}
namespace UnityEditor
{
    public class ExpressionEvaluator
    {
        public ExpressionEvaluator();

        public static bool Evaluate<T>(string expression, out T value);
    }
}
using UnityEngine;

namespace UnityEditor
{
    public class MathUtils
    {
        public MathUtils();

        public static float GetQuatLength(Quaternion q);
        public static Quaternion GetQuatConjugate(Quaternion q);
        public static Matrix4x4 OrthogonalizeMatrix(Matrix4x4 m);
        public static void QuaternionNormalize(ref Quaternion q);
        public static Quaternion QuaternionFromMatrix(Matrix4x4 m);
        public static Quaternion GetQuatLog(Quaternion q);
        public static Quaternion GetQuatExp(Quaternion q);
        public static Quaternion GetQuatSquad(float t, Quaternion q0, Quaternion q1, Quaternion a0, Quaternion a1);
        public static Quaternion GetSquadIntermediate(Quaternion q0, Quaternion q1, Quaternion q2);
        public static float Ease(float t, float k1, float k2);
        public static Quaternion Slerp(Quaternion p, Quaternion q, float t);
        public static object IntersectRayTriangle(Ray ray, Vector3 v0, Vector3 v1, Vector3 v2, bool bidirectional);
        public static Vector3 ClosestPtSegmentRay(Vector3 p1, Vector3 q1, Ray ray, out float squaredDist, out float s, out Vector3 closestRay);
        public static bool IntersectRaySphere(Ray ray, Vector3 sphereOrigin, float sphereRadius, ref float t, ref Vector3 q);
        public static bool ClosestPtRaySphere(Ray ray, Vector3 sphereOrigin, float sphereRadius, ref float t, ref Vector3 q);
    }
}
namespace UnityEditor
{
    public enum RemoveAssetOptions
    {
        MoveAssetToTrash = 0,
        DeleteAssets = 2
    }
}
using System;

namespace UnityEditor
{
    [Flags]
    public enum ImportAssetOptions
    {
        Default = 0,
        ForceUpdate = 1,
        ForceSynchronousImport = 8,
        ImportRecursive = 256,
        DontDownloadFromCacheServer = 8192,
        ForceUncompressedImport = 16384
    }
}
namespace UnityEditor
{
    public enum StatusQueryOptions
    {
        ForceUpdate = 0,
        UseCachedIfPossible = 1,
        UseCachedAsync = 2
    }
}
namespace UnityEditor
{
    public enum ForceReserializeAssetsOptions
    {
        ReserializeAssets = 1,
        ReserializeMetadata = 2,
        ReserializeAssetsAndMetadata = 3
    }
}
using UnityEngine.Internal;

namespace UnityEditor
{
    [ExcludeFromDocs]
    public struct CacheServerConnectionChangedParameters
    {
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Modules/AssetPipelineEditor/Public/AndroidAssetPackImporter.h")]
    [ExcludeFromPreset]
    public class AndroidAssetPackImporter : AssetImporter
    {
        public AndroidAssetPackImporter();

        public static AndroidAssetPackImporter[] GetAllImporters();
    }
}
using System;
using System.ComponentModel;

namespace UnityEditor
{
    [EditorBrowsable(Never)]
    [Obsolete("UnityEditor.AudioImporterFormat has been deprecated. Use UnityEngine.AudioCompressionFormat instead.")]
    public enum AudioImporterFormat
    {
        Native = -1,
        Compressed = 0
    }
}
using System;
using System.ComponentModel;

namespace UnityEditor
{
    [EditorBrowsable(Never)]
    [Obsolete("UnityEditor.AudioImporterLoadType has been deprecated. Use UnityEngine.AudioClipLoadType instead (UnityUpgradable) -> [UnityEngine] UnityEngine.AudioClipLoadType", True)]
    public enum AudioImporterLoadType
    {
        DecompressOnLoad = -1,
        CompressedInMemory = -1,
        [Obsolete("UnityEditor.AudioImporterLoadType.StreamFromDisc has been deprecated. Use UnityEngine.AudioClipLoadType.Streaming instead (UnityUpgradable) -> UnityEngine.AudioClipLoadType.Streaming", True)]
        StreamFromDisc = -1
    }
}
using System;

namespace UnityEditor
{
    [Obsolete("Setting and getting import channels is not used anymore (use forceToMono instead)", True)]
    public enum AudioImporterChannels
    {
        Automatic = 0,
        Mono = 1,
        Stereo = 2
    }
}
namespace UnityEditor
{
    public enum AudioSampleRateSetting
    {
        PreserveSampleRate = 0,
        OptimizeSampleRate = 1,
        OverrideSampleRate = 2
    }
}
using UnityEngine;

namespace UnityEditor
{
    public struct AudioImporterSampleSettings
    {
        public AudioClipLoadType loadType;
        public AudioSampleRateSetting sampleRateSetting;
        public uint sampleRateOverride;
        public AudioCompressionFormat compressionFormat;
        public float quality;
        public int conversionMode;
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Modules/AssetPipelineEditor/Public/AudioImporter.h")]
    public sealed class AudioImporter : AssetImporter
    {
        public AudioImporter();

        public AudioImporterSampleSettings defaultSampleSettings { get; set; }
        public bool forceToMono { get; set; }
        public bool ambisonic { get; set; }
        public bool loadInBackground { get; set; }
        public bool preloadAudioData { get; set; }
        [Obsolete("Setting and getting import channels is not used anymore (use forceToMono instead)", True)]
        public AudioImporterChannels channels { get; set; }
        [Obsolete("AudioImporter.compressionBitrate is no longer supported", True)]
        public int compressionBitrate { get; set; }
        [Obsolete("AudioImporter.loopable is no longer supported. All audio assets encoded by Unity are by default loopable.")]
        public bool loopable { get; set; }
        [Obsolete("AudioImporter.hardware is no longer supported. All mixing of audio is done by software and only some platforms use hardware acceleration to perform decoding.")]
        public bool hardware { get; set; }
        [Obsolete("AudioImporter.threeD is no longer supported")]
        public bool threeD { get; set; }

        public bool ContainsSampleSettingsOverride(string platform);
        public AudioImporterSampleSettings GetOverrideSampleSettings(string platform);
        public bool SetOverrideSampleSettings(string platform, AudioImporterSampleSettings settings);
        public bool ClearSampleSettingOverride(string platform);
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Modules/AssetPipelineEditor/Public/MonoImporter.bindings.h")]
    [NativeHeader("Modules/AssetPipelineEditor/Public/MonoImporter.h")]
    [ExcludeFromPreset]
    public class MonoImporter : AssetImporter
    {
        public MonoImporter();

        public void SetDefaultReferences(string[] name, Object[] target);
        [FreeFunction("MonoImporterBindings::GetAllRuntimeMonoScripts")]
        public static MonoScript[] GetAllRuntimeMonoScripts();
        [FreeFunction("MonoImporterBindings::SetMonoScriptExecutionOrder")]
        public static void SetExecutionOrder([NotNull("NullExceptionObject")] MonoScript script, int order);
        [FreeFunction("MonoImporterBindings::GetExecutionOrder")]
        public static int GetExecutionOrder([NotNull("NullExceptionObject")] MonoScript script);
        public MonoScript GetScript();
        public Object GetDefaultReference(string name);
    }
}
using System;
using System.ComponentModel;

namespace UnityEditor
{
    [Obsolete("MovieImporter is removed. Use VideoClipImporter instead.", True)]
    [EditorBrowsable(Never)]
    public class MovieImporter
    {
        public MovieImporter();

        public float quality { get; set; }
        public bool linearTexture { get; set; }
        public float duration { get; }
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Modules/AssetPipelineEditor/Public/PluginImporter.h")]
    [ExcludeFromPreset]
    public sealed class PluginImporter : AssetImporter
    {
        public PluginImporter();

        [NativeProperty("DefineConstraints")]
        public string[] DefineConstraints { get; set; }
        public bool isPreloaded { get; set; }
        public bool isNativePlugin { get; }

        public static PluginImporter[] GetImporters(string platformName);
        public static PluginImporter[] GetImporters(BuildTarget platform);
        public static PluginImporter[] GetImporters(string buildTargetGroup, string buildTarget);
        public static PluginImporter[] GetImporters(BuildTargetGroup buildTargetGroup, BuildTarget buildTarget);
        [NativeMethod("ClearPlatformData")]
        public void ClearSettings();
        public void SetCompatibleWithAnyPlatform(bool enable);
        public bool GetCompatibleWithAnyPlatform();
        public void SetExcludeFromAnyPlatform(string platformName, bool excludedFromAny);
        public bool GetExcludeFromAnyPlatform(string platformName);
        public void SetIncludeInBuildDelegate(IncludeInBuildDelegate includeInBuildDelegate);
        public void SetExcludeFromAnyPlatform(BuildTarget platform, bool excludedFromAny);
        public bool GetExcludeFromAnyPlatform(BuildTarget platform);
        public void SetExcludeEditorFromAnyPlatform(bool excludedFromAny);
        public bool GetExcludeEditorFromAnyPlatform();
        public void SetCompatibleWithEditor(bool enable);
        public bool GetCompatibleWithEditor();
        public bool GetCompatibleWithEditor(string buildTargetGroup, string buildTarget);
        public bool GetIsOverridable();
        public bool ShouldIncludeInBuild();
        public void SetCompatibleWithPlatform(BuildTarget platform, bool enable);
        public bool GetCompatibleWithPlatform(BuildTarget platform);
        public void SetCompatibleWithPlatform(string platformName, bool enable);
        public bool GetCompatibleWithPlatform(string platformName);
        public void SetPlatformData(BuildTarget platform, string key, string value);
        public string GetPlatformData(BuildTarget platform, string key);
        public void SetPlatformData(string platformName, string key, string value);
        public string GetPlatformData(string platformName, string key);
        public void SetEditorData(string key, string value);
        public string GetEditorData(string key);
        public static PluginImporter[] GetAllImporters();

        public delegate bool IncludeInBuildDelegate(string path);
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Editor/Src/Video/VideoClipTranscode.h")]
    public enum VideoCodec
    {
        Auto = 0,
        H264 = 1,
        H265 = 3,
        VP8 = 2
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Modules/Video/Public/Base/VideoMediaTypes.h")]
    public enum VideoBitrateMode
    {
        Low = 0,
        Medium = 1,
        High = 2
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Editor/Src/Video/VideoClipTranscode.h")]
    public enum VideoDeinterlaceMode
    {
        Off = 0,
        Even = 1,
        Odd = 2
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Modules/AssetPipelineEditor/Public/VideoClipImporter.h")]
    public enum VideoResizeMode
    {
        OriginalSize = 0,
        ThreeQuarterRes = 1,
        HalfRes = 2,
        QuarterRes = 3,
        Square1024 = 4,
        Square512 = 5,
        Square256 = 6,
        CustomSize = 7
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Editor/Src/Video/VideoClipTranscode.h")]
    public enum VideoSpatialQuality
    {
        LowSpatialQuality = 0,
        MediumSpatialQuality = 1,
        HighSpatialQuality = 2
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Modules/AssetPipelineEditor/Public/VideoClipImporter.h")]
    public enum VideoEncodeAspectRatio
    {
        NoScaling = 0,
        Stretch = 5
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor
{
    [NativeType(Header = "Modules/AssetPipelineEditor/Public/VideoClipImporter.h")]
    [NativeAsStruct]
    [RequiredByNativeCode]
    public class VideoImporterTargetSettings
    {
        public bool enableTranscoding;
        public VideoCodec codec;
        [NativeName("resizeFormat")]
        public VideoResizeMode resizeMode;
        public VideoEncodeAspectRatio aspectRatio;
        public int customWidth;
        public int customHeight;
        public VideoBitrateMode bitrateMode;
        public VideoSpatialQuality spatialQuality;

        public VideoImporterTargetSettings();
    }
}
using System;
using System.ComponentModel;
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeConditional("ENABLE_VIDEO")]
    [NativeHeader("Modules/AssetPipelineEditor/Public/VideoClipImporter.h")]
    [NativeHeader("Modules/AssetPipelineEditor/Public/VideoClipImporter.bindings.h")]
    public class VideoClipImporter : AssetImporter
    {
        public VideoClipImporter();

        [Obsolete("VideoClipImporter.quality has no effect anymore (was only used for MovieTexture which is removed)", False)]
        [EditorBrowsable(Never)]
        public float quality { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("VideoClipImporter.linearColor has no effect anymore (was only used for MovieTexture which is removed)", False)]
        public bool linearColor { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("VideoClipImporter.useLegacyImporter has no effect anymore (was only used for MovieTexture which is removed)", False)]
        public bool useLegacyImporter { get; set; }
        public ulong sourceFileSize { get; }
        public ulong outputFileSize { get; }
        public int frameCount { get; }
        public double frameRate { get; }
        [NativeProperty("EncodeAlpha")]
        public bool keepAlpha { get; set; }
        public bool sourceHasAlpha { get; }
        [NativeProperty("Deinterlace")]
        public VideoDeinterlaceMode deinterlaceMode { get; set; }
        public bool flipVertical { get; set; }
        public bool flipHorizontal { get; set; }
        public bool importAudio { get; set; }
        [NativeName("sRGBClip")]
        public bool sRGBClip { get; set; }
        public VideoImporterTargetSettings defaultTargetSettings { get; set; }
        public bool isPlayingPreview { get; }
        public ushort sourceAudioTrackCount { get; }
        public int pixelAspectRatioNumerator { get; }
        public int pixelAspectRatioDenominator { get; }
        public bool transcodeSkipped { get; }

        public VideoImporterTargetSettings GetTargetSettings(string platform);
        public void SetTargetSettings(string platform, VideoImporterTargetSettings settings);
        public void ClearTargetSettings(string platform);
        [NativeName("StartPreview")]
        public void PlayPreview();
        public void StopPreview();
        public Texture GetPreviewTexture();
        public string GetResizeModeName(VideoResizeMode mode);
        [NativeName("GetDefaultResizeWidth")]
        public int GetResizeWidth(VideoResizeMode mode);
        [NativeName("GetDefaultResizeHeight")]
        public int GetResizeHeight(VideoResizeMode mode);
        public ushort GetSourceAudioChannelCount(ushort audioTrackIdx);
        public uint GetSourceAudioSampleRate(ushort audioTrackIdx);
        [NativeMethod("operator==")]
        public bool Equals([NotNull("NullExceptionObject")] VideoClipImporter rhs);
    }
}
using System;

namespace UnityEditor
{
    [Flags]
    public enum MeshOptimizationFlags
    {
        PolygonOrder = 1,
        VertexOrder = 2,
        Everything = -1
    }
}
namespace UnityEditor
{
    public enum ClipAnimationMaskType
    {
        CreateFromThisModel = 0,
        CopyFromOther = 1,
        None = 3
    }
}
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor
{
    [NativeHeader("Modules/AssetPipelineEditor/Public/ModelImporting/ModelImporter.bindings.h")]
    [NativeType(CodegenOptions = Custom, IntermediateScriptingStructName = "MonoClipAnimationInfoCurve")]
    [UsedByNativeCode]
    public struct ClipAnimationInfoCurve
    {
        public string name;
        public AnimationCurve curve;
    }
}
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor
{
    [UsedByNativeCode]
    [NativeType(CodegenOptions = Custom, IntermediateScriptingStructName = "MonoClipAnimationInfo")]
    [NativeHeader("Modules/AssetPipelineEditor/Public/ModelImporting/ModelImporter.bindings.h")]
    public sealed class ModelImporterClipAnimation
    {
        public ModelImporterClipAnimation();

        public string takeName { get; set; }
        public string name { get; set; }
        public float firstFrame { get; set; }
        public float lastFrame { get; set; }
        public WrapMode wrapMode { get; set; }
        public bool loop { get; set; }
        public float rotationOffset { get; set; }
        public float heightOffset { get; set; }
        public float cycleOffset { get; set; }
        public bool loopTime { get; set; }
        public bool loopPose { get; set; }
        public bool lockRootRotation { get; set; }
        public bool lockRootHeightY { get; set; }
        public bool lockRootPositionXZ { get; set; }
        public bool keepOriginalOrientation { get; set; }
        public bool keepOriginalPositionY { get; set; }
        public bool keepOriginalPositionXZ { get; set; }
        public bool heightFromFeet { get; set; }
        public bool mirror { get; set; }
        public ClipAnimationMaskType maskType { get; set; }
        public AvatarMask maskSource { get; set; }
        public AnimationEvent[] events { get; set; }
        public ClipAnimationInfoCurve[] curves { get; set; }
        public bool maskNeedsUpdating { get; }
        public float additiveReferencePoseFrame { get; set; }
        public bool hasAdditiveReferencePose { get; set; }

        public void ConfigureMaskFromClip(ref AvatarMask mask);
        public void ConfigureClipFromMask(AvatarMask mask);
        public override bool Equals(object o);
        public override int GetHashCode();
    }
}
using System;

namespace UnityEditor
{
    [Obsolete("Use ModelImporterMaterialName, ModelImporter.materialName and ModelImporter.materialImportMode instead", True)]
    public enum ModelImporterGenerateMaterials
    {
        [Obsolete("Use ModelImporter.materialImportMode=None instead", True)]
        None = 0,
        [Obsolete("Use ModelImporter.materialImportMode=Import and ModelImporter.materialName=ModelImporterMaterialName.BasedOnTextureName instead", True)]
        PerTexture = 1,
        [Obsolete("Use ModelImporter.materialImportMode=Import and ModelImporter.materialName=ModelImporterMaterialName.BasedOnModelNameAndMaterialName instead", True)]
        PerSourceMaterial = 2
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType(Header = "Modules/AssetPipelineEditor/Public/ModelImporting/ModelImporter.h")]
    public enum ModelImporterMaterialName
    {
        BasedOnTextureName = 0,
        BasedOnMaterialName = 1,
        BasedOnModelNameAndMaterialName = 2,
        [Obsolete("You should use ModelImporterMaterialName.BasedOnTextureName instead, because it it less complicated and behaves in more consistent way.")]
        BasedOnTextureName_Or_ModelNameAndMaterialName = 3
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType(Header = "Modules/AssetPipelineEditor/Public/ModelImporting/ModelImporter.h")]
    public enum ModelImporterMaterialSearch
    {
        Local = 0,
        RecursiveUp = 1,
        Everywhere = 2
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType(Header = "Modules/AssetPipelineEditor/Public/ModelImporting/ModelImporter.h")]
    public enum ModelImporterMaterialLocation
    {
        [Tooltip("Use external materials if found in the project.")]
        [InspectorName("Use External Materials (Legacy)")]
        External = 0,
        [InspectorName("Use Embedded Materials")]
        [Tooltip("Embed the material inside the imported asset.")]
        InPrefab = 1
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType(Header = "Modules/AssetPipelineEditor/Public/ModelImporting/ModelImporter.h")]
    public enum ModelImporterMaterialImportMode
    {
        [Tooltip("Do not import materials")]
        None = 0,
        [InspectorName("Standard (Legacy)")]
        [Tooltip("Use the standard Material import method.")]
        ImportStandard = 1,
        [InspectorName("Import via MaterialDescription")]
        [Tooltip("Use AssetPostprocessor.OnPreprocessMaterialDescription.")]
        ImportViaMaterialDescription = 2,
        [Obsolete("Use ImportStandard (UnityUpgradable) -> ImportStandard")]
        LegacyImport = 1,
        [Obsolete("Use ImportViaMaterialDescription (UnityUpgradable) -> ImportViaMaterialDescription")]
        Import = 2
    }
}
using System;

namespace UnityEditor
{
    public enum ModelImporterTangentSpaceMode
    {
        [Obsolete("Use ModelImporterNormals.Import instead")]
        Import = 0,
        [Obsolete("Use ModelImporterNormals.Calculate instead")]
        Calculate = 1,
        [Obsolete("Use ModelImporterNormals.None instead")]
        None = 2
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType(Header = "Modules/AssetPipelineEditor/Public/ModelImporting/ImportMesh.h")]
    public enum ModelImporterNormals
    {
        Import = 0,
        Calculate = 1,
        None = 2
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType(Header = "Modules/AssetPipelineEditor/Public/ModelImporting/ImportMesh.h")]
    public enum ModelImporterNormalCalculationMode
    {
        [InspectorName("Unweighted (Legacy)")]
        Unweighted_Legacy = 0,
        Unweighted = 1,
        AreaWeighted = 2,
        AngleWeighted = 3,
        AreaAndAngleWeighted = 4
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType(Header = "Modules/AssetPipelineEditor/Public/ModelImporting/ImportMesh.h")]
    public enum ModelImporterNormalSmoothingSource
    {
        PreferSmoothingGroups = 0,
        FromSmoothingGroups = 1,
        FromAngle = 2,
        None = 3
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType(Header = "Modules/AssetPipelineEditor/Public/ModelImporting/ImportMesh.h")]
    public enum ModelImporterTangents
    {
        Import = 0,
        CalculateLegacy = 1,
        CalculateLegacyWithSplitTangents = 4,
        [InspectorName("Calculate Mikktspace")]
        CalculateMikk = 3,
        None = 2
    }
}
namespace UnityEditor
{
    public enum ModelImporterMeshCompression
    {
        Off = 0,
        Low = 1,
        Medium = 2,
        High = 3
    }
}
using UnityEngine;

namespace UnityEditor
{
    public enum ModelImporterIndexFormat
    {
        Auto = 0,
        [InspectorName("16 bits")]
        UInt16 = 1,
        [InspectorName("32 bits")]
        UInt32 = 2
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType(Header = "Modules/AssetPipelineEditor/Public/ModelImporting/ModelImporter.h")]
    public enum ModelImporterAnimationCompression
    {
        Off = 0,
        KeyframeReduction = 1,
        KeyframeReductionAndCompression = 2,
        Optimal = 3
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType(Header = "Modules/AssetPipelineEditor/Public/ModelImporting/ModelImporter.h")]
    public enum ModelImporterGenerateAnimations
    {
        None = 0,
        GenerateAnimations = 4,
        InRoot = 3,
        InOriginalRoots = 1,
        InNodes = 2
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType(Header = "Modules/AssetPipelineEditor/Public/ModelImporting/ModelImporter.h")]
    public enum ModelImporterAnimationType
    {
        None = 0,
        Legacy = 1,
        Generic = 2,
        Human = 3
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType(Header = "Modules/AssetPipelineEditor/Public/ModelImporting/ModelImporter.h")]
    public enum ModelImporterHumanoidOversampling
    {
        X1 = 1,
        X2 = 2,
        X4 = 4,
        X8 = 8
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType(Header = "Modules/AssetPipelineEditor/Public/ModelImporting/ModelImporter.h")]
    public enum ModelImporterSecondaryUVMarginMethod
    {
        Manual = 0,
        Calculate = 1
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType(Header = "Modules/AssetPipelineEditor/Public/ModelImporting/ModelImporter.h")]
    public enum ModelImporterAvatarSetup
    {
        NoAvatar = 0,
        [Tooltip("Create an Avatar based on the model from this file.")]
        CreateFromThisModel = 1,
        [InspectorName("Copy From Other Avatar")]
        [Tooltip("Copy an Avatar from another file to import muscle clip. No avatar will be created.")]
        CopyFromOther = 2
    }
}
namespace UnityEditor
{
    public enum ModelImporterSkinWeights
    {
        Standard = 0,
        Custom = 1
    }
}
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor
{
    [UsedByNativeCode]
    [NativeType(Header = "Editor/Src/Animation/HumanTemplate.h")]
    public sealed class HumanTemplate : Object
    {
        public HumanTemplate();

        public void Insert(string name, string templateName);
        public string Find(string name);
        public void ClearTemplate();
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor
{
    [NativeType(Header = "Modules/AssetPipelineEditor/Public/ModelImporting/ModelImporter.h")]
    [UsedByNativeCode]
    public struct TakeInfo
    {
        public string name;
        public string defaultClipName;
        public float startTime;
        public float stopTime;
        public float bakeStartTime;
        public float bakeStopTime;
        public float sampleRate;
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Modules/Animation/ScriptBindings/AvatarBuilder.bindings.h")]
    [NativeHeader("Modules/AssetPipelineEditor/Public/ModelImporting/ModelImporter.bindings.h")]
    [NativeType(Header = "Modules/AssetPipelineEditor/Public/ModelImporting/ModelImporter.h")]
    public class ModelImporter : AssetImporter
    {
        public ModelImporter();

        [Obsolete("generateMaterials has been  removed. Use materialImportMode, materialName and materialSearch instead.", True)]
        public ModelImporterGenerateMaterials generateMaterials { get; }
        [Obsolete("importMaterials has been  removed. Use materialImportMode instead.", True)]
        public bool importMaterials { get; }
        public ModelImporterMaterialName materialName { get; set; }
        public ModelImporterMaterialSearch materialSearch { get; set; }
        public ModelImporterMaterialLocation materialLocation { get; set; }
        public float globalScale { get; set; }
        public bool isUseFileUnitsSupported { get; }
        public bool importVisibility { get; set; }
        public bool useFileUnits { get; set; }
        public float fileScale { get; }
        public bool useFileScale { get; set; }
        [Obsolete("Use useFileScale instead")]
        public bool isFileScaleUsed { get; }
        public bool importBlendShapes { get; set; }
        public bool importCameras { get; set; }
        public bool importLights { get; set; }
        public bool addCollider { get; set; }
        public float normalSmoothingAngle { get; set; }
        [Obsolete("Please use tangentImportMode instead")]
        public bool splitTangentsAcrossSeams { get; set; }
        public bool swapUVChannels { get; set; }
        public bool weldVertices { get; set; }
        public bool bakeAxisConversion { get; set; }
        public bool keepQuads { get; set; }
        public ModelImporterIndexFormat indexFormat { get; set; }
        public bool preserveHierarchy { get; set; }
        public bool generateSecondaryUV { get; set; }
        public float secondaryUVAngleDistortion { get; set; }
        public float secondaryUVAreaDistortion { get; set; }
        public float secondaryUVHardAngle { get; set; }
        public ModelImporterSecondaryUVMarginMethod secondaryUVMarginMethod { get; set; }
        public float secondaryUVPackMargin { get; set; }
        public float secondaryUVMinLightmapResolution { get; set; }
        public float secondaryUVMinObjectScale { get; set; }
        public ModelImporterGenerateAnimations generateAnimations { get; set; }
        public TakeInfo[] importedTakeInfos { get; }
        public string[] transformPaths { get; }
        public string[] referencedClips { get; }
        public bool isReadable { get; set; }
        public MeshOptimizationFlags meshOptimizationFlags { get; set; }
        public bool optimizeMeshPolygons { get; set; }
        public bool optimizeMeshVertices { get; set; }
        [Obsolete("optimizeMesh is deprecated. Use optimizeMeshPolygons and/or optimizeMeshVertices instead.  Note that optimizeMesh false equates to optimizeMeshPolygons true and optimizeMeshVertices false while optimizeMesh true equates to both true")]
        public bool optimizeMesh { get; set; }
        public ModelImporterSkinWeights skinWeights { get; set; }
        public int maxBonesPerVertex { get; set; }
        public float minBoneWeight { get; set; }
        [Obsolete("normalImportMode is deprecated. Use importNormals instead")]
        public ModelImporterTangentSpaceMode normalImportMode { get; set; }
        [Obsolete("tangentImportMode is deprecated. Use importTangents instead")]
        public ModelImporterTangentSpaceMode tangentImportMode { get; set; }
        public ModelImporterNormals importNormals { get; set; }
        public ModelImporterNormalSmoothingSource normalSmoothingSource { get; set; }
        public ModelImporterNormals importBlendShapeNormals { get; set; }
        public ModelImporterNormalCalculationMode normalCalculationMode { get; set; }
        public ModelImporterTangents importTangents { get; set; }
        public bool bakeIK { get; set; }
        public bool isBakeIKSupported { get; }
        [Obsolete("use resampleCurves instead.")]
        public bool resampleRotations { get; set; }
        public bool resampleCurves { get; set; }
        public bool isTangentImportSupported { get; }
        public ModelImporterMeshCompression meshCompression { get; set; }
        public bool importAnimation { get; set; }
        public bool optimizeGameObjects { get; set; }
        public string[] extraExposedTransformPaths { get; set; }
        public string[] extraUserProperties { get; set; }
        public ModelImporterAnimationCompression animationCompression { get; set; }
        public bool importAnimatedCustomProperties { get; set; }
        public bool importConstraints { get; set; }
        public float animationRotationError { get; set; }
        public float animationPositionError { get; set; }
        public float animationScaleError { get; set; }
        public WrapMode animationWrapMode { get; set; }
        public ModelImporterAnimationType animationType { get; set; }
        public ModelImporterHumanoidOversampling humanoidOversampling { get; set; }
        public string motionNodeName { get; set; }
        public ModelImporterAvatarSetup avatarSetup { get; set; }
        public Avatar sourceAvatar { get; set; }
        public HumanDescription humanDescription { get; set; }
        [Obsolete("splitAnimations has been deprecated please use clipAnimations instead.", True)]
        public bool splitAnimations { get; set; }
        public ModelImporterClipAnimation[] clipAnimations { get; set; }
        public ModelImporterClipAnimation[] defaultClipAnimations { get; }
        public bool useSRGBMaterialColor { get; set; }
        public bool sortHierarchyByName { get; set; }
        public ModelImporterMaterialImportMode materialImportMode { get; set; }
        public bool autoGenerateAvatarMappingIfUnspecified { get; set; }

        public void CreateDefaultMaskForClip(ModelImporterClipAnimation clip);
        public bool ExtractTextures(string folderPath);
        public bool SearchAndRemapMaterials(ModelImporterMaterialName nameOption, ModelImporterMaterialSearch searchOption);
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Modules/JSONSerializeEditor/EditorJsonUtility.bindings.h")]
    public static class EditorJsonUtility
    {
        public static string ToJson(object obj);
        public static string ToJson(object obj, bool prettyPrint);
        public static void FromJsonOverwrite(string json, object objectToOverwrite);
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEditor
{
    [AttributeUsage(Assembly)]
    [RequiredByNativeCode]
    public sealed class LocalizationAttribute : Attribute
    {
        public LocalizationAttribute(string locGroupName = null);
    }
}
using UnityEngine;
using UnityEngine.Internal;

namespace UnityEditor
{
    public static class L10n
    {
        public static string Tr(string str);
        public static string[] Tr(string[] str_list);
        public static string Tr(string str, string groupName);
        [ExcludeFromDocs]
        public static string TrPath(string path);
        [ExcludeFromDocs]
        public static GUIContent TextContent(string text, string tooltip = null, Texture icon = null);
        [ExcludeFromDocs]
        public static GUIContent TextContent(string text, string tooltip, string iconName);
        [ExcludeFromDocs]
        public static GUIContent TextContent(string text, Texture icon);
        [ExcludeFromDocs]
        public static GUIContent TextContentWithIcon(string text, Texture icon);
        [ExcludeFromDocs]
        public static GUIContent TextContentWithIcon(string text, string iconName);
        [ExcludeFromDocs]
        public static GUIContent TextContentWithIcon(string text, string tooltip, string iconName);
        [ExcludeFromDocs]
        public static GUIContent TextContentWithIcon(string text, string tooltip, Texture icon);
        [ExcludeFromDocs]
        public static GUIContent TextContentWithIcon(string text, string tooltip, MessageType messageType);
        [ExcludeFromDocs]
        public static GUIContent TextContentWithIcon(string text, MessageType messageType);
        [ExcludeFromDocs]
        public static GUIContent IconContent(string iconName, string tooltip = null);
        [ExcludeFromDocs]
        public static GUIContent IconContent(Texture icon, string tooltip = null);
        [ExcludeFromDocs]
        public static GUIContent TempContent(string t);
        [ExcludeFromDocs]
        public static GUIContent[] TempContent(string[] texts);
        [ExcludeFromDocs]
        public static GUIContent[] TempContent(string[] texts, string[] tooltips);
    }
}
using System;
using UnityEngine;

namespace UnityEditor
{
    public class LocalizationGroup : IDisposable
    {
        public LocalizationGroup();
        public LocalizationGroup(Behaviour behaviour);
        public LocalizationGroup(Type type);
        public LocalizationGroup(object obj);

        public string locGroupName { get; }

        public void Dispose();
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Runtime/Camera/Camera.h")]
    [NativeHeader("Modules/Physics/Collider.h")]
    [NativeHeader("PhysicsScriptingClasses.h")]
    [StaticAccessor("GetPhysicsVisualizationSettings()", Dot)]
    [NativeHeader("Modules/PhysicsEditor/PhysicsVisualizationSettings.h")]
    public static class PhysicsVisualizationSettings
    {
        public static bool devOptions { get; set; }
        public static int dirtyCount { get; }
        [Obsolete("Enum PhysicsVisualizationSettings.FilterWorkflow has been deprecated.", True)]
        public static FilterWorkflow filterWorkflow { get; set; }
        public static bool showCollisionGeometry { get; set; }
        public static bool enableMouseSelect { get; set; }
        public static bool useSceneCam { get; set; }
        public static float viewDistance { get; set; }
        public static int terrainTilesMax { get; set; }
        public static bool forceOverdraw { get; set; }
        public static Color staticColor { get; set; }
        public static Color rigidbodyColor { get; set; }
        public static Color kinematicColor { get; set; }
        public static Color articulationBodyColor { get; set; }
        public static Color triggerColor { get; set; }
        public static Color sleepingBodyColor { get; set; }
        public static float baseAlpha { get; set; }
        public static float colorVariance { get; set; }
        public static float dotAlpha { get; set; }
        public static bool forceDot { get; set; }

        public static void Reset();
        public static bool GetShowStaticColliders();
        public static void SetShowStaticColliders(bool show);
        public static bool GetShowTriggers();
        public static void SetShowTriggers(bool show);
        public static bool GetShowRigidbodies();
        public static void SetShowRigidbodies(bool show);
        public static bool GetShowKinematicBodies();
        public static void SetShowKinematicBodies(bool show);
        public static bool GetShowArticulationBodies();
        public static void SetShowArticulationBodies(bool show);
        public static bool GetShowSleepingBodies();
        public static void SetShowSleepingBodies(bool show);
        public static bool GetShowCollisionLayer(int layer);
        public static void SetShowCollisionLayer(int layer, bool show);
        public static int GetShowCollisionLayerMask();
        public static void SetShowCollisionLayerMask(int mask);
        public static bool GetShowBoxColliders();
        public static void SetShowBoxColliders(bool show);
        public static bool GetShowSphereColliders();
        public static void SetShowSphereColliders(bool show);
        public static bool GetShowCapsuleColliders();
        public static void SetShowCapsuleColliders(bool show);
        public static bool GetShowMeshColliders(MeshColliderType colliderType);
        public static void SetShowMeshColliders(MeshColliderType colliderType, bool show);
        public static bool GetShowTerrainColliders();
        public static void SetShowTerrainColliders(bool show);
        public static int GetShowPhysicsSceneMask();
        public static void SetShowPhysicsSceneMask(int mask);
        public static void InitDebugDraw();
        public static void DeinitDebugDraw();
        public static void ClearMouseHighlight();
        public static bool HasMouseHighlight();
        public static void UpdateMouseHighlight(Vector2 screenPos);
        public static GameObject PickClosestGameObject([NotNull("ArgumentNullException")] Camera cam, int layers, Vector2 position, GameObject[] ignore, GameObject[] filter, out int materialIndex);
        public static void SetShowForAllFilters(bool selected);
        [Obsolete("Enum PhysicsVisualizationSettings.FilterWorkflow has been deprecated. Use APIs without this argument instead", True)]
        public static bool GetShowStaticColliders(FilterWorkflow filterWorkFlow);
        [Obsolete("Enum PhysicsVisualizationSettings.FilterWorkflow has been deprecated. Use APIs without this argument instead", True)]
        public static void SetShowStaticColliders(FilterWorkflow filterWorkflow, bool show);
        [Obsolete("Enum PhysicsVisualizationSettings.FilterWorkflow has been deprecated. Use APIs without this argument instead", True)]
        public static bool GetShowTriggers(FilterWorkflow filterWorkflow);
        [Obsolete("Enum PhysicsVisualizationSettings.FilterWorkflow has been deprecated. Use APIs without this argument instead", True)]
        public static void SetShowTriggers(FilterWorkflow filterWorkflow, bool show);
        [Obsolete("Enum PhysicsVisualizationSettings.FilterWorkflow has been deprecated. Use APIs without this argument instead", True)]
        public static bool GetShowRigidbodies(FilterWorkflow filterWorkflow);
        [Obsolete("Enum PhysicsVisualizationSettings.FilterWorkflow has been deprecated. Use APIs without this argument instead", True)]
        public static void SetShowRigidbodies(FilterWorkflow filterWorkflow, bool show);
        [Obsolete("Enum PhysicsVisualizationSettings.FilterWorkflow has been deprecated. Use APIs without this argument instead", True)]
        public static bool GetShowKinematicBodies(FilterWorkflow filterWorkflow);
        [Obsolete("Enum PhysicsVisualizationSettings.FilterWorkflow has been deprecated. Use APIs without this argument instead", True)]
        public static void SetShowKinematicBodies(FilterWorkflow filterWorkflow, bool show);
        [Obsolete("Enum PhysicsVisualizationSettings.FilterWorkflow has been deprecated. Use APIs without this argument instead", True)]
        public static bool GetShowSleepingBodies(FilterWorkflow filterWorkflow);
        [Obsolete("Enum PhysicsVisualizationSettings.FilterWorkflow has been deprecated. Use APIs without this argument instead", True)]
        public static void SetShowSleepingBodies(FilterWorkflow filterWorkflow, bool show);
        [Obsolete("Enum PhysicsVisualizationSettings.FilterWorkflow has been deprecated. Use APIs without this argument instead", True)]
        public static bool GetShowCollisionLayer(FilterWorkflow filterWorkflow, int layer);
        [Obsolete("Enum PhysicsVisualizationSettings.FilterWorkflow has been deprecated. Use APIs without this argument instead", True)]
        public static void SetShowCollisionLayer(FilterWorkflow filterWorkflow, int layer, bool show);
        [Obsolete("Enum PhysicsVisualizationSettings.FilterWorkflow has been deprecated. Use APIs without this argument instead", True)]
        public static int GetShowCollisionLayerMask(FilterWorkflow filterWorkflow);
        [Obsolete("Enum PhysicsVisualizationSettings.FilterWorkflow has been deprecated. Use APIs without this argument instead", True)]
        public static void SetShowCollisionLayerMask(FilterWorkflow filterWorkflow, int mask);
        [Obsolete("Enum PhysicsVisualizationSettings.FilterWorkflow has been deprecated. Use APIs without this argument instead", True)]
        public static bool GetShowBoxColliders(FilterWorkflow filterWorkflow);
        [Obsolete("Enum PhysicsVisualizationSettings.FilterWorkflow has been deprecated. Use APIs without this argument instead", True)]
        public static void SetShowBoxColliders(FilterWorkflow filterWorkflow, bool show);
        [Obsolete("Enum PhysicsVisualizationSettings.FilterWorkflow has been deprecated. Use APIs without this argument instead", True)]
        public static bool GetShowSphereColliders(FilterWorkflow filterWorkflow);
        [Obsolete("Enum PhysicsVisualizationSettings.FilterWorkflow has been deprecated. Use APIs without this argument instead", True)]
        public static void SetShowSphereColliders(FilterWorkflow filterWorkflow, bool show);
        [Obsolete("Enum PhysicsVisualizationSettings.FilterWorkflow has been deprecated. Use APIs without this argument instead", True)]
        public static bool GetShowCapsuleColliders(FilterWorkflow filterWorkflow);
        [Obsolete("Enum PhysicsVisualizationSettings.FilterWorkflow has been deprecated. Use APIs without this argument instead", True)]
        public static void SetShowCapsuleColliders(FilterWorkflow filterWorkflow, bool show);
        [Obsolete("Enum PhysicsVisualizationSettings.FilterWorkflow has been deprecated. Use APIs without this argument instead", True)]
        public static bool GetShowMeshColliders(FilterWorkflow filterWorkflow, MeshColliderType colliderType);
        [Obsolete("Enum PhysicsVisualizationSettings.FilterWorkflow has been deprecated. Use APIs without this argument instead", True)]
        public static void SetShowMeshColliders(FilterWorkflow filterWorkflow, MeshColliderType colliderType, bool show);
        [Obsolete("Enum PhysicsVisualizationSettings.FilterWorkflow has been deprecated. Use APIs without this argument instead", True)]
        public static bool GetShowTerrainColliders(FilterWorkflow filterWorkflow);
        [Obsolete("Enum PhysicsVisualizationSettings.FilterWorkflow has been deprecated. Use APIs without this argument instead", True)]
        public static void SetShowTerrainColliders(FilterWorkflow filterWorkflow, bool show);
        [Obsolete("Enum PhysicsVisualizationSettings.FilterWorkflow has been deprecated. Use APIs without this argument instead", True)]
        public static int GetShowPhysicsSceneMask(FilterWorkflow filterWorkflow);
        [Obsolete("Enum PhysicsVisualizationSettings.FilterWorkflow has been deprecated. Use APIs without this argument instead", True)]
        public static void SetShowPhysicsSceneMask(FilterWorkflow filterWorkflow, int mask);
        [Obsolete("Enum PhysicsVisualizationSettings.FilterWorkflow has been deprecated. Use APIs without this argument instead", True)]
        public static void SetShowForAllFilters(FilterWorkflow filterWorkflow, bool selected);

        public enum FilterWorkflow
        {
            HideSelectedItems = 0,
            ShowSelectedItems = 1
        }
        public enum MeshColliderType
        {
            Convex = 0,
            NonConvex = 1
        }
    }
}
using System;

namespace UnityEditor
{
    [Obsolete("This profiler helper class is deprecated, it's here to support the high level API package until it no longer depends on it and will then be removed.")]
    public class NetworkDetailStats
    {
        public NetworkDetailStats();

        public static void NewProfilerTick(float newTime);
        public static void SetStat(NetworkDirection direction, short msgId, string entryName, int amount);
        public static void IncrementStat(NetworkDirection direction, short msgId, string entryName, int amount);
        public static void ResetAll();

        public enum NetworkDirection
        {
            Incoming = 0,
            Outgoing = 1
        }
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType("Modules/SketchUpEditor/SketchUpImporter.h")]
    public struct SketchUpImportCamera
    {
        public Vector3 position;
        public Vector3 lookAt;
        public Vector3 up;
        public float fieldOfView;
        public float aspectRatio;
        public float orthoSize;
        public float nearPlane;
        public float farPlane;
        public bool isPerspective;
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeType("Modules/SketchUpEditor/SketchUpImporter.h")]
    public struct SketchUpImportScene
    {
        public SketchUpImportCamera camera;
        public string name;
    }
}
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Modules/SketchUpEditor/SketchUpImporter.h")]
    public sealed class SketchUpImporter : ModelImporter
    {
        public SketchUpImporter();

        public double latitude { get; }
        public double longitude { get; }
        public double northCorrection { get; }

        public SketchUpImportScene[] GetScenes();
        public SketchUpImportCamera GetDefaultCamera();
    }
}
using UnityEngine;

namespace UnityEditor
{
    [CustomEditor(typeof(TerrainLayer))]
    [CanEditMultipleObjects]
    public sealed class TerrainLayerInspector : Editor
    {
        public TerrainLayerInspector();

        public void ApplyCustomUI(ITerrainLayerCustomUI customUI, Terrain terrain);
        public override void OnInspectorGUI();
        public override bool HasPreviewGUI();
        public override void OnPreviewGUI(Rect r, GUIStyle background);
        public override Texture2D RenderStaticPreview(string assetPath, Object[] subAssets, int width, int height);
    }
}
using UnityEngine;

namespace UnityEditor
{
    public interface ITerrainLayerCustomUI
    {
        bool OnTerrainLayerGUI(TerrainLayer terrainLayer, Terrain terrain);
    }
}
using UnityEngine;

namespace UnityEditor
{
    public static class TerrainLayerUtility
    {
        public static int ShowTerrainLayersSelectionHelper(Terrain terrain, int activeTerrainLayer);
        public static void ShowTerrainLayerGUI(Terrain terrain, TerrainLayer terrainLayer, ref Editor terrainLayerEditor, ITerrainLayerCustomUI customGUI);
        public static void ValidateDiffuseTextureUI(Texture2D texture);
        public static bool CheckNormalMapTextureType(Texture2D texture);
        public static void ValidateNormalMapTextureUI(Texture2D texture, bool normalMapTextureType);
        public static void ValidateMaskMapTextureUI(Texture2D texture);
        public static void TilingSettingsUI(TerrainLayer terrainLayer);
        public static void TilingSettingsUI(SerializedProperty tileSize, SerializedProperty tileOffset);
    }
}
using UnityEngine;

namespace UnityEditor
{
    public enum FontTextureCase
    {
        Dynamic = -2,
        Unicode = -1,
        [InspectorName("ASCII default set")]
        ASCII = 0,
        ASCIIUpperCase = 1,
        ASCIILowerCase = 2,
        CustomSet = 3
    }
}
namespace UnityEditor
{
    public enum FontRenderingMode
    {
        Smooth = 0,
        HintedSmooth = 1,
        HintedRaster = 2,
        OSDefault = 3
    }
}
using UnityEngine;

namespace UnityEditor
{
    public enum AscentCalculationMode
    {
        [InspectorName("Legacy version 2 mode (glyph bounding boxes)")]
        Legacy2x = 0,
        [InspectorName("Face ascender metric")]
        FaceAscender = 1,
        [InspectorName("Face bounding box metric")]
        FaceBoundingBox = 2
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor
{
    [NativeHeader("Modules/TextRenderingEditor/TrueTypeFontImporter.h")]
    public sealed class TrueTypeFontImporter : AssetImporter
    {
        public TrueTypeFontImporter();

        public int fontSize { get; set; }
        public bool includeFontData { get; set; }
        public AscentCalculationMode ascentCalculationMode { get; set; }
        public string customCharacters { get; set; }
        public int characterSpacing { get; set; }
        public int characterPadding { get; set; }
        public FontRenderingMode fontRenderingMode { get; set; }
        public bool shouldRoundAdvanceValue { get; set; }
        [NativeProperty("FontNameFromTTFData", False, Function)]
        public string fontTTFName { get; }
        [NativeProperty("ForceTextureCase", False, Function)]
        public FontTextureCase fontTextureCase { get; set; }
        [NativeProperty("MarshalledFontReferences", False, Function)]
        public Font[] fontReferences { get; set; }
        [NativeProperty("MarshalledFontNames", False, Function)]
        public string[] fontNames { get; set; }

        public Font GenerateEditableFont(string path);
    }
}
using UnityEngine;

namespace UnityEditor
{
    public class GridPalette : ScriptableObject
    {
        [SerializeField]
        public CellSizing cellSizing;

        public GridPalette();

        public TransparencySortMode transparencySortMode { get; set; }
        public Vector3 transparencySortAxis { get; set; }

        public enum CellSizing
        {
            Automatic = 0,
            Manual = 100
        }
    }
}
using UnityEngine.Analytics;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor
{
    [RequiredByNativeCode]
    [NativeHeader("Modules/UnityEditorAnalyticsEditor/UnityEditorAnalytics.h")]
    [NativeHeader("Modules/UnityEditorAnalyticsEditor/UnityEditorAnalyticsManager.h")]
    [NativeHeader("Modules/UnityAnalytics/ContinuousEvent/Manager.h")]
    public static class EditorAnalytics
    {
        public static bool enabled { get; }

        public static AnalyticsResult RegisterEventWithLimit(string eventName, int maxEventPerHour, int maxItems, string vendorKey);
        public static AnalyticsResult RegisterEventWithLimit(string eventName, int maxEventPerHour, int maxItems, string vendorKey, int ver);
        public static AnalyticsResult SendEventWithLimit(string eventName, object parameters);
        public static AnalyticsResult SendEventWithLimit(string eventName, object parameters, int ver);
        public static AnalyticsResult SetEventWithLimitEndPoint(string eventName, string endPoint, int ver);
        public static AnalyticsResult SetEventWithLimitPriority(string eventName, AnalyticsEventPriority eventPriority, int ver);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor
{
    [NativeHeader("Modules/UnityEditorAnalyticsEditor/UnityEditorAnalytics.h")]
    [RequiredByNativeCode]
    public static class EditorAnalyticsSessionInfo
    {
        public static long id { get; }
        public static long sessionCount { get; }
        public static long elapsedTime { get; }
        public static long focusedElapsedTime { get; }
        public static long playbackElapsedTime { get; }
        public static long activeElapsedTime { get; }
        public static string userId { get; }
    }
}
using UnityEngine.Bindings;
using UnityEngine.Internal;

namespace UnityEditor.XR
{
    [NativeType(Header = "Modules/XREditor/Boot/XRBoot.h")]
    [ExcludeFromDocs]
    public class BootOptions
    {
        public BootOptions();

        [ExcludeFromDocs]
        public static void SetXRSDKPreInitLibrary(string bootConfigPath, string libraryName);
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.MPE
{
    [NativeHeader("Modules/UMPE/ChannelService.h")]
    [StaticAccessor("Unity::MPE::ChannelClient", DoubleColon)]
    [MovedFrom("Unity.MPE")]
    public class ChannelClient
    {
        public int clientId { get; }
        public string channelName { get; }
        public bool isAutoTick { get; }

        public bool IsConnected();
        public void Start(bool autoTick);
        public void Stop();
        public void Close();
        public void Tick();
        public void Send(string data);
        public void Send(byte[] data);
        public Action RegisterMessageHandler(Action<string> handler);
        public void UnregisterMessageHandler(Action<string> handler);
        public Action RegisterMessageHandler(Action<byte[]> handler);
        public void UnregisterMessageHandler(Action<byte[]> handler);
        public int NewRequestId();
        public ChannelClientInfo GetChannelClientInfo();
        public static void Send(int connectionId, byte[] data);
        public static void Close(string channelName);
        public static ChannelClient GetOrCreateClient(string channelName);
        public static void Shutdown();
        public static ChannelClientInfo GetChannelClientInfo(string channelName);
        public static int NewRequestId(int clientId);
        public static ChannelClientInfo GetChannelClientInfo(int clientId);
        public static ChannelClientInfo[] GetChannelClientList();
    }
}
using System;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.MPE
{
    [MovedFrom("Unity.MPE")]
    public struct ChannelClientScope : IDisposable
    {
        public ChannelClientScope(bool autoTick, string channelName, Action<string> handler, bool closeClientOnExit = True);
        public ChannelClientScope(bool autoTick, string channelName, Action<byte[]> handler, bool closeClientOnExit = True);

        public ChannelClient client { get; }

        public void Dispose();
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.MPE
{
    [NativeHeader("Modules/UMPE/ChannelService.h")]
    [MovedFrom("Unity.MPE")]
    [StaticAccessor("Unity::MPE::ChannelService", DoubleColon)]
    public static class ChannelService
    {
        public static Action GetOrCreateChannel(string channelName, Action<int, byte[]> handler);
        public static Action RegisterMessageHandler(string channelName, Action<int, byte[]> handler);
        public static void UnregisterMessageHandler(string channelName, Action<int, byte[]> handler);
        public static void CloseChannel(string channelName);
        public static void Broadcast(int channelId, byte[] data);
        public static void Send(int connectionId, byte[] data);
        public static string GetAddress();
        public static int GetPort();
        public static void Start();
        public static void Stop();
        public static bool IsRunning();
        public static ChannelInfo[] GetChannelList();
        public static ChannelClientInfo[] GetChannelClientList();
        public static void Broadcast(int channelId, string data);
        public static void BroadcastBinary(int channelId, byte[] data);
        public static void Send(int connectionId, string data);
        public static int ChannelNameToId(string channelName);
    }
}
using System;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.MPE
{
    [MovedFrom("Unity.MPE")]
    public struct ChannelScope : IDisposable
    {
        public ChannelScope(string channelName, Action<int, byte[]> handler, bool closeChannelOnExit = True);

        public void Dispose();
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.MPE
{
    [MovedFrom("Unity.MPE")]
    public enum EventDataSerialization
    {
        StandardJson = 0,
        JsonUtility = 1
    }
}
using System;
using UnityEngine;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.MPE
{
    [MovedFrom("Unity.MPE")]
    public static class EventService
    {
        public static bool isConnected { get; }

        public static void Start();
        public static void Close();
        public static Action RegisterEventHandler(string eventType, Action<string, object[]> handler);
        public static Action RegisterEventHandler(string eventType, Func<string, object[], object> handler);
        public static void UnregisterEventHandler(string eventType, Func<string, object[], object> handler);
        public static void Clear();
        public static void Emit(string eventType, object args = null, int targetId = -1, EventDataSerialization eventDataSerialization = JsonUtility);
        public static void Emit(string eventType, object[] args, int targetId = -1, EventDataSerialization eventDataSerialization = JsonUtility);
        public static bool IsRequestPending(string eventType);
        public static bool CancelRequest(string eventType, string message = null);
        public static void Request(string eventType, Action<Exception, object[]> promiseHandler, object args = null, long timeoutInMs = 700, EventDataSerialization eventDataSerialization = JsonUtility);
        public static void Request(string eventType, Action<Exception, object[]> promiseHandler, object[] args, long timeoutInMs = 700, EventDataSerialization eventDataSerialization = JsonUtility);
        public static void Log(string msg);
        public static void Log(string msg, LogType logType);
        public static void Tick();
    }
}
using System;
using UnityEngine.Scripting;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.MPE
{
    [RequiredByNativeCode]
    [MovedFrom("Unity.MPE")]
    [AttributeUsage(Method, AllowMultiple = True)]
    public sealed class RoleProviderAttribute : Attribute
    {
        public string name;
        public ProcessEvent eventType;
        public ProcessLevel level;

        public RoleProviderAttribute(string name, ProcessEvent eventType);
        public RoleProviderAttribute(ProcessLevel level, ProcessEvent eventType);
    }
}
using System;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.MPE
{
    [MovedFrom("Unity.MPE")]
    public enum ProcessEvent
    {
        [Obsolete("... (UnityUpgradable) -> Undefined")]
        UMP_EVENT_UNDEFINED = 0,
        Undefined = 0,
        [Obsolete("... (UnityUpgradable) -> Create")]
        UMP_EVENT_CREATE = 1,
        Create = 1,
        [Obsolete("... (UnityUpgradable) -> Initialize")]
        UMP_EVENT_INITIALIZE = 2,
        Initialize = 2,
        [Obsolete("... (UnityUpgradable) -> AfterDomainReload")]
        UMP_EVENT_AFTER_DOMAIN_RELOAD = 3,
        AfterDomainReload = 3,
        [Obsolete("... (UnityUpgradable) -> Shutdown")]
        UMP_EVENT_SHUTDOWN = 4,
        Shutdown = 4
    }
}
using System;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.MPE
{
    [MovedFrom("Unity.MPE")]
    public enum ProcessLevel
    {
        [Obsolete("... (UnityUpgradable) -> Undefined")]
        UMP_UNDEFINED = 0,
        Undefined = 0,
        [Obsolete("... (UnityUpgradable) -> Master")]
        UMP_MASTER = 1,
        Master = 1,
        [Obsolete("... (UnityUpgradable) -> Slave")]
        UMP_SLAVE = 2,
        Slave = 2
    }
}
using System;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.MPE
{
    [MovedFrom("Unity.MPE")]
    public enum ProcessState
    {
        [Obsolete("... (UnityUpgradable) -> UnknownProcess")]
        UMP_UNKNOWN_PROCESS = 0,
        UnknownProcess = 0,
        [Obsolete("... (UnityUpgradable) -> FinishedSuccessfully")]
        UMP_FINISHED_SUCCESSFULLY = 1,
        FinishedSuccessfully = 1,
        [Obsolete("... (UnityUpgradable) -> FinishedWithError")]
        UMP_FINISHED_WITH_ERROR = 2,
        FinishedWithError = 2,
        [Obsolete("... (UnityUpgradable) -> Running")]
        UMP_RUNNING = 3,
        Running = 3
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.MPE
{
    [MovedFrom("Unity.MPE")]
    [NativeType("Modules/UMPE/ChannelService.h")]
    public struct ChannelInfo : IEquatable<ChannelInfo>
    {
        public static ChannelInfo invalidChannel;

        public string name { get; }
        public int id { get; }

        public bool Equals(ChannelInfo obj);
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static bool operator ==(ChannelInfo x, ChannelInfo y);
        public static bool operator !=(ChannelInfo x, ChannelInfo y);
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.MPE
{
    [MovedFrom("Unity.MPE")]
    [NativeType("Modules/UMPE/ChannelService.h")]
    public struct ChannelClientInfo : IEquatable<ChannelClientInfo>
    {
        public static ChannelClientInfo invalidClient;

        public string name { get; }
        public int clientId { get; }
        public int connectionId { get; }

        public bool Equals(ChannelClientInfo obj);
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static bool operator ==(ChannelClientInfo x, ChannelClientInfo y);
        public static bool operator !=(ChannelClientInfo x, ChannelClientInfo y);
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.MPE
{
    [MovedFrom("Unity.MPE")]
    [NativeHeader("Modules/UMPE/ProcessService.h")]
    [StaticAccessor("Unity::MPE::ProcessService", DoubleColon)]
    public class ProcessService
    {
        public ProcessService();

        public static ProcessLevel level { get; }
        public static string roleName { get; }

        public static event Action<int, ProcessState> SlaveProcessExitedEvent;

        public static bool IsChannelServiceStarted();
        public static string ReadParameter(string paramName);
        public static int LaunchSlave(string roleName, params string[] keyValuePairs);
        public static void TerminateSlave(int pid);
        public static ProcessState GetSlaveProcessState(int pid);
        public static bool HasCapability(string capName);
        public static void ApplyPropertyModifications(PropertyModification[] modifications);
        public static byte[] SerializeObject(int instanceId);
        public static UnityEngine.Object DeserializeObject(byte[] bytes);
        public static int EnableProfileConnection(string dataPath);
        public static void DisableProfileConnection();
    }
}
using System;
using UnityEngine;

namespace UnityEditor.ShortcutManagement
{
    public struct KeyCombination : IEquatable<KeyCombination>
    {
        public KeyCombination(KeyCode keyCode, ShortcutModifiers shortcutModifiers = None);

        public KeyCode keyCode { get; }
        public ShortcutModifiers modifiers { get; }
        public bool alt { get; }
        public bool action { get; }
        public bool shift { get; }

        public override string ToString();
        public bool Equals(KeyCombination other);
        public override bool Equals(object obj);
        public override int GetHashCode();
    }
}
using System;

namespace UnityEditor.ShortcutManagement
{
    public abstract class ShortcutBaseAttribute : Attribute
    {
        protected ShortcutBaseAttribute();
    }
}
using System;
using System.ComponentModel;
using UnityEngine;

namespace UnityEditor.ShortcutManagement
{
    [AttributeUsage(Method, AllowMultiple = True)]
    public class ShortcutAttribute : ShortcutBaseAttribute
    {
        public ShortcutAttribute(string id, [DefaultValue("null")] Type context = null);
        public ShortcutAttribute(string id, Type context, KeyCode defaultKeyCode, [DefaultValue("None")] ShortcutModifiers defaultShortcutModifiers = None);
        public ShortcutAttribute(string id, KeyCode defaultKeyCode, [DefaultValue("None")] ShortcutModifiers defaultShortcutModifiers = None);

        public string displayName { get; set; }
    }
}
using System;
using System.ComponentModel;
using UnityEngine;

namespace UnityEditor.ShortcutManagement
{
    [AttributeUsage(Method)]
    public class ClutchShortcutAttribute : ShortcutAttribute
    {
        public ClutchShortcutAttribute(string id, [DefaultValue("null")] Type context = null);
        public ClutchShortcutAttribute(string id, Type context, KeyCode defaultKeyCode, [DefaultValue("None")] ShortcutModifiers defaultShortcutModifiers = None);
        public ClutchShortcutAttribute(string id, KeyCode defaultKeyCode, [DefaultValue("None")] ShortcutModifiers defaultShortcutModifiers = None);
    }
}
using System;
using System.Collections.Generic;

namespace UnityEditor.ShortcutManagement
{
    public struct ShortcutBinding : IEquatable<ShortcutBinding>
    {
        public ShortcutBinding(KeyCombination keyCombination);

        public static ShortcutBinding empty { get; }
        public IEnumerable<KeyCombination> keyCombinationSequence { get; }

        public override string ToString();
        public bool Equals(ShortcutBinding other);
        public override bool Equals(object obj);
        public override int GetHashCode();
    }
}
namespace UnityEditor.ShortcutManagement
{
    public enum ShortcutStage
    {
        Begin = 0,
        End = 1
    }
}
namespace UnityEditor.ShortcutManagement
{
    public struct ShortcutArguments
    {
        public object context;
        public ShortcutStage stage;
    }
}
using System;

namespace UnityEditor.ShortcutManagement
{
    [Flags]
    public enum ShortcutModifiers
    {
        None = 0,
        Alt = 1,
        Action = 2,
        Shift = 4
    }
}
using System;
using System.Collections.Generic;

namespace UnityEditor.ShortcutManagement
{
    public interface IShortcutManager
    {
        string activeProfileId { get; set; }

        event Action<ActiveProfileChangedEventArgs> activeProfileChanged;
        event Action<ShortcutBindingChangedEventArgs> shortcutBindingChanged;

        IEnumerable<string> GetAvailableProfileIds();
        bool IsProfileIdValid(string profileId);
        bool IsProfileReadOnly(string profileId);
        void CreateProfile(string profileId);
        void DeleteProfile(string profileId);
        void RenameProfile(string profileId, string newProfileId);
        IEnumerable<string> GetAvailableShortcutIds();
        ShortcutBinding GetShortcutBinding(string shortcutId);
        void RebindShortcut(string shortcutId, ShortcutBinding binding);
        void ClearShortcutOverride(string shortcutId);
        bool IsShortcutOverridden(string shortcutId);
    }
}
namespace UnityEditor.ShortcutManagement
{
    public struct ActiveProfileChangedEventArgs
    {
        public ActiveProfileChangedEventArgs(string previousActiveProfileId, string currentActiveProfileId);

        public string previousActiveProfileId { get; }
        public string currentActiveProfileId { get; }
    }
}
namespace UnityEditor.ShortcutManagement
{
    public struct ShortcutBindingChangedEventArgs
    {
        public ShortcutBindingChangedEventArgs(string shortcutId, ShortcutBinding oldBinding, ShortcutBinding newBinding);

        public string shortcutId { get; }
        public ShortcutBinding oldBinding { get; }
        public ShortcutBinding newBinding { get; }
    }
}
namespace UnityEditor.ShortcutManagement
{
    public static class ShortcutManager
    {
        public const string defaultProfileId = "Default";

        public static IShortcutManager instance { get; }
    }
}
using System;

namespace UnityEditor.MemoryProfiler
{
    public static class MemorySnapshot
    {
        public static event Action<PackedMemorySnapshot> OnSnapshotReceived;

        public static void RequestNewSnapshot();
    }
}
using UnityEditor.Profiling.Memory.Experimental;

namespace UnityEditor.MemoryProfiler
{
    public class PackedMemorySnapshot
    {
        public PackedMemorySnapshot(UnityEditor.Profiling.Memory.Experimental.PackedMemorySnapshot snapshot);

        public PackedNativeType[] nativeTypes { get; }
        public PackedNativeUnityEngineObject[] nativeObjects { get; }
        public PackedGCHandle[] gcHandles { get; }
        public Connection[] connections { get; }
        public MemorySection[] managedHeapSections { get; }
        public TypeDescription[] typeDescriptions { get; }
        public VirtualMachineInformation virtualMachineInformation { get; }
    }
}
using System;

namespace UnityEditor.MemoryProfiler
{
    public struct PackedNativeType
    {
        public PackedNativeType(string name, int nativeBaseTypeArrayIndex);

        public string name { get; }
        [Obsolete("PackedNativeType.baseClassId is obsolete. Use PackedNativeType.nativeBaseTypeArrayIndex instead (UnityUpgradable) -> nativeBaseTypeArrayIndex")]
        public int baseClassId { get; }
        public int nativeBaseTypeArrayIndex { get; }
    }
}
using System;
using UnityEngine;

namespace UnityEditor.MemoryProfiler
{
    public struct PackedNativeUnityEngineObject
    {
        public PackedNativeUnityEngineObject(string name, int instanceId, int size, int nativeTypeArrayIndex, HideFlags hideFlags, ObjectFlags flags, long nativeObjectAddress);

        public bool isPersistent { get; }
        public bool isDontDestroyOnLoad { get; }
        public bool isManager { get; }
        public string name { get; }
        public int instanceId { get; }
        public int size { get; }
        [Obsolete("PackedNativeUnityEngineObject.classId is obsolete. Use PackedNativeUnityEngineObject.nativeTypeArrayIndex instead (UnityUpgradable) -> nativeTypeArrayIndex")]
        public int classId { get; }
        public int nativeTypeArrayIndex { get; }
        public HideFlags hideFlags { get; }
        public long nativeObjectAddress { get; }

        public enum ObjectFlags
        {
            IsDontDestroyOnLoad = 1,
            IsPersistent = 2,
            IsManager = 4
        }
    }
}
namespace UnityEditor.MemoryProfiler
{
    public struct PackedGCHandle
    {
        public PackedGCHandle(ulong target);

        public ulong target { get; }
    }
}
namespace UnityEditor.MemoryProfiler
{
    public struct Connection
    {
        public Connection(int from, int to);

        public int from { get; set; }
        public int to { get; set; }
    }
}
namespace UnityEditor.MemoryProfiler
{
    public struct MemorySection
    {
        public MemorySection(byte[] bytes, ulong startAddress);

        public byte[] bytes { get; }
        public ulong startAddress { get; }
    }
}
namespace UnityEditor.MemoryProfiler
{
    public struct TypeDescription
    {
        public TypeDescription(string name, string assembly, FieldDescription[] fields, byte[] staticFieldBytes, int baseOrElementTypeIndes, int size, ulong typeInfoAddress, int typeIndex, TypeFlags flags);

        public bool isValueType { get; }
        public bool isArray { get; }
        public int arrayRank { get; }
        public string name { get; }
        public string assembly { get; }
        public FieldDescription[] fields { get; }
        public byte[] staticFieldBytes { get; }
        public int baseOrElementTypeIndex { get; }
        public int size { get; }
        public ulong typeInfoAddress { get; }
        public int typeIndex { get; }

        public enum TypeFlags
        {
            kNone = 0,
            kValueType = 1,
            kArray = 2,
            kArrayRankMask = -65536
        }
    }
}
namespace UnityEditor.MemoryProfiler
{
    public struct FieldDescription
    {
        public FieldDescription(string name, int offset, int typeIndex, bool isStatic);

        public string name { get; }
        public int offset { get; }
        public int typeIndex { get; }
        public bool isStatic { get; }
    }
}
namespace UnityEditor.MemoryProfiler
{
    public struct VirtualMachineInformation
    {
        public int pointerSize { get; }
        public int objectHeaderSize { get; }
        public int arrayHeaderSize { get; }
        public int arrayBoundsOffsetInHeader { get; }
        public int arraySizeOffsetInHeader { get; }
        public int allocationGranularity { get; }
        public int heapFormatVersion { get; }
    }
}
using UnityEngine;

namespace UnityEditor.Presets
{
    public abstract class PresetSelectorReceiver : ScriptableObject
    {
        protected PresetSelectorReceiver();

        public virtual void OnSelectionChanged(Preset selection);
        public virtual void OnSelectionClosed(Preset selection);
    }
}
namespace UnityEditor.Presets
{
    public class DefaultPresetSelectorReceiver : PresetSelectorReceiver
    {
        public DefaultPresetSelectorReceiver();

        public override void OnSelectionChanged(Preset selection);
        public override void OnSelectionClosed(Preset selection);
    }
}
using UnityEngine;

namespace UnityEditor.Presets
{
    public class PresetSelector : EditorWindow
    {
        public PresetSelector();

        [EditorHeaderItem(typeof(Object), -1001)]
        public static bool DrawPresetButton(Rect rectangle, Object[] targets);
        public static void ShowSelector(Object[] targets, Preset currentSelection, bool createNewAllowed);
        public static void ShowSelector(Object target, Preset currentSelection, bool createNewAllowed, PresetSelectorReceiver eventReceiver);
        public static void ShowSelector(PresetType presetType, Preset currentSelection, bool createNewAllowed, PresetSelectorReceiver eventReceiver);
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.Presets
{
    [UsedByNativeCode]
    [NativeHeader("Modules/PresetsEditor/Public/PresetManager.h")]
    [ExcludeFromPreset]
    [NativeType(Header = "Modules/PresetsEditor/Public/Preset.h")]
    public sealed class Preset : UnityEngine.Object
    {
        public Preset(UnityEngine.Object source);

        public PropertyModification[] PropertyModifications { get; }
        public string[] excludedProperties { get; set; }

        public bool ApplyTo(UnityEngine.Object target);
        public bool ApplyTo([NotNull("ArgumentNullException")] UnityEngine.Object target, string[] selectedPropertyPaths);
        public bool DataEquals([NotNull("ArgumentNullException")] UnityEngine.Object target);
        public bool UpdateProperties([NotNull("ArgumentNullException")] UnityEngine.Object source);
        public PresetType GetPresetType();
        public string GetTargetFullTypeName();
        public string GetTargetTypeName();
        public bool IsValid();
        public bool CanBeAppliedTo(UnityEngine.Object target);
        [FreeFunction("GetDefaultPresetsForObject")]
        public static Preset[] GetDefaultPresetsForObject([NotNull("ArgumentNullException")] UnityEngine.Object target);
        [Obsolete("Use GetDefaultPresetsForObject to get the full ordered list of default Presets that would be applied to that Object")]
        public static Preset GetDefaultForObject(UnityEngine.Object target);
        [Obsolete("Use GetDefaultPresetsForType to get the full list of default Presets for a given PresetType.")]
        public static Preset GetDefaultForPreset(Preset preset);
        [FreeFunction("GetAllDefaultTypes")]
        public static PresetType[] GetAllDefaultTypes();
        [FreeFunction("GetDefaultPresetsForType")]
        public static DefaultPreset[] GetDefaultPresetsForType(PresetType type);
        [FreeFunction("SetDefaultPresetsForType")]
        public static bool SetDefaultPresetsForType(PresetType type, DefaultPreset[] presets);
        [Obsolete("Use SetDefaultPresetsForType instead.")]
        public static bool SetAsDefault(Preset preset);
        public static void RemoveFromDefault(Preset preset);
        [Obsolete("Use PresetType.IsValidDefault instead.")]
        public static bool IsPresetExcludedFromDefaultPresets(Preset preset);
        [Obsolete("Use PresetType.IsValidDefault instead.")]
        public static bool IsObjectExcludedFromDefaultPresets(UnityEngine.Object target);
        [Obsolete("Use PresetType.IsValid instead.")]
        public static bool IsObjectExcludedFromPresets(UnityEngine.Object target);
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor.Presets
{
    [NativeType(Header = "Modules/PresetsEditor/Public/PresetManager.h")]
    public struct DefaultPreset
    {
        [SerializeField]
        [Obsolete("Use the new getter/setter instead. (UnityUpgradable) -> filter")]
        public string m_Filter;
        [SerializeField]
        [Obsolete("Use the new getter/setter instead. (UnityUpgradable) -> preset")]
        public Preset m_Preset;

        public DefaultPreset(string filter, Preset preset);
        public DefaultPreset(string filter, Preset preset, bool enabled);

        public string filter { get; set; }
        public Preset preset { get; set; }
        public bool enabled { get; set; }
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor.Presets
{
    [NativeType(Header = "Modules/PresetsEditor/Public/PresetType.h")]
    public struct PresetType : IEquatable<PresetType>
    {
        public PresetType(UnityEngine.Object o);

        public override bool Equals(object obj);
        public override int GetHashCode();
        public bool IsValid();
        public bool IsValidDefault();
        public string GetManagedTypeName();
        public bool Equals(PresetType other);

        public static bool operator ==(PresetType a, PresetType b);
        public static bool operator !=(PresetType a, PresetType b);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.PackageManager
{
    [NativeAsStruct]
    [RequiredByNativeCode]
    public class AuthorInfo
    {
        public string name { get; }
        public string email { get; }
        public string url { get; }
    }
}
namespace UnityEditor.PackageManager
{
    public static class BuildUtilities
    {
        public static void RegisterShouldIncludeInBuildCallback(IShouldIncludeInBuildCallback cb);
    }
}
using UnityEditor.PackageManager.Requests;
using UnityEngine.Bindings;

namespace UnityEditor.PackageManager
{
    [NativeHeader("Modules/PackageManager/Editor/Public/PackageManager.h")]
    public static class Client
    {
        [StaticAccessor("PackageManager", DoubleColon)]
        [NativeHeader("Modules/PackageManager/Editor/PackageManagerLogger.h")]
        public static LogLevel LogLevel { get; set; }

        public static ListRequest List(bool offlineMode, bool includeIndirectDependencies);
        public static ListRequest List(bool offlineMode);
        public static ListRequest List();
        public static AddRequest Add(string identifier);
        public static EmbedRequest Embed(string packageName);
        public static RemoveRequest Remove(string packageName);
        public static SearchRequest Search(string packageIdOrName, bool offlineMode);
        public static SearchRequest Search(string packageIdOrName);
        public static SearchRequest SearchAll(bool offlineMode);
        public static SearchRequest SearchAll();
        public static ResetToEditorDefaultsRequest ResetToEditorDefaults();
        public static PackRequest Pack(string packageFolder, string targetFolder);
        public static void Resolve();
    }
}
namespace UnityEditor.PackageManager
{
    public struct DependencyInfo
    {
        public string version { get; }
        public string name { get; }
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.PackageManager
{
    [NativeAsStruct]
    [RequiredByNativeCode]
    public class Error
    {
        public ErrorCode errorCode { get; }
        public string message { get; }
    }
}
namespace UnityEditor.PackageManager
{
    public enum ErrorCode
    {
        Unknown = 0,
        NotFound = 1,
        Forbidden = 2,
        InvalidParameter = 3,
        Conflict = 4
    }
}
using System;

namespace UnityEditor.PackageManager
{
    public static class Events
    {
        public static event Action<PackageRegistrationEventArgs> registeringPackages;
        public static event Action<PackageRegistrationEventArgs> registeredPackages;
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.PackageManager
{
    [RequiredByNativeCode]
    [NativeAsStruct]
    public class GitInfo
    {
        public string hash { get; }
        public string revision { get; }
    }
}
namespace UnityEditor.PackageManager
{
    public interface IShouldIncludeInBuildCallback
    {
        string PackageName { get; }

        bool ShouldIncludeInBuild(string path);
    }
}
namespace UnityEditor.PackageManager
{
    public enum LogLevel
    {
        Error = 0,
        Warn = 1,
        Info = 2,
        Verbose = 3,
        Debug = 4,
        Silly = 5
    }
}
using System.Collections;
using System.Collections.Generic;

namespace UnityEditor.PackageManager
{
    public class PackageCollection : IEnumerable, IEnumerable<PackageInfo>
    {
        public Error error { get; }
    }
}
using System;
using System.Reflection;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.PackageManager
{
    [RequiredByNativeCode]
    [NativeAsStruct]
    [NativeType(IntermediateScriptingStructName = "PackageManager_PackageInfo")]
    [NativeHeader("Modules/PackageManager/Editor/Public/PackageManager.h")]
    [StaticAccessor("PackageManager", DoubleColon)]
    public sealed class PackageInfo
    {
        public string packageId { get; }
        public bool isDirectDependency { get; }
        public string version { get; }
        public PackageSource source { get; }
        public string resolvedPath { get; }
        public string assetPath { get; }
        public string name { get; }
        public string displayName { get; }
        public string category { get; }
        public string type { get; }
        public string description { get; }
        public PackageStatus status { get; }
        public Error[] errors { get; }
        public VersionsInfo versions { get; }
        public DependencyInfo[] dependencies { get; }
        public DependencyInfo[] resolvedDependencies { get; }
        public string[] keywords { get; }
        public AuthorInfo author { get; }
        public string documentationUrl { get; }
        public string changelogUrl { get; }
        public string licensesUrl { get; }
        public RegistryInfo registry { get; }
        public DateTime? datePublished { get; }
        public GitInfo git { get; }
        public RepositoryInfo repository { get; }

        public static PackageInfo FindForAssetPath(string assetPath);
        public static PackageInfo FindForAssembly(Assembly assembly);
    }
}
using System.Collections.ObjectModel;

namespace UnityEditor.PackageManager
{
    public class PackageRegistrationEventArgs
    {
        public ReadOnlyCollection<PackageInfo> added { get; }
        public ReadOnlyCollection<PackageInfo> removed { get; }
        public ReadOnlyCollection<PackageInfo> changedFrom { get; }
        public ReadOnlyCollection<PackageInfo> changedTo { get; }
    }
}
namespace UnityEditor.PackageManager
{
    public enum PackageSource
    {
        Unknown = 0,
        Registry = 1,
        BuiltIn = 2,
        Embedded = 3,
        Local = 4,
        Git = 5,
        LocalTarball = 6
    }
}
namespace UnityEditor.PackageManager
{
    public enum PackageStatus
    {
        Unknown = 0,
        Unavailable = 1,
        InProgress = 2,
        Error = 3,
        Available = 4
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.PackageManager
{
    [RequiredByNativeCode]
    [NativeAsStruct]
    public sealed class PackOperationResult
    {
        public string tarballPath { get; }
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.PackageManager
{
    [RequiredByNativeCode]
    [NativeAsStruct]
    public class RegistryInfo
    {
        public string name { get; }
        public string url { get; }
        public bool isDefault { get; }
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.PackageManager
{
    [NativeAsStruct]
    [RequiredByNativeCode]
    public class RepositoryInfo
    {
        public string type { get; }
        public string url { get; }
        public string revision { get; }
        public string path { get; }
    }
}
namespace UnityEditor.PackageManager
{
    public enum StatusCode
    {
        InProgress = 0,
        Success = 1,
        Failure = 2
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.PackageManager
{
    [RequiredByNativeCode]
    [NativeAsStruct]
    public class VersionsInfo
    {
        public string[] all { get; }
        public string[] compatible { get; }
        public string verified { get; }
        [Obsolete("'recommended' is obsolete; use 'verified' instead. (UnityUpgradable) -> verified", False)]
        public string recommended { get; }
        public string latest { get; }
        public string latestCompatible { get; }
    }
}
namespace UnityEditor.PackageManager.Requests
{
    public sealed class AddRequest : Request<PackageInfo>
    {
        protected override PackageInfo GetResult();
    }
}
namespace UnityEditor.PackageManager.Requests
{
    public sealed class EmbedRequest : Request<PackageInfo>
    {
        protected override PackageInfo GetResult();
    }
}
namespace UnityEditor.PackageManager.Requests
{
    public sealed class ListRequest : Request<PackageCollection>
    {
        protected override PackageCollection GetResult();
    }
}
namespace UnityEditor.PackageManager.Requests
{
    public sealed class PackRequest : Request<PackOperationResult>
    {
        protected override PackOperationResult GetResult();
    }
}
namespace UnityEditor.PackageManager.Requests
{
    public sealed class RemoveRequest : Request
    {
        public string PackageIdOrName { get; }
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor.PackageManager.Requests
{
    [StaticAccessor("PackageManager", DoubleColon)]
    [NativeHeader("Modules/PackageManager/Editor/Public/PackageManager.h")]
    public abstract class Request : ISerializationCallbackReceiver
    {
        ~Request();

        public StatusCode Status { get; }
        public bool IsCompleted { get; }
        public Error Error { get; }

        protected virtual void FetchNativeData();
    }
}
namespace UnityEditor.PackageManager.Requests
{
    public abstract class Request<T> : Request
    {
        public T Result { get; }

        protected abstract T GetResult();
        protected sealed override void FetchNativeData();
    }
}
namespace UnityEditor.PackageManager.Requests
{
    public sealed class SearchRequest : Request<PackageInfo[]>
    {
        public string PackageIdOrName { get; }

        protected override PackageInfo[] GetResult();
    }
}
namespace UnityEditor.PackageManager.Requests
{
    public sealed class ResetToEditorDefaultsRequest : Request
    {
    }
}
using System;

namespace UnityEditor.Localization.Editor
{
    [Obsolete("Please use UnityEditor.LocalizationAttribute instead. (UnityUpgradable) -> UnityEditor.LocalizationAttribute", True)]
    [AttributeUsage(Assembly)]
    public sealed class LocalizationAttribute : Attribute
    {
        public LocalizationAttribute(string locGroupName = null);
    }
}
using System;

namespace UnityEditor.Localization.Editor
{
    [Obsolete("Localization has been deprecated. Please use UnityEditor.L10n instead", True)]
    public static class Localization
    {
        [Obsolete("Obsolete msg (UnityUpgradable) -> UnityEditor.L10n.Tr(*)", True)]
        public static string Tr(string str);
    }
}
using System;
using UnityEngine;

namespace UnityEditor.Localization.Editor
{
    [Obsolete("LocalizationGroup has been deprecated. Please use UnityEditor.LocalizationGroup instead", True)]
    public class LocalizationGroup : IDisposable
    {
        public LocalizationGroup();
        public LocalizationGroup(Behaviour behaviour);
        public LocalizationGroup(Type type);
        public LocalizationGroup(object obj);

        public string locGroupName { get; }

        public void Dispose();
    }
}
using UnityEngine.Bindings;

namespace UnityEditor.Purchasing
{
    [StaticAccessor("GetUnityPurchasingSettings()", Dot)]
    [NativeHeader("Modules/UnityConnect/UnityPurchasing/UnityPurchasingSettings.h")]
    public static class PurchasingSettings
    {
        public static bool enabled { get; set; }
    }
}
using UnityEngine.Bindings;

namespace UnityEditor.CrashReporting
{
    [StaticAccessor("GetCrashReportingSettings()")]
    [NativeHeader("Modules/UnityConnect/CrashReporting/CrashReportingSettings.h")]
    public static class CrashReportingSettings
    {
        public static bool enabled { get; set; }
        public static bool captureEditorExceptions { get; set; }
        [NativeThrows]
        public static uint logBufferSize { get; set; }
    }
}
using UnityEngine.Bindings;

namespace UnityEditor.Analytics
{
    [StaticAccessor("GetUnityAnalyticsSettings()", Dot)]
    [NativeHeader("Modules/UnityConnect/UnityAnalytics/UnityAnalyticsSettings.h")]
    [NativeHeader("Modules/UnityConnect/UnityConnectSettings.h")]
    public static class AnalyticsSettings
    {
        public static bool enabled { get; set; }
        public static bool testMode { get; set; }
        public static bool initializeOnStartup { get; set; }
        public static bool deviceStatsEnabledInBuild { get; }
        [StaticAccessor("GetUnityConnectSettings()", Dot)]
        public static string eventUrl { get; set; }
        [StaticAccessor("GetUnityConnectSettings()", Dot)]
        public static string configUrl { get; set; }
        [StaticAccessor("GetUnityConnectSettings()", Dot)]
        public static string dashboardUrl { get; set; }

        public static event RequireInBuildDelegate OnRequireInBuildHandler;

        public delegate bool RequireInBuildDelegate();
    }
}
using UnityEngine.Bindings;

namespace UnityEditor.Analytics
{
    [NativeHeader("Modules/UnityConnect/PerformanceReporting/PerformanceReportingSettings.h")]
    [StaticAccessor("GetPerformanceReportingSettings()", Dot)]
    public static class PerformanceReportingSettings
    {
        public static bool enabled { get; set; }
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor.Advertisements
{
    [NativeHeader("Modules/UnityConnect/UnityAds/UnityAdsSettings.h")]
    [StaticAccessor("GetUnityAdsSettings()", Dot)]
    public static class AdvertisementSettings
    {
        public static bool enabled { get; set; }
        public static bool testMode { get; set; }
        public static bool initializeOnStartup { get; set; }

        public static string GetGameId(RuntimePlatform platform);
        public static void SetGameId(RuntimePlatform platform, string gameId);
        [Obsolete("No longer supported and will always return true")]
        public static bool IsPlatformEnabled(RuntimePlatform platform);
        [Obsolete("No longer supported and will do nothing")]
        public static void SetPlatformEnabled(RuntimePlatform platform, bool value);
        [NativeMethod("GetGameId")]
        public static string GetPlatformGameId(string platformName);
        [NativeMethod("SetGameId")]
        public static void SetPlatformGameId(string platformName, string gameId);
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.VersionControl
{
    [UsedByNativeCode]
    [NativeHeader("Editor/Src/VersionControl/VC_bindings.h")]
    [NativeHeader("Editor/Src/VersionControl/VCAsset.h")]
    public class Asset
    {
        public Asset(string clientPath);

        ~Asset();

        public States state { get; }
        [NativeMethod(IsThreadSafe = True)]
        public string path { get; }
        [NativeMethod(IsThreadSafe = True)]
        public string metaPath { get; }
        [NativeMethod(IsThreadSafe = True)]
        public string assetPath { get; }
        [NativeMethod(IsThreadSafe = True)]
        public bool isFolder { get; }
        [NativeMethod(IsThreadSafe = True)]
        public bool readOnly { get; }
        [NativeMethod(IsThreadSafe = True)]
        public bool isMeta { get; }
        [NativeMethod(IsThreadSafe = True)]
        public bool locked { get; }
        [NativeMethod(IsThreadSafe = True)]
        public string name { get; }
        [NativeMethod(IsThreadSafe = True)]
        public string fullName { get; }
        [NativeMethod(IsThreadSafe = True)]
        public bool isInCurrentProject { get; }
        public string prettyPath { get; }

        public void Dispose();
        [NativeName("MonoIsChildOf")]
        [NativeMethod(IsThreadSafe = True)]
        public bool IsChildOf(Asset other);
        public bool IsState(States state);
        public bool IsOneOfStates(States[] states);
        public void Edit();
        public UnityEngine.Object Load();

        [Flags]
        public enum States
        {
            None = 0,
            Local = 1,
            Synced = 2,
            OutOfSync = 4,
            Missing = 8,
            CheckedOutLocal = 16,
            CheckedOutRemote = 32,
            DeletedLocal = 64,
            DeletedRemote = 128,
            AddedLocal = 256,
            AddedRemote = 512,
            Conflicted = 1024,
            LockedLocal = 2048,
            LockedRemote = 4096,
            Updating = 8192,
            ReadOnly = 16384,
            MetaFile = 32768,
            MovedLocal = 65536,
            MovedRemote = 131072,
            Unversioned = 262144,
            Exclusive = 524288
        }
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.VersionControl
{
    [NativeHeader("Editor/Src/VersionControl/VCChangeSet.h")]
    [NativeHeader("Editor/Src/VersionControl/VC_bindings.h")]
    [UsedByNativeCode]
    public class ChangeSet
    {
        public static string defaultID;

        public ChangeSet();
        public ChangeSet(string description);
        public ChangeSet(string description, string revision);
        public ChangeSet(ChangeSet other);

        ~ChangeSet();

        [NativeMethod(IsThreadSafe = True)]
        public string description { get; }
        [NativeMethod(IsThreadSafe = True)]
        public string id { get; }

        public void Dispose();
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.VersionControl
{
    [NativeHeader("Editor/Src/VersionControl/VCMessage.h")]
    [UsedByNativeCode]
    [NativeHeader("Editor/Src/VersionControl/VC_bindings.h")]
    public class Message
    {
        ~Message();

        [NativeMethod(IsThreadSafe = True)]
        public Severity severity { get; }
        [NativeMethod(IsThreadSafe = True)]
        public string message { get; }

        public void Dispose();
        public void Show();

        [NativeType("Editor/Src/VersionControl/VCMessage.h")]
        public enum Severity
        {
            Data = 0,
            Verbose = 1,
            Info = 2,
            Warning = 3,
            Error = 4
        }
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.VersionControl
{
    [NativeHeader("Editor/Src/VersionControl/VC_bindings.h")]
    [NativeHeader("Editor/Src/VersionControl/VCConfigField.h")]
    [UsedByNativeCode]
    public class ConfigField
    {
        ~ConfigField();

        public string name { get; }
        public string label { get; }
        public string description { get; }
        public bool isRequired { get; }
        public bool isPassword { get; }

        public void Dispose();
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.VersionControl
{
    [UsedByNativeCode]
    [NativeHeader("Editor/Src/VersionControl/VCPlugin.h")]
    public class Plugin
    {
        ~Plugin();

        public static Plugin[] availablePlugins { get; }
        public string name { get; }
        public ConfigField[] configFields { get; }

        public void Dispose();
    }
}
using System;
using System.ComponentModel;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Internal;

namespace UnityEditor.VersionControl
{
    [NativeHeader("Editor/Src/VersionControl/VCCache.h")]
    [NativeHeader("Editor/Src/VersionControl/VC_bindings.h")]
    [NativeHeader("Editor/Src/VersionControl/VCProvider.h")]
    [NativeHeader("Editor/Src/VersionControl/VCPlugin.h")]
    [NativeHeader("Editor/Src/VersionControl/VCTask.h")]
    public class Provider
    {
        public static PreSubmitCallback preSubmitCallback;
        public static PreCheckoutCallback preCheckoutCallback;

        public Provider();

        [StaticAccessor("GetVCProvider()", Dot)]
        public static bool enabled { get; }
        [StaticAccessor("GetVCProvider()", Dot)]
        public static bool isActive { get; }
        public static bool requiresNetwork { get; }
        public static bool hasChangelistSupport { get; }
        public static bool hasCheckoutSupport { get; }
        public static bool hasLockingSupport { get; }
        public static bool isVersioningFolders { get; }
        [StaticAccessor("GetVCProvider()", Dot)]
        public static OnlineState onlineState { get; }
        [StaticAccessor("GetVCProvider()", Dot)]
        public static string offlineReason { get; }
        public static Task activeTask { get; }

        [FreeFunction("VersionControlBindings::VCProvider::GetActivePlugin")]
        public static Plugin GetActivePlugin();
        [FreeFunction("VersionControlBindings::VCProvider::GetActiveConfigFields")]
        public static ConfigField[] GetActiveConfigFields();
        [FreeFunction("VersionControlBindings::VCProvider::ChangeSets")]
        public static Task ChangeSets();
        [FreeFunction("VersionControlBindings::VCProvider::Incoming")]
        public static Task Incoming();
        [FreeFunction("VersionControlBindings::VCProvider::UpdateSettings")]
        public static Task UpdateSettings();
        [FreeFunction("VersionControlBindings::VCProvider::GetAssetByPath")]
        public static Asset GetAssetByPath(string unityPath);
        [FreeFunction("VersionControlBindings::VCProvider::GetAssetByGUID")]
        public static Asset GetAssetByGUID(string guid);
        [FreeFunction("VersionControlBindings::VCProvider::IsOpenForEdit")]
        public static bool IsOpenForEdit([NotNull("ArgumentNullException")] Asset asset);
        [StaticAccessor("GetVCCache()", Dot)]
        [NativeMethod("Clear")]
        public static void ClearCache();
        [FreeFunction("VersionControlBindings::VCProvider::Internal_CreateWarningTask")]
        public static Task Internal_WarningTask([NotNull("ArgumentNullException")] string message);
        [FreeFunction("VersionControlBindings::VCProvider::Internal_CreateErrorTask")]
        public static Task Internal_ErrorTask([NotNull("ArgumentNullException")] string message);
        public static Task Status(AssetList assets);
        public static Task Status(Asset asset);
        public static Task Status(AssetList assets, bool recursively);
        public static Task Status(Asset asset, bool recursively);
        public static Task Status(string[] assets);
        public static Task Status(string[] assets, bool recursively);
        public static Task Status(string asset);
        public static Task Status(string asset, bool recursively);
        public static Task Move(string from, string to);
        public static bool CheckoutIsValid(AssetList assets);
        public static bool CheckoutIsValid(AssetList assets, CheckoutMode mode);
        public static Task Checkout(AssetList assets, CheckoutMode mode);
        public static Task Checkout(AssetList assets, CheckoutMode mode, ChangeSet changeset);
        public static Task Checkout(string[] assets, CheckoutMode mode);
        public static Task Checkout(string[] assets, CheckoutMode mode, ChangeSet changeset);
        public static Task Checkout(UnityEngine.Object[] assets, CheckoutMode mode);
        public static Task Checkout(UnityEngine.Object[] assets, CheckoutMode mode, ChangeSet changeset);
        public static bool CheckoutIsValid(Asset asset);
        public static bool CheckoutIsValid(Asset asset, CheckoutMode mode);
        public static Task Checkout(Asset asset, CheckoutMode mode);
        public static Task Checkout(Asset asset, CheckoutMode mode, ChangeSet changeset);
        public static Task Checkout(string asset, CheckoutMode mode);
        public static Task Checkout(string asset, CheckoutMode mode, ChangeSet changeset);
        public static Task Checkout(UnityEngine.Object asset, CheckoutMode mode);
        public static Task Checkout(UnityEngine.Object asset, CheckoutMode mode, ChangeSet changeset);
        public static Task Delete(string assetProjectPath);
        public static Task Delete(AssetList assets);
        public static Task Delete(Asset asset);
        public static bool AddIsValid(AssetList assets);
        public static Task Add(AssetList assets, bool recursive);
        public static Task Add(Asset asset, bool recursive);
        public static bool DeleteChangeSetsIsValid(ChangeSets changesets);
        public static Task DeleteChangeSets(ChangeSets changesets);
        public static bool SubmitIsValid(ChangeSet changeset, AssetList assets);
        public static Task Submit(ChangeSet changeset, AssetList list, string description, bool saveOnly);
        public static bool DiffIsValid(AssetList assets);
        public static Task DiffHead(AssetList assets, bool includingMetaFiles);
        public static bool ResolveIsValid(AssetList assets);
        public static Task Resolve(AssetList assets, ResolveMethod resolveMethod);
        public static Task Merge(AssetList assets);
        [EditorBrowsable(Never)]
        [ExcludeFromDocs]
        [Obsolete("MergeMethod is no longer used.")]
        public static Task Merge(AssetList assets, MergeMethod method);
        public static bool LockIsValid(AssetList assets);
        public static bool LockIsValid(Asset asset);
        public static bool UnlockIsValid(AssetList assets);
        public static bool UnlockIsValid(Asset asset);
        public static Task Lock(AssetList assets, bool locked);
        public static Task Lock(Asset asset, bool locked);
        public static bool RevertIsValid(AssetList assets, RevertMode mode);
        public static Task Revert(AssetList assets, RevertMode mode);
        public static bool RevertIsValid(Asset asset, RevertMode mode);
        public static Task Revert(Asset asset, RevertMode mode);
        public static bool GetLatestIsValid(AssetList assets);
        public static bool GetLatestIsValid(Asset asset);
        public static Task GetLatest(AssetList assets);
        public static Task GetLatest(Asset asset);
        public static Task ChangeSetDescription(ChangeSet changeset);
        public static Task ChangeSetStatus(ChangeSet changeset);
        public static Task ChangeSetStatus(string changesetID);
        public static Task IncomingChangeSetAssets(ChangeSet changeset);
        public static Task IncomingChangeSetAssets(string changesetID);
        public static Task ChangeSetMove(AssetList assets, ChangeSet changeset);
        public static Task ChangeSetMove(Asset asset, ChangeSet changeset);
        public static Task ChangeSetMove(AssetList assets, string changesetID);
        public static Task ChangeSetMove(Asset asset, string changesetID);
        public static AssetList GetAssetListFromSelection();

        public delegate bool PreSubmitCallback(AssetList list, ref string changesetID, ref string changesetDescription);
        public delegate bool PreCheckoutCallback(AssetList list, ref string changesetID, ref string changesetDescription);
    }
}
using UnityEngine.Bindings;

namespace UnityEditor.VersionControl
{
    [NativeType("Editor/Src/VersionControl/VCEnums.h")]
    public enum CompletionAction
    {
        UpdatePendingWindow = 1,
        OnChangeContentsPendingWindow = 2,
        OnIncomingPendingWindow = 3,
        OnChangeSetsPendingWindow = 4,
        OnGotLatestPendingWindow = 5,
        OnSubmittedChangeWindow = 6,
        OnAddedChangeWindow = 7,
        OnCheckoutCompleted = 8
    }
}
using System;

namespace UnityEditor.VersionControl
{
    [Flags]
    public enum SubmitResult
    {
        OK = 1,
        Error = 2,
        ConflictingFiles = 4,
        UnaddedFiles = 8
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.VersionControl
{
    [NativeHeader("Editor/Src/VersionControl/VC_bindings.h")]
    [NativeHeader("Editor/Src/VersionControl/VCTask.h")]
    [UsedByNativeCode]
    public class Task
    {
        ~Task();

        public int userIdentifier { get; set; }
        public string text { get; }
        public string description { get; }
        public bool success { get; }
        public int secondsSpent { get; }
        public int progressPct { get; }
        public string progressMessage { get; }
        public int resultCode { get; }
        public Message[] messages { get; }
        public AssetList assetList { get; }
        public ChangeSets changeSets { get; }

        public void Wait();
        public void SetCompletionAction(CompletionAction action);
        public void Dispose();
    }
}
using System.Collections.Generic;

namespace UnityEditor.VersionControl
{
    public class AssetList : List<Asset>
    {
        public AssetList();
        public AssetList(AssetList src);

        public AssetList Filter(bool includeFolder, params Asset.States[] states);
        public int FilterCount(bool includeFolder, params Asset.States[] states);
        public AssetList FilterChildren();
    }
}
using System.Collections.Generic;

namespace UnityEditor.VersionControl
{
    public class ChangeSets : List<ChangeSet>
    {
        public ChangeSets();
    }
}
using System;

namespace UnityEditor.VersionControl
{
    [Flags]
    public enum CheckoutMode
    {
        Asset = 1,
        Meta = 2,
        Both = 3,
        Exact = 4
    }
}
using System;

namespace UnityEditor.VersionControl
{
    [Flags]
    public enum ResolveMethod
    {
        UseMine = 1,
        UseTheirs = 2,
        UseMerged = 3
    }
}
using System;

namespace UnityEditor.VersionControl
{
    [Obsolete("MergeMethod is no longer used.")]
    [Flags]
    public enum MergeMethod
    {
        MergeNone = 0,
        MergeAll = 1,
        [Obsolete("This member is no longer supported (UnityUpgradable) -> MergeNone", True)]
        MergeNonConflicting = 2
    }
}
using System;

namespace UnityEditor.VersionControl
{
    [Flags]
    public enum OnlineState
    {
        Updating = 0,
        Online = 1,
        Offline = 2
    }
}
using System;

namespace UnityEditor.VersionControl
{
    [Flags]
    public enum RevertMode
    {
        Normal = 0,
        Unchanged = 1,
        KeepModifications = 2
    }
}
using System;

namespace UnityEditor.VersionControl
{
    [Flags]
    public enum FileMode
    {
        None = 0,
        Binary = 1,
        Text = 2
    }
}
using UnityEngine;
using UnityEngine.Events;

namespace UnityEditor.Events
{
    public static class UnityEventTools
    {
        public static void AddPersistentListener(UnityEventBase unityEvent);
        public static void RemovePersistentListener(UnityEventBase unityEvent, int index);
        public static void AddPersistentListener(UnityEvent unityEvent, UnityAction call);
        public static void AddPersistentListener<T0>(UnityEvent<T0> unityEvent, UnityAction<T0> call);
        public static void AddPersistentListener<T0, T1>(UnityEvent<T0, T1> unityEvent, UnityAction<T0, T1> call);
        public static void AddPersistentListener<T0, T1, T2>(UnityEvent<T0, T1, T2> unityEvent, UnityAction<T0, T1, T2> call);
        public static void AddPersistentListener<T0, T1, T2, T3>(UnityEvent<T0, T1, T2, T3> unityEvent, UnityAction<T0, T1, T2, T3> call);
        public static void RegisterPersistentListener(UnityEvent unityEvent, int index, UnityAction call);
        public static void RegisterPersistentListener<T0>(UnityEvent<T0> unityEvent, int index, UnityAction<T0> call);
        public static void RegisterPersistentListener<T0, T1>(UnityEvent<T0, T1> unityEvent, int index, UnityAction<T0, T1> call);
        public static void RegisterPersistentListener<T0, T1, T2>(UnityEvent<T0, T1, T2> unityEvent, int index, UnityAction<T0, T1, T2> call);
        public static void RegisterPersistentListener<T0, T1, T2, T3>(UnityEvent<T0, T1, T2, T3> unityEvent, int index, UnityAction<T0, T1, T2, T3> call);
        public static void RemovePersistentListener(UnityEventBase unityEvent, UnityAction call);
        public static void RemovePersistentListener<T0>(UnityEventBase unityEvent, UnityAction<T0> call);
        public static void RemovePersistentListener<T0, T1>(UnityEventBase unityEvent, UnityAction<T0, T1> call);
        public static void RemovePersistentListener<T0, T1, T2>(UnityEventBase unityEvent, UnityAction<T0, T1, T2> call);
        public static void RemovePersistentListener<T0, T1, T2, T3>(UnityEventBase unityEvent, UnityAction<T0, T1, T2, T3> call);
        public static void UnregisterPersistentListener(UnityEventBase unityEvent, int index);
        public static void AddVoidPersistentListener(UnityEventBase unityEvent, UnityAction call);
        public static void RegisterVoidPersistentListener(UnityEventBase unityEvent, int index, UnityAction call);
        public static void AddIntPersistentListener(UnityEventBase unityEvent, UnityAction<int> call, int argument);
        public static void RegisterIntPersistentListener(UnityEventBase unityEvent, int index, UnityAction<int> call, int argument);
        public static void AddFloatPersistentListener(UnityEventBase unityEvent, UnityAction<float> call, float argument);
        public static void RegisterFloatPersistentListener(UnityEventBase unityEvent, int index, UnityAction<float> call, float argument);
        public static void AddBoolPersistentListener(UnityEventBase unityEvent, UnityAction<bool> call, bool argument);
        public static void RegisterBoolPersistentListener(UnityEventBase unityEvent, int index, UnityAction<bool> call, bool argument);
        public static void AddStringPersistentListener(UnityEventBase unityEvent, UnityAction<string> call, string argument);
        public static void RegisterStringPersistentListener(UnityEventBase unityEvent, int index, UnityAction<string> call, string argument);
        public static void AddObjectPersistentListener<T>(UnityEventBase unityEvent, UnityAction<T> call, T argument) where T : Object;
        public static void RegisterObjectPersistentListener<T>(UnityEventBase unityEvent, int index, UnityAction<T> call, T argument) where T : Object;
    }
}
using System;

namespace UnityEditor.Connect
{
    public static class UnityOAuth
    {
        public static event Action UserLoggedIn;
        public static event Action UserLoggedOut;

        public static void GetAuthorizationCodeAsync(string clientId, Action<AuthCodeResponse> callback);

        public struct AuthCodeResponse
        {
            public string AuthCode { get; set; }
            public Exception Exception { get; set; }
        }
    }
}
using System;

namespace UnityEditor.SearchService
{
    [AttributeUsage(Class)]
    public class ObjectSelectorEngineAttribute : Attribute
    {
        public ObjectSelectorEngineAttribute();
    }
}
using System;

namespace UnityEditor.SearchService
{
    [AttributeUsage(Method)]
    public class ObjectSelectorHandlerAttribute : Attribute
    {
        public ObjectSelectorHandlerAttribute(Type attributeType);

        public Type attributeType { get; }
    }
}
using System;

namespace UnityEditor.SearchService
{
    [Flags]
    public enum VisibleObjects
    {
        None = 0,
        Assets = 1,
        Scene = 2,
        All = 3
    }
}
using System;
using UnityEngine;

namespace UnityEditor.SearchService
{
    public struct ObjectSelectorTargetInfo
    {
        public ObjectSelectorTargetInfo(GlobalObjectId globalObjectId, UnityEngine.Object targetObject = null, Type type = null);

        public GlobalObjectId globalObjectId { get; }
        public UnityEngine.Object targetObject { get; }
        public Type type { get; }

        public UnityEngine.Object LoadObject();
    }
}
using System;
using System.Collections.Generic;
using UnityEngine;

namespace UnityEditor.SearchService
{
    public class ObjectSelectorSearchContext : ISearchContext
    {
        public ObjectSelectorSearchContext();

        public Guid guid { get; }
        public SearchEngineScope engineScope { get; protected set; }
        public UnityEngine.Object currentObject { get; set; }
        public UnityEngine.Object[] editedObjects { get; set; }
        public IEnumerable<Type> requiredTypes { get; set; }
        public IEnumerable<string> requiredTypeNames { get; set; }
        public VisibleObjects visibleObjects { get; set; }
        public IEnumerable<int> allowedInstanceIds { get; set; }
        public Func<ObjectSelectorTargetInfo, UnityEngine.Object[], ObjectSelectorSearchContext, bool> selectorConstraint { get; set; }
    }
}
namespace UnityEditor.SearchService
{
    public interface IObjectSelectorEngine : ISelectorEngine, ISearchEngineBase
    {
    }
}
namespace UnityEditor.SearchService
{
    [InitializeOnLoad]
    public static class ObjectSelector
    {
        public const SearchEngineScope EngineScope = 2;

        public static void RegisterEngine(IObjectSelectorEngine engine);
        public static void UnregisterEngine(IObjectSelectorEngine engine);
    }
}
using System;

namespace UnityEditor.SearchService
{
    [AttributeUsage(Class)]
    public class ProjectSearchEngineAttribute : Attribute
    {
        public ProjectSearchEngineAttribute();
    }
}
using System;
using System.Collections.Generic;

namespace UnityEditor.SearchService
{
    public class ProjectSearchContext : ISearchContext
    {
        public ProjectSearchContext();

        public Guid guid { get; }
        public SearchEngineScope engineScope { get; protected set; }
        public IEnumerable<Type> requiredTypes { get; set; }
        public IEnumerable<string> requiredTypeNames { get; set; }
    }
}
namespace UnityEditor.SearchService
{
    public interface IProjectSearchEngine : ISearchEngineBase, ISearchEngine<string>
    {
    }
}
namespace UnityEditor.SearchService
{
    [InitializeOnLoad]
    public static class Project
    {
        public const SearchEngineScope EngineScope = 1;

        public static void RegisterEngine(IProjectSearchEngine engine);
        public static void UnregisterEngine(IProjectSearchEngine engine);
    }
}
using System;

namespace UnityEditor.SearchService
{
    [AttributeUsage(Class)]
    public class SceneSearchEngineAttribute : Attribute
    {
        public SceneSearchEngineAttribute();
    }
}
using System;
using System.Collections.Generic;

namespace UnityEditor.SearchService
{
    public class SceneSearchContext : ISearchContext
    {
        public SceneSearchContext();

        public Guid guid { get; }
        public SearchEngineScope engineScope { get; protected set; }
        public IEnumerable<Type> requiredTypes { get; set; }
        public IEnumerable<string> requiredTypeNames { get; set; }
        public HierarchyProperty rootProperty { get; set; }
    }
}
namespace UnityEditor.SearchService
{
    public interface ISceneSearchEngine : IFilterEngine<HierarchyProperty>, ISearchEngineBase
    {
    }
}
namespace UnityEditor.SearchService
{
    [InitializeOnLoad]
    public static class Scene
    {
        public const SearchEngineScope EngineScope = 0;

        public static void RegisterEngine(ISceneSearchEngine engine);
        public static void UnregisterEngine(ISceneSearchEngine engine);
    }
}
namespace UnityEditor.SearchService
{
    public enum SearchEngineScope
    {
        Scene = 0,
        Project = 1,
        ObjectSelector = 2
    }
}
using System;
using System.Collections.Generic;

namespace UnityEditor.SearchService
{
    public interface ISearchContext
    {
        Guid guid { get; }
        SearchEngineScope engineScope { get; }
        IEnumerable<Type> requiredTypes { get; }
        IEnumerable<string> requiredTypeNames { get; }
    }
}
namespace UnityEditor.SearchService
{
    public interface ISearchEngineBase
    {
        string name { get; }

        void BeginSession(ISearchContext context);
        void EndSession(ISearchContext context);
        void BeginSearch(ISearchContext context, string query);
        void EndSearch(ISearchContext context);
    }
}
using System;
using System.Collections.Generic;

namespace UnityEditor.SearchService
{
    public interface ISearchEngine<T> : ISearchEngineBase
    {
        IEnumerable<T> Search(ISearchContext context, string query, Action<IEnumerable<T>> asyncItemsReceived);
    }
}
namespace UnityEditor.SearchService
{
    public interface IFilterEngine<T> : ISearchEngineBase
    {
        bool Filter(ISearchContext context, string query, T objectToFilter);
    }
}
using System;
using UnityEngine;

namespace UnityEditor.SearchService
{
    public interface ISelectorEngine : ISearchEngineBase
    {
        bool SelectObject(ISearchContext context, Action<UnityEngine.Object, bool> onObjectSelectorClosed, Action<UnityEngine.Object> onObjectSelectedUpdated);
        void SetSearchFilter(ISearchContext context, string searchFilter);
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEditor.Scripting
{
    [InitializeOnLoad]
    [NativeHeader("Editor/Src/Scripting/ManagedDebugger.h")]
    public sealed class ManagedDebugger
    {
        public ManagedDebugger();

        public static bool isAttached { get; }
        public static bool isEnabled { get; }

        public static event Action<bool> debuggerAttached;

        [FreeFunction(Name = "ManagedDebugger::Disconnect")]
        public static void Disconnect();
    }
}
using UnityEngine;

namespace UnityEditor.ProjectWindowCallback
{
    public abstract class EndNameEditAction : ScriptableObject
    {
        protected EndNameEditAction();

        public virtual void OnEnable();
        public abstract void Action(int instanceId, string pathName, string resourceFile);
        public virtual void Cancelled(int instanceId, string pathName, string resourceFile);
        public virtual void CleanUp();
    }
}
using UnityEngine.Playables;

namespace UnityEditor.Playables
{
    public static class PlayableOutputEditorExtensions
    {
        public static string GetEditorName<U>(this U output) where U : IPlayableOutput, struct;
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Playables;

namespace UnityEditor.Playables
{
    [NativeHeader("Editor/Src/Playables/Playables.bindings.h")]
    public static class Utility
    {
        public static event Action<PlayableGraph> graphCreated;
        public static event Action<PlayableGraph> destroyingGraph;

        public static PlayableGraph[] GetAllGraphs();
    }
}
using System;
using UnityEngine.Networking.PlayerConnection;

namespace UnityEditor.Networking.PlayerConnection
{
    public static class PlayerConnectionGUIUtility
    {
        public static IConnectionState GetConnectionState(EditorWindow parentWindow, Action<string> connectedCallback = null);
    }
}
using UnityEngine;
using UnityEngine.Networking.PlayerConnection;

namespace UnityEditor.Networking.PlayerConnection
{
    public static class PlayerConnectionGUI
    {
        public static void ConnectionTargetSelectionDropdown(Rect rect, IConnectionState state, GUIStyle style = null);
    }
}
using UnityEngine;
using UnityEngine.Networking.PlayerConnection;

namespace UnityEditor.Networking.PlayerConnection
{
    public static class PlayerConnectionGUILayout
    {
        public static void ConnectionTargetSelectionDropdown(IConnectionState state, GUIStyle style = null);
    }
}
using System;
using System.ComponentModel;

namespace UnityEditor.Networking.PlayerConnection
{
    public class ConnectedPlayer
    {
        public ConnectedPlayer();
        public ConnectedPlayer(int playerId);
        public ConnectedPlayer(int playerId, string name);

        [EditorBrowsable(Never)]
        [Obsolete("Use playerId instead (UnityUpgradable) -> playerId", True)]
        public int PlayerId { get; }
        public int playerId { get; }
        public string name { get; }
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.Events;
using UnityEngine.Networking.PlayerConnection;

namespace UnityEditor.Networking.PlayerConnection
{
    public class EditorConnection : ScriptableSingleton<EditorConnection>, IEditorPlayerConnection
    {
        public EditorConnection();

        public List<ConnectedPlayer> ConnectedPlayers { get; }

        public void Initialize();
        public void Register(Guid messageId, UnityAction<MessageEventArgs> callback);
        public void Unregister(Guid messageId, UnityAction<MessageEventArgs> callback);
        public void RegisterConnection(UnityAction<int> callback);
        public void RegisterDisconnection(UnityAction<int> callback);
        public void UnregisterConnection(UnityAction<int> callback);
        public void UnregisterDisconnection(UnityAction<int> callback);
        public void Send(Guid messageId, byte[] data, int playerId);
        public void Send(Guid messageId, byte[] data);
        public bool TrySend(Guid messageId, byte[] data, int playerId);
        public bool TrySend(Guid messageId, byte[] data);
        public void DisconnectAll();
    }
}
using UnityEngine.Bindings;

namespace UnityEditor.Media
{
    [NativeHeader("Editor/Mono/Media/Bindings/MediaEncoder.bindings.h")]
    public struct MediaRational
    {
        public static readonly MediaRational Invalid;
        public int numerator;
        public int denominator;

        public MediaRational(int numerator);
        public MediaRational(int numerator, int denominator);

        public MediaRational inverse { get; }
        public bool isValid { get; }
        public bool isZero { get; }
        public bool isNegative { get; }

        public void Set(int numerator, int denominator = 1);

        public static explicit operator double(MediaRational r);
    }
}
namespace UnityEditor.Media
{
    public struct MediaTime
    {
        public static readonly MediaTime Invalid;

        public MediaTime(long seconds);
        public MediaTime(long count, uint rateNumerator, uint rateDenominator = 1);

        public long count { get; set; }
        public MediaRational rate { get; set; }

        public static explicit operator double(MediaTime t);
    }
}
namespace UnityEditor.Media
{
    public struct VideoTrackAttributes
    {
        public MediaRational frameRate;
        public uint width;
        public uint height;
        public bool includeAlpha;
        public VideoBitrateMode bitRateMode;
    }
}
namespace UnityEditor.Media
{
    public struct AudioTrackAttributes
    {
        public MediaRational sampleRate;
        public ushort channelCount;
        public string language;
    }
}
using System;
using Unity.Collections;
using UnityEngine;

namespace UnityEditor.Media
{
    public class MediaEncoder : IDisposable
    {
        [Obsolete("Was made public by mistake. Not meant to be used by user code.", True)]
        public IntPtr m_Ptr;

        public MediaEncoder(string filePath, VideoTrackAttributes videoAttrs, AudioTrackAttributes[] audioAttrs);
        public MediaEncoder(string filePath, VideoTrackAttributes videoAttrs, AudioTrackAttributes audioAttrs);
        public MediaEncoder(string filePath, VideoTrackAttributes videoAttrs);
        public MediaEncoder(string filePath, AudioTrackAttributes[] audioAttrs);
        public MediaEncoder(string filePath, AudioTrackAttributes audioAttrs);

        ~MediaEncoder();

        public bool AddFrame(int width, int height, int rowBytes, TextureFormat format, NativeArray<byte> data);
        public bool AddFrame(int width, int height, int rowBytes, TextureFormat format, NativeArray<byte> data, MediaTime time);
        public bool AddFrame(Texture2D texture);
        public bool AddFrame(Texture2D texture, MediaTime time);
        public bool AddSamples(ushort trackIndex, NativeArray<float> interleavedSamples);
        public bool AddSamples(NativeArray<float> interleavedSamples);
        public void Dispose();
    }
}
namespace UnityEditor.Macros
{
    public static class MacroEvaluator
    {
        public static string Eval(string macro);
    }
}
using System;

namespace UnityEditor.Macros
{
    public static class MethodEvaluator
    {
        public static object Eval(string assemblyFile, string typeName, string methodName, Type[] paramTypes, object[] args);
        public static object ExecuteExternalCode(string parcel);
    }
}
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.Bindings;
using UnityEngine.Internal;

namespace UnityEditor.AI
{
    [StaticAccessor("NavMeshVisualizationSettingsScriptBindings", DoubleColon)]
    [NativeHeader("Modules/AIEditor/Visualization/NavMeshVisualizationSettings.bindings.h")]
    public static class NavMeshEditorHelpers
    {
        public static void OpenAgentSettings(int agentTypeID);
        public static void OpenAreaSettings();
        public static void DrawAgentDiagram(Rect rect, float agentRadius, float agentHeight, float agentClimb, float agentSlope);
        [ExcludeFromDocs]
        public static void DrawBuildDebug(NavMeshData navMeshData);
        public static void DrawBuildDebug(NavMeshData navMeshData, [DefaultValue("NavMeshBuildDebugFlags.All")] NavMeshBuildDebugFlags flags);
    }
}
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.Bindings;
using UnityEngine.SceneManagement;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.AI
{
    [MovedFrom("UnityEditor")]
    [NativeHeader("Modules/AIEditor/Builder/NavMeshBuilderEditor.bindings.h")]
    [StaticAccessor("NavMeshBuilderEditorBindings", DoubleColon)]
    public sealed class NavMeshBuilder
    {
        public NavMeshBuilder();

        public static Object navMeshSettingsObject { get; }
        public static bool isRunning { get; }

        public static void BuildNavMesh();
        public static void BuildNavMeshAsync();
        [StaticAccessor("NavMeshBuilder", DoubleColon)]
        public static void ClearAllNavMeshes();
        [StaticAccessor("NavMeshBuilder", DoubleColon)]
        public static void Cancel();
        public static void BuildNavMeshForMultipleScenes(string[] paths);
        public static void CollectSourcesInStage(Bounds includedWorldBounds, int includedLayerMask, NavMeshCollectGeometry geometry, int defaultArea, List<NavMeshBuildMarkup> markups, Scene stageProxy, List<NavMeshBuildSource> results);
        public static void CollectSourcesInStage(Transform root, int includedLayerMask, NavMeshCollectGeometry geometry, int defaultArea, List<NavMeshBuildMarkup> markups, Scene stageProxy, List<NavMeshBuildSource> results);
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.AI
{
    [StaticAccessor("GetNavMeshVisualizationSettings()", Dot)]
    [MovedFrom("UnityEditor")]
    public sealed class NavMeshVisualizationSettings
    {
        public NavMeshVisualizationSettings();

        public static int showNavigation { get; set; }
    }
}
using System;

namespace UnityEditor.EditorTools
{
    [AttributeUsage(Class, Inherited = False)]
    public sealed class EditorToolAttribute : Attribute
    {
        public EditorToolAttribute(string displayName, Type targetType = null);

        public string displayName { get; }
        public Type targetType { get; set; }
    }
}
namespace UnityEditor.EditorTools
{
    public interface IDrawSelectedHandles
    {
        void OnDrawHandles();
    }
}
using System.Collections.Generic;
using UnityEngine;

namespace UnityEditor.EditorTools
{
    public abstract class EditorTool : ScriptableObject
    {
        protected EditorTool();

        public IEnumerable<Object> targets { get; }
        public Object target { get; }
        public virtual GUIContent toolbarIcon { get; }

        public virtual void OnActivated();
        public virtual void OnWillBeDeactivated();
        public virtual void OnToolGUI(EditorWindow window);
        public virtual bool IsAvailable();
    }
}
using System;
using UnityEngine;

namespace UnityEditor.EditorTools
{
    public abstract class EditorToolContext : ScriptableObject
    {
        protected EditorToolContext();

        public virtual void OnToolGUI(EditorWindow window);
        public Type ResolveTool(Tool tool);
        protected virtual Type GetEditorToolType(Tool tool);
    }
}
using System;
using System.ComponentModel;

namespace UnityEditor.EditorTools
{
    [EditorBrowsable(Never)]
    [Obsolete("EditorTools has been deprecated. Use ToolManager instead (UnityUpgradable) -> ToolManager")]
    public static class EditorTools
    {
        public static Type activeToolType { get; }

        public static event Action activeToolChanging;
        public static event Action activeToolChanged;

        public static void SetActiveTool<T>() where T : EditorTool;
        public static void SetActiveTool(Type type);
        public static void SetActiveTool(EditorTool tool);
        public static void RestorePreviousTool();
        public static void RestorePreviousPersistentTool();
        public static bool IsActiveTool(EditorTool tool);
    }
}
namespace UnityEditor.EditorTools
{
    [EditorToolContext("GameObject", "Manipulate GameObjects in the Scene View.")]
    public sealed class GameObjectToolContext : EditorToolContext
    {
    }
}
using System;

namespace UnityEditor.EditorTools
{
    public static class ToolManager
    {
        public static Type activeContextType { get; }
        public static Type activeToolType { get; }

        public static event Action activeToolChanging;
        public static event Action activeToolChanged;
        public static event Action activeContextChanging;
        public static event Action activeContextChanged;

        public static void SetActiveContext(Type context);
        public static void SetActiveContext<T>() where T : EditorToolContext;
        public static void SetActiveTool<T>() where T : EditorTool;
        public static void SetActiveTool(Type type);
        public static void SetActiveTool(EditorTool tool);
        public static void RestorePreviousTool();
        public static void RestorePreviousPersistentTool();
        public static bool IsActiveTool(EditorTool tool);
    }
}
using System;
using UnityEngine.Events;

namespace UnityEditor.AnimatedValues
{
    public abstract class BaseAnimValueNonAlloc<T> : BaseAnimValue<T> where T : IEquatable<T>
    {
        protected BaseAnimValueNonAlloc(T value);
        protected BaseAnimValueNonAlloc(T value, UnityAction callback);

        protected override bool AreEqual(T a, T b);
    }
}
using UnityEngine;
using UnityEngine.Events;

namespace UnityEditor.AnimatedValues
{
    public abstract class BaseAnimValue<T> : ISerializationCallbackReceiver
    {
        public float speed;
        public UnityEvent valueChanged;

        protected BaseAnimValue(T value);
        protected BaseAnimValue(T value, UnityAction callback);

        public bool isAnimating { get; }
        protected float lerpPosition { get; }
        protected T start { get; }
        public T target { get; set; }
        public T value { get; set; }

        protected virtual bool AreEqual(T a, T b);
        protected void BeginAnimating(T newTarget, T newStart);
        protected void StopAnim(T newValue);
        protected abstract T GetValue();
    }
}
using UnityEngine.Events;

namespace UnityEditor.AnimatedValues
{
    public class AnimFloat : BaseAnimValueNonAlloc<float>
    {
        public AnimFloat(float value);
        public AnimFloat(float value, UnityAction callback);

        protected override float GetValue();
    }
}
using UnityEngine;
using UnityEngine.Events;

namespace UnityEditor.AnimatedValues
{
    public class AnimVector3 : BaseAnimValueNonAlloc<Vector3>
    {
        public AnimVector3();
        public AnimVector3(Vector3 value);
        public AnimVector3(Vector3 value, UnityAction callback);

        protected override Vector3 GetValue();
    }
}
using UnityEngine.Events;

namespace UnityEditor.AnimatedValues
{
    public class AnimBool : BaseAnimValueNonAlloc<bool>
    {
        public AnimBool();
        public AnimBool(bool value);
        public AnimBool(UnityAction callback);
        public AnimBool(bool value, UnityAction callback);

        public float faded { get; }

        protected override bool GetValue();
        public float Fade(float from, float to);
    }
}
using UnityEngine;
using UnityEngine.Events;

namespace UnityEditor.AnimatedValues
{
    public class AnimQuaternion : BaseAnimValueNonAlloc<Quaternion>
    {
        public AnimQuaternion(Quaternion value);
        public AnimQuaternion(Quaternion value, UnityAction callback);

        protected override Quaternion GetValue();
    }
}
using UnityEngine;

namespace UnityEditor.IMGUI.Controls
{
    public class ArcHandle
    {
        public ArcHandle();

        ~ArcHandle();

        public float angle { get; set; }
        public float radius { get; set; }
        public Color angleHandleColor { get; set; }
        public Color radiusHandleColor { get; set; }
        public Color fillColor { get; set; }
        public Color wireframeColor { get; set; }
        public Handles.CapFunction angleHandleDrawFunction { get; set; }
        public Handles.SizeFunction angleHandleSizeFunction { get; set; }
        public Handles.CapFunction radiusHandleDrawFunction { get; set; }
        public Handles.SizeFunction radiusHandleSizeFunction { get; set; }

        public static void DefaultAngleHandleDrawFunction(int controlID, Vector3 position, Quaternion rotation, float size, EventType eventType);
        public static float DefaultAngleHandleSizeFunction(Vector3 position);
        public static float DefaultRadiusHandleSizeFunction(Vector3 position);
        public void SetColorWithoutRadiusHandle(Color color, float fillColorAlpha);
        public void SetColorWithRadiusHandle(Color color, float fillColorAlpha);
        public void DrawHandle();
    }
}
using UnityEngine;

namespace UnityEditor.IMGUI.Controls
{
    public class JointAngularLimitHandle
    {
        public JointAngularLimitHandle();

        public float xMin { get; set; }
        public float xMax { get; set; }
        public float yMin { get; set; }
        public float yMax { get; set; }
        public float zMin { get; set; }
        public float zMax { get; set; }
        public Vector2 xRange { get; set; }
        public Vector2 yRange { get; set; }
        public Vector2 zRange { get; set; }
        public ConfigurableJointMotion xMotion { get; set; }
        public ConfigurableJointMotion yMotion { get; set; }
        public ConfigurableJointMotion zMotion { get; set; }
        public Color xHandleColor { get; set; }
        public Color yHandleColor { get; set; }
        public Color zHandleColor { get; set; }
        public float radius { get; set; }
        public float fillAlpha { get; set; }
        public float wireframeAlpha { get; set; }
        public Handles.CapFunction angleHandleDrawFunction { get; set; }
        public Handles.SizeFunction angleHandleSizeFunction { get; set; }

        public void DrawHandle();
    }
}
using System;
using UnityEngine;

namespace UnityEditor.IMGUI.Controls
{
    public class BoxBoundsHandle : PrimitiveBoundsHandle
    {
        [Obsolete("Use parameterless constructor instead.")]
        public BoxBoundsHandle(int controlIDHint);
        public BoxBoundsHandle();

        public Vector3 size { get; set; }

        protected override void DrawWireframe();
    }
}
using System;
using UnityEngine;

namespace UnityEditor.IMGUI.Controls
{
    public class CapsuleBoundsHandle : PrimitiveBoundsHandle
    {
        [Obsolete("Use parameterless constructor instead.")]
        public CapsuleBoundsHandle(int controlIDHint);
        public CapsuleBoundsHandle();

        public HeightAxis heightAxis { get; set; }
        public float height { get; set; }
        public float radius { get; set; }

        protected override void DrawWireframe();
        protected override Bounds OnHandleChanged(PrimitiveBoundsHandle.HandleDirection handle, Bounds boundsOnClick, Bounds newBounds);

        public enum HeightAxis
        {
            X = 0,
            Y = 1,
            Z = 2
        }
    }
}
using System;
using UnityEngine;

namespace UnityEditor.IMGUI.Controls
{
    public abstract class PrimitiveBoundsHandle
    {
        [Obsolete("Use parameterless constructor instead.")]
        public PrimitiveBoundsHandle(int controlIDHint);
        public PrimitiveBoundsHandle();

        public Vector3 center { get; set; }
        public Axes axes { get; set; }
        public Color handleColor { get; set; }
        public Color wireframeColor { get; set; }
        public Handles.CapFunction midpointHandleDrawFunction { get; set; }
        public Handles.SizeFunction midpointHandleSizeFunction { get; set; }

        public static float DefaultMidpointHandleSizeFunction(Vector3 position);
        public void SetColor(Color color);
        public void DrawHandle();
        protected abstract void DrawWireframe();
        protected virtual Bounds OnHandleChanged(HandleDirection handle, Bounds boundsOnClick, Bounds newBounds);
        protected Vector3 GetSize();
        protected void SetSize(Vector3 size);
        protected bool IsAxisEnabled(Axes axis);
        protected bool IsAxisEnabled(int vector3Axis);

        [Flags]
        public enum Axes
        {
            None = 0,
            X = 1,
            Y = 2,
            Z = 4,
            All = 7
        }
        protected enum HandleDirection
        {
            PositiveX = 0,
            NegativeX = 1,
            PositiveY = 2,
            NegativeY = 3,
            PositiveZ = 4,
            NegativeZ = 5
        }
    }
}
using System;
using UnityEngine;

namespace UnityEditor.IMGUI.Controls
{
    public class SphereBoundsHandle : PrimitiveBoundsHandle
    {
        [Obsolete("Use parameterless constructor instead.")]
        public SphereBoundsHandle(int controlIDHint);
        public SphereBoundsHandle();

        public float radius { get; set; }

        protected override void DrawWireframe();
        protected override Bounds OnHandleChanged(PrimitiveBoundsHandle.HandleDirection handle, Bounds boundsOnClick, Bounds newBounds);
    }
}
using UnityEngine;

namespace UnityEditor.IMGUI.Controls
{
    public class SearchField
    {
        public SearchField();

        public int searchFieldControlID { get; set; }
        public bool autoSetFocusOnFindCommand { get; set; }

        public event SearchFieldCallback downOrUpArrowKeyPressed;

        public void SetFocus();
        public bool HasFocus();
        public string OnGUI(Rect rect, string text, GUIStyle style, GUIStyle cancelButtonStyle, GUIStyle emptyCancelButtonStyle);
        public string OnGUI(Rect rect, string text);
        public string OnGUI(string text, params GUILayoutOption[] options);
        public string OnToolbarGUI(Rect rect, string text);
        public string OnToolbarGUI(string text, params GUILayoutOption[] options);

        public delegate void SearchFieldCallback();
    }
}
using UnityEngine;

namespace UnityEditor.IMGUI.Controls
{
    public class MultiColumnHeader
    {
        public MultiColumnHeader(MultiColumnHeaderState state);

        public int sortedColumnIndex { get; set; }
        public MultiColumnHeaderState state { get; set; }
        public float height { get; set; }
        public bool canSort { get; set; }

        public event HeaderCallback sortingChanged;
        public event HeaderCallback visibleColumnsChanged;

        public void SetSortingColumns(int[] columnIndices, bool[] sortAscending);
        public void SetSorting(int columnIndex, bool sortAscending);
        public void SetSortDirection(int columnIndex, bool sortAscending);
        public bool IsSortedAscending(int columnIndex);
        public MultiColumnHeaderState.Column GetColumn(int columnIndex);
        public bool IsColumnVisible(int columnIndex);
        public int GetVisibleColumnIndex(int columnIndex);
        public Rect GetCellRect(int visibleColumnIndex, Rect rowRect);
        public Rect GetColumnRect(int visibleColumnIndex);
        public void ResizeToFit();
        public virtual void OnGUI(Rect rect, float xScroll);
        protected virtual void ColumnHeaderClicked(MultiColumnHeaderState.Column column, int columnIndex);
        protected virtual void OnSortingChanged();
        protected virtual void ColumnHeaderGUI(MultiColumnHeaderState.Column column, Rect headerRect, int columnIndex);
        protected void SortingButton(MultiColumnHeaderState.Column column, Rect headerRect, int columnIndex);
        protected virtual void AddColumnHeaderContextMenuItems(GenericMenu menu);
        protected virtual void OnVisibleColumnsChanged();
        protected virtual void ToggleVisibility(int columnIndex);
        public void Repaint();

        public delegate void HeaderCallback(MultiColumnHeader multiColumnHeader);
        public static class DefaultGUI
        {
            public static float defaultHeight { get; }
            public static float minimumHeight { get; }
            public static float columnContentMargin { get; }
        }
        public static class DefaultStyles
        {
            public static GUIStyle columnHeader;
            public static GUIStyle columnHeaderRightAligned;
            public static GUIStyle columnHeaderCenterAligned;
            public static GUIStyle background;
        }
    }
}
using UnityEngine;

namespace UnityEditor.IMGUI.Controls
{
    public class MultiColumnHeaderState
    {
        public MultiColumnHeaderState(Column[] columns);

        public int sortedColumnIndex { get; set; }
        public int maximumNumberOfSortedColumns { get; set; }
        public int[] sortedColumns { get; set; }
        public Column[] columns { get; }
        public int[] visibleColumns { get; set; }
        public float widthOfAllVisibleColumns { get; }

        public static bool CanOverwriteSerializedFields(MultiColumnHeaderState source, MultiColumnHeaderState destination);
        public static void OverwriteSerializedFields(MultiColumnHeaderState source, MultiColumnHeaderState destination);

        public class Column
        {
            [SerializeField]
            public float width;
            [SerializeField]
            public bool sortedAscending;
            public GUIContent headerContent;
            public string contextMenuText;
            public TextAlignment headerTextAlignment;
            public TextAlignment sortingArrowAlignment;
            public float minWidth;
            public float maxWidth;
            public bool autoResize;
            public bool allowToggleVisibility;
            public bool canSort;

            public Column();
        }
    }
}
using System.Collections.Generic;
using UnityEngine;

namespace UnityEditor.IMGUI.Controls
{
    public class TreeViewState
    {
        public Vector2 scrollPos;

        public TreeViewState();

        public List<int> selectedIDs { get; set; }
        public int lastClickedID { get; set; }
        public List<int> expandedIDs { get; set; }
        public string searchString { get; set; }
    }
}
using System;
using System.Collections.Generic;
using UnityEngine;

namespace UnityEditor.IMGUI.Controls
{
    public class TreeViewItem : IComparable<TreeViewItem>
    {
        public TreeViewItem();
        public TreeViewItem(int id);
        public TreeViewItem(int id, int depth);
        public TreeViewItem(int id, int depth, string displayName);

        public virtual int id { get; set; }
        public virtual string displayName { get; set; }
        public virtual int depth { get; set; }
        public virtual bool hasChildren { get; }
        public virtual List<TreeViewItem> children { get; set; }
        public virtual TreeViewItem parent { get; set; }
        public virtual Texture2D icon { get; set; }

        public void AddChild(TreeViewItem child);
        public virtual int CompareTo(TreeViewItem other);
        public override string ToString();
    }
}
using System.Collections.Generic;
using UnityEngine;

namespace UnityEditor.IMGUI.Controls
{
    public abstract class TreeView
    {
        public TreeView(TreeViewState state);
        public TreeView(TreeViewState state, MultiColumnHeader multiColumnHeader);

        protected GetNewSelectionFunction getNewSelectionOverride { set; }
        protected DoFoldoutCallback foldoutOverride { get; set; }
        public TreeViewState state { get; }
        public MultiColumnHeader multiColumnHeader { get; set; }
        protected TreeViewItem rootItem { get; }
        protected bool isInitialized { get; }
        protected Rect treeViewRect { get; set; }
        protected float baseIndent { get; set; }
        protected float foldoutWidth { get; }
        protected float extraSpaceBeforeIconAndLabel { get; set; }
        protected float customFoldoutYOffset { get; set; }
        protected int columnIndexForTreeFoldouts { get; set; }
        protected bool useScrollView { get; set; }
        protected float depthIndentWidth { get; set; }
        protected bool showAlternatingRowBackgrounds { get; set; }
        protected bool showBorder { get; set; }
        protected bool showingHorizontalScrollBar { get; }
        protected bool showingVerticalScrollBar { get; }
        protected float cellMargin { get; set; }
        public float totalHeight { get; }
        protected float rowHeight { get; set; }
        public int treeViewControlID { get; set; }
        protected bool isDragging { get; }
        public bool hasSearch { get; }
        public string searchString { get; set; }

        protected abstract TreeViewItem BuildRoot();
        protected virtual IList<TreeViewItem> BuildRows(TreeViewItem root);
        public void Reload();
        public void Repaint();
        protected Rect GetCellRectForTreeFoldouts(Rect rowRect);
        protected Rect GetRowRect(int row);
        public virtual IList<TreeViewItem> GetRows();
        protected IList<TreeViewItem> FindRows(IList<int> ids);
        protected TreeViewItem FindItem(int id, TreeViewItem searchFromThisItem);
        protected int FindRowOfItem(TreeViewItem item);
        protected void GetFirstAndLastVisibleRows(out int firstRowVisible, out int lastRowVisible);
        public void ExpandAll();
        public void CollapseAll();
        public void SetExpandedRecursive(int id, bool expanded);
        public bool SetExpanded(int id, bool expanded);
        public void SetExpanded(IList<int> ids);
        public IList<int> GetExpanded();
        public bool IsExpanded(int id);
        public IList<int> GetSelection();
        public void SetSelection(IList<int> selectedIDs);
        public void SetSelection(IList<int> selectedIDs, TreeViewSelectionOptions options);
        public bool IsSelected(int id);
        public bool HasSelection();
        public bool HasFocus();
        public void SetFocus();
        public void SetFocusAndEnsureSelectedItem();
        protected void SelectionClick(TreeViewItem item, bool keepMultiSelection);
        public bool BeginRename(TreeViewItem item);
        public bool BeginRename(TreeViewItem item, float delay);
        public void EndRename();
        public void FrameItem(int id);
        public virtual void OnGUI(Rect rect);
        public void SelectAllRows();
        protected float GetFoldoutIndent(TreeViewItem item);
        protected float GetContentIndent(TreeViewItem item);
        protected IList<int> SortItemIDsInRowOrder(IList<int> ids);
        protected void CenterRectUsingSingleLineHeight(ref Rect rect);
        protected void AddExpandedRows(TreeViewItem root, IList<TreeViewItem> rows);
        protected virtual void SelectionChanged(IList<int> selectedIds);
        protected virtual void SingleClickedItem(int id);
        protected virtual void DoubleClickedItem(int id);
        protected virtual void ContextClickedItem(int id);
        protected virtual void ContextClicked();
        protected virtual void ExpandedStateChanged();
        protected virtual void SearchChanged(string newSearch);
        protected virtual void KeyEvent();
        protected virtual IList<int> GetAncestors(int id);
        protected virtual IList<int> GetDescendantsThatHaveChildren(int id);
        protected virtual bool CanMultiSelect(TreeViewItem item);
        protected virtual bool CanRename(TreeViewItem item);
        protected virtual void RenameEnded(RenameEndedArgs args);
        protected virtual bool CanStartDrag(CanStartDragArgs args);
        protected virtual void SetupDragAndDrop(SetupDragAndDropArgs args);
        protected virtual DragAndDropVisualMode HandleDragAndDrop(DragAndDropArgs args);
        protected virtual bool CanBeParent(TreeViewItem item);
        protected virtual bool CanChangeExpandedState(TreeViewItem item);
        protected virtual bool DoesItemMatchSearch(TreeViewItem item, string search);
        protected virtual void RowGUI(RowGUIArgs args);
        protected virtual void BeforeRowsGUI();
        protected virtual void AfterRowsGUI();
        protected virtual void RefreshCustomRowHeights();
        protected virtual float GetCustomRowHeight(int row, TreeViewItem item);
        protected virtual Rect GetRenameRect(Rect rowRect, int row, TreeViewItem item);
        protected virtual void CommandEventHandling();
        protected static void SetupParentsAndChildrenFromDepths(TreeViewItem root, IList<TreeViewItem> rows);
        protected static void SetupDepthsFromParentsAndChildren(TreeViewItem root);
        protected static List<TreeViewItem> CreateChildListForCollapsedParent();
        protected static bool IsChildListForACollapsedParent(IList<TreeViewItem> childList);

        public delegate bool DoFoldoutCallback(Rect position, bool expandedState, GUIStyle style);
        public delegate List<int> GetNewSelectionFunction(TreeViewItem clickedItem, bool keepMultiSelection, bool useActionKeyAsShift);
        protected struct RowGUIArgs
        {
            public TreeViewItem item;
            public string label;
            public Rect rowRect;
            public int row;
            public bool selected;
            public bool focused;
            public bool isRenaming;

            public int GetNumVisibleColumns();
            public int GetColumn(int visibleColumnIndex);
            public Rect GetCellRect(int visibleColumnIndex);
        }
        protected struct DragAndDropArgs
        {
            public DragAndDropPosition dragAndDropPosition;
            public TreeViewItem parentItem;
            public int insertAtIndex;
            public bool performDrop;
        }
        protected struct SetupDragAndDropArgs
        {
            public IList<int> draggedItemIDs;
        }
        protected struct CanStartDragArgs
        {
            public TreeViewItem draggedItem;
            public IList<int> draggedItemIDs;
        }
        protected struct RenameEndedArgs
        {
            public bool acceptedRename;
            public int itemID;
            public string originalName;
            public string newName;
        }
        protected enum DragAndDropPosition
        {
            UponItem = 0,
            BetweenItems = 1,
            OutsideItems = 2
        }
        public static class DefaultGUI
        {
            public static void FoldoutLabel(Rect rect, string label, bool selected, bool focused);
            public static void Label(Rect rect, string label, bool selected, bool focused);
            public static void LabelRightAligned(Rect rect, string label, bool selected, bool focused);
            public static void BoldLabel(Rect rect, string label, bool selected, bool focused);
            public static void BoldLabelRightAligned(Rect rect, string label, bool selected, bool focused);
        }
        public static class DefaultStyles
        {
            public static GUIStyle foldoutLabel;
            public static GUIStyle label;
            public static GUIStyle labelRightAligned;
            public static GUIStyle boldLabel;
            public static GUIStyle boldLabelRightAligned;
            public static GUIStyle backgroundEven;
            public static GUIStyle backgroundOdd;
        }
    }
}
using System;

namespace UnityEditor.IMGUI.Controls
{
    [Flags]
    public enum TreeViewSelectionOptions
    {
        None = 0,
        FireSelectionChanged = 1,
        RevealAndFrame = 2
    }
}
using System;
using System.Collections.Generic;
using UnityEngine;

namespace UnityEditor.IMGUI.Controls
{
    public class AdvancedDropdownItem : IComparable
    {
        public AdvancedDropdownItem(string name);

        public string name { get; set; }
        public Texture2D icon { get; set; }
        public int id { get; set; }
        public bool enabled { get; set; }
        public IEnumerable<AdvancedDropdownItem> children { get; }

        public void AddChild(AdvancedDropdownItem child);
        public virtual int CompareTo(object o);
        public void AddSeparator();
        public override string ToString();
    }
}
namespace UnityEditor.IMGUI.Controls
{
    public class AdvancedDropdownState
    {
        public AdvancedDropdownState();
    }
}
using UnityEngine;

namespace UnityEditor.IMGUI.Controls
{
    public abstract class AdvancedDropdown
    {
        public AdvancedDropdown(AdvancedDropdownState state);

        protected Vector2 minimumSize { get; set; }

        public void Show(Rect rect);
        protected abstract AdvancedDropdownItem BuildRoot();
        protected virtual void ItemSelected(AdvancedDropdownItem item);
    }
}
namespace UnityEditor.VisualStudioIntegration
{
    public static class SolutionGuidGenerator
    {
        public static string GuidForProject(string projectName);
        public static string GuidForSolution(string projectName, string sourceFileExtension);
    }
}
namespace UnityEditor.UnityLinker
{
    public sealed class UnityLinkerBuildPipelineData
    {
        public readonly BuildTarget target;
        public readonly string inputDirectory;

        public UnityLinkerBuildPipelineData(BuildTarget target, string inputDirectory);
    }
}
namespace UnityEditor.Il2Cpp
{
    public sealed class Il2CppBuildPipelineData
    {
        public readonly BuildTarget target;
        public readonly string inputDirectory;

        public Il2CppBuildPipelineData(BuildTarget target, string inputDirectory);
    }
}
using UnityEditor.Build;

namespace UnityEditor.Android
{
    public interface IPostGenerateGradleAndroidProject : IOrderedCallback
    {
        void OnPostGenerateGradleAndroidProject(string path);
    }
}
using System;
using UnityEngine.Scripting;

namespace UnityEditor.Build
{
    [RequiredByNativeCode]
    public class BuildFailedException : Exception
    {
        public BuildFailedException(string message);
        public BuildFailedException(Exception innerException);
    }
}
namespace UnityEditor.Build
{
    public interface IOrderedCallback
    {
        int callbackOrder { get; }
    }
}
using System;

namespace UnityEditor.Build
{
    [Obsolete("Use IPreprocessBuildWithReport instead")]
    public interface IPreprocessBuild : IOrderedCallback
    {
        void OnPreprocessBuild(BuildTarget target, string path);
    }
}
using UnityEditor.Build.Reporting;

namespace UnityEditor.Build
{
    public interface IPreprocessBuildWithReport : IOrderedCallback
    {
        void OnPreprocessBuild(BuildReport report);
    }
}
namespace UnityEditor.Build
{
    public interface IFilterBuildAssemblies : IOrderedCallback
    {
        string[] OnFilterAssemblies(BuildOptions buildOptions, string[] assemblies);
    }
}
using System;

namespace UnityEditor.Build
{
    [Obsolete("Use IPostprocessBuildWithReport instead")]
    public interface IPostprocessBuild : IOrderedCallback
    {
        void OnPostprocessBuild(BuildTarget target, string path);
    }
}
using UnityEditor.Build.Reporting;

namespace UnityEditor.Build
{
    public interface IPostprocessBuildWithReport : IOrderedCallback
    {
        void OnPostprocessBuild(BuildReport report);
    }
}
using UnityEditor.Build.Reporting;

namespace UnityEditor.Build
{
    public interface IPostBuildPlayerScriptDLLs : IOrderedCallback
    {
        void OnPostBuildPlayerScriptDLLs(BuildReport report);
    }
}
using System;
using UnityEngine.SceneManagement;

namespace UnityEditor.Build
{
    [Obsolete("Use IProcessSceneWithReport instead")]
    public interface IProcessScene : IOrderedCallback
    {
        void OnProcessScene(Scene scene);
    }
}
using UnityEditor.Build.Reporting;
using UnityEngine.SceneManagement;

namespace UnityEditor.Build
{
    public interface IProcessSceneWithReport : IOrderedCallback
    {
        void OnProcessScene(Scene scene, BuildReport report);
    }
}
namespace UnityEditor.Build
{
    public interface IActiveBuildTargetChanged : IOrderedCallback
    {
        void OnActiveBuildTargetChanged(BuildTarget previousTarget, BuildTarget newTarget);
    }
}
using System.Collections.Generic;
using UnityEditor.Rendering;
using UnityEngine;

namespace UnityEditor.Build
{
    public interface IPreprocessShaders : IOrderedCallback
    {
        void OnProcessShader(Shader shader, ShaderSnippetData snippet, IList<ShaderCompilerData> data);
    }
}
using System.Collections.Generic;
using UnityEditor.Rendering;
using UnityEngine;

namespace UnityEditor.Build
{
    public interface IPreprocessComputeShaders : IOrderedCallback
    {
        void OnProcessComputeShader(ComputeShader shader, string kernelName, IList<ShaderCompilerData> data);
    }
}
using UnityEditor.Build.Reporting;
using UnityEditor.UnityLinker;

namespace UnityEditor.Build
{
    public interface IUnityLinkerProcessor : IOrderedCallback
    {
        string GenerateAdditionalLinkXmlFile(BuildReport report, UnityLinkerBuildPipelineData data);
        void OnBeforeRun(BuildReport report, UnityLinkerBuildPipelineData data);
        void OnAfterRun(BuildReport report, UnityLinkerBuildPipelineData data);
    }
}
using UnityEditor.Build.Reporting;
using UnityEditor.Il2Cpp;

namespace UnityEditor.Build
{
    public interface IIl2CppProcessor : IOrderedCallback
    {
        void OnBeforeConvertRun(BuildReport report, Il2CppBuildPipelineData data);
    }
}
using UnityEngine.Bindings;

namespace UnityEditor.Build.Reporting
{
    [NativeType(Header = "Modules/BuildReportingEditor/Public/BuildReport.h")]
    public struct BuildFile
    {
        public uint id { get; }
        public string path { get; }
        public string role { get; }
        [NativeName("totalSize")]
        public ulong size { get; }

        public override string ToString();
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor.Build.Reporting
{
    [NativeHeader("Runtime/Utilities/DateTime.h")]
    [NativeType(Header = "Modules/BuildReportingEditor/Public/BuildReport.h")]
    [NativeClass("BuildReporting::BuildReport")]
    public sealed class BuildReport : Object
    {
        public BuildFile[] files { get; }
        [NativeName("BuildSteps")]
        public BuildStep[] steps { get; }
        public BuildSummary summary { get; }
        public StrippingInfo strippingInfo { get; }
        public PackedAssets[] packedAssets { get; }
        public ScenesUsingAssets[] scenesUsingAssets { get; }
    }
}
namespace UnityEditor.Build.Reporting
{
    public enum BuildResult
    {
        Unknown = 0,
        Succeeded = 1,
        Failed = 2,
        Cancelled = 3
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEditor.Build.Reporting
{
    [NativeType(Header = "Modules/BuildReportingEditor/Public/BuildReport.h")]
    public struct BuildStep
    {
        [NativeName("stepName")]
        public string name { get; }
        public TimeSpan duration { get; }
        public BuildStepMessage[] messages { get; }
        public int depth { get; }

        public override string ToString();
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor.Build.Reporting
{
    [NativeType(Header = "Modules/BuildReportingEditor/Public/BuildReport.h")]
    public struct BuildStepMessage
    {
        public LogType type { get; }
        public string content { get; }
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEditor.Build.Reporting
{
    [NativeType(Header = "Modules/BuildReportingEditor/Managed/BuildSummary.bindings.h", CodegenOptions = Custom)]
    public struct BuildSummary
    {
        public DateTime buildStartedAt { get; }
        [NativeName("buildGUID")]
        public GUID guid { get; }
        public BuildTarget platform { get; }
        public BuildTargetGroup platformGroup { get; }
        public BuildOptions options { get; }
        public string outputPath { get; }
        public ulong totalSize { get; }
        public TimeSpan totalTime { get; }
        public DateTime buildEndedAt { get; }
        public int totalErrors { get; }
        public int totalWarnings { get; }
        [NativeName("buildResult")]
        public BuildResult result { get; }
    }
}
using UnityEngine.Bindings;

namespace UnityEditor.Build.Reporting
{
    [NativeType(Header = "Modules/BuildReportingEditor/Public/CommonRoles.h")]
    public static class CommonRoles
    {
        [NativeProperty("BuildReporting::CommonRoles::scene", True, Field)]
        public static string scene { get; }
        [NativeProperty("BuildReporting::CommonRoles::sharedAssets", True, Field)]
        public static string sharedAssets { get; }
        [NativeProperty("BuildReporting::CommonRoles::resourcesFile", True, Field)]
        public static string resourcesFile { get; }
        [NativeProperty("BuildReporting::CommonRoles::assetBundle", True, Field)]
        public static string assetBundle { get; }
        [NativeProperty("BuildReporting::CommonRoles::manifestAssetBundle", True, Field)]
        public static string manifestAssetBundle { get; }
        [NativeProperty("BuildReporting::CommonRoles::assetBundleTextManifest", True, Field)]
        public static string assetBundleTextManifest { get; }
        [NativeProperty("BuildReporting::CommonRoles::managedLibrary", True, Field)]
        public static string managedLibrary { get; }
        [NativeProperty("BuildReporting::CommonRoles::dependentManagedLibrary", True, Field)]
        public static string dependentManagedLibrary { get; }
        [NativeProperty("BuildReporting::CommonRoles::executable", True, Field)]
        public static string executable { get; }
        [NativeProperty("BuildReporting::CommonRoles::streamingResourceFile", True, Field)]
        public static string streamingResourceFile { get; }
        [NativeProperty("BuildReporting::CommonRoles::streamingAsset", True, Field)]
        public static string streamingAsset { get; }
        [NativeProperty("BuildReporting::CommonRoles::bootConfig", True, Field)]
        public static string bootConfig { get; }
        [NativeProperty("BuildReporting::CommonRoles::builtInResources", True, Field)]
        public static string builtInResources { get; }
        [NativeProperty("BuildReporting::CommonRoles::builtInShaders", True, Field)]
        public static string builtInShaders { get; }
        [NativeProperty("BuildReporting::CommonRoles::appInfo", True, Field)]
        public static string appInfo { get; }
        [NativeProperty("BuildReporting::CommonRoles::managedEngineAPI", True, Field)]
        public static string managedEngineApi { get; }
        [NativeProperty("BuildReporting::CommonRoles::monoRuntime", True, Field)]
        public static string monoRuntime { get; }
        [NativeProperty("BuildReporting::CommonRoles::monoConfig", True, Field)]
        public static string monoConfig { get; }
        [NativeProperty("BuildReporting::CommonRoles::debugInfo", True, Field)]
        public static string debugInfo { get; }
        [NativeProperty("BuildReporting::CommonRoles::globalGameManagers", True, Field)]
        public static string globalGameManagers { get; }
        [NativeProperty("BuildReporting::CommonRoles::crashHandler", True, Field)]
        public static string crashHandler { get; }
        [NativeProperty("BuildReporting::CommonRoles::engineLibrary", True, Field)]
        public static string engineLibrary { get; }
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEditor.Build.Reporting
{
    [NativeType(Header = "Modules/BuildReportingEditor/Public/PackedAssets.h")]
    public struct PackedAssetInfo
    {
        [NativeName("fileID")]
        public long id { get; }
        public Type type { get; }
        public ulong packedSize { get; }
        public ulong offset { get; }
        public GUID sourceAssetGUID { get; }
        [NativeName("buildTimeAssetPath")]
        public string sourceAssetPath { get; }
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor.Build.Reporting
{
    [NativeClass("BuildReporting::PackedAssets")]
    [NativeType(Header = "Modules/BuildReportingEditor/Public/PackedAssets.h")]
    public sealed class PackedAssets : Object
    {
        public PackedAssets();

        public uint file { get; }
        public string shortPath { get; }
        public ulong overhead { get; }
        public PackedAssetInfo[] contents { get; }
    }
}
using UnityEngine.Bindings;

namespace UnityEditor.Build.Reporting
{
    [NativeType(Header = "Modules/BuildReportingEditor/Public/ScenesUsingAssets.h")]
    public struct ScenesUsingAsset
    {
        public string assetPath { get; }
        public string[] scenePaths { get; }
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor.Build.Reporting
{
    [NativeType(Header = "Modules/BuildReportingEditor/Public/ScenesUsingAssets.h")]
    [NativeClass("BuildReporting::ScenesUsingAssets")]
    public sealed class ScenesUsingAssets : Object
    {
        public ScenesUsingAssets();

        public ScenesUsingAsset[] list { get; }
    }
}
using System.Collections.Generic;
using UnityEngine;

namespace UnityEditor.Build.Reporting
{
    public class StrippingInfo : ScriptableObject, ISerializationCallbackReceiver
    {
        public StrippingInfo();

        public IEnumerable<string> includedModules { get; }

        public IEnumerable<string> GetReasonsForIncluding(string entityName);
    }
}
namespace UnityEditor.Build.Player
{
    public enum ScriptCompilationOptions
    {
        None = 0,
        DevelopmentBuild = 1,
        Assertions = 2
    }
}
using UnityEngine.Scripting;

namespace UnityEditor.Build.Player
{
    [UsedByNativeCode]
    public struct ScriptCompilationSettings
    {
        public BuildTarget target { get; set; }
        public BuildTargetGroup group { get; set; }
        public ScriptCompilationOptions options { get; set; }
        public string[] extraScriptingDefines { get; set; }
    }
}
using System.Collections.ObjectModel;
using UnityEngine.Scripting;

namespace UnityEditor.Build.Player
{
    [UsedByNativeCode]
    public struct ScriptCompilationResult
    {
        public ReadOnlyCollection<string> assemblies { get; }
        public TypeDB typeDB { get; }
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.Bindings;

namespace UnityEditor.Build.Player
{
    [NativeHeader("Modules/BuildPipeline/Editor/Public/PlayerBuildInterface.h")]
    public static class PlayerBuildInterface
    {
        public static Func<IEnumerable<string>> ExtraTypesProvider;

        public static ScriptCompilationResult CompilePlayerScripts(ScriptCompilationSettings input, string outputFolder);
    }
}
namespace UnityEditor.Build.Player
{
    public static class TypeDbHelper
    {
        public static bool TryGet(string path, out TypeDB typeDb);
    }
}
using System;
using System.Runtime.Serialization;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.Build.Player
{
    [UsedByNativeCode]
    [NativeHeader("Modules/BuildPipeline/Editor/Public/TypeDB.h")]
    public class TypeDB : IDisposable, ISerializable
    {
        protected TypeDB(SerializationInfo info, StreamingContext context);

        ~TypeDB();

        public void Dispose();
        protected virtual void Dispose(bool disposing);
        [NativeMethod(IsThreadSafe = True)]
        public Hash128 GetHash128();
        public override bool Equals(object obj);
        public override int GetHashCode();
        public void GetObjectData(SerializationInfo info, StreamingContext context);
    }
}
using UnityEngine.Scripting;

namespace UnityEditor.Build.Content
{
    [UsedByNativeCode]
    public struct SerializedLocation
    {
        public string fileName { get; }
        public ulong offset { get; }
        public ulong size { get; }
    }
}
using UnityEngine.Scripting;

namespace UnityEditor.Build.Content
{
    [UsedByNativeCode]
    public struct ObjectSerializedInfo
    {
        public ObjectIdentifier serializedObject { get; }
        public SerializedLocation header { get; }
        public SerializedLocation rawData { get; }
    }
}
using System;
using System.Collections.ObjectModel;
using UnityEngine.Scripting;

namespace UnityEditor.Build.Content
{
    [UsedByNativeCode]
    public struct WriteResult
    {
        public ReadOnlyCollection<ObjectSerializedInfo> serializedObjects { get; }
        public ReadOnlyCollection<ResourceFile> resourceFiles { get; }
        public ReadOnlyCollection<Type> includedTypes { get; }
        public ReadOnlyCollection<string> includedSerializeReferenceFQN { get; }
    }
}
using System;
using System.Runtime.Serialization;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.Build.Content
{
    [NativeHeader("Modules/BuildPipeline/Editor/Public/BuildReferenceMap.h")]
    [UsedByNativeCode]
    public class BuildReferenceMap : IDisposable, ISerializable
    {
        public BuildReferenceMap();
        protected BuildReferenceMap(System.Runtime.Serialization.SerializationInfo info, StreamingContext context);

        ~BuildReferenceMap();

        public void Dispose();
        protected virtual void Dispose(bool disposing);
        [NativeMethod(IsThreadSafe = True)]
        public Hash128 GetHash128();
        public void AddMapping(string internalFileName, long serializationIndex, ObjectIdentifier objectID, bool overwrite = False);
        public void AddMappings(string internalFileName, SerializationInfo[] objectIDs, bool overwrite = False);
        [NativeMethod(IsThreadSafe = True)]
        public void FilterToSubset(ObjectIdentifier[] objectIds);
        public override bool Equals(object obj);
        public override int GetHashCode();
        public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, StreamingContext context);
    }
}
using System;

namespace UnityEditor.Build.Content
{
    [Flags]
    public enum ContentBuildFlags
    {
        None = 0,
        DisableWriteTypeTree = 1,
        StripUnityVersion = 2,
        DevelopmentBuild = 4
    }
}
using UnityEditor.Build.Player;
using UnityEngine.Scripting;

namespace UnityEditor.Build.Content
{
    [UsedByNativeCode]
    public struct BuildSettings
    {
        public TypeDB typeDB { get; set; }
        public BuildTarget target { get; set; }
        public BuildTargetGroup group { get; set; }
        public ContentBuildFlags buildFlags { get; set; }
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.Build.Content
{
    [NativeHeader("Modules/BuildPipeline/Editor/Public/BuildUsageCache.h")]
    [UsedByNativeCode]
    public class BuildUsageCache : IDisposable
    {
        public BuildUsageCache();

        ~BuildUsageCache();

        public void Dispose();
        protected virtual void Dispose(bool disposing);
    }
}
using UnityEngine.Scripting;

namespace UnityEditor.Build.Content
{
    [UsedByNativeCode]
    public struct BuildUsageTagGlobal
    {
        public static BuildUsageTagGlobal operator |(BuildUsageTagGlobal x, BuildUsageTagGlobal y);
    }
}
using System;
using System.Runtime.Serialization;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.Build.Content
{
    [UsedByNativeCode]
    [NativeHeader("Modules/BuildPipeline/Editor/Public/BuildUsageTagSet.h")]
    public class BuildUsageTagSet : IDisposable, ISerializable
    {
        public BuildUsageTagSet();
        protected BuildUsageTagSet(System.Runtime.Serialization.SerializationInfo info, StreamingContext context);

        ~BuildUsageTagSet();

        public void Dispose();
        protected virtual void Dispose(bool disposing);
        [NativeMethod(IsThreadSafe = True)]
        public Hash128 GetHash128();
        [NativeMethod(IsThreadSafe = True)]
        public ObjectIdentifier[] GetObjectIdentifiers();
        [NativeMethod(IsThreadSafe = True)]
        public void UnionWith(BuildUsageTagSet other);
        [NativeMethod(IsThreadSafe = True)]
        public void FilterToSubset(ObjectIdentifier[] objectIds);
        public override bool Equals(object obj);
        public override int GetHashCode();
        public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, StreamingContext context);
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEditor.Build.Content
{
    [Flags]
    [NativeType("Modules/BuildPipeline/Editor/Shared/ContentDependencyCollector.h")]
    public enum DependencyType
    {
        RecursiveOperation = 1,
        MissingReferences = 2,
        ValidReferences = 4,
        DefaultDependencies = 5
    }
}
using System;
using UnityEditor.Build.Player;
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor.Build.Content
{
    [NativeHeader("Modules/BuildPipeline/Editor/Public/ContentBuildTypes.h")]
    [NativeHeader("Modules/BuildPipeline/Editor/Shared/ContentBuildInterface.bindings.h")]
    [NativeHeader("Modules/BuildPipeline/Editor/Public/BuildUtilities.h")]
    [NativeHeader("Modules/BuildPipeline/Editor/Public/ContentBuildInterfaceProfile.h")]
    [StaticAccessor("BuildPipeline", DoubleColon)]
    public static class ContentBuildInterface
    {
        public static AssetBundleBuild[] GenerateAssetBundleBuilds();
        public static BuildUsageTagGlobal GetGlobalUsageFromGraphicsSettings();
        public static BuildUsageTagGlobal GetGlobalUsageFromActiveScene(BuildTarget target);
        public static bool ObjectIsSupportedInBuild(UnityEngine.Object targetObject);
        public static SceneDependencyInfo CalculatePlayerDependenciesForScene(string scenePath, BuildSettings settings, BuildUsageTagSet usageSet);
        public static SceneDependencyInfo CalculatePlayerDependenciesForScene(string scenePath, BuildSettings settings, BuildUsageTagSet usageSet, BuildUsageCache usageCache);
        public static SceneDependencyInfo CalculatePlayerDependenciesForScene(string scenePath, BuildSettings settings, BuildUsageTagSet usageSet, BuildUsageCache usageCache, DependencyType mode);
        public static GameManagerDependencyInfo CalculatePlayerDependenciesForGameManagers(BuildSettings settings, BuildUsageTagGlobal globalUsage, BuildUsageTagSet usageSet);
        public static GameManagerDependencyInfo CalculatePlayerDependenciesForGameManagers(BuildSettings settings, BuildUsageTagGlobal globalUsage, BuildUsageTagSet usageSet, BuildUsageCache usageCache);
        public static GameManagerDependencyInfo CalculatePlayerDependenciesForGameManagers(BuildSettings settings, BuildUsageTagGlobal globalUsage, BuildUsageTagSet usageSet, BuildUsageCache usageCache, DependencyType mode);
        public static ObjectIdentifier[] GetPlayerObjectIdentifiersInAsset(GUID asset, BuildTarget target);
        public static ObjectIdentifier[] GetPlayerObjectIdentifiersInSerializedFile(string filePath, BuildTarget target);
        public static ObjectIdentifier[] GetPlayerDependenciesForObject(ObjectIdentifier objectID, BuildTarget target, TypeDB typeDB);
        public static ObjectIdentifier[] GetPlayerDependenciesForObject(ObjectIdentifier objectID, BuildTarget target, TypeDB typeDB, DependencyType mode);
        public static ObjectIdentifier[] GetPlayerDependenciesForObject(UnityEngine.Object targetObject, BuildTarget target, TypeDB typeDB);
        public static ObjectIdentifier[] GetPlayerDependenciesForObject(UnityEngine.Object targetObject, BuildTarget target, TypeDB typeDB, DependencyType mode);
        public static ObjectIdentifier[] GetPlayerDependenciesForObjects(ObjectIdentifier[] objectIDs, BuildTarget target, TypeDB typeDB);
        public static ObjectIdentifier[] GetPlayerDependenciesForObjects(ObjectIdentifier[] objectIDs, BuildTarget target, TypeDB typeDB, DependencyType mode);
        public static ObjectIdentifier[] GetPlayerDependenciesForObjects(UnityEngine.Object[] objects, BuildTarget target, TypeDB typeDB);
        public static ObjectIdentifier[] GetPlayerDependenciesForObjects(UnityEngine.Object[] objects, BuildTarget target, TypeDB typeDB, DependencyType mode);
        public static ObjectIdentifier[] GetPlayerAssetRepresentations(GUID asset, BuildTarget target);
        public static void CalculateBuildUsageTags(ObjectIdentifier[] objectIDs, ObjectIdentifier[] dependentObjectIDs, BuildUsageTagGlobal globalUsage, BuildUsageTagSet usageSet);
        public static void CalculateBuildUsageTags(ObjectIdentifier[] objectIDs, ObjectIdentifier[] dependentObjectIDs, BuildUsageTagGlobal globalUsage, BuildUsageTagSet usageSet, BuildUsageCache usageCache);
        public static Type GetTypeForObject(ObjectIdentifier objectID);
        public static Type[] GetTypesForObject(ObjectIdentifier objectID);
        public static Type[] GetTypeForObjects(ObjectIdentifier[] objectIDs);
        public static WriteResult WriteSerializedFile(string outputFolder, WriteParameters parameters);
        public static WriteResult WriteSceneSerializedFile(string outputFolder, WriteSceneParameters parameters);
        public static WriteResult WriteGameManagersSerializedFile(string outputFolder, WriteManagerParameters parameters);
        public static uint ArchiveAndCompress(ResourceFile[] resourceFiles, string outputBundlePath, UnityEngine.BuildCompression compression);
        [ThreadSafe]
        public static uint ArchiveAndCompress(ResourceFile[] resourceFiles, string outputBundlePath, UnityEngine.BuildCompression compression, bool stripUnityVersion);
        [NativeThrows]
        public static void StartProfileCapture(ProfileCaptureOptions options);
        [NativeThrows]
        public static ContentBuildProfileEvent[] StopProfileCapture();
        public static Hash128 CalculatePlayerSerializationHashForType(Type type, TypeDB typeDB);
        [Obsolete("ContentBuildInterface.PrepareScene has been deprecated. Use ContentBuildInterface.CalculatePlayerDependenciesForScene instead")]
        public static SceneDependencyInfo PrepareScene(string scenePath, BuildSettings settings, BuildUsageTagSet usageSet, string outputFolder);
        [Obsolete("ContentBuildInterface.PrepareScene has been deprecated. Use ContentBuildInterface.CalculatePlayerDependenciesForScene instead")]
        public static SceneDependencyInfo PrepareScene(string scenePath, BuildSettings settings, BuildUsageTagSet usageSet, BuildUsageCache usageCache, string outputFolder);
        [Obsolete("ContentBuildInterface.WriteSerializedFile has been deprecated. Use ContentBuildInterface.WriteSerializedFile instead")]
        public static WriteResult WriteSerializedFile(string outputFolder, WriteCommand writeCommand, BuildSettings settings, BuildUsageTagGlobal globalUsage, BuildUsageTagSet usageSet, BuildReferenceMap referenceMap);
        [Obsolete("ContentBuildInterface.WriteSerializedFile has been deprecated. Use ContentBuildInterface.WriteSerializedFile instead")]
        public static WriteResult WriteSerializedFile(string outputFolder, WriteCommand writeCommand, BuildSettings settings, BuildUsageTagGlobal globalUsage, BuildUsageTagSet usageSet, BuildReferenceMap referenceMap, AssetBundleInfo bundleInfo);
        [Obsolete("ContentBuildInterface.WriteSceneSerializedFile has been deprecated. Use ContentBuildInterface.WriteSceneSerializedFile instead")]
        public static WriteResult WriteSceneSerializedFile(string outputFolder, string scenePath, string processedScene, WriteCommand writeCommand, BuildSettings settings, BuildUsageTagGlobal globalUsage, BuildUsageTagSet usageSet, BuildReferenceMap referenceMap);
        [Obsolete("ContentBuildInterface.WriteSceneSerializedFile has been deprecated. Use ContentBuildInterface.WriteSceneSerializedFile with WriteParameters instead")]
        public static WriteResult WriteSceneSerializedFile(string outputFolder, string scenePath, string processedScene, WriteCommand writeCommand, BuildSettings settings, BuildUsageTagGlobal globalUsage, BuildUsageTagSet usageSet, BuildReferenceMap referenceMap, PreloadInfo preloadInfo);
        [Obsolete("ContentBuildInterface.WriteSceneSerializedFile has been deprecated. Use ContentBuildInterface.WriteSceneSerializedFile with WriteSceneParameters instead")]
        public static WriteResult WriteSceneSerializedFile(string outputFolder, string scenePath, string processedScene, WriteCommand writeCommand, BuildSettings settings, BuildUsageTagGlobal globalUsage, BuildUsageTagSet usageSet, BuildReferenceMap referenceMap, PreloadInfo preloadInfo, SceneBundleInfo sceneBundleInfo);
    }
}
using System;
using System.ComponentModel;

namespace UnityEditor.Build.Content
{
    [EditorBrowsable(Never)]
    [Obsolete("UnityEditor.Build.Content.CompressionType has been deprecated. Use UnityEngine.CompressionType instead (UnityUpgradable) -> [UnityEngine] UnityEngine.CompressionType", True)]
    public enum CompressionType
    {
        None = 0,
        Lzma = 1,
        Lz4 = 2,
        Lz4HC = 3
    }
}
using System;
using System.ComponentModel;

namespace UnityEditor.Build.Content
{
    [EditorBrowsable(Never)]
    [Obsolete("UnityEditor.Build.Content.CompressionLevel has been deprecated. Use UnityEngine.CompressionLevel instead (UnityUpgradable) -> [UnityEngine] UnityEngine.CompressionLevel", True)]
    public enum CompressionLevel
    {
        None = 0,
        Fastest = 1,
        Fast = 2,
        Normal = 3,
        High = 4,
        Maximum = 5
    }
}
using System;
using System.ComponentModel;

namespace UnityEditor.Build.Content
{
    [Obsolete("UnityEditor.Build.Content.BuildCompression has been deprecated. Use UnityEngine.BuildCompression instead (UnityUpgradable) -> [UnityEngine] UnityEngine.BuildCompression", True)]
    [EditorBrowsable(Never)]
    public struct BuildCompression
    {
        [Obsolete("DefaultUncompressed has been deprecated. Use Uncompressed instead (UnityUpgradable) -> [UnityEngine] UnityEngine.BuildCompression.Uncompressed", True)]
        [EditorBrowsable(Never)]
        public static readonly BuildCompression DefaultUncompressed;
        [EditorBrowsable(Never)]
        [Obsolete("DefaultLZ4 has been deprecated. Use LZ4 instead (UnityUpgradable) -> [UnityEngine] UnityEngine.BuildCompression.LZ4", True)]
        public static readonly BuildCompression DefaultLZ4;
        [EditorBrowsable(Never)]
        [Obsolete("DefaultLZMA has been deprecated. Use LZMA instead (UnityUpgradable) -> [UnityEngine] UnityEngine.BuildCompression.LZMA", True)]
        public static readonly BuildCompression DefaultLZMA;
    }
}
namespace UnityEditor.Build.Content
{
    public enum ProfileEventType
    {
        Begin = 0,
        End = 1,
        Info = 2
    }
}
namespace UnityEditor.Build.Content
{
    public enum ProfileCaptureOptions
    {
        None = 0,
        IgnoreShortEvents = 1
    }
}
using UnityEngine.Scripting;

namespace UnityEditor.Build.Content
{
    [UsedByNativeCode]
    public struct ContentBuildProfileEvent
    {
        public ulong TimeMicroseconds;
        public string Name;
        public string Metadata;
        public ProfileEventType Type;
    }
}
using System;
using System.Collections.ObjectModel;
using UnityEngine.Scripting;

namespace UnityEditor.Build.Content
{
    [UsedByNativeCode]
    public struct GameManagerDependencyInfo
    {
        public ReadOnlyCollection<ObjectIdentifier> managerObjects { get; }
        public ReadOnlyCollection<ObjectIdentifier> referencedObjects { get; }
        public ReadOnlyCollection<Type> includedTypes { get; }
    }
}
namespace UnityEditor.Build.Content
{
    public enum FileType
    {
        NonAssetType = 0,
        DeprecatedCachedAssetType = 1,
        SerializedAssetType = 2,
        MetaAssetType = 3
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.Build.Content
{
    [UsedByNativeCode]
    [NativeHeader("Modules/BuildPipeline/Editor/Public/ObjectIdentifier.h")]
    [StaticAccessor("BuildPipeline", DoubleColon)]
    public struct ObjectIdentifier : IEquatable<ObjectIdentifier>
    {
        public GUID guid { get; }
        public long localIdentifierInFile { get; }
        public FileType fileType { get; }
        public string filePath { get; }

        public override string ToString();
        public override bool Equals(object obj);
        public bool Equals(ObjectIdentifier other);
        public override int GetHashCode();
        [FreeFunction("GetObjectFromObjectIdentifier")]
        public static UnityEngine.Object ToObject(ObjectIdentifier objectId);
        [FreeFunction("GetInstanceIDFromObjectIdentifier")]
        public static int ToInstanceID(ObjectIdentifier objectId);
        public static bool TryGetObjectIdentifier(UnityEngine.Object targetObject, out ObjectIdentifier objectId);
        public static bool TryGetObjectIdentifier(int instanceID, out ObjectIdentifier objectId);

        public static bool operator ==(ObjectIdentifier a, ObjectIdentifier b);
        public static bool operator !=(ObjectIdentifier a, ObjectIdentifier b);
        public static bool operator <(ObjectIdentifier a, ObjectIdentifier b);
        public static bool operator >(ObjectIdentifier a, ObjectIdentifier b);
    }
}
using UnityEngine.Scripting;

namespace UnityEditor.Build.Content
{
    [UsedByNativeCode]
    public struct ResourceFile
    {
        public string fileName { get; set; }
        public string fileAlias { get; set; }
        public bool serializedFile { get; set; }
    }
}
using System;
using System.Collections.ObjectModel;
using UnityEngine.Scripting;

namespace UnityEditor.Build.Content
{
    [UsedByNativeCode]
    public struct SceneDependencyInfo
    {
        public string scene { get; }
        [Obsolete("processedScene has been deprecated.")]
        public string processedScene { get; }
        public ReadOnlyCollection<ObjectIdentifier> referencedObjects { get; }
        public ReadOnlyCollection<Type> includedTypes { get; }
        public BuildUsageTagGlobal globalUsage { get; }
    }
}
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.Build.Content
{
    [UsedByNativeCode]
    [NativeType(CodegenOptions = Custom)]
    [NativeHeader("Modules/BuildPipeline/Editor/Shared/ContentBuildInterface.bindings.h")]
    public class PreloadInfo
    {
        public PreloadInfo();

        public List<ObjectIdentifier> preloadObjects { get; set; }
    }
}
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.Build.Content
{
    [NativeHeader("Modules/BuildPipeline/Editor/Shared/ContentBuildInterface.bindings.h")]
    [UsedByNativeCode]
    [NativeType(CodegenOptions = Custom)]
    [NativeAsStruct]
    public class AssetLoadInfo
    {
        public AssetLoadInfo();

        public GUID asset { get; set; }
        public string address { get; set; }
        public List<ObjectIdentifier> includedObjects { get; set; }
        public List<ObjectIdentifier> referencedObjects { get; set; }
    }
}
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.Build.Content
{
    [NativeType(CodegenOptions = Custom)]
    [UsedByNativeCode]
    [NativeHeader("Modules/BuildPipeline/Editor/Shared/ContentBuildInterface.bindings.h")]
    public class AssetBundleInfo
    {
        public AssetBundleInfo();

        public string bundleName { get; set; }
        public List<AssetLoadInfo> bundleAssets { get; set; }
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.Build.Content
{
    [NativeAsStruct]
    [UsedByNativeCode]
    [NativeType(CodegenOptions = Custom)]
    [NativeHeader("Modules/BuildPipeline/Editor/Shared/ContentBuildInterface.bindings.h")]
    public class SceneLoadInfo
    {
        public SceneLoadInfo();

        public GUID asset { get; set; }
        public string address { get; set; }
        public string internalName { get; set; }
    }
}
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.Build.Content
{
    [UsedByNativeCode]
    [NativeType(CodegenOptions = Custom)]
    [NativeHeader("Modules/BuildPipeline/Editor/Shared/ContentBuildInterface.bindings.h")]
    public class SceneBundleInfo
    {
        public SceneBundleInfo();

        public string bundleName { get; set; }
        public List<SceneLoadInfo> bundleScenes { get; set; }
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.Build.Content
{
    [NativeAsStruct]
    [NativeType(CodegenOptions = Custom)]
    [UsedByNativeCode]
    public class SerializationInfo
    {
        public SerializationInfo();

        public ObjectIdentifier serializationObject { get; set; }
        public long serializationIndex { get; set; }
    }
}
using System.Collections.Generic;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.Build.Content
{
    [NativeHeader("Modules/BuildPipeline/Editor/Shared/ContentBuildInterface.bindings.h")]
    [NativeType(CodegenOptions = Custom)]
    [NativeAsStruct]
    [UsedByNativeCode]
    public class WriteCommand
    {
        public WriteCommand();

        public string fileName { get; set; }
        public string internalName { get; set; }
        public List<SerializationInfo> serializeObjects { get; set; }
    }
}
namespace UnityEditor.Build.Content
{
    public struct WriteParameters
    {
        public WriteCommand writeCommand;
        public BuildSettings settings;
        public BuildUsageTagGlobal globalUsage;
        public BuildUsageTagSet usageSet;
        public BuildReferenceMap referenceMap;
        public AssetBundleInfo bundleInfo;
        public PreloadInfo preloadInfo;
    }
}
namespace UnityEditor.Build.Content
{
    public struct WriteSceneParameters
    {
        public string scenePath;
        public WriteCommand writeCommand;
        public BuildSettings settings;
        public BuildUsageTagGlobal globalUsage;
        public BuildUsageTagSet usageSet;
        public BuildReferenceMap referenceMap;
        public PreloadInfo preloadInfo;
        public SceneBundleInfo sceneBundleInfo;
    }
}
namespace UnityEditor.Build.Content
{
    public struct WriteManagerParameters
    {
        public BuildSettings settings;
        public BuildUsageTagGlobal globalUsage;
        public BuildReferenceMap referenceMap;
    }
}
namespace UnityEditor.Audio
{
    public class AudioMixerEffectPlugin : IAudioEffectPlugin
    {
        public AudioMixerEffectPlugin();

        public override bool SetFloatParameter(string name, float value);
        public override bool GetFloatParameter(string name, out float value);
        public override bool GetFloatParameterInfo(string name, out float minRange, out float maxRange, out float defaultValue);
        public override bool GetFloatBuffer(string name, out float[] data, int numsamples);
        public override int GetSampleRate();
        public override bool IsPluginEditableAndEnabled();
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor.U2D
{
    [NativeHeader("Editor/Src/2D/SpriteEditorExtension.h")]
    public static class SpriteEditorExtension
    {
        public static GUID GetSpriteID(this Sprite sprite);
        public static void SetSpriteID(this Sprite sprite, GUID guid);
    }
}
using UnityEngine.Bindings;
using UnityEngine.U2D;

namespace UnityEditor.U2D
{
    [NativeHeader("Runtime/2D/SpriteAtlas/SpriteAtlas.h")]
    [NativeHeader("Editor/Src/2D/SpriteAtlas/SpriteAtlasPackingUtilities.h")]
    public class SpriteAtlasUtility
    {
        public SpriteAtlasUtility();

        [FreeFunction("CollectAllSpriteAtlasesAndPack")]
        public static void PackAllAtlases(BuildTarget target, bool canCancel = True);
        public static void PackAtlases(SpriteAtlas[] atlases, BuildTarget target, bool canCancel = True);
    }
}
using UnityEngine;

namespace UnityEditor.U2D
{
    public struct SpriteAtlasTextureSettings
    {
        public int anisoLevel { get; set; }
        public FilterMode filterMode { get; set; }
        public bool generateMipMaps { get; set; }
        public bool readable { get; set; }
        public bool sRGB { get; set; }
    }
}
namespace UnityEditor.U2D
{
    public struct SpriteAtlasPackingSettings
    {
        public int blockOffset { get; set; }
        public int padding { get; set; }
        public bool enableRotation { get; set; }
        public bool enableTightPacking { get; set; }
    }
}
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.U2D;

namespace UnityEditor.U2D
{
    [NativeHeader("Runtime/2D/SpriteAtlas/SpriteAtlas.h")]
    [NativeHeader("Editor/Src/AssetPipeline/TextureImporting/TextureImporterTypes.h")]
    [NativeHeader("Editor/Src/AssetPipeline/TextureImporting/TextureImporter.bindings.h")]
    [NativeHeader("Editor/Src/2D/SpriteAtlas/SpriteAtlas_EditorTypes.h")]
    public static class SpriteAtlasExtensions
    {
        public static void Add([NotNull("NullExceptionObject")] this SpriteAtlas spriteAtlas, Object[] objects);
        public static void Remove([NotNull("NullExceptionObject")] this SpriteAtlas spriteAtlas, Object[] objects);
        public static Object[] GetPackables([NotNull("NullExceptionObject")] this SpriteAtlas spriteAtlas);
        public static SpriteAtlasTextureSettings GetTextureSettings([NotNull("NullExceptionObject")] this SpriteAtlas spriteAtlas);
        public static void SetTextureSettings([NotNull("NullExceptionObject")] this SpriteAtlas spriteAtlas, SpriteAtlasTextureSettings src);
        public static SpriteAtlasPackingSettings GetPackingSettings([NotNull("NullExceptionObject")] this SpriteAtlas spriteAtlas);
        public static void SetPackingSettings([NotNull("NullExceptionObject")] this SpriteAtlas spriteAtlas, SpriteAtlasPackingSettings src);
        public static TextureImporterPlatformSettings GetPlatformSettings([NotNull("NullExceptionObject")] this SpriteAtlas spriteAtlas, string buildTarget);
        public static void SetPlatformSettings([NotNull("NullExceptionObject")] this SpriteAtlas spriteAtlas, TextureImporterPlatformSettings src);
        public static void SetIncludeInBuild([NotNull("NullExceptionObject")] this SpriteAtlas spriteAtlas, bool value);
        public static void SetIsVariant([NotNull("NullExceptionObject")] this SpriteAtlas spriteAtlas, bool value);
        public static void SetMasterAtlas([NotNull("NullExceptionObject")] this SpriteAtlas spriteAtlas, SpriteAtlas value);
        public static void SetVariantScale([NotNull("NullExceptionObject")] this SpriteAtlas spriteAtlas, float value);
    }
}
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.U2D;

namespace UnityEditor.U2D
{
    [NativeHeader("Editor/Src/2D/SpriteAtlas/SpriteAtlasAsset.h")]
    [NativeType(Header = "Editor/Src/2D/SpriteAtlas/SpriteAtlasAsset.h")]
    public class SpriteAtlasAsset : Object
    {
        public SpriteAtlasAsset();

        public bool isVariant { get; }

        public void SetIsVariant(bool value);
        public void SetMasterAtlas(SpriteAtlas atlas);
        public void SetIncludeInBuild(bool value);
        public void SetVariantScale(float value);
        public void SetPlatformSettings(TextureImporterPlatformSettings src);
        public TextureImporterPlatformSettings GetPlatformSettings(string buildTarget);
        public SpriteAtlasTextureSettings GetTextureSettings();
        public void SetTextureSettings(SpriteAtlasTextureSettings src);
        public SpriteAtlasPackingSettings GetPackingSettings();
        public void SetPackingSettings(SpriteAtlasPackingSettings src);
        public void Add(Object[] objects);
        public void Remove(Object[] objects);
    }
}
using UnityEngine.Bindings;

namespace UnityEditor.U2D
{
    [NativeHeader("Editor/Src/2D/SpriteAtlas/SpriteAtlasImporter.h")]
    public sealed class SpriteAtlasImporter : AssetImporter
    {
        public SpriteAtlasImporter();
    }
}
using UnityEngine;

namespace UnityEditor.Sprites
{
    public struct AtlasSettings
    {
        public TextureFormat format;
        public ColorSpace colorSpace;
        public int compressionQuality;
        public FilterMode filterMode;
        public int maxWidth;
        public int maxHeight;
        public uint paddingPower;
        public int anisoLevel;
        public bool generateMipMaps;
        public bool enableRotation;
        public bool allowsAlphaSplitting;
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor.Sprites
{
    [NativeHeader("Editor/Src/SpritePacker/SpritePacker.h")]
    public sealed class PackerJob
    {
        public void AddAtlas(string atlasName, AtlasSettings settings);
        public void AssignToAtlas(string atlasName, Sprite sprite, SpritePackingMode packingMode, SpritePackingRotation packingRotation);
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor.Sprites
{
    [NativeHeader("Editor/Src/SpritePacker/SpritePacker.h")]
    public sealed class Packer
    {
        public static string kDefaultPolicy;

        public Packer();

        public static string[] atlasNames { get; }
        public static string[] Policies { get; }
        public static string SelectedPolicy { get; set; }

        [FreeFunction("SpritePacker::GetTexturesForAtlas")]
        public static Texture2D[] GetTexturesForAtlas(string atlasName);
        [FreeFunction("SpritePacker::GetAlphaTexturesForAtlas")]
        public static Texture2D[] GetAlphaTexturesForAtlas(string atlasName);
        [Obsolete("Sprite Packing Tags are deprecated. Please use Sprite Atlas asset.")]
        [FreeFunction("SpritePacker::RebuildAtlasCacheIfNeededFromScript")]
        public static void RebuildAtlasCacheIfNeeded(BuildTarget target, bool displayProgressBar, Execution execution);
        [Obsolete("Sprite Packing Tags are deprecated. Please use Sprite Atlas asset.")]
        public static void RebuildAtlasCacheIfNeeded(BuildTarget target, bool displayProgressBar);
        [Obsolete("Sprite Packing Tags are deprecated. Please use Sprite Atlas asset.")]
        public static void RebuildAtlasCacheIfNeeded(BuildTarget target);
        public static void GetAtlasDataForSprite(Sprite sprite, out string atlasName, out Texture2D atlasTexture);

        public enum Execution
        {
            Normal = 0,
            ForceRegroup = 1
        }
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor.Sprites
{
    [NativeHeader("Editor/Mono/SpritesEditor.bindings.h")]
    [StaticAccessor("SpriteUtilityBindings", DoubleColon)]
    public sealed class SpriteUtility
    {
        public SpriteUtility();

        [NativeThrows]
        public static Texture2D GetSpriteTexture([NotNull("ArgumentNullException")] Sprite sprite, bool getAtlasData);
        [Obsolete("Use Sprite.vertices API instead. This data is the same for packed and unpacked sprites.")]
        public static Vector2[] GetSpriteMesh(Sprite sprite, bool getAtlasData);
        [NativeThrows]
        public static Vector2[] GetSpriteUVs([NotNull("ArgumentNullException")] Sprite sprite, bool getAtlasData);
        [Obsolete("Use Sprite.triangles API instead. This data is the same for packed and unpacked sprites.")]
        public static ushort[] GetSpriteIndices(Sprite sprite, bool getAtlasData);
    }
}
using System;

namespace UnityEditor.Sprites
{
    [Obsolete("Use UnityEditor.Sprites.SpriteUtility instead (UnityUpgradable)", True)]
    public sealed class DataUtility
    {
        public DataUtility();
    }
}
namespace UnityEditor.Sprites
{
    public interface IPackerPolicy
    {
        bool AllowSequentialPacking { get; }

        void OnGroupAtlases(BuildTarget target, PackerJob job, int[] textureImporterInstanceIDs);
        int GetVersion();
    }
}
using Unity.Profiling;
using UnityEngine;
using UnityEngine.Scripting;

namespace UnityEditor.Profiling
{
    [RequiredByNativeCode]
    public struct ProfilerCategoryInfo
    {
        public ushort id { get; }
        public Color32 color { get; }
        public string name { get; }
        public ProfilerCategoryFlags flags { get; }
    }
}
using System;
using System.Collections.Generic;
using Unity.Collections;
using Unity.Profiling;
using Unity.Profiling.LowLevel;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.Profiling
{
    [NativeHeader("Modules/ProfilerEditor/ProfilerHistory/FrameDataView.h")]
    public abstract class FrameDataView : IDisposable
    {
        protected IntPtr m_Ptr;
        public const int invalidMarkerId = -1;

        protected FrameDataView();

        ~FrameDataView();

        public bool valid { get; }
        public int frameIndex { get; }
        public int threadIndex { get; }
        public string threadGroupName { get; }
        public string threadName { get; }
        public ulong threadId { get; }
        public double frameStartTimeMs { get; }
        public ulong frameStartTimeNs { get; }
        public float frameTimeMs { get; }
        public ulong frameTimeNs { get; }
        public float frameGpuTimeMs { get; }
        public ulong frameGpuTimeNs { get; }
        public float frameFps { get; }
        public int sampleCount { get; }
        public int maxDepth { get; }

        public void Dispose();
        [NativeMethod(IsThreadSafe = True, ThrowsException = True)]
        public ushort GetMarkerCategoryIndex(int markerId);
        [NativeMethod(IsThreadSafe = True, ThrowsException = True)]
        public MarkerFlags GetMarkerFlags(int markerId);
        [NativeMethod(IsThreadSafe = True, ThrowsException = True)]
        public string GetMarkerName(int markerId);
        [NativeMethod(IsThreadSafe = True, ThrowsException = True)]
        public MarkerMetadataInfo[] GetMarkerMetadataInfo(int markerId);
        [NativeMethod(IsThreadSafe = True)]
        public int GetMarkerId(string markerName);
        [NativeMethod(IsThreadSafe = True, ThrowsException = True)]
        public void GetMarkers(List<MarkerInfo> markerInfoList);
        [NativeMethod(IsThreadSafe = True, ThrowsException = True)]
        public ProfilerCategoryInfo GetCategoryInfo(ushort id);
        [NativeMethod(IsThreadSafe = True, ThrowsException = True)]
        public void GetAllCategories(List<ProfilerCategoryInfo> categoryInfoList);
        public NativeArray<T> GetFrameMetaData<T>(Guid id, int tag) where T : struct;
        public NativeArray<T> GetFrameMetaData<T>(Guid id, int tag, int index) where T : struct;
        public int GetFrameMetaDataCount(Guid id, int tag);
        public NativeArray<T> GetSessionMetaData<T>(Guid id, int tag) where T : struct;
        public NativeArray<T> GetSessionMetaData<T>(Guid id, int tag, int index) where T : struct;
        public int GetSessionMetaDataCount(Guid id, int tag);
        public MethodInfo ResolveMethodInfo(ulong addr);
        [NativeMethod(IsThreadSafe = True)]
        public void* GetCounterValuePtr(int markerId);
        public bool HasCounterValue(int markerId);
        [NativeMethod(IsThreadSafe = True)]
        public int GetCounterValueAsInt(int markerId);
        [NativeMethod(IsThreadSafe = True)]
        public long GetCounterValueAsLong(int markerId);
        [NativeMethod(IsThreadSafe = True)]
        public float GetCounterValueAsFloat(int markerId);
        [NativeMethod(IsThreadSafe = True)]
        public double GetCounterValueAsDouble(int markerId);

        [RequiredByNativeCode]
        public struct MarkerMetadataInfo
        {
            public ProfilerMarkerDataType type;
            public ProfilerMarkerDataUnit unit;
            public string name;
        }
        [RequiredByNativeCode]
        public struct MarkerInfo
        {
            public int id;
            public ushort category;
            public MarkerFlags flags;
            public string name;
            public MarkerMetadataInfo[] metadataInfo;
        }
        [RequiredByNativeCode]
        public struct MethodInfo
        {
            public string methodName;
            public string sourceFileName;
            public uint sourceFileLine;
        }
    }
}
using System;
using System.Collections.Generic;
using Unity.Profiling.LowLevel;
using UnityEngine.Bindings;

namespace UnityEditor.Profiling
{
    [NativeHeader("Modules/ProfilerEditor/ProfilerHistory/HierarchyFrameDataView.h")]
    public class HierarchyFrameDataView : FrameDataView
    {
        public const int invalidSampleId = -1;
        public const int columnDontSort = -1;
        public const int columnName = 0;
        public const int columnTotalPercent = 1;
        public const int columnSelfPercent = 2;
        public const int columnCalls = 3;
        public const int columnGcMemory = 4;
        public const int columnTotalTime = 5;
        public const int columnSelfTime = 6;
        public const int columnWarningCount = 12;
        public const int columnObjectName = 13;
        public const int columnStartTime = 14;

        public ViewModes viewMode { get; }
        public int sortColumn { get; }
        public bool sortColumnAscending { get; }

        [ThreadSafe]
        public int GetRootItemID();
        [ThreadSafe]
        public int GetItemMarkerID(int id);
        [ThreadSafe]
        public MarkerFlags GetItemMarkerFlags(int id);
        [ThreadSafe]
        public ushort GetItemCategoryIndex(int id);
        [ThreadSafe]
        public int GetItemDepth(int id);
        public bool HasItemChildren(int id);
        [NativeThrows]
        public void GetItemChildren(int id, List<int> outChildren);
        [NativeThrows]
        public void GetItemAncestors(int id, List<int> outAncestors);
        [NativeThrows]
        public void GetItemDescendantsThatHaveChildren(int id, List<int> outChildren);
        [ThreadSafe]
        public string GetItemName(int id);
        [ThreadSafe]
        public int GetItemInstanceID(int id);
        [ThreadSafe]
        public string GetItemColumnData(int id, int column);
        public float GetItemColumnDataAsSingle(int id, int column);
        [ThreadSafe]
        public float GetItemColumnDataAsFloat(int id, int column);
        [ThreadSafe]
        public double GetItemColumnDataAsDouble(int id, int column);
        public int GetItemMetadataCount(int id);
        public string GetItemMetadata(int id, int index);
        public float GetItemMetadataAsFloat(int id, int index);
        public long GetItemMetadataAsLong(int id, int index);
        [NativeMethod(IsThreadSafe = True, ThrowsException = True)]
        public int GetItemMergedSamplesMetadataCount(int id, int sampleIndex);
        [NativeMethod(IsThreadSafe = True, ThrowsException = True)]
        public string GetItemMergedSamplesMetadata(int id, int sampleIndex, int metadataIndex);
        [NativeMethod(IsThreadSafe = True, ThrowsException = True)]
        public float GetItemMergedSamplesMetadataAsFloat(int id, int sampleIndex, int metadataIndex);
        [NativeMethod(IsThreadSafe = True, ThrowsException = True)]
        public long GetItemMergedSamplesMetadataAsLong(int id, int sampleIndex, int metadataIndex);
        public string ResolveItemCallstack(int id);
        public void GetItemCallstack(int id, List<ulong> outCallstack);
        [ThreadSafe]
        public int GetItemMergedSamplesCount(int id);
        public void GetItemMergedSamplesColumnData(int id, int column, List<string> outStrings);
        public void GetItemMergedSamplesColumnDataAsFloats(int id, int column, List<float> outValues);
        public void GetItemMergedSamplesColumnDataAsDoubles(int id, int column, List<double> outValues);
        public void GetItemMergedSamplesInstanceID(int id, List<int> outInstanceIds);
        public void GetItemMergedSampleCallstack(int id, int sampleIndex, List<ulong> outCallstack);
        public string ResolveItemMergedSampleCallstack(int id, int sampleIndex);
        public void GetItemMarkerIDPath(int id, List<int> outFullIdPath);
        public string GetItemPath(int id);
        public void Sort(int sortColumn, bool sortAscending);
        public override bool Equals(object obj);
        public override int GetHashCode();

        [Flags]
        public enum ViewModes
        {
            Default = 0,
            MergeSamplesWithTheSameName = 1,
            HideEditorOnlySamples = 2
        }
    }
}
using System.Collections.Generic;
using Unity.Profiling;
using Unity.Profiling.LowLevel;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.Profiling
{
    [NativeHeader("Modules/ProfilerEditor/ProfilerHistory/RawFrameDataView.h")]
    public class RawFrameDataView : FrameDataView
    {
        [NativeMethod(IsThreadSafe = True, ThrowsException = True)]
        public double GetSampleStartTimeMs(int sampleIndex);
        [NativeMethod(IsThreadSafe = True, ThrowsException = True)]
        public ulong GetSampleStartTimeNs(int sampleIndex);
        [NativeMethod(IsThreadSafe = True, ThrowsException = True)]
        public float GetSampleTimeMs(int sampleIndex);
        [NativeMethod(IsThreadSafe = True, ThrowsException = True)]
        public ulong GetSampleTimeNs(int sampleIndex);
        [NativeMethod(IsThreadSafe = True, ThrowsException = True)]
        public int GetSampleMarkerId(int sampleIndex);
        [NativeMethod(IsThreadSafe = True, ThrowsException = True)]
        public MarkerFlags GetSampleFlags(int sampleIndex);
        [NativeMethod(IsThreadSafe = True, ThrowsException = True)]
        public ushort GetSampleCategoryIndex(int sampleIndex);
        [NativeMethod(IsThreadSafe = True, ThrowsException = True)]
        public string GetSampleName(int sampleIndex);
        [NativeMethod(IsThreadSafe = True, ThrowsException = True)]
        public int GetSampleChildrenCount(int sampleIndex);
        [NativeMethod(IsThreadSafe = True, ThrowsException = True)]
        public int GetSampleChildrenCountRecursive(int sampleIndex);
        [NativeMethod(IsThreadSafe = True, ThrowsException = True)]
        public int GetSampleMetadataCount(int sampleIndex);
        [NativeMethod(IsThreadSafe = True, ThrowsException = True)]
        public string GetSampleMetadataAsString(int sampleIndex, int metadataIndex);
        [NativeMethod(IsThreadSafe = True, ThrowsException = True)]
        public int GetSampleMetadataAsInt(int sampleIndex, int metadataIndex);
        [NativeMethod(IsThreadSafe = True, ThrowsException = True)]
        public long GetSampleMetadataAsLong(int sampleIndex, int metadataIndex);
        [NativeMethod(IsThreadSafe = True, ThrowsException = True)]
        public float GetSampleMetadataAsFloat(int sampleIndex, int metadataIndex);
        [NativeMethod(IsThreadSafe = True, ThrowsException = True)]
        public double GetSampleMetadataAsDouble(int sampleIndex, int metadataIndex);
        public void GetSampleCallstack(int sampleIndex, List<ulong> outCallstack);
        [NativeMethod(IsThreadSafe = True, ThrowsException = True)]
        public void GetSampleFlowEvents(int sampleIndex, List<FlowEvent> outFlowEvents);
        [NativeMethod(IsThreadSafe = True, ThrowsException = True)]
        public void GetFlowEvents(List<FlowEvent> outFlowEvents);
        public override bool Equals(object obj);
        public override int GetHashCode();

        [RequiredByNativeCode]
        public struct FlowEvent
        {
            public int ParentSampleIndex;
            public uint FlowId;
            public ProfilerFlowEventType FlowEventType;
        }
    }
}
namespace UnityEditor.Profiling.Memory.Experimental
{
    public class ArrayEntries<T>
    {
        public uint GetNumEntries();
        public virtual void GetEntries(uint indexStart, uint numEntries, ref T[] dataOut);
    }
}
namespace UnityEditor.Profiling.Memory.Experimental
{
    public class ConnectionEntries
    {
        public ArrayEntries<int> from { get; }
        public ArrayEntries<int> to { get; }

        public uint GetNumEntries();
    }
}
namespace UnityEditor.Profiling.Memory.Experimental
{
    public class GCHandleEntries
    {
        public ArrayEntries<ulong> target { get; }

        public uint GetNumEntries();
    }
}
namespace UnityEditor.Profiling.Memory.Experimental
{
    public class ManagedMemorySectionEntries
    {
        public ArrayEntries<byte[]> bytes { get; }
        public ArrayEntries<ulong> startAddress { get; }

        public uint GetNumEntries();
    }
}
using UnityEngine;

namespace UnityEditor.Profiling.Memory.Experimental
{
    public class NativeObjectEntries
    {
        public ArrayEntries<string> objectName { get; }
        public ArrayEntries<int> instanceId { get; }
        public ArrayEntries<ulong> size { get; }
        public ArrayEntries<int> nativeTypeArrayIndex { get; }
        public ArrayEntries<HideFlags> hideFlags { get; }
        public ArrayEntries<ObjectFlags> flags { get; }
        public ArrayEntries<ulong> nativeObjectAddress { get; }
        public ArrayEntries<long> rootReferenceId { get; }
        public ArrayEntries<int> gcHandleIndex { get; }

        public uint GetNumEntries();
    }
}
namespace UnityEditor.Profiling.Memory.Experimental
{
    public class NativeTypeEntries
    {
        public ArrayEntries<string> typeName { get; }
        public ArrayEntries<int> nativeBaseTypeArrayIndex { get; }

        public uint GetNumEntries();
    }
}
namespace UnityEditor.Profiling.Memory.Experimental
{
    public class TypeDescriptionEntries
    {
        public ArrayEntries<TypeFlags> flags { get; }
        public ArrayEntries<string> typeDescriptionName { get; }
        public ArrayEntries<string> assembly { get; }
        public ArrayEntries<int[]> fieldIndices { get; }
        public ArrayEntries<byte[]> staticFieldBytes { get; }
        public ArrayEntries<int> baseOrElementTypeIndex { get; }
        public ArrayEntries<int> size { get; }
        public ArrayEntries<ulong> typeInfoAddress { get; }
        public ArrayEntries<int> typeIndex { get; }

        public uint GetNumEntries();
    }
}
namespace UnityEditor.Profiling.Memory.Experimental
{
    public class FieldDescriptionEntries
    {
        public ArrayEntries<string> fieldDescriptionName { get; }
        public ArrayEntries<int> offset { get; }
        public ArrayEntries<int> typeIndex { get; }
        public ArrayEntries<bool> isStatic { get; }

        public uint GetNumEntries();
    }
}
namespace UnityEditor.Profiling.Memory.Experimental
{
    public class NativeMemoryLabelEntries
    {
        public ArrayEntries<string> memoryLabelName { get; }

        public uint GetNumEntries();
    }
}
namespace UnityEditor.Profiling.Memory.Experimental
{
    public class NativeRootReferenceEntries
    {
        public ArrayEntries<long> id { get; }
        public ArrayEntries<string> areaName { get; }
        public ArrayEntries<string> objectName { get; }
        public ArrayEntries<ulong> accumulatedSize { get; }

        public uint GetNumEntries();
    }
}
namespace UnityEditor.Profiling.Memory.Experimental
{
    public class NativeAllocationEntries
    {
        public ArrayEntries<int> memoryRegionIndex { get; }
        public ArrayEntries<long> rootReferenceId { get; }
        public ArrayEntries<long> allocationSiteId { get; }
        public ArrayEntries<ulong> address { get; }
        public ArrayEntries<ulong> size { get; }
        public ArrayEntries<int> overheadSize { get; }
        public ArrayEntries<int> paddingSize { get; }

        public uint GetNumEntries();
    }
}
namespace UnityEditor.Profiling.Memory.Experimental
{
    public class NativeMemoryRegionEntries
    {
        public ArrayEntries<string> memoryRegionName { get; }
        public ArrayEntries<int> parentIndex { get; }
        public ArrayEntries<ulong> addressBase { get; }
        public ArrayEntries<ulong> addressSize { get; }
        public ArrayEntries<int> firstAllocationIndex { get; }
        public ArrayEntries<int> numAllocations { get; }

        public uint GetNumEntries();
    }
}
namespace UnityEditor.Profiling.Memory.Experimental
{
    public class NativeAllocationSiteEntries
    {
        public ArrayEntries<long> id { get; }
        public ArrayEntries<int> memoryLabelIndex { get; }
        public ArrayEntries<ulong[]> callstackSymbols { get; }

        public uint GetNumEntries();
    }
}
namespace UnityEditor.Profiling.Memory.Experimental
{
    public class NativeCallstackSymbolEntries
    {
        public ArrayEntries<ulong> symbol { get; }
        public ArrayEntries<string> readableStackTrace { get; }

        public uint GetNumEntries();
    }
}
using System;
using UnityEditor.MemoryProfiler;
using UnityEngine.Profiling.Memory.Experimental;

namespace UnityEditor.Profiling.Memory.Experimental
{
    public class PackedMemorySnapshot : IDisposable
    {
        ~PackedMemorySnapshot();

        public ConnectionEntries connections { get; }
        public FieldDescriptionEntries fieldDescriptions { get; }
        public GCHandleEntries gcHandles { get; }
        public ManagedMemorySectionEntries managedHeapSections { get; }
        public ManagedMemorySectionEntries managedStacks { get; }
        public NativeAllocationEntries nativeAllocations { get; }
        public NativeAllocationSiteEntries nativeAllocationSites { get; }
        public NativeCallstackSymbolEntries nativeCallstackSymbols { get; }
        public NativeMemoryLabelEntries nativeMemoryLabels { get; }
        public NativeMemoryRegionEntries nativeMemoryRegions { get; }
        public NativeObjectEntries nativeObjects { get; }
        public NativeRootReferenceEntries nativeRootReferences { get; }
        public NativeTypeEntries nativeTypes { get; }
        public TypeDescriptionEntries typeDescriptions { get; }
        public uint version { get; }
        public MetaData metadata { get; }
        public string filePath { get; }
        public DateTime recordDate { get; }
        public CaptureFlags captureFlags { get; }
        public VirtualMachineInformation virtualMachineInformation { get; }

        public static PackedMemorySnapshot Load(string path);
        public static bool Convert(UnityEditor.MemoryProfiler.PackedMemorySnapshot snapshot, string writePath);
        public static void Save(PackedMemorySnapshot snapshot, string writePath);
        public void Dispose();
        protected virtual void Dispose(bool disposing);
    }
}
using System;

namespace UnityEditor.Profiling.Memory.Experimental
{
    [Flags]
    public enum ObjectFlags
    {
        IsDontDestroyOnLoad = 1,
        IsPersistent = 2,
        IsManager = 4
    }
}
namespace UnityEditor.Profiling.Memory.Experimental
{
    public static class ObjectFlagsExtensions
    {
        public static bool IsDontDestroyOnLoad(this ObjectFlags flags);
        public static bool IsPersistent(this ObjectFlags flags);
        public static bool IsManager(this ObjectFlags flags);
    }
}
using System;

namespace UnityEditor.Profiling.Memory.Experimental
{
    [Flags]
    public enum TypeFlags
    {
        kNone = 0,
        kValueType = 1,
        kArray = 2,
        kArrayRankMask = -65536
    }
}
namespace UnityEditor.Profiling.Memory.Experimental
{
    public static class TypeFlagsExtensions
    {
        public static bool IsValueType(this TypeFlags flags);
        public static bool IsArray(this TypeFlags flags);
        public static int ArrayRank(this TypeFlags flags);
    }
}
namespace UnityEditor.Profiling.Memory.Experimental
{
    public struct VirtualMachineInformation
    {
        public int pointerSize { get; }
        public int objectHeaderSize { get; }
        public int arrayHeaderSize { get; }
        public int arrayBoundsOffsetInHeader { get; }
        public int arraySizeOffsetInHeader { get; }
        public int allocationGranularity { get; }
    }
}
using UnityEngine.Scripting;

namespace UnityEditor.Hardware
{
    [RequiredByNativeCode(GenerateProxy = True)]
    public struct UsbDevice
    {
        public readonly int vendorId;
        public readonly int productId;
        public readonly int revision;
        public readonly string udid;
        public readonly string name;

        public override string ToString();
    }
}
using UnityEngine.Scripting;

namespace UnityEditor.Hardware
{
    public sealed class Usb
    {
        public Usb();

        public static event OnDevicesChangedHandler DevicesChanged;

        [RequiredByNativeCode]
        public static void OnDevicesChanged(UsbDevice[] devices);

        public delegate void OnDevicesChangedHandler(UsbDevice[] devices);
    }
}
namespace UnityEditor.Hardware
{
    public enum DevDeviceState
    {
        Disconnected = 0,
        Connected = 1
    }
}
using System;

namespace UnityEditor.Hardware
{
    [Flags]
    public enum DevDeviceFeatures
    {
        None = 0,
        PlayerConnection = 1,
        RemoteConnection = 2
    }
}
using UnityEngine.Scripting;

namespace UnityEditor.Hardware
{
    [RequiredByNativeCode]
    public struct DevDevice
    {
        public readonly string id;
        public readonly string name;
        public readonly string type;
        public readonly string module;
        public readonly DevDeviceState state;
        public readonly DevDeviceFeatures features;

        public DevDevice(string id, string name, string type, string module, DevDeviceState state, DevDeviceFeatures features);

        public bool isConnected { get; }
        public static DevDevice none { get; }

        public override string ToString();
    }
}
using UnityEngine.Bindings;

namespace UnityEditor.Hardware
{
    [NativeHeader("Editor/Src/Devices/DevDevice.h")]
    public sealed class DevDeviceList
    {
        public DevDeviceList();

        public static event OnChangedHandler Changed;

        public static void OnChanged();
        public static bool FindDevice(string deviceId, out DevDevice device);
        [FreeFunction("GetDeviceList")]
        public static DevDevice[] GetDevices();

        public delegate void OnChangedHandler();
    }
}
namespace UnityEditor.UIElements
{
    public static class UIElementsEntryPoint
    {
        public static void SetAntiAliasing(this EditorWindow window, int aa);
        public static int GetAntiAliasing(this EditorWindow window);
    }
}
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public sealed class SerializedPropertyChangeEvent : EventBase<SerializedPropertyChangeEvent>
    {
        public SerializedPropertyChangeEvent();

        public SerializedProperty changedProperty { get; set; }

        protected override void Init();
        public static SerializedPropertyChangeEvent GetPooled(SerializedProperty value);
    }
}
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Events;
using UnityEngine.Internal;
using UnityEngine.SceneManagement;

namespace UnityEditor.SceneManagement
{
    [NativeHeader("Modules/AssetPipelineEditor/Public/DefaultImporter.h")]
    [NativeHeader("Runtime/SceneManager/SceneManager.h")]
    [NativeHeader("Editor/Mono/EditorSceneManager.bindings.h")]
    public sealed class EditorSceneManager : SceneManager
    {
        public const ulong DefaultSceneCullingMask = 16140901064495857664;

        public EditorSceneManager();

        public static int loadedSceneCount { get; }
        public static int loadedRootSceneCount { get; }
        public static int previewSceneCount { get; }
        public static bool preventCrossSceneReferences { get; set; }
        public static SceneAsset playModeStartScene { get; set; }

        public static event UnityAction<Scene, Scene> activeSceneChangedInEditMode;
        public static event NewSceneCreatedCallback newSceneCreated;
        public static event SceneOpeningCallback sceneOpening;
        public static event SceneOpenedCallback sceneOpened;
        public static event SceneClosingCallback sceneClosing;
        public static event SceneClosedCallback sceneClosed;
        public static event SceneSavingCallback sceneSaving;
        public static event SceneSavedCallback sceneSaved;
        public static event SceneDirtiedCallback sceneDirtied;

        [StaticAccessor("GetSceneManager()", Dot)]
        [NativeMethod("IsReloading")]
        public static bool IsReloading(Scene scene);
        [StaticAccessor("EditorSceneManagerBindings", DoubleColon)]
        [NativeThrows]
        [NativeMethod("OpenScene")]
        public static Scene OpenScene(string scenePath, [DefaultValue("OpenSceneMode.Single")] OpenSceneMode mode);
        [StaticAccessor("EditorSceneManagerBindings", DoubleColon)]
        [NativeMethod("NewScene")]
        [NativeThrows]
        public static Scene NewScene(NewSceneSetup setup, [DefaultValue("NewSceneMode.Single")] NewSceneMode mode);
        public static Scene NewPreviewScene();
        [NativeMethod("CloseScene")]
        [NativeThrows]
        [StaticAccessor("EditorSceneManagerBindings", DoubleColon)]
        public static bool CloseScene(Scene scene, bool removeScene);
        [NativeMethod("ClosePreviewScene")]
        [NativeThrows]
        [StaticAccessor("EditorSceneManagerBindings", DoubleColon)]
        public static bool ClosePreviewScene(Scene scene);
        [StaticAccessor("EditorSceneManagerBindings", DoubleColon)]
        [NativeMethod("IsPreviewScene")]
        public static bool IsPreviewScene(Scene scene);
        [StaticAccessor("EditorSceneManagerBindings", DoubleColon)]
        [NativeMethod("IsPreviewSceneObject")]
        public static bool IsPreviewSceneObject(Object obj);
        [NativeMethod("MoveSceneBefore")]
        [StaticAccessor("EditorSceneManagerBindings", DoubleColon)]
        public static void MoveSceneBefore(Scene src, Scene dst);
        [NativeMethod("MoveSceneAfter")]
        [StaticAccessor("EditorSceneManagerBindings", DoubleColon)]
        public static void MoveSceneAfter(Scene src, Scene dst);
        [StaticAccessor("EditorSceneManagerBindings", DoubleColon)]
        [NativeMethod("SaveOpenScenes")]
        [NativeThrows]
        public static bool SaveOpenScenes();
        [NativeMethod("SaveScenes")]
        [StaticAccessor("EditorSceneManagerBindings", DoubleColon)]
        [NativeThrows]
        public static bool SaveScenes(Scene[] scenes);
        [NativeMethod("SaveCurrentModifiedScenesIfUserWantsTo")]
        [NativeThrows]
        [StaticAccessor("EditorSceneManagerBindings", DoubleColon)]
        public static bool SaveCurrentModifiedScenesIfUserWantsTo();
        [StaticAccessor("EditorSceneManagerBindings", DoubleColon)]
        [NativeMethod("SaveModifiedScenesIfUserWantsTo")]
        [NativeThrows]
        public static bool SaveModifiedScenesIfUserWantsTo(Scene[] scenes);
        [NativeMethod("EnsureUntitledSceneHasBeenSaved")]
        [StaticAccessor("GetSceneManager()", Dot)]
        public static bool EnsureUntitledSceneHasBeenSaved(string dialogContent);
        [NativeMethod("MarkSceneDirty")]
        [StaticAccessor("EditorSceneManagerBindings", DoubleColon)]
        [NativeThrows]
        public static bool MarkSceneDirty(Scene scene);
        [NativeMethod("MarkAllScenesDirty")]
        [StaticAccessor("EditorSceneManagerBindings", DoubleColon)]
        [NativeThrows]
        public static void MarkAllScenesDirty();
        [StaticAccessor("EditorSceneManagerBindings", DoubleColon)]
        [NativeMethod("GetSceneManagerSetup")]
        [NativeThrows]
        public static SceneSetup[] GetSceneManagerSetup();
        [NativeThrows]
        [StaticAccessor("EditorSceneManagerBindings", DoubleColon)]
        [NativeMethod("RestoreSceneManagerSetup")]
        public static void RestoreSceneManagerSetup(SceneSetup[] value);
        [StaticAccessor("EditorSceneManagerBindings", DoubleColon)]
        [NativeMethod("DetectCrossSceneReferences")]
        public static bool DetectCrossSceneReferences(Scene scene);
        [StaticAccessor("EditorSceneManagerBindings", DoubleColon)]
        public static ulong GetSceneCullingMask(Scene scene);
        [StaticAccessor("EditorSceneManagerBindings", DoubleColon)]
        public static void SetSceneCullingMask(Scene scene, ulong sceneCullingMask);
        [StaticAccessor("GetSceneManager()", Dot)]
        public static ulong CalculateAvailableSceneCullingMask();
        [ExcludeFromDocs]
        public static Scene OpenScene(string scenePath);
        [ExcludeFromDocs]
        public static Scene NewScene(NewSceneSetup setup);
        [ExcludeFromDocs]
        public static bool SaveScene(Scene scene, string dstScenePath);
        [ExcludeFromDocs]
        public static bool SaveScene(Scene scene);
        public static bool SaveScene(Scene scene, [DefaultValue("\"\"")] string dstScenePath, [DefaultValue("false")] bool saveAsCopy);
        public static Scene LoadSceneInPlayMode(string path, LoadSceneParameters parameters);
        public static AsyncOperation LoadSceneAsyncInPlayMode(string path, LoadSceneParameters parameters);

        public delegate void NewSceneCreatedCallback(Scene scene, NewSceneSetup setup, NewSceneMode mode);
        public delegate void SceneOpeningCallback(string path, OpenSceneMode mode);
        public delegate void SceneOpenedCallback(Scene scene, OpenSceneMode mode);
        public delegate void SceneClosingCallback(Scene scene, bool removingScene);
        public delegate void SceneClosedCallback(Scene scene);
        public delegate void SceneSavingCallback(Scene scene, string path);
        public delegate void SceneSavedCallback(Scene scene);
        public delegate void SceneDirtiedCallback(Scene scene);
    }
}
namespace UnityEditor.SceneManagement
{
    public static class SceneCullingMasks
    {
        public const ulong DefaultSceneCullingMask = 16140901064495857664;
        public const ulong GameViewObjects = 9223372036854775808;
        public const ulong MainStageSceneViewObjects = 6917529027641081856;
    }
}
namespace UnityEditor.SceneManagement
{
    public enum OpenSceneMode
    {
        Single = 0,
        Additive = 1,
        AdditiveWithoutLoading = 2
    }
}
namespace UnityEditor.SceneManagement
{
    public enum NewSceneMode
    {
        Single = 0,
        Additive = 1
    }
}
namespace UnityEditor.SceneManagement
{
    public enum NewSceneSetup
    {
        EmptyScene = 0,
        DefaultGameObjects = 1
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.SceneManagement;

namespace UnityEditor.SceneManagement
{
    public static class SceneHierarchyHooks
    {
        public static Func<SubSceneInfo[]> provideSubScenes;
        public static Func<SubSceneInfo, string> provideSubSceneName;

        public static event Action<GenericMenu, GameObject> addItemsToGameObjectContextMenu;
        public static event Action<GenericMenu, Scene> addItemsToSceneHeaderContextMenu;
        public static event Action<GenericMenu, SubSceneInfo> addItemsToSubSceneHeaderContextMenu;
        public static event Action<GenericMenu> addItemsToCreateMenu;

        public static void ReloadAllSceneHierarchies();
        public static bool CanSetNewParent(Transform transform, Transform newParent);
        public static bool CanMoveTransformToScene(Transform transform, Scene scene);

        [NativeType(IntermediateScriptingStructName = "SceneHierarchyHooks_SubSceneInfo")]
        public struct SubSceneInfo
        {
            public Transform transform;
            public Scene scene;
            [Ignore]
            public SceneAsset sceneAsset;
            [Ignore]
            public string sceneName;
            [Ignore]
            public Color32 color;

            public bool isValid { get; }
        }
    }
}
using UnityEngine;

namespace UnityEditor.SceneManagement
{
    public abstract class PrefabOverride
    {
        protected PrefabOverride();

        public abstract void Apply(string prefabAssetPath, InteractionMode mode);
        public abstract void Revert(InteractionMode mode);
        public void Apply();
        public void Apply(string prefabAssetPath);
        public void Apply(InteractionMode mode);
        public void Revert();
        protected Object FindApplyTargetAssetObject(string prefabAssetPath);
        public abstract Object GetAssetObject();
    }
}
using UnityEngine;

namespace UnityEditor.SceneManagement
{
    public class ObjectOverride : PrefabOverride
    {
        public ObjectOverride();

        public Object instanceObject { get; set; }
        public PrefabOverride coupledOverride { get; set; }

        public override void Apply(string prefabAssetPath, InteractionMode mode);
        public override void Revert(InteractionMode mode);
        public override Object GetAssetObject();
    }
}
using UnityEngine;

namespace UnityEditor.SceneManagement
{
    public class AddedComponent : PrefabOverride
    {
        public AddedComponent();

        public Component instanceComponent { get; set; }

        public override void Apply(string prefabAssetPath, InteractionMode mode);
        public override void Revert(InteractionMode mode);
        public override Object GetAssetObject();
    }
}
using UnityEngine;

namespace UnityEditor.SceneManagement
{
    public class RemovedComponent : PrefabOverride
    {
        public RemovedComponent();

        public GameObject containingInstanceGameObject { get; set; }
        public Component assetComponent { get; set; }

        public override void Apply(string prefabAssetPath, InteractionMode mode);
        public override void Revert(InteractionMode mode);
        public override Object GetAssetObject();
    }
}
using UnityEngine;

namespace UnityEditor.SceneManagement
{
    public class AddedGameObject : PrefabOverride
    {
        public AddedGameObject();

        public GameObject instanceGameObject { get; set; }
        public int siblingIndex { get; set; }

        public override void Apply(string prefabAssetPath, InteractionMode mode);
        public override void Revert(InteractionMode mode);
        public override Object GetAssetObject();
    }
}
namespace UnityEditor.SceneManagement
{
    public class SceneSetup
    {
        public SceneSetup();

        public string path { get; set; }
        public bool isLoaded { get; set; }
        public bool isActive { get; set; }
        public bool isSubScene { get; set; }
    }
}
using UnityEngine;

namespace UnityEditor.SceneManagement
{
    public sealed class MainStage : Stage
    {
        public MainStage();

        protected internal override bool OnOpenStage();
        protected override void OnCloseStage();
        protected internal override GUIContent CreateHeaderContent();
    }
}
using UnityEngine.SceneManagement;

namespace UnityEditor.SceneManagement
{
    public abstract class PreviewSceneStage : Stage
    {
        protected PreviewSceneStage();

        public Scene scene { get; protected set; }
        public override StageHandle stageHandle { get; }

        protected internal override bool OnOpenStage();
        protected override void OnCloseStage();
    }
}
using UnityEngine;

namespace UnityEditor.SceneManagement
{
    public abstract class Stage : ScriptableObject
    {
        protected Stage();

        public virtual string assetPath { get; }
        public virtual StageHandle stageHandle { get; }

        protected internal abstract bool OnOpenStage();
        protected abstract void OnCloseStage();
        protected internal virtual void OnReturnToStage();
        protected internal abstract GUIContent CreateHeaderContent();
        public virtual ulong GetCombinedSceneCullingMaskForCamera();
        protected internal virtual void OnFirstTimeOpenStageInSceneView(SceneView sceneView);
        protected internal virtual Hash128 GetHashForStateStorage();
        protected virtual void OnEnable();
        protected virtual void OnDisable();
        public T FindComponentOfType<T>() where T : Component;
        public T[] FindComponentsOfType<T>() where T : Component;
    }
}
using System;
using UnityEngine;

namespace UnityEditor.SceneManagement
{
    public struct StageHandle : IEquatable<StageHandle>
    {
        public bool Contains(GameObject gameObject);
        public T FindComponentOfType<T>() where T : Component;
        public T[] FindComponentsOfType<T>() where T : Component;
        public bool IsValid();
        public override bool Equals(object other);
        public bool Equals(StageHandle other);
        public override int GetHashCode();

        public static bool operator ==(StageHandle s1, StageHandle s2);
        public static bool operator !=(StageHandle s1, StageHandle s2);
    }
}
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.SceneManagement;

namespace UnityEditor.SceneManagement
{
    [NativeHeader("Editor/Src/SceneManager/StageUtility.bindings.h")]
    public static class StageUtility
    {
        public static bool IsGameObjectRenderedByCamera(GameObject gameObject, Camera camera);
        public static bool IsGameObjectRenderedByCameraAndPartOfEditableScene(GameObject gameObject, Camera camera);
        public static Stage GetCurrentStage();
        public static MainStage GetMainStage();
        public static Stage GetStage(GameObject gameObject);
        public static Stage GetStage(Scene scene);
        public static StageHandle GetCurrentStageHandle();
        public static StageHandle GetMainStageHandle();
        public static StageHandle GetStageHandle(GameObject gameObject);
        public static StageHandle GetStageHandle(Scene scene);
        public static void GoToMainStage();
        public static void GoBackToPreviousStage();
        public static void GoToStage(Stage stage, bool setAsFirstItemAfterMainStage);
        public static void PlaceGameObjectInCurrentStage(GameObject gameObject);
    }
}
using System;
using UnityEngine.Bindings;
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    [NativeHeader("Editor/Mono/EditorGraphicsSettings.bindings.h")]
    [StaticAccessor("EditorGraphicsSettingsScripting", DoubleColon)]
    public sealed class EditorGraphicsSettings
    {
        public EditorGraphicsSettings();

        public static AlbedoSwatchInfo[] albedoSwatches { get; set; }

        public static TierSettings GetTierSettings(BuildTargetGroup target, GraphicsTier tier);
        public static void SetTierSettings(BuildTargetGroup target, GraphicsTier tier, TierSettings settings);
        [Obsolete("Use GetTierSettings() instead (UnityUpgradable) -> GetTierSettings(*)", False)]
        public static PlatformShaderSettings GetShaderSettingsForPlatform(BuildTargetGroup target, ShaderHardwareTier tier);
        [Obsolete("Use SetTierSettings() instead (UnityUpgradable) -> SetTierSettings(*)", False)]
        public static void SetShaderSettingsForPlatform(BuildTargetGroup target, ShaderHardwareTier tier, PlatformShaderSettings settings);
        [Obsolete("Use GraphicsTier instead of ShaderHardwareTier enum", False)]
        public static TierSettings GetTierSettings(BuildTargetGroup target, ShaderHardwareTier tier);
        [Obsolete("Use GraphicsTier instead of ShaderHardwareTier enum", False)]
        public static void SetTierSettings(BuildTargetGroup target, ShaderHardwareTier tier, TierSettings settings);
    }
}
namespace UnityEditor.Rendering
{
    public enum ShaderQuality
    {
        Low = 0,
        Medium = 1,
        High = 2
    }
}
using UnityEngine;

namespace UnityEditor.Rendering
{
    public struct AlbedoSwatchInfo
    {
        public string name;
        public Color color;
        public float minLuminance;
        public float maxLuminance;
    }
}
using UnityEngine;
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    public struct TierSettings
    {
        public ShaderQuality standardShaderQuality;
        public CameraHDRMode hdrMode;
        public bool reflectionProbeBoxProjection;
        public bool reflectionProbeBlending;
        public bool hdr;
        public bool detailNormalMap;
        public bool cascadedShadowMaps;
        public bool prefer32BitShadowMaps;
        public bool enableLPPV;
        public bool semitransparentShadows;
        public RenderingPath renderingPath;
        public RealtimeGICPUUsage realtimeGICPUUsage;
    }
}
using System;

namespace UnityEditor.Rendering
{
    [Obsolete("Use TierSettings instead (UnityUpgradable) -> UnityEditor.Rendering.TierSettings", False)]
    public struct PlatformShaderSettings
    {
        public bool cascadedShadowMaps;
        public bool reflectionProbeBoxProjection;
        public bool reflectionProbeBlending;
        public ShaderQuality standardShaderQuality;
    }
}
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.Rendering
{
    [NativeHeader("Editor/Src/Camera/EditorCameraUtils.h")]
    [RequiredByNativeCode]
    public static class EditorCameraUtils
    {
        public static bool RenderToCubemap(this Camera camera, Texture target, int faceMask, StaticEditorFlags culledFlags);
    }
}
using UnityEngine.Rendering;
using UnityEngine.Scripting;

namespace UnityEditor.Rendering
{
    [UsedByNativeCode]
    public struct ShaderSnippetData
    {
        public ShaderType shaderType { get; }
        public PassType passType { get; }
        public string passName { get; }
    }
}
using UnityEngine.Rendering;
using UnityEngine.Scripting;

namespace UnityEditor.Rendering
{
    [UsedByNativeCode]
    public struct ShaderCompilerData
    {
        public ShaderKeywordSet shaderKeywordSet;
        public PlatformKeywordSet platformKeywordSet;

        public ShaderRequirements shaderRequirements { get; }
        public GraphicsTier graphicsTier { get; }
        public ShaderCompilerPlatform shaderCompilerPlatform { get; }
        public BuildTarget buildTarget { get; }
    }
}
namespace UnityEditor.Rendering
{
    public enum ShaderCompilerPlatform
    {
        None = 0,
        D3D = 4,
        GLES20 = 5,
        GLES3x = 9,
        PS4 = 11,
        XboxOneD3D11 = 12,
        Metal = 14,
        OpenGLCore = 15,
        Vulkan = 18,
        Switch = 19,
        XboxOneD3D12 = 20,
        GameCore = 21,
        PS5 = 23,
        PS5NGGC = 24
    }
}
namespace UnityEditor.Rendering
{
    public enum ShaderCompilerMessageSeverity
    {
        Error = 0,
        Warning = 1
    }
}
using System;

namespace UnityEditor.Rendering
{
    [Flags]
    public enum ShaderRequirements
    {
        None = 0,
        BaseShaders = 1,
        Interpolators10 = 2,
        Interpolators32 = 4,
        MRT4 = 8,
        MRT8 = 16,
        Derivatives = 32,
        SampleLOD = 64,
        FragCoord = 128,
        Interpolators15Integers = 512,
        Texture2DArray = 1024,
        Instancing = 2048,
        Geometry = 4096,
        CubeArray = 8192,
        Compute = 16384,
        RandomWrite = 32768,
        TessellationCompute = 65536,
        TessellationShaders = 131072,
        SparseTexelResident = 262144,
        FramebufferFetch = 524288,
        MSAATextureSamples = 1048576
    }
}
namespace UnityEditor.Rendering
{
    public enum ShaderType
    {
        Vertex = 1,
        Fragment = 2,
        Geometry = 3,
        Hull = 4,
        Domain = 5,
        Surface = 6,
        RayTracing = 7,
        Count = 7
    }
}
using System;

namespace UnityEditor.Rendering
{
    [AttributeUsage(Class)]
    public class ScriptableRenderPipelineExtensionAttribute : Attribute
    {
        public ScriptableRenderPipelineExtensionAttribute(Type renderPipelineAsset);

        public bool inUse { get; }
    }
}
using System;

namespace UnityEditor.Rendering
{
    public static class RenderPipelineEditorUtility
    {
        public static Type FetchFirstCompatibleTypeUsingScriptableRenderPipelineExtension<TBaseClass>();
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEditor.Compilation
{
    [NativeHeader("Editor/Src/ScriptCompilation/ScriptCompilationPipeline.h")]
    public static class CompilationPipeline
    {
        public static CodeOptimization codeOptimization { get; set; }

        public static event Action<object> compilationStarted;
        public static event Action<object> compilationFinished;
        public static event Action<string> assemblyCompilationStarted;
        public static event Action<string, CompilerMessage[]> assemblyCompilationFinished;
        public static event Action<CodeOptimization> codeOptimizationChanged;

        public static string[] GetSystemAssemblyDirectories(ApiCompatibilityLevel apiCompatibilityLevel);
        public static ResponseFileData ParseResponseFile(string relativePath, string projectDirectory, string[] systemReferenceDirectories);
        public static Assembly[] GetAssemblies();
        public static Assembly[] GetAssemblies(AssembliesType assembliesType);
        public static string GetAssemblyNameFromScriptPath(string sourceFilePath);
        public static string GetAssemblyDefinitionFilePathFromScriptPath(string sourceFilePath);
        public static string GetAssemblyDefinitionFilePathFromAssemblyName(string assemblyName);
        public static string GetAssemblyDefinitionFilePathFromAssemblyReference(string reference);
        public static AssemblyDefinitionReferenceType GetAssemblyDefinitionReferenceType(string reference);
        public static string GUIDToAssemblyDefinitionReferenceGUID(string guid);
        public static string AssemblyDefinitionReferenceGUIDToGUID(string reference);
        public static string GetAssemblyRootNamespaceFromScriptPath(string sourceFilePath);
        public static AssemblyDefinitionPlatform[] GetAssemblyDefinitionPlatforms();
        public static string[] GetDefinesFromAssemblyName(string assemblyName);
        public static string[] GetResponseFileDefinesFromAssemblyName(string assemblyName);
        public static string[] GetPrecompiledAssemblyNames();
        public static bool IsDefineConstraintsCompatible(string[] defines, string[] defineConstraints);
        public static string[] GetPrecompiledAssemblyPaths(PrecompiledAssemblySources precompiledAssemblySources);
        public static string GetPrecompiledAssemblyPathFromAssemblyName(string assemblyName);
        public static void RequestScriptCompilation();

        [Flags]
        public enum PrecompiledAssemblySources
        {
            UserAssembly = 1,
            UnityEngine = 2,
            UnityEditor = 4,
            SystemAssembly = 8,
            UnityAssembly = 16,
            All = -1
        }
    }
}
namespace UnityEditor.Compilation
{
    public enum AssemblyBuilderStatus
    {
        NotStarted = 0,
        IsCompiling = 1,
        Finished = 2
    }
}
using System;

namespace UnityEditor.Compilation
{
    [Flags]
    public enum AssemblyBuilderFlags
    {
        None = 0,
        EditorAssembly = 1,
        DevelopmentBuild = 2
    }
}
using System;

namespace UnityEditor.Compilation
{
    [Flags]
    public enum ReferencesOptions
    {
        None = 0,
        UseEngineModules = 1
    }
}
using System;

namespace UnityEditor.Compilation
{
    public class AssemblyBuilder
    {
        public AssemblyBuilder(string assemblyPath, params string[] scriptPaths);

        public string[] scriptPaths { get; }
        public string assemblyPath { get; }
        public string[] additionalDefines { get; set; }
        public string[] additionalReferences { get; set; }
        public string[] excludeReferences { get; set; }
        public ScriptCompilerOptions compilerOptions { get; set; }
        public ReferencesOptions referencesOptions { get; set; }
        public AssemblyBuilderFlags flags { get; set; }
        public BuildTargetGroup buildTargetGroup { get; set; }
        public BuildTarget buildTarget { get; set; }
        public string[] defaultReferences { get; }
        public string[] defaultDefines { get; }
        public AssemblyBuilderStatus status { get; }

        public event Action<string> buildStarted;
        public event Action<string, CompilerMessage[]> buildFinished;

        public bool Build();
    }
}
using System;

namespace UnityEditor.Compilation
{
    public class AssemblyDefinitionException : Exception
    {
        public AssemblyDefinitionException(string message, params string[] filePaths);

        public string[] filePaths { get; }
    }
}
using System;

namespace UnityEditor.Compilation
{
    public class PrecompiledAssemblyException : Exception
    {
        public PrecompiledAssemblyException(string message, params string[] filePaths);

        public string[] filePaths { get; }
    }
}
using System;

namespace UnityEditor.Compilation
{
    [Flags]
    public enum AssemblyFlags
    {
        None = 0,
        EditorAssembly = 1
    }
}
namespace UnityEditor.Compilation
{
    public class ScriptCompilerOptions
    {
        public ScriptCompilerOptions();

        public string RoslynAnalyzerRulesetPath { get; set; }
        public string[] RoslynAnalyzerDllPaths { get; set; }
        public bool AllowUnsafeCode { get; set; }
        public bool EmitReferenceAssembly { get; set; }
        public string[] AdditionalCompilerArguments { get; set; }
        public CodeOptimization CodeOptimization { get; set; }
        public ApiCompatibilityLevel ApiCompatibilityLevel { get; set; }
        public string[] ResponseFiles { get; set; }
        public string LanguageVersion { get; }
    }
}
namespace UnityEditor.Compilation
{
    public enum AssembliesType
    {
        Editor = 0,
        Player = 1,
        PlayerWithoutTestAssemblies = 2
    }
}
namespace UnityEditor.Compilation
{
    public enum AssemblyDefinitionReferenceType
    {
        Name = 0,
        Guid = 1
    }
}
namespace UnityEditor.Compilation
{
    public enum CodeOptimization
    {
        None = 0,
        Debug = 1,
        Release = 2
    }
}
namespace UnityEditor.Compilation
{
    public class Assembly
    {
        public Assembly(string name, string outputPath, string[] sourceFiles, string[] defines, Assembly[] assemblyReferences, string[] compiledAssemblyReferences, AssemblyFlags flags);
        public Assembly(string name, string outputPath, string[] sourceFiles, string[] defines, Assembly[] assemblyReferences, string[] compiledAssemblyReferences, AssemblyFlags flags, ScriptCompilerOptions compilerOptions);
        public Assembly(string name, string outputPath, string[] sourceFiles, string[] defines, Assembly[] assemblyReferences, string[] compiledAssemblyReferences, AssemblyFlags flags, ScriptCompilerOptions compilerOptions, string rootNamespace);

        public string name { get; }
        public string rootNamespace { get; }
        public string outputPath { get; }
        public string[] sourceFiles { get; }
        public string[] defines { get; }
        public Assembly[] assemblyReferences { get; }
        public string[] compiledAssemblyReferences { get; }
        public AssemblyFlags flags { get; }
        public ScriptCompilerOptions compilerOptions { get; }
        public string[] allReferences { get; }
    }
}
namespace UnityEditor.Compilation
{
    public class ResponseFileData
    {
        public string[] Defines;
        public string[] FullPathReferences;
        public string[] Errors;
        public string[] OtherArguments;
        public bool Unsafe;

        public ResponseFileData();
    }
}
namespace UnityEditor.Compilation
{
    public struct AssemblyDefinitionPlatform
    {
        public string Name { get; }
        public string DisplayName { get; }
        public BuildTarget BuildTarget { get; }
    }
}
namespace UnityEditor.Compilation
{
    public enum CompilerMessageType
    {
        Error = 0,
        Warning = 1
    }
}
namespace UnityEditor.Compilation
{
    public struct CompilerMessage
    {
        public string message;
        public string file;
        public int line;
        public int column;
        public CompilerMessageType type;
    }
}
using System;
using UnityEngine.Scripting;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.AssetImporters
{
    [RequiredByNativeCode]
    [MovedFrom("UnityEditor.Experimental.AssetImporters")]
    [AttributeUsage(Method, Inherited = False, AllowMultiple = True)]
    public class CollectImportedDependenciesAttribute : Attribute
    {
        public CollectImportedDependenciesAttribute(Type importerType, uint version);

        public Type importerType { get; }
        public uint version { get; }
    }
}
using System.Collections.Generic;
using UnityEditor.Experimental;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Scripting;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.AssetImporters
{
    [RequiredByNativeCode]
    [NativeHeader("Editor/Src/AssetPipeline/AssetImportContext.h")]
    [MovedFrom("UnityEditor.Experimental.AssetImporters")]
    public class AssetImportContext
    {
        public string assetPath { get; }
        public BuildTarget selectedBuildTarget { get; }
        public Object mainObject { get; }

        public string GetResultPath(string extension);
        [NativeThrows]
        public void SetMainObject(Object obj);
        public void AddObjectToAsset(string identifier, Object obj);
        [FreeFunction("AssetImportContextBindings::GetObjects", HasExplicitThis = True)]
        public void GetObjects([NotNull("ArgumentNullException")] List<Object> objects);
        [NativeThrows]
        public void AddObjectToAsset(string identifier, Object obj, Texture2D thumbnail);
        public void DependsOnSourceAsset(string path);
        public void DependsOnSourceAsset(GUID guid);
        public void DependsOnArtifact(ArtifactKey key);
        public void DependsOnArtifact(GUID guid);
        public void DependsOnArtifact(string path);
        public void DependsOnCustomDependency(string dependency);
        public void LogImportError(string msg, Object obj = null);
        public void LogImportWarning(string msg, Object obj = null);
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor.AssetImporters
{
    [NativeType(Header = "Editor/Src/AssetPipeline/ModelImporting/MaterialDescription.h")]
    public struct TexturePropertyDescription
    {
        public Vector2 offset;
        public Vector2 scale;
        public Texture texture;
        public string relativePath;
        public string path;
    }
}
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.AssetImporters
{
    [RequiredByNativeCode]
    [NativeHeader("Editor/Src/AssetPipeline/ModelImporting/MaterialDescription.h")]
    public class MaterialDescription : IDisposable
    {
        public MaterialDescription();

        ~MaterialDescription();

        [NativeProperty("materialName", Field)]
        public string materialName { get; }

        public void Dispose();
        public bool TryGetProperty(string propertyName, out float value);
        public bool TryGetProperty(string propertyName, out Vector4 value);
        public bool TryGetProperty(string propertyName, out string value);
        public bool TryGetProperty(string propertyName, out TexturePropertyDescription value);
        public void GetVector4PropertyNames(List<string> names);
        public void GetFloatPropertyNames(List<string> names);
        public void GetTexturePropertyNames(List<string> names);
        public void GetStringPropertyNames(List<string> names);
        public bool TryGetAnimationCurve(string clipName, string propertyName, out AnimationCurve value);
        public bool HasAnimationCurveInClip(string clipName, string propertyName);
        public bool HasAnimationCurve(string propertyName);
    }
}
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.AssetImporters
{
    [MovedFrom("UnityEditor.Experimental.AssetImporters")]
    public struct SpriteImportData
    {
        public string name { get; set; }
        public Rect rect { get; set; }
        public SpriteAlignment alignment { get; set; }
        public Vector2 pivot { get; set; }
        public Vector4 border { get; set; }
        public List<Vector2[]> outline { get; set; }
        public float tessellationDetail { get; set; }
        public string spriteID { get; set; }
    }
}
using UnityEngine;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.AssetImporters
{
    [MovedFrom("UnityEditor.Experimental.AssetImporters")]
    public struct TextureGenerationOutput
    {
        public Texture2D texture { get; }
        public string importInspectorWarnings { get; }
        public string[] importWarnings { get; }
        public Texture2D thumbNail { get; }
        public Sprite[] sprites { get; }
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.AssetImporters
{
    [MovedFrom("UnityEditor.Experimental.AssetImporters")]
    [NativeAsStruct]
    public class SourceTextureInformation
    {
        public SourceTextureInformation();

        public int width { get; set; }
        public int height { get; set; }
        public bool containsAlpha { get; set; }
        public bool hdr { get; set; }
    }
}
using UnityEngine;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.AssetImporters
{
    [MovedFrom("UnityEditor.Experimental.AssetImporters")]
    public struct TextureGenerationSettings
    {
        public TextureGenerationSettings(TextureImporterType type);

        public string assetPath { get; set; }
        public bool qualifyForSpritePacking { get; set; }
        public bool enablePostProcessor { get; set; }
        public TextureImporterSettings textureImporterSettings { get; set; }
        public TextureImporterPlatformSettings platformSettings { get; set; }
        public SourceTextureInformation sourceTextureInformation { get; set; }
        public SpriteImportData[] spriteImportData { get; set; }
        public string spritePackingTag { get; set; }
        public SecondarySpriteTexture[] secondarySpriteTextures { get; set; }
    }
}
using Unity.Collections;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.AssetImporters
{
    [MovedFrom("UnityEditor.Experimental.AssetImporters")]
    [NativeHeader("Runtime/Serialize/BuildTarget.h")]
    [NativeHeader("Editor/Src/AssetPipeline/TextureImporting/TextureImporter.bindings.h")]
    [NativeHeader("Editor/Src/AssetPipeline/TextureImporting/TextureImporterTypes.h")]
    [NativeHeader("Editor/Src/AssetPipeline/TextureImporting/TextureGenerator.h")]
    public static class TextureGenerator
    {
        public static TextureGenerationOutput GenerateTexture(TextureGenerationSettings settings, NativeArray<Color32> colorBuffer);
    }
}
using UnityEngine;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.AssetImporters
{
    [MovedFrom("UnityEditor.Experimental.AssetImporters")]
    public class FBXMaterialDescriptionPreprocessor : AssetPostprocessor
    {
        public FBXMaterialDescriptionPreprocessor();

        public override uint GetVersion();
        public override int GetPostprocessOrder();
        public void OnPreprocessMaterialDescription(MaterialDescription description, Material material, AnimationClip[] clips);
    }
}
using UnityEngine;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.AssetImporters
{
    [MovedFrom("UnityEditor.Experimental.AssetImporters")]
    public class SketchupMaterialDescriptionPreprocessor : AssetPostprocessor
    {
        public SketchupMaterialDescriptionPreprocessor();

        public override uint GetVersion();
        public override int GetPostprocessOrder();
        public void OnPreprocessMaterialDescription(MaterialDescription description, Material material, AnimationClip[] clips);
    }
}
using UnityEngine;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.AssetImporters
{
    [MovedFrom("UnityEditor.Experimental.AssetImporters")]
    public class ThreeDSMaterialDescriptionPreprocessor : AssetPostprocessor
    {
        public ThreeDSMaterialDescriptionPreprocessor();

        public override uint GetVersion();
        public override int GetPostprocessOrder();
        public void OnPreprocessMaterialDescription(MaterialDescription description, Material material, AnimationClip[] clips);
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.AssetImporters
{
    [NativeHeader("Modules/AssetPipelineEditor/ImportSettings/AssetImporterEditorUtility.h")]
    [MovedFrom("UnityEditor.Experimental.AssetImporters")]
    public abstract class AssetImporterEditor : Editor
    {
        protected AssetImporterEditor();

        protected internal UnityEngine.Object[] assetTargets { get; }
        protected internal UnityEngine.Object assetTarget { get; }
        protected internal SerializedObject assetSerializedObject { get; }
        protected UnityEngine.Object[] extraDataTargets { get; }
        protected UnityEngine.Object extraDataTarget { get; }
        protected ExtraDataSerializedObject extraDataSerializedObject { get; }
        protected virtual bool needsApplyRevert { get; }
        protected virtual Type extraDataType { get; }
        protected virtual bool useAssetDrawPreview { get; }
        public virtual bool showImportedObject { get; }

        protected virtual void InitializeExtraDataInstance(UnityEngine.Object extraData, int targetIndex);
        public virtual void OnEnable();
        public virtual void OnDisable();
        protected virtual void Awake();
        public override void OnInspectorGUI();
        protected virtual void ResetValues();
        public virtual bool HasModified();
        protected virtual bool CanApply();
        protected virtual void Apply();
        protected internal void ApplyAndImport();
        protected void RevertButton();
        protected bool ApplyButton();
        protected virtual bool OnApplyRevertGUI();
        protected void ApplyRevertGUI();

        protected sealed class ExtraDataSerializedObject : SerializedObject
        {
            public void Update();
            public void UpdateIfRequiredOrScript();
            public void ApplyModifiedProperties();
            public void SetIsDifferentCacheDirty();
        }
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.AssetImporters
{
    [MovedFrom("UnityEditor.Experimental.AssetImporters")]
    [CanEditMultipleObjects]
    [CustomEditor(typeof(ScriptedImporter), True)]
    public class ScriptedImporterEditor : AssetImporterEditor
    {
        public ScriptedImporterEditor();
    }
}
using System;
using UnityEngine;
using UnityEngine.Scripting;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.AssetImporters
{
    [Preserve]
    [ExtensionOfNativeClass]
    [MovedFrom("UnityEditor.Experimental.AssetImporters")]
    [UsedByNativeCode]
    public abstract class ScriptedImporter : AssetImporter
    {
        protected ScriptedImporter();

        public abstract void OnImportAsset(AssetImportContext ctx);
        public virtual bool SupportsRemappedAssetType(Type type);
    }
}
using System;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.AssetImporters
{
    [AttributeUsage(Class, Inherited = False)]
    [MovedFrom("UnityEditor.Experimental.AssetImporters")]
    public class ScriptedImporterAttribute : Attribute
    {
        [Obsolete("Use overrideFileExtensions instead to specify this importer is an override for those file extensions")]
        public bool AutoSelect;
        public bool AllowCaching;

        public ScriptedImporterAttribute(int version, string ext);
        public ScriptedImporterAttribute(int version, string ext, int importQueueOffset);
        public ScriptedImporterAttribute(int version, string[] exts);
        public ScriptedImporterAttribute(int version, string[] exts, string[] overrideExts);
        public ScriptedImporterAttribute(int version, string[] exts, int importQueueOffset);
        public ScriptedImporterAttribute(int version, string[] exts, string[] overrideExts, int importQueueOffset);

        public int version { get; }
        public int importQueuePriority { get; }
        public string[] fileExtensions { get; }
        public string[] overrideFileExtensions { get; }
    }
}
using UnityEngine.Scripting;

namespace UnityEditor.Callbacks
{
    [RequiredByNativeCode]
    public sealed class PostProcessBuildAttribute : CallbackOrderAttribute
    {
        public PostProcessBuildAttribute();
        public PostProcessBuildAttribute(int callbackOrder);
    }
}
using UnityEngine.Scripting;

namespace UnityEditor.Callbacks
{
    [RequiredByNativeCode]
    public sealed class PostProcessSceneAttribute : CallbackOrderAttribute
    {
        public PostProcessSceneAttribute();
        public PostProcessSceneAttribute(int callbackOrder);
        public PostProcessSceneAttribute(int callbackOrder, int version);
    }
}
using UnityEngine.Scripting;

namespace UnityEditor.Callbacks
{
    [RequiredByNativeCode]
    public sealed class DidReloadScripts : CallbackOrderAttribute
    {
        public DidReloadScripts();
        public DidReloadScripts(int callbackOrder);
    }
}
using UnityEngine.Scripting;

namespace UnityEditor.Callbacks
{
    [RequiredByNativeCode]
    public sealed class OnOpenAssetAttribute : CallbackOrderAttribute
    {
        public OnOpenAssetAttribute();
        public OnOpenAssetAttribute(int callbackOrder);
    }
}
namespace UnityEditor.Experimental
{
    public static class BuildPipelineExperimental
    {
        public static string GetSessionIdForBuildTarget(BuildTarget target);
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Internal;

namespace UnityEditor.Experimental
{
    [StaticAccessor("EditorResources", DoubleColon)]
    [NativeHeader("Editor/Src/EditorResources.h")]
    [ExcludeFromDocs]
    public class EditorResources
    {
        public EditorResources();

        [NativeProperty("k_NormalSkinIndex", True, Field)]
        public static int normalSkinIndex { get; }
        [NativeProperty("k_DarkSkinIndex", True, Field)]
        public static int darkSkinIndex { get; }
        [NativeProperty("k_LightSkinSourcePath", True, Field)]
        public static string lightSkinSourcePath { get; }
        [NativeProperty("k_DarkSkinSourcePath", True, Field)]
        public static string darkSkinSourcePath { get; }
        [NativeProperty("k_FontsPath", True, Field)]
        public static string fontsPath { get; }
        [NativeProperty("k_BrushesPath", True, Field)]
        public static string brushesPath { get; }
        [NativeProperty("k_IconsPath", True, Field)]
        public static string iconsPath { get; }
        [NativeProperty("k_GeneratedIconsPath", True, Field)]
        public static string generatedIconsPath { get; }
        [NativeProperty("k_FolderIconName", True, Field)]
        public static string folderIconName { get; }
        [NativeProperty("k_EmptyFolderIconName", True, Field)]
        public static string emptyFolderIconName { get; }
        [NativeProperty("k_EditorDefaultResourcesPath", True, Field)]
        public static string editorDefaultResourcesPath { get; }
        [NativeProperty("k_LibraryBundlePath", True, Field)]
        public static string libraryBundlePath { get; }
        public static string dataPath { get; }

        public static UnityEngine.Object Load(string assetPath, [UnityType] Type type);
        public static string GetAssetPath(UnityEngine.Object obj);
        public static string ExpandPath(string path);
        public static string GetFullPath(string path);
        public static bool Exists(string path);
        public static T Load<T>(string assetPath, bool isRequired = True) where T : UnityEngine.Object;
    }
}
using System;
using UnityEditor.AssetImporters;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Internal;

namespace UnityEditor.Experimental
{
    [NativeHeader("Modules/AssetDatabase/Editor/Public/AssetDatabaseExperimental.h")]
    [NativeHeader("Modules/AssetDatabase/Editor/V2/AssetDatabaseCounters.h")]
    [NativeHeader("Modules/AssetDatabase/Editor/V2/AssetDatabaseInternal.h")]
    public sealed class AssetDatabaseExperimental
    {
        public AssetDatabaseExperimental();

        public static AssetDatabaseCounters counters { get; }
        public static OnDemandMode ActiveOnDemandMode { get; set; }

        [Obsolete("AssetDatabaseExperimental.cacheServerConnectionChanged has been deprecated. Use AssetDatabase.cacheServerConnectionChanged instead (UnityUpgradable) -> UnityEditor.AssetDatabase.cacheServerConnectionChanged", False)]
        public static event Action<CacheServerConnectionChangedParameters> cacheServerConnectionChanged;

        [FreeFunction("AssetDatabase::ClearImporterOverride")]
        [Obsolete("AssetDatabaseExperimental.ClearImporterOverride() has been deprecated. Use AssetDatabase.ClearImporterOverride() instead (UnityUpgradable) -> UnityEditor.AssetDatabase.ClearImporterOverride(*)", False)]
        public static void ClearImporterOverride(string path);
        [FreeFunction("AssetDatabase::IsCacheServerEnabled")]
        [Obsolete("AssetDatabaseExperimental.IsCacheServerEnabled() has been deprecated. Use AssetDatabase.IsCacheServerEnabled() instead (UnityUpgradable) -> UnityEditor.AssetDatabase.IsCacheServerEnabled(*)", False)]
        public static bool IsCacheServerEnabled();
        [Obsolete("AssetDatabaseExperimental.SetImporterOverride<T>() has been deprecated. Use AssetDatabase.SetImporterOverride<T>() instead (UnityUpgradable) -> UnityEditor.AssetDatabase.SetImporterOverride<T>(*)", False)]
        public static void SetImporterOverride<T>(string path) where T : ScriptedImporter;
        [FreeFunction("AssetDatabase::GetImporterOverride")]
        [Obsolete("AssetDatabaseExperimental.GetImporterOverride() has been deprecated. Use AssetDatabase.GetImporterOverride() instead (UnityUpgradable) -> UnityEditor.AssetDatabase.GetImporterOverride(*)", False)]
        public static Type GetImporterOverride(string path);
        [FreeFunction("AssetDatabase::GetAvailableImporterTypes")]
        [Obsolete("AssetDatabaseExperimental.GetAvailableImporterTypes() has been deprecated. Use AssetDatabase.GetAvailableImporterTypes() instead (UnityUpgradable) -> UnityEditor.AssetDatabase.GetAvailableImporterTypes(*)", False)]
        public static Type[] GetAvailableImporterTypes(string path);
        [Obsolete("AssetDatabaseExperimental.CanConnectToCacheServer() has been deprecated. Use AssetDatabase.CanConnectToCacheServer() instead (UnityUpgradable) -> UnityEditor.AssetDatabase.CanConnectToCacheServer(*)", False)]
        [FreeFunction("AcceleratorClientCanConnectTo")]
        public static bool CanConnectToCacheServer(string ip, ushort port);
        [FreeFunction]
        [Obsolete("AssetDatabaseExperimental.RefreshSettings() has been deprecated. Use AssetDatabase.RefreshSettings() instead (UnityUpgradable) -> UnityEditor.AssetDatabase.RefreshSettings(*)", False)]
        public static void RefreshSettings();
        [Obsolete("AssetDatabaseExperimental.IsConnectedToCacheServer() has been deprecated. Use AssetDatabase.IsConnectedToCacheServer() instead (UnityUpgradable) -> UnityEditor.AssetDatabase.IsConnectedToCacheServer(*)", False)]
        [FreeFunction("AcceleratorClientIsConnected")]
        public static bool IsConnectedToCacheServer();
        [Obsolete("AssetDatabaseExperimental.GetCacheServerAddress() has been deprecated. Use AssetDatabase.GetCacheServerAddress() instead (UnityUpgradable) -> UnityEditor.AssetDatabase.GetCacheServerAddress(*)", False)]
        [FreeFunction]
        public static string GetCacheServerAddress();
        [Obsolete("AssetDatabaseExperimental.GetCacheServerPort() has been deprecated. Use AssetDatabase.GetCacheServerPort() instead (UnityUpgradable) -> UnityEditor.AssetDatabase.GetCacheServerPort(*)", False)]
        [FreeFunction]
        public static ushort GetCacheServerPort();
        [Obsolete("AssetDatabaseExperimental.GetCacheServerNamespacePrefix() has been deprecated. Use AssetDatabase.GetCacheServerNamespacePrefix() instead (UnityUpgradable) -> UnityEditor.AssetDatabase.GetCacheServerNamespacePrefix(*)", False)]
        [FreeFunction("AssetDatabase::GetCacheServerNamespacePrefix")]
        public static string GetCacheServerNamespacePrefix();
        [Obsolete("AssetDatabaseExperimental.GetCacheServerEnableDownload() has been deprecated. Use AssetDatabase.GetCacheServerEnableDownload() instead (UnityUpgradable) -> UnityEditor.AssetDatabase.GetCacheServerEnableDownload(*)", False)]
        [FreeFunction("AssetDatabase::GetCacheServerEnableDownload")]
        public static bool GetCacheServerEnableDownload();
        [Obsolete("AssetDatabaseExperimental.GetCacheServerEnableUpload() has been deprecated. Use AssetDatabase.GetCacheServerEnableUpload() instead (UnityUpgradable) -> UnityEditor.AssetDatabase.GetCacheServerEnableUpload(*)", False)]
        [FreeFunction("AssetDatabase::GetCacheServerEnableUpload")]
        public static bool GetCacheServerEnableUpload();
        [FreeFunction("AssetDatabase::IsDirectoryMonitoringEnabled")]
        [Obsolete("AssetDatabaseExperimental.IsDirectoryMonitoringEnabled() has been deprecated. Use AssetDatabase.IsDirectoryMonitoringEnabled() instead (UnityUpgradable) -> UnityEditor.AssetDatabase.IsDirectoryMonitoringEnabled(*)", False)]
        public static bool IsDirectoryMonitoringEnabled();
        [FreeFunction("AssetDatabaseExperimental::RegisterCustomDependency")]
        [Obsolete("AssetDatabaseExperimental.RegisterCustomDependency() has been deprecated. Use AssetDatabase.RegisterCustomDependency() instead (UnityUpgradable) -> UnityEditor.AssetDatabase.RegisterCustomDependency(*)", False)]
        [PreventExecutionInState(kPreventCustomDependencyChanges, PreventExecution_ManagedException, "Custom dependencies can only be removed when the assetdatabase is not importing.")]
        public static void RegisterCustomDependency(string dependency, Hash128 hashOfValue);
        [Obsolete("AssetDatabaseExperimental.UnregisterCustomDependencyPrefixFilter() has been deprecated. Use AssetDatabase.UnregisterCustomDependencyPrefixFilter() instead (UnityUpgradable) -> UnityEditor.AssetDatabase.UnregisterCustomDependencyPrefixFilter(*)", False)]
        [PreventExecutionInState(kPreventCustomDependencyChanges, PreventExecution_ManagedException, "Custom dependencies can only be removed when the assetdatabase is not importing.")]
        [FreeFunction("AssetDatabaseExperimental::UnregisterCustomDependencyPrefixFilter")]
        public static uint UnregisterCustomDependencyPrefixFilter(string prefixFilter);
        [Obsolete("AssetDatabaseExperimental.IsAssetImportWorkerProcess() has been deprecated. Use AssetDatabase.IsAssetImportWorkerProcess()", False)]
        [FreeFunction("AssetDatabase::IsAssetImportProcess")]
        public static bool IsAssetImportWorkerProcess();
        [Obsolete("Has been replaced by AssetDatabaseExperimental.RefreshSettings", True)]
        public static void ReconnectToCacheServer();
        public static ArtifactID LookupArtifact(ArtifactKey artifactKey);
        public static ArtifactID ProduceArtifact(ArtifactKey artifactKey);
        public static ArtifactID ProduceArtifactAsync(ArtifactKey artifactKey);
        public static ArtifactID[] ProduceArtifactsAsync(GUID[] artifactKey, [DefaultValue("null")] Type importerType = null);
        public static ArtifactID ForceProduceArtifact(ArtifactKey artifactKey);
        [Obsolete("GetArtifactHash() has been removed. Use LookupArtifact(), ProduceArtifact() or ForceProduceArtifact() instead.")]
        [ExcludeFromDocs]
        public static Hash128 GetArtifactHash(string guid, ImportSyncMode mode = Block);
        [Obsolete("GetArtifactHash() has been removed. Use LookupArtifact(), ProduceArtifact() or ForceProduceArtifact() instead.")]
        public static Hash128 GetArtifactHash(string guid, [DefaultValue("null")] Type importerType, ImportSyncMode mode = Block);
        public static bool GetArtifactPaths(ArtifactID hash, out string[] paths);
        [Obsolete("GetArtifactPaths(Hash128, out string[]) has been removed. Use GetArtifactPaths(ArtifactID, out string[]) instead.")]
        public static bool GetArtifactPaths(Hash128 hash, out string[] paths);
        [Obsolete("GetArtifactHashes() has been removed. Use LookupArtifact(), ProduceArtifact() or ForceProduceArtifact() instead.")]
        public static Hash128[] GetArtifactHashes(string[] guids, ImportSyncMode mode = Block);
        public static OnDemandProgress GetOnDemandArtifactProgress(ArtifactKey artifactKey);
        [Obsolete("GetOnDemandArtifactProgress(string) has been removed. Use GetOnDemandArtifactProgress(ArtifactKey) instead.")]
        public static OnDemandProgress GetOnDemandArtifactProgress(string guid);
        [Obsolete("GetOnDemandArtifactProgress(string,Type) has been removed. Use GetOnDemandArtifactProgress(ArtifactKey) instead.")]
        public static OnDemandProgress GetOnDemandArtifactProgress(string guid, Type importerType);

        [Obsolete("AssetDatabaseExperimental.CacheServerConnectionChangedParameters has been deprecated. Use UnityEditor.CacheServerConnectionChangedParameters instead (UnityUpgradable) -> UnityEditor.CacheServerConnectionChangedParameters", False)]
        public struct CacheServerConnectionChangedParameters
        {
        }
        public enum OnDemandMode
        {
            Off = 0,
            Lazy = 1,
            Background = 2
        }
        [Obsolete("ImportSyncMode has been removed from the editor API", False)]
        public enum ImportSyncMode
        {
            Block = 0,
            Queue = 1,
            Poll = 2
        }
        public struct AssetDatabaseCounters
        {
            public CacheServerCounters cacheServer;
            public ImportCounters import;

            public void ResetDeltas();

            public struct Counter
            {
                public long total;
                public long delta;
            }
            public struct CacheServerCounters
            {
                public Counter metadataRequested;
                public Counter metadataDownloaded;
                public Counter metadataFailedToDownload;
                public Counter metadataUploaded;
                public Counter metadataFailedToUpload;
                public Counter metadataVersionsDownloaded;
                public Counter metadataMatched;
                public Counter artifactsDownloaded;
                public Counter artifactFilesDownloaded;
                public Counter artifactFilesFailedToDownload;
                public Counter artifactsUploaded;
                public Counter artifactFilesUploaded;
                public Counter artifactFilesFailedToUpload;
                public Counter connects;
                public Counter disconnects;
            }
            public struct ImportCounters
            {
                public Counter imported;
                public Counter importedInProcess;
                public Counter importedOutOfProcess;
                public Counter refresh;
                public Counter domainReload;
            }
        }
    }
}
using System;

namespace UnityEditor.Experimental
{
    public struct AssetMoveInfo : IEquatable<AssetMoveInfo>
    {
        public AssetMoveInfo(string sourceAssetPath, string destinationAssetPath);

        public string sourceAssetPath { get; }
        public string destinationAssetPath { get; }

        public bool Equals(AssetMoveInfo other);
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static bool operator ==(AssetMoveInfo left, AssetMoveInfo right);
        public static bool operator !=(AssetMoveInfo left, AssetMoveInfo right);
    }
}
using System.Collections.Generic;

namespace UnityEditor.Experimental
{
    public abstract class AssetsModifiedProcessor
    {
        protected AssetsModifiedProcessor();

        public HashSet<string> assetsReportedChanged { get; set; }

        protected void ReportAssetChanged(string assetChanged);
        protected abstract void OnAssetsModified(string[] changedAssets, string[] addedAssets, string[] deletedAssets, AssetMoveInfo[] movedAssets);
    }
}
using System;
using Unity.Collections;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Rendering;
using UnityEngine.SceneManagement;

namespace UnityEditor.Experimental
{
    public sealed class Lightmapping
    {
        public Lightmapping();

        [StaticAccessor("ProgressiveRuntimeManager::Get()", Arrow)]
        public static bool probesIgnoreDirectEnvironment { get; set; }
        [Obsolete("UnityEditor.Experimental.Lightmapping.extractAmbientOcclusion is obsolete, use Lightmapping.lightingSettings.extractAO instead. ", False)]
        public static bool extractAmbientOcclusion { get; set; }

        public static event Action additionalBakedProbesCompleted;

        [StaticAccessor("ProgressiveRuntimeManager::Get()", Arrow)]
        public static void SetCustomBakeInputs(Vector4[] inputData, int sampleCount);
        [StaticAccessor("ProgressiveRuntimeManager::Get()", Arrow)]
        public static bool GetCustomBakeResults(out Vector4[] results);
        [NativeThrows]
        [FreeFunction]
        public static bool BakeAsync(Scene targetScene);
        [NativeThrows]
        [FreeFunction]
        public static bool Bake(Scene targetScene);
        [Obsolete("Please use the new GetAdditionalBakedProbes with added octahedral depth map data.", False)]
        public static bool GetAdditionalBakedProbes(int id, NativeArray<SphericalHarmonicsL2> outBakedProbeSH, NativeArray<float> outBakedProbeValidity);
        public static bool GetAdditionalBakedProbes(int id, NativeArray<SphericalHarmonicsL2> outBakedProbeSH, NativeArray<float> outBakedProbeValidity, NativeArray<float> outBakedProbeOctahedralDepth);
        [FreeFunction]
        public static void SetAdditionalBakedProbes(int id, Vector3[] positions);
    }
}
namespace UnityEditor.Experimental
{
    public enum OnDemandState
    {
        Unavailable = 0,
        Processing = 1,
        Downloading = 2,
        Available = 3,
        Failed = 4
    }
}
using System;
using UnityEngine.Bindings;

namespace UnityEditor.Experimental
{
    [NativeHeader("Modules/AssetDatabase/Editor/Public/AssetDatabaseExperimental.h")]
    public struct ArtifactKey
    {
        public GUID guid;
        public Type importerType;

        public ArtifactKey(GUID g);
        public ArtifactKey(GUID guid, Type importerType);

        public bool isValid { get; }
    }
}
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.Experimental
{
    [RequiredByNativeCode]
    [NativeHeader("Modules/AssetDatabase/Editor/Public/AssetDatabaseTypes.h")]
    public struct ArtifactID
    {
        public Hash128 value;

        public bool isValid { get; }
    }
}
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.Experimental
{
    [NativeHeader("Modules/AssetDatabase/Editor/Public/AssetDatabaseTypes.h")]
    [RequiredByNativeCode]
    public struct OnDemandProgress
    {
        public OnDemandState state;
        public float progress;
    }
}
using UnityEditor.ShortcutManagement;

namespace UnityEditor.Experimental.TerrainAPI
{
    public class TerrainToolShortcutContext : IShortcutToolContext
    {
        public void SelectPaintTool<T>() where T : TerrainPaintTool<T>;
    }
}
using System;

namespace UnityEditor.Experimental.TerrainAPI
{
    [Flags]
    public enum BrushGUIEditFlags
    {
        Select = 1,
        Inspect = 2,
        Size = 4,
        Opacity = 8,
        SelectAndInspect = 3,
        All = 15
    }
}
using System;

namespace UnityEditor.Experimental.TerrainAPI
{
    [Flags]
    public enum RepaintFlags
    {
        UI = 1,
        Scene = 2
    }
}
using System;
using UnityEngine;

namespace UnityEditor.Experimental.TerrainAPI
{
    public interface IOnPaint
    {
        Texture brushTexture { get; }
        Vector2 uv { get; }
        float brushStrength { get; }
        float brushSize { get; }
        bool hitValidTerrain { get; }
        RaycastHit raycastHit { get; }

        [Obsolete("IOnPaint.RepaintAllInspectors has been deprecated. Use IOnPaint.Repaint instead")]
        void RepaintAllInspectors();
        void Repaint(RepaintFlags flags = UI);
    }
}
using UnityEngine;

namespace UnityEditor.Experimental.TerrainAPI
{
    public interface IOnSceneGUI
    {
        SceneView sceneView { get; }
        Texture brushTexture { get; }
        float brushStrength { get; }
        float brushSize { get; }
        bool hitValidTerrain { get; }
        RaycastHit raycastHit { get; }

        void Repaint(RepaintFlags flags = UI);
    }
}
namespace UnityEditor.Experimental.TerrainAPI
{
    public interface IOnInspectorGUI
    {
        void ShowBrushesGUI(int spacing);
        void ShowBrushesGUI(int spacing, BrushGUIEditFlags flags);
        void ShowBrushesGUI(int spacing, BrushGUIEditFlags flags, int textureResolutionPerTile);
        void Repaint(RepaintFlags flags = UI);
    }
}
using UnityEngine;

namespace UnityEditor.Experimental.TerrainAPI
{
    public abstract class TerrainPaintTool<T> : ScriptableSingleton<T>, ITerrainPaintTool where T : TerrainPaintTool<T>
    {
        protected TerrainPaintTool();

        public abstract string GetName();
        public abstract string GetDesc();
        public virtual void OnEnable();
        public virtual void OnDisable();
        public virtual void OnEnterToolMode();
        public virtual void OnExitToolMode();
        public virtual void OnSceneGUI(Terrain terrain, IOnSceneGUI editContext);
        public virtual void OnInspectorGUI(Terrain terrain, IOnInspectorGUI editContext);
        public virtual bool OnPaint(Terrain terrain, IOnPaint editContext);
    }
}
using UnityEngine;
using UnityEngine.Experimental.TerrainAPI;

namespace UnityEditor.Experimental.TerrainAPI
{
    public static class TerrainPaintUtilityEditor
    {
        public static void ShowDefaultPreviewBrush(Terrain terrain, Texture brushTexture, float brushSize);
        public static Material GetDefaultBrushPreviewMaterial();
        public static void DrawBrushPreview(PaintContext heightmapPC, BrushPreview previewTexture, Texture brushTexture, BrushTransform brushXform, Material proceduralMaterial, int materialPassIndex);

        public enum BrushPreview
        {
            SourceRenderTexture = 0,
            DestinationRenderTexture = 1
        }
    }
}
using System;

namespace UnityEditor.Experimental.RestService
{
    [Obsolete("This type is obsolete and will be deleted.", True)]
    public class PlayerDataFileLocator
    {
        public PlayerDataFileLocator();

        public static void Register(Locator locator);

        public delegate bool Locator(ref string path);
    }
}
using UnityEngine.Bindings;

namespace UnityEditor.Experimental.Licensing
{
    [NativeHeader("Modules/Licensing/Public/LicensingUtility.bindings.h")]
    public static class LicensingUtility
    {
        [NativeMethod("HasEntitlement")]
        public static bool HasEntitlement(string entitlement);
        [NativeMethod("HasEntitlements")]
        public static string[] HasEntitlements(string[] entitlements);
    }
}
using System;
using System.ComponentModel;

namespace UnityEditor.Experimental.Build.AssetBundle
{
    [EditorBrowsable(Never)]
    [Obsolete("UnityEditor.Experimental.Build.AssetBundle.CompressionType has been deprecated. Use UnityEngine.CompressionType instead (UnityUpgradable) -> [UnityEngine] UnityEngine.CompressionType", True)]
    public enum CompressionType
    {
        None = 0,
        Lzma = 1,
        Lz4 = 2,
        Lz4HC = 3
    }
}
using System;
using System.ComponentModel;

namespace UnityEditor.Experimental.Build.AssetBundle
{
    [Obsolete("UnityEditor.Experimental.Build.AssetBundle.CompressionLevel has been deprecated. Use UnityEngine.CompressionLevel instead (UnityUpgradable) -> [UnityEngine] UnityEngine.CompressionLevel", True)]
    [EditorBrowsable(Never)]
    public enum CompressionLevel
    {
        None = 0,
        Fastest = 1,
        Fast = 2,
        Normal = 3,
        High = 4,
        Maximum = 5
    }
}
using System;
using System.ComponentModel;

namespace UnityEditor.Experimental.Build.AssetBundle
{
    [Obsolete("UnityEditor.Experimental.Build.AssetBundle.BuildCompression has been deprecated. Use UnityEngine.BuildCompression instead (UnityUpgradable) -> [UnityEngine] UnityEngine.BuildCompression", True)]
    [EditorBrowsable(Never)]
    public struct BuildCompression
    {
        [Obsolete("DefaultUncompressed has been deprecated. Use Uncompressed instead (UnityUpgradable) -> [UnityEngine] UnityEngine.BuildCompression.Uncompressed", True)]
        [EditorBrowsable(Never)]
        public static readonly BuildCompression DefaultUncompressed;
        [EditorBrowsable(Never)]
        [Obsolete("DefaultLZ4 has been deprecated. Use LZ4 instead (UnityUpgradable) -> [UnityEngine] UnityEngine.BuildCompression.LZ4", True)]
        public static readonly BuildCompression DefaultLZ4;
        [Obsolete("DefaultLZMA has been deprecated. Use LZMA instead (UnityUpgradable) -> [UnityEngine] UnityEngine.BuildCompression.LZMA", True)]
        [EditorBrowsable(Never)]
        public static readonly BuildCompression DefaultLZMA;
    }
}
using System;
using UnityEditor.SceneManagement;
using UnityEngine;

namespace UnityEditor.Experimental.SceneManagement
{
    public sealed class PrefabStage : PreviewSceneStage
    {
        public GameObject prefabContentsRoot { get; }
        public GameObject openedFromInstanceRoot { get; }
        public GameObject openedFromInstanceObject { get; }
        public Mode mode { get; }
        public override string assetPath { get; }
        [Obsolete("prefabAssetPath has been deprecated. Use assetPath instead.")]
        public string prefabAssetPath { get; }

        public static event Action<PrefabStage> prefabStageOpened;
        public static event Action<PrefabStage> prefabStageClosing;
        public static event Action<PrefabStage> prefabStageDirtied;
        public static event Action<GameObject> prefabSaving;
        public static event Action<GameObject> prefabSaved;

        protected override void OnEnable();
        protected override void OnDisable();
        public override ulong GetCombinedSceneCullingMaskForCamera();
        public bool IsPartOfPrefabContents(GameObject gameObject);
        protected internal override bool OnOpenStage();
        protected override void OnCloseStage();
        protected internal override void OnReturnToStage();
        protected internal override void OnFirstTimeOpenStageInSceneView(SceneView sceneView);
        protected internal override GUIContent CreateHeaderContent();
        public void ClearDirtiness();

        public enum Mode
        {
            InIsolation = 0,
            InContext = 1
        }
    }
}
using UnityEngine;

namespace UnityEditor.Experimental.SceneManagement
{
    public class PrefabStageUtility
    {
        public PrefabStageUtility();

        public static PrefabStage GetCurrentPrefabStage();
        public static PrefabStage GetPrefabStage(GameObject gameObject);
    }
}
using System;
using UnityEngine;

namespace UnityEditor.Experimental.Rendering
{
    public interface IScriptableBakedReflectionSystem : IDisposable
    {
        int stageCount { get; }
        Hash128[] stateHashes { get; }

        void Tick(SceneStateHash sceneStateHash, IScriptableBakedReflectionSystemStageNotifier handle);
        void SynchronizeReflectionProbes();
        void Clear();
        void Cancel();
        bool BakeAllReflectionProbes();
    }
}
namespace UnityEditor.Experimental.Rendering
{
    public interface IScriptableBakedReflectionSystemStageNotifier
    {
        void EnterStage(int stage, string progressMessage, float progress);
        void ExitStage(int stage);
        void SetIsDone(bool isDone);
    }
}
using System;
using UnityEngine;
using UnityEngine.Scripting;

namespace UnityEditor.Experimental.Rendering
{
    [RequiredByNativeCode]
    public struct SceneStateHash : IEquatable<SceneStateHash>
    {
        public SceneStateHash(Hash128 sceneObjectsHash, Hash128 skySettingsHash, Hash128 ambientProbeHash);

        public Hash128 sceneObjectsHash { get; }
        public Hash128 skySettingsHash { get; }
        public Hash128 ambientProbeHash { get; }

        public bool Equals(SceneStateHash other);
        public override bool Equals(object obj);
        public override int GetHashCode();
    }
}
using System;
using UnityEngine;

namespace UnityEditor.Experimental.Rendering
{
    public abstract class ScriptableBakedReflectionSystem : IScriptableBakedReflectionSystem, IDisposable
    {
        protected ScriptableBakedReflectionSystem(int stageCount);

        public int stageCount { get; }
        public Hash128[] stateHashes { get; protected set; }

        public virtual void Tick(SceneStateHash sceneStateHash, IScriptableBakedReflectionSystemStageNotifier handle);
        public virtual void SynchronizeReflectionProbes();
        public virtual void Clear();
        public virtual void Cancel();
        public virtual bool BakeAllReflectionProbes();
        protected virtual void Dispose(bool disposing);
    }
}
using UnityEngine.Scripting;

namespace UnityEditor.Experimental.Rendering
{
    [RequiredByNativeCode]
    public static class ScriptableBakedReflectionSystemSettings
    {
        public static IScriptableBakedReflectionSystem system { get; set; }
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngineInternal;

namespace UnityEditor.Animations
{
    [NativeHeader("Modules/Animation/AnimatorController.h")]
    [NativeClass(null)]
    [NativeHeader("Modules/Animation/Animator.h")]
    [NativeHeader("Editor/Src/Animation/StateMachineBehaviourScripting.h")]
    [NativeHeader("Editor/Src/Animation/AnimatorController.bindings.h")]
    public sealed class AnimatorController : RuntimeAnimatorController
    {
        public AnimatorController();

        public AnimatorControllerLayer[] layers { get; set; }
        public AnimatorControllerParameter[] parameters { get; set; }

        public static void SetAnimatorController(Animator animator, AnimatorController controller);
        public string MakeUniqueParameterName(string name);
        public string MakeUniqueLayerName(string name);
        public static StateMachineBehaviourContext[] FindStateMachineBehaviourContext(StateMachineBehaviour behaviour);
        [FreeFunction("AnimatorControllerBindings::Internal_CreateStateMachineBehaviour")]
        public static int CreateStateMachineBehaviour(MonoScript script);
        [TypeInferenceRule(TypeReferencedByFirstArgument)]
        public StateMachineBehaviour AddEffectiveStateMachineBehaviour(Type stateMachineBehaviourType, AnimatorState state, int layerIndex);
        public T AddEffectiveStateMachineBehaviour<T>(AnimatorState state, int layerIndex) where T : StateMachineBehaviour;
        public T[] GetBehaviours<T>() where T : StateMachineBehaviour;
        public void AddLayer(string name);
        public void AddLayer(AnimatorControllerLayer layer);
        public void RemoveLayer(int index);
        public void AddParameter(string name, AnimatorControllerParameterType type);
        public void AddParameter(AnimatorControllerParameter paramater);
        public void RemoveParameter(int index);
        public void RemoveParameter(AnimatorControllerParameter parameter);
        public AnimatorState AddMotion(Motion motion);
        public AnimatorState AddMotion(Motion motion, int layerIndex);
        public AnimatorState CreateBlendTreeInController(string name, out BlendTree tree);
        public AnimatorState CreateBlendTreeInController(string name, out BlendTree tree, int layerIndex);
        public static AnimatorController CreateAnimatorControllerAtPath(string path);
        public static AnimationClip AllocateAnimatorClip(string name);
        public static AnimatorController CreateAnimatorControllerAtPathWithClip(string path, AnimationClip clip);
        public void SetStateEffectiveMotion(AnimatorState state, Motion motion);
        public void SetStateEffectiveMotion(AnimatorState state, Motion motion, int layerIndex);
        public Motion GetStateEffectiveMotion(AnimatorState state);
        public Motion GetStateEffectiveMotion(AnimatorState state, int layerIndex);
        public void SetStateEffectiveBehaviours(AnimatorState state, int layerIndex, StateMachineBehaviour[] behaviours);
        public StateMachineBehaviour[] GetStateEffectiveBehaviours(AnimatorState state, int layerIndex);
    }
}
namespace UnityEditor.Animations
{
    public enum AnimatorLayerBlendingMode
    {
        Override = 0,
        Additive = 1
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor.Animations
{
    [NativeHeader("Editor/Src/Animation/AnimatorControllerLayer.bindings.h")]
    [NativeAsStruct]
    [NativeType(Custom, "MonoAnimatorControllerLayer")]
    [NativeHeader("Editor/Src/Animation/AnimatorControllerLayer.h")]
    public class AnimatorControllerLayer
    {
        public AnimatorControllerLayer();

        public string name { get; set; }
        public AnimatorStateMachine stateMachine { get; set; }
        public AvatarMask avatarMask { get; set; }
        public AnimatorLayerBlendingMode blendingMode { get; set; }
        public int syncedLayerIndex { get; set; }
        public bool iKPass { get; set; }
        public float defaultWeight { get; set; }
        public bool syncedLayerAffectsTiming { get; set; }

        public Motion GetOverrideMotion(AnimatorState state);
        public void SetOverrideMotion(AnimatorState state, Motion motion);
        public StateMachineBehaviour[] GetOverrideBehaviours(AnimatorState state);
        public void SetOverrideBehaviours(AnimatorState state, StateMachineBehaviour[] behaviours);
    }
}
namespace UnityEditor.Animations
{
    public enum BlendTreeType
    {
        Simple1D = 0,
        SimpleDirectional2D = 1,
        FreeformDirectional2D = 2,
        FreeformCartesian2D = 3,
        Direct = 4
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor.Animations
{
    [NativeType("Editor/Src/Animation/BlendTree.h")]
    public struct ChildMotion
    {
        public Motion motion { get; set; }
        public float threshold { get; set; }
        public Vector2 position { get; set; }
        public float timeScale { get; set; }
        public float cycleOffset { get; set; }
        public string directBlendParameter { get; set; }
        public bool mirror { get; set; }
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor.Animations
{
    [ExcludeFromPreset]
    [NativeType("Editor/Src/Animation/BlendTree.h")]
    [NativeHeader("Editor/Src/Animation/BlendTree.bindings.h")]
    public class BlendTree : Motion
    {
        public BlendTree();

        public string blendParameter { get; set; }
        public string blendParameterY { get; set; }
        public BlendTreeType blendType { get; set; }
        public ChildMotion[] children { get; set; }
        public bool useAutomaticThresholds { get; set; }
        public float minThreshold { get; set; }
        public float maxThreshold { get; set; }

        public void AddChild(Motion motion);
        public void AddChild(Motion motion, Vector2 position);
        public void AddChild(Motion motion, float threshold);
        public void RemoveChild(int index);
        public BlendTree CreateBlendTreeChild(float threshold);
        public BlendTree CreateBlendTreeChild(Vector2 position);
    }
}
namespace UnityEditor.Animations
{
    public enum AnimatorConditionMode
    {
        If = 1,
        IfNot = 2,
        Greater = 3,
        Less = 4,
        Equals = 6,
        NotEqual = 7
    }
}
namespace UnityEditor.Animations
{
    public enum TransitionInterruptionSource
    {
        None = 0,
        Source = 1,
        Destination = 2,
        SourceThenDestination = 3,
        DestinationThenSource = 4
    }
}
using UnityEngine.Bindings;

namespace UnityEditor.Animations
{
    [NativeHeader("Editor/Src/Animation/Transition.h")]
    public struct AnimatorCondition
    {
        public AnimatorConditionMode mode { get; set; }
        public string parameter { get; set; }
        public float threshold { get; set; }
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor.Animations
{
    [NativeHeader("Editor/Src/Animation/Transition.h")]
    [NativeHeader("Modules/Animation/MecanimUtility.h")]
    public class AnimatorTransitionBase : Object
    {
        protected AnimatorTransitionBase();

        public bool solo { get; set; }
        public bool mute { get; set; }
        public bool isExit { get; set; }
        public AnimatorStateMachine destinationStateMachine { get; set; }
        public AnimatorState destinationState { get; set; }
        public AnimatorCondition[] conditions { get; set; }

        public string GetDisplayName(Object source);
        public void AddCondition(AnimatorConditionMode mode, float threshold, string parameter);
        public void RemoveCondition(AnimatorCondition condition);
    }
}
using UnityEngine.Bindings;

namespace UnityEditor.Animations
{
    [NativeHeader("Editor/Src/Animation/Transition.h")]
    [NativeHeader("Editor/Src/Animation/StateMachine.bindings.h")]
    public class AnimatorTransition : AnimatorTransitionBase
    {
        public AnimatorTransition();
    }
}
using UnityEngine.Bindings;

namespace UnityEditor.Animations
{
    [NativeHeader("Editor/Src/Animation/Transition.h")]
    [NativeHeader("Editor/Src/Animation/StateMachine.bindings.h")]
    public class AnimatorStateTransition : AnimatorTransitionBase
    {
        public AnimatorStateTransition();

        public float duration { get; set; }
        public float offset { get; set; }
        public TransitionInterruptionSource interruptionSource { get; set; }
        public bool orderedInterruption { get; set; }
        public float exitTime { get; set; }
        public bool hasExitTime { get; set; }
        public bool hasFixedDuration { get; set; }
        public bool canTransitionToSelf { get; set; }
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngineInternal;

namespace UnityEditor.Animations
{
    [NativeHeader("Editor/Src/Animation/StateMachine.h")]
    [NativeHeader("Editor/Src/Animation/StateMachine.bindings.h")]
    [NativeHeader("Editor/Src/Animation/StateMachineBehaviourScripting.h")]
    public sealed class AnimatorState : UnityEngine.Object
    {
        public AnimatorState();

        public int nameHash { get; }
        public Motion motion { get; set; }
        public float speed { get; set; }
        public float cycleOffset { get; set; }
        public bool mirror { get; set; }
        public bool iKOnFeet { get; set; }
        public bool writeDefaultValues { get; set; }
        public string tag { get; set; }
        public string speedParameter { get; set; }
        public string cycleOffsetParameter { get; set; }
        public string mirrorParameter { get; set; }
        public string timeParameter { get; set; }
        public bool speedParameterActive { get; set; }
        public bool cycleOffsetParameterActive { get; set; }
        public bool mirrorParameterActive { get; set; }
        public bool timeParameterActive { get; set; }
        public AnimatorStateTransition[] transitions { get; set; }
        public StateMachineBehaviour[] behaviours { get; set; }
        [Obsolete("uniqueName does not exist anymore. Consider using .name instead.", True)]
        public string uniqueName { get; }
        [Obsolete("uniqueNameHash does not exist anymore.", True)]
        public int uniqueNameHash { get; }

        [TypeInferenceRule(TypeReferencedByFirstArgument)]
        public StateMachineBehaviour AddStateMachineBehaviour(Type stateMachineBehaviourType);
        public T AddStateMachineBehaviour<T>() where T : StateMachineBehaviour;
        public void AddTransition(AnimatorStateTransition transition);
        public void RemoveTransition(AnimatorStateTransition transition);
        public AnimatorStateTransition AddTransition(AnimatorState destinationState);
        public AnimatorStateTransition AddTransition(AnimatorStateMachine destinationStateMachine);
        public AnimatorStateTransition AddTransition(AnimatorState destinationState, bool defaultExitTime);
        public AnimatorStateTransition AddTransition(AnimatorStateMachine destinationStateMachine, bool defaultExitTime);
        public AnimatorStateTransition AddExitTransition();
        public AnimatorStateTransition AddExitTransition(bool defaultExitTime);
        [Obsolete("GetMotion() is obsolete. Use motion", True)]
        public Motion GetMotion();
    }
}
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.Animations
{
    [NativeHeader("Editor/Src/Animation/StateMachine.h")]
    [NativeHeader("Editor/Src/Animation/StateMachine.bindings.h")]
    [RequiredByNativeCode]
    public struct ChildAnimatorState
    {
        public AnimatorState state { get; set; }
        public Vector3 position { get; set; }
    }
}
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngine.Scripting;

namespace UnityEditor.Animations
{
    [RequiredByNativeCode]
    [NativeHeader("Editor/Src/Animation/StateMachine.bindings.h")]
    [NativeHeader("Editor/Src/Animation/StateMachine.h")]
    public struct ChildAnimatorStateMachine
    {
        public AnimatorStateMachine stateMachine { get; set; }
        public Vector3 position { get; set; }
    }
}
using System;
using UnityEngine;
using UnityEngine.Bindings;
using UnityEngineInternal;

namespace UnityEditor.Animations
{
    [NativeHeader("Editor/Src/Animation/StateMachine.h")]
    [NativeHeader("Editor/Src/Animation/StateMachine.bindings.h")]
    [NativeHeader("Editor/Src/Animation/StateMachineBehaviourScripting.h")]
    public sealed class AnimatorStateMachine : UnityEngine.Object
    {
        public AnimatorStateMachine();

        public ChildAnimatorState[] states { get; set; }
        public ChildAnimatorStateMachine[] stateMachines { get; set; }
        public AnimatorState defaultState { get; set; }
        public Vector3 anyStatePosition { get; set; }
        public Vector3 entryPosition { get; set; }
        public Vector3 exitPosition { get; set; }
        public Vector3 parentStateMachinePosition { get; set; }
        public AnimatorStateTransition[] anyStateTransitions { get; set; }
        public AnimatorTransition[] entryTransitions { get; set; }
        public StateMachineBehaviour[] behaviours { get; set; }

        public AnimatorTransition[] GetStateMachineTransitions(AnimatorStateMachine sourceStateMachine);
        public void SetStateMachineTransitions(AnimatorStateMachine sourceStateMachine, AnimatorTransition[] transitions);
        [TypeInferenceRule(TypeReferencedByFirstArgument)]
        public StateMachineBehaviour AddStateMachineBehaviour(Type stateMachineBehaviourType);
        public T AddStateMachineBehaviour<T>() where T : StateMachineBehaviour;
        public string MakeUniqueStateName(string name);
        public string MakeUniqueStateMachineName(string name);
        public AnimatorState AddState(string name);
        public AnimatorState AddState(string name, Vector3 position);
        public void AddState(AnimatorState state, Vector3 position);
        public void RemoveState(AnimatorState state);
        public AnimatorStateMachine AddStateMachine(string name);
        public AnimatorStateMachine AddStateMachine(string name, Vector3 position);
        public void AddStateMachine(AnimatorStateMachine stateMachine, Vector3 position);
        public void RemoveStateMachine(AnimatorStateMachine stateMachine);
        public AnimatorStateTransition AddAnyStateTransition(AnimatorState destinationState);
        public AnimatorStateTransition AddAnyStateTransition(AnimatorStateMachine destinationStateMachine);
        public bool RemoveAnyStateTransition(AnimatorStateTransition transition);
        public AnimatorTransition AddStateMachineTransition(AnimatorStateMachine sourceStateMachine);
        public AnimatorTransition AddStateMachineTransition(AnimatorStateMachine sourceStateMachine, AnimatorStateMachine destinationStateMachine);
        public AnimatorTransition AddStateMachineTransition(AnimatorStateMachine sourceStateMachine, AnimatorState destinationState);
        public AnimatorTransition AddStateMachineExitTransition(AnimatorStateMachine sourceStateMachine);
        public bool RemoveStateMachineTransition(AnimatorStateMachine sourceStateMachine, AnimatorTransition transition);
        public AnimatorTransition AddEntryTransition(AnimatorState destinationState);
        public AnimatorTransition AddEntryTransition(AnimatorStateMachine destinationStateMachine);
        public bool RemoveEntryTransition(AnimatorTransition transition);
    }
}
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor.Animations
{
    [NativeAsStruct]
    [NativeHeader("Editor/Src/Animation/StateMachineBehaviourContext.h")]
    public class StateMachineBehaviourContext
    {
        [NativeName("m_AnimatorController")]
        public AnimatorController animatorController;
        [NativeName("m_AnimatorObject")]
        public Object animatorObject;
        [NativeName("m_LayerIndex")]
        public int layerIndex;

        public StateMachineBehaviourContext();
    }
}
namespace UnityEditor.Animations
{
    public struct CurveFilterOptions
    {
        public float positionError;
        public float rotationError;
        public float scaleError;
        public float floatError;
        public bool keyframeReduction;
        public bool unrollRotation;
    }
}
using System;
using System.ComponentModel;
using UnityEngine;
using UnityEngine.Bindings;

namespace UnityEditor.Animations
{
    [NativeHeader("Editor/Src/Animation/EditorCurveBinding.bindings.h")]
    [NativeHeader("Editor/Src/Animation/GameObjectRecorder.h")]
    [NativeHeader("Modules/Animation/AnimationClip.h")]
    [NativeType]
    public class GameObjectRecorder : UnityEngine.Object
    {
        public GameObjectRecorder(GameObject root);
        [EditorBrowsable(Never)]
        [Obsolete("The GameObjectRecorder constructor now takes a root GameObject", True)]
        public GameObjectRecorder();

        public GameObject root { get; }
        public float currentTime { get; }
        public bool isRecording { get; }

        public void BindComponentsOfType<T>(GameObject target, bool recursive) where T : UnityEngine.Component;
        public void BindComponentsOfType(GameObject target, Type componentType, bool recursive);
        public void Bind(EditorCurveBinding binding);
        public void BindAll(GameObject target, bool recursive);
        public void BindComponent([NotNull("ArgumentNullException")] UnityEngine.Component component);
        public EditorCurveBinding[] GetBindings();
        public void TakeSnapshot(float dt);
        public void SaveToClip(AnimationClip clip);
        public void SaveToClip(AnimationClip clip, float fps);
        public void SaveToClip(AnimationClip clip, float fps, CurveFilterOptions filterOptions);
        public void ResetRecording();
        [EditorBrowsable(Never)]
        [Obsolete("BindComponent() using a System::Type is obsolete, use BindComponentsOfType() instead (UnityUpgradable) -> BindComponentsOfType(*)", True)]
        public void BindComponent(GameObject target, Type componentType, bool recursive);
        [EditorBrowsable(Never)]
        [Obsolete("\"BindComponent<T>() where T : Component\" is obsolete, use BindComponentsOfType<T>() instead (UnityUpgradable) -> BindComponentsOfType<T>(*)", True)]
        public void BindComponent<T>(GameObject target, bool recursive) where T : UnityEngine.Component;
    }
}
-------- {UnityEditor.GraphViewModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEditor.GraphViewModule.dll)}:  169 --------
using System;

namespace UnityEditor.Experimental.GraphView
{
    [Flags]
    public enum Capabilities
    {
        Selectable = 1,
        Collapsible = 2,
        Resizable = 4,
        Movable = 8,
        Deletable = 16,
        Droppable = 32,
        Ascendable = 64,
        Renamable = 128,
        Copiable = 256,
        Snappable = 512,
        Groupable = 1024,
        Stackable = 2048
    }
}
namespace UnityEditor.Experimental.GraphView
{
    public enum Direction
    {
        Input = 0,
        Output = 1
    }
}
using System;
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public class EdgeControl : VisualElement
    {
        public const float k_MinEdgeWidth = 1.75F;

        public EdgeControl();

        public Orientation inputOrientation { get; set; }
        public Orientation outputOrientation { get; set; }
        [Obsolete("Use inputColor and/or outputColor")]
        public Color edgeColor { get; set; }
        public Color inputColor { get; set; }
        public Color outputColor { get; set; }
        public Color fromCapColor { get; set; }
        public Color toCapColor { get; set; }
        public float capRadius { get; set; }
        public int edgeWidth { get; set; }
        public float interceptWidth { get; set; }
        public Vector2 from { get; set; }
        public Vector2 to { get; set; }
        public Vector2[] controlPoints { get; }
        public bool drawFromCap { get; set; }
        public bool drawToCap { get; set; }

        public override bool ContainsPoint(Vector2 localPoint);
        public override bool Overlaps(Rect rect);
        protected virtual void PointsChanged();
        public virtual void UpdateLayout();
        protected virtual void UpdateRenderPoints();
        protected virtual void ComputeControlPoints();
    }
}
using System;
using System.Collections.Generic;

namespace UnityEditor.Experimental.GraphView
{
    public interface ICollectibleElement
    {
        void CollectElements(HashSet<GraphElement> collectedElementSet, Func<GraphElement, bool> conditionFunc);
    }
}
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public class IconBadge : VisualElement
    {
        public IconBadge();
        public IconBadge(VisualTreeAsset template);

        protected SpriteAlignment alignment { get; set; }
        protected VisualElement target { get; set; }
        public string badgeText { get; set; }
        public string visualStyle { get; set; }
        public int distance { get; set; }

        public static IconBadge CreateError(string message);
        public static IconBadge CreateComment(string message);
        public void AttachTo(VisualElement target, SpriteAlignment align);
        public void Detach();
        protected override void ExecuteDefaultAction(EventBase evt);
    }
}
namespace UnityEditor.Experimental.GraphView
{
    public interface IDroppable
    {
        bool IsDroppable();
    }
}
using System.Collections.Generic;
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public interface IDropTarget
    {
        bool CanAcceptDrop(List<ISelectable> selection);
        bool DragUpdated(DragUpdatedEvent evt, IEnumerable<ISelectable> selection, IDropTarget dropTarget, ISelection dragSource);
        bool DragPerform(DragPerformEvent evt, IEnumerable<ISelectable> selection, IDropTarget dropTarget, ISelection dragSource);
        bool DragEnter(DragEnterEvent evt, IEnumerable<ISelectable> selection, IDropTarget enteredTarget, ISelection dragSource);
        bool DragLeave(DragLeaveEvent evt, IEnumerable<ISelectable> selection, IDropTarget leftTarget, ISelection dragSource);
        bool DragExited();
    }
}
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public interface ISelectable
    {
        bool IsSelectable();
        bool HitTest(Vector2 localPoint);
        bool Overlaps(Rect rectangle);
        void Select(VisualElement selectionContainer, bool additive);
        void Unselect(VisualElement selectionContainer);
        bool IsSelected(VisualElement selectionContainer);
    }
}
using System.Collections.Generic;

namespace UnityEditor.Experimental.GraphView
{
    public interface ISelection
    {
        List<ISelectable> selection { get; }

        void AddToSelection(ISelectable selectable);
        void RemoveFromSelection(ISelectable selectable);
        void ClearSelection();
    }
}
namespace UnityEditor.Experimental.GraphView
{
    public class PortSource<T>
    {
        public PortSource();
    }
}
using System;

namespace UnityEditor.Experimental.GraphView
{
    public class TypeAdapter : Attribute
    {
        public TypeAdapter();
    }
}
using System;
using System.Reflection;

namespace UnityEditor.Experimental.GraphView
{
    public class NodeAdapter
    {
        public NodeAdapter();

        public bool CanAdapt(object a, object b);
        public bool Connect(object a, object b);
        public MethodInfo GetAdapter(object a, object b);
        public MethodInfo GetTypeAdapter(Type from, Type to);
    }
}
namespace UnityEditor.Experimental.GraphView
{
    public enum Orientation
    {
        Horizontal = 0,
        Vertical = 1
    }
}
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public class GridBackground : ImmediateModeElement
    {
        public GridBackground();

        protected override void ImmediateRepaint();
    }
}
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public class Edge : GraphElement
    {
        public Edge();

        public bool isGhostEdge { get; set; }
        public Port output { get; set; }
        public override bool showInMiniMap { get; }
        public Port input { get; set; }
        public EdgeControl edgeControl { get; }
        public Vector2 candidatePosition { get; set; }
        public int edgeWidth { get; }
        public Color selectedColor { get; }
        public Color defaultColor { get; }
        public Color ghostColor { get; }
        protected Vector2[] PointsAndTangents { get; }

        public override bool Overlaps(Rect rectangle);
        public override bool ContainsPoint(Vector2 localPoint);
        public virtual void OnPortChanged(bool isInput);
        public virtual bool UpdateEdgeControl();
        protected virtual void DrawEdge();
        protected override void OnCustomStyleResolved(ICustomStyle styles);
        public override void OnSelected();
        public override void OnUnselected();
        protected virtual EdgeControl CreateEdgeControl();
    }
}
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public abstract class GraphElement : VisualElement, ISelectable
    {
        protected GraphElement();

        public Color elementTypeColor { get; set; }
        public int layer { get; set; }
        public virtual string title { get; set; }
        public virtual bool showInMiniMap { get; set; }
        public Capabilities capabilities { get; set; }
        public bool selected { get; set; }

        public void ResetLayer();
        protected virtual void OnCustomStyleResolved(ICustomStyle style);
        public virtual bool IsSelectable();
        public virtual bool IsMovable();
        public virtual bool IsResizable();
        public virtual bool IsDroppable();
        public virtual bool IsAscendable();
        public virtual bool IsRenamable();
        public virtual bool IsCopiable();
        public virtual bool IsSnappable();
        public virtual bool IsGroupable();
        public virtual bool IsStackable();
        public virtual Vector3 GetGlobalCenter();
        public virtual void UpdatePresenterPosition();
        public virtual Rect GetPosition();
        public virtual void SetPosition(Rect newPos);
        public virtual void OnSelected();
        public virtual void OnUnselected();
        public virtual bool HitTest(Vector2 localPoint);
        public virtual void Select(VisualElement selectionContainer, bool additive);
        public virtual void Unselect(VisualElement selectionContainer);
        public virtual bool IsSelected(VisualElement selectionContainer);
    }
}
namespace UnityEditor.Experimental.GraphView
{
    public static class GraphElementScopeExtensions
    {
        public static Scope GetContainingScope(this GraphElement element);
    }
}
using System;
using System.Collections.Generic;

namespace UnityEditor.Experimental.GraphView
{
    public class Group : Scope, ICollectibleElement
    {
        public Group();

        public override string title { get; set; }

        public override bool AcceptsElement(GraphElement element, ref string reasonWhyNotAccepted);
        protected override void OnElementsAdded(IEnumerable<GraphElement> elements);
        protected override void OnElementsRemoved(IEnumerable<GraphElement> elements);
        public void FocusTitleTextField();
        protected virtual void OnGroupRenamed(string oldName, string newName);
        public void CollectElements(HashSet<GraphElement> collectedElementSet, Func<GraphElement, bool> conditionFunc);
    }
}
namespace UnityEditor.Experimental.GraphView
{
    public interface IResizable
    {
        void OnStartResize();
        void OnResized();
    }
}
using System;
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public class MiniMap : GraphElement
    {
        protected readonly Color m_SelectedChildrenColor;
        public Action<string> zoomFactorTextChanged;

        public MiniMap();

        public float maxHeight { get; set; }
        public float maxWidth { get; set; }
        public bool anchored { get; set; }
        public bool windowed { get; set; }
        public GraphView graphView { get; set; }

        public virtual void BuildContextualMenu(ContextualMenuPopulateEvent evt);
        public void OnResized();
    }
}
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public class Node : GraphElement, ICollectibleElement
    {
        protected readonly VisualElement m_CollapseButton;
        protected readonly VisualElement m_ButtonContainer;

        public Node();
        public Node(string uiFile);

        public VisualElement mainContainer { get; }
        public VisualElement titleContainer { get; }
        public VisualElement inputContainer { get; }
        public VisualElement outputContainer { get; }
        public VisualElement titleButtonContainer { get; }
        public VisualElement topContainer { get; }
        public VisualElement extensionContainer { get; }
        public virtual bool expanded { get; set; }
        public override string title { get; set; }

        public void RefreshExpandedState();
        public override Rect GetPosition();
        public override void SetPosition(Rect newPos);
        protected virtual void OnPortRemoved(Port port);
        public virtual Port InstantiatePort(Orientation orientation, Direction direction, Port.Capacity capacity, Type type);
        public bool RefreshPorts();
        protected virtual void ToggleCollapse();
        protected void UseDefaultStyling();
        public virtual void BuildContextualMenu(ContextualMenuPopulateEvent evt);
        public virtual void CollectElements(HashSet<GraphElement> collectedElementSet, Func<GraphElement, bool> conditionFunc);
    }
}
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public class Pill : VisualElement
    {
        public Pill();
        public Pill(VisualElement left, VisualElement right);

        public bool highlighted { get; set; }
        public string text { get; set; }
        public Texture icon { get; set; }
        public VisualElement left { get; set; }
        public VisualElement right { get; set; }

        public class UxmlFactory : UxmlFactory<Pill, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : VisualElement.UxmlTraits
        {
            public UxmlTraits();

            public override IEnumerable<UxmlChildElementDescription> uxmlChildElementsDescription { get; }

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public class Port : GraphElement
    {
        protected EdgeConnector m_EdgeConnector;
        protected VisualElement m_ConnectorBox;
        protected Label m_ConnectorText;
        protected VisualElement m_ConnectorBoxCap;
        protected GraphView m_GraphView;

        protected Port(Orientation portOrientation, Direction portDirection, Capacity portCapacity, Type type);

        public override bool showInMiniMap { get; }
        public bool allowMultiDrag { get; set; }
        public string portName { get; set; }
        public bool portCapLit { get; set; }
        public Direction direction { get; }
        public Orientation orientation { get; }
        public Capacity capacity { get; }
        public string visualClass { get; set; }
        public Type portType { get; set; }
        public EdgeConnector edgeConnector { get; }
        public object source { get; set; }
        public bool highlight { get; set; }
        public virtual IEnumerable<Edge> connections { get; }
        public virtual bool connected { get; }
        public virtual bool collapsed { get; }
        public Color portColor { get; set; }
        public Color disabledPortColor { get; }
        public Node node { get; }

        public virtual void OnStartEdgeDragging();
        public virtual void OnStopEdgeDragging();
        public Edge ConnectTo(Port other);
        public T ConnectTo<T>(Port other) where T : Edge, new();
        public virtual void Connect(Edge edge);
        public virtual void Disconnect(Edge edge);
        public virtual void DisconnectAll();
        public static Port Create<TEdge>(Orientation orientation, Direction direction, Capacity capacity, Type type) where TEdge : Edge, new();
        public override Vector3 GetGlobalCenter();
        public override bool ContainsPoint(Vector2 localPoint);
        protected override void ExecuteDefaultAction(EventBase evt);
        protected override void OnCustomStyleResolved(ICustomStyle styles);

        public enum Capacity
        {
            Single = 0,
            Multi = 1
        }
    }
}
using System;

namespace UnityEditor.Experimental.GraphView
{
    [Flags]
    public enum ResizerDirection
    {
        Top = 1,
        Bottom = 2,
        Left = 4,
        Right = 8
    }
}
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public class ResizableElement : VisualElement
    {
        public ResizableElement();
        public ResizableElement(string uiFile);

        public class UxmlFactory : UxmlFactory<ResizableElement>
        {
            public UxmlFactory();
        }
    }
}
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public class Scope : GraphElement
    {
        public Scope();

        public bool autoUpdateGeometry { get; set; }
        public VisualElement headerContainer { get; }
        public IEnumerable<GraphElement> containedElements { get; }
        public Rect containedElementsRect { get; }

        public override bool HitTest(Vector2 localPoint);
        public override bool Overlaps(Rect rectangle);
        public bool ContainsElement(GraphElement element);
        public virtual bool AcceptsElement(GraphElement element, ref string reasonWhyNotAccepted);
        public void AddElements(IEnumerable<GraphElement> elements);
        public void AddElement(GraphElement element);
        protected virtual void OnElementsAdded(IEnumerable<GraphElement> elements);
        public void RemoveElementsWithoutNotification(IEnumerable<GraphElement> elements);
        public void RemoveElements(IEnumerable<GraphElement> elements);
        public void RemoveElement(GraphElement element);
        protected virtual void OnElementsRemoved(IEnumerable<GraphElement> elements);
        protected void ScheduleUpdateGeometryFromContent();
        public void UpdateGeometryFromContent();
        public override Rect GetPosition();
        public override void SetPosition(Rect newPos);
        protected virtual void SetScopePositionOnly(Rect newPos);
        public override void UpdatePresenterPosition();
    }
}
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public class StackNode : Node, IDropTarget
    {
        public StackNode();

        public VisualElement headerContainer { get; }
        public override VisualElement contentContainer { get; }
        protected bool dragEntered { get; }
        public Func<GraphElement, VisualElement> dropPreviewTemplate { get; set; }
        protected virtual bool hasMultipleSelectionSupport { get; }

        protected override void ExecuteDefaultAction(EventBase evt);
        protected virtual bool AcceptsElement(GraphElement element, ref int proposedIndex, int maxIndex);
        public void AddElement(GraphElement element);
        public void InsertElement(int index, GraphElement element);
        public void RemoveElement(GraphElement element);
        protected override void OnCustomStyleResolved(ICustomStyle styles);
        protected virtual void OnSeparatorContextualMenuEvent(ContextualMenuPopulateEvent evt, int separatorIndex);
        public virtual int GetInsertionIndex(Vector2 worldPosition);
        public virtual void OnStartDragging(GraphElement ge);
        public override void CollectElements(HashSet<GraphElement> collectedElementSet, Func<GraphElement, bool> conditionFunc);
        public bool CanAcceptDrop(List<ISelectable> selection);
        public virtual bool DragExited();
        public virtual bool DragPerform(DragPerformEvent evt, IEnumerable<ISelectable> selection, IDropTarget dropTarget, ISelection dragSource);
        public virtual bool DragUpdated(DragUpdatedEvent evt, IEnumerable<ISelectable> selection, IDropTarget dropTarget, ISelection dragSource);
        public virtual bool DragEnter(DragEnterEvent evt, IEnumerable<ISelectable> selection, IDropTarget enteredTarget, ISelection dragSource);
        public virtual bool DragLeave(DragLeaveEvent evt, IEnumerable<ISelectable> selection, IDropTarget leftTarget, ISelection dragSource);
    }
}
namespace UnityEditor.Experimental.GraphView
{
    public enum StickyNoteChange
    {
        Title = 0,
        Contents = 1,
        Theme = 2,
        FontSize = 3,
        Position = 4
    }
}
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public class StickyNoteChangeEvent : EventBase<StickyNoteChangeEvent>
    {
        public StickyNoteChangeEvent();

        public StickyNoteChange change { get; protected set; }

        public static StickyNoteChangeEvent GetPooled(StickyNote target, StickyNoteChange change);
    }
}
namespace UnityEditor.Experimental.GraphView
{
    public enum StickyNoteTheme
    {
        Classic = 0,
        Black = 1
    }
}
namespace UnityEditor.Experimental.GraphView
{
    public enum StickyNoteFontSize
    {
        Small = 0,
        Medium = 1,
        Large = 2,
        Huge = 3
    }
}
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public class StickyNote : GraphElement, IResizable
    {
        public static readonly Vector2 defaultSize;

        public StickyNote();
        public StickyNote(Vector2 position);
        public StickyNote(string uiFile, Vector2 position);

        public StickyNoteTheme theme { get; set; }
        public StickyNoteFontSize fontSize { get; set; }
        public string contents { get; set; }
        public override string title { get; set; }

        public void FitText(bool onlyIfSmaller);
        public void BuildContextualMenu(ContextualMenuPopulateEvent evt);
        public override void SetPosition(Rect rect);
        public override Rect GetPosition();
        public override void UpdatePresenterPosition();
        public virtual void OnStartResize();
        public virtual void OnResized();

        public class UxmlFactory : UxmlFactory<StickyNote>
        {
            public UxmlFactory();
        }
    }
}
using UnityEngine;

namespace UnityEditor.Experimental.GraphView
{
    public class TokenNode : Node
    {
        public TokenNode(Port input, Port output);

        public Texture icon { get; set; }
        public Port input { get; }
        public Port output { get; }
        public bool highlighted { get; set; }
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public class Blackboard : GraphElement, ISelection
    {
        public Blackboard(GraphView associatedGraphView = null);

        public GraphView graphView { get; set; }
        public Action<Blackboard> addItemRequested { get; set; }
        public Action<Blackboard, int, VisualElement> moveItemRequested { get; set; }
        public Action<Blackboard, VisualElement, string> editTextRequested { get; set; }
        public List<ISelectable> selection { get; }
        public override string title { get; set; }
        public string subTitle { get; set; }
        public bool windowed { get; set; }
        public override VisualElement contentContainer { get; }
        public bool scrollable { get; set; }

        public virtual void AddToSelection(ISelectable selectable);
        public virtual void RemoveFromSelection(ISelectable selectable);
        public virtual void ClearSelection();
    }
}
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public class BlackboardField : GraphElement
    {
        public BlackboardField();
        public BlackboardField(Texture icon, string text, string typeText);

        public string text { get; set; }
        public string typeText { get; set; }
        public Texture icon { get; set; }
        public bool highlighted { get; set; }
        public Blackboard blackboard { get; }

        protected override void ExecuteDefaultAction(EventBase evt);
        public void OpenTextEditor();
        protected virtual void BuildFieldContextualMenu(ContextualMenuPopulateEvent evt);
    }
}
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public class BlackboardRow : GraphElement
    {
        public BlackboardRow(VisualElement item, VisualElement propertyView);

        public bool expanded { get; set; }
    }
}
using System.Collections.Generic;
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public class BlackboardSection : GraphElement
    {
        public BlackboardSection();

        public CanAcceptDropDelegate canAcceptDrop { get; set; }
        public override VisualElement contentContainer { get; }
        public override string title { get; set; }
        public bool headerVisible { get; set; }

        public bool CanAcceptDrop(List<ISelectable> selection);

        public delegate bool CanAcceptDropDelegate(ISelectable selected);
    }
}
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public class Placemat : GraphElement
    {
        protected GraphView m_GraphView;

        public Placemat();

        public override string title { get; set; }
        public virtual int ZOrder { get; set; }
        public virtual Color Color { get; set; }
        public Vector2 UncollapsedSize { get; }
        public Vector2 CollapsedSize { get; }
        public Rect ExpandedPosition { get; }
        public IEnumerable<GraphElement> CollapsedElements { get; }
        public virtual bool Collapsed { get; set; }

        public override void SetPosition(Rect newPos);
        protected internal void SetCollapsedElements(IEnumerable<GraphElement> collapsedElements);
        protected override void ExecuteDefaultActionAtTarget(EventBase evt);
        protected virtual void BuildContextualMenu(ContextualMenuPopulateEvent evt);
        public void StartEditTitle();
        public static bool ComputeElementBounds(ref Rect pos, List<GraphElement> elements, MinSizePolicy ensureMinSize = EnsureMinSize);

        public enum MinSizePolicy
        {
            EnsureMinSize = 0,
            DoNotEnsureMinSize = 1
        }
    }
}
using System;
using System.Collections.Generic;
using UnityEngine;

namespace UnityEditor.Experimental.GraphView
{
    public class PlacematContainer : GraphView.Layer
    {
        public PlacematContainer(GraphView graphView);

        public IEnumerable<Placemat> Placemats { get; }
        public static int PlacematsLayer { get; }

        public bool GetPortCenterOverride(Port port, out Vector2 overriddenPosition);
        public T CreatePlacemat<T>(Rect placematPosition, int zOrder, string placematTitle) where T : Placemat, new();
        public T CreatePlacemat<T>(Func<T> creator, Rect placematPosition, int zOrder, string placematTitle) where T : Placemat;
        public void RemoveAllPlacemats();
        public int GetTopZOrder();
        protected virtual void UpdateElementsOrder();
        public void HideCollapsedEdges();

        public enum CycleDirection
        {
            Up = 0,
            Down = 1
        }
    }
}
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public class ClickSelector : MouseManipulator
    {
        public ClickSelector();

        protected override void RegisterCallbacksOnTarget();
        protected override void UnregisterCallbacksFromTarget();
        protected void OnMouseDown(MouseDownEvent e);
    }
}
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public class ContentDragger : MouseManipulator
    {
        public ContentDragger();

        public Vector2 panSpeed { get; set; }
        public bool clampToParentEdges { get; set; }

        protected Rect CalculatePosition(float x, float y, float width, float height);
        protected override void RegisterCallbacksOnTarget();
        protected override void UnregisterCallbacksFromTarget();
        protected void OnMouseDown(MouseDownEvent e);
        protected void OnMouseMove(MouseMoveEvent e);
        protected void OnMouseUp(MouseUpEvent e);
    }
}
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public class Dragger : MouseManipulator
    {
        protected bool m_Active;

        public Dragger();

        public Vector2 panSpeed { get; set; }
        public bool clampToParentEdges { get; set; }

        protected Rect CalculatePosition(float x, float y, float width, float height);
        protected override void RegisterCallbacksOnTarget();
        protected override void UnregisterCallbacksFromTarget();
        protected void OnMouseDown(MouseDownEvent e);
        protected void OnMouseMove(MouseMoveEvent e);
        protected void OnMouseUp(MouseUpEvent e);
    }
}
using UnityEngine;

namespace UnityEditor.Experimental.GraphView
{
    public interface IEdgeConnectorListener
    {
        void OnDropOutsidePort(Edge edge, Vector2 position);
        void OnDrop(GraphView graphView, Edge edge);
    }
}
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public abstract class EdgeConnector : MouseManipulator
    {
        protected EdgeConnector();

        public abstract EdgeDragHelper edgeDragHelper { get; }
    }
}
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public class EdgeConnector<TEdge> : EdgeConnector where TEdge : Edge, new()
    {
        public EdgeConnector(IEdgeConnectorListener listener);

        public override EdgeDragHelper edgeDragHelper { get; }

        protected override void RegisterCallbacksOnTarget();
        protected override void UnregisterCallbacksFromTarget();
        protected virtual void OnMouseDown(MouseDownEvent e);
        protected virtual void OnMouseMove(MouseMoveEvent e);
        protected virtual void OnMouseUp(MouseUpEvent e);
    }
}
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public abstract class EdgeDragHelper
    {
        protected EdgeDragHelper();

        public abstract Edge edgeCandidate { get; set; }
        public abstract Port draggedPort { get; set; }

        public abstract bool HandleMouseDown(MouseDownEvent evt);
        public abstract void HandleMouseMove(MouseMoveEvent evt);
        public abstract void HandleMouseUp(MouseUpEvent evt);
        public abstract void Reset(bool didConnect = False);
    }
}
using System.Collections.Generic;
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public class EdgeDragHelper<TEdge> : EdgeDragHelper where TEdge : Edge, new()
    {
        protected List<Port> m_CompatiblePorts;
        protected GraphView m_GraphView;
        protected static NodeAdapter s_nodeAdapter;
        protected readonly IEdgeConnectorListener m_Listener;

        public EdgeDragHelper(IEdgeConnectorListener listener);

        public bool resetPositionOnPan { get; set; }
        public override Edge edgeCandidate { get; set; }
        public override Port draggedPort { get; set; }

        public override void Reset(bool didConnect = False);
        public override bool HandleMouseDown(MouseDownEvent evt);
        public override void HandleMouseMove(MouseMoveEvent evt);
        public override void HandleMouseUp(MouseUpEvent evt);
    }
}
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public class EdgeManipulator : MouseManipulator
    {
        public EdgeManipulator();

        protected override void RegisterCallbacksOnTarget();
        protected override void UnregisterCallbacksFromTarget();
        protected void OnMouseDown(MouseDownEvent evt);
        protected void OnMouseMove(MouseMoveEvent evt);
        protected void OnMouseUp(MouseUpEvent evt);
        protected void OnKeyDown(KeyDownEvent evt);
    }
}
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public class FreehandSelector : MouseManipulator
    {
        public FreehandSelector();

        protected override void RegisterCallbacksOnTarget();
        protected override void UnregisterCallbacksFromTarget();
    }
}
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public class RectangleSelector : MouseManipulator
    {
        public RectangleSelector();

        public Rect ComputeAxisAlignedBound(Rect position, Matrix4x4 transform);
        protected override void RegisterCallbacksOnTarget();
        protected override void UnregisterCallbacksFromTarget();
    }
}
using System;
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public class Resizer : VisualElement
    {
        public Resizer();
        public Resizer(Action onResizedCallback);
        public Resizer(Vector2 minimumSize, Action onResizedCallback = null);

        public MouseButton activateButton { get; set; }
    }
}
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public class SelectionDragger : Dragger
    {
        public SelectionDragger();

        protected override void RegisterCallbacksOnTarget();
        protected override void UnregisterCallbacksFromTarget();
        protected void OnMouseDown(MouseDownEvent e);
        protected void OnMouseMove(MouseMoveEvent e);
        protected void OnMouseUp(MouseUpEvent evt);
    }
}
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public class SelectionDropper : Manipulator
    {
        public SelectionDropper();

        public Vector2 panSpeed { get; set; }
        public MouseButton activateButton { get; set; }
        public bool clampToParentEdges { get; set; }

        protected override void RegisterCallbacksOnTarget();
        protected override void UnregisterCallbacksFromTarget();
        protected void OnMouseDown(MouseDownEvent e);
        protected void OnMouseMove(MouseMoveEvent e);
        protected void OnMouseUp(MouseUpEvent e);
    }
}
namespace UnityEditor.Experimental.GraphView
{
    public enum EventPropagation
    {
        Stop = 0,
        Continue = 1
    }
}
namespace UnityEditor.Experimental.GraphView
{
    public delegate EventPropagation ShortcutDelegate();
}
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public class ShortcutHandler : Manipulator
    {
        public ShortcutHandler(Dictionary<Event, ShortcutDelegate> dictionary);

        protected override void RegisterCallbacksOnTarget();
        protected override void UnregisterCallbacksFromTarget();
    }
}
using System;
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public class ContentZoomer : Manipulator
    {
        public static readonly float DefaultReferenceScale;
        public static readonly float DefaultMinScale;
        public static readonly float DefaultMaxScale;
        public static readonly float DefaultScaleStep;

        public ContentZoomer();

        public float referenceScale { get; set; }
        public float minScale { get; set; }
        public float maxScale { get; set; }
        public float scaleStep { get; set; }
        [Obsolete("ContentZoomer.keepPixelCacheOnZoom is deprecated and has no effect")]
        public bool keepPixelCacheOnZoom { get; set; }

        protected override void RegisterCallbacksOnTarget();
        protected override void UnregisterCallbacksFromTarget();
    }
}
using System;
using UnityEngine;

namespace UnityEditor.Experimental.GraphView
{
    public class SearchTreeEntry : IComparable<SearchTreeEntry>
    {
        public int level;
        public GUIContent content;
        public object userData;

        public SearchTreeEntry(GUIContent content);

        public string name { get; }

        public int CompareTo(SearchTreeEntry o);
    }
}
using UnityEngine;

namespace UnityEditor.Experimental.GraphView
{
    public class SearchTreeGroupEntry : SearchTreeEntry
    {
        public SearchTreeGroupEntry(GUIContent content, int level = 0);
    }
}
using UnityEngine;

namespace UnityEditor.Experimental.GraphView
{
    public struct SearchWindowContext
    {
        public SearchWindowContext(Vector2 screenMousePosition, float requestedWidth = 0, float requestedHeight = 0);

        public Vector2 screenMousePosition { get; }
        public float requestedWidth { get; }
        public float requestedHeight { get; }
    }
}
using System.Collections.Generic;

namespace UnityEditor.Experimental.GraphView
{
    public interface ISearchWindowProvider
    {
        List<SearchTreeEntry> CreateSearchTree(SearchWindowContext context);
        bool OnSelectEntry(SearchTreeEntry SearchTreeEntry, SearchWindowContext context);
    }
}
using UnityEngine;

namespace UnityEditor.Experimental.GraphView
{
    [InitializeOnLoad]
    public class SearchWindow : EditorWindow
    {
        public SearchWindow();

        public static bool Open<T>(SearchWindowContext context, T provider) where T : ScriptableObject, ISearchWindowProvider;
    }
}
using UnityEngine;

namespace UnityEditor.Experimental.GraphView
{
    public class RectUtils
    {
        public RectUtils();

        public static bool IntersectsSegment(Rect rect, Vector2 p1, Vector2 p2);
        public static Rect Encompass(Rect a, Rect b);
        public static Rect Inflate(Rect a, float left, float top, float right, float bottom);
    }
}
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public class Attacher
    {
        public Attacher(VisualElement anchored, VisualElement target, SpriteAlignment alignment);

        public VisualElement target { get; }
        public VisualElement element { get; }
        public SpriteAlignment alignment { get; set; }
        public Vector2 offset { get; set; }
        public float distance { get; set; }

        public void Detach();
        public void Reattach();
    }
}
using System.Collections.Generic;
using UnityEngine;

namespace UnityEditor.Experimental.GraphView
{
    public struct GraphViewChange
    {
        public List<GraphElement> elementsToRemove;
        public List<Edge> edgesToCreate;
        public List<GraphElement> movedElements;
        public Vector2 moveDelta;
    }
}
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public struct NodeCreationContext
    {
        public Vector2 screenMousePosition;
        public VisualElement target;
        public int index;
    }
}
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public abstract class GraphView : VisualElement, ISelection
    {
        public UQueryState<Port> ports;

        protected GraphView();

        public Action<NodeCreationContext> nodeCreationRequest { get; set; }
        public GraphViewChanged graphViewChanged { get; set; }
        public Action<Group, string> groupTitleChanged { get; set; }
        public Action<Group, IEnumerable<GraphElement>> elementsAddedToGroup { get; set; }
        public Action<Group, IEnumerable<GraphElement>> elementsRemovedFromGroup { get; set; }
        public Action<StackNode, int, IEnumerable<GraphElement>> elementsInsertedToStackNode { get; set; }
        public Action<StackNode, IEnumerable<GraphElement>> elementsRemovedFromStackNode { get; set; }
        public ElementResized elementResized { get; set; }
        public ViewTransformChanged viewTransformChanged { get; set; }
        public virtual bool supportsWindowedBlackboard { get; }
        public VisualElement contentViewContainer { get; }
        public VisualElement viewport { get; }
        public ITransform viewTransform { get; }
        public bool isReframable { get; set; }
        public override VisualElement contentContainer { get; }
        public PlacematContainer placematContainer { get; }
        public UQueryState<GraphElement> graphElements { get; }
        public UQueryState<Node> nodes { get; }
        public UQueryState<Edge> edges { get; }
        public float minScale { get; }
        public float maxScale { get; }
        public float scaleStep { get; }
        public float referenceScale { get; }
        public float scale { get; }
        public int zoomerMaxElementCountWithPixelCacheRegen { get; set; }
        public List<ISelectable> selection { get; protected set; }
        protected internal virtual bool canCopySelection { get; }
        protected internal virtual bool canCutSelection { get; }
        protected internal virtual bool canPaste { get; }
        protected internal virtual bool canDuplicateSelection { get; }
        protected internal virtual bool canDeleteSelection { get; }
        public SerializeGraphElementsDelegate serializeGraphElements { get; set; }
        public CanPasteSerializedDataDelegate canPasteSerializedData { get; set; }
        public UnserializeAndPasteDelegate unserializeAndPaste { get; set; }
        public DeleteSelectionDelegate deleteSelection { get; set; }

        public void UpdateViewTransform(Vector3 newPosition, Vector3 newScale);
        public bool GetPortCenterOverride(Port port, out Vector2 overriddenPosition);
        public void AddLayer(int index);
        public GraphElement GetElementByGuid(string guid);
        public Node GetNodeByGuid(string guid);
        public Port GetPortByGuid(string guid);
        public Edge GetEdgeByGuid(string guid);
        public void SetupZoom(float minScaleSetup, float maxScaleSetup);
        public void SetupZoom(float minScaleSetup, float maxScaleSetup, float scaleStepSetup, float referenceScaleSetup);
        protected void ValidateTransform();
        public virtual void AddToSelection(ISelectable selectable);
        public virtual void RemoveFromSelection(ISelectable selectable);
        public virtual void ClearSelection();
        public virtual void BuildContextualMenu(ContextualMenuPopulateEvent evt);
        protected override void ExecuteDefaultActionAtTarget(EventBase evt);
        protected override void ExecuteDefaultAction(EventBase evt);
        public static void CollectElements(IEnumerable<GraphElement> elements, HashSet<GraphElement> collectedElementSet, Func<GraphElement, bool> conditionFunc);
        protected internal virtual void CollectCopyableGraphElements(IEnumerable<GraphElement> elements, HashSet<GraphElement> elementsToCopySet);
        protected internal void CopySelectionCallback();
        protected internal void CutSelectionCallback();
        protected internal void PasteCallback();
        protected internal void DuplicateSelectionCallback();
        protected internal void DeleteSelectionCallback(AskUser askUser);
        protected string SerializeGraphElements(IEnumerable<GraphElement> elements);
        protected bool CanPasteSerializedData(string data);
        protected void UnserializeAndPasteOperation(string operationName, string data);
        protected void DeleteSelectionOperation(string operationName, AskUser askUser);
        public virtual List<Port> GetCompatiblePorts(Port startPort, NodeAdapter nodeAdapter);
        public void AddElement(GraphElement graphElement);
        public void RemoveElement(GraphElement graphElement);
        public virtual EventPropagation DeleteSelection();
        public void DeleteElements(IEnumerable<GraphElement> elementsToRemove);
        public EventPropagation FrameAll();
        public EventPropagation FrameSelection();
        public EventPropagation FrameOrigin();
        public EventPropagation FramePrev();
        public EventPropagation FrameNext();
        public EventPropagation FramePrev(Func<GraphElement, bool> predicate);
        public EventPropagation FrameNext(Func<GraphElement, bool> predicate);
        public virtual Rect CalculateRectToFitAll(VisualElement container);
        public static void CalculateFrameTransform(Rect rectToFit, Rect clientRect, int border, out Vector3 frameTranslation, out Vector3 frameScaling);
        public virtual Blackboard GetBlackboard();
        public virtual void ReleaseBlackboard(Blackboard toRelease);
        protected virtual PlacematContainer CreatePlacematContainer();

        public class Layer : VisualElement
        {
            public Layer();
        }
        public delegate GraphViewChange GraphViewChanged(GraphViewChange graphViewChange);
        public delegate void ElementResized(VisualElement visualElement);
        public delegate void ViewTransformChanged(GraphView graphView);
        public enum FrameType
        {
            All = 0,
            Selection = 1,
            Origin = 2
        }
        public enum AskUser
        {
            AskUser = 0,
            DontAskUser = 1
        }
        public delegate string SerializeGraphElementsDelegate(IEnumerable<GraphElement> elements);
        public delegate bool CanPasteSerializedDataDelegate(string data);
        public delegate void UnserializeAndPasteDelegate(string operationName, string data);
        public delegate void DeleteSelectionDelegate(string operationName, AskUser askUser);
    }
}
namespace UnityEditor.Experimental.GraphView
{
    [EditorWindowTitle(title = "Blackboard")]
    public class GraphViewBlackboardWindow : GraphViewToolWindow
    {
        public GraphViewBlackboardWindow();

        protected override string ToolName { get; }

        protected override void OnGraphViewChanging();
        protected override void OnGraphViewChanged();
        protected override bool IsGraphViewSupported(GraphView gv);
    }
}
using System;
using System.Collections.Generic;

namespace UnityEditor.Experimental.GraphView
{
    public abstract class GraphViewEditorWindow : EditorWindow
    {
        protected GraphViewEditorWindow();

        public virtual IEnumerable<GraphView> graphViews { get; }

        public override IEnumerable<Type> GetExtraPaneTypes();
        public static List<EditorWindow> ShowGraphViewWindowWithTools<T>() where T : GraphViewEditorWindow;
    }
}
namespace UnityEditor.Experimental.GraphView
{
    [EditorWindowTitle(title = "MiniMap")]
    public class GraphViewMinimapWindow : GraphViewToolWindow
    {
        public GraphViewMinimapWindow();

        protected override string ToolName { get; }

        protected override void OnGraphViewChanging();
        protected override void OnGraphViewChanged();
        protected override bool IsGraphViewSupported(GraphView gv);
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.UIElements;

namespace UnityEditor.Experimental.GraphView
{
    public abstract class GraphViewToolWindow : EditorWindow
    {
        protected VisualElement m_ToolbarContainer;
        protected GraphView m_SelectedGraphView;

        protected GraphViewToolWindow();

        protected abstract string ToolName { get; }

        public override IEnumerable<Type> GetExtraPaneTypes();
        public void SelectGraphViewFromWindow(GraphViewEditorWindow window, GraphView graphView, int graphViewIndexInWindow = 0);
        protected void OnEnable();
        protected abstract void OnGraphViewChanging();
        protected abstract void OnGraphViewChanged();
        protected virtual bool IsGraphViewSupported(GraphView gv);
    }
}
-------- {UnityEditor.PackageManagerUIModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEditor.PackageManagerUIModule.dll)}:  320 --------
using UnityEditor;
using UnityEngine;

namespace UnityEditorInternal
{
    [ExcludeFromPreset]
    public sealed class PackageManifestImporter : AssetImporter
    {
        public PackageManifestImporter();
    }
}
using UnityEngine;

namespace UnityEditorInternal
{
    public sealed class PackageManifest : TextAsset
    {
    }
}
using System;
using System.Collections.Generic;

namespace UnityEditor.PackageManager.UI
{
    public struct Sample
    {
        public string displayName { get; }
        public string description { get; }
        public string resolvedPath { get; }
        public string importPath { get; }
        public bool interactiveImport { get; }
        public bool isImported { get; }

        public static IEnumerable<Sample> FindByPackage(string packageName, string packageVersion);
        public bool Import(ImportOptions options = None);

        [Flags]
        public enum ImportOptions
        {
            None = 0,
            OverridePreviousImports = 1,
            HideImportWindow = 2
        }
    }
}
namespace UnityEditor.PackageManager.UI
{
    public static class PackageManagerExtensions
    {
        public static void RegisterExtension(IPackageManagerExtension extension);
    }
}
namespace UnityEditor.PackageManager.UI
{
    public static class Window
    {
        public static void Open(string packageToSelect);
    }
}
using UnityEngine.UIElements;

namespace UnityEditor.PackageManager.UI
{
    public interface IPackageManagerExtension
    {
        VisualElement CreateExtensionUI();
        void OnPackageSelectionChange(PackageInfo packageInfo);
        void OnPackageAddedOrUpdated(PackageInfo packageInfo);
        void OnPackageRemoved(PackageInfo packageInfo);
    }
}
-------- {UnityEditor.SceneTemplateModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEditor.SceneTemplateModule.dll)}:   76 --------
namespace UnityEditor.SceneTemplate
{
    public enum TemplateInstantiationMode
    {
        Clone = 0,
        Reference = 1
    }
}
using UnityEngine;

namespace UnityEditor.SceneTemplate
{
    [ExcludeFromPreset]
    [AssetFileNameExtension("scenetemplate", new[] { })]
    public class SceneTemplateAsset : ScriptableObject
    {
        public SceneAsset templateScene;
        public string templateName;
        public string description;
        public Texture2D preview;
        public DependencyInfo[] dependencies;
        public MonoScript templatePipeline;
        public bool addToDefaults;

        public SceneTemplateAsset();

        public bool isValid { get; }
    }
}
using System.Diagnostics;
using UnityEngine;

namespace UnityEditor.SceneTemplate
{
    [DebuggerDisplay("{dependency} - {instantiationMode}")]
    public sealed class DependencyInfo
    {
        public Object dependency;
        public TemplateInstantiationMode instantiationMode;

        public DependencyInfo();
    }
}
using UnityEngine.SceneManagement;

namespace UnityEditor.SceneTemplate
{
    public interface ISceneTemplatePipeline
    {
        bool IsValidTemplateForInstantiation(SceneTemplateAsset sceneTemplateAsset);
        void BeforeTemplateInstantiation(SceneTemplateAsset sceneTemplateAsset, bool isAdditive, string sceneName);
        void AfterTemplateInstantiation(SceneTemplateAsset sceneTemplateAsset, Scene scene, bool isAdditive, string sceneName);
    }
}
using UnityEngine.SceneManagement;

namespace UnityEditor.SceneTemplate
{
    public class SceneTemplatePipelineAdapter : ISceneTemplatePipeline
    {
        public SceneTemplatePipelineAdapter();

        public virtual bool IsValidTemplateForInstantiation(SceneTemplateAsset sceneTemplateAsset);
        public virtual void BeforeTemplateInstantiation(SceneTemplateAsset sceneTemplateAsset, bool isAdditive, string sceneName);
        public virtual void AfterTemplateInstantiation(SceneTemplateAsset sceneTemplateAsset, Scene scene, bool isAdditive, string sceneName);
    }
}
using UnityEngine.SceneManagement;

namespace UnityEditor.SceneTemplate
{
    public sealed class InstantiationResult
    {
        public Scene scene { get; }
        public SceneAsset sceneAsset { get; }
    }
}
using UnityEngine.SceneManagement;

namespace UnityEditor.SceneTemplate
{
    public static class SceneTemplateService
    {
        public static event NewTemplateInstantiating newSceneTemplateInstantiating;
        public static event NewTemplateInstantiated newSceneTemplateInstantiated;

        public static InstantiationResult Instantiate(SceneTemplateAsset sceneTemplate, bool loadAdditively, string newSceneOutputPath = null);
        public static SceneTemplateAsset CreateSceneTemplate(string sceneTemplatePath);
        public static SceneTemplateAsset CreateTemplateFromScene(SceneAsset sourceSceneAsset, string sceneTemplatePath);

        public delegate void NewTemplateInstantiating(SceneTemplateAsset sceneTemplateAsset, string newSceneOutputPath, bool additiveLoad);
        public delegate void NewTemplateInstantiated(SceneTemplateAsset sceneTemplateAsset, Scene scene, SceneAsset sceneAsset, bool additiveLoad);
    }
}
-------- {UnityEditor.UIElementsModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEditor.UIElementsModule.dll)}:  311 --------
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public abstract class BaseFieldMouseDragger
    {
        protected BaseFieldMouseDragger();

        public void SetDragZone(VisualElement dragElement);
        public abstract void SetDragZone(VisualElement dragElement, Rect hotZone);
    }
}
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class FieldMouseDragger<T> : BaseFieldMouseDragger
    {
        public FieldMouseDragger(IValueField<T> drivenField);

        public bool dragging { get; set; }
        public T startValue { get; set; }

        public sealed override void SetDragZone(VisualElement dragElement, Rect hotZone);
    }
}
using System;

namespace UnityEditor.UIElements
{
    [AttributeUsage(Assembly, AllowMultiple = True)]
    public sealed class UxmlNamespacePrefixAttribute : Attribute
    {
        public UxmlNamespacePrefixAttribute(string ns, string prefix);

        public string ns { get; }
        public string prefix { get; }
    }
}
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public static class BindingExtensions
    {
        public static readonly string prefabOverrideUssClassName;

        public static void Bind(this VisualElement element, SerializedObject obj);
        public static void Unbind(this VisualElement element);
        public static SerializedProperty BindProperty(this IBindable field, SerializedObject obj);
        public static void BindProperty(this IBindable field, SerializedProperty property);
    }
}
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public abstract class BaseCompositeField<TValueType, TField, TFieldValue> : BaseField<TValueType> where TField : TextValueField<TFieldValue>, new()
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;
        public static readonly string spacerUssClassName;
        public static readonly string multilineVariantUssClassName;
        public static readonly string fieldGroupUssClassName;
        public static readonly string fieldUssClassName;
        public static readonly string firstFieldVariantUssClassName;
        public static readonly string twoLinesVariantUssClassName;

        protected BaseCompositeField(string label, int fieldsByLine);

        public override void SetValueWithoutNotify(TValueType newValue);
    }
}
using System.Collections.Generic;
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public abstract class BasePopupField<TValueType, TValueChoice> : BaseField<TValueType>
    {
        public static readonly string ussClassName;
        public static readonly string textUssClassName;
        public static readonly string arrowUssClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;

        protected TextElement textElement { get; }
        public virtual List<TValueChoice> choices { get; set; }
        public string text { get; }

        public override void SetValueWithoutNotify(TValueType newValue);
        protected override void ExecuteDefaultActionAtTarget(EventBase evt);
    }
}
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class BoundsField : BaseField<Bounds>
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;
        public static readonly string centerFieldUssClassName;
        public static readonly string extentsFieldUssClassName;

        public BoundsField();
        public BoundsField(string label);

        public override void SetValueWithoutNotify(Bounds newValue);

        public class UxmlFactory : UxmlFactory<BoundsField, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : BaseField<Bounds>.UxmlTraits
        {
            public UxmlTraits();

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class BoundsIntField : BaseField<BoundsInt>
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;
        public static readonly string positionUssClassName;
        public static readonly string sizeUssClassName;

        public BoundsIntField();
        public BoundsIntField(string label);

        public override void SetValueWithoutNotify(BoundsInt newValue);

        public class UxmlFactory : UxmlFactory<BoundsIntField, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : BaseField<BoundsInt>.UxmlTraits
        {
            public UxmlTraits();

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class ColorField : BaseField<Color>
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;

        public ColorField();
        public ColorField(string label);

        public bool showEyeDropper { get; set; }
        public bool showAlpha { get; set; }
        public bool hdr { get; set; }

        public class UxmlFactory : UxmlFactory<ColorField, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : BaseFieldTraits<Color, UxmlColorAttributeDescription>
        {
            public UxmlTraits();

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class RectField : BaseCompositeField<Rect, FloatField, float>
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;

        public RectField();
        public RectField(string label);

        public class UxmlFactory : UxmlFactory<RectField, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : BaseField<Rect>.UxmlTraits
        {
            public UxmlTraits();

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class RectIntField : BaseCompositeField<RectInt, IntegerField, int>
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;

        public RectIntField();
        public RectIntField(string label);

        public class UxmlFactory : UxmlFactory<RectIntField, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : BaseField<RectInt>.UxmlTraits
        {
            public UxmlTraits();

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class Vector2Field : BaseCompositeField<Vector2, FloatField, float>
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;

        public Vector2Field();
        public Vector2Field(string label);

        public class UxmlFactory : UxmlFactory<Vector2Field, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : BaseField<Vector2>.UxmlTraits
        {
            public UxmlTraits();

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class Vector3Field : BaseCompositeField<Vector3, FloatField, float>
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;

        public Vector3Field();
        public Vector3Field(string label);

        public class UxmlFactory : UxmlFactory<Vector3Field, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : BaseField<Vector3>.UxmlTraits
        {
            public UxmlTraits();

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class Vector4Field : BaseCompositeField<Vector4, FloatField, float>
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;

        public Vector4Field();
        public Vector4Field(string label);

        public class UxmlFactory : UxmlFactory<Vector4Field, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : BaseField<Vector4>.UxmlTraits
        {
            public UxmlTraits();

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class Vector2IntField : BaseCompositeField<Vector2Int, IntegerField, int>
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;

        public Vector2IntField();
        public Vector2IntField(string label);

        public class UxmlFactory : UxmlFactory<Vector2IntField, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : BaseField<Vector2Int>.UxmlTraits
        {
            public UxmlTraits();

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class Vector3IntField : BaseCompositeField<Vector3Int, IntegerField, int>
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;

        public Vector3IntField();
        public Vector3IntField(string label);

        public class UxmlFactory : UxmlFactory<Vector3IntField, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : BaseField<Vector3Int>.UxmlTraits
        {
            public UxmlTraits();

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class CurveField : BaseField<AnimationCurve>
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;
        public static readonly string contentUssClassName;
        public static readonly string borderUssClassName;

        public CurveField();
        public CurveField(string label);

        public Rect ranges { get; set; }
        public RenderMode renderMode { get; set; }
        public override AnimationCurve value { get; set; }

        public override void SetValueWithoutNotify(AnimationCurve newValue);
        protected override void ExecuteDefaultAction(EventBase evt);

        public class UxmlFactory : UxmlFactory<CurveField, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : BaseField<AnimationCurve>.UxmlTraits
        {
            public UxmlTraits();
        }
        public enum RenderMode
        {
            Texture = 0,
            Mesh = 1,
            Default = 0
        }
    }
}
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class DoubleField : TextValueField<double>
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;

        public DoubleField();
        public DoubleField(int maxLength);
        public DoubleField(string label, int maxLength = -1);

        protected override string ValueToString(double v);
        protected override double StringToValue(string str);
        public override void ApplyInputDeviceDelta(Vector3 delta, DeltaSpeed speed, double startValue);

        public class UxmlFactory : UxmlFactory<DoubleField, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : TextValueFieldTraits<double, UxmlDoubleAttributeDescription>
        {
            public UxmlTraits();
        }
    }
}
using System;
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class EnumField : BaseField<Enum>
    {
        public static readonly string ussClassName;
        public static readonly string textUssClassName;
        public static readonly string arrowUssClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;

        public EnumField();
        public EnumField(Enum defaultValue);
        public EnumField(string label, Enum defaultValue = null);

        public string text { get; }

        public void Init(Enum defaultValue);
        public void Init(Enum defaultValue, bool includeObsoleteValues);
        public override void SetValueWithoutNotify(Enum newValue);
        protected override void ExecuteDefaultActionAtTarget(EventBase evt);

        public class UxmlFactory : UxmlFactory<EnumField, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : BaseField<Enum>.UxmlTraits
        {
            public UxmlTraits();

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
using System;
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class EnumFlagsField : BaseMaskField<Enum>
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;

        public EnumFlagsField(Enum defaultValue);
        public EnumFlagsField(Enum defaultValue, bool includeObsoleteValues);
        public EnumFlagsField(string label, Enum defaultValue);
        public EnumFlagsField();
        public EnumFlagsField(string label, Enum defaultValue, bool includeObsoleteValues);
        public EnumFlagsField(string label);

        public void Init(Enum defaultValue, bool includeObsoleteValues = False);

        public class UxmlFactory : UxmlFactory<EnumFlagsField, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : BaseField<Enum>.UxmlTraits
        {
            public UxmlTraits();

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class FloatField : TextValueField<float>
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;

        public FloatField();
        public FloatField(int maxLength);
        public FloatField(string label, int maxLength = -1);

        protected override string ValueToString(float v);
        protected override float StringToValue(string str);
        public override void ApplyInputDeviceDelta(Vector3 delta, DeltaSpeed speed, float startValue);

        public class UxmlFactory : UxmlFactory<FloatField, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : TextValueFieldTraits<float, UxmlFloatAttributeDescription>
        {
            public UxmlTraits();
        }
    }
}
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class GradientField : BaseField<Gradient>
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;
        public static readonly string contentUssClassName;
        public static readonly string borderUssClassName;

        public GradientField();
        public GradientField(string label);

        public override Gradient value { get; set; }
        public ColorSpace colorSpace { get; set; }

        protected override void ExecuteDefaultAction(EventBase evt);
        public override void SetValueWithoutNotify(Gradient newValue);

        public class UxmlFactory : UxmlFactory<GradientField, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : BaseField<Gradient>.UxmlTraits
        {
            public UxmlTraits();
        }
    }
}
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class IntegerField : TextValueField<int>
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;

        public IntegerField();
        public IntegerField(int maxLength);
        public IntegerField(string label, int maxLength = -1);

        protected override string ValueToString(int v);
        protected override int StringToValue(string str);
        public override void ApplyInputDeviceDelta(Vector3 delta, DeltaSpeed speed, int startValue);

        public class UxmlFactory : UxmlFactory<IntegerField, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : TextValueFieldTraits<int, UxmlIntAttributeDescription>
        {
            public UxmlTraits();
        }
    }
}
using System;
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class LayerField : PopupField<int>
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;

        public LayerField(string label);
        public LayerField();
        public LayerField(int defaultValue);
        public LayerField(string label, int defaultValue);

        public override int value { get; set; }
        public override Func<int, string> formatSelectedValueCallback { get; set; }
        public override Func<int, string> formatListItemCallback { get; set; }

        public override void SetValueWithoutNotify(int newValue);

        public class UxmlFactory : UxmlFactory<LayerField, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : BaseField<int>.UxmlTraits
        {
            public UxmlTraits();

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
using System;
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class LayerMaskField : MaskField
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;

        public LayerMaskField(int defaultMask);
        public LayerMaskField(string label, int defaultMask);
        public LayerMaskField();
        public LayerMaskField(string label);

        public override Func<string, string> formatSelectedValueCallback { get; set; }
        public override Func<string, string> formatListItemCallback { get; set; }

        public class UxmlFactory : UxmlFactory<LayerMaskField, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : BaseField<int>.UxmlTraits
        {
            public UxmlTraits();

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class LongField : TextValueField<long>
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;

        public LongField();
        public LongField(int maxLength);
        public LongField(string label, int maxLength = -1);

        protected override string ValueToString(long v);
        protected override long StringToValue(string str);
        public override void ApplyInputDeviceDelta(Vector3 delta, DeltaSpeed speed, long startValue);

        public class UxmlFactory : UxmlFactory<LongField, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : TextValueFieldTraits<long, UxmlLongAttributeDescription>
        {
            public UxmlTraits();
        }
    }
}
using System.Collections.Generic;

namespace UnityEditor.UIElements
{
    public abstract class BaseMaskField<TChoice> : BasePopupField<TChoice, string>
    {
        public override List<string> choices { get; set; }
        public virtual List<int> choicesMasks { get; set; }

        public override void SetValueWithoutNotify(TChoice newValue);
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class MaskField : BaseMaskField<int>
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;

        public MaskField(List<string> choices, int defaultMask, Func<string, string> formatSelectedValueCallback = null, Func<string, string> formatListItemCallback = null);
        public MaskField(string label, List<string> choices, int defaultMask, Func<string, string> formatSelectedValueCallback = null, Func<string, string> formatListItemCallback = null);
        public MaskField();
        public MaskField(string label);

        public virtual Func<string, string> formatSelectedValueCallback { get; set; }
        public virtual Func<string, string> formatListItemCallback { get; set; }

        public class UxmlFactory : UxmlFactory<MaskField, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : BaseField<int>.UxmlTraits
        {
            public UxmlTraits();

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
using System;
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class ObjectField : BaseField<UnityEngine.Object>
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;
        public static readonly string objectUssClassName;
        public static readonly string selectorUssClassName;

        public ObjectField();
        public ObjectField(string label);

        public Type objectType { get; set; }
        public bool allowSceneObjects { get; set; }

        public override void SetValueWithoutNotify(UnityEngine.Object newValue);

        public class UxmlFactory : UxmlFactory<ObjectField, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : BaseField<UnityEngine.Object>.UxmlTraits
        {
            public UxmlTraits();

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
using System;
using System.Collections.Generic;

namespace UnityEditor.UIElements
{
    public class PopupField<T> : BasePopupField<T, T>
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;

        public PopupField();
        public PopupField(string label = null);
        public PopupField(List<T> choices, T defaultValue, Func<T, string> formatSelectedValueCallback = null, Func<T, string> formatListItemCallback = null);
        public PopupField(string label, List<T> choices, T defaultValue, Func<T, string> formatSelectedValueCallback = null, Func<T, string> formatListItemCallback = null);
        public PopupField(List<T> choices, int defaultIndex, Func<T, string> formatSelectedValueCallback = null, Func<T, string> formatListItemCallback = null);
        public PopupField(string label, List<T> choices, int defaultIndex, Func<T, string> formatSelectedValueCallback = null, Func<T, string> formatListItemCallback = null);

        public virtual Func<T, string> formatSelectedValueCallback { get; set; }
        public virtual Func<T, string> formatListItemCallback { get; set; }
        public override T value { get; set; }
        public int index { get; set; }

        public override void SetValueWithoutNotify(T newValue);
    }
}
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class ProgressBar : BindableElement, INotifyValueChanged<float>
    {
        public static readonly string ussClassName;
        public static readonly string containerUssClassName;
        public static readonly string titleUssClassName;
        public static readonly string titleContainerUssClassName;
        public static readonly string progressUssClassName;
        public static readonly string backgroundUssClassName;

        public ProgressBar();

        public string title { get; set; }
        public virtual float value { get; set; }

        public void SetValueWithoutNotify(float newValue);

        public class UxmlFactory : UxmlFactory<ProgressBar, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : BindableElement.UxmlTraits
        {
            public UxmlTraits();

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class PropertyField : VisualElement, IBindable
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;

        public PropertyField();
        public PropertyField(SerializedProperty property);
        public PropertyField(SerializedProperty property, string label);

        public IBinding binding { get; set; }
        public string bindingPath { get; set; }
        public string label { get; set; }

        protected override void ExecuteDefaultActionAtTarget(EventBase evt);
        public void RegisterValueChangeCallback(EventCallback<SerializedPropertyChangeEvent> callback);

        public class UxmlFactory : UxmlFactory<PropertyField, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : VisualElement.UxmlTraits
        {
            public UxmlTraits();

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
using System;
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class TagField : PopupField<string>
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;

        public TagField();
        public TagField(string label, string defaultValue = null);

        public override string value { get; set; }
        public override Func<string, string> formatSelectedValueCallback { get; set; }
        public override Func<string, string> formatListItemCallback { get; set; }

        public override void SetValueWithoutNotify(string newValue);

        public class UxmlFactory : UxmlFactory<TagField, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : BaseField<string>.UxmlTraits
        {
            public UxmlTraits();

            public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
        }
    }
}
namespace UnityEditor.UIElements
{
    public enum DeltaSpeed
    {
        Fast = 0,
        Normal = 1,
        Slow = 2
    }
}
using UnityEngine;

namespace UnityEditor.UIElements
{
    public interface IValueField<T>
    {
        T value { get; set; }

        void ApplyInputDeviceDelta(Vector3 delta, DeltaSpeed speed, T startValue);
        void StartDragging();
        void StopDragging();
    }
}
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public abstract class TextValueField<TValueType> : TextInputBaseField<TValueType>, IValueField<TValueType>
    {
        protected TextValueField(int maxLength, TextValueInput textValueInput);
        protected TextValueField(string label, int maxLength, TextValueInput textValueInput);

        public string formatString { get; set; }
        public override TValueType value { get; set; }

        protected abstract string ValueToString(TValueType value);
        protected abstract TValueType StringToValue(string str);
        public abstract void ApplyInputDeviceDelta(Vector3 delta, DeltaSpeed speed, TValueType startValue);
        public void StartDragging();
        public void StopDragging();
        protected void AddLabelDragger<TDraggerType>();
        public override void SetValueWithoutNotify(TValueType newValue);

        protected abstract class TextValueInput : TextInputBaseField<TValueType>.TextInputBase
        {
            protected TextValueInput();

            protected abstract string allowedCharacters { get; }
            public string formatString { get; set; }

            public abstract void ApplyInputDeviceDelta(Vector3 delta, DeltaSpeed speed, TValueType startValue);
            public void StartDragging();
            public void StopDragging();
            protected abstract string ValueToString(TValueType value);
            protected override TValueType StringToValue(string str);
            protected override void ExecuteDefaultActionAtTarget(EventBase evt);
            protected override void ExecuteDefaultAction(EventBase evt);
        }
    }
}
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class TextValueFieldTraits<TValueType, TValueUxmlAttributeType> : BaseFieldTraits<TValueType, TValueUxmlAttributeType> where TValueUxmlAttributeType : TypedUxmlAttributeDescription<TValueType>, new()
    {
        public TextValueFieldTraits();

        public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc);
    }
}
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class InspectorElement : BindableElement
    {
        public static readonly string ussClassName;
        public static readonly string customInspectorUssClassName;
        public static readonly string iMGUIContainerUssClassName;
        public static readonly string iMGUIInspectorVariantUssClassName;
        public static readonly string uIEInspectorVariantUssClassName;
        public static readonly string noInspectorFoundVariantUssClassName;
        public static readonly string uIECustomVariantUssClassName;
        public static readonly string iMGUICustomVariantUssClassName;
        public static readonly string iMGUIDefaultVariantUssClassName;
        public static readonly string uIEDefaultVariantUssClassName;
        public static readonly string debugVariantUssClassName;
        public static readonly string debugInternalVariantUssClassName;

        public InspectorElement();
        public InspectorElement(Object obj);
        public InspectorElement(SerializedObject obj);
        public InspectorElement(Editor editor);

        protected override void ExecuteDefaultActionAtTarget(EventBase evt);

        public class UxmlFactory : UxmlFactory<InspectorElement, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : BindableElement.UxmlTraits
        {
            public UxmlTraits();
        }
    }
}
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public interface IToolbarMenuElement
    {
        DropdownMenu menu { get; }
    }
}
namespace UnityEditor.UIElements
{
    public static class ToolbarMenuElementExtensions
    {
        public static void ShowMenu(this IToolbarMenuElement tbe);
    }
}
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public abstract class SearchFieldBase<TextInputType, T> : VisualElement, INotifyValueChanged<T> where TextInputType : TextInputBaseField<T>, new()
    {
        public static readonly string ussClassName;
        public static readonly string textUssClassName;
        public static readonly string textInputUssClassName;
        public static readonly string searchButtonUssClassName;
        public static readonly string cancelButtonUssClassName;
        public static readonly string cancelButtonOffVariantUssClassName;
        public static readonly string popupVariantUssClassName;

        protected SearchFieldBase();

        protected TextInputType textInputField { get; }
        protected Button searchButton { get; }
        public T value { get; set; }

        protected abstract void ClearTextField();
        public virtual void SetValueWithoutNotify(T newValue);
        protected abstract bool FieldIsEmpty(T fieldValue);
    }
}
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class Toolbar : VisualElement
    {
        public static readonly string ussClassName;

        public Toolbar();

        public class UxmlFactory : UxmlFactory<Toolbar>
        {
            public UxmlFactory();
        }
    }
}
using System;
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class ToolbarBreadcrumbs : VisualElement
    {
        public static readonly string ussClassName;
        public static readonly string itemClassName;
        public static readonly string firstItemClassName;

        public ToolbarBreadcrumbs();

        public void PushItem(string label, Action clickedEvent = null);
        public void PopItem();

        public class UxmlFactory : UxmlFactory<ToolbarBreadcrumbs>
        {
            public UxmlFactory();
        }
    }
}
using System;
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class ToolbarButton : Button
    {
        public static readonly string ussClassName;

        public ToolbarButton(Action clickEvent);
        public ToolbarButton();

        public class UxmlFactory : UxmlFactory<ToolbarButton, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : Button.UxmlTraits
        {
            public UxmlTraits();
        }
    }
}
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class ToolbarMenu : TextElement, IToolbarMenuElement
    {
        public static readonly string ussClassName;
        public static readonly string popupVariantUssClassName;
        public static readonly string textUssClassName;
        public static readonly string arrowUssClassName;

        public ToolbarMenu();

        public DropdownMenu menu { get; }
        public override string text { get; set; }
        public Variant variant { get; set; }

        public class UxmlFactory : UxmlFactory<ToolbarMenu, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : TextElement.UxmlTraits
        {
            public UxmlTraits();
        }
        public enum Variant
        {
            Default = 0,
            Popup = 1
        }
    }
}
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class ToolbarPopupSearchField : ToolbarSearchField, IToolbarMenuElement
    {
        public ToolbarPopupSearchField();

        public DropdownMenu menu { get; }

        public class UxmlFactory : UxmlFactory<ToolbarPopupSearchField>
        {
            public UxmlFactory();
        }
    }
}
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class ToolbarSearchField : SearchFieldBase<TextField, string>
    {
        public static readonly string textUssClassName;
        public static readonly string searchButtonUssClassName;
        public static readonly string cancelButtonUssClassName;
        public static readonly string cancelButtonOffVariantUssClassName;
        public static readonly string popupVariantUssClassName;
        public static readonly string ussClassName;

        public ToolbarSearchField();

        protected Button searchButton { get; }
        public string value { get; set; }

        public override void SetValueWithoutNotify(string newValue);
        protected override void ClearTextField();
        protected override bool FieldIsEmpty(string fieldValue);

        public class UxmlFactory : UxmlFactory<ToolbarSearchField>
        {
            public UxmlFactory();
        }
    }
}
using System;
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class ToolbarSpacer : VisualElement
    {
        public static readonly string ussClassName;
        [Obsolete("The `fixedSpacerVariantUssClassName` style has been deprecated as is it now the default style.")]
        public static readonly string fixedSpacerVariantUssClassName;
        public static readonly string flexibleSpacerVariantUssClassName;

        public ToolbarSpacer();

        public bool flex { get; set; }

        public class UxmlFactory : UxmlFactory<ToolbarSpacer>
        {
            public UxmlFactory();
        }
    }
}
using UnityEngine.UIElements;

namespace UnityEditor.UIElements
{
    public class ToolbarToggle : Toggle
    {
        public static readonly string ussClassName;

        public ToolbarToggle();

        public class UxmlFactory : UxmlFactory<ToolbarToggle, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : Toggle.UxmlTraits
        {
            public UxmlTraits();
        }
    }
}
-------- {UnityEditor.UIElementsSamplesModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEditor.UIElementsSamplesModule.dll)}:   78 --------
-------- {UnityEditor.UIServiceModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEditor.UIServiceModule.dll)}:   27 --------
-------- {UnityEditor.UnityConnectModule(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEngine\UnityEditor.UnityConnectModule.dll)}:  185 --------
-------- {UnityEditor.Graphs(D:\Programs\2020.3.38f1\Editor\Data\Managed\UnityEditor.Graphs.dll)}:  131 --------
using UnityEngine;

namespace UnityEditor.Graphs
{
    public sealed class Edge
    {
        [SerializeField]
        public Color color;

        public Edge(Slot fromSlot, Slot toSlot);

        public Slot fromSlot { get; set; }
        public Slot toSlot { get; set; }
        public string fromSlotName { get; set; }
        public string toSlotName { get; set; }

        public override string ToString();
    }
}
using System.Collections.Generic;
using System.Reflection;
using UnityEngine;

namespace UnityEditor.Graphs
{
    [DefaultMember("Item")]
    public class Graph : ScriptableObject
    {
        [SerializeField]
        public List<Node> nodes;
        [SerializeField]
        public List<Edge> edges;

        public Graph();

        public Node this[string name] { get; }
        protected bool isAwake { get; }

        public virtual bool CanConnect(Slot fromSlot, Slot toSlot);
        public virtual bool Connected(Slot fromSlot, Slot toSlot);
        public virtual Edge Connect(Slot fromSlot, Slot toSlot);
        public virtual void RemoveEdge(Edge e);
        public virtual void AddNode(Node node);
        public virtual void AddNodes(params Node[] nodes);
        public virtual void Clear(bool destroyNodes = False);
        public virtual void RemoveNodes(List<Node> nodesToRemove, bool destroyNodes = False);
        public virtual void RemoveNode(Node node, bool destroyNode = False);
        public virtual void DestroyNode(Node node);
        public Node GetNodeByName(string name);
        public virtual void OnEnable();
        public void WakeUp();
        public virtual void WakeUp(bool force);
        public void WakeUpEdges(bool clearSlotEdges);
        public void RevalidateInputDataEdges(Slot s);
        public void RevalidateOutputDataEdges(Slot s);
        protected virtual void WakeUpNodes();
        public override string ToString();
        public static Graph FlattenedCopy(Graph source);
        public void RedirectSlotEdges(Node node, string oldSlotName, string newSlotName);
        public virtual void Dirty();
        public void RemoveInvalidEdgesForSlot(Slot slot);
    }
}
using System;
using System.Collections.Generic;

namespace UnityEditor.Graphs
{
    public class GroupNode : Node
    {
        public GroupNode();

        public Graph subGraph { get; }

        public override void NodeUI(GraphGUI host);
        public void AddChildNode(Node node);
        public void DestroyChildNode(Node node);
        public static GroupNode FromNodes(string name, List<Node> nodes, Type graphType);
        public void UnGroup();
        public override string ToString();
    }
}
using System;
using System.Collections.Generic;
using System.Reflection;
using UnityEngine;

namespace UnityEditor.Graphs
{
    [DefaultMember("Item")]
    public class Node : ScriptableObject
    {
        [SerializeField]
        protected List<Slot> m_Slots;
        [SerializeField]
        protected string m_GenericTypeString;
        [SerializeField]
        public Styles.Color color;
        [SerializeField]
        public string style;
        [SerializeField]
        public Rect position;

        public Node();

        public Slot this[string name] { get; }
        public Slot this[int index] { get; }
        public bool nodeIsInvalid { get; }
        public string nodeInvalidError { get; set; }
        public Graph graph { get; set; }
        public Type genericType { get; set; }
        public bool isGeneric { get; }
        public bool isDragging { get; }
        public virtual string title { get; set; }
        public bool hasTitle { get; }
        public virtual string windowTitle { get; }
        public List<Slot> slots { get; }
        public IEnumerable<Slot> inputSlots { get; }
        public IEnumerable<Slot> outputSlots { get; }
        public IEnumerable<Slot> inputDataSlots { get; }
        public IEnumerable<Slot> outputDataSlots { get; }
        public IEnumerable<Slot> inputFlowSlots { get; }
        public IEnumerable<Slot> outputFlowSlots { get; }
        public List<Property> properties { get; }
        public IEnumerable<Property> settingProperties { get; }
        public IEnumerable<Edge> outputEdges { get; }
        public IEnumerable<Edge> inputEdges { get; }
        public IEnumerable<Edge> outputFlowEdges { get; }
        public IEnumerable<Edge> inputFlowEdges { get; }
        public IEnumerable<Edge> outputDataEdges { get; }
        public IEnumerable<Edge> inputDataEdges { get; }

        public static T Instance<T>() where T : Node, new();
        public static Node Instance();
        public Slot AddInputSlot(string name);
        public Slot AddInputSlot(string name, Type type);
        public Slot AddOutputSlot(string name);
        public Slot AddOutputSlot(string name, Type type);
        public void AddSlot(Slot s);
        public virtual void AddSlot(Slot s, int index);
        public virtual void RemoveSlot(Slot s);
        public virtual void ChangeSlotType(Slot s, Type toType);
        public virtual void RenameProperty(string oldName, string newName, Type newType);
        public virtual void SetGenericPropertyArgumentType(Type type);
        public virtual void ResetGenericPropertyArgumentType();
        public virtual void InputEdgeChanged(Edge e);
        public virtual void AddedToGraph();
        public virtual void RemovingFromGraph();
        public override string ToString();
        public virtual void NodeUI(GraphGUI host);
        public Property ConstructAndAddProperty(Type type, string name);
        public Property ConstructAndAddProperty(string serializedTypeString, string name);
        public Property AddOrModifyProperty(Type dataType, string name);
        public Property AddOrModifyPropertyForSlot(Slot s);
        public void AddProperty(Property p);
        public string GetSettingPropertyTitle(Property property);
        public void RemoveProperty(string name);
        public void RemoveProperty(Property p);
        public void SetPropertyValueOrCreateAndAddProperty(string name, Type type, object value);
        public void SetPropertyValue(string name, object value);
        public object GetPropertyValue(string name);
        public object GetSlotValue(string slotName);
        public object TryGetSlotPropertyValue(Slot slot);
        public Property GetProperty(string name);
        public Property TryGetProperty(string name);
        public Property GetOrCreateAndAddProperty(Type type, string name);
        public virtual void Dirty();
        public virtual void BeginDrag();
        public virtual void OnDrag();
        public virtual void EndDrag();
    }
}
using System;
using System.CodeDom;

namespace UnityEditor.Graphs
{
    public class Property
    {
        public Property();
        public Property(string typeString, string name);
        public Property(Type type, string name);

        public Type type { get; set; }
        public string typeString { get; }
        public bool isGeneric { get; }
        public bool hasValue { get; }
        public bool hasDefaultValue { get; }
        public string name { get; set; }
        public bool isIList { get; }
        public bool isSceneReferenceType { get; }
        public int elementCount { get; }
        public Type elementType { get; }
        public string stringValue { get; }
        public CodeExpression codeExpression { get; }
        public object value { get; set; }

        public static bool IsSceneReferenceType(Type t);
        public void SetGenericArgumentType(Type type);
        public void ResetGenericArgumentType();
        public static bool ValidPropertyType(Type type);
        public static object ConvertFromString(Type toType, string str);
        public void ChangeDataType(Type newDataType);
        public static object ConvertActualValueIfPossible(object value, Type toType);
        public static bool ConvertableUnityObjects(Type t1, Type t2);
    }
}
using System;

namespace UnityEditor.Graphs
{
    public class SerializedType
    {
        public SerializedType();

        public static Type GenericType(Type t);
        public static bool IsListType(Type t);
        public static string GetFullName(Type t);
        public static string ToString(Type t);
        public static Type FromString(string serializedTypeString);
        public static bool IsGeneric(string serializedTypeString);
        public static bool IsBaseTypeGeneric(string serializedTypeString);
        public static string SetGenericArgumentType(string serializedTypeString, Type type);
        public static string ResetGenericArgumentType(string serializedTypeString);
        public static bool CanAssignFromGenericType(string serializedTypeString, Type t);
    }
}
namespace UnityEditor.Graphs
{
    public enum SlotType
    {
        InputSlot = 0,
        OutputSlot = 1
    }
}
using System;
using System.Collections.Generic;

namespace UnityEditor.Graphs
{
    public class Slot
    {
        public SlotType type;
        public List<Edge> edges;

        public Slot();
        public Slot(SlotType type);
        public Slot(SlotType type, string name);
        public Slot(SlotType type, string name, Type dataType);
        public Slot(SlotType type, string name, string title);
        public Slot(SlotType type, string name, string title, Type dataType);

        public string name { get; set; }
        public string title { get; set; }
        public Node node { get; set; }
        public Type dataType { get; set; }
        public string dataTypeString { get; }
        public bool isFlowSlot { get; }
        public bool isDataSlot { get; }
        public bool isInputDataSlot { get; }
        public bool isOutputDataSlot { get; }
        public bool isInputSlot { get; }
        public bool isOutputSlot { get; }
        public bool isGeneric { get; }
        public bool isTarget { get; }

        public void SetGenericArgumentType(Type type);
        public void ResetGenericArgumentType();
        public void RemoveEdge(Edge e);
        public void AddEdge(Edge e);
        public Property GetProperty();
        public override string ToString();
    }
}
namespace UnityEditor.Graphs
{
    public class SpecialNames
    {
        public const string kTargetSlotName = "$Target";
        public const string kFunctionOutSlotName = "$FnOut";
        public const string kVarInSlotName = "$VarIn";
        public const string kVarOutSlotName = "$VarOut";
        public const string kFunctionInSlotName = "$FnIn";

        public SpecialNames();
    }
}
namespace UnityEditor.Graphs
{
    public enum DummyCachedNullType
    {
        Nothing = 0
    }
}
namespace UnityEditor.Graphs
{
    public enum DummyNullType
    {
        Nothing = 0
    }
}
using System;
using System.ComponentModel;

namespace UnityEditor.Graphs
{
    public class GraphsTypeConverter : TypeConverter
    {
        public GraphsTypeConverter();

        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    }
}
using System;
using System.ComponentModel;
using System.Globalization;

namespace UnityEditor.Graphs
{
    public class GenericFloatVarsTypeConverter : GraphsTypeConverter
    {
        public GenericFloatVarsTypeConverter(Type type, params string[] varNames);

        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
        public override bool IsValid(ITypeDescriptorContext context, object value);
    }
}
using System;
using System.ComponentModel;
using System.Globalization;

namespace UnityEditor.Graphs
{
    public class EnumTypeConverter : GraphsTypeConverter
    {
        public EnumTypeConverter(Type type);

        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
        public override bool IsValid(ITypeDescriptorContext context, object value);
    }
}
using System;
using System.ComponentModel;
using System.Globalization;

namespace UnityEditor.Graphs
{
    public class AnimationCurveTypeConverter : GraphsTypeConverter
    {
        public AnimationCurveTypeConverter(Type type);

        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
        public override bool IsValid(ITypeDescriptorContext context, object value);
    }
}
namespace UnityEditor.Graphs
{
    public sealed class Explore
    {
        public static event SearchHandler OnDiscoverNode;
        public static event SearchHandler OnDiscoverEdge;

        public static void Traverse(Node v, SearchDirection direction);

        public struct SearchEvent
        {
            public Node node;
            public Edge edge;

            public SearchEvent(Node n, Edge e);
        }
        public delegate void SearchHandler(SearchEvent e);
        public enum SearchDirection
        {
            Forward = 0,
            Backward = 1
        }
    }
}
using System.Collections.Generic;

namespace UnityEditor.Graphs
{
    public sealed class TopologicalSort
    {
        public static List<Node> SortedNodes { get; }
        public static IEnumerable<Node> deadNodes { get; }

        public static void Sort(Graph g);
    }
}
using System.Collections.Generic;
using UnityEngine;

namespace UnityEditor.Graphs
{
    public class EdgeGUI : IEdgeGUI
    {
        public EdgeStyle edgeStyle;
        public static readonly Color kFunctionEdgeColor;
        public static readonly Color kObjectTypeEdgeColor;
        public static readonly Color kSimpleTypeEdgeColor;

        public EdgeGUI();

        public List<int> edgeSelection { get; set; }
        public GraphGUI host { get; set; }

        public void DoEdges();
        public void DoDraggedEdge();
        public void BeginSlotDragging(Slot slot, bool allowStartDrag, bool allowEndDrag);
        public void SlotDragging(Slot slot, bool allowEndDrag, bool allowMultiple);
        public void EndSlotDragging(Slot slot, bool allowMultiple);
        public void EndDragging();
        public Edge FindClosestEdge();

        public enum EdgeStyle
        {
            Angular = 0,
            Curvy = 1
        }
    }
}
using System.Collections.Generic;
using UnityEngine;

namespace UnityEditor.Graphs
{
    public abstract class GraphGUI : ScriptableObject
    {
        [SerializeField]
        protected Vector2 m_ScrollPosition;
        protected bool m_CenterGraph;
        protected bool m_CenterGraphOnPosition;
        protected Vector2 m_CenterGraphPosition;
        public Rect m_GraphClientArea;
        protected Vector2? m_contextMenuMouseDownPosition;
        [SerializeField]
        protected Graph m_Graph;
        protected EditorWindow m_Host;
        protected IEdgeGUI m_EdgeGUI;
        protected const float kGraphPaddingMultiplier = 0.6F;
        public DrawSelectionRectCallback drawSelectionRectCallback;
        protected List<NodeTool> m_Tools;
        public List<Node> selection;
        protected const float kNodeGridSize = 10;

        protected GraphGUI();

        public Vector2 scrollPosition { get; }
        public float zoomLevel { get; }
        public Graph graph { get; set; }
        public virtual IEdgeGUI edgeGUI { get; }

        protected virtual Vector2 GetCenterPosition();
        public virtual void OnGraphGUI();
        public void BeginGraphGUI(EditorWindow host, Rect position);
        public void EndGraphGUI();
        protected virtual void OnScroll();
        protected void ShowContextMenu();
        protected Graph CopyNodesPasteboardData(out int[] ids);
        protected virtual void CopyNodesToPasteboard();
        protected virtual void PasteNodesPasteboardData(Graph dummyGraph);
        protected virtual void PasteNodesFromPasteboard();
        protected static void OffsetPastedNodePositions(IEnumerable<Node> nodes, Vector2? pastePosition);
        protected virtual void DuplicateNodesThroughPasteboard();
        protected void HandleMenuEvents();
        public void ZoomToGraph(Graph g);
        public virtual void NodeGUI(Node n);
        protected void DragNodes();
        protected static Rect SnapPositionToGrid(Rect position);
        protected static float CeilValueToGrid(float value);
        protected void SelectNode(Node node);
        protected virtual void UpdateUnitySelection();
        protected void DragSelection();
        public void LayoutSlot(Slot s, string title, bool allowStartDrag, bool allowEndDrag, bool allowMultiple, GUIStyle style);
        public void Slot(Rect position, string title, Slot s, bool allowStartDrag, bool allowEndDrag, bool allowMultiple, GUIStyle style);
        public virtual void OnNodeLibraryGUI(EditorWindow host, Rect position);
        public void BeginToolbarGUI(Rect position);
        public void EndToolbarGUI();
        public virtual void OnToolbarGUI();
        protected virtual void AddNode(Node node);
        public virtual void AddTools();
        public virtual void OnEnable();
        public void CenterGraph();
        public void CenterGraph(Vector2 center);
        public virtual void ClearSelection();
        public virtual void SyncGraphToUnitySelection(bool force = False);
        public virtual void DoBackgroundClickAction();

        public class NodeTool
        {
            public string category;
            public GUIContent content;
            public bool visible;
            public CreateNodeFuncDelegate createNodeFunc;

            public NodeTool(string category, string title, CreateNodeFuncDelegate createNodeFunc);

            public delegate Node CreateNodeFuncDelegate();
        }
        public delegate void DrawSelectionRectCallback(Rect selectionRect);
    }
}
using System.Collections.Generic;

namespace UnityEditor.Graphs
{
    public interface IEdgeGUI
    {
        GraphGUI host { get; set; }
        List<int> edgeSelection { get; set; }

        void DoEdges();
        void DoDraggedEdge();
        void BeginSlotDragging(Slot slot, bool allowStartDrag, bool allowEndDrag);
        void SlotDragging(Slot slot, bool allowEndDrag, bool allowMultiple);
        void EndSlotDragging(Slot slot, bool allowMultiple);
        void EndDragging();
        Edge FindClosestEdge();
    }
}
using UnityEngine;

namespace UnityEditor.Graphs
{
    public class Styles
    {
        public static GUIStyle graphBackground;
        public static GUIContent connectionTexture;
        public static GUIContent selectedConnectionTexture;
        public static GUIStyle varPinIn;
        public static GUIStyle varPinOut;
        public static GUIStyle varPinTooltip;
        public static GUIStyle targetPinIn;
        public static GUIStyle triggerPinIn;
        public static GUIStyle triggerPinOut;
        public static GUIStyle selectionRect;
        public static GUIStyle nodeGroupButton;
        public static GUIStyle nodeTitlebar;
        public static GUIStyle nodeAddButton;

        public Styles();

        public static GUIStyle GetNodeStyle(string styleName, Color color, bool on);

        public enum Color
        {
            Grey = 0,
            Gray = 0,
            Blue = 1,
            Aqua = 2,
            Green = 3,
            Yellow = 4,
            Orange = 5,
            Red = 6
        }
    }
}
using System;

namespace UnityEditor.Graphs
{
    public class TypeSelector
    {
        public Type selectedType;
        public TypeKind selectedTypeKind;

        public TypeSelector();
        public TypeSelector(string[] types);
        public TypeSelector(bool onlyComponents);

        public bool DoGUI();
        public bool DoTypeKindGUI();
        public static Type GetFinalType(TypeKind typeKind, Type baseType);
        public static Type GetBaseType(TypeKind typeKind, Type finalType);
        public static TypeKind GetTypeKind(Type dataType);
        public static string DotNetTypeNiceName(Type t);

        public enum TypeKind
        {
            Simple = 0,
            List = 1,
            Array = 2
        }
    }
}
using System.Collections.Generic;
using UnityEditor.Animations;
using UnityEngine;

namespace UnityEditor.Graphs.AnimationBlendTree
{
    public class Node : UnityEditor.Graphs.Node
    {
        public List<Node> children;
        public Motion motion;
        public float weight;

        public Node();

        public bool controllerDirty { get; }
        public BlendTree blendTree { get; }
        public Animator animator { get; }
        public Node parent { get; set; }
        public int childIndex { get; }
        public bool isLeaf { get; }
        public Color weightColor { get; }
        public Color weightEdgeColor { get; }

        public void CreateParameters();
        protected virtual void ControllerDirty();
        public void UpdateAnimator();
    }
}
-------- {UnityEditor.WindowsStandalone.Extensions(D:\Programs\2020.3.38f1\Editor\Data\PlaybackEngines\WindowsStandaloneSupport\UnityEditor.WindowsStandalone.Extensions.dll)}:   13 --------
using UnityEditorInternal;

namespace UnityEditor.WindowsStandalone
{
    public class WindowsStandaloneIL2CppNativeCodeBuilder : Il2CppNativeCodeBuilder
    {
        public WindowsStandaloneIL2CppNativeCodeBuilder(BuildTarget target, string baselibLibraryDirectory);

        public override string CompilerPlatform { get; }
        public override string CompilerArchitecture { get; }
        public override string CacheDirectory { get; }
    }
}
namespace UnityEditor.WindowsStandalone
{
    public static class UserBuildSettings
    {
        public static bool copyPDBFiles { get; set; }
        public static bool createSolution { get; set; }
    }
}
-------- {Unity.2D.Tilemap.Extras(D:\Documents\GitHub\Rogue-like-game-i-guess\The game is liar\Library\ScriptAssemblies\Unity.2D.Tilemap.Extras.dll)}:   40 --------
using UnityEngine;

[ExecuteInEditMode]
public class TintTextureGenerator : MonoBehaviour
{
    public int k_TintMapSize;

    public TintTextureGenerator();

    public void Start();
    public void Refresh(Grid grid);
    public void Refresh(Grid grid, Vector3Int position);
    public Color GetColor(Grid grid, Vector3Int position);
    public void SetColor(Grid grid, Vector3Int position, Color color);
}
using System;

namespace UnityEngine
{
    public class HexagonalRuleTile<T> : HexagonalRuleTile
    {
        public HexagonalRuleTile();

        public sealed override Type m_NeighborType { get; }
    }
}
namespace UnityEngine
{
    [HelpURL("https://docs.unity3d.com/Packages/com.unity.2d.tilemap.extras@latest/index.html?subfolder=/manual/RuleTile.html")]
    [CreateAssetMenu(fileName = "New Hexagonal Rule Tile", menuName = "2D/Tiles/Hexagonal Rule Tile", order = 83)]
    public class HexagonalRuleTile : RuleTile
    {
        [RuleTile.DontOverride]
        public bool m_FlatTop;

        public HexagonalRuleTile();

        public override int m_RotationAngle { get; }

        public static Vector3 TilemapPositionToWorldPosition(Vector3Int tilemapPosition);
        public static Vector3Int WorldPositionToTilemapPosition(Vector3 worldPosition);
        public override Vector3Int GetOffsetPosition(Vector3Int position, Vector3Int offset);
        public override Vector3Int GetOffsetPositionReverse(Vector3Int position, Vector3Int offset);
        public override Vector3Int GetRotatedPosition(Vector3Int position, int rotation);
        public override Vector3Int GetMirroredPosition(Vector3Int position, bool mirrorX, bool mirrorY);
    }
}
using System;

namespace UnityEngine
{
    public class IsometricRuleTile<T> : IsometricRuleTile
    {
        public IsometricRuleTile();

        public sealed override Type m_NeighborType { get; }
    }
}
namespace UnityEngine
{
    [HelpURL("https://docs.unity3d.com/Packages/com.unity.2d.tilemap.extras@latest/index.html?subfolder=/manual/RuleTile.html")]
    [CreateAssetMenu(fileName = "New Isometric Rule Tile", menuName = "2D/Tiles/Isometric Rule Tile", order = 83)]
    public class IsometricRuleTile : RuleTile
    {
        public IsometricRuleTile();
    }
}
using System;

namespace UnityEngine
{
    public class RuleTile<T> : RuleTile
    {
        public RuleTile();

        public sealed override Type m_NeighborType { get; }
    }
}
using System;
using System.Collections.Generic;
using System.Reflection;
using UnityEngine.Tilemaps;

namespace UnityEngine
{
    [HelpURL("https://docs.unity3d.com/Packages/com.unity.2d.tilemap.extras@latest/index.html?subfolder=/manual/RuleTile.html")]
    [CreateAssetMenu(fileName = "New Rule Tile", menuName = "2D/Tiles/Rule Tile", order = 83)]
    public class RuleTile : TileBase
    {
        public Sprite m_DefaultSprite;
        public GameObject m_DefaultGameObject;
        public Tile.ColliderType m_DefaultColliderType;
        [HideInInspector]
        public List<TilingRule> m_TilingRules;

        public RuleTile();

        public virtual Type m_NeighborType { get; }
        public virtual int m_RotationAngle { get; }
        public int m_RotationCount { get; }
        public HashSet<Vector3Int> neighborPositions { get; }

        public void UpdateNeighborPositions();
        public override bool StartUp(Vector3Int position, ITilemap tilemap, GameObject instantiatedGameObject);
        public override void GetTileData(Vector3Int position, ITilemap tilemap, ref TileData tileData);
        public static float GetPerlinValue(Vector3Int position, float scale, float offset);
        public override bool GetTileAnimationData(Vector3Int position, ITilemap tilemap, ref TileAnimationData tileAnimationData);
        public override void RefreshTile(Vector3Int position, ITilemap tilemap);
        public virtual bool RuleMatches(TilingRule rule, Vector3Int position, ITilemap tilemap, ref Matrix4x4 transform);
        public virtual Matrix4x4 ApplyRandomTransform(TilingRuleOutput.Transform type, Matrix4x4 original, float perlinScale, Vector3Int position);
        public FieldInfo[] GetCustomFields(bool isOverrideInstance);
        public virtual bool RuleMatch(int neighbor, TileBase other);
        public bool RuleMatches(TilingRule rule, Vector3Int position, ITilemap tilemap, int angle);
        public bool RuleMatches(TilingRule rule, Vector3Int position, ITilemap tilemap, bool mirrorX, bool mirrorY);
        public virtual Vector3Int GetRotatedPosition(Vector3Int position, int rotation);
        public virtual Vector3Int GetMirroredPosition(Vector3Int position, bool mirrorX, bool mirrorY);
        public virtual Vector3Int GetOffsetPosition(Vector3Int position, Vector3Int offset);
        public virtual Vector3Int GetOffsetPositionReverse(Vector3Int position, Vector3Int offset);

        public class TilingRuleOutput
        {
            public int m_Id;
            public Sprite[] m_Sprites;
            public GameObject m_GameObject;
            public float m_AnimationSpeed;
            public float m_PerlinScale;
            public OutputSprite m_Output;
            public Tile.ColliderType m_ColliderType;
            public Transform m_RandomTransform;

            public TilingRuleOutput();

            public class Neighbor
            {
                public const int This = 1;
                public const int NotThis = 2;

                public Neighbor();
            }
            public enum Transform
            {
                Fixed = 0,
                Rotated = 1,
                MirrorX = 2,
                MirrorY = 3,
                MirrorXY = 4
            }
            public enum OutputSprite
            {
                Single = 0,
                Random = 1,
                Animation = 2
            }
        }
        public class TilingRule : TilingRuleOutput
        {
            public List<int> m_Neighbors;
            public List<Vector3Int> m_NeighborPositions;
            public TilingRuleOutput.Transform m_RuleTransform;

            public TilingRule();

            public Dictionary<Vector3Int, int> GetNeighbors();
            public void ApplyNeighbors(Dictionary<Vector3Int, int> dict);
            public BoundsInt GetBounds();
        }
        public class DontOverride : Attribute
        {
            public DontOverride();
        }
    }
}
namespace UnityEngine.Tilemaps
{
    [HelpURL("https://docs.unity3d.com/Packages/com.unity.2d.tilemap.extras@latest/index.html?subfolder=/manual/GridInformation.html")]
    [AddComponentMenu("Tilemap/Grid Information")]
    public class GridInformation : MonoBehaviour, ISerializationCallbackReceiver
    {
        public GridInformation();

        public bool SetPositionProperty<T>(Vector3Int position, string name, T positionProperty);
        public bool SetPositionProperty(Vector3Int position, string name, int positionProperty);
        public bool SetPositionProperty(Vector3Int position, string name, string positionProperty);
        public bool SetPositionProperty(Vector3Int position, string name, float positionProperty);
        public bool SetPositionProperty(Vector3Int position, string name, double positionProperty);
        public bool SetPositionProperty(Vector3Int position, string name, Object positionProperty);
        public bool SetPositionProperty(Vector3Int position, string name, Color positionProperty);
        public T GetPositionProperty<T>(Vector3Int position, string name, T defaultValue) where T : Object;
        public int GetPositionProperty(Vector3Int position, string name, int defaultValue);
        public string GetPositionProperty(Vector3Int position, string name, string defaultValue);
        public float GetPositionProperty(Vector3Int position, string name, float defaultValue);
        public double GetPositionProperty(Vector3Int position, string name, double defaultValue);
        public Color GetPositionProperty(Vector3Int position, string name, Color defaultValue);
        public bool ErasePositionProperty(Vector3Int position, string name);
        public virtual void Reset();
        public Vector3Int[] GetAllPositions(string propertyName);
    }
}
namespace UnityEngine.Tilemaps
{
    [HelpURL("https://docs.unity3d.com/Packages/com.unity.2d.tilemap.extras@latest/index.html?subfolder=/manual/AnimatedTile.html")]
    [CreateAssetMenu(fileName = "New Animated Tile", menuName = "2D/Tiles/Animated Tile", order = 82)]
    public class AnimatedTile : TileBase
    {
        public Sprite[] m_AnimatedSprites;
        public float m_MinSpeed;
        public float m_MaxSpeed;
        public float m_AnimationStartTime;
        public int m_AnimationStartFrame;
        public Tile.ColliderType m_TileColliderType;

        public AnimatedTile();

        public override void GetTileData(Vector3Int position, ITilemap tilemap, ref TileData tileData);
        public override bool GetTileAnimationData(Vector3Int position, ITilemap tilemap, ref TileAnimationData tileAnimationData);
    }
}
using UnityEditor;

namespace UnityEngine.Tilemaps
{
    [CustomEditor(typeof(AnimatedTile))]
    public class AnimatedTileEditor : Editor
    {
        public AnimatedTileEditor();

        public override void OnInspectorGUI();
    }
}
namespace UnityEngine.Tilemaps
{
    [CreateAssetMenu(fileName = "New Pipeline Tile", menuName = "2D/Tiles/Pipeline Tile", order = 82)]
    public class PipelineTile : TileBase
    {
        [SerializeField]
        public Sprite[] m_Sprites;

        public PipelineTile();

        public override void RefreshTile(Vector3Int position, ITilemap tilemap);
        public override void GetTileData(Vector3Int position, ITilemap tilemap, ref TileData tileData);
    }
}
using UnityEditor;

namespace UnityEngine.Tilemaps
{
    [CustomEditor(typeof(PipelineTile))]
    public class PipelineTileEditor : Editor
    {
        public PipelineTileEditor();

        public void OnEnable();
        public override void OnInspectorGUI();
    }
}
namespace UnityEngine.Tilemaps
{
    [CreateAssetMenu(fileName = "New Random Tile", menuName = "2D/Tiles/Random Tile", order = 82)]
    public class RandomTile : Tile
    {
        [SerializeField]
        public Sprite[] m_Sprites;

        public RandomTile();

        public override void GetTileData(Vector3Int position, ITilemap tilemap, ref TileData tileData);
    }
}
using UnityEditor;

namespace UnityEngine.Tilemaps
{
    [CustomEditor(typeof(RandomTile))]
    public class RandomTileEditor : Editor
    {
        public RandomTileEditor();

        public void OnEnable();
        public override void OnInspectorGUI();
    }
}
using System.Collections.Generic;
using System.Reflection;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Tilemaps
{
    [DefaultMember("Item")]
    [MovedFrom(True, "UnityEngine", null, null)]
    [HelpURL("https://docs.unity3d.com/Packages/com.unity.2d.tilemap.extras@latest/index.html?subfolder=/manual/RuleOverrideTile.html")]
    [CreateAssetMenu(fileName = "New Advanced Rule Override Tile", menuName = "2D/Tiles/Advanced Rule Override Tile", order = 83)]
    public class AdvancedRuleOverrideTile : RuleOverrideTile
    {
        public Sprite m_DefaultSprite;
        public GameObject m_DefaultGameObject;
        public Tile.ColliderType m_DefaultColliderType;
        public List<RuleTile.TilingRuleOutput> m_OverrideTilingRules;

        public AdvancedRuleOverrideTile();

        public RuleTile.TilingRuleOutput this[RuleTile.TilingRule originalRule] { get; set; }

        public void ApplyOverrides(IList<KeyValuePair<RuleTile.TilingRule, RuleTile.TilingRuleOutput>> overrides);
        public void GetOverrides(List<KeyValuePair<RuleTile.TilingRule, RuleTile.TilingRuleOutput>> overrides, ref int validCount);
        public override void Override();
    }
}
using System.Collections.Generic;
using System.Reflection;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Tilemaps
{
    [DefaultMember("Item")]
    [MovedFrom(True, "UnityEngine", null, null)]
    [HelpURL("https://docs.unity3d.com/Packages/com.unity.2d.tilemap.extras@latest/index.html?subfolder=/manual/RuleOverrideTile.html")]
    [CreateAssetMenu(fileName = "New Rule Override Tile", menuName = "2D/Tiles/Rule Override Tile", order = 83)]
    public class RuleOverrideTile : TileBase
    {
        public RuleTile m_Tile;
        public List<TileSpritePair> m_Sprites;
        public List<TileGameObjectPair> m_GameObjects;
        [HideInInspector]
        public RuleTile m_InstanceTile;

        public RuleOverrideTile();

        public Sprite this[Sprite originalSprite] { get; set; }
        public GameObject this[GameObject originalGameObject] { get; set; }

        public void ApplyOverrides(IList<KeyValuePair<Sprite, Sprite>> overrides);
        public void ApplyOverrides(IList<KeyValuePair<GameObject, GameObject>> overrides);
        public void GetOverrides(List<KeyValuePair<Sprite, Sprite>> overrides, ref int validCount);
        public void GetOverrides(List<KeyValuePair<GameObject, GameObject>> overrides, ref int validCount);
        public virtual void Override();
        public void PrepareOverride();
        public override bool GetTileAnimationData(Vector3Int position, ITilemap tilemap, ref TileAnimationData tileAnimationData);
        public override void GetTileData(Vector3Int position, ITilemap tilemap, ref TileData tileData);
        public override void RefreshTile(Vector3Int position, ITilemap tilemap);
        public override bool StartUp(Vector3Int position, ITilemap tilemap, GameObject go);

        public class TileSpritePair
        {
            public Sprite m_OriginalSprite;
            public Sprite m_OverrideSprite;

            public TileSpritePair();
        }
        public class TileGameObjectPair
        {
            public GameObject m_OriginalGameObject;
            public GameObject m_OverrideGameObject;

            public TileGameObjectPair();
        }
    }
}
namespace UnityEngine.Tilemaps
{
    [CreateAssetMenu(fileName = "New Terrain Tile", menuName = "2D/Tiles/Terrain Tile", order = 82)]
    public class TerrainTile : TileBase
    {
        [SerializeField]
        public Sprite[] m_Sprites;

        public TerrainTile();

        public override void RefreshTile(Vector3Int position, ITilemap tilemap);
        public override void GetTileData(Vector3Int position, ITilemap tilemap, ref TileData tileData);
    }
}
using UnityEditor;

namespace UnityEngine.Tilemaps
{
    [CustomEditor(typeof(TerrainTile))]
    public class TerrainTileEditor : Editor
    {
        public TerrainTileEditor();

        public void OnEnable();
        public override void OnInspectorGUI();
    }
}
namespace UnityEngine.Tilemaps
{
    public struct WeightedSprite
    {
        public Sprite Sprite;
        public int Weight;
    }
}
namespace UnityEngine.Tilemaps
{
    [CreateAssetMenu(fileName = "New Weighted Random Tile", menuName = "2D/Tiles/Weighted Random Tile", order = 82)]
    public class WeightedRandomTile : Tile
    {
        [SerializeField]
        public WeightedSprite[] Sprites;

        public WeightedRandomTile();

        public override void GetTileData(Vector3Int position, ITilemap tilemap, ref TileData tileData);
    }
}
using UnityEditor;

namespace UnityEngine.Tilemaps
{
    [CustomEditor(typeof(WeightedRandomTile))]
    public class WeightedRandomTileEditor : Editor
    {
        public WeightedRandomTileEditor();

        public void OnEnable();
        public override void OnInspectorGUI();
    }
}
-------- {Unity.Recorder.Editor(D:\Documents\GitHub\Rogue-like-game-i-guess\The game is liar\Library\ScriptAssemblies\Unity.Recorder.Editor.dll)}:  260 --------
using UnityEngine;

public class AccumulationSettings
{
    public AccumulationSettings();

    public bool CaptureAccumulation { get; set; }
    public int Samples { get; set; }
    public float ShutterInterval { get; set; }
    public ShutterProfileType ShutterType { get; set; }
    public AnimationCurve ShutterProfileCurve { get; set; }
    public float ShutterFullyOpen { get; set; }
    public float ShutterBeginsClosing { get; set; }

    public enum ShutterProfileType
    {
        Range = 0,
        Curve = 1
    }
}
public interface IAccumulation
{
    AccumulationSettings GetAccumulationSettings();
}
using UnityEngine;

namespace UnityEditor.Recorder
{
    public abstract class BaseRenderTextureInput : RecorderInput
    {
        protected BaseRenderTextureInput();

        protected internal RenderTexture OutputRenderTexture { get; set; }
        protected internal Texture2D ReadbackTexture { get; set; }
        public int OutputWidth { get; protected set; }
        public int OutputHeight { get; protected set; }

        protected void ReleaseBuffer();
        protected override void Dispose(bool disposing);
    }
}
using UnityEngine;
using UnityEngine.Rendering;

namespace UnityEditor.Recorder
{
    public abstract class BaseTextureRecorder<T> : GenericRecorder<T> where T : RecorderSettings
    {
        protected bool UseAsyncGPUReadback;

        protected BaseTextureRecorder();

        protected abstract TextureFormat ReadbackTextureFormat { get; }

        protected internal override bool BeginRecording(RecordingSession session);
        protected internal override void RecordFrame(RecordingSession session);
        protected internal override void PrepareNewFrame(RecordingSession ctx);
        protected internal override void EndRecording(RecordingSession session);
        protected virtual void WriteFrame(AsyncGPUReadbackRequest r);
        protected abstract void WriteFrame(Texture2D t);
        protected virtual void DisposeEncoder();
    }
}
namespace UnityEditor.Recorder
{
    public static class DefaultWildcard
    {
        public static readonly string Recorder;
        public static readonly string Time;
        public static readonly string Take;
        public static readonly string Date;
        public static readonly string Project;
        public static readonly string Product;
        public static readonly string Scene;
        public static readonly string Resolution;
        public static readonly string Frame;
        public static readonly string Extension;

        public static string GeneratePattern(string tag);
    }
}
using System;

namespace UnityEditor.Recorder
{
    public class FileNameGenerator
    {
        public string FileName { get; set; }
        public OutputPath.Root Root { get; set; }
        public string Leaf { get; set; }
        public bool ForceAssetsFolder { get; set; }

        public void AddWildcard(string tag, Func<RecordingSession, string> resolver);
        public string BuildAbsolutePath(RecordingSession session);
        public void CreateDirectory(RecordingSession session);
        public static string SanitizePath(string fullPath);
    }
}
namespace UnityEditor.Recorder
{
    public abstract class GenericRecorder<T> : Recorder where T : RecorderSettings
    {
        protected GenericRecorder();

        public T Settings { get; set; }
    }
}
using UnityEngine;

namespace UnityEditor.Recorder
{
    public static class UnityHelpers
    {
        public static void Destroy(Object obj, bool allowDestroyingAssets = False);
    }
}
using UnityEditor.Recorder.Input;
using UnityEngine;

namespace UnityEditor.Recorder
{
    public class ImageInputSelector : InputSettingsSelector
    {
        [SerializeField]
        public GameViewInputSettings gameViewInputSettings;
        [SerializeField]
        public CameraInputSettings cameraInputSettings;
        [SerializeField]
        public Camera360InputSettings camera360InputSettings;
        [SerializeField]
        public RenderTextureInputSettings renderTextureInputSettings;
        [SerializeField]
        public RenderTextureSamplerSettings renderTextureSamplerSettings;

        public ImageInputSelector();

        public ImageInputSettings ImageInputSettings { get; set; }
    }
}
using System;
using System.Collections.Generic;

namespace UnityEditor.Recorder
{
    public abstract class RecorderInputSettings
    {
        protected RecorderInputSettings();

        protected internal abstract Type InputType { get; }

        [Obsolete("Please use methods CheckForErrors() and CheckForWarnings()")]
        protected internal virtual bool ValidityCheck(List<string> errors);
        protected internal virtual void CheckForWarnings(List<string> warnings);
        protected internal virtual void CheckForErrors(List<string> errors);
    }
}
namespace UnityEditor.Recorder
{
    public abstract class InputSettingsSelector
    {
        protected internal InputSettingsSelector();

        public RecorderInputSettings Selected { get; protected set; }
    }
}
namespace UnityEditor.Recorder
{
    public class OutputPath
    {
        public OutputPath();

        public enum Root
        {
            Project = 0,
            AssetsFolder = 1,
            StreamingAssets = 2,
            PersistentData = 3,
            TemporaryCache = 4,
            Absolute = 5
        }
    }
}
using System.Collections.Generic;
using UnityEngine;

namespace UnityEditor.Recorder
{
    public abstract class Recorder : ScriptableObject
    {
        protected List<RecorderInput> m_Inputs;

        protected Recorder();

        protected internal int RecordedFramesCount { get; }
        public bool Recording { get; protected set; }

        protected internal virtual void Reset();
        protected internal void ConsoleLogMessage(string message, LogType logType);
        protected internal virtual void SessionCreated(RecordingSession session);
        protected internal virtual bool BeginRecording(RecordingSession session);
        protected internal virtual void EndRecording(RecordingSession session);
        protected internal abstract void RecordFrame(RecordingSession ctx);
        protected internal virtual void PrepareNewFrame(RecordingSession ctx);
        protected internal virtual bool SkipFrame(RecordingSession ctx);
        protected internal virtual bool SkipSubFrame(RecordingSession ctx);
    }
}
namespace UnityEditor.Recorder
{
    public class RecorderController
    {
        public RecorderController(RecorderControllerSettings settings);

        public RecorderControllerSettings Settings { get; }

        public void PrepareRecording();
        public bool StartRecording();
        public bool IsRecording();
        public void StopRecording();
    }
}
using System.Collections.Generic;
using UnityEngine;

namespace UnityEditor.Recorder
{
    public class RecorderControllerSettings : ScriptableObject
    {
        public RecorderControllerSettings();

        public FrameRatePlayback FrameRatePlayback { get; set; }
        public float FrameRate { get; set; }
        public bool CapFrameRate { get; set; }
        public IEnumerable<RecorderSettings> RecorderSettings { get; }

        public void SetRecordModeToManual();
        public void SetRecordModeToSingleFrame(int frameNumber);
        public void SetRecordModeToFrameInterval(int startFrame, int endFrame);
        public void SetRecordModeToTimeInterval(float startTime, float endTime);
        public static RecorderControllerSettings LoadOrCreate(string path);
        public static RecorderControllerSettings GetGlobalSettings();
        public void AddRecorderSettings(RecorderSettings recorder);
        public void RemoveRecorder(RecorderSettings recorder);
        public void Save();
    }
}
using UnityEngine;

namespace UnityEditor.Recorder
{
    public class RecorderControllerSettingsPreset : ScriptableObject
    {
        public RecorderControllerSettingsPreset();

        public static void SaveAtPath(RecorderControllerSettings model, string path);
        public void ApplyTo(RecorderControllerSettings prefs);
    }
}
namespace UnityEditor.Recorder
{
    public abstract class RecorderEditor : Editor
    {
        protected RecorderEditor();

        protected virtual void OnEnable();
        protected static void DrawSeparator();
        public override void OnInspectorGUI();
        protected virtual void OnValidateSettingsGUI();
        protected virtual void NameAndPathGUI();
        protected virtual void ImageRenderOptionsGUI();
        protected virtual void ExtraOptionsGUI();
        protected virtual void FileTypeAndFormatGUI();
        protected virtual void OnEncodingGui();
        protected virtual void AOVGUI();
        protected virtual void AccumulationGUI();
    }
}
using System;

namespace UnityEditor.Recorder
{
    public class RecorderInput : IDisposable
    {
        public RecorderInput();

        ~RecorderInput();

        public RecorderInputSettings settings { get; set; }

        public void Dispose();
        protected virtual void Dispose(bool disposing);
        protected internal virtual void SessionCreated(RecordingSession session);
        protected internal virtual void BeginRecording(RecordingSession session);
        protected internal virtual void NewFrameStarting(RecordingSession session);
        protected internal virtual void NewFrameReady(RecordingSession session);
        protected internal virtual void FrameDone(RecordingSession session);
        protected internal virtual void EndRecording(RecordingSession session);
    }
}
namespace UnityEditor.Recorder
{
    public static class RecorderOptions
    {
        public static bool VerboseMode { get; set; }
        public static bool ShowRecorderGameObject { get; set; }
    }
}
using System;

namespace UnityEditor.Recorder
{
    [Flags]
    public enum ImageSource
    {
        ActiveCamera = 1,
        MainCamera = 2,
        TaggedCamera = 4
    }
}
namespace UnityEditor.Recorder
{
    public enum FrameRatePlayback
    {
        Constant = 0,
        Variable = 1
    }
}
namespace UnityEditor.Recorder
{
    public enum RecordMode
    {
        Manual = 0,
        SingleFrame = 1,
        FrameInterval = 2,
        TimeInterval = 3
    }
}
using System;
using System.Collections.Generic;
using UnityEngine;

namespace UnityEditor.Recorder
{
    public abstract class RecorderSettings : ScriptableObject
    {
        protected RecorderSettings();

        public string OutputFile { get; set; }
        public bool Enabled { get; set; }
        public int Take { get; set; }
        protected internal abstract string Extension { get; }
        public FileNameGenerator FileNameGenerator { get; }
        public RecordMode RecordMode { get; set; }
        public FrameRatePlayback FrameRatePlayback { get; set; }
        public float FrameRate { get; set; }
        public int StartFrame { get; set; }
        public int EndFrame { get; set; }
        public float StartTime { get; set; }
        public float EndTime { get; set; }
        public bool CapFrameRate { get; set; }
        public virtual bool IsPlatformSupported { get; }
        public abstract IEnumerable<RecorderInputSettings> InputsSettings { get; }

        [Obsolete("Please use methods GetErrors() and GetWarnings()")]
        protected internal virtual bool ValidityCheck(List<string> errors);
        protected internal virtual void GetErrors(List<string> errors);
        protected internal virtual void GetWarnings(List<string> warnings);
        public virtual void OnAfterDuplicate();
        protected internal virtual bool HasErrors();
        public virtual bool IsAccumulationSupported();
    }
}
using System;

namespace UnityEditor.Recorder
{
    [AttributeUsage(Class, Inherited = False)]
    public class RecorderSettingsAttribute : Attribute
    {
        public RecorderSettingsAttribute(Type recorderType, string displayName);
        public RecorderSettingsAttribute(Type recorderType, string displayName, bool deprecated);
        public RecorderSettingsAttribute(Type recorderType, string displayName, string iconName);
        public RecorderSettingsAttribute(Type recorderType, string displayName, string iconName, bool deprecated);
    }
}
namespace UnityEditor.Recorder
{
    public class RecorderWindow : EditorWindow
    {
        public const string MenuRoot = "Window/General/Recorder/";
        public const int MenuRootIndex = 1000;

        public RecorderWindow();

        public void SetRecorderControllerSettings(RecorderControllerSettings settings);
        public void StartRecording();
        public bool IsRecording();
        public void StopRecording();
        public void ApplyPreset(RecorderControllerSettingsPreset preset);
    }
}
using System.Collections.Generic;
using UnityEditor.Recorder.Input;

namespace UnityEditor.Recorder
{
    [RecorderSettings(typeof(AnimationRecorder), "Animation Clip", "animation_recorder")]
    public class AnimationRecorderSettings : RecorderSettings
    {
        public AnimationRecorderSettings();

        public AnimationInputSettings AnimationInputSettings { get; set; }
        public override bool IsPlatformSupported { get; }
        public override IEnumerable<RecorderInputSettings> InputsSettings { get; }
        protected internal override string Extension { get; }

        protected internal override void GetErrors(List<string> errors);
        public override void OnAfterDuplicate();
    }
}
using System;
using UnityEditor.Recorder.FrameCapturer;

namespace UnityEditor.Recorder
{
    [Obsolete("The GIFRecorder is deprecated")]
    [RecorderSettings(typeof(GIFRecorder), "GIF Animation", "imagesequence_16", True)]
    public class GIFRecorderSettings : BaseFCRecorderSettings
    {
        [Obsolete("The GIFRecorder is deprecated")]
        public GIFRecorderSettings();

        protected internal override string Extension { get; }
    }
}
using System.Collections.Generic;
using UnityEditor.Recorder.Input;

namespace UnityEditor.Recorder
{
    [RecorderSettings(typeof(ImageRecorder), "Image Sequence", "imagesequence_16")]
    public class ImageRecorderSettings : RecorderSettings, IAccumulation
    {
        public ImageRecorderSettings();

        public ImageRecorderOutputFormat OutputFormat { get; set; }
        public bool CaptureAlpha { get; set; }
        public bool CaptureHDR { get; }
        protected internal override string Extension { get; }
        public EXRCompressionType EXRCompression { get; set; }
        public ColorSpaceType OutputColorSpace { get; set; }
        public ImageInputSettings imageInputSettings { get; set; }
        public override IEnumerable<RecorderInputSettings> InputsSettings { get; }
        public AccumulationSettings AccumulationSettings { get; set; }

        public AccumulationSettings GetAccumulationSettings();
        public override bool IsAccumulationSupported();

        public enum ImageRecorderOutputFormat
        {
            PNG = 0,
            JPEG = 1,
            EXR = 2
        }
        public enum EXRCompressionType
        {
            None = 0,
            RLE = 1,
            Zip = 2
        }
        public enum ColorSpaceType
        {
            sRGB_sRGB = 0,
            Unclamped_linear_sRGB = 1
        }
    }
}
using System.Collections.Generic;
using UnityEditor.Recorder.Input;

namespace UnityEditor.Recorder
{
    [RecorderSettings(typeof(MovieRecorder), "Movie", "movie_16")]
    public class MovieRecorderSettings : RecorderSettings, IAccumulation
    {
        public MovieRecorderSettings();

        public VideoRecorderOutputFormat OutputFormat { get; set; }
        public VideoBitrateMode VideoBitRateMode { get; set; }
        public bool CaptureAlpha { get; set; }
        public AccumulationSettings AccumulationSettings { get; set; }
        public ImageInputSettings ImageInputSettings { get; set; }
        public AudioInputSettings AudioInputSettings { get; }
        public override IEnumerable<RecorderInputSettings> InputsSettings { get; }
        protected internal override string Extension { get; }

        public void GetPresetsForEncoder(int indexEncoder, out List<string> presetNames, out List<string> presetOptions);
        public AccumulationSettings GetAccumulationSettings();
        public override bool IsAccumulationSupported();
        protected internal override void GetWarnings(List<string> warnings);
        protected internal override void GetErrors(List<string> errors);

        public enum VideoRecorderOutputFormat
        {
            MP4 = 0,
            WebM = 1,
            MOV = 2
        }
    }
}
using System;

namespace UnityEditor.Recorder
{
    public class RecordingSession : IDisposable
    {
        public Recorder recorder;

        public RecordingSession();

        public RecorderSettings settings { get; }
        public int frameIndex { get; }
        public float recorderTime { get; }

        public void Dispose();
    }
}
using UnityEngine;

namespace UnityEditor.Recorder
{
    public static class BindingManager
    {
        public static Object Get(string id);
        public static void Duplicate(string id, string newId);
        public static void Set(string id, Object obj);
    }
}
using System.ComponentModel;
using UnityEngine;
using UnityEngine.Playables;
using UnityEngine.Timeline;

namespace UnityEditor.Recorder.Timeline
{
    [DisplayName("Recorder Clip")]
    public class RecorderClip : PlayableAsset, ISerializationCallbackReceiver, ITimelineClipAsset
    {
        [SerializeField]
        public RecorderSettings settings;

        public RecorderClip();

        public ClipCaps clipCaps { get; }

        public override Playable CreatePlayable(PlayableGraph graph, GameObject owner);
        public void OnDestroy();
        public void OnBeforeSerialize();
        public void OnAfterDeserialize();
    }
}
using UnityEngine.Timeline;

namespace UnityEditor.Recorder.Timeline
{
    [TrackClipType(typeof(RecorderClip))]
    [TrackColor(0, 0.53F, 0.08F)]
    public class RecorderTrack : TrackAsset
    {
        public RecorderTrack();
    }
}
using System;
using System.Collections.Generic;
using UnityEditor.Recorder.Input;

namespace UnityEditor.Recorder.FrameCapturer
{
    [Obsolete("The legacy recorders are deprecated")]
    public abstract class BaseFCRecorderSettings : RecorderSettings
    {
        protected BaseFCRecorderSettings();

        public ImageInputSettings imageInputSettings { get; set; }
        public override IEnumerable<RecorderInputSettings> InputsSettings { get; }
    }
}
namespace UnityEditor.Recorder.AOV
{
    public enum AOVType
    {
        Beauty = 0,
        Albedo = 1,
        Normal = 2,
        Smoothness = 3,
        AmbientOcclusion = 4,
        Metal = 5,
        Specular = 6,
        Alpha = 7,
        DiffuseLighting = 8,
        SpecularLighting = 9,
        DirectDiffuse = 10,
        DirectSpecular = 11,
        IndirectDiffuse = 12,
        Reflection = 13,
        Refraction = 14,
        Emissive = 15,
        MotionVectors = 16,
        Depth = 17
    }
}
using System.Collections.Generic;
using UnityEditor.Recorder.Input;

namespace UnityEditor.Recorder.AOV
{
    [RecorderSettings(typeof(AOVRecorder), "AOV Image Sequence", "aovimagesequence_16")]
    public class AOVRecorderSettings : RecorderSettings
    {
        public AOVRecorderSettings();

        protected internal override string Extension { get; }
        public AOVType AOVSelection { get; set; }
        public ImageRecorderSettings.ColorSpaceType OutputColorSpace { get; set; }
        public ImageRecorderSettings.EXRCompressionType EXRCompression { get; set; }
        public ImageRecorderSettings.ImageRecorderOutputFormat OutputFormat { get; set; }
        public bool CaptureHDR { get; }
        public ImageInputSettings imageInputSettings { get; set; }
        public override IEnumerable<RecorderInputSettings> InputsSettings { get; }

        protected internal override void GetErrors(List<string> errors);
        protected internal override bool HasErrors();
    }
}
using System;
using UnityEditor.Recorder.Input;

namespace UnityEditor.Recorder.AOV.Input
{
    public class AOVCameraInputSettings : CameraInputSettings
    {
        public AOVCameraInputSettings();

        protected internal override Type InputType { get; }
    }
}
namespace UnityEditor.Recorder.Input
{
    public abstract class ImageInputSettings : RecorderInputSettings
    {
        protected ImageInputSettings();

        public abstract int OutputWidth { get; set; }
        public abstract int OutputHeight { get; set; }
        public virtual bool SupportsTransparent { get; }
        public bool RecordTransparency { get; set; }
    }
}
using System.Collections.Generic;

namespace UnityEditor.Recorder.Input
{
    public abstract class StandardImageInputSettings : ImageInputSettings
    {
        protected StandardImageInputSettings();

        public override int OutputWidth { get; set; }
        public override int OutputHeight { get; set; }

        protected internal override void CheckForWarnings(List<string> warnings);
        protected internal override void CheckForErrors(List<string> errors);
    }
}
using UnityEditor.Animations;

namespace UnityEditor.Recorder.Input
{
    public class AnimationInput : RecorderInput
    {
        public AnimationInput();

        public GameObjectRecorder GameObjectRecorder { get; }

        protected internal override void BeginRecording(RecordingSession session);
        protected internal override void NewFrameReady(RecordingSession session);
    }
}
using System;
using System.Collections.Generic;
using System.ComponentModel;
using UnityEngine;

namespace UnityEditor.Recorder.Input
{
    [DisplayName("Animation")]
    public class AnimationInputSettings : RecorderInputSettings
    {
        public AnimationInputSettings();

        public GameObject gameObject { get; set; }
        public bool Recursive { get; set; }
        public bool ClampedTangents { get; set; }
        public CurveSimplificationOptions SimplyCurves { get; set; }
        protected internal override Type InputType { get; }

        public void AddComponentToRecord(Type componentType);
        protected internal override void CheckForErrors(List<string> errors);
        public void DuplicateExposedReference();
        public void ClearExposedReference();

        public enum CurveSimplificationOptions
        {
            Lossy = 0,
            Lossless = 1,
            Disabled = 2
        }
    }
}
using System;
using System.ComponentModel;

namespace UnityEditor.Recorder.Input
{
    [DisplayName("Audio")]
    public class AudioInputSettings : RecorderInputSettings
    {
        public AudioInputSettings();

        public bool PreserveAudio { get; set; }
        protected internal override Type InputType { get; }
    }
}
using UnityEngine;

namespace UnityEditor.Recorder.Input
{
    public class CameraInput : BaseRenderTextureInput
    {
        public CameraInput();

        protected Camera TargetCamera { get; set; }

        protected internal override void BeginRecording(RecordingSession session);
        protected internal override void NewFrameStarting(RecordingSession session);
        protected internal override void NewFrameReady(RecordingSession session);
        protected override void Dispose(bool disposing);
        protected internal override void EndRecording(RecordingSession session);
    }
}
using System;
using System.Collections.Generic;
using System.ComponentModel;

namespace UnityEditor.Recorder.Input
{
    [DisplayName("Targeted Camera")]
    public class CameraInputSettings : StandardImageInputSettings
    {
        public CameraInputSettings();

        public ImageSource Source { get; set; }
        public string CameraTag { get; set; }
        public bool FlipFinalOutput { get; set; }
        public bool CaptureUI { get; set; }
        protected internal override Type InputType { get; }

        protected internal override void CheckForErrors(List<string> errors);
    }
}
using System;
using System.Collections.Generic;
using System.ComponentModel;

namespace UnityEditor.Recorder.Input
{
    [DisplayName("360 View")]
    public class Camera360InputSettings : ImageInputSettings
    {
        public Camera360InputSettings();

        public ImageSource Source { get; set; }
        public string CameraTag { get; set; }
        public bool FlipFinalOutput { get; set; }
        public bool RenderStereo { get; set; }
        public float StereoSeparation { get; set; }
        public int MapSize { get; set; }
        protected internal override Type InputType { get; }
        public override int OutputWidth { get; set; }
        public override int OutputHeight { get; set; }

        protected internal override void CheckForErrors(List<string> errors);
    }
}
using System;
using System.ComponentModel;

namespace UnityEditor.Recorder.Input
{
    [DisplayName("Game View")]
    public class GameViewInputSettings : StandardImageInputSettings
    {
        public GameViewInputSettings();

        public bool FlipFinalOutput { get; set; }
        protected internal override Type InputType { get; }
        public override bool SupportsTransparent { get; }
    }
}
using System;
using System.Collections.Generic;
using System.ComponentModel;
using UnityEngine;

namespace UnityEditor.Recorder.Input
{
    [DisplayName("Render Texture Asset")]
    public class RenderTextureInputSettings : ImageInputSettings
    {
        public RenderTextureInputSettings();

        public RenderTexture RenderTexture { get; set; }
        public bool FlipFinalOutput { get; set; }
        protected internal override Type InputType { get; }
        public override int OutputWidth { get; set; }
        public override int OutputHeight { get; set; }

        protected internal override void CheckForErrors(List<string> errors);
    }
}
namespace UnityEditor.Recorder.Input
{
    public enum SuperSamplingCount
    {
        X1 = 1,
        X2 = 2,
        X4 = 4,
        X8 = 8,
        X16 = 16
    }
}
using System;
using System.Collections.Generic;
using System.ComponentModel;
using UnityEngine;

namespace UnityEditor.Recorder.Input
{
    [DisplayName("Texture Sampling")]
    public class RenderTextureSamplerSettings : ImageInputSettings
    {
        public RenderTextureSamplerSettings();

        public SuperSamplingCount SuperSampling { get; set; }
        public string CameraTag { get; set; }
        public ColorSpace ColorSpace { get; set; }
        public bool FlipFinalOutput { get; set; }
        protected internal override Type InputType { get; }
        public override int OutputWidth { get; set; }
        public override int OutputHeight { get; set; }
        public int RenderWidth { get; set; }
        public int RenderHeight { get; set; }

        protected internal override void CheckForWarnings(List<string> warnings);
    }
}
-------- {Unity.MemoryProfiler(D:\Documents\GitHub\Rogue-like-game-i-guess\The game is liar\Library\ScriptAssemblies\Unity.MemoryProfiler.dll)}:    2 --------
using System;
using UnityEngine.Profiling.Memory.Experimental;

namespace Unity.MemoryProfiler
{
    public abstract class MetadataCollect : IDisposable
    {
        public MetadataCollect();

        public abstract void CollectMetadata(MetaData data);
        public void Dispose();
    }
}
-------- {Unity.2D.Tilemap.Editor(D:\Documents\GitHub\Rogue-like-game-i-guess\The game is liar\Library\ScriptAssemblies\Unity.2D.Tilemap.Editor.dll)}:   90 --------
using System;

namespace UnityEditor.Tilemaps
{
    [AttributeUsage(Method)]
    public class CreateTileFromPaletteAttribute : Attribute
    {
        public CreateTileFromPaletteAttribute();
    }
}
using UnityEngine;

namespace UnityEditor.Tilemaps
{
    public sealed class BoxTool : TilemapEditorTool
    {
        public BoxTool();

        protected override string tooltipStringFormat { get; }
        protected override string shortcutId { get; }
        public override GUIContent toolbarIcon { get; }
    }
}
using UnityEngine;

namespace UnityEditor.Tilemaps
{
    public sealed class EraseTool : TilemapEditorTool
    {
        public EraseTool();

        protected override string tooltipStringFormat { get; }
        protected override string shortcutId { get; }
        public override GUIContent toolbarIcon { get; }
    }
}
using UnityEngine;

namespace UnityEditor.Tilemaps
{
    public sealed class FillTool : TilemapEditorTool
    {
        public FillTool();

        protected override string tooltipStringFormat { get; }
        protected override string shortcutId { get; }
        public override GUIContent toolbarIcon { get; }
    }
}
using UnityEngine;

namespace UnityEditor.Tilemaps
{
    public sealed class MoveTool : TilemapEditorTool
    {
        public MoveTool();

        protected override string tooltipStringFormat { get; }
        protected override string shortcutId { get; }
        public override GUIContent toolbarIcon { get; }
    }
}
using UnityEngine;

namespace UnityEditor.Tilemaps
{
    public sealed class PaintTool : TilemapEditorTool
    {
        public PaintTool();

        protected override string tooltipStringFormat { get; }
        protected override string shortcutId { get; }
        public override GUIContent toolbarIcon { get; }
    }
}
using UnityEngine;

namespace UnityEditor.Tilemaps
{
    public sealed class PickingTool : TilemapEditorTool
    {
        public PickingTool();

        protected override string tooltipStringFormat { get; }
        protected override string shortcutId { get; }
        public override GUIContent toolbarIcon { get; }
    }
}
using UnityEngine;

namespace UnityEditor.Tilemaps
{
    public sealed class SelectTool : TilemapEditorTool
    {
        public SelectTool();

        protected override string tooltipStringFormat { get; }
        protected override string shortcutId { get; }
        public override GUIContent toolbarIcon { get; }
    }
}
using System;
using UnityEditor.EditorTools;

namespace UnityEditor.Tilemaps
{
    public abstract class TilemapEditorTool : EditorTool
    {
        protected TilemapEditorTool();

        public static EditorTool[] tilemapEditorTools { get; }
        public static float tilemapEditorToolsToolbarSize { get; }
        protected abstract string tooltipStringFormat { get; }
        protected abstract string shortcutId { get; }

        protected static string GetTooltipText(string tooltipStringFormat, string shortcutId);
        protected static string GetKeysFromToolName(string id);
        protected void UpdateTooltip();
        public override bool IsAvailable();
        public static void ToggleActiveEditorTool(Type type);
        public static void SetActiveEditorTool(Type type);
    }
}
using UnityEngine;
using UnityEngine.Scripting.APIUpdating;
using UnityEngine.Tilemaps;

namespace UnityEditor.Tilemaps
{
    [MovedFrom(True, "UnityEditor", "UnityEditor", null)]
    public class GridBrush : GridBrushBase
    {
        public GridBrush();

        public Vector3Int size { get; set; }
        public Vector3Int pivot { get; set; }
        public BrushCell[] cells { get; }
        public int cellCount { get; }
        public bool canChangeZPosition { get; set; }

        public void Init(Vector3Int size);
        public void Init(Vector3Int size, Vector3Int pivot);
        public override void Paint(GridLayout gridLayout, GameObject brushTarget, Vector3Int position);
        public override void Erase(GridLayout gridLayout, GameObject brushTarget, Vector3Int position);
        public override void BoxFill(GridLayout gridLayout, GameObject brushTarget, BoundsInt position);
        public override void BoxErase(GridLayout gridLayout, GameObject brushTarget, BoundsInt position);
        public override void FloodFill(GridLayout gridLayout, GameObject brushTarget, Vector3Int position);
        public override void Rotate(GridBrushBase.RotationDirection direction, GridLayout.CellLayout layout);
        public override void Flip(GridBrushBase.FlipAxis flip, GridLayout.CellLayout layout);
        public override void Pick(GridLayout gridLayout, GameObject brushTarget, BoundsInt position, Vector3Int pickStart);
        public override void MoveStart(GridLayout gridLayout, GameObject brushTarget, BoundsInt position);
        public override void MoveEnd(GridLayout gridLayout, GameObject brushTarget, BoundsInt position);
        public void Reset();
        public void UpdateSizeAndPivot(Vector3Int size, Vector3Int pivot);
        public void SetTile(Vector3Int position, TileBase tile);
        public void SetMatrix(Vector3Int position, Matrix4x4 matrix);
        public void SetColor(Vector3Int position, Color color);
        public int GetCellIndex(Vector3Int brushPosition);
        public int GetCellIndex(int x, int y, int z);
        public int GetCellIndex(int x, int y, int z, int sizex, int sizey, int sizez);
        public int GetCellIndexWrapAround(int x, int y, int z);
        public override int GetHashCode();

        public class BrushCell
        {
            public BrushCell();

            public TileBase tile { get; set; }
            public Matrix4x4 matrix { get; set; }
            public Color color { get; set; }

            public override int GetHashCode();
        }
    }
}
using UnityEngine;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.Tilemaps
{
    [MovedFrom(True, "UnityEditor", "UnityEditor", null)]
    [CustomEditor(typeof(GridBrush))]
    public class GridBrushEditor : GridBrushEditorBase
    {
        public GridBrushEditor();

        public GridBrush brush { get; }
        public override bool canChangeZPosition { get; set; }
        public override GameObject[] validTargets { get; }

        protected virtual void OnEnable();
        protected virtual void OnDisable();
        public override void OnPaintSceneGUI(GridLayout gridLayout, GameObject brushTarget, BoundsInt position, GridBrushBase.Tool tool, bool executing);
        public override void OnSelectionInspectorGUI();
        public override void OnSelectionSceneGUI(GridLayout gridLayout, GameObject brushTarget);
        public override void OnMouseLeave();
        public override void OnToolDeactivated(GridBrushBase.Tool tool);
        public override void RegisterUndo(GameObject brushTarget, GridBrushBase.Tool tool);
        public virtual void PaintPreview(GridLayout gridLayout, GameObject brushTarget, Vector3Int position);
        public virtual void BoxFillPreview(GridLayout gridLayout, GameObject brushTarget, BoundsInt position);
        public virtual void FloodFillPreview(GridLayout gridLayout, GameObject brushTarget, Vector3Int position);
        public virtual void ClearPreview();

        public enum ModifyCells
        {
            InsertRow = 0,
            InsertColumn = 1,
            InsertRowBefore = 2,
            InsertColumnBefore = 3,
            DeleteRow = 4,
            DeleteColumn = 5,
            DeleteRowBefore = 6,
            DeleteColumnBefore = 7
        }
    }
}
using UnityEngine;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.Tilemaps
{
    [MovedFrom(True, "UnityEditor", "UnityEditor", null)]
    [CustomEditor(typeof(GridBrushBase))]
    public class GridBrushEditorBase : Editor
    {
        public GridBrushEditorBase();

        public virtual bool canChangeZPosition { get; set; }
        public virtual GameObject[] validTargets { get; }

        public virtual void OnPaintSceneGUI(GridLayout gridLayout, GameObject brushTarget, BoundsInt position, GridBrushBase.Tool tool, bool executing);
        public virtual void OnPaintInspectorGUI();
        public virtual void OnSelectionInspectorGUI();
        public virtual void OnSelectionSceneGUI(GridLayout gridLayout, GameObject brushTarget);
        public virtual void OnSceneGUI(GridLayout gridLayout, GameObject brushTarget);
        public virtual void OnMouseLeave();
        public virtual void OnMouseEnter();
        public virtual void OnToolActivated(GridBrushBase.Tool tool);
        public virtual void OnToolDeactivated(GridBrushBase.Tool tool);
        public virtual void RegisterUndo(GameObject brushTarget, GridBrushBase.Tool tool);
    }
}
using System;

namespace UnityEditor.Tilemaps
{
    [AttributeUsage(Class, Method)]
    public class GridPaintSortingAttribute : Attribute
    {
        public GridPaintSortingAttribute();
    }
}
using System;
using System.Collections.Generic;
using UnityEngine;

namespace UnityEditor.Tilemaps
{
    public class GridPaintingState : ScriptableSingleton<GridPaintingState>
    {
        public GridPaintingState();

        public static GameObject scenePaintTarget { get; set; }
        public static GridBrushBase gridBrush { get; set; }
        public static IList<GridBrushBase> brushes { get; }
        public static GameObject palette { get; set; }
        public static IList<GameObject> palettes { get; }
        public static GridBrushEditorBase activeBrushEditor { get; }
        public static GameObject[] validTargets { get; }

        public static event Action<GameObject> scenePaintTargetChanged;
        public static event Action<GridBrushBase> brushChanged;
        public static event Action<GameObject> paletteChanged;

        public static bool IsPartOfActivePalette(GameObject target);
    }
}
namespace UnityEditor.Tilemaps
{
    [CustomEditor(typeof(GridPalette))]
    public class GridPaletteEditor : Editor
    {
        public GridPaletteEditor();

        public override void OnInspectorGUI();
    }
}
using UnityEngine;

namespace UnityEditor.Tilemaps
{
    public static class GridPaletteUtility
    {
        public static GameObject CreateNewPaletteAtCurrentFolder(string name, GridLayout.CellLayout layout, GridPalette.CellSizing cellSizing, Vector3 cellSize, GridLayout.CellSwizzle swizzle);
        public static GameObject CreateNewPaletteAtCurrentFolder(string name, GridLayout.CellLayout layout, GridPalette.CellSizing cellSizing, Vector3 cellSize, GridLayout.CellSwizzle swizzle, TransparencySortMode sortMode, Vector3 sortAxis);
        public static GameObject CreateNewPalette(string folderPath, string name, GridLayout.CellLayout layout, GridPalette.CellSizing cellSizing, Vector3 cellSize, GridLayout.CellSwizzle swizzle);
        public static GameObject CreateNewPalette(string folderPath, string name, GridLayout.CellLayout layout, GridPalette.CellSizing cellSizing, Vector3 cellSize, GridLayout.CellSwizzle swizzle, TransparencySortMode sortMode, Vector3 sortAxis);
    }
}
using System;
using UnityEngine;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.Tilemaps
{
    [MovedFrom(True, "UnityEditor", "UnityEditor", null)]
    public class GridSelection : ScriptableObject
    {
        public GridSelection();

        public static bool active { get; }
        public static BoundsInt position { get; set; }
        public static GameObject target { get; }
        public static Grid grid { get; }

        public static event Action gridSelectionChanged;

        public static void Select(UnityEngine.Object target, BoundsInt bounds);
        public static void Clear();
    }
}
using UnityEngine;
using UnityEngine.Tilemaps;

namespace UnityEditor.Tilemaps
{
    public class TileUtility
    {
        public TileUtility();

        public static Tile CreateDefaultTile();
        [CreateTileFromPalette]
        public static TileBase DefaultTile(Sprite sprite);
    }
}
-------- {Unity.RenderPipelines.Universal.Shaders(D:\Documents\GitHub\Rogue-like-game-i-guess\The game is liar\Library\ScriptAssemblies\Unity.RenderPipelines.Universal.Shaders.dll)}:    0 --------
-------- {Unity.Recorder.Base(D:\Documents\GitHub\Rogue-like-game-i-guess\The game is liar\Library\ScriptAssemblies\Unity.Recorder.Base.dll)}:    0 --------
using System;

namespace Unity.Media
{
    public class RefHandle<T> : IDisposable where T : class
    {
        public RefHandle();
        public RefHandle(T target);

        ~RefHandle();

        public bool IsCreated { get; }
        public T Target { get; set; }

        public void Dispose();
        public void Dispose(bool disposing);
    }
}
-------- {Unity.RenderPipelines.Universal.Runtime(D:\Documents\GitHub\Rogue-like-game-i-guess\The game is liar\Library\ScriptAssemblies\Unity.RenderPipelines.Universal.Runtime.dll)}:  258 --------
using System;

namespace UnityEngine.Rendering.LWRP
{
    [Obsolete("LWRP -> Universal (UnityUpgradable) -> UnityEngine.Rendering.Universal.UniversalRenderPipelineAsset", True)]
    public class LightweightRenderPipelineAsset
    {
        public LightweightRenderPipelineAsset();
    }
}
using System;

namespace UnityEngine.Rendering.LWRP
{
    [Obsolete("LWRP -> Universal (UnityUpgradable) -> UnityEngine.Rendering.Universal.UniversalRenderPipelineEditorResources", True)]
    public class LightweightRenderPipelineEditorResources
    {
        public LightweightRenderPipelineEditorResources();
    }
}
using System;

namespace UnityEngine.Rendering.LWRP
{
    [Obsolete("LWRP -> Universal (UnityUpgradable) -> UnityEngine.Rendering.Universal.UniversalAdditionalCameraData", True)]
    public class LWRPAdditionalCameraData
    {
        public LWRPAdditionalCameraData();
    }
}
using System;

namespace UnityEngine.Rendering.LWRP
{
    [Obsolete("LWRP -> Universal (UnityUpgradable) -> UnityEngine.Rendering.Universal.UniversalAdditionalLightData", True)]
    public class LWRPAdditionalLightData
    {
        public LWRPAdditionalLightData();
    }
}
using System;

namespace UnityEngine.Rendering.LWRP
{
    [Obsolete("LWRP -> Universal (UnityUpgradable) -> UnityEngine.Rendering.Universal.UniversalRenderPipeline", True)]
    public class LightweightRenderPipeline
    {
        public LightweightRenderPipeline(LightweightRenderPipelineAsset asset);
    }
}
namespace UnityEngine.Rendering.Universal
{
    public static class ComponentUtility
    {
        public static bool IsUniversalCamera(Camera camera);
        public static bool IsUniversalLight(Light light);
    }
}
namespace UnityEngine.Rendering.Universal
{
    public class PostProcessData : ScriptableObject
    {
        public ShaderResources shaders;
        public TextureResources textures;

        public PostProcessData();

        [ReloadGroup]
        public sealed class ShaderResources
        {
            [Reload("Shaders/PostProcessing/StopNaN.shader", Root)]
            public Shader stopNanPS;
            [Reload("Shaders/PostProcessing/SubpixelMorphologicalAntialiasing.shader", Root)]
            public Shader subpixelMorphologicalAntialiasingPS;
            [Reload("Shaders/PostProcessing/GaussianDepthOfField.shader", Root)]
            public Shader gaussianDepthOfFieldPS;
            [Reload("Shaders/PostProcessing/BokehDepthOfField.shader", Root)]
            public Shader bokehDepthOfFieldPS;
            [Reload("Shaders/PostProcessing/CameraMotionBlur.shader", Root)]
            public Shader cameraMotionBlurPS;
            [Reload("Shaders/PostProcessing/PaniniProjection.shader", Root)]
            public Shader paniniProjectionPS;
            [Reload("Shaders/PostProcessing/LutBuilderLdr.shader", Root)]
            public Shader lutBuilderLdrPS;
            [Reload("Shaders/PostProcessing/LutBuilderHdr.shader", Root)]
            public Shader lutBuilderHdrPS;
            [Reload("Shaders/PostProcessing/Bloom.shader", Root)]
            public Shader bloomPS;
            [Reload("Shaders/PostProcessing/UberPost.shader", Root)]
            public Shader uberPostPS;
            [Reload("Shaders/PostProcessing/FinalPost.shader", Root)]
            public Shader finalPostPassPS;

            public ShaderResources();
        }
        [ReloadGroup]
        public sealed class TextureResources
        {
            [Reload("Textures/BlueNoise16/L/LDR_LLL1_{0}.png", 0, 32, Root)]
            public Texture2D[] blueNoise16LTex;
            [Reload(new[] {"Textures/FilmGrain/Thin01.png", "Textures/FilmGrain/Thin02.png", "Textures/FilmGrain/Medium01.png", "Textures/FilmGrain/Medium02.png", "Textures/FilmGrain/Medium03.png", "Textures/FilmGrain/Medium04.png", "Textures/FilmGrain/Medium05.png", "Textures/FilmGrain/Medium06.png", "Textures/FilmGrain/Large01.png", "Textures/FilmGrain/Large02.png" }, Root)]
            public Texture2D[] filmGrainTex;
            [Reload("Textures/SMAA/AreaTex.tga", Root)]
            public Texture2D smaaAreaTex;
            [Reload("Textures/SMAA/SearchTex.tga", Root)]
            public Texture2D smaaSearchTex;

            public TextureResources();
        }
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering.Universal
{
    [MovedFrom("UnityEngine.Rendering.LWRP")]
    public class StencilStateData
    {
        public bool overrideStencilState;
        public int stencilReference;
        public CompareFunction stencilCompareFunction;
        public StencilOp passOperation;
        public StencilOp failOperation;
        public StencilOp zFailOperation;

        public StencilStateData();
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering.Universal
{
    [MovedFrom("UnityEngine.Rendering.LWRP")]
    public enum ShadowQuality
    {
        Disabled = 0,
        HardShadows = 1,
        SoftShadows = 2
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering.Universal
{
    [MovedFrom("UnityEngine.Rendering.LWRP")]
    public enum ShadowResolution
    {
        _256 = 256,
        _512 = 512,
        _1024 = 1024,
        _2048 = 2048,
        _4096 = 4096
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering.Universal
{
    [MovedFrom("UnityEngine.Rendering.LWRP")]
    public enum MsaaQuality
    {
        Disabled = 1,
        _2x = 2,
        _4x = 4,
        _8x = 8
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering.Universal
{
    [MovedFrom("UnityEngine.Rendering.LWRP")]
    public enum Downsampling
    {
        None = 0,
        _2xBilinear = 1,
        _4xBox = 2,
        _4xBilinear = 3
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering.Universal
{
    [MovedFrom("UnityEngine.Rendering.LWRP")]
    public enum LightRenderingMode
    {
        Disabled = 0,
        PerVertex = 2,
        PerPixel = 1
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering.Universal
{
    [MovedFrom("UnityEngine.Rendering.LWRP")]
    public enum ShaderVariantLogLevel
    {
        Disabled = 0,
        OnlyUniversalRPShaders = 1,
        AllShaders = 2
    }
}
using System;

namespace UnityEngine.Rendering.Universal
{
    [Obsolete("PipelineDebugLevel is unused and has no effect.", False)]
    public enum PipelineDebugLevel
    {
        Disabled = 0,
        Profiling = 1
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering.Universal
{
    [MovedFrom("UnityEngine.Rendering.LWRP")]
    public enum RendererType
    {
        Custom = 0,
        ForwardRenderer = 1,
        _2DRenderer = 2
    }
}
namespace UnityEngine.Rendering.Universal
{
    public enum ColorGradingMode
    {
        LowDynamicRange = 0,
        HighDynamicRange = 1
    }
}
using System;

namespace UnityEngine.Rendering.Universal
{
    [ExcludeFromPreset]
    public class UniversalRenderPipelineAsset : RenderPipelineAsset, ISerializationCallbackReceiver
    {
        public const int k_MinLutSize = 16;
        public const int k_MaxLutSize = 65;
        public static readonly string packagePath;
        public static readonly string editorResourcesGUID;

        public UniversalRenderPipelineAsset();

        public ScriptableRenderer scriptableRenderer { get; }
        public bool supportsCameraDepthTexture { get; set; }
        public bool supportsCameraOpaqueTexture { get; set; }
        public Downsampling opaqueDownsampling { get; }
        public bool supportsTerrainHoles { get; }
        public bool supportsHDR { get; set; }
        public int msaaSampleCount { get; set; }
        public float renderScale { get; set; }
        public LightRenderingMode mainLightRenderingMode { get; }
        public bool supportsMainLightShadows { get; }
        public int mainLightShadowmapResolution { get; }
        public LightRenderingMode additionalLightsRenderingMode { get; }
        public int maxAdditionalLightsCount { get; set; }
        public bool supportsAdditionalLightShadows { get; }
        public int additionalLightsShadowmapResolution { get; }
        public float shadowDistance { get; set; }
        public int shadowCascadeCount { get; set; }
        public float cascade2Split { get; }
        public Vector2 cascade3Split { get; }
        public Vector3 cascade4Split { get; }
        public float shadowDepthBias { get; set; }
        public float shadowNormalBias { get; set; }
        public bool supportsSoftShadows { get; }
        public bool supportsDynamicBatching { get; set; }
        public bool supportsMixedLighting { get; }
        public ShaderVariantLogLevel shaderVariantLogLevel { get; set; }
        [Obsolete("PipelineDebugLevel is deprecated. Calling debugLevel is not necessary.", False)]
        public PipelineDebugLevel debugLevel { get; }
        public bool useSRPBatcher { get; set; }
        public ColorGradingMode colorGradingMode { get; set; }
        public int colorGradingLutSize { get; set; }
        public bool useAdaptivePerformance { get; set; }
        public override Material defaultMaterial { get; }
        public override Material defaultParticleMaterial { get; }
        public override Material defaultLineMaterial { get; }
        public override Material defaultTerrainMaterial { get; }
        public override Material defaultUIMaterial { get; }
        public override Material defaultUIOverdrawMaterial { get; }
        public override Material defaultUIETC1SupportedMaterial { get; }
        public override Material default2DMaterial { get; }
        public override Shader defaultShader { get; }
        public override Shader autodeskInteractiveShader { get; }
        public override Shader autodeskInteractiveTransparentShader { get; }
        public override Shader autodeskInteractiveMaskedShader { get; }
        public override Shader terrainDetailLitShader { get; }
        public override Shader terrainDetailGrassShader { get; }
        public override Shader terrainDetailGrassBillboardShader { get; }
        public override Shader defaultSpeedTree7Shader { get; }
        public override Shader defaultSpeedTree8Shader { get; }
        [Obsolete("This is obsolete, please use shadowCascadeCount instead.", False)]
        public ShadowCascadesOption shadowCascadeOption { get; set; }

        public static UniversalRenderPipelineAsset Create(ScriptableRendererData rendererData = null);
        public ScriptableRendererData LoadBuiltinRendererData(RendererType type = ForwardRenderer);
        protected override RenderPipeline CreatePipeline();
        protected override void OnValidate();
        protected override void OnDisable();
        public ScriptableRenderer GetRenderer(int index);
        public void OnBeforeSerialize();
        public void OnAfterDeserialize();
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering.Universal
{
    [MovedFrom("UnityEngine.Rendering.LWRP")]
    public class UniversalRenderPipelineEditorResources : ScriptableObject
    {
        public ShaderResources shaders;
        public MaterialResources materials;

        public UniversalRenderPipelineEditorResources();

        [ReloadGroup]
        public sealed class ShaderResources
        {
            [Reload("Shaders/Autodesk Interactive/Autodesk Interactive.shadergraph", Root)]
            public Shader autodeskInteractivePS;
            [Reload("Shaders/Autodesk Interactive/Autodesk Interactive Transparent.shadergraph", Root)]
            public Shader autodeskInteractiveTransparentPS;
            [Reload("Shaders/Autodesk Interactive/Autodesk Interactive Masked.shadergraph", Root)]
            public Shader autodeskInteractiveMaskedPS;
            [Reload("Shaders/Terrain/TerrainDetailLit.shader", Root)]
            public Shader terrainDetailLitPS;
            [Reload("Shaders/Terrain/WavingGrass.shader", Root)]
            public Shader terrainDetailGrassPS;
            [Reload("Shaders/Terrain/WavingGrassBillboard.shader", Root)]
            public Shader terrainDetailGrassBillboardPS;
            [Reload("Shaders/Nature/SpeedTree7.shader", Root)]
            public Shader defaultSpeedTree7PS;
            [Reload("Shaders/Nature/SpeedTree8.shader", Root)]
            public Shader defaultSpeedTree8PS;

            public ShaderResources();
        }
        [ReloadGroup]
        public sealed class MaterialResources
        {
            [Reload("Runtime/Materials/Lit.mat", Root)]
            public Material lit;
            [Reload("Runtime/Materials/ParticlesLit.mat", Root)]
            public Material particleLit;
            [Reload("Runtime/Materials/TerrainLit.mat", Root)]
            public Material terrainLit;

            public MaterialResources();
        }
    }
}
namespace UnityEngine.Rendering.Universal
{
    public class XRSystemData : ScriptableObject
    {
        public ShaderResources shaders;

        public XRSystemData();

        [ReloadGroup]
        public sealed class ShaderResources
        {
            [Reload("Shaders/XR/XROcclusionMesh.shader", Root)]
            public Shader xrOcclusionMeshPS;
            [Reload("Shaders/XR/XRMirrorView.shader", Root)]
            public Shader xrMirrorViewPS;

            public ShaderResources();
        }
    }
}
using System.Collections.Generic;
using System.ComponentModel;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering.Universal
{
    [MovedFrom("UnityEngine.Rendering.LWRP")]
    public abstract class ScriptableRenderPass
    {
        public ScriptableRenderPass();

        public RenderPassEvent renderPassEvent { get; set; }
        public RenderTargetIdentifier[] colorAttachments { get; }
        public RenderTargetIdentifier colorAttachment { get; }
        public RenderTargetIdentifier depthAttachment { get; }
        public ScriptableRenderPassInput input { get; }
        public ClearFlag clearFlag { get; }
        public Color clearColor { get; }
        protected internal ProfilingSampler profilingSampler { get; set; }

        [EditorBrowsable(Never)]
        public virtual void FrameCleanup(CommandBuffer cmd);
        public void ConfigureInput(ScriptableRenderPassInput passInput);
        public void ConfigureTarget(RenderTargetIdentifier colorAttachment, RenderTargetIdentifier depthAttachment);
        public void ConfigureTarget(RenderTargetIdentifier[] colorAttachments, RenderTargetIdentifier depthAttachment);
        public void ConfigureTarget(RenderTargetIdentifier colorAttachment);
        public void ConfigureTarget(RenderTargetIdentifier[] colorAttachments);
        public void ConfigureClear(ClearFlag clearFlag, Color clearColor);
        public virtual void OnCameraSetup(CommandBuffer cmd, ref RenderingData renderingData);
        public virtual void Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor);
        public virtual void OnCameraCleanup(CommandBuffer cmd);
        public virtual void OnFinishCameraStackRendering(CommandBuffer cmd);
        public abstract void Execute(ScriptableRenderContext context, ref RenderingData renderingData);
        public void Blit(CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, Material material = null, int passIndex = 0);
        public DrawingSettings CreateDrawingSettings(ShaderTagId shaderTagId, ref RenderingData renderingData, SortingCriteria sortingCriteria);
        public DrawingSettings CreateDrawingSettings(List<ShaderTagId> shaderTagIdList, ref RenderingData renderingData, SortingCriteria sortingCriteria);

        public static bool operator <(ScriptableRenderPass lhs, ScriptableRenderPass rhs);
        public static bool operator >(ScriptableRenderPass lhs, ScriptableRenderPass rhs);
    }
}
using System;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering.Universal
{
    [Obsolete("This is obsolete, please use shadowCascadeCount instead.", False)]
    [MovedFrom("UnityEngine.Rendering.LWRP")]
    public enum ShadowCascadesOption
    {
        NoCascades = 0,
        TwoCascades = 1,
        FourCascades = 2
    }
}
using System;
using System.Collections.Generic;
using System.ComponentModel;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering.Universal
{
    [MovedFrom("UnityEngine.Rendering.LWRP")]
    public abstract class ScriptableRenderer : IDisposable
    {
        public ScriptableRenderer(ScriptableRendererData data);

        [Obsolete("cameraDepth has been renamed to cameraDepthTarget. (UnityUpgradable) -> cameraDepthTarget")]
        [EditorBrowsable(Never)]
        public RenderTargetIdentifier cameraDepth { get; }
        protected ProfilingSampler profilingExecute { get; set; }
        public RenderTargetIdentifier cameraColorTarget { get; }
        public RenderTargetIdentifier cameraDepthTarget { get; }
        protected List<ScriptableRendererFeature> rendererFeatures { get; }
        protected List<ScriptableRenderPass> activeRenderPassQueue { get; }
        public RenderingFeatures supportedRenderingFeatures { get; set; }
        public GraphicsDeviceType[] unsupportedGraphicsDeviceTypes { get; set; }

        public static void SetCameraMatrices(CommandBuffer cmd, ref CameraData cameraData, bool setInverseMatrices);
        public void Dispose();
        protected virtual void Dispose(bool disposing);
        public void ConfigureCameraTarget(RenderTargetIdentifier colorTarget, RenderTargetIdentifier depthTarget);
        public abstract void Setup(ScriptableRenderContext context, ref RenderingData renderingData);
        public virtual void SetupLights(ScriptableRenderContext context, ref RenderingData renderingData);
        public virtual void SetupCullingParameters(ref ScriptableCullingParameters cullingParameters, ref CameraData cameraData);
        public virtual void FinishRendering(CommandBuffer cmd);
        public void Execute(ScriptableRenderContext context, ref RenderingData renderingData);
        public void EnqueuePass(ScriptableRenderPass pass);
        protected static ClearFlag GetCameraClearFlag(ref CameraData cameraData);
        protected void AddRenderPasses(ref RenderingData renderingData);

        public class RenderingFeatures
        {
            public RenderingFeatures();

            public bool cameraStacking { get; set; }
            public bool msaa { get; set; }
        }
    }
}
namespace UnityEngine.Rendering.Universal
{
    public enum RenderingMode
    {
        Forward = 0,
        Deferred = 1
    }
}
namespace UnityEngine.Rendering.Universal
{
    public sealed class ForwardRenderer : ScriptableRenderer
    {
        public ForwardRenderer(ForwardRendererData data);

        protected override void Dispose(bool disposing);
        public override void Setup(ScriptableRenderContext context, ref RenderingData renderingData);
        public override void SetupLights(ScriptableRenderContext context, ref RenderingData renderingData);
        public override void SetupCullingParameters(ref ScriptableCullingParameters cullingParameters, ref CameraData cameraData);
        public override void FinishRendering(CommandBuffer cmd);
    }
}
using System.ComponentModel;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering.Universal
{
    [ReloadGroup]
    [ExcludeFromPreset]
    [MovedFrom("UnityEngine.Rendering.LWRP")]
    public class ForwardRendererData : ScriptableRendererData
    {
        [Reload("Runtime/Data/PostProcessData.asset", Root)]
        public PostProcessData postProcessData;
        [Reload("Runtime/Data/XRSystemData.asset", Root)]
        public XRSystemData xrSystemData;
        public ShaderResources shaders;

        public ForwardRendererData();

        public LayerMask opaqueLayerMask { get; set; }
        public LayerMask transparentLayerMask { get; set; }
        public StencilStateData defaultStencilState { get; set; }
        public bool shadowTransparentReceive { get; set; }
        public RenderingMode renderingMode { get; set; }
        public bool accurateGbufferNormals { get; set; }

        protected override ScriptableRenderer Create();
        protected override void OnEnable();

        [ReloadGroup]
        public sealed class ShaderResources
        {
            [Reload("Shaders/Utils/Blit.shader", Root)]
            public Shader blitPS;
            [Reload("Shaders/Utils/CopyDepth.shader", Root)]
            public Shader copyDepthPS;
            [Reload("Shaders/Utils/ScreenSpaceShadows.shader", Root)]
            public Shader screenSpaceShadowPS;
            [Reload("Shaders/Utils/Sampling.shader", Root)]
            public Shader samplingPS;
            [EditorBrowsable(Never)]
            public Shader tileDepthInfoPS;
            [EditorBrowsable(Never)]
            public Shader tileDeferredPS;
            [Reload("Shaders/Utils/StencilDeferred.shader", Root)]
            public Shader stencilDeferredPS;
            [Reload("Shaders/Utils/FallbackError.shader", Root)]
            public Shader fallbackErrorPS;
            [Reload("Shaders/Utils/MaterialError.shader", Root)]
            public Shader materialErrorPS;

            public ShaderResources();
        }
    }
}
namespace UnityEngine.Rendering.Universal
{
    [VolumeComponentMenu("Post-processing/Bloom")]
    public sealed class Bloom : VolumeComponent, IPostProcessComponent
    {
        [Tooltip("Filters out pixels under this level of brightness. Value is in gamma-space.")]
        public MinFloatParameter threshold;
        [Tooltip("Strength of the bloom filter.")]
        public MinFloatParameter intensity;
        [Tooltip("Changes the extent of veiling effects.")]
        public ClampedFloatParameter scatter;
        [Tooltip("Clamps pixels to control the bloom amount.")]
        public MinFloatParameter clamp;
        [Tooltip("Global tint of the bloom filter.")]
        public ColorParameter tint;
        [Tooltip("Use bicubic sampling instead of bilinear sampling for the upsampling passes. This is slightly more expensive but helps getting smoother visuals.")]
        public BoolParameter highQualityFiltering;
        [Tooltip("The number of final iterations to skip in the effect processing sequence.")]
        public ClampedIntParameter skipIterations;
        [Tooltip("Dirtiness texture to add smudges or dust to the bloom effect.")]
        public TextureParameter dirtTexture;
        [Tooltip("Amount of dirtiness.")]
        public MinFloatParameter dirtIntensity;

        public Bloom();

        public bool IsActive();
        public bool IsTileCompatible();
    }
}
namespace UnityEngine.Rendering.Universal
{
    [VolumeComponentMenu("Post-processing/Channel Mixer")]
    public sealed class ChannelMixer : VolumeComponent, IPostProcessComponent
    {
        [Tooltip("Modify influence of the red channel in the overall mix.")]
        public ClampedFloatParameter redOutRedIn;
        [Tooltip("Modify influence of the green channel in the overall mix.")]
        public ClampedFloatParameter redOutGreenIn;
        [Tooltip("Modify influence of the blue channel in the overall mix.")]
        public ClampedFloatParameter redOutBlueIn;
        [Tooltip("Modify influence of the red channel in the overall mix.")]
        public ClampedFloatParameter greenOutRedIn;
        [Tooltip("Modify influence of the green channel in the overall mix.")]
        public ClampedFloatParameter greenOutGreenIn;
        [Tooltip("Modify influence of the blue channel in the overall mix.")]
        public ClampedFloatParameter greenOutBlueIn;
        [Tooltip("Modify influence of the red channel in the overall mix.")]
        public ClampedFloatParameter blueOutRedIn;
        [Tooltip("Modify influence of the green channel in the overall mix.")]
        public ClampedFloatParameter blueOutGreenIn;
        [Tooltip("Modify influence of the blue channel in the overall mix.")]
        public ClampedFloatParameter blueOutBlueIn;

        public ChannelMixer();

        public bool IsActive();
        public bool IsTileCompatible();
    }
}
namespace UnityEngine.Rendering.Universal
{
    [VolumeComponentMenu("Post-processing/Chromatic Aberration")]
    public sealed class ChromaticAberration : VolumeComponent, IPostProcessComponent
    {
        [Tooltip("Amount of tangential distortion.")]
        public ClampedFloatParameter intensity;

        public ChromaticAberration();

        public bool IsActive();
        public bool IsTileCompatible();
    }
}
namespace UnityEngine.Rendering.Universal
{
    [VolumeComponentMenu("Post-processing/Color Adjustments")]
    public sealed class ColorAdjustments : VolumeComponent, IPostProcessComponent
    {
        [Tooltip("Adjusts the overall exposure of the scene in EV100. This is applied after HDR effect and right before tonemapping so it won't affect previous effects in the chain.")]
        public FloatParameter postExposure;
        [Tooltip("Expands or shrinks the overall range of tonal values.")]
        public ClampedFloatParameter contrast;
        [Tooltip("Tint the render by multiplying a color.")]
        public ColorParameter colorFilter;
        [Tooltip("Shift the hue of all colors.")]
        public ClampedFloatParameter hueShift;
        [Tooltip("Pushes the intensity of all colors.")]
        public ClampedFloatParameter saturation;

        public ColorAdjustments();

        public bool IsActive();
        public bool IsTileCompatible();
    }
}
namespace UnityEngine.Rendering.Universal
{
    [VolumeComponentMenu("Post-processing/Color Curves")]
    public sealed class ColorCurves : VolumeComponent, IPostProcessComponent
    {
        public TextureCurveParameter master;
        public TextureCurveParameter red;
        public TextureCurveParameter green;
        public TextureCurveParameter blue;
        public TextureCurveParameter hueVsHue;
        public TextureCurveParameter hueVsSat;
        public TextureCurveParameter satVsSat;
        public TextureCurveParameter lumVsSat;

        public ColorCurves();

        public bool IsActive();
        public bool IsTileCompatible();
    }
}
namespace UnityEngine.Rendering.Universal
{
    [VolumeComponentMenu("Post-processing/Color Lookup")]
    public sealed class ColorLookup : VolumeComponent, IPostProcessComponent
    {
        [Tooltip("A custom 2D texture lookup table to apply.")]
        public TextureParameter texture;
        [Tooltip("How much of the lookup texture will contribute to the color grading effect.")]
        public ClampedFloatParameter contribution;

        public ColorLookup();

        public bool IsActive();
        public bool IsTileCompatible();
        public bool ValidateLUT();
    }
}
namespace UnityEngine.Rendering.Universal
{
    public enum DepthOfFieldMode
    {
        Off = 0,
        Gaussian = 1,
        Bokeh = 2
    }
}
namespace UnityEngine.Rendering.Universal
{
    [VolumeComponentMenu("Post-processing/Depth Of Field")]
    public sealed class DepthOfField : VolumeComponent, IPostProcessComponent
    {
        [Tooltip("Use \"Gaussian\" for a faster but non physical depth of field; \"Bokeh\" for a more realistic but slower depth of field.")]
        public DepthOfFieldModeParameter mode;
        [Tooltip("The distance at which the blurring will start.")]
        public MinFloatParameter gaussianStart;
        [Tooltip("The distance at which the blurring will reach its maximum radius.")]
        public MinFloatParameter gaussianEnd;
        [Tooltip("The maximum radius of the gaussian blur. Values above 1 may show under-sampling artifacts.")]
        public ClampedFloatParameter gaussianMaxRadius;
        [Tooltip("Use higher quality sampling to reduce flickering and improve the overall blur smoothness.")]
        public BoolParameter highQualitySampling;
        [Tooltip("The distance to the point of focus.")]
        public MinFloatParameter focusDistance;
        [Tooltip("The ratio of aperture (known as f-stop or f-number). The smaller the value is, the shallower the depth of field is.")]
        public ClampedFloatParameter aperture;
        [Tooltip("The distance between the lens and the film. The larger the value is, the shallower the depth of field is.")]
        public ClampedFloatParameter focalLength;
        [Tooltip("The number of aperture blades.")]
        public ClampedIntParameter bladeCount;
        [Tooltip("The curvature of aperture blades. The smaller the value is, the more visible aperture blades are. A value of 1 will make the bokeh perfectly circular.")]
        public ClampedFloatParameter bladeCurvature;
        [Tooltip("The rotation of aperture blades in degrees.")]
        public ClampedFloatParameter bladeRotation;

        public DepthOfField();

        public bool IsActive();
        public bool IsTileCompatible();
    }
}
namespace UnityEngine.Rendering.Universal
{
    public sealed class DepthOfFieldModeParameter : VolumeParameter<DepthOfFieldMode>
    {
        public DepthOfFieldModeParameter(DepthOfFieldMode value, bool overrideState = False);
    }
}
namespace UnityEngine.Rendering.Universal
{
    public enum FilmGrainLookup
    {
        Thin1 = 0,
        Thin2 = 1,
        Medium1 = 2,
        Medium2 = 3,
        Medium3 = 4,
        Medium4 = 5,
        Medium5 = 6,
        Medium6 = 7,
        Large01 = 8,
        Large02 = 9,
        Custom = 10
    }
}
namespace UnityEngine.Rendering.Universal
{
    [VolumeComponentMenu("Post-processing/FilmGrain")]
    public sealed class FilmGrain : VolumeComponent, IPostProcessComponent
    {
        [Tooltip("The type of grain to use. You can select a preset or provide your own texture by selecting Custom.")]
        public FilmGrainLookupParameter type;
        [Tooltip("Amount of vignetting on screen.")]
        public ClampedFloatParameter intensity;
        [Tooltip("Controls the noisiness response curve based on scene luminance. Higher values mean less noise in light areas.")]
        public ClampedFloatParameter response;
        [Tooltip("A tileable texture to use for the grain. The neutral value is 0.5 where no grain is applied.")]
        public NoInterpTextureParameter texture;

        public FilmGrain();

        public bool IsActive();
        public bool IsTileCompatible();
    }
}
namespace UnityEngine.Rendering.Universal
{
    public sealed class FilmGrainLookupParameter : VolumeParameter<FilmGrainLookup>
    {
        public FilmGrainLookupParameter(FilmGrainLookup value, bool overrideState = False);
    }
}
namespace UnityEngine.Rendering.Universal
{
    [VolumeComponentMenu("Post-processing/Lens Distortion")]
    public sealed class LensDistortion : VolumeComponent, IPostProcessComponent
    {
        [Tooltip("Total distortion amount.")]
        public ClampedFloatParameter intensity;
        [Tooltip("Intensity multiplier on X axis. Set it to 0 to disable distortion on this axis.")]
        public ClampedFloatParameter xMultiplier;
        [Tooltip("Intensity multiplier on Y axis. Set it to 0 to disable distortion on this axis.")]
        public ClampedFloatParameter yMultiplier;
        [Tooltip("Distortion center point.")]
        public Vector2Parameter center;
        [Tooltip("Global screen scaling.")]
        public ClampedFloatParameter scale;

        public LensDistortion();

        public bool IsActive();
        public bool IsTileCompatible();
    }
}
namespace UnityEngine.Rendering.Universal
{
    [VolumeComponentMenu("Post-processing/Lift, Gamma, Gain")]
    public sealed class LiftGammaGain : VolumeComponent, IPostProcessComponent
    {
        [Tooltip("Controls the darkest portions of the render.")]
        public Vector4Parameter lift;
        [Tooltip("Power function that controls mid-range tones.")]
        public Vector4Parameter gamma;
        [Tooltip("Controls the lightest portions of the render.")]
        public Vector4Parameter gain;

        public LiftGammaGain();

        public bool IsActive();
        public bool IsTileCompatible();
    }
}
namespace UnityEngine.Rendering.Universal
{
    public enum MotionBlurMode
    {
        CameraOnly = 0,
        CameraAndObjects = 1
    }
}
namespace UnityEngine.Rendering.Universal
{
    public enum MotionBlurQuality
    {
        Low = 0,
        Medium = 1,
        High = 2
    }
}
namespace UnityEngine.Rendering.Universal
{
    [VolumeComponentMenu("Post-processing/Motion Blur")]
    public sealed class MotionBlur : VolumeComponent, IPostProcessComponent
    {
        [Tooltip("The motion blur technique to use. If you don't need object motion blur, CameraOnly will result in better performance.")]
        public MotionBlurModeParameter mode;
        [Tooltip("The quality of the effect. Lower presets will result in better performance at the expense of visual quality.")]
        public MotionBlurQualityParameter quality;
        [Tooltip("The strength of the motion blur filter. Acts as a multiplier for velocities.")]
        public ClampedFloatParameter intensity;
        [Tooltip("Sets the maximum length, as a fraction of the screen's full resolution, that the velocity resulting from Camera rotation can have. Lower values will improve performance.")]
        public ClampedFloatParameter clamp;

        public MotionBlur();

        public bool IsActive();
        public bool IsTileCompatible();
    }
}
namespace UnityEngine.Rendering.Universal
{
    public sealed class MotionBlurModeParameter : VolumeParameter<MotionBlurMode>
    {
        public MotionBlurModeParameter(MotionBlurMode value, bool overrideState = False);
    }
}
namespace UnityEngine.Rendering.Universal
{
    public sealed class MotionBlurQualityParameter : VolumeParameter<MotionBlurQuality>
    {
        public MotionBlurQualityParameter(MotionBlurQuality value, bool overrideState = False);
    }
}
namespace UnityEngine.Rendering.Universal
{
    [VolumeComponentMenu("Post-processing/Panini Projection")]
    public sealed class PaniniProjection : VolumeComponent, IPostProcessComponent
    {
        [Tooltip("Panini projection distance.")]
        public ClampedFloatParameter distance;
        [Tooltip("Panini projection crop to fit.")]
        public ClampedFloatParameter cropToFit;

        public PaniniProjection();

        public bool IsActive();
        public bool IsTileCompatible();
    }
}
namespace UnityEngine.Rendering.Universal
{
    [VolumeComponentMenu("Post-processing/Shadows, Midtones, Highlights")]
    public sealed class ShadowsMidtonesHighlights : VolumeComponent, IPostProcessComponent
    {
        [Tooltip("Controls the darkest portions of the render.")]
        public Vector4Parameter shadows;
        [Tooltip("Power function that controls mid-range tones.")]
        public Vector4Parameter midtones;
        [Tooltip("Controls the lightest portions of the render.")]
        public Vector4Parameter highlights;
        [Tooltip("Start point of the transition between shadows and midtones.")]
        public MinFloatParameter shadowsStart;
        [Tooltip("End point of the transition between shadows and midtones.")]
        public MinFloatParameter shadowsEnd;
        [Tooltip("Start point of the transition between midtones and highlights.")]
        public MinFloatParameter highlightsStart;
        [Tooltip("End point of the transition between midtones and highlights.")]
        public MinFloatParameter highlightsEnd;

        public ShadowsMidtonesHighlights();

        public bool IsActive();
        public bool IsTileCompatible();
    }
}
namespace UnityEngine.Rendering.Universal
{
    [VolumeComponentMenu("Post-processing/Split Toning")]
    public sealed class SplitToning : VolumeComponent, IPostProcessComponent
    {
        [Tooltip("The color to use for shadows.")]
        public ColorParameter shadows;
        [Tooltip("The color to use for highlights.")]
        public ColorParameter highlights;
        [Tooltip("Balance between the colors in the highlights and shadows.")]
        public ClampedFloatParameter balance;

        public SplitToning();

        public bool IsActive();
        public bool IsTileCompatible();
    }
}
namespace UnityEngine.Rendering.Universal
{
    public enum TonemappingMode
    {
        None = 0,
        Neutral = 1,
        ACES = 2
    }
}
namespace UnityEngine.Rendering.Universal
{
    [VolumeComponentMenu("Post-processing/Tonemapping")]
    public sealed class Tonemapping : VolumeComponent, IPostProcessComponent
    {
        [Tooltip("Select a tonemapping algorithm to use for the color grading process.")]
        public TonemappingModeParameter mode;

        public Tonemapping();

        public bool IsActive();
        public bool IsTileCompatible();
    }
}
namespace UnityEngine.Rendering.Universal
{
    public sealed class TonemappingModeParameter : VolumeParameter<TonemappingMode>
    {
        public TonemappingModeParameter(TonemappingMode value, bool overrideState = False);
    }
}
namespace UnityEngine.Rendering.Universal
{
    [VolumeComponentMenu("Post-processing/Vignette")]
    public sealed class Vignette : VolumeComponent, IPostProcessComponent
    {
        [Tooltip("Vignette color.")]
        public ColorParameter color;
        [Tooltip("Sets the vignette center point (screen center is [0.5,0.5]).")]
        public Vector2Parameter center;
        [Tooltip("Amount of vignetting on screen.")]
        public ClampedFloatParameter intensity;
        [Tooltip("Smoothness of the vignette borders.")]
        public ClampedFloatParameter smoothness;
        [Tooltip("Should the vignette be perfectly round or be dependent on the current aspect ratio?")]
        public BoolParameter rounded;

        public Vignette();

        public bool IsActive();
        public bool IsTileCompatible();
    }
}
namespace UnityEngine.Rendering.Universal
{
    [VolumeComponentMenu("Post-processing/White Balance")]
    public sealed class WhiteBalance : VolumeComponent, IPostProcessComponent
    {
        [Tooltip("Sets the white balance to a custom color temperature.")]
        public ClampedFloatParameter temperature;
        [Tooltip("Sets the white balance to compensate for a green or magenta tint.")]
        public ClampedFloatParameter tint;

        public WhiteBalance();

        public bool IsActive();
        public bool IsTileCompatible();
    }
}
namespace UnityEngine.Rendering.Universal
{
    public class DrawSkyboxPass : ScriptableRenderPass
    {
        public DrawSkyboxPass(RenderPassEvent evt);

        public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData);
    }
}
namespace UnityEngine.Rendering.Universal
{
    public interface IPostProcessComponent
    {
        bool IsActive();
        bool IsTileCompatible();
    }
}
using System;

namespace UnityEngine.Rendering.Universal
{
    [Flags]
    public enum ScriptableRenderPassInput
    {
        None = 0,
        Depth = 1,
        Normal = 2,
        Color = 4
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering.Universal
{
    [MovedFrom("UnityEngine.Rendering.LWRP")]
    public enum RenderPassEvent
    {
        BeforeRendering = 0,
        BeforeRenderingShadows = 50,
        AfterRenderingShadows = 100,
        BeforeRenderingPrepasses = 150,
        AfterRenderingPrePasses = 200,
        BeforeRenderingOpaques = 250,
        AfterRenderingOpaques = 300,
        BeforeRenderingSkybox = 350,
        AfterRenderingSkybox = 400,
        BeforeRenderingTransparents = 450,
        AfterRenderingTransparents = 500,
        BeforeRenderingPostProcessing = 550,
        AfterRenderingPostProcessing = 600,
        AfterRendering = 1000
    }
}
namespace UnityEngine.Rendering.Universal
{
    public class XROcclusionMeshPass : ScriptableRenderPass
    {
        public XROcclusionMeshPass(RenderPassEvent evt);

        public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData);
    }
}
using System;

namespace UnityEngine.Rendering.Universal
{
    public static class PostProcessUtils
    {
        [Obsolete("This method is obsolete. Use ConfigureDithering override that takes camera pixel width and height instead.")]
        public static int ConfigureDithering(PostProcessData data, int index, Camera camera, Material material);
        public static int ConfigureDithering(PostProcessData data, int index, int cameraPixelWidth, int cameraPixelHeight, Material material);
        [Obsolete("This method is obsolete. Use ConfigureFilmGrain override that takes camera pixel width and height instead.")]
        public static void ConfigureFilmGrain(PostProcessData data, FilmGrain settings, Camera camera, Material material);
        public static void ConfigureFilmGrain(PostProcessData data, FilmGrain settings, int cameraPixelWidth, int cameraPixelHeight, Material material);
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering.Universal
{
    [MovedFrom("UnityEngine.Rendering.LWRP")]
    public struct RenderTargetHandle
    {
        public static readonly RenderTargetHandle CameraTarget;

        public RenderTargetHandle(RenderTargetIdentifier renderTargetIdentifier);

        public int id { get; set; }

        public void Init(string shaderProperty);
        public void Init(RenderTargetIdentifier renderTargetIdentifier);
        public RenderTargetIdentifier Identifier();
        public bool HasInternalRenderTargetId();
        public bool Equals(RenderTargetHandle other);
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static bool operator ==(RenderTargetHandle c1, RenderTargetHandle c2);
        public static bool operator !=(RenderTargetHandle c1, RenderTargetHandle c2);
    }
}
using UnityEngine.Experimental.Rendering;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering.Universal
{
    [MovedFrom("UnityEngine.Rendering.LWRP")]
    public static class RenderingUtils
    {
        public static Mesh fullscreenMesh { get; }

        public static void SetViewAndProjectionMatrices(CommandBuffer cmd, Matrix4x4 viewMatrix, Matrix4x4 projectionMatrix, bool setInverseMatrices);
        public static bool SupportsRenderTextureFormat(RenderTextureFormat format);
        public static bool SupportsGraphicsFormat(GraphicsFormat format, FormatUsage usage);
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering.Universal
{
    [MovedFrom("UnityEngine.Rendering.LWRP")]
    public enum SampleCount
    {
        One = 1,
        Two = 2,
        Four = 4
    }
}
using System.Collections.Generic;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering.Universal
{
    [MovedFrom("UnityEngine.Rendering.LWRP")]
    public abstract class ScriptableRendererData : ScriptableObject
    {
        protected ScriptableRendererData();

        public List<ScriptableRendererFeature> rendererFeatures { get; }

        protected abstract ScriptableRenderer Create();
        public void SetDirty();
        protected virtual void OnValidate();
        protected virtual void OnEnable();
    }
}
using System;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering.Universal
{
    [ExcludeFromPreset]
    [MovedFrom("UnityEngine.Rendering.LWRP")]
    public abstract class ScriptableRendererFeature : ScriptableObject, IDisposable
    {
        protected ScriptableRendererFeature();

        public bool isActive { get; }

        public abstract void Create();
        public abstract void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData);
        public void SetActive(bool active);
        public void Dispose();
        protected virtual void Dispose(bool disposing);
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering.Universal
{
    [MovedFrom("UnityEngine.Rendering.LWRP")]
    public enum ShaderPathID
    {
        Lit = 0,
        SimpleLit = 1,
        Unlit = 2,
        TerrainLit = 3,
        ParticlesLit = 4,
        ParticlesSimpleLit = 5,
        ParticlesUnlit = 6,
        BakedLit = 7,
        SpeedTree7 = 8,
        SpeedTree7Billboard = 9,
        SpeedTree8 = 10
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering.Universal
{
    [MovedFrom("UnityEngine.Rendering.LWRP")]
    public static class ShaderUtils
    {
        public static string GetShaderPath(ShaderPathID id);
        public static ShaderPathID GetEnumFromPath(string path);
        public static bool IsLWShader(Shader shader);
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering.Universal
{
    [MovedFrom("UnityEngine.Rendering.LWRP")]
    public struct ShadowSliceData
    {
        public Matrix4x4 viewMatrix;
        public Matrix4x4 projectionMatrix;
        public Matrix4x4 shadowTransform;
        public int offsetX;
        public int offsetY;
        public int resolution;

        public void Clear();
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering.Universal
{
    [MovedFrom("UnityEngine.Rendering.LWRP")]
    public static class ShadowUtils
    {
        public static bool ExtractDirectionalLightMatrix(ref CullingResults cullResults, ref ShadowData shadowData, int shadowLightIndex, int cascadeIndex, int shadowmapWidth, int shadowmapHeight, int shadowResolution, float shadowNearPlane, out Vector4 cascadeSplitDistance, out ShadowSliceData shadowSliceData, out Matrix4x4 viewMatrix, out Matrix4x4 projMatrix);
        public static bool ExtractSpotLightMatrix(ref CullingResults cullResults, ref ShadowData shadowData, int shadowLightIndex, out Matrix4x4 shadowMatrix, out Matrix4x4 viewMatrix, out Matrix4x4 projMatrix);
        public static void RenderShadowSlice(CommandBuffer cmd, ref ScriptableRenderContext context, ref ShadowSliceData shadowSliceData, ref ShadowDrawingSettings settings, Matrix4x4 proj, Matrix4x4 view);
        public static void RenderShadowSlice(CommandBuffer cmd, ref ScriptableRenderContext context, ref ShadowSliceData shadowSliceData, ref ShadowDrawingSettings settings);
        public static int GetMaxTileResolutionInAtlas(int atlasWidth, int atlasHeight, int tileCount);
        public static void ApplySliceTransform(ref ShadowSliceData shadowSliceData, int atlasWidth, int atlasHeight);
        public static Vector4 GetShadowBias(ref VisibleLight shadowLight, int shadowLightIndex, ref ShadowData shadowData, Matrix4x4 lightProjectionMatrix, float shadowResolution);
        public static void SetupShadowCasterConstantBuffer(CommandBuffer cmd, ref VisibleLight shadowLight, Vector4 shadowBias);
        public static RenderTexture GetTemporaryShadowTexture(int width, int height, int bits);
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering.Universal
{
    [MovedFrom("UnityEngine.Rendering.LWRP")]
    public enum CameraOverrideOption
    {
        Off = 0,
        On = 1,
        UsePipelineSettings = 2
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering.Universal
{
    [MovedFrom("UnityEngine.Rendering.LWRP")]
    public enum RendererOverrideOption
    {
        Custom = 0,
        UsePipelineSettings = 1
    }
}
namespace UnityEngine.Rendering.Universal
{
    public enum AntialiasingMode
    {
        None = 0,
        FastApproximateAntialiasing = 1,
        SubpixelMorphologicalAntiAliasing = 2
    }
}
namespace UnityEngine.Rendering.Universal
{
    public enum CameraRenderType
    {
        Base = 0,
        Overlay = 1
    }
}
namespace UnityEngine.Rendering.Universal
{
    public enum AntialiasingQuality
    {
        Low = 0,
        Medium = 1,
        High = 2
    }
}
namespace UnityEngine.Rendering.Universal
{
    public static class CameraExtensions
    {
        public static UniversalAdditionalCameraData GetUniversalAdditionalCameraData(this Camera camera);
    }
}
using System.Collections.Generic;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering.Universal
{
    [DisallowMultipleComponent]
    [RequireComponent(typeof(Camera))]
    [ImageEffectAllowedInSceneView]
    [MovedFrom("UnityEngine.Rendering.LWRP")]
    public class UniversalAdditionalCameraData : MonoBehaviour, ISerializationCallbackReceiver
    {
        public UniversalAdditionalCameraData();

        public float version { get; }
        public bool renderShadows { get; set; }
        public CameraOverrideOption requiresDepthOption { get; set; }
        public CameraOverrideOption requiresColorOption { get; set; }
        public CameraRenderType renderType { get; set; }
        public List<Camera> cameraStack { get; }
        public bool clearDepth { get; }
        public bool requiresDepthTexture { get; set; }
        public bool requiresColorTexture { get; set; }
        public ScriptableRenderer scriptableRenderer { get; }
        public LayerMask volumeLayerMask { get; set; }
        public Transform volumeTrigger { get; set; }
        public bool renderPostProcessing { get; set; }
        public AntialiasingMode antialiasing { get; set; }
        public AntialiasingQuality antialiasingQuality { get; set; }
        public bool stopNaN { get; set; }
        public bool dithering { get; set; }
        public bool allowXRRendering { get; set; }

        public void SetRenderer(int index);
        public void OnBeforeSerialize();
        public void OnAfterDeserialize();
        public void OnDrawGizmos();
    }
}
namespace UnityEngine.Rendering.Universal
{
    [DisallowMultipleComponent]
    [RequireComponent(typeof(Light))]
    public class UniversalAdditionalLightData : MonoBehaviour
    {
        public UniversalAdditionalLightData();

        public bool usePipelineSettings { get; set; }
    }
}
using System;
using Unity.Collections;

namespace UnityEngine.Rendering.Universal
{
    public sealed class UniversalRenderPipeline : RenderPipeline
    {
        public const string k_ShaderTagName = "UniversalPipeline";

        public UniversalRenderPipeline(UniversalRenderPipelineAsset asset);

        public static float maxShadowBias { get; }
        public static float minRenderScale { get; }
        public static float maxRenderScale { get; }
        public static int maxPerObjectLights { get; }
        public static int maxVisibleAdditionalLights { get; }
        public static UniversalRenderPipelineAsset asset { get; }

        protected override void Dispose(bool disposing);
        protected override void Render(ScriptableRenderContext renderContext, Camera[] cameras);
        public static void RenderSingleCamera(ScriptableRenderContext context, Camera camera);
        public static bool IsGameCamera(Camera camera);
        [Obsolete("Please use CameraData.xr.enabled instead.")]
        public static bool IsStereoEnabled(Camera camera);
        public static void GetLightAttenuationAndSpotDirection(LightType lightType, float lightRange, Matrix4x4 lightLocalToWorldMatrix, float spotAngle, float? innerSpotAngle, out Vector4 lightAttenuation, out Vector4 lightSpotDir);
        public static void InitializeLightConstants_Common(NativeArray<VisibleLight> lights, int lightIndex, out Vector4 lightPos, out Vector4 lightColor, out Vector4 lightAttenuation, out Vector4 lightSpotDir, out Vector4 lightOcclusionProbeChannel);
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering.Universal
{
    [MovedFrom("UnityEngine.Rendering.LWRP")]
    public enum MixedLightingSetup
    {
        None = 0,
        ShadowMask = 1,
        Subtractive = 2
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering.Universal
{
    [MovedFrom("UnityEngine.Rendering.LWRP")]
    public struct RenderingData
    {
        public CullingResults cullResults;
        public CameraData cameraData;
        public LightData lightData;
        public ShadowData shadowData;
        public PostProcessingData postProcessingData;
        public bool supportsDynamicBatching;
        public PerObjectData perObjectData;
        public bool postProcessingEnabled;
    }
}
using Unity.Collections;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering.Universal
{
    [MovedFrom("UnityEngine.Rendering.LWRP")]
    public struct LightData
    {
        public int mainLightIndex;
        public int additionalLightsCount;
        public int maxPerObjectAdditionalLightsCount;
        public NativeArray<VisibleLight> visibleLights;
        public bool shadeAdditionalLightsPerVertex;
        public bool supportsMixedLighting;
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering.Universal
{
    [MovedFrom("UnityEngine.Rendering.LWRP")]
    public struct CameraData
    {
        public Camera camera;
        public CameraRenderType renderType;
        public RenderTexture targetTexture;
        public RenderTextureDescriptor cameraTargetDescriptor;
        public float renderScale;
        public bool clearDepth;
        public CameraType cameraType;
        public bool isDefaultViewport;
        public bool isHdrEnabled;
        public bool requiresDepthTexture;
        public bool requiresOpaqueTexture;
        public bool xrRendering;
        public SortingCriteria defaultOpaqueSortFlags;
        [Obsolete("Please use xr.enabled instead.")]
        public bool isStereoEnabled;
        public float maxShadowDistance;
        public bool postProcessEnabled;
        public IEnumerator<Action<RenderTargetIdentifier, CommandBuffer>> captureActions;
        public LayerMask volumeLayerMask;
        public Transform volumeTrigger;
        public bool isStopNaNEnabled;
        public bool isDitheringEnabled;
        public AntialiasingMode antialiasing;
        public AntialiasingQuality antialiasingQuality;
        public ScriptableRenderer renderer;
        public bool resolveFinalTarget;

        public bool isSceneViewCamera { get; }
        public bool isPreviewCamera { get; }

        public Matrix4x4 GetViewMatrix(int viewIndex = 0);
        public Matrix4x4 GetProjectionMatrix(int viewIndex = 0);
        public Matrix4x4 GetGPUProjectionMatrix(int viewIndex = 0);
        public bool IsCameraProjectionMatrixFlipped();
    }
}
using System.Collections.Generic;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering.Universal
{
    [MovedFrom("UnityEngine.Rendering.LWRP")]
    public struct ShadowData
    {
        public bool supportsMainLightShadows;
        public bool requiresScreenSpaceShadowResolve;
        public int mainLightShadowmapWidth;
        public int mainLightShadowmapHeight;
        public int mainLightShadowCascadesCount;
        public Vector3 mainLightShadowCascadesSplit;
        public bool supportsAdditionalLightShadows;
        public int additionalLightsShadowmapWidth;
        public int additionalLightsShadowmapHeight;
        public bool supportsSoftShadows;
        public int shadowmapDepthBufferBits;
        public List<Vector4> bias;
    }
}
using Unity.Mathematics;

namespace UnityEngine.Rendering.Universal
{
    public struct PreTile
    {
        public float4 planeLeft;
        public float4 planeRight;
        public float4 planeBottom;
        public float4 planeTop;
    }
}
namespace UnityEngine.Rendering.Universal
{
    public struct TileData
    {
        public uint tileID;
        public uint listBitMask;
        public uint relLightOffset;
        public uint unused;
    }
}
namespace UnityEngine.Rendering.Universal
{
    public struct PunctualLightData
    {
        public Vector3 wsPos;
        public float radius;
        public Vector4 color;
        public Vector4 attenuation;
        public Vector3 spotDirection;
        public int lightIndex;
        public Vector4 occlusionProbeInfo;
    }
}
namespace UnityEngine.Rendering.Universal
{
    public struct PostProcessingData
    {
        public ColorGradingMode gradingMode;
        public int lutSize;
    }
}
namespace UnityEngine.Rendering.Universal
{
    public static class ShaderKeywordStrings
    {
        public static readonly string MainLightShadows;
        public static readonly string MainLightShadowCascades;
        public static readonly string AdditionalLightsVertex;
        public static readonly string AdditionalLightsPixel;
        public static readonly string AdditionalLightShadows;
        public static readonly string SoftShadows;
        public static readonly string MixedLightingSubtractive;
        public static readonly string LightmapShadowMixing;
        public static readonly string ShadowsShadowMask;
        public static readonly string DepthNoMsaa;
        public static readonly string DepthMsaa2;
        public static readonly string DepthMsaa4;
        public static readonly string DepthMsaa8;
        public static readonly string LinearToSRGBConversion;
        public static readonly string SmaaLow;
        public static readonly string SmaaMedium;
        public static readonly string SmaaHigh;
        public static readonly string PaniniGeneric;
        public static readonly string PaniniUnitDistance;
        public static readonly string BloomLQ;
        public static readonly string BloomHQ;
        public static readonly string BloomLQDirt;
        public static readonly string BloomHQDirt;
        public static readonly string UseRGBM;
        public static readonly string Distortion;
        public static readonly string ChromaticAberration;
        public static readonly string HDRGrading;
        public static readonly string TonemapACES;
        public static readonly string TonemapNeutral;
        public static readonly string FilmGrain;
        public static readonly string Fxaa;
        public static readonly string Dithering;
        public static readonly string ScreenSpaceOcclusion;
        public static readonly string HighQualitySampling;
        public static readonly string DOWNSAMPLING_SIZE_2;
        public static readonly string DOWNSAMPLING_SIZE_4;
        public static readonly string DOWNSAMPLING_SIZE_8;
        public static readonly string DOWNSAMPLING_SIZE_16;
        public static readonly string _SPOT;
        public static readonly string _DIRECTIONAL;
        public static readonly string _POINT;
        public static readonly string _DEFERRED_ADDITIONAL_LIGHT_SHADOWS;
        public static readonly string _GBUFFER_NORMALS_OCT;
        public static readonly string _DEFERRED_SUBTRACTIVE_LIGHTING;
        public static readonly string LIGHTMAP_ON;
        public static readonly string _ALPHATEST_ON;
        public static readonly string DIRLIGHTMAP_COMBINED;
        public static readonly string _DETAIL_MULX2;
        public static readonly string _DETAIL_SCALED;
        public static readonly string _CLEARCOAT;
        public static readonly string _CLEARCOATMAP;
        public static readonly string UseDrawProcedural;
    }
}
namespace UnityEngine.Rendering.Universal.Internal
{
    public class ForwardLights
    {
        public ForwardLights();

        public void Setup(ScriptableRenderContext context, ref RenderingData renderingData);
    }
}
namespace UnityEngine.Rendering.Universal.Internal
{
    public class AdditionalLightsShadowCasterPass : ScriptableRenderPass
    {
        public static int m_AdditionalShadowsBufferId;
        public static int m_AdditionalShadowsIndicesId;

        public AdditionalLightsShadowCasterPass(RenderPassEvent evt);

        public bool Setup(ref RenderingData renderingData);
        public override void Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor);
        public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData);
        public override void OnCameraCleanup(CommandBuffer cmd);
        public int GetShadowLightIndexFromLightIndex(int visibleLightIndex);
    }
}
namespace UnityEngine.Rendering.Universal.Internal
{
    public class ColorGradingLutPass : ScriptableRenderPass
    {
        public ColorGradingLutPass(RenderPassEvent evt, PostProcessData data);

        public void Setup(in RenderTargetHandle internalLut);
        public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData);
        public override void OnFinishCameraStackRendering(CommandBuffer cmd);
        public void Cleanup();
    }
}
namespace UnityEngine.Rendering.Universal.Internal
{
    public class CopyColorPass : ScriptableRenderPass
    {
        public CopyColorPass(RenderPassEvent evt, Material samplingMaterial, Material copyColorMaterial = null);

        public void Setup(RenderTargetIdentifier source, RenderTargetHandle destination, Downsampling downsampling);
        public override void OnCameraSetup(CommandBuffer cmd, ref RenderingData renderingData);
        public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData);
        public override void OnCameraCleanup(CommandBuffer cmd);
    }
}
namespace UnityEngine.Rendering.Universal.Internal
{
    public class CopyDepthPass : ScriptableRenderPass
    {
        public CopyDepthPass(RenderPassEvent evt, Material copyDepthMaterial);

        public void Setup(RenderTargetHandle source, RenderTargetHandle destination);
        public override void OnCameraSetup(CommandBuffer cmd, ref RenderingData renderingData);
        public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData);
        public override void OnCameraCleanup(CommandBuffer cmd);
    }
}
namespace UnityEngine.Rendering.Universal.Internal
{
    public class DepthNormalOnlyPass : ScriptableRenderPass
    {
        public DepthNormalOnlyPass(RenderPassEvent evt, RenderQueueRange renderQueueRange, LayerMask layerMask);

        public void Setup(RenderTextureDescriptor baseDescriptor, RenderTargetHandle depthHandle, RenderTargetHandle normalHandle);
        public override void OnCameraSetup(CommandBuffer cmd, ref RenderingData renderingData);
        public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData);
        public override void OnCameraCleanup(CommandBuffer cmd);
    }
}
namespace UnityEngine.Rendering.Universal.Internal
{
    public class DepthOnlyPass : ScriptableRenderPass
    {
        public DepthOnlyPass(RenderPassEvent evt, RenderQueueRange renderQueueRange, LayerMask layerMask);

        public void Setup(RenderTextureDescriptor baseDescriptor, RenderTargetHandle depthAttachmentHandle);
        public override void OnCameraSetup(CommandBuffer cmd, ref RenderingData renderingData);
        public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData);
        public override void OnCameraCleanup(CommandBuffer cmd);
    }
}
namespace UnityEngine.Rendering.Universal.Internal
{
    public class DrawObjectsPass : ScriptableRenderPass
    {
        public DrawObjectsPass(string profilerTag, ShaderTagId[] shaderTagIds, bool opaque, RenderPassEvent evt, RenderQueueRange renderQueueRange, LayerMask layerMask, StencilState stencilState, int stencilReference);
        public DrawObjectsPass(string profilerTag, bool opaque, RenderPassEvent evt, RenderQueueRange renderQueueRange, LayerMask layerMask, StencilState stencilState, int stencilReference);

        public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData);
    }
}
namespace UnityEngine.Rendering.Universal.Internal
{
    public class FinalBlitPass : ScriptableRenderPass
    {
        public FinalBlitPass(RenderPassEvent evt, Material blitMaterial);

        public void Setup(RenderTextureDescriptor baseDescriptor, RenderTargetHandle colorHandle);
        public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData);
    }
}
namespace UnityEngine.Rendering.Universal.Internal
{
    public class MainLightShadowCasterPass : ScriptableRenderPass
    {
        public MainLightShadowCasterPass(RenderPassEvent evt);

        public bool Setup(ref RenderingData renderingData);
        public override void Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor);
        public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData);
        public override void OnCameraCleanup(CommandBuffer cmd);
    }
}
namespace UnityEngine.Rendering.Universal.Internal
{
    public class PostProcessPass : ScriptableRenderPass
    {
        public PostProcessPass(RenderPassEvent evt, PostProcessData data, Material blitMaterial);

        public void Cleanup();
        public void Setup(in RenderTextureDescriptor baseDescriptor, in RenderTargetHandle source, in RenderTargetHandle destination, in RenderTargetHandle depth, in RenderTargetHandle internalLut, bool hasFinalPass, bool enableSRGBConversion);
        public void SetupFinalPass(in RenderTargetHandle source);
        public override void OnCameraSetup(CommandBuffer cmd, ref RenderingData renderingData);
        public override void OnCameraCleanup(CommandBuffer cmd);
        public void ResetHistory();
        public bool CanRunOnTile();
        public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData);
    }
}
namespace UnityEngine.Rendering.Universal.Internal
{
    public class ScreenSpaceShadowResolvePass : ScriptableRenderPass
    {
        public ScreenSpaceShadowResolvePass(RenderPassEvent evt, Material screenspaceShadowsMaterial);

        public void Setup(RenderTextureDescriptor baseDescriptor);
        public override void Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor);
        public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData);
        public override void OnCameraCleanup(CommandBuffer cmd);
    }
}
using System;

namespace UnityEngine.Experimental.Rendering.LWRP
{
    [Obsolete("LWRP -> Universal (UnityUpgradable) -> UnityEngine.Experimental.Rendering.Universal.Light2D", True)]
    public class Light2D
    {
        public Light2D();
    }
}
namespace UnityEngine.Experimental.Rendering.Universal
{
    [AddComponentMenu("")]
    public class CinemachineUniversalPixelPerfect : MonoBehaviour
    {
        public CinemachineUniversalPixelPerfect();
    }
}
namespace UnityEngine.Experimental.Rendering.Universal
{
    [ExecuteAlways]
    [DisallowMultipleComponent]
    [AddComponentMenu("Rendering/2D/Light 2D (Experimental)")]
    [HelpURL("https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@latest/index.html?subfolder=/manual/2DLightProperties.html")]
    public sealed class Light2D : MonoBehaviour
    {
        public Light2D();

        public LightType lightType { get; set; }
        public int blendStyleIndex { get; set; }
        public float shadowIntensity { get; set; }
        public float shadowVolumeIntensity { get; set; }
        public Color color { get; set; }
        public float intensity { get; set; }
        public float volumeOpacity { get; }
        public Sprite lightCookieSprite { get; }
        public float falloffIntensity { get; }
        public bool useNormalMap { get; }
        public bool alphaBlendOnOverlap { get; }
        public int lightOrder { get; set; }
        public float pointLightInnerAngle { get; set; }
        public float pointLightOuterAngle { get; set; }
        public float pointLightInnerRadius { get; set; }
        public float pointLightOuterRadius { get; set; }
        public float pointLightDistance { get; }
        public PointLightQuality pointLightQuality { get; }
        public int shapeLightParametricSides { get; }
        public float shapeLightParametricAngleOffset { get; }
        public float shapeLightParametricRadius { get; }
        public float shapeLightFalloffSize { get; }
        public Vector2 shapeLightFalloffOffset { get; }
        public Vector3[] shapePath { get; }

        public enum LightType
        {
            Parametric = 0,
            Freeform = 1,
            Sprite = 2,
            Point = 3,
            Global = 4
        }
        public enum PointLightQuality
        {
            Fast = 0,
            Accurate = 1
        }
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Experimental.Rendering.Universal
{
    [MovedFrom("UnityEngine.Experimental.Rendering.LWRP")]
    public struct Light2DBlendStyle
    {
        public string name;
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Experimental.Rendering.Universal
{
    [DisallowMultipleComponent]
    [AddComponentMenu("Rendering/2D/Pixel Perfect Camera (Experimental)")]
    [RequireComponent(typeof(Camera))]
    [MovedFrom("UnityEngine.Experimental.Rendering.LWRP")]
    [HelpURL("https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@latest/index.html?subfolder=/manual/2d-pixelperfect.html%23properties")]
    public class PixelPerfectCamera : MonoBehaviour, IPixelPerfectCamera
    {
        public PixelPerfectCamera();

        public int assetsPPU { get; set; }
        public int refResolutionX { get; set; }
        public int refResolutionY { get; set; }
        public bool upscaleRT { get; set; }
        public bool pixelSnapping { get; set; }
        public bool cropFrameX { get; set; }
        public bool cropFrameY { get; set; }
        public bool stretchFill { get; set; }
        public int pixelRatio { get; }

        public Vector3 RoundToPixel(Vector3 position);
        public float CorrectCinemachineOrthoSize(float targetOrthoSize);
    }
}
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Experimental.Rendering.Universal
{
    [ReloadGroup]
    [ExcludeFromPreset]
    [MovedFrom("UnityEngine.Experimental.Rendering.LWRP")]
    [HelpURL("https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@latest/index.html?subfolder=/manual/2DRendererData_overview.html")]
    public class Renderer2DData : ScriptableRendererData
    {
        public Renderer2DData();

        public float hdrEmulationScale { get; }
        public Light2DBlendStyle[] lightBlendStyles { get; }

        protected override ScriptableRenderer Create();
        protected override void OnEnable();

        public enum Renderer2DDefaultMaterialType
        {
            Lit = 0,
            Unlit = 1,
            Custom = 2
        }
    }
}
namespace UnityEngine.Experimental.Rendering.Universal
{
    [AddComponentMenu("Rendering/2D/Composite Shadow Caster 2D (Experimental)")]
    [ExecuteInEditMode]
    public class CompositeShadowCaster2D : ShadowCasterGroup2D
    {
        public CompositeShadowCaster2D();

        protected void OnEnable();
        protected void OnDisable();
    }
}
namespace UnityEngine.Experimental.Rendering.Universal
{
    [ExecuteInEditMode]
    [DisallowMultipleComponent]
    [AddComponentMenu("Rendering/2D/Shadow Caster 2D (Experimental)")]
    public class ShadowCaster2D : ShadowCasterGroup2D
    {
        public ShadowCaster2D();

        public bool useRendererSilhouette { get; set; }
        public bool selfShadows { get; set; }
        public bool castsShadows { get; set; }

        protected void OnEnable();
        protected void OnDisable();
        public void Update();
    }
}
using System.Collections.Generic;

namespace UnityEngine.Experimental.Rendering.Universal
{
    public abstract class ShadowCasterGroup2D : MonoBehaviour
    {
        protected ShadowCasterGroup2D();

        public List<ShadowCaster2D> GetShadowCasters();
        public int GetShadowGroup();
        public void RegisterShadowCaster2D(ShadowCaster2D shadowCaster2D);
        public void UnregisterShadowCaster2D(ShadowCaster2D shadowCaster2D);
    }
}
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Experimental.Rendering.Universal
{
    [MovedFrom("UnityEngine.Experimental.Rendering.LWRP")]
    public class RenderObjectsPass : ScriptableRenderPass
    {
        public RenderObjectsPass(string profilerTag, RenderPassEvent renderPassEvent, string[] shaderTags, RenderQueueType renderQueueType, int layerMask, RenderObjects.CustomCameraSettings cameraSettings);

        public Material overrideMaterial { get; set; }
        public int overrideMaterialPassIndex { get; set; }

        public void SetDetphState(bool writeEnabled, CompareFunction function = Less);
        public void SetStencilState(int reference, CompareFunction compareFunction, StencilOp passOp, StencilOp failOp, StencilOp zFailOp);
        public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData);
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Experimental.Rendering.Universal
{
    [MovedFrom("UnityEngine.Experimental.Rendering.LWRP")]
    public enum RenderQueueType
    {
        Opaque = 0,
        Transparent = 1
    }
}
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Experimental.Rendering.Universal
{
    [ExcludeFromPreset]
    [MovedFrom("UnityEngine.Experimental.Rendering.LWRP")]
    public class RenderObjects : ScriptableRendererFeature
    {
        public RenderObjectsSettings settings;

        public RenderObjects();

        public override void Create();
        public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData);

        public class RenderObjectsSettings
        {
            public string passTag;
            public RenderPassEvent Event;
            public FilterSettings filterSettings;
            public Material overrideMaterial;
            public int overrideMaterialPassIndex;
            public bool overrideDepthState;
            public CompareFunction depthCompareFunction;
            public bool enableWrite;
            public StencilStateData stencilSettings;
            public CustomCameraSettings cameraSettings;

            public RenderObjectsSettings();
        }
        public class FilterSettings
        {
            public RenderQueueType RenderQueueType;
            public LayerMask LayerMask;
            public string[] PassNames;

            public FilterSettings();
        }
        public class CustomCameraSettings
        {
            public bool overrideCamera;
            public bool restoreCamera;
            public Vector4 offset;
            public float cameraFieldOfView;

            public CustomCameraSettings();
        }
    }
}
-------- {Unity.TextMeshPro.Editor(D:\Documents\GitHub\Rogue-like-game-i-guess\The game is liar\Library\ScriptAssemblies\Unity.TextMeshPro.Editor.dll)}:   92 --------
using UnityEditor;

namespace TMPro
{
    public static class TMP_FontAsset_CreationMenu
    {
        [MenuItem("Assets/Create/TextMeshPro/Font Asset Variant", False, 105)]
        public static void CreateFontAssetVariant();
        [MenuItem("Assets/Create/TextMeshPro/Font Asset #%F12", False, 100)]
        public static void CreateFontAsset();
    }
}
using UnityEditor;

namespace TMPro
{
    public class TMP_ProjectConversionUtility : EditorWindow
    {
        public TMP_ProjectConversionUtility();
    }
}
using UnityEditor;

namespace TMPro
{
    public class TMP_PackageUtilities : Editor
    {
        public TMP_PackageUtilities();

        [MenuItem("Window/TextMeshPro/Import TMP Essential Resources", False, 2050)]
        public static void ImportProjectResourcesMenu();
        [MenuItem("Window/TextMeshPro/Import TMP Examples and Extras", False, 2051)]
        public static void ImportExamplesContentMenu();
    }
}
using UnityEditor;
using UnityEditor.Callbacks;

namespace TMPro
{
    public class TMP_PostBuildProcessHandler
    {
        public TMP_PostBuildProcessHandler();

        [PostProcessBuild(10000)]
        public static void OnPostprocessBuild(BuildTarget target, string pathToBuiltProject);
    }
}
using UnityEditor.Build;
using UnityEditor.Build.Reporting;

namespace TMPro
{
    public class TMP_PreBuildProcessor : IOrderedCallback, IPreprocessBuildWithReport
    {
        public TMP_PreBuildProcessor();

        public int callbackOrder { get; }

        public void OnPreprocessBuild(BuildReport report);
    }
}
using UnityEditor;

namespace TMPro
{
    public class TMP_SpriteAssetImporter : EditorWindow
    {
        public TMP_SpriteAssetImporter();

        [MenuItem("Window/TextMeshPro/Sprite Importer", False, 2026)]
        public static void ShowFontAtlasCreatorWindow();
        public void OnGUI();
    }
}
namespace TMPro
{
    public static class SortingLayerHelper
    {
        public static string[] sortingLayerNames { get; }
    }
}
using UnityEditor;
using UnityEngine;
using UnityEngine.TextCore;

namespace TMPro.EditorUtilities
{
    [CustomPropertyDrawer(typeof(GlyphMetrics))]
    public class GlyphMetricsPropertyDrawer : PropertyDrawer
    {
        public GlyphMetricsPropertyDrawer();

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label);
        public override float GetPropertyHeight(SerializedProperty property, GUIContent label);
    }
}
using UnityEditor;
using UnityEngine;
using UnityEngine.TextCore;

namespace TMPro.EditorUtilities
{
    [CustomPropertyDrawer(typeof(GlyphRect))]
    public class GlyphRectPropertyDrawer : PropertyDrawer
    {
        public GlyphRectPropertyDrawer();

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label);
        public override float GetPropertyHeight(SerializedProperty property, GUIContent label);
    }
}
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace TMPro.EditorUtilities
{
    public abstract class TMP_BaseEditorPanel : Editor
    {
        protected static readonly GUIContent k_ExtraSettingsLabel;
        protected static string[] k_UiStateLabel;
        protected Dictionary<int, int> m_TextStyleIndexLookup;
        protected static int s_EventId;
        public int selAlignGridA;
        public int selAlignGridB;
        protected SerializedProperty m_TextProp;
        protected SerializedProperty m_IsRightToLeftProp;
        protected string m_RtlText;
        protected SerializedProperty m_FontAssetProp;
        protected SerializedProperty m_FontSharedMaterialProp;
        protected Material[] m_MaterialPresets;
        protected GUIContent[] m_MaterialPresetNames;
        protected Dictionary<int, int> m_MaterialPresetIndexLookup;
        protected int m_MaterialPresetSelectionIndex;
        protected bool m_IsPresetListDirty;
        protected List<TMP_Style> m_Styles;
        protected GUIContent[] m_StyleNames;
        protected int m_StyleSelectionIndex;
        protected SerializedProperty m_FontStyleProp;
        protected SerializedProperty m_FontColorProp;
        protected SerializedProperty m_EnableVertexGradientProp;
        protected SerializedProperty m_FontColorGradientProp;
        protected SerializedProperty m_FontColorGradientPresetProp;
        protected SerializedProperty m_OverrideHtmlColorProp;
        protected SerializedProperty m_FontSizeProp;
        protected SerializedProperty m_FontSizeBaseProp;
        protected SerializedProperty m_AutoSizingProp;
        protected SerializedProperty m_FontSizeMinProp;
        protected SerializedProperty m_FontSizeMaxProp;
        protected SerializedProperty m_LineSpacingMaxProp;
        protected SerializedProperty m_CharWidthMaxAdjProp;
        protected SerializedProperty m_CharacterSpacingProp;
        protected SerializedProperty m_WordSpacingProp;
        protected SerializedProperty m_LineSpacingProp;
        protected SerializedProperty m_ParagraphSpacingProp;
        protected SerializedProperty m_TextAlignmentProp;
        protected SerializedProperty m_HorizontalAlignmentProp;
        protected SerializedProperty m_VerticalAlignmentProp;
        protected SerializedProperty m_HorizontalMappingProp;
        protected SerializedProperty m_VerticalMappingProp;
        protected SerializedProperty m_UvLineOffsetProp;
        protected SerializedProperty m_EnableWordWrappingProp;
        protected SerializedProperty m_WordWrappingRatiosProp;
        protected SerializedProperty m_TextOverflowModeProp;
        protected SerializedProperty m_PageToDisplayProp;
        protected SerializedProperty m_LinkedTextComponentProp;
        protected SerializedProperty m_ParentLinkedTextComponentProp;
        protected SerializedProperty m_EnableKerningProp;
        protected SerializedProperty m_IsRichTextProp;
        protected SerializedProperty m_HasFontAssetChangedProp;
        protected SerializedProperty m_EnableExtraPaddingProp;
        protected SerializedProperty m_CheckPaddingRequiredProp;
        protected SerializedProperty m_EnableEscapeCharacterParsingProp;
        protected SerializedProperty m_UseMaxVisibleDescenderProp;
        protected SerializedProperty m_GeometrySortingOrderProp;
        protected SerializedProperty m_IsTextObjectScaleStaticProp;
        protected SerializedProperty m_SpriteAssetProp;
        protected SerializedProperty m_StyleSheetAssetProp;
        protected SerializedProperty m_TextStyleHashCodeProp;
        protected SerializedProperty m_MarginProp;
        protected SerializedProperty m_ColorModeProp;
        protected bool m_HavePropertiesChanged;
        protected TMP_Text m_TextComponent;
        protected TMP_Text m_PreviousLinkedTextComponent;
        protected RectTransform m_RectTransform;
        protected Material m_TargetMaterial;
        protected Vector3[] m_RectCorners;
        protected Vector3[] m_HandlePoints;

        protected TMP_BaseEditorPanel();

        protected virtual void OnEnable();
        protected virtual void OnDisable();
        public override void OnInspectorGUI();
        public void OnSceneGUI();
        protected void DrawTextInput();
        protected void DrawMainSettings();
        protected abstract void DrawExtraSettings();
        protected void DrawMargins();
        protected void DrawGeometrySorting();
        protected void DrawIsTextObjectScaleStatic();
        protected void DrawRichText();
        protected void DrawParsing();
        protected void DrawSpriteAsset();
        protected void DrawStyleSheet();
        protected void DrawTextureMapping();
        protected void DrawKerning();
        protected void DrawPadding();
        protected GUIContent[] GetMaterialPresets();
        protected GUIContent[] GetStyleNames();
        protected void DrawMarginProperty(SerializedProperty property, GUIContent label);
        protected void DrawPropertySlider(GUIContent label, SerializedProperty property);
        protected abstract bool IsMixSelectionTypes();
        protected abstract void OnUndoRedo();

        protected struct Foldout
        {
            public static bool extraSettings;
            public static bool materialInspector;
        }
    }
}
using UnityEditor;
using UnityEngine;

namespace TMPro.EditorUtilities
{
    public abstract class TMP_BaseShaderGUI : ShaderGUI
    {
        protected static bool s_DebugExtended;
        protected static GUIContent[] s_XywhVectorLabels;
        protected static GUIContent[] s_LbrtVectorLabels;
        protected static GUIContent[] s_CullingTypeLabels;
        protected MaterialEditor m_Editor;
        protected Material m_Material;
        protected MaterialProperty[] m_Properties;

        protected TMP_BaseShaderGUI();

        public override void OnGUI(MaterialEditor materialEditor, MaterialProperty[] properties);
        protected abstract void DoGUI();
        protected bool BeginPanel(string panel, bool expanded);
        protected bool BeginPanel(string panel, ShaderFeature feature, bool expanded, bool readState = True);
        public void EndPanel();
        protected void DoPopup(string name, string label, GUIContent[] options);
        protected void DoCubeMap(string name, string label);
        protected void DoTexture2D(string name, string label, bool withTilingOffset = False, string[] speedNames = null);
        protected void DoUVSpeed(Rect rect, string[] names);
        protected void DoToggle(string name, string label);
        protected void DoFloat(string name, string label);
        protected void DoColor(string name, string label);
        protected void DoSlider(string name, string label);
        protected void DoSlider(string propertyName, string propertyField, string label);
        protected void DoVector2(string name, string label);
        protected void DoVector3(string name, string label);
        protected void DoVector(string name, string label, GUIContent[] subLabels);

        protected class ShaderFeature
        {
            public string undoLabel;
            public GUIContent label;
            public GUIContent[] keywordLabels;
            public string[] keywords;

            public ShaderFeature();

            public bool Active { get; }
            public int State { get; }

            public void ReadState(Material material);
            public void SetActive(bool active, Material material);
            public void DoPopup(MaterialEditor editor, Material material);
        }
    }
}
namespace TMPro.EditorUtilities
{
    public class TMP_BitmapShaderGUI : TMP_BaseShaderGUI
    {
        public TMP_BitmapShaderGUI();

        protected override void DoGUI();
    }
}
using UnityEditor;
using UnityEngine;

namespace TMPro.EditorUtilities
{
    [CustomPropertyDrawer(typeof(TMP_Character))]
    public class TMP_CharacterPropertyDrawer : PropertyDrawer
    {
        public TMP_CharacterPropertyDrawer();

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label);
        public override float GetPropertyHeight(SerializedProperty property, GUIContent label);
    }
}
using UnityEditor;

namespace TMPro.EditorUtilities
{
    public static class TMP_ColorGradientAssetMenu
    {
        [MenuItem("Assets/Create/TextMeshPro/Color Gradient", False, 115)]
        public static void CreateColorGradient(MenuCommand context);
    }
}
using UnityEditor;

namespace TMPro.EditorUtilities
{
    [CustomEditor(typeof(TMP_ColorGradient))]
    public class TMP_ColorGradientEditor : Editor
    {
        public TMP_ColorGradientEditor();

        public override void OnInspectorGUI();
    }
}
using UnityEditor;
using UnityEditor.UI;

namespace TMPro.EditorUtilities
{
    [CustomEditor(typeof(TMP_Dropdown), True)]
    [CanEditMultipleObjects]
    public class DropdownEditor : SelectableEditor
    {
        public DropdownEditor();

        protected override void OnEnable();
        public override void OnInspectorGUI();
    }
}
using System.Collections;

namespace TMPro.EditorUtilities
{
    public class TMP_EditorCoroutine
    {
        public static TMP_EditorCoroutine StartCoroutine(IEnumerator routine);
        public void Stop();
    }
}
using UnityEditor;

namespace TMPro.EditorUtilities
{
    [CustomEditor(typeof(TextMeshPro), True)]
    [CanEditMultipleObjects]
    public class TMP_EditorPanel : TMP_BaseEditorPanel
    {
        public TMP_EditorPanel();

        protected override void OnEnable();
        protected override void DrawExtraSettings();
        protected void DrawVolumetricSetup();
        protected override bool IsMixSelectionTypes();
        protected override void OnUndoRedo();
    }
}
using UnityEditor;

namespace TMPro.EditorUtilities
{
    [CustomEditor(typeof(TextMeshProUGUI), True)]
    [CanEditMultipleObjects]
    public class TMP_EditorPanelUI : TMP_BaseEditorPanel
    {
        public TMP_EditorPanelUI();

        protected override void OnEnable();
        protected override void DrawExtraSettings();
        protected void DrawRaycastTarget();
        protected void DrawMaskable();
        protected override bool IsMixSelectionTypes();
        protected override void OnUndoRedo();
    }
}
using UnityEditor;
using UnityEngine;

namespace TMPro.EditorUtilities
{
    public static class TMP_EditorUtility
    {
        public static string packageRelativePath { get; }
        public static string packageFullPath { get; }

        public static void RepaintAll();
        public static T CreateAsset<T>(string name) where T : ScriptableObject;
        public static Material[] FindMaterialReferences(TMP_FontAsset fontAsset);
        public static TMP_FontAsset FindMatchingFontAsset(Material mat);
        public static string GetDecimalCharacterSequence(int[] characterSet);
        public static string GetUnicodeCharacterSequence(int[] characterSet);
        public static void DrawBox(Rect rect, float thickness, Color color);
        public static int GetHorizontalAlignmentGridValue(int value);
        public static int GetVerticalAlignmentGridValue(int value);
        public static void DrawColorProperty(Rect rect, SerializedProperty property);
        public static bool EditorToggle(Rect position, bool value, GUIContent content, GUIStyle style);
    }
}
using UnityEditor;
using UnityEngine;

namespace TMPro.EditorUtilities
{
    [CustomPropertyDrawer(typeof(TMP_FontWeightPair))]
    public class FontWeightDrawer : PropertyDrawer
    {
        public FontWeightDrawer();

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label);
    }
}
using UnityEditor;

namespace TMPro.EditorUtilities
{
    [CustomEditor(typeof(TMP_FontAsset))]
    public class TMP_FontAssetEditor : Editor
    {
        public TMP_FontAssetEditor();

        public void OnEnable();
        public void OnDisable();
        public override void OnInspectorGUI();
    }
}
using UnityEditor;
using UnityEngine;

namespace TMPro.EditorUtilities
{
    [CustomPropertyDrawer(typeof(TMP_GlyphPairAdjustmentRecord))]
    public class TMP_GlyphPairAdjustmentRecordPropertyDrawer : PropertyDrawer
    {
        public TMP_GlyphPairAdjustmentRecordPropertyDrawer();

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label);
    }
}
using UnityEditor;
using UnityEngine;
using UnityEngine.TextCore;

namespace TMPro.EditorUtilities
{
    [CustomPropertyDrawer(typeof(Glyph))]
    public class TMP_GlyphPropertyDrawer : PropertyDrawer
    {
        public TMP_GlyphPropertyDrawer();

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label);
        public override float GetPropertyHeight(SerializedProperty property, GUIContent label);
    }
}
using UnityEditor;
using UnityEditor.UI;

namespace TMPro.EditorUtilities
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(TMP_InputField), True)]
    public class TMP_InputFieldEditor : SelectableEditor
    {
        public TMP_InputFieldEditor();

        protected override void OnEnable();
        protected override void OnDisable();
        public override void OnInspectorGUI();
    }
}
namespace TMPro.EditorUtilities
{
    public class TMP_SDFShaderGUI : TMP_BaseShaderGUI
    {
        public TMP_SDFShaderGUI();

        protected override void DoGUI();
    }
}
using UnityEditor;

namespace TMPro.EditorUtilities
{
    [CustomEditor(typeof(TMP_Settings))]
    public class TMP_SettingsEditor : Editor
    {
        public TMP_SettingsEditor();

        public void OnEnable();
        public override void OnInspectorGUI();
    }
}
using UnityEditor;

namespace TMPro.EditorUtilities
{
    [CustomEditor(typeof(TMP_SpriteAsset))]
    public class TMP_SpriteAssetEditor : Editor
    {
        public TMP_SpriteAssetEditor();

        public void OnEnable();
        public override void OnInspectorGUI();
    }
}
using UnityEditor;

namespace TMPro.EditorUtilities
{
    public static class TMP_SpriteAssetMenu
    {
        [MenuItem("Assets/Create/TextMeshPro/Sprite Asset", False, 110)]
        public static void CreateSpriteAsset();
    }
}
using UnityEditor;
using UnityEngine;

namespace TMPro.EditorUtilities
{
    [CustomPropertyDrawer(typeof(TMP_SpriteCharacter))]
    public class TMP_SpriteCharacterPropertyDrawer : PropertyDrawer
    {
        public TMP_SpriteCharacterPropertyDrawer();

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label);
        public override float GetPropertyHeight(SerializedProperty property, GUIContent label);
    }
}
using UnityEditor;
using UnityEngine;

namespace TMPro.EditorUtilities
{
    [CustomPropertyDrawer(typeof(TMP_SpriteGlyph))]
    public class TMP_SpriteGlyphPropertyDrawer : PropertyDrawer
    {
        public TMP_SpriteGlyphPropertyDrawer();

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label);
        public override float GetPropertyHeight(SerializedProperty property, GUIContent label);
    }
}
using UnityEditor;

namespace TMPro.EditorUtilities
{
    public static class TMP_StyleAssetMenu
    {
        [MenuItem("Assets/Create/TextMeshPro/Style Sheet", False, 120)]
        public static void CreateTextMeshProObjectPerform();
    }
}
using UnityEditor;
using UnityEngine;

namespace TMPro.EditorUtilities
{
    [CustomPropertyDrawer(typeof(TMP_Style))]
    public class StyleDrawer : PropertyDrawer
    {
        public static readonly float height;

        public StyleDrawer();

        public override float GetPropertyHeight(SerializedProperty property, GUIContent label);
        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label);
    }
}
using UnityEditor;

namespace TMPro.EditorUtilities
{
    [CustomEditor(typeof(TMP_StyleSheet))]
    [CanEditMultipleObjects]
    public class TMP_StyleEditor : Editor
    {
        public TMP_StyleEditor();

        public override void OnInspectorGUI();
    }
}
using UnityEditor;

namespace TMPro.EditorUtilities
{
    [CustomEditor(typeof(TMP_SubMeshUI))]
    [CanEditMultipleObjects]
    public class TMP_SubMeshUI_Editor : Editor
    {
        public TMP_SubMeshUI_Editor();

        public void OnEnable();
        public void OnDisable();
        public override void OnInspectorGUI();
    }
}
using UnityEditor;

namespace TMPro.EditorUtilities
{
    [CustomEditor(typeof(TMP_SubMesh))]
    [CanEditMultipleObjects]
    public class TMP_SubMesh_Editor : Editor
    {
        public TMP_SubMesh_Editor();

        public void OnEnable();
        public override void OnInspectorGUI();
    }
}
using UnityEditor;
using UnityEngine;

namespace TMPro.EditorUtilities
{
    [CustomPropertyDrawer(typeof(TextAlignmentOptions))]
    public class TMP_TextAlignmentDrawer : PropertyDrawer
    {
        public TMP_TextAlignmentDrawer();

        public override float GetPropertyHeight(SerializedProperty property, GUIContent label);
        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label);
    }
}
using UnityEditor;
using UnityEngine;

namespace TMPro.EditorUtilities
{
    [CustomPropertyDrawer(typeof(HorizontalAlignmentOptions))]
    public class TMP_HorizontalAlignmentDrawer : PropertyDrawer
    {
        public TMP_HorizontalAlignmentDrawer();

        public override float GetPropertyHeight(SerializedProperty property, GUIContent label);
        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label);
    }
}
using UnityEditor;
using UnityEngine;

namespace TMPro.EditorUtilities
{
    [CustomPropertyDrawer(typeof(VerticalAlignmentOptions))]
    public class TMP_VerticalAlignmentDrawer : PropertyDrawer
    {
        public TMP_VerticalAlignmentDrawer();

        public override float GetPropertyHeight(SerializedProperty property, GUIContent label);
        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label);
    }
}
using UnityEngine;

namespace TMPro.EditorUtilities
{
    public static class TMP_UIStyleManager
    {
        public static GUIStyle label;
        public static GUIStyle textAreaBoxWindow;
        public static GUIStyle boldFoldout;
        public static GUIStyle panelTitle;
        public static GUIStyle sectionHeader;
        public static GUIStyle centeredLabel;
        public static GUIStyle rightLabel;
        public static GUIStyle wrappingTextArea;
        public static GUIStyle alignmentButtonLeft;
        public static GUIStyle alignmentButtonMid;
        public static GUIStyle alignmentButtonRight;
        public static Texture2D alignLeft;
        public static Texture2D alignCenter;
        public static Texture2D alignRight;
        public static Texture2D alignJustified;
        public static Texture2D alignFlush;
        public static Texture2D alignGeoCenter;
        public static Texture2D alignTop;
        public static Texture2D alignMiddle;
        public static Texture2D alignBottom;
        public static Texture2D alignBaseline;
        public static Texture2D alignMidline;
        public static Texture2D alignCapline;
        public static Texture2D sectionHeaderTexture;
        public static GUIContent[] alignContentA;
        public static GUIContent[] alignContentB;
    }
}
using UnityEditor;

namespace TMPro.EditorUtilities
{
    public class TMP_ContextMenus : Editor
    {
        public TMP_ContextMenus();
    }
}
using UnityEditor;
using UnityEngine;

namespace TMPro.EditorUtilities
{
    public static class TMPro_CreateObjectMenu
    {
        [MenuItem("GameObject/UI/Button - TextMeshPro", False, 2031)]
        public static void AddButton(MenuCommand menuCommand);
        [MenuItem("GameObject/UI/Dropdown - TextMeshPro", False, 2036)]
        public static void AddDropdown(MenuCommand menuCommand);
        public static GameObject CreateNewUI();
        public static GameObject GetOrCreateCanvasGameObject();
    }
}
using UnityEngine;

namespace TMPro.EditorUtilities
{
    public static class EditorShaderUtilities
    {
        public static void CopyMaterialProperties(Material source, Material destination);
    }
}
using UnityEditor;
using UnityEngine;

namespace TMPro.EditorUtilities
{
    public class TMPro_FontAssetCreatorWindow : EditorWindow
    {
        public TMPro_FontAssetCreatorWindow();

        [MenuItem("Window/TextMeshPro/Font Asset Creator", False, 2025)]
        public static void ShowFontAtlasCreatorWindow();
        public static void ShowFontAtlasCreatorWindow(Font sourceFontFile);
        public static void ShowFontAtlasCreatorWindow(TMP_FontAsset fontAsset);
        public void OnEnable();
        public void OnDisable();
        public void OnGUI();
        public void Update();
        public TMP_FontFeatureTable GetKerningTable();
    }
}
using UnityEditor;

namespace TMPro.EditorUtilities
{
    [CustomEditor(typeof(TextContainer))]
    [CanEditMultipleObjects]
    public class TMPro_TextContainerEditor : Editor
    {
        public TMPro_TextContainerEditor();

        public override void OnInspectorGUI();
    }
}
-------- {Unity.VisualStudio.Editor(D:\Documents\GitHub\Rogue-like-game-i-guess\The game is liar\Library\ScriptAssemblies\Unity.VisualStudio.Editor.dll)}:   79 --------
using System;
using System.IO;

namespace Microsoft.Unity.VisualStudio.Editor
{
    public sealed class Image : IDisposable
    {
        public static bool IsAssembly(string file);
        public static bool IsAssembly(Stream stream);
    }
}
using System;
using System.Collections.Generic;
using UnityEditor.Compilation;
using UnityEditor.PackageManager;

namespace Microsoft.Unity.VisualStudio.Editor
{
    public interface IAssemblyNameProvider
    {
        string[] ProjectSupportedExtensions { get; }
        string ProjectGenerationRootNamespace { get; }
        ProjectGenerationFlag ProjectGenerationFlag { get; }

        string GetAssemblyNameFromScriptPath(string path);
        string GetAssemblyName(string assemblyOutputPath, string assemblyName);
        bool IsInternalizedPackagePath(string path);
        IEnumerable<Assembly> GetAssemblies(Func<string, bool> shouldFileBePartOfSolution);
        IEnumerable<string> GetAllAssetPaths();
        PackageInfo FindForAssetPath(string assetPath);
        ResponseFileData ParseResponseFile(string responseFilePath, string projectDirectory, string[] systemReferenceDirectories);
        void ToggleProjectGeneration(ProjectGenerationFlag preference);
    }
}
using System;
using System.Collections.Generic;
using UnityEditor.Compilation;
using UnityEditor.PackageManager;

namespace Microsoft.Unity.VisualStudio.Editor
{
    public class AssemblyNameProvider : IAssemblyNameProvider
    {
        public AssemblyNameProvider();

        public string[] ProjectSupportedExtensions { get; }
        public string ProjectGenerationRootNamespace { get; }
        public ProjectGenerationFlag ProjectGenerationFlag { get; }

        public string GetAssemblyNameFromScriptPath(string path);
        public IEnumerable<Assembly> GetAssemblies(Func<string, bool> shouldFileBePartOfSolution);
        public string GetCompileOutputPath(string assemblyName);
        public IEnumerable<string> GetAllAssetPaths();
        public PackageInfo FindForAssetPath(string assetPath);
        public bool IsInternalizedPackagePath(string path);
        public ResponseFileData ParseResponseFile(string responseFilePath, string projectDirectory, string[] systemReferenceDirectories);
        public void ToggleProjectGeneration(ProjectGenerationFlag preference);
        public void ResetProjectGenerationFlag();
        public string GetAssemblyName(string assemblyOutputPath, string assemblyName);
    }
}
namespace Microsoft.Unity.VisualStudio.Editor
{
    public interface IFileIO
    {
        bool Exists(string fileName);
        string ReadAllText(string fileName);
        void WriteAllText(string fileName, string content);
    }
}
namespace Microsoft.Unity.VisualStudio.Editor
{
    public interface IGUIDGenerator
    {
        string ProjectGuid(string projectName, string assemblyName);
        string SolutionGuid(string projectName, ScriptingLanguage scriptingLanguage);
    }
}
namespace Microsoft.Unity.VisualStudio.Editor
{
    public enum ScriptingLanguage
    {
        None = 0,
        CSharp = 1
    }
}
using System.Collections.Generic;

namespace Microsoft.Unity.VisualStudio.Editor
{
    public interface IGenerator
    {
        string ProjectDirectory { get; }
        IAssemblyNameProvider AssemblyNameProvider { get; }

        bool SyncIfNeeded(IEnumerable<string> affectedFiles, IEnumerable<string> reimportedFiles);
        void Sync();
        bool HasSolutionBeenGenerated();
        bool IsSupportedFile(string path);
        string SolutionFile();
    }
}
using System.Collections.Generic;
using UnityEditor.Compilation;

namespace Microsoft.Unity.VisualStudio.Editor
{
    public class ProjectGeneration : IGenerator
    {
        public static readonly string MSBuildNamespaceUri;

        public ProjectGeneration();
        public ProjectGeneration(string tempDirectory);
        public ProjectGeneration(string tempDirectory, IAssemblyNameProvider assemblyNameProvider, IFileIO fileIoProvider, IGUIDGenerator guidGenerator);

        public IAssemblyNameProvider AssemblyNameProvider { get; }
        public string ProjectDirectory { get; }

        public bool SyncIfNeeded(IEnumerable<string> affectedFiles, IEnumerable<string> reimportedFiles);
        public void Sync();
        public bool HasSolutionBeenGenerated();
        public bool IsSupportedFile(string path);
        public void GenerateAndWriteSolutionAndProjects();
        public string ProjectFile(Assembly assembly);
        public string SolutionFile();
    }
}
namespace Microsoft.Unity.VisualStudio.Editor
{
    public static class SolutionGuidGenerator
    {
        public static string GuidForProject(string projectName);
        public static string GuidForSolution(string projectName, ScriptingLanguage language);
    }
}
using System;

namespace Microsoft.Unity.VisualStudio.Editor
{
    [Flags]
    public enum ProjectGenerationFlag
    {
        None = 0,
        Embedded = 1,
        Local = 2,
        Registry = 4,
        Git = 8,
        BuiltIn = 16,
        Unknown = 32,
        PlayerAssemblies = 64,
        LocalTarBall = 128
    }
}
using Unity.CodeEditor;
using UnityEditor;

namespace Microsoft.Unity.VisualStudio.Editor
{
    [InitializeOnLoad]
    public class VisualStudioEditor : IExternalCodeEditor
    {
        public VisualStudioEditor();

        public void CreateIfDoesntExist();
        public void Initialize(string editorInstallationPath);
        public virtual bool TryGetInstallationForPath(string editorPath, out CodeEditor.Installation installation);
        public void OnGUI();
        public void SyncIfNeeded(string[] addedFiles, string[] deletedFiles, string[] movedFiles, string[] movedFromFiles, string[] importedFiles);
        public void SyncAll();
        public bool OpenProject(string path, int line, int column);
    }
}
-------- {UnityEngine.TestRunner(D:\Documents\GitHub\Rogue-like-game-i-guess\The game is liar\Library\ScriptAssemblies\UnityEngine.TestRunner.dll)}:  177 --------
using NUnit.Framework.Interfaces;

namespace UnityEngine.TestRunner
{
    public interface ITestRunCallback
    {
        void RunStarted(ITest testsToRun);
        void RunFinished(ITestResult testResults);
        void TestStarted(ITest test);
        void TestFinished(ITestResult result);
    }
}
using System;

namespace UnityEngine.TestRunner
{
    [AttributeUsage(Assembly)]
    public class TestRunCallbackAttribute : Attribute
    {
        public TestRunCallbackAttribute(Type type);
    }
}
using System.Text.RegularExpressions;

namespace UnityEngine.TestTools
{
    public static class LogAssert
    {
        public static bool ignoreFailingMessages { get; set; }

        public static void Expect(LogType type, string message);
        public static void Expect(LogType type, Regex message);
        public static void NoUnexpectedReceived();
    }
}
using NUnit.Framework;
using NUnit.Framework.Interfaces;
using NUnit.Framework.Internal;

namespace UnityEngine.TestTools
{
    public class ConditionalIgnoreAttribute : NUnitAttribute, IApplyToTest
    {
        public ConditionalIgnoreAttribute(string conditionKey, string ignoreReason);

        public void ApplyToTest(Test test);
        public static void AddConditionalIgnoreMapping(string key, bool value);
    }
}
using System;

namespace UnityEngine.TestTools
{
    [AttributeUsage(Assembly, Class, Method)]
    public class TestMustExpectAllLogsAttribute : Attribute
    {
        public TestMustExpectAllLogsAttribute(bool mustExpect = True);

        public bool MustExpect { get; }
    }
}
using NUnit.Framework;
using NUnit.Framework.Interfaces;
using NUnit.Framework.Internal;
using System;

namespace UnityEngine.TestTools
{
    [AttributeUsage(Assembly, Class, Method, AllowMultiple = True, Inherited = False)]
    public class UnityPlatformAttribute : NUnitAttribute, IApplyToTest
    {
        public UnityPlatformAttribute();
        public UnityPlatformAttribute(params RuntimePlatform[] include);

        public RuntimePlatform[] include { get; set; }
        public RuntimePlatform[] exclude { get; set; }

        public void ApplyToTest(Test test);
    }
}
using NUnit.Framework;
using System;

namespace UnityEngine.TestTools
{
    [AttributeUsage(Method)]
    public class UnitySetUpAttribute : NUnitAttribute
    {
        public UnitySetUpAttribute();
    }
}
using NUnit.Framework;
using System;

namespace UnityEngine.TestTools
{
    [AttributeUsage(Method)]
    public class UnityTearDownAttribute : NUnitAttribute
    {
        public UnityTearDownAttribute();
    }
}
using NUnit.Framework;
using NUnit.Framework.Interfaces;
using NUnit.Framework.Internal;
using System;

namespace UnityEngine.TestTools
{
    [AttributeUsage(Method)]
    public class UnityTestAttribute : CombiningStrategyAttribute, IImplyFixture, ISimpleTestBuilder
    {
        public UnityTestAttribute();

        public void ApplyToTest(Test test);
    }
}
using System.Collections;

namespace UnityEngine.TestTools
{
    public interface IEditModeTestYieldInstruction
    {
        bool ExpectDomainReload { get; }
        bool ExpectedPlaymodeState { get; }

        IEnumerator Perform();
    }
}
using System;

namespace UnityEngine.TestTools
{
    [Flags]
    public enum TestPlatform
    {
        All = 255,
        EditMode = 2,
        PlayMode = 4
    }
}
using NUnit.Framework.Interfaces;
using System.Collections;

namespace UnityEngine.TestTools
{
    public interface IOuterUnityTestAction
    {
        IEnumerator BeforeTest(ITest test);
        IEnumerator AfterTest(ITest test);
    }
}
namespace UnityEngine.TestTools
{
    public interface IPostBuildCleanup
    {
        void Cleanup();
    }
}
namespace UnityEngine.TestTools
{
    public interface IPrebuildSetup
    {
        void Setup();
    }
}
namespace UnityEngine.TestTools
{
    public interface IMonoBehaviourTest
    {
        bool IsTestFinished { get; }
    }
}
namespace UnityEngine.TestTools
{
    public class MonoBehaviourTest<T> : CustomYieldInstruction where T : MonoBehaviour, IMonoBehaviourTest
    {
        public MonoBehaviourTest(bool dontDestroyOnLoad = True);

        public T component { get; }
        public GameObject gameObject { get; }
        public override bool keepWaiting { get; }
    }
}
using System;

namespace UnityEngine.TestTools
{
    [AttributeUsage(Assembly, Class, Method)]
    public class PostBuildCleanupAttribute : Attribute
    {
        public PostBuildCleanupAttribute(Type targetClass);
        public PostBuildCleanupAttribute(string targetClassName);
    }
}
using System;

namespace UnityEngine.TestTools
{
    [AttributeUsage(Assembly, Class, Method)]
    public class PrebuildSetupAttribute : Attribute
    {
        public PrebuildSetupAttribute(Type targetClass);
        public PrebuildSetupAttribute(string targetClassName);
    }
}
using System.Collections.Generic;

namespace UnityEngine.TestTools.Utils
{
    public class ColorEqualityComparer : IEqualityComparer<Color>
    {
        public ColorEqualityComparer(float error);

        public static ColorEqualityComparer Instance { get; }

        public bool Equals(Color expected, Color actual);
        public int GetHashCode(Color color);
    }
}
using System.Collections.Generic;

namespace UnityEngine.TestTools.Utils
{
    public class FloatEqualityComparer : IEqualityComparer<float>
    {
        public FloatEqualityComparer(float allowedError);

        public static FloatEqualityComparer Instance { get; }

        public bool Equals(float expected, float actual);
        public int GetHashCode(float value);
    }
}
using System.Collections.Generic;

namespace UnityEngine.TestTools.Utils
{
    public class QuaternionEqualityComparer : IEqualityComparer<Quaternion>
    {
        public QuaternionEqualityComparer(float allowedError);

        public static QuaternionEqualityComparer Instance { get; }

        public bool Equals(Quaternion expected, Quaternion actual);
        public int GetHashCode(Quaternion quaternion);
    }
}
namespace UnityEngine.TestTools.Utils
{
    public static class Utils
    {
        public static bool AreFloatsEqual(float expected, float actual, float epsilon);
        public static bool AreFloatsEqualAbsoluteError(float expected, float actual, float allowedAbsoluteError);
        public static GameObject CreatePrimitive(PrimitiveType type);
    }
}
using System.Collections.Generic;

namespace UnityEngine.TestTools.Utils
{
    public class Vector2ComparerWithEqualsOperator : IEqualityComparer<Vector2>
    {
        public static Vector2ComparerWithEqualsOperator Instance { get; }

        public bool Equals(Vector2 expected, Vector2 actual);
        public int GetHashCode(Vector2 vec2);
    }
}
using System.Collections.Generic;

namespace UnityEngine.TestTools.Utils
{
    public class Vector2EqualityComparer : IEqualityComparer<Vector2>
    {
        public Vector2EqualityComparer(float error);

        public static Vector2EqualityComparer Instance { get; }

        public bool Equals(Vector2 expected, Vector2 actual);
        public int GetHashCode(Vector2 vec2);
    }
}
using System.Collections.Generic;

namespace UnityEngine.TestTools.Utils
{
    public class Vector3ComparerWithEqualsOperator : IEqualityComparer<Vector3>
    {
        public static Vector3ComparerWithEqualsOperator Instance { get; }

        public bool Equals(Vector3 expected, Vector3 actual);
        public int GetHashCode(Vector3 vec3);
    }
}
using System.Collections.Generic;

namespace UnityEngine.TestTools.Utils
{
    public class Vector3EqualityComparer : IEqualityComparer<Vector3>
    {
        public Vector3EqualityComparer(float allowedError);

        public static Vector3EqualityComparer Instance { get; }

        public bool Equals(Vector3 expected, Vector3 actual);
        public int GetHashCode(Vector3 vec3);
    }
}
using System.Collections.Generic;

namespace UnityEngine.TestTools.Utils
{
    public class Vector4ComparerWithEqualsOperator : IEqualityComparer<Vector4>
    {
        public static Vector4ComparerWithEqualsOperator Instance { get; }

        public bool Equals(Vector4 expected, Vector4 actual);
        public int GetHashCode(Vector4 vec4);
    }
}
using System.Collections.Generic;

namespace UnityEngine.TestTools.Utils
{
    public class Vector4EqualityComparer : IEqualityComparer<Vector4>
    {
        public Vector4EqualityComparer(float allowedError);

        public static Vector4EqualityComparer Instance { get; }

        public bool Equals(Vector4 expected, Vector4 actual);
        public int GetHashCode(Vector4 vec4);
    }
}
using NUnit.Framework.Constraints;

namespace UnityEngine.TestTools.Constraints
{
    public class AllocatingGCMemoryConstraint : Constraint
    {
        public AllocatingGCMemoryConstraint();

        public override string Description { get; }

        public override ConstraintResult ApplyTo(object obj);
        public override ConstraintResult ApplyTo<TActual>(ActualValueDelegate<TActual> del);
    }
}
using NUnit.Framework.Constraints;

namespace UnityEngine.TestTools.Constraints
{
    public static class ConstraintExtensions
    {
        public static AllocatingGCMemoryConstraint AllocatingGCMemory(this ConstraintExpression chain);
    }
}
using NUnit.Framework;

namespace UnityEngine.TestTools.Constraints
{
    public class Is : NUnit.Framework.Is
    {
        public Is();

        public static AllocatingGCMemoryConstraint AllocatingGCMemory();
    }
}
-------- {Unity.Timeline(D:\Documents\GitHub\Rogue-like-game-i-guess\The game is liar\Library\ScriptAssemblies\Unity.Timeline.dll)}:  130 --------
using UnityEngine.Playables;

namespace UnityEngine.Timeline
{
    [TrackClipType(typeof(ActivationPlayableAsset))]
    [TrackBindingType(typeof(GameObject))]
    [ExcludeFromPreset]
    [TimelineHelpURL(typeof(ActivationTrack))]
    public class ActivationTrack : TrackAsset
    {
        public ActivationTrack();

        public PostPlaybackState postPlaybackState { get; set; }

        public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount);
        public override void GatherProperties(PlayableDirector director, IPropertyCollector driver);
        protected override void OnCreateClip(TimelineClip clip);

        public enum PostPlaybackState
        {
            Active = 0,
            Inactive = 1,
            Revert = 2,
            LeaveAsIs = 3
        }
    }
}
using System.Collections.Generic;
using UnityEngine.Playables;

namespace UnityEngine.Timeline
{
    [NotKeyable]
    public class AnimationPlayableAsset : PlayableAsset, ISerializationCallbackReceiver, IPropertyPreview, ITimelineClipAsset
    {
        public AnimationPlayableAsset();

        public Vector3 position { get; set; }
        public Quaternion rotation { get; set; }
        public Vector3 eulerAngles { get; set; }
        public bool useTrackMatchFields { get; set; }
        public MatchTargetFields matchTargetFields { get; set; }
        public bool removeStartOffset { get; set; }
        public bool applyFootIK { get; set; }
        public LoopMode loop { get; set; }
        public AnimationClip clip { get; set; }
        public override double duration { get; }
        public override IEnumerable<PlayableBinding> outputs { get; }
        public ClipCaps clipCaps { get; }

        public override Playable CreatePlayable(PlayableGraph graph, GameObject go);
        public void LiveLink();
        public void ResetOffsets();
        public void GatherProperties(PlayableDirector director, IPropertyCollector driver);

        public enum LoopMode
        {
            [Tooltip("Use the loop time setting from the source AnimationClip.")]
            UseSourceAsset = 0,
            [Tooltip("The source AnimationClip loops during playback.")]
            On = 1,
            [Tooltip("The source AnimationClip does not loop during playback.")]
            Off = 2
        }
    }
}
using System;

namespace UnityEngine.Timeline
{
    [Flags]
    public enum MatchTargetFields
    {
        PositionX = 1,
        PositionY = 2,
        PositionZ = 4,
        RotationX = 8,
        RotationY = 16,
        RotationZ = 32
    }
}
namespace UnityEngine.Timeline
{
    public enum TrackOffset
    {
        ApplyTransformOffsets = 0,
        ApplySceneOffsets = 1,
        Auto = 2
    }
}
using System;
using System.Collections.Generic;
using System.ComponentModel;
using UnityEngine.Playables;

namespace UnityEngine.Timeline
{
    [TrackClipType(typeof(AnimationPlayableAsset), False)]
    [TrackBindingType(typeof(Animator))]
    [ExcludeFromPreset]
    [TimelineHelpURL(typeof(AnimationTrack))]
    public class AnimationTrack : TrackAsset, ILayerable
    {
        public AnimationTrack();

        public Vector3 position { get; set; }
        public Quaternion rotation { get; set; }
        public Vector3 eulerAngles { get; set; }
        [Obsolete("applyOffset is deprecated. Use trackOffset instead", True)]
        public bool applyOffsets { get; set; }
        public TrackOffset trackOffset { get; set; }
        public MatchTargetFields matchTargetFields { get; set; }
        public AnimationClip infiniteClip { get; }
        public AvatarMask avatarMask { get; set; }
        public bool applyAvatarMask { get; set; }
        public override IEnumerable<PlayableBinding> outputs { get; }
        public bool inClipMode { get; }
        public Vector3 infiniteClipOffsetPosition { get; set; }
        public Quaternion infiniteClipOffsetRotation { get; set; }
        public Vector3 infiniteClipOffsetEulerAngles { get; set; }
        public TimelineClip.ClipExtrapolation infiniteClipPreExtrapolation { get; set; }
        public TimelineClip.ClipExtrapolation infiniteClipPostExtrapolation { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("openClipOffsetPosition has been deprecated. Use infiniteClipOffsetPosition instead. (UnityUpgradable) -> infiniteClipOffsetPosition", True)]
        public Vector3 openClipOffsetPosition { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("openClipOffsetRotation has been deprecated. Use infiniteClipOffsetRotation instead. (UnityUpgradable) -> infiniteClipOffsetRotation", True)]
        public Quaternion openClipOffsetRotation { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("openClipOffsetEulerAngles has been deprecated. Use infiniteClipOffsetEulerAngles instead. (UnityUpgradable) -> infiniteClipOffsetEulerAngles", True)]
        public Vector3 openClipOffsetEulerAngles { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("openClipPreExtrapolation has been deprecated. Use infiniteClipPreExtrapolation instead. (UnityUpgradable) -> infiniteClipPreExtrapolation", True)]
        public TimelineClip.ClipExtrapolation openClipPreExtrapolation { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("openClipPostExtrapolation has been deprecated. Use infiniteClipPostExtrapolation instead. (UnityUpgradable) -> infiniteClipPostExtrapolation", True)]
        public TimelineClip.ClipExtrapolation openClipPostExtrapolation { get; set; }

        public TimelineClip CreateClip(AnimationClip clip);
        public void CreateInfiniteClip(string infiniteClipName);
        public TimelineClip CreateRecordableClip(string animClipName);
        protected override void OnCreateClip(TimelineClip clip);
        protected internal override int CalculateItemsHash();
        public override void GatherProperties(PlayableDirector director, IPropertyCollector driver);
    }
}
using System;
using System.Collections.Generic;

namespace UnityEngine.Timeline
{
    public class TimelineClip : ISerializationCallbackReceiver, ICurvesOwner
    {
        public static readonly ClipCaps kDefaultClipCaps;
        public static readonly float kDefaultClipDurationInSeconds;
        public static readonly double kTimeScaleMin;
        public static readonly double kTimeScaleMax;

        public bool hasPreExtrapolation { get; }
        public bool hasPostExtrapolation { get; }
        public double timeScale { get; set; }
        public double start { get; set; }
        public double duration { get; set; }
        public double end { get; }
        public double clipIn { get; set; }
        public string displayName { get; set; }
        public double clipAssetDuration { get; }
        public AnimationClip curves { get; }
        public bool hasCurves { get; }
        public Object asset { get; set; }
        [Obsolete("underlyingAsset property is obsolete. Use asset property instead", True)]
        public Object underlyingAsset { get; set; }
        [Obsolete("parentTrack is deprecated and will be removed in a future release. Use GetParentTrack() and TimelineClipExtensions::MoveToTrack() or TimelineClipExtensions::TryMoveToTrack() instead.", False)]
        public TrackAsset parentTrack { get; set; }
        public double easeInDuration { get; set; }
        public double easeOutDuration { get; set; }
        [Obsolete("Use easeOutTime instead (UnityUpgradable) -> easeOutTime", True)]
        public double eastOutTime { get; }
        public double easeOutTime { get; }
        public double blendInDuration { get; set; }
        public double blendOutDuration { get; set; }
        public BlendCurveMode blendInCurveMode { get; set; }
        public BlendCurveMode blendOutCurveMode { get; set; }
        public bool hasBlendIn { get; }
        public bool hasBlendOut { get; }
        public AnimationCurve mixInCurve { get; set; }
        public float mixInPercentage { get; }
        public double mixInDuration { get; }
        public AnimationCurve mixOutCurve { get; set; }
        public double mixOutTime { get; }
        public double mixOutDuration { get; }
        public float mixOutPercentage { get; }
        public bool recordable { get; }
        [Obsolete("exposedParameter is deprecated and will be removed in a future release", True)]
        public List<string> exposedParameters { get; }
        public ClipCaps clipCaps { get; }
        public AnimationClip animationClip { get; }
        public ClipExtrapolation postExtrapolationMode { get; }
        public ClipExtrapolation preExtrapolationMode { get; }
        public double extrapolatedStart { get; }
        public double extrapolatedDuration { get; }

        public TrackAsset GetParentTrack();
        public float EvaluateMixOut(double time);
        public float EvaluateMixIn(double time);
        public double ToLocalTime(double time);
        public double ToLocalTimeUnbound(double time);
        public bool IsExtrapolatedTime(double sequenceTime);
        public bool IsPreExtrapolatedTime(double sequenceTime);
        public bool IsPostExtrapolatedTime(double sequenceTime);
        public void CreateCurves(string curvesClipName);
        public override string ToString();
        public void ConformEaseValues();

        public enum ClipExtrapolation
        {
            None = 0,
            Hold = 1,
            Loop = 2,
            PingPong = 3,
            Continue = 4
        }
        public enum BlendCurveMode
        {
            Auto = 0,
            Manual = 1
        }
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.Playables;

namespace UnityEngine.Timeline
{
    [ExcludeFromPreset]
    [TimelineHelpURL(typeof(TimelineAsset))]
    public class TimelineAsset : PlayableAsset, ISerializationCallbackReceiver, IPropertyPreview, ITimelineClipAsset
    {
        public TimelineAsset();

        public EditorSettings editorSettings { get; }
        public override double duration { get; }
        public double fixedDuration { get; set; }
        public DurationMode durationMode { get; set; }
        public override IEnumerable<PlayableBinding> outputs { get; }
        public ClipCaps clipCaps { get; }
        public int outputTrackCount { get; }
        public int rootTrackCount { get; }
        public MarkerTrack markerTrack { get; }

        public TrackAsset GetRootTrack(int index);
        public IEnumerable<TrackAsset> GetRootTracks();
        public TrackAsset GetOutputTrack(int index);
        public IEnumerable<TrackAsset> GetOutputTracks();
        public override Playable CreatePlayable(PlayableGraph graph, GameObject go);
        public void GatherProperties(PlayableDirector director, IPropertyCollector driver);
        public void CreateMarkerTrack();
        public TrackAsset CreateTrack(Type type, TrackAsset parent, string name);
        public T CreateTrack<T>(TrackAsset parent, string trackName) where T : TrackAsset, new();
        public T CreateTrack<T>(string trackName) where T : TrackAsset, new();
        public T CreateTrack<T>() where T : TrackAsset, new();
        public bool DeleteClip(TimelineClip clip);
        public bool DeleteTrack(TrackAsset track);

        [Obsolete("MediaType has been deprecated. It is no longer required, and will be removed in a future release.", False)]
        public enum MediaType
        {
            Animation = 0,
            Audio = 1,
            Texture = 2,
            [Obsolete("Use Texture MediaType instead. (UnityUpgradable) -> UnityEngine.Timeline.TimelineAsset/MediaType.Texture", False)]
            Video = 2,
            Script = 3,
            Hybrid = 4,
            Group = 5
        }
        public enum DurationMode
        {
            BasedOnClips = 0,
            FixedLength = 1
        }
        public class EditorSettings
        {
            public EditorSettings();

            [Obsolete("EditorSettings.fps has been deprecated. Use editorSettings.frameRate instead.", False)]
            public float fps { get; set; }
            public double frameRate { get; set; }
            public bool scenePreview { get; set; }

            public void SetStandardFrameRate(StandardFrameRates enumValue);
        }
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.Playables;

namespace UnityEngine.Timeline
{
    [IgnoreOnPlayableTrack]
    public abstract class TrackAsset : PlayableAsset, ISerializationCallbackReceiver, ICurvesOwner, IPropertyPreview
    {
        [SerializeField]
        [HideInInspector]
        protected internal List<TimelineClip> m_Clips;

        protected TrackAsset();

        public double start { get; }
        public double end { get; }
        public sealed override double duration { get; }
        public bool muted { get; set; }
        public bool mutedInHierarchy { get; }
        public TimelineAsset timelineAsset { get; }
        public PlayableAsset parent { get; }
        public virtual bool isEmpty { get; }
        public bool hasClips { get; }
        public bool hasCurves { get; }
        public bool isSubTrack { get; }
        public override IEnumerable<PlayableBinding> outputs { get; }
        public AnimationClip curves { get; }
        public bool locked { get; set; }
        public bool lockedInHierarchy { get; }
        public bool supportsNotifications { get; }

        protected virtual void OnBeforeTrackSerialize();
        protected virtual void OnAfterTrackDeserialize();
        public IEnumerable<TimelineClip> GetClips();
        public IEnumerable<TrackAsset> GetChildTracks();
        public void CreateCurves(string curvesClipName);
        public virtual Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount);
        public sealed override Playable CreatePlayable(PlayableGraph graph, GameObject go);
        public TimelineClip CreateDefaultClip();
        public TimelineClip CreateClip<T>() where T : ScriptableObject, IPlayableAsset;
        public bool DeleteClip(TimelineClip clip);
        public IMarker CreateMarker(Type type, double time);
        public T CreateMarker<T>(double time) where T : ScriptableObject, IMarker;
        public bool DeleteMarker(IMarker marker);
        public IEnumerable<IMarker> GetMarkers();
        public int GetMarkerCount();
        public IMarker GetMarker(int idx);
        public virtual void GatherProperties(PlayableDirector director, IPropertyCollector driver);
        protected virtual void OnCreateClip(TimelineClip clip);
        protected internal virtual int CalculateItemsHash();
        protected virtual Playable CreatePlayable(PlayableGraph graph, GameObject gameObject, TimelineClip clip);
        public virtual bool CanCreateTrackMixer();
        protected static int GetAnimationClipHash(AnimationClip clip);
    }
}
using System;

namespace UnityEngine.Timeline
{
    [AttributeUsage(Class)]
    public class TrackColorAttribute : Attribute
    {
        public TrackColorAttribute(float r, float g, float b);

        public Color color { get; }
    }
}
using System.Collections.Generic;
using System.ComponentModel;
using UnityEngine.Playables;

namespace UnityEngine.Timeline
{
    [DisplayName("Audio Clip")]
    public class AudioPlayableAsset : PlayableAsset, ITimelineClipAsset
    {
        public AudioPlayableAsset();

        public AudioClip clip { get; set; }
        public bool loop { get; set; }
        public override double duration { get; }
        public override IEnumerable<PlayableBinding> outputs { get; }
        public ClipCaps clipCaps { get; }

        public override Playable CreatePlayable(PlayableGraph graph, GameObject go);
    }
}
using System.Collections.Generic;
using UnityEngine.Playables;

namespace UnityEngine.Timeline
{
    [TrackClipType(typeof(AudioPlayableAsset), False)]
    [TrackBindingType(typeof(AudioSource))]
    [ExcludeFromPreset]
    [TimelineHelpURL(typeof(AudioTrack))]
    public class AudioTrack : TrackAsset
    {
        public AudioTrack();

        public override IEnumerable<PlayableBinding> outputs { get; }

        public TimelineClip CreateClip(AudioClip clip);
    }
}
using System;

namespace UnityEngine.Timeline
{
    [Flags]
    public enum ClipCaps
    {
        None = 0,
        Looping = 1,
        Extrapolation = 2,
        ClipIn = 4,
        SpeedMultiplier = 8,
        Blending = 16,
        AutoScale = 40,
        All = -1
    }
}
using UnityEngine.Playables;

namespace UnityEngine.Timeline
{
    [NotKeyable]
    public class ControlPlayableAsset : PlayableAsset, IPropertyPreview, ITimelineClipAsset
    {
        [SerializeField]
        public ExposedReference<GameObject> sourceGameObject;
        [SerializeField]
        public GameObject prefabGameObject;
        [SerializeField]
        public bool updateParticle;
        [SerializeField]
        public uint particleRandomSeed;
        [SerializeField]
        public bool updateDirector;
        [SerializeField]
        public bool updateITimeControl;
        [SerializeField]
        public bool searchHierarchy;
        [SerializeField]
        public bool active;
        [SerializeField]
        public ActivationControlPlayable.PostPlaybackState postPlayback;

        public ControlPlayableAsset();

        public override double duration { get; }
        public ClipCaps clipCaps { get; }

        public void OnEnable();
        public override Playable CreatePlayable(PlayableGraph graph, GameObject go);
        public void GatherProperties(PlayableDirector director, IPropertyCollector driver);
    }
}
using UnityEngine.Playables;

namespace UnityEngine.Timeline
{
    [TrackClipType(typeof(ControlPlayableAsset), False)]
    [ExcludeFromPreset]
    [TimelineHelpURL(typeof(ControlTrack))]
    public class ControlTrack : TrackAsset
    {
        public ControlTrack();

        public override void GatherProperties(PlayableDirector director, IPropertyCollector driver);
    }
}
namespace UnityEngine.Timeline
{
    public interface IMarker
    {
        double time { get; set; }
        TrackAsset parent { get; }

        void Initialize(TrackAsset parent);
    }
}
namespace UnityEngine.Timeline
{
    public interface INotificationOptionProvider
    {
        NotificationFlags flags { get; }
    }
}
namespace UnityEngine.Timeline
{
    public abstract class Marker : ScriptableObject, IMarker
    {
        protected Marker();

        public TrackAsset parent { get; }
        public double time { get; set; }

        public virtual void OnInitialize(TrackAsset aPent);
    }
}
using System.Collections.Generic;
using UnityEngine.Playables;

namespace UnityEngine.Timeline
{
    [TrackBindingType(typeof(GameObject))]
    [HideInMenu]
    [ExcludeFromPreset]
    [TimelineHelpURL(typeof(MarkerTrack))]
    public class MarkerTrack : TrackAsset
    {
        public MarkerTrack();

        public override IEnumerable<PlayableBinding> outputs { get; }
    }
}
namespace UnityEngine.Timeline
{
    [TrackBindingType(typeof(SignalReceiver))]
    [TrackColor(0.25F, 0.25F, 0.25F)]
    [ExcludeFromPreset]
    [TimelineHelpURL(typeof(SignalTrack))]
    public class SignalTrack : MarkerTrack
    {
        public SignalTrack();
    }
}
namespace UnityEngine.Timeline
{
    [AssetFileNameExtension("signal", new[] { })]
    [TimelineHelpURL(typeof(SignalAsset))]
    public class SignalAsset : ScriptableObject
    {
        public SignalAsset();
    }
}
using UnityEngine.Playables;

namespace UnityEngine.Timeline
{
    [CustomStyle("SignalEmitter")]
    [ExcludeFromPreset]
    [TimelineHelpURL(typeof(SignalEmitter))]
    public class SignalEmitter : Marker, INotificationOptionProvider, INotification
    {
        public SignalEmitter();

        public bool retroactive { get; set; }
        public bool emitOnce { get; set; }
        public SignalAsset asset { get; set; }
    }
}
using System.Collections.Generic;
using UnityEngine.Events;
using UnityEngine.Playables;

namespace UnityEngine.Timeline
{
    [TimelineHelpURL(typeof(SignalReceiver))]
    public class SignalReceiver : MonoBehaviour, INotificationReceiver
    {
        public SignalReceiver();

        public void OnNotify(Playable origin, INotification notification, object context);
        public void AddReaction(SignalAsset asset, UnityEvent reaction);
        public int AddEmptyReaction(UnityEvent reaction);
        public void Remove(SignalAsset asset);
        public IEnumerable<SignalAsset> GetRegisteredSignals();
        public UnityEvent GetReaction(SignalAsset key);
        public int Count();
        public void ChangeSignalAtIndex(int idx, SignalAsset newKey);
        public void RemoveAtIndex(int idx);
        public void ChangeReactionAtIndex(int idx, UnityEvent reaction);
        public UnityEvent GetReactionAtIndex(int idx);
        public SignalAsset GetSignalAssetAtIndex(int idx);
    }
}
namespace UnityEngine.Timeline
{
    public static class TrackAssetExtensions
    {
        public static GroupTrack GetGroup(this TrackAsset asset);
        public static void SetGroup(this TrackAsset asset, GroupTrack group);
    }
}
using System.Collections.Generic;
using UnityEngine.Playables;

namespace UnityEngine.Timeline
{
    [TrackClipType(typeof(TrackAsset))]
    [SupportsChildTracks(null, 2147483647)]
    [ExcludeFromPreset]
    [TimelineHelpURL(typeof(GroupTrack))]
    public class GroupTrack : TrackAsset
    {
        public GroupTrack();

        public override IEnumerable<PlayableBinding> outputs { get; }
    }
}
using UnityEngine.Playables;

namespace UnityEngine.Timeline
{
    public interface ILayerable
    {
        Playable CreateLayerMixer(PlayableGraph graph, GameObject go, int inputCount);
    }
}
using UnityEngine.Playables;

namespace UnityEngine.Timeline
{
    public class ActivationControlPlayable : PlayableBehaviour
    {
        public GameObject gameObject;
        public PostPlaybackState postPlayback;

        public ActivationControlPlayable();

        public static ScriptPlayable<ActivationControlPlayable> Create(PlayableGraph graph, GameObject gameObject, PostPlaybackState postPlaybackState);
        public override void OnBehaviourPlay(Playable playable, FrameData info);
        public override void OnBehaviourPause(Playable playable, FrameData info);
        public override void ProcessFrame(Playable playable, FrameData info, object userData);
        public override void OnGraphStart(Playable playable);
        public override void OnPlayableDestroy(Playable playable);

        public enum PostPlaybackState
        {
            Active = 0,
            Inactive = 1,
            Revert = 2
        }
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.Playables;

namespace UnityEngine.Timeline
{
    [Obsolete("For best performance use PlayableAsset and PlayableBehaviour.")]
    public class BasicPlayableBehaviour : ScriptableObject, IPlayableBehaviour, IPlayableAsset
    {
        public BasicPlayableBehaviour();

        public virtual double duration { get; }
        public virtual IEnumerable<PlayableBinding> outputs { get; }

        public virtual void OnGraphStart(Playable playable);
        public virtual void OnGraphStop(Playable playable);
        public virtual void OnPlayableCreate(Playable playable);
        public virtual void OnPlayableDestroy(Playable playable);
        public virtual void OnBehaviourPlay(Playable playable, FrameData info);
        public virtual void OnBehaviourPause(Playable playable, FrameData info);
        public virtual void PrepareFrame(Playable playable, FrameData info);
        public virtual void ProcessFrame(Playable playable, FrameData info, object playerData);
        public virtual Playable CreatePlayable(PlayableGraph graph, GameObject owner);
    }
}
using UnityEngine.Playables;

namespace UnityEngine.Timeline
{
    public class DirectorControlPlayable : PlayableBehaviour
    {
        public PlayableDirector director;

        public DirectorControlPlayable();

        public static ScriptPlayable<DirectorControlPlayable> Create(PlayableGraph graph, PlayableDirector director);
        public override void OnPlayableDestroy(Playable playable);
        public override void PrepareFrame(Playable playable, FrameData info);
        public override void OnBehaviourPlay(Playable playable, FrameData info);
        public override void OnBehaviourPause(Playable playable, FrameData info);
        public override void ProcessFrame(Playable playable, FrameData info, object playerData);
    }
}
namespace UnityEngine.Timeline
{
    public interface ITimeControl
    {
        void SetTime(double time);
        void OnControlTimeStart();
        void OnControlTimeStop();
    }
}
using System;

namespace UnityEngine.Timeline
{
    [Flags]
    public enum NotificationFlags
    {
        TriggerInEditMode = 1,
        Retroactive = 2,
        TriggerOnce = 4
    }
}
using UnityEngine.Playables;

namespace UnityEngine.Timeline
{
    public class ParticleControlPlayable : PlayableBehaviour
    {
        public ParticleControlPlayable();

        public ParticleSystem particleSystem { get; }

        public static ScriptPlayable<ParticleControlPlayable> Create(PlayableGraph graph, ParticleSystem component, uint randomSeed);
        public void Initialize(ParticleSystem ps, uint randomSeed);
        public override void OnPlayableDestroy(Playable playable);
        public override void PrepareFrame(Playable playable, FrameData data);
        public override void OnBehaviourPlay(Playable playable, FrameData info);
        public override void OnBehaviourPause(Playable playable, FrameData info);
    }
}
using UnityEngine.Playables;

namespace UnityEngine.Timeline
{
    public class PrefabControlPlayable : PlayableBehaviour
    {
        public PrefabControlPlayable();

        public GameObject prefabInstance { get; }

        public static ScriptPlayable<PrefabControlPlayable> Create(PlayableGraph graph, GameObject prefabGameObject, Transform parentTransform);
        public GameObject Initialize(GameObject prefabGameObject, Transform parentTransform);
        public override void OnPlayableDestroy(Playable playable);
        public override void OnBehaviourPlay(Playable playable, FrameData info);
        public override void OnBehaviourPause(Playable playable, FrameData info);
    }
}
using UnityEngine.Playables;

namespace UnityEngine.Timeline
{
    public class TimeControlPlayable : PlayableBehaviour
    {
        public TimeControlPlayable();

        public static ScriptPlayable<TimeControlPlayable> Create(PlayableGraph graph, ITimeControl timeControl);
        public void Initialize(ITimeControl timeControl);
        public override void PrepareFrame(Playable playable, FrameData info);
        public override void OnBehaviourPlay(Playable playable, FrameData info);
        public override void OnBehaviourPause(Playable playable, FrameData info);
    }
}
using UnityEngine.Playables;

namespace UnityEngine.Timeline
{
    public class TimeNotificationBehaviour : PlayableBehaviour
    {
        public TimeNotificationBehaviour();

        public Playable timeSource { set; }

        public static ScriptPlayable<TimeNotificationBehaviour> Create(PlayableGraph graph, double duration, DirectorWrapMode loopMode);
        public void AddNotification(double time, INotification payload, NotificationFlags flags = Retroactive);
        public override void OnGraphStart(Playable playable);
        public override void OnBehaviourPause(Playable playable, FrameData info);
        public override void PrepareFrame(Playable playable, FrameData info);
    }
}
namespace UnityEngine.Timeline
{
    [TimelineHelpURL(typeof(PlayableTrack))]
    public class PlayableTrack : TrackAsset
    {
        public PlayableTrack();

        protected override void OnCreateClip(TimelineClip clip);
    }
}
using System;

namespace UnityEngine.Timeline
{
    [AttributeUsage(Class)]
    [Obsolete("TrackMediaType has been deprecated. It is no longer required, and will be removed in a future release.", False)]
    public class TrackMediaType : Attribute
    {
        public readonly TimelineAsset.MediaType m_MediaType;

        public TrackMediaType(TimelineAsset.MediaType mt);
    }
}
using System;

namespace UnityEngine.Timeline
{
    [AttributeUsage(Class, AllowMultiple = True)]
    public class TrackClipTypeAttribute : Attribute
    {
        public readonly Type inspectedType;
        public readonly bool allowAutoCreate;

        public TrackClipTypeAttribute(Type clipClass);
        public TrackClipTypeAttribute(Type clipClass, bool allowAutoCreate);
    }
}
using System;

namespace UnityEngine.Timeline
{
    [AttributeUsage(Class, Field)]
    public class NotKeyableAttribute : Attribute
    {
        public NotKeyableAttribute();
    }
}
using System;

namespace UnityEngine.Timeline
{
    [Flags]
    public enum TrackBindingFlags
    {
        None = 0,
        AllowCreateComponent = 1,
        All = 1
    }
}
using System;

namespace UnityEngine.Timeline
{
    [AttributeUsage(Class)]
    public class TrackBindingTypeAttribute : Attribute
    {
        public readonly Type type;
        public readonly TrackBindingFlags flags;

        public TrackBindingTypeAttribute(Type type);
        public TrackBindingTypeAttribute(Type type, TrackBindingFlags flags);
    }
}
using System;

namespace UnityEngine.Timeline
{
    [AttributeUsage(Class, Inherited = False)]
    public class HideInMenuAttribute : Attribute
    {
        public HideInMenuAttribute();
    }
}
using System;

namespace UnityEngine.Timeline
{
    [AttributeUsage(Class)]
    public class CustomStyleAttribute : Attribute
    {
        public readonly string ussStyle;

        public CustomStyleAttribute(string ussStyle);
    }
}
namespace UnityEngine.Timeline
{
    public interface ITimelineClipAsset
    {
        ClipCaps clipCaps { get; }
    }
}
using System.Collections.Generic;
using UnityEngine.Playables;

namespace UnityEngine.Timeline
{
    public class TimelinePlayable : PlayableBehaviour
    {
        public TimelinePlayable();

        public static ScriptPlayable<TimelinePlayable> Create(PlayableGraph graph, IEnumerable<TrackAsset> tracks, GameObject go, bool autoRebalance, bool createOutputs);
        public void Compile(PlayableGraph graph, Playable timelinePlayable, IEnumerable<TrackAsset> tracks, GameObject go, bool autoRebalance, bool createOutputs);
        public override void PrepareFrame(Playable playable, FrameData info);
    }
}
using System.Collections.Generic;

namespace UnityEngine.Timeline
{
    public interface IPropertyCollector
    {
        void PushActiveGameObject(GameObject gameObject);
        void PopActiveGameObject();
        void AddFromClip(AnimationClip clip);
        void AddFromClips(IEnumerable<AnimationClip> clips);
        void AddFromName<T>(string name) where T : Component;
        void AddFromName(string name);
        void AddFromClip(GameObject obj, AnimationClip clip);
        void AddFromClips(GameObject obj, IEnumerable<AnimationClip> clips);
        void AddFromName<T>(GameObject obj, string name) where T : Component;
        void AddFromName(GameObject obj, string name);
        void AddFromName(Component component, string name);
        void AddFromComponent(GameObject obj, Component component);
        void AddObjectProperties(Object obj, AnimationClip clip);
    }
}
using UnityEngine.Playables;

namespace UnityEngine.Timeline
{
    public interface IPropertyPreview
    {
        void GatherProperties(PlayableDirector director, IPropertyCollector driver);
    }
}
namespace UnityEngine.Timeline
{
    public enum StandardFrameRates
    {
        Fps24 = 0,
        Fps23_97 = 1,
        Fps25 = 2,
        Fps30 = 3,
        Fps29_97 = 4,
        Fps50 = 5,
        Fps60 = 6,
        Fps59_94 = 7
    }
}
namespace UnityEngine.Timeline
{
    public static class TimelineClipExtensions
    {
        public static void MoveToTrack(this TimelineClip clip, TrackAsset destinationTrack);
        public static bool TryMoveToTrack(this TimelineClip clip, TrackAsset destinationTrack);
    }
}
-------- {Unity.TextMeshPro(D:\Documents\GitHub\Rogue-like-game-i-guess\The game is liar\Library\ScriptAssemblies\Unity.TextMeshPro.dll)}:  174 --------
using System;

namespace TMPro
{
    public class FastAction
    {
        public FastAction();

        public void Add(Action rhs);
        public void Remove(Action rhs);
        public void Call();
    }
}
using System;

namespace TMPro
{
    public class FastAction<A>
    {
        public FastAction();

        public void Add(Action<A> rhs);
        public void Remove(Action<A> rhs);
        public void Call(A a);
    }
}
using System;

namespace TMPro
{
    public class FastAction<A, B>
    {
        public FastAction();

        public void Add(Action<A, B> rhs);
        public void Remove(Action<A, B> rhs);
        public void Call(A a, B b);
    }
}
using System;

namespace TMPro
{
    public class FastAction<A, B, C>
    {
        public FastAction();

        public void Add(Action<A, B, C> rhs);
        public void Remove(Action<A, B, C> rhs);
        public void Call(A a, B b, C c);
    }
}
namespace TMPro
{
    public interface ITextPreprocessor
    {
        string PreprocessText(string text);
    }
}
using UnityEngine;

namespace TMPro
{
    public class MaterialReferenceManager
    {
        public MaterialReferenceManager();

        public static MaterialReferenceManager instance { get; }

        public static void AddFontAsset(TMP_FontAsset fontAsset);
        public static void AddSpriteAsset(TMP_SpriteAsset spriteAsset);
        public static void AddSpriteAsset(int hashCode, TMP_SpriteAsset spriteAsset);
        public static void AddFontMaterial(int hashCode, Material material);
        public static void AddColorGradientPreset(int hashCode, TMP_ColorGradient spriteAsset);
        public bool Contains(TMP_FontAsset font);
        public bool Contains(TMP_SpriteAsset sprite);
        public static bool TryGetFontAsset(int hashCode, out TMP_FontAsset fontAsset);
        public static bool TryGetSpriteAsset(int hashCode, out TMP_SpriteAsset spriteAsset);
        public static bool TryGetColorGradientPreset(int hashCode, out TMP_ColorGradient gradientPreset);
        public static bool TryGetMaterial(int hashCode, out Material material);
    }
}
using UnityEngine;

namespace TMPro
{
    public struct TMP_MaterialReference
    {
        public Material material;
        public int referenceCount;
    }
}
using System.Collections.Generic;
using UnityEngine;

namespace TMPro
{
    public struct MaterialReference
    {
        public int index;
        public TMP_FontAsset fontAsset;
        public TMP_SpriteAsset spriteAsset;
        public Material material;
        public bool isDefaultMaterial;
        public bool isFallbackMaterial;
        public Material fallbackMaterial;
        public float padding;
        public int referenceCount;

        public MaterialReference(int index, TMP_FontAsset fontAsset, TMP_SpriteAsset spriteAsset, Material material, float padding);

        public static bool Contains(MaterialReference[] materialReferences, TMP_FontAsset fontAsset);
        public static int AddMaterialReference(Material material, TMP_FontAsset fontAsset, ref MaterialReference[] materialReferences, Dictionary<int, int> materialReferenceIndexLookup);
        public static int AddMaterialReference(Material material, TMP_SpriteAsset spriteAsset, ref MaterialReference[] materialReferences, Dictionary<int, int> materialReferenceIndexLookup);
    }
}
using UnityEngine;

namespace TMPro
{
    public abstract class TMP_Asset : ScriptableObject
    {
        public int hashCode;
        public Material material;
        public int materialHashCode;

        protected TMP_Asset();

        public int instanceID { get; }
    }
}
using UnityEngine.TextCore;

namespace TMPro
{
    public class TMP_Character : TMP_TextElement
    {
        public TMP_Character();
        public TMP_Character(uint unicode, Glyph glyph);
        public TMP_Character(uint unicode, TMP_FontAsset fontAsset, Glyph glyph);
    }
}
using UnityEngine;

namespace TMPro
{
    public struct TMP_Vertex
    {
        public Vector3 position;
        public Vector2 uv;
        public Vector2 uv2;
        public Vector2 uv4;
        public Color32 color;

        public static TMP_Vertex zero { get; }
    }
}
namespace TMPro
{
    public struct TMP_Offset
    {
        public TMP_Offset(float left, float right, float top, float bottom);
        public TMP_Offset(float horizontal, float vertical);

        public float left { get; set; }
        public float right { get; set; }
        public float top { get; set; }
        public float bottom { get; set; }
        public float horizontal { get; set; }
        public float vertical { get; set; }
        public static TMP_Offset zero { get; }

        public override int GetHashCode();
        public override bool Equals(object obj);
        public bool Equals(TMP_Offset other);

        public static bool operator ==(TMP_Offset lhs, TMP_Offset rhs);
        public static bool operator !=(TMP_Offset lhs, TMP_Offset rhs);
        public static TMP_Offset operator *(TMP_Offset a, float b);
    }
}
using UnityEngine;

namespace TMPro
{
    public struct HighlightState
    {
        public Color32 color;
        public TMP_Offset padding;

        public HighlightState(Color32 color, TMP_Offset padding);

        public override int GetHashCode();
        public override bool Equals(object obj);
        public bool Equals(HighlightState other);

        public static bool operator ==(HighlightState lhs, HighlightState rhs);
        public static bool operator !=(HighlightState lhs, HighlightState rhs);
    }
}
using System.Diagnostics;
using UnityEngine;

namespace TMPro
{
    [DebuggerDisplay("Unicode '{character}'  ({((uint)character).ToString(\"X\")})")]
    public struct TMP_CharacterInfo
    {
        public char character;
        public int index;
        public int stringLength;
        public TMP_TextElementType elementType;
        public TMP_TextElement textElement;
        public TMP_FontAsset fontAsset;
        public TMP_SpriteAsset spriteAsset;
        public int spriteIndex;
        public Material material;
        public int materialReferenceIndex;
        public bool isUsingAlternateTypeface;
        public float pointSize;
        public int lineNumber;
        public int pageNumber;
        public int vertexIndex;
        public TMP_Vertex vertex_BL;
        public TMP_Vertex vertex_TL;
        public TMP_Vertex vertex_TR;
        public TMP_Vertex vertex_BR;
        public Vector3 topLeft;
        public Vector3 bottomLeft;
        public Vector3 topRight;
        public Vector3 bottomRight;
        public float origin;
        public float xAdvance;
        public float ascender;
        public float baseLine;
        public float descender;
        public float aspectRatio;
        public float scale;
        public Color32 color;
        public Color32 underlineColor;
        public int underlineVertexIndex;
        public Color32 strikethroughColor;
        public int strikethroughVertexIndex;
        public Color32 highlightColor;
        public HighlightState highlightState;
        public FontStyles style;
        public bool isVisible;
    }
}
namespace TMPro
{
    public enum ColorMode
    {
        Single = 0,
        HorizontalGradient = 1,
        VerticalGradient = 2,
        FourCornersGradient = 3
    }
}
using UnityEngine;

namespace TMPro
{
    [ExcludeFromPreset]
    public class TMP_ColorGradient : ScriptableObject
    {
        public ColorMode colorMode;
        public Color topLeft;
        public Color topRight;
        public Color bottomLeft;
        public Color bottomRight;

        public TMP_ColorGradient();
        public TMP_ColorGradient(Color color);
        public TMP_ColorGradient(Color color0, Color color1, Color color2, Color color3);
    }
}
namespace TMPro
{
    public static class TMP_Compatibility
    {
        public static TextAlignmentOptions ConvertTextAlignmentEnumValues(TextAlignmentOptions oldValue);

        public enum AnchorPositions
        {
            TopLeft = 0,
            Top = 1,
            TopRight = 2,
            Left = 3,
            Center = 4,
            Right = 5,
            BottomLeft = 6,
            Bottom = 7,
            BottomRight = 8,
            BaseLine = 9,
            None = 10
        }
    }
}
using UnityEngine;

namespace TMPro
{
    public static class TMP_DefaultControls
    {
        public static GameObject CreateScrollbar(Resources resources);
        public static GameObject CreateButton(Resources resources);
        public static GameObject CreateText(Resources resources);
        public static GameObject CreateInputField(Resources resources);
        public static GameObject CreateDropdown(Resources resources);

        public struct Resources
        {
            public Sprite standard;
            public Sprite background;
            public Sprite inputField;
            public Sprite knob;
            public Sprite checkmark;
            public Sprite dropdown;
            public Sprite mask;
        }
    }
}
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.UI;

namespace TMPro
{
    [AddComponentMenu("UI/Dropdown - TextMeshPro", 35)]
    [RequireComponent(typeof(RectTransform))]
    public class TMP_Dropdown : Selectable, ISubmitHandler, IPointerClickHandler, ICancelHandler
    {
        protected TMP_Dropdown();

        public RectTransform template { get; set; }
        public TMP_Text captionText { get; set; }
        public Image captionImage { get; set; }
        public Graphic placeholder { get; set; }
        public TMP_Text itemText { get; set; }
        public Image itemImage { get; set; }
        public List<OptionData> options { get; set; }
        public DropdownEvent onValueChanged { get; set; }
        public float alphaFadeSpeed { get; set; }
        public int value { get; set; }
        public bool IsExpanded { get; }

        public void SetValueWithoutNotify(int input);
        protected override void Awake();
        protected override void Start();
        protected override void OnValidate();
        protected override void OnDisable();
        public void RefreshShownValue();
        public void AddOptions(List<OptionData> options);
        public void AddOptions(List<string> options);
        public void AddOptions(List<Sprite> options);
        public void ClearOptions();
        public virtual void OnPointerClick(PointerEventData eventData);
        public virtual void OnSubmit(BaseEventData eventData);
        public virtual void OnCancel(BaseEventData eventData);
        public void Show();
        protected virtual GameObject CreateBlocker(Canvas rootCanvas);
        protected virtual void DestroyBlocker(GameObject blocker);
        protected virtual GameObject CreateDropdownList(GameObject template);
        protected virtual void DestroyDropdownList(GameObject dropdownList);
        protected virtual DropdownItem CreateItem(DropdownItem itemTemplate);
        protected virtual void DestroyItem(DropdownItem item);
        public void Hide();

        protected internal class DropdownItem : MonoBehaviour, IEventSystemHandler, IPointerEnterHandler, ICancelHandler
        {
            public DropdownItem();

            public TMP_Text text { get; set; }
            public Image image { get; set; }
            public RectTransform rectTransform { get; set; }
            public Toggle toggle { get; set; }

            public virtual void OnPointerEnter(PointerEventData eventData);
            public virtual void OnCancel(BaseEventData eventData);
        }
        public class OptionData
        {
            public OptionData();
            public OptionData(string text);
            public OptionData(Sprite image);
            public OptionData(string text, Sprite image);

            public string text { get; set; }
            public Sprite image { get; set; }
        }
        public class OptionDataList
        {
            public OptionDataList();

            public List<OptionData> options { get; set; }
        }
        public class DropdownEvent : UnityEvent<int>
        {
            public DropdownEvent();
        }
    }
}
namespace TMPro
{
    public class TMP_EditorResourceManager
    {
        public static TMP_EditorResourceManager instance { get; }
    }
}
namespace TMPro
{
    public enum AtlasPopulationMode
    {
        Static = 0,
        Dynamic = 1
    }
}
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.TextCore;
using UnityEngine.TextCore.LowLevel;

namespace TMPro
{
    [ExcludeFromPreset]
    public class TMP_FontAsset : TMP_Asset
    {
        [SerializeField]
        public Texture2D atlas;
        public float normalStyle;
        public float normalSpacingOffset;
        public float boldStyle;
        public float boldSpacing;
        public byte italicStyle;
        public byte tabSize;

        public TMP_FontAsset();

        public string version { get; }
        public Font sourceFontFile { get; }
        public AtlasPopulationMode atlasPopulationMode { get; set; }
        public FaceInfo faceInfo { get; set; }
        public List<Glyph> glyphTable { get; }
        public Dictionary<uint, Glyph> glyphLookupTable { get; }
        public List<TMP_Character> characterTable { get; }
        public Dictionary<uint, TMP_Character> characterLookupTable { get; }
        public Texture2D atlasTexture { get; }
        public Texture2D[] atlasTextures { get; set; }
        public int atlasTextureCount { get; }
        public bool isMultiAtlasTexturesEnabled { get; set; }
        [Obsolete("The fontInfo property and underlying type is now obsolete. Please use the faceInfo property and FaceInfo type instead.")]
        public FaceInfo_Legacy fontInfo { get; }
        public int atlasWidth { get; }
        public int atlasHeight { get; }
        public int atlasPadding { get; }
        public GlyphRenderMode atlasRenderMode { get; }
        public TMP_FontFeatureTable fontFeatureTable { get; }
        public List<TMP_FontAsset> fallbackFontAssetTable { get; set; }
        public FontAssetCreationSettings creationSettings { get; set; }
        public TMP_FontWeightPair[] fontWeightTable { get; }

        public static TMP_FontAsset CreateFontAsset(Font font);
        public static TMP_FontAsset CreateFontAsset(Font font, int samplingPointSize, int atlasPadding, GlyphRenderMode renderMode, int atlasWidth, int atlasHeight, AtlasPopulationMode atlasPopulationMode = Dynamic, bool enableMultiAtlasSupport = True);
        public void ReadFontAssetDefinition();
        public bool HasCharacter(int character);
        public bool HasCharacter(char character, bool searchFallbacks = False, bool tryAddCharacter = False);
        public bool HasCharacters(string text, out List<char> missingCharacters);
        public bool HasCharacters(string text, out uint[] missingCharacters, bool searchFallbacks = False, bool tryAddCharacter = False);
        public bool HasCharacters(string text);
        public static string GetCharacters(TMP_FontAsset fontAsset);
        public static int[] GetCharactersArray(TMP_FontAsset fontAsset);
        public bool TryAddCharacters(uint[] unicodes, bool includeFontFeatures = False);
        public bool TryAddCharacters(uint[] unicodes, out uint[] missingUnicodes, bool includeFontFeatures = False);
        public bool TryAddCharacters(string characters, bool includeFontFeatures = False);
        public bool TryAddCharacters(string characters, out string missingCharacters, bool includeFontFeatures = False);
        public void ClearFontAssetData(bool setAtlasSizeToZero = False);
    }
}
namespace TMPro
{
    public class FaceInfo_Legacy
    {
        public string Name;
        public float PointSize;
        public float Scale;
        public int CharacterCount;
        public float LineHeight;
        public float Baseline;
        public float Ascender;
        public float CapHeight;
        public float Descender;
        public float CenterLine;
        public float SuperscriptOffset;
        public float SubscriptOffset;
        public float SubSize;
        public float Underline;
        public float UnderlineThickness;
        public float strikethrough;
        public float strikethroughThickness;
        public float TabWidth;
        public float Padding;
        public float AtlasWidth;
        public float AtlasHeight;

        public FaceInfo_Legacy();
    }
}
namespace TMPro
{
    public class TMP_Glyph : TMP_TextElement_Legacy
    {
        public TMP_Glyph();

        public static TMP_Glyph Clone(TMP_Glyph source);
    }
}
namespace TMPro
{
    public struct FontAssetCreationSettings
    {
        public string sourceFontFileName;
        public string sourceFontFileGUID;
        public int pointSizeSamplingMode;
        public int pointSize;
        public int padding;
        public int packingMode;
        public int atlasWidth;
        public int atlasHeight;
        public int characterSetSelectionMode;
        public string characterSequence;
        public string referencedFontAssetGUID;
        public string referencedTextAssetGUID;
        public int fontStyle;
        public float fontStyleModifier;
        public int renderMode;
        public bool includeFontFeatures;
    }
}
namespace TMPro
{
    public struct TMP_FontWeightPair
    {
        public TMP_FontAsset regularTypeface;
        public TMP_FontAsset italicTypeface;
    }
}
namespace TMPro
{
    public struct KerningPairKey
    {
        public uint ascii_Left;
        public uint ascii_Right;
        public uint key;

        public KerningPairKey(uint ascii_left, uint ascii_right);
    }
}
namespace TMPro
{
    public struct GlyphValueRecord_Legacy
    {
        public float xPlacement;
        public float yPlacement;
        public float xAdvance;
        public float yAdvance;

        public static GlyphValueRecord_Legacy operator +(GlyphValueRecord_Legacy a, GlyphValueRecord_Legacy b);
    }
}
using UnityEngine.Serialization;

namespace TMPro
{
    public class KerningPair
    {
        [FormerlySerializedAs("XadvanceOffset")]
        public float xOffset;

        public KerningPair();
        public KerningPair(uint left, uint right, float offset);
        public KerningPair(uint firstGlyph, GlyphValueRecord_Legacy firstGlyphAdjustments, uint secondGlyph, GlyphValueRecord_Legacy secondGlyphAdjustments);

        public uint firstGlyph { get; set; }
        public GlyphValueRecord_Legacy firstGlyphAdjustments { get; }
        public uint secondGlyph { get; set; }
        public GlyphValueRecord_Legacy secondGlyphAdjustments { get; }
        public bool ignoreSpacingAdjustments { get; }
    }
}
using System.Collections.Generic;

namespace TMPro
{
    public class KerningTable
    {
        public List<KerningPair> kerningPairs;

        public KerningTable();

        public void AddKerningPair();
        public int AddKerningPair(uint first, uint second, float offset);
        public int AddGlyphPairAdjustmentRecord(uint first, GlyphValueRecord_Legacy firstAdjustments, uint second, GlyphValueRecord_Legacy secondAdjustments);
        public void RemoveKerningPair(int left, int right);
        public void RemoveKerningPair(int index);
        public void SortKerningPairs();
    }
}
using System.Collections.Generic;

namespace TMPro
{
    public static class TMP_FontUtilities
    {
        public static TMP_FontAsset SearchForCharacter(TMP_FontAsset font, uint unicode, out TMP_Character character);
        public static TMP_FontAsset SearchForCharacter(List<TMP_FontAsset> fonts, uint unicode, out TMP_Character character);
    }
}
using System.Collections.Generic;

namespace TMPro
{
    public class TMP_FontAssetUtilities
    {
        public TMP_FontAssetUtilities();

        public static TMP_FontAssetUtilities instance { get; }

        public static TMP_Character GetCharacterFromFontAsset(uint unicode, TMP_FontAsset sourceFontAsset, bool includeFallbacks, FontStyles fontStyle, FontWeight fontWeight, out bool isAlternativeTypeface);
        public static TMP_Character GetCharacterFromFontAssets(uint unicode, TMP_FontAsset sourceFontAsset, List<TMP_FontAsset> fontAssets, bool includeFallbacks, FontStyles fontStyle, FontWeight fontWeight, out bool isAlternativeTypeface);
        public static TMP_SpriteCharacter GetSpriteCharacterFromSpriteAsset(uint unicode, TMP_SpriteAsset spriteAsset, bool includeFallbacks);
    }
}
using System.Collections.Generic;

namespace TMPro
{
    public class TMP_FontFeatureTable
    {
        public TMP_FontFeatureTable();

        public List<TMP_GlyphPairAdjustmentRecord> glyphPairAdjustmentRecords { get; set; }

        public void SortGlyphPairAdjustmentRecords();
    }
}
using System;

namespace TMPro
{
    [Flags]
    public enum FontFeatureLookupFlags
    {
        None = 0,
        IgnoreLigatures = 4,
        IgnoreSpacingAdjustments = 256
    }
}
namespace TMPro
{
    public struct TMP_GlyphValueRecord
    {
        public TMP_GlyphValueRecord(float xPlacement, float yPlacement, float xAdvance, float yAdvance);

        public float xPlacement { get; set; }
        public float yPlacement { get; set; }
        public float xAdvance { get; set; }
        public float yAdvance { get; set; }

        public static TMP_GlyphValueRecord operator +(TMP_GlyphValueRecord a, TMP_GlyphValueRecord b);
    }
}
namespace TMPro
{
    public struct TMP_GlyphAdjustmentRecord
    {
        public TMP_GlyphAdjustmentRecord(uint glyphIndex, TMP_GlyphValueRecord glyphValueRecord);

        public uint glyphIndex { get; set; }
        public TMP_GlyphValueRecord glyphValueRecord { get; set; }
    }
}
namespace TMPro
{
    public class TMP_GlyphPairAdjustmentRecord
    {
        public TMP_GlyphPairAdjustmentRecord(TMP_GlyphAdjustmentRecord firstAdjustmentRecord, TMP_GlyphAdjustmentRecord secondAdjustmentRecord);

        public TMP_GlyphAdjustmentRecord firstAdjustmentRecord { get; set; }
        public TMP_GlyphAdjustmentRecord secondAdjustmentRecord { get; set; }
        public FontFeatureLookupFlags featureLookupFlags { get; set; }
    }
}
namespace TMPro
{
    public struct GlyphPairKey
    {
        public uint firstGlyphIndex;
        public uint secondGlyphIndex;
        public uint key;

        public GlyphPairKey(uint firstGlyphIndex, uint secondGlyphIndex);
    }
}
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.UI;

namespace TMPro
{
    [AddComponentMenu("UI/TextMeshPro - Input Field", 11)]
    public class TMP_InputField : Selectable, IDragHandler, IEndDragHandler, IScrollHandler, ICanvasElement, IUpdateSelectedHandler, ILayoutElement, ISubmitHandler, IPointerClickHandler, IBeginDragHandler
    {
        protected TouchScreenKeyboard m_SoftKeyboard;
        protected RectTransform m_RectTransform;
        [SerializeField]
        protected RectTransform m_TextViewport;
        protected RectMask2D m_TextComponentRectMask;
        protected RectMask2D m_TextViewportRectMask;
        [SerializeField]
        protected TMP_Text m_TextComponent;
        protected RectTransform m_TextComponentRectTransform;
        [SerializeField]
        protected Graphic m_Placeholder;
        [SerializeField]
        protected Scrollbar m_VerticalScrollbar;
        [SerializeField]
        protected TMP_ScrollbarEventHandler m_VerticalScrollbarEventHandler;
        [SerializeField]
        protected float m_ScrollSensitivity;
        [SerializeField]
        [TextArea(5, 10)]
        protected string m_Text;
        protected int m_StringPosition;
        protected int m_StringSelectPosition;
        protected int m_CaretPosition;
        protected int m_CaretSelectPosition;
        protected UIVertex[] m_CursorVerts;
        protected Mesh m_Mesh;
        protected bool m_CaretVisible;
        [SerializeField]
        protected TMP_FontAsset m_GlobalFontAsset;
        [SerializeField]
        protected bool m_OnFocusSelectAll;
        protected bool m_isSelectAll;
        [SerializeField]
        protected bool m_ResetOnDeActivation;
        [SerializeField]
        protected bool m_isRichTextEditingAllowed;
        [SerializeField]
        protected int m_LineLimit;
        [SerializeField]
        protected TMP_InputValidator m_InputValidator;

        protected TMP_InputField();

        protected Mesh mesh { get; }
        public bool shouldHideMobileInput { get; set; }
        public bool shouldHideSoftKeyboard { get; set; }
        public string text { get; set; }
        public bool isFocused { get; }
        public float caretBlinkRate { get; set; }
        public int caretWidth { get; set; }
        public RectTransform textViewport { get; set; }
        public TMP_Text textComponent { get; set; }
        public Graphic placeholder { get; set; }
        public Scrollbar verticalScrollbar { get; set; }
        public float scrollSensitivity { get; set; }
        public Color caretColor { get; set; }
        public bool customCaretColor { get; set; }
        public Color selectionColor { get; set; }
        public SubmitEvent onEndEdit { get; set; }
        public SubmitEvent onSubmit { get; set; }
        public SelectionEvent onSelect { get; set; }
        public SelectionEvent onDeselect { get; set; }
        public TextSelectionEvent onTextSelection { get; set; }
        public TextSelectionEvent onEndTextSelection { get; set; }
        public OnChangeEvent onValueChanged { get; set; }
        public TouchScreenKeyboardEvent onTouchScreenKeyboardStatusChanged { get; set; }
        public OnValidateInput onValidateInput { get; set; }
        public int characterLimit { get; set; }
        public float pointSize { get; set; }
        public TMP_FontAsset fontAsset { get; set; }
        public bool onFocusSelectAll { get; set; }
        public bool resetOnDeActivation { get; set; }
        public bool restoreOriginalTextOnEscape { get; set; }
        public bool isRichTextEditingAllowed { get; set; }
        public ContentType contentType { get; set; }
        public LineType lineType { get; set; }
        public int lineLimit { get; set; }
        public InputType inputType { get; set; }
        public TouchScreenKeyboardType keyboardType { get; set; }
        public CharacterValidation characterValidation { get; set; }
        public TMP_InputValidator inputValidator { get; set; }
        public bool readOnly { get; set; }
        public bool richText { get; set; }
        public bool multiLine { get; }
        public char asteriskChar { get; set; }
        public bool wasCanceled { get; }
        protected int caretPositionInternal { get; set; }
        protected int stringPositionInternal { get; set; }
        protected int caretSelectPositionInternal { get; set; }
        protected int stringSelectPositionInternal { get; set; }
        public int caretPosition { get; set; }
        public int selectionAnchorPosition { get; set; }
        public int selectionFocusPosition { get; set; }
        public int stringPosition { get; set; }
        public int selectionStringAnchorPosition { get; set; }
        public int selectionStringFocusPosition { get; set; }
        public virtual float minWidth { get; }
        public virtual float preferredWidth { get; }
        public virtual float flexibleWidth { get; }
        public virtual float minHeight { get; }
        public virtual float preferredHeight { get; }
        public virtual float flexibleHeight { get; }
        public virtual int layoutPriority { get; }

        public void SetTextWithoutNotify(string input);
        protected void ClampStringPos(ref int pos);
        protected void ClampCaretPos(ref int pos);
        protected override void OnValidate();
        protected override void OnEnable();
        protected override void OnDisable();
        protected void OnFocus();
        protected void SelectAll();
        public void MoveTextEnd(bool shift);
        public void MoveTextStart(bool shift);
        public void MoveToEndOfLine(bool shift, bool ctrl);
        public void MoveToStartOfLine(bool shift, bool ctrl);
        protected virtual void LateUpdate();
        public virtual void OnBeginDrag(PointerEventData eventData);
        public virtual void OnDrag(PointerEventData eventData);
        public virtual void OnEndDrag(PointerEventData eventData);
        public override void OnPointerDown(PointerEventData eventData);
        protected EditState KeyPressed(Event evt);
        protected virtual bool IsValidChar(char c);
        public void ProcessEvent(Event e);
        public virtual void OnUpdateSelected(BaseEventData eventData);
        public virtual void OnScroll(PointerEventData eventData);
        protected virtual void Append(string input);
        protected virtual void Append(char input);
        protected void SendOnEndEdit();
        protected void SendOnSubmit();
        protected void SendOnFocus();
        protected void SendOnFocusLost();
        protected void SendOnTextSelection();
        protected void SendOnEndTextSelection();
        protected void SendTouchScreenKeyboardStatusChanged();
        protected void UpdateLabel();
        public void ForceLabelUpdate();
        public virtual void Rebuild(CanvasUpdate update);
        public virtual void LayoutComplete();
        public virtual void GraphicUpdateComplete();
        protected char Validate(string text, int pos, char ch);
        public void ActivateInputField();
        public override void OnSelect(BaseEventData eventData);
        public virtual void OnPointerClick(PointerEventData eventData);
        public void OnControlClick();
        public void ReleaseSelection();
        public void DeactivateInputField(bool clearSelection = False);
        public override void OnDeselect(BaseEventData eventData);
        public virtual void OnSubmit(BaseEventData eventData);
        protected override void DoStateTransition(Selectable.SelectionState state, bool instant);
        public virtual void CalculateLayoutInputHorizontal();
        public virtual void CalculateLayoutInputVertical();
        public void SetGlobalPointSize(float pointSize);
        public void SetGlobalFontAsset(TMP_FontAsset fontAsset);

        public enum ContentType
        {
            Standard = 0,
            Autocorrected = 1,
            IntegerNumber = 2,
            DecimalNumber = 3,
            Alphanumeric = 4,
            Name = 5,
            EmailAddress = 6,
            Password = 7,
            Pin = 8,
            Custom = 9
        }
        public enum InputType
        {
            Standard = 0,
            AutoCorrect = 1,
            Password = 2
        }
        public enum CharacterValidation
        {
            None = 0,
            Digit = 1,
            Integer = 2,
            Decimal = 3,
            Alphanumeric = 4,
            Name = 5,
            Regex = 6,
            EmailAddress = 7,
            CustomValidator = 8
        }
        public enum LineType
        {
            SingleLine = 0,
            MultiLineSubmit = 1,
            MultiLineNewline = 2
        }
        public delegate char OnValidateInput(string text, int charIndex, char addedChar);
        public class SubmitEvent : UnityEvent<string>
        {
            public SubmitEvent();
        }
        public class OnChangeEvent : UnityEvent<string>
        {
            public OnChangeEvent();
        }
        public class SelectionEvent : UnityEvent<string>
        {
            public SelectionEvent();
        }
        public class TextSelectionEvent : UnityEvent<string, int, int>
        {
            public TextSelectionEvent();
        }
        public class TouchScreenKeyboardEvent : UnityEvent<TouchScreenKeyboard.Status>
        {
            public TouchScreenKeyboardEvent();
        }
        protected enum EditState
        {
            Continue = 0,
            Finish = 1
        }
    }
}
using UnityEngine;

namespace TMPro
{
    public abstract class TMP_InputValidator : ScriptableObject
    {
        protected TMP_InputValidator();

        public abstract char Validate(ref string text, ref int pos, char ch);
    }
}
namespace TMPro
{
    public struct TMP_LineInfo
    {
        public int characterCount;
        public int visibleCharacterCount;
        public int spaceCount;
        public int wordCount;
        public int firstCharacterIndex;
        public int firstVisibleCharacterIndex;
        public int lastCharacterIndex;
        public int lastVisibleCharacterIndex;
        public float length;
        public float lineHeight;
        public float ascender;
        public float baseline;
        public float descender;
        public float maxAdvance;
        public float width;
        public float marginLeft;
        public float marginRight;
        public HorizontalAlignmentOptions alignment;
        public Extents lineExtents;
    }
}
using UnityEngine;
using UnityEngine.UI;

namespace TMPro
{
    public static class TMP_MaterialManager
    {
        public static Material GetStencilMaterial(Material baseMaterial, int stencilID);
        public static void ReleaseStencilMaterial(Material stencilMaterial);
        public static Material GetBaseMaterial(Material stencilMaterial);
        public static Material SetStencil(Material material, int stencilID);
        public static void AddMaskingMaterial(Material baseMaterial, Material stencilMaterial, int stencilID);
        public static void RemoveStencilMaterial(Material stencilMaterial);
        public static void ReleaseBaseMaterial(Material baseMaterial);
        public static void ClearMaterials();
        public static int GetStencilID(GameObject obj);
        public static Material GetMaterialForRendering(MaskableGraphic graphic, Material baseMaterial);
        public static Material GetFallbackMaterial(Material sourceMaterial, Material targetMaterial);
        public static void AddFallbackMaterialReference(Material targetMaterial);
        public static void RemoveFallbackMaterialReference(Material targetMaterial);
        public static void CleanupFallbackMaterials();
        public static void ReleaseFallbackMaterial(Material fallbackMaterial);
        public static void CopyMaterialPresetProperties(Material source, Material destination);
    }
}
namespace TMPro
{
    public enum VertexSortingOrder
    {
        Normal = 0,
        Reverse = 1
    }
}
using System.Collections.Generic;
using UnityEngine;

namespace TMPro
{
    public struct TMP_MeshInfo
    {
        public Mesh mesh;
        public int vertexCount;
        public Vector3[] vertices;
        public Vector3[] normals;
        public Vector4[] tangents;
        public Vector2[] uvs0;
        public Vector2[] uvs2;
        public Color32[] colors32;
        public int[] triangles;
        public Material material;

        public TMP_MeshInfo(Mesh mesh, int size);
        public TMP_MeshInfo(Mesh mesh, int size, bool isVolumetric);

        public void ResizeMeshInfo(int size);
        public void ResizeMeshInfo(int size, bool isVolumetric);
        public void Clear();
        public void Clear(bool uploadChanges);
        public void ClearUnusedVertices();
        public void ClearUnusedVertices(int startIndex);
        public void ClearUnusedVertices(int startIndex, bool updateMesh);
        public void SortGeometry(VertexSortingOrder order);
        public void SortGeometry(IList<int> sortingOrder);
        public void SwapVertexData(int src, int dst);
    }
}
namespace TMPro
{
    public class TMP_PackageResourceImporter
    {
        public TMP_PackageResourceImporter();

        public void OnDestroy();
        public void OnGUI();
        public static void ImportResources(bool importEssentials, bool importExamples, bool interactive);
    }
}
using UnityEditor;

namespace TMPro
{
    public class TMP_PackageResourceImporterWindow : EditorWindow
    {
        public TMP_PackageResourceImporterWindow();

        public static void ShowPackageImporterWindow();
    }
}
namespace TMPro
{
    public class TMP_ResourceManager
    {
        public TMP_ResourceManager();

        public static void AddFontAsset(TMP_FontAsset fontAsset);
        public static bool TryGetFontAsset(int hashcode, out TMP_FontAsset fontAsset);
    }
}
namespace TMPro
{
    public enum TagValueType
    {
        None = 0,
        NumericalValue = 1,
        StringValue = 2,
        ColorValue = 4
    }
}
namespace TMPro
{
    public enum TagUnitType
    {
        Pixels = 0,
        FontUnits = 1,
        Percentage = 2
    }
}
using UnityEngine;
using UnityEngine.EventSystems;

namespace TMPro
{
    public class TMP_ScrollbarEventHandler : MonoBehaviour, IEventSystemHandler, ISelectHandler, IDeselectHandler, IPointerClickHandler
    {
        public bool isSelected;

        public TMP_ScrollbarEventHandler();

        public void OnPointerClick(PointerEventData eventData);
        public void OnSelect(BaseEventData eventData);
        public void OnDeselect(BaseEventData eventData);
    }
}
using UnityEngine;
using UnityEngine.UI;

namespace TMPro
{
    [RequireComponent(typeof(CanvasRenderer))]
    public class TMP_SelectionCaret : MaskableGraphic
    {
        public TMP_SelectionCaret();

        public override void Cull(Rect clipRect, bool validRect);
        protected override void UpdateGeometry();
    }
}
using System.Collections.Generic;
using UnityEngine;

namespace TMPro
{
    [ExcludeFromPreset]
    public class TMP_Settings : ScriptableObject
    {
        public TMP_Settings();

        public static string version { get; }
        public static bool enableWordWrapping { get; }
        public static bool enableKerning { get; }
        public static bool enableExtraPadding { get; }
        public static bool enableTintAllSprites { get; }
        public static bool enableParseEscapeCharacters { get; }
        public static bool enableRaycastTarget { get; }
        public static bool getFontFeaturesAtRuntime { get; }
        public static int missingGlyphCharacter { get; set; }
        public static bool warningsDisabled { get; }
        public static TMP_FontAsset defaultFontAsset { get; }
        public static string defaultFontAssetPath { get; }
        public static float defaultFontSize { get; }
        public static float defaultTextAutoSizingMinRatio { get; }
        public static float defaultTextAutoSizingMaxRatio { get; }
        public static Vector2 defaultTextMeshProTextContainerSize { get; }
        public static Vector2 defaultTextMeshProUITextContainerSize { get; }
        public static bool autoSizeTextContainer { get; }
        public static bool isTextObjectScaleStatic { get; set; }
        public static List<TMP_FontAsset> fallbackFontAssets { get; }
        public static bool matchMaterialPreset { get; }
        public static TMP_SpriteAsset defaultSpriteAsset { get; }
        public static string defaultSpriteAssetPath { get; }
        public static bool enableEmojiSupport { get; set; }
        public static uint missingCharacterSpriteUnicode { get; set; }
        public static string defaultColorGradientPresetsPath { get; }
        public static TMP_StyleSheet defaultStyleSheet { get; }
        public static string styleSheetsResourcePath { get; }
        public static TextAsset leadingCharacters { get; }
        public static TextAsset followingCharacters { get; }
        public static LineBreakingTable linebreakingRules { get; }
        public static bool useModernHangulLineBreakingRules { get; set; }
        public static TMP_Settings instance { get; }

        public static TMP_Settings LoadDefaultSettings();
        public static TMP_Settings GetSettings();
        public static TMP_FontAsset GetFontAsset();
        public static TMP_SpriteAsset GetSpriteAsset();
        public static TMP_StyleSheet GetStyleSheet();
        public static void LoadLinebreakingRules();

        public class LineBreakingTable
        {
            public Dictionary<int, char> leadingCharacters;
            public Dictionary<int, char> followingCharacters;

            public LineBreakingTable();
        }
    }
}
using UnityEngine;

namespace TMPro
{
    public static class ShaderUtilities
    {
        public static int ID_MainTex;
        public static int ID_FaceTex;
        public static int ID_FaceColor;
        public static int ID_FaceDilate;
        public static int ID_Shininess;
        public static int ID_UnderlayColor;
        public static int ID_UnderlayOffsetX;
        public static int ID_UnderlayOffsetY;
        public static int ID_UnderlayDilate;
        public static int ID_UnderlaySoftness;
        public static int ID_UnderlayOffset;
        public static int ID_UnderlayIsoPerimeter;
        public static int ID_WeightNormal;
        public static int ID_WeightBold;
        public static int ID_OutlineTex;
        public static int ID_OutlineWidth;
        public static int ID_OutlineSoftness;
        public static int ID_OutlineColor;
        public static int ID_Outline2Color;
        public static int ID_Outline2Width;
        public static int ID_Padding;
        public static int ID_GradientScale;
        public static int ID_ScaleX;
        public static int ID_ScaleY;
        public static int ID_PerspectiveFilter;
        public static int ID_Sharpness;
        public static int ID_TextureWidth;
        public static int ID_TextureHeight;
        public static int ID_BevelAmount;
        public static int ID_GlowColor;
        public static int ID_GlowOffset;
        public static int ID_GlowPower;
        public static int ID_GlowOuter;
        public static int ID_GlowInner;
        public static int ID_LightAngle;
        public static int ID_EnvMap;
        public static int ID_EnvMatrix;
        public static int ID_EnvMatrixRotation;
        public static int ID_MaskCoord;
        public static int ID_ClipRect;
        public static int ID_MaskSoftnessX;
        public static int ID_MaskSoftnessY;
        public static int ID_VertexOffsetX;
        public static int ID_VertexOffsetY;
        public static int ID_UseClipRect;
        public static int ID_StencilID;
        public static int ID_StencilOp;
        public static int ID_StencilComp;
        public static int ID_StencilReadMask;
        public static int ID_StencilWriteMask;
        public static int ID_ShaderFlags;
        public static int ID_ScaleRatio_A;
        public static int ID_ScaleRatio_B;
        public static int ID_ScaleRatio_C;
        public static string Keyword_Bevel;
        public static string Keyword_Glow;
        public static string Keyword_Underlay;
        public static string Keyword_Ratios;
        public static string Keyword_MASK_SOFT;
        public static string Keyword_MASK_HARD;
        public static string Keyword_MASK_TEX;
        public static string Keyword_Outline;
        public static string ShaderTag_ZTestMode;
        public static string ShaderTag_CullMode;
        public static bool isInitialized;

        public static void GetShaderPropertyIDs();
        public static void UpdateShaderRatios(Material mat);
        public static Vector4 GetFontExtent(Material material);
        public static bool IsMaskingEnabled(Material material);
        public static float GetPadding(Material material, bool enableExtraPadding, bool isBold);
        public static float GetPadding(Material[] materials, bool enableExtraPadding, bool isBold);
    }
}
using UnityEngine;

namespace TMPro
{
    public class TMP_Sprite : TMP_TextElement_Legacy
    {
        public string name;
        public int hashCode;
        public int unicode;
        public Vector2 pivot;
        public Sprite sprite;

        public TMP_Sprite();
    }
}
using UnityEngine;

namespace TMPro
{
    [DisallowMultipleComponent]
    public class TMP_SpriteAnimator : MonoBehaviour
    {
        public TMP_SpriteAnimator();

        public void StopAllAnimations();
        public void DoSpriteAnimation(int currentCharacter, TMP_SpriteAsset spriteAsset, int start, int end, int framerate);
    }
}
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.TextCore;

namespace TMPro
{
    [ExcludeFromPreset]
    public class TMP_SpriteAsset : TMP_Asset
    {
        public Texture spriteSheet;
        public List<TMP_Sprite> spriteInfoList;
        [SerializeField]
        public List<TMP_SpriteAsset> fallbackSpriteAssets;

        public TMP_SpriteAsset();

        public string version { get; }
        public FaceInfo faceInfo { get; }
        public List<TMP_SpriteCharacter> spriteCharacterTable { get; }
        public Dictionary<uint, TMP_SpriteCharacter> spriteCharacterLookupTable { get; }
        public List<TMP_SpriteGlyph> spriteGlyphTable { get; }

        public void UpdateLookupTables();
        public int GetSpriteIndexFromHashcode(int hashCode);
        public int GetSpriteIndexFromUnicode(uint unicode);
        public int GetSpriteIndexFromName(string name);
        public static TMP_SpriteAsset SearchForSpriteByUnicode(TMP_SpriteAsset spriteAsset, uint unicode, bool includeFallbacks, out int spriteIndex);
        public static TMP_SpriteAsset SearchForSpriteByHashCode(TMP_SpriteAsset spriteAsset, int hashCode, bool includeFallbacks, out int spriteIndex);
        public void SortGlyphTable();
    }
}
namespace TMPro
{
    public class TMP_SpriteCharacter : TMP_TextElement
    {
        public TMP_SpriteCharacter();
        public TMP_SpriteCharacter(uint unicode, TMP_SpriteGlyph glyph);
        public TMP_SpriteCharacter(uint unicode, TMP_SpriteAsset spriteAsset, TMP_SpriteGlyph glyph);

        public string name { get; set; }
        public int hashCode { get; }
    }
}
using UnityEngine;
using UnityEngine.TextCore;

namespace TMPro
{
    public class TMP_SpriteGlyph : Glyph
    {
        public Sprite sprite;

        public TMP_SpriteGlyph();
        public TMP_SpriteGlyph(uint index, GlyphMetrics metrics, GlyphRect glyphRect, float scale, int atlasIndex);
        public TMP_SpriteGlyph(uint index, GlyphMetrics metrics, GlyphRect glyphRect, float scale, int atlasIndex, Sprite sprite);
    }
}
namespace TMPro
{
    public class TMP_Style
    {
        public static TMP_Style NormalStyle { get; }
        public string name { get; set; }
        public int hashCode { get; set; }
        public string styleOpeningDefinition { get; }
        public string styleClosingDefinition { get; }
        public int[] styleOpeningTagArray { get; }
        public int[] styleClosingTagArray { get; }

        public void RefreshStyle();
    }
}
using UnityEngine;

namespace TMPro
{
    [ExcludeFromPreset]
    public class TMP_StyleSheet : ScriptableObject
    {
        public TMP_StyleSheet();

        public TMP_Style GetStyle(int hashCode);
        public TMP_Style GetStyle(string name);
        public void RefreshStyles();
    }
}
using UnityEngine;

namespace TMPro
{
    [RequireComponent(typeof(MeshRenderer))]
    [ExecuteAlways]
    public class TMP_SubMesh : MonoBehaviour
    {
        public TMP_SubMesh();

        public TMP_FontAsset fontAsset { get; set; }
        public TMP_SpriteAsset spriteAsset { get; set; }
        public Material material { get; set; }
        public Material sharedMaterial { get; set; }
        public Material fallbackMaterial { get; set; }
        public Material fallbackSourceMaterial { get; set; }
        public bool isDefaultMaterial { get; set; }
        public float padding { get; set; }
        public Renderer renderer { get; }
        public MeshFilter meshFilter { get; }
        public Mesh mesh { get; set; }
        public TMP_Text textComponent { get; }

        public static TMP_SubMesh AddSubTextObject(TextMeshPro textComponent, MaterialReference materialReference);
        public void DestroySelf();
        public float GetPaddingForMaterial();
        public void UpdateMeshPadding(bool isExtraPadding, bool isUsingBold);
        public void SetVerticesDirty();
        public void SetMaterialDirty();
        protected void UpdateMaterial();
    }
}
using UnityEngine;
using UnityEngine.UI;

namespace TMPro
{
    [ExecuteAlways]
    [RequireComponent(typeof(CanvasRenderer))]
    public class TMP_SubMeshUI : MaskableGraphic
    {
        public TMP_SubMeshUI();

        public TMP_FontAsset fontAsset { get; set; }
        public TMP_SpriteAsset spriteAsset { get; set; }
        public override Texture mainTexture { get; }
        public override Material material { get; set; }
        public Material sharedMaterial { get; set; }
        public Material fallbackMaterial { get; set; }
        public Material fallbackSourceMaterial { get; set; }
        public override Material materialForRendering { get; }
        public bool isDefaultMaterial { get; set; }
        public float padding { get; set; }
        public Mesh mesh { get; set; }
        public TMP_Text textComponent { get; }

        public static TMP_SubMeshUI AddSubTextObject(TextMeshProUGUI textComponent, MaterialReference materialReference);
        protected override void OnEnable();
        protected override void OnDisable();
        protected override void OnDestroy();
        protected override void OnTransformParentChanged();
        public override Material GetModifiedMaterial(Material baseMaterial);
        public float GetPaddingForMaterial();
        public float GetPaddingForMaterial(Material mat);
        public void UpdateMeshPadding(bool isExtraPadding, bool isUsingBold);
        public override void SetAllDirty();
        public override void SetVerticesDirty();
        public override void SetLayoutDirty();
        public override void SetMaterialDirty();
        public void SetPivotDirty();
        public override void Cull(Rect clipRect, bool validRect);
        protected override void UpdateGeometry();
        public override void Rebuild(CanvasUpdate update);
        public void RefreshMaterial();
        protected override void UpdateMaterial();
        public override void RecalculateClipping();
    }
}
using UnityEngine;
using UnityEngine.UI;

namespace TMPro
{
    public interface ITextElement
    {
        Material sharedMaterial { get; }

        void Rebuild(CanvasUpdate update);
        int GetInstanceID();
    }
}
namespace TMPro
{
    public enum TextAlignmentOptions
    {
        TopLeft = 257,
        Top = 258,
        TopRight = 260,
        TopJustified = 264,
        TopFlush = 272,
        TopGeoAligned = 288,
        Left = 513,
        Center = 514,
        Right = 516,
        Justified = 520,
        Flush = 528,
        CenterGeoAligned = 544,
        BottomLeft = 1025,
        Bottom = 1026,
        BottomRight = 1028,
        BottomJustified = 1032,
        BottomFlush = 1040,
        BottomGeoAligned = 1056,
        BaselineLeft = 2049,
        Baseline = 2050,
        BaselineRight = 2052,
        BaselineJustified = 2056,
        BaselineFlush = 2064,
        BaselineGeoAligned = 2080,
        MidlineLeft = 4097,
        Midline = 4098,
        MidlineRight = 4100,
        MidlineJustified = 4104,
        MidlineFlush = 4112,
        MidlineGeoAligned = 4128,
        CaplineLeft = 8193,
        Capline = 8194,
        CaplineRight = 8196,
        CaplineJustified = 8200,
        CaplineFlush = 8208,
        CaplineGeoAligned = 8224,
        Converted = 65535
    }
}
namespace TMPro
{
    public enum HorizontalAlignmentOptions
    {
        Left = 1,
        Center = 2,
        Right = 4,
        Justified = 8,
        Flush = 16,
        Geometry = 32
    }
}
namespace TMPro
{
    public enum VerticalAlignmentOptions
    {
        Top = 256,
        Middle = 512,
        Bottom = 1024,
        Baseline = 2048,
        Geometry = 4096,
        Capline = 8192
    }
}
namespace TMPro
{
    public enum TextRenderFlags
    {
        DontRender = 0,
        Render = 255
    }
}
namespace TMPro
{
    public enum TMP_TextElementType
    {
        Character = 0,
        Sprite = 1
    }
}
namespace TMPro
{
    public enum MaskingTypes
    {
        MaskOff = 0,
        MaskHard = 1,
        MaskSoft = 2
    }
}
namespace TMPro
{
    public enum TextOverflowModes
    {
        Overflow = 0,
        Ellipsis = 1,
        Masking = 2,
        Truncate = 3,
        ScrollRect = 4,
        Page = 5,
        Linked = 6
    }
}
namespace TMPro
{
    public enum MaskingOffsetMode
    {
        Percentage = 0,
        Pixel = 1
    }
}
namespace TMPro
{
    public enum TextureMappingOptions
    {
        Character = 0,
        Line = 1,
        Paragraph = 2,
        MatchAspect = 3
    }
}
using System;

namespace TMPro
{
    [Flags]
    public enum FontStyles
    {
        Normal = 0,
        Bold = 1,
        Italic = 2,
        Underline = 4,
        LowerCase = 8,
        UpperCase = 16,
        SmallCaps = 32,
        Strikethrough = 64,
        Superscript = 128,
        Subscript = 256,
        Highlight = 512
    }
}
namespace TMPro
{
    public enum FontWeight
    {
        Thin = 100,
        ExtraLight = 200,
        Light = 300,
        Regular = 400,
        Medium = 500,
        SemiBold = 600,
        Bold = 700,
        Heavy = 800,
        Black = 900
    }
}
using System;
using System.Collections.Generic;
using System.Text;
using UnityEngine;
using UnityEngine.Serialization;
using UnityEngine.UI;

namespace TMPro
{
    public abstract class TMP_Text : MaskableGraphic
    {
        [SerializeField]
        [TextArea(5, 10)]
        protected string m_text;
        [SerializeField]
        protected ITextPreprocessor m_TextPreprocessor;
        [SerializeField]
        protected bool m_isRightToLeft;
        [SerializeField]
        protected TMP_FontAsset m_fontAsset;
        protected TMP_FontAsset m_currentFontAsset;
        protected bool m_isSDFShader;
        [SerializeField]
        protected Material m_sharedMaterial;
        protected Material m_currentMaterial;
        protected static MaterialReference[] m_materialReferences;
        protected static Dictionary<int, int> m_materialReferenceIndexLookup;
        protected static TMP_TextProcessingStack<MaterialReference> m_materialReferenceStack;
        protected int m_currentMaterialIndex;
        [SerializeField]
        protected Material[] m_fontSharedMaterials;
        [SerializeField]
        protected Material m_fontMaterial;
        [SerializeField]
        protected Material[] m_fontMaterials;
        protected bool m_isMaterialDirty;
        [SerializeField]
        protected Color32 m_fontColor32;
        [SerializeField]
        protected Color m_fontColor;
        protected static Color32 s_colorWhite;
        protected Color32 m_underlineColor;
        protected Color32 m_strikethroughColor;
        [SerializeField]
        protected bool m_enableVertexGradient;
        [SerializeField]
        protected ColorMode m_colorMode;
        [SerializeField]
        protected VertexGradient m_fontColorGradient;
        [SerializeField]
        protected TMP_ColorGradient m_fontColorGradientPreset;
        [SerializeField]
        protected TMP_SpriteAsset m_spriteAsset;
        [SerializeField]
        protected bool m_tintAllSprites;
        protected bool m_tintSprite;
        protected Color32 m_spriteColor;
        [SerializeField]
        protected TMP_StyleSheet m_StyleSheet;
        [SerializeField]
        protected int m_TextStyleHashCode;
        [SerializeField]
        protected bool m_overrideHtmlColors;
        [SerializeField]
        protected Color32 m_faceColor;
        protected Color32 m_outlineColor;
        protected float m_outlineWidth;
        [SerializeField]
        protected float m_fontSize;
        protected float m_currentFontSize;
        [SerializeField]
        protected float m_fontSizeBase;
        protected TMP_TextProcessingStack<float> m_sizeStack;
        [SerializeField]
        protected FontWeight m_fontWeight;
        protected FontWeight m_FontWeightInternal;
        protected TMP_TextProcessingStack<FontWeight> m_FontWeightStack;
        [SerializeField]
        protected bool m_enableAutoSizing;
        protected float m_maxFontSize;
        protected float m_minFontSize;
        protected int m_AutoSizeIterationCount;
        protected int m_AutoSizeMaxIterationCount;
        protected bool m_IsAutoSizePointSizeSet;
        [SerializeField]
        protected float m_fontSizeMin;
        [SerializeField]
        protected float m_fontSizeMax;
        [SerializeField]
        protected FontStyles m_fontStyle;
        protected FontStyles m_FontStyleInternal;
        protected TMP_FontStyleStack m_fontStyleStack;
        protected bool m_isUsingBold;
        [SerializeField]
        protected HorizontalAlignmentOptions m_HorizontalAlignment;
        [SerializeField]
        protected VerticalAlignmentOptions m_VerticalAlignment;
        [SerializeField]
        [FormerlySerializedAs("m_lineJustification")]
        protected TextAlignmentOptions m_textAlignment;
        protected HorizontalAlignmentOptions m_lineJustification;
        protected TMP_TextProcessingStack<HorizontalAlignmentOptions> m_lineJustificationStack;
        protected Vector3[] m_textContainerLocalCorners;
        [SerializeField]
        protected float m_characterSpacing;
        protected float m_cSpacing;
        protected float m_monoSpacing;
        [SerializeField]
        protected float m_wordSpacing;
        [SerializeField]
        protected float m_lineSpacing;
        protected float m_lineSpacingDelta;
        protected float m_lineHeight;
        protected bool m_IsDrivenLineSpacing;
        [SerializeField]
        protected float m_lineSpacingMax;
        [SerializeField]
        protected float m_paragraphSpacing;
        [SerializeField]
        protected float m_charWidthMaxAdj;
        protected float m_charWidthAdjDelta;
        [SerializeField]
        protected bool m_enableWordWrapping;
        protected bool m_isCharacterWrappingEnabled;
        protected bool m_isNonBreakingSpace;
        protected bool m_isIgnoringAlignment;
        [SerializeField]
        protected float m_wordWrappingRatios;
        [SerializeField]
        protected TextOverflowModes m_overflowMode;
        protected int m_firstOverflowCharacterIndex;
        [SerializeField]
        protected TMP_Text m_linkedTextComponent;
        protected bool m_isTextTruncated;
        [SerializeField]
        protected bool m_enableKerning;
        protected float m_GlyphHorizontalAdvanceAdjustment;
        [SerializeField]
        protected bool m_enableExtraPadding;
        [SerializeField]
        protected bool checkPaddingRequired;
        [SerializeField]
        protected bool m_isRichText;
        [SerializeField]
        protected bool m_parseCtrlCharacters;
        protected bool m_isOverlay;
        [SerializeField]
        protected bool m_isOrthographic;
        [SerializeField]
        protected bool m_isCullingEnabled;
        protected bool m_isMaskingEnabled;
        protected bool isMaskUpdateRequired;
        protected bool m_ignoreCulling;
        [SerializeField]
        protected TextureMappingOptions m_horizontalMapping;
        [SerializeField]
        protected TextureMappingOptions m_verticalMapping;
        [SerializeField]
        protected float m_uvLineOffset;
        protected TextRenderFlags m_renderMode;
        [SerializeField]
        protected VertexSortingOrder m_geometrySortingOrder;
        [SerializeField]
        protected bool m_IsTextObjectScaleStatic;
        [SerializeField]
        protected bool m_VertexBufferAutoSizeReduction;
        protected int m_firstVisibleCharacter;
        protected int m_maxVisibleCharacters;
        protected int m_maxVisibleWords;
        protected int m_maxVisibleLines;
        [SerializeField]
        protected bool m_useMaxVisibleDescender;
        [SerializeField]
        protected int m_pageToDisplay;
        protected bool m_isNewPage;
        [SerializeField]
        protected Vector4 m_margin;
        protected float m_marginLeft;
        protected float m_marginRight;
        protected float m_marginWidth;
        protected float m_marginHeight;
        protected float m_width;
        protected TMP_TextInfo m_textInfo;
        protected bool m_havePropertiesChanged;
        [SerializeField]
        protected bool m_isUsingLegacyAnimationComponent;
        protected Transform m_transform;
        protected RectTransform m_rectTransform;
        protected Vector2 m_PreviousRectTransformSize;
        protected Vector2 m_PreviousPivotPosition;
        protected bool m_autoSizeTextContainer;
        protected Mesh m_mesh;
        [SerializeField]
        protected bool m_isVolumetricText;
        protected TMP_SpriteAnimator m_spriteAnimator;
        protected float m_flexibleHeight;
        protected float m_flexibleWidth;
        protected float m_minWidth;
        protected float m_minHeight;
        protected float m_maxWidth;
        protected float m_maxHeight;
        protected LayoutElement m_LayoutElement;
        protected float m_preferredWidth;
        protected float m_renderedWidth;
        protected bool m_isPreferredWidthDirty;
        protected float m_preferredHeight;
        protected float m_renderedHeight;
        protected bool m_isPreferredHeightDirty;
        protected bool m_isCalculatingPreferredValues;
        protected int m_layoutPriority;
        protected bool m_isLayoutDirty;
        protected bool m_isAwake;
        protected float m_fontScaleMultiplier;
        protected float tag_LineIndent;
        protected float tag_Indent;
        protected TMP_TextProcessingStack<float> m_indentStack;
        protected bool tag_NoParsing;
        protected bool m_isParsingText;
        protected Matrix4x4 m_FXMatrix;
        protected bool m_isFXMatrixSet;
        protected int m_totalCharacterCount;
        protected static WordWrapState m_SavedWordWrapState;
        protected static WordWrapState m_SavedLineState;
        protected static WordWrapState m_SavedEllipsisState;
        protected static WordWrapState m_SavedLastValidState;
        protected static WordWrapState m_SavedSoftLineBreakState;
        protected int m_characterCount;
        protected int m_firstCharacterOfLine;
        protected int m_firstVisibleCharacterOfLine;
        protected int m_lastCharacterOfLine;
        protected int m_lastVisibleCharacterOfLine;
        protected int m_lineNumber;
        protected int m_lineVisibleCharacterCount;
        protected int m_pageNumber;
        protected float m_PageAscender;
        protected float m_maxTextAscender;
        protected float m_maxCapHeight;
        protected float m_ElementAscender;
        protected float m_ElementDescender;
        protected float m_maxLineAscender;
        protected float m_maxLineDescender;
        protected float m_startOfLineAscender;
        protected float m_startOfLineDescender;
        protected float m_lineOffset;
        protected Extents m_meshExtents;
        protected Color32 m_htmlColor;
        protected TMP_TextProcessingStack<Color32> m_colorStack;
        protected TMP_TextProcessingStack<Color32> m_underlineColorStack;
        protected TMP_TextProcessingStack<Color32> m_strikethroughColorStack;
        protected TMP_TextProcessingStack<HighlightState> m_HighlightStateStack;
        protected TMP_ColorGradient m_colorGradientPreset;
        protected TMP_TextProcessingStack<TMP_ColorGradient> m_colorGradientStack;
        protected bool m_colorGradientPresetIsTinted;
        protected float m_tabSpacing;
        protected float m_spacing;
        protected TMP_TextProcessingStack<int>[] m_TextStyleStacks;
        protected int m_TextStyleStackDepth;
        protected TMP_TextProcessingStack<int> m_ItalicAngleStack;
        protected int m_ItalicAngle;
        protected TMP_TextProcessingStack<int> m_actionStack;
        protected float m_padding;
        protected float m_baselineOffset;
        protected TMP_TextProcessingStack<float> m_baselineOffsetStack;
        protected float m_xAdvance;
        protected TMP_TextElementType m_textElementType;
        protected TMP_TextElement m_cached_TextElement;
        protected SpecialCharacter m_Ellipsis;
        protected SpecialCharacter m_Underline;
        protected TMP_SpriteAsset m_defaultSpriteAsset;
        protected TMP_SpriteAsset m_currentSpriteAsset;
        protected int m_spriteCount;
        protected int m_spriteIndex;
        protected int m_spriteAnimationID;
        protected bool m_ignoreActiveState;
        protected static Vector2 k_LargePositiveVector2;
        protected static Vector2 k_LargeNegativeVector2;
        protected static float k_LargePositiveFloat;
        protected static float k_LargeNegativeFloat;
        protected static int k_LargePositiveInt;
        protected static int k_LargeNegativeInt;

        protected TMP_Text();

        public virtual string text { get; set; }
        public ITextPreprocessor textPreprocessor { get; set; }
        public bool isRightToLeftText { get; set; }
        public TMP_FontAsset font { get; set; }
        public virtual Material fontSharedMaterial { get; set; }
        public virtual Material[] fontSharedMaterials { get; set; }
        public Material fontMaterial { get; set; }
        public virtual Material[] fontMaterials { get; set; }
        public override Color color { get; set; }
        public float alpha { get; set; }
        public bool enableVertexGradient { get; set; }
        public VertexGradient colorGradient { get; set; }
        public TMP_ColorGradient colorGradientPreset { get; set; }
        public TMP_SpriteAsset spriteAsset { get; set; }
        public bool tintAllSprites { get; set; }
        public TMP_StyleSheet styleSheet { get; set; }
        public TMP_Style textStyle { get; set; }
        public bool overrideColorTags { get; set; }
        public Color32 faceColor { get; set; }
        public Color32 outlineColor { get; set; }
        public float outlineWidth { get; set; }
        public float fontSize { get; set; }
        public FontWeight fontWeight { get; set; }
        public float pixelsPerUnit { get; }
        public bool enableAutoSizing { get; set; }
        public float fontSizeMin { get; set; }
        public float fontSizeMax { get; set; }
        public FontStyles fontStyle { get; set; }
        public bool isUsingBold { get; }
        public HorizontalAlignmentOptions horizontalAlignment { get; set; }
        public VerticalAlignmentOptions verticalAlignment { get; set; }
        public TextAlignmentOptions alignment { get; set; }
        public float characterSpacing { get; set; }
        public float wordSpacing { get; set; }
        public float lineSpacing { get; set; }
        public float lineSpacingAdjustment { get; set; }
        public float paragraphSpacing { get; set; }
        public float characterWidthAdjustment { get; set; }
        public bool enableWordWrapping { get; set; }
        public float wordWrappingRatios { get; set; }
        public TextOverflowModes overflowMode { get; set; }
        public bool isTextOverflowing { get; }
        public int firstOverflowCharacterIndex { get; }
        public TMP_Text linkedTextComponent { get; set; }
        public bool isTextTruncated { get; }
        public bool enableKerning { get; set; }
        public bool extraPadding { get; set; }
        public bool richText { get; set; }
        public bool parseCtrlCharacters { get; set; }
        public bool isOverlay { get; set; }
        public bool isOrthographic { get; set; }
        public bool enableCulling { get; set; }
        public bool ignoreVisibility { get; set; }
        public TextureMappingOptions horizontalMapping { get; set; }
        public TextureMappingOptions verticalMapping { get; set; }
        public float mappingUvLineOffset { get; set; }
        public TextRenderFlags renderMode { get; set; }
        public VertexSortingOrder geometrySortingOrder { get; set; }
        public bool isTextObjectScaleStatic { get; set; }
        public bool vertexBufferAutoSizeReduction { get; set; }
        public int firstVisibleCharacter { get; set; }
        public int maxVisibleCharacters { get; set; }
        public int maxVisibleWords { get; set; }
        public int maxVisibleLines { get; set; }
        public bool useMaxVisibleDescender { get; set; }
        public int pageToDisplay { get; set; }
        public virtual Vector4 margin { get; set; }
        public TMP_TextInfo textInfo { get; }
        public bool havePropertiesChanged { get; set; }
        public bool isUsingLegacyAnimationComponent { get; set; }
        public Transform transform { get; }
        public RectTransform rectTransform { get; }
        public virtual bool autoSizeTextContainer { get; set; }
        public virtual Mesh mesh { get; }
        public bool isVolumetricText { get; set; }
        public Bounds bounds { get; }
        public Bounds textBounds { get; }
        protected TMP_SpriteAnimator spriteAnimator { get; }
        public float flexibleHeight { get; }
        public float flexibleWidth { get; }
        public float minWidth { get; }
        public float minHeight { get; }
        public float maxWidth { get; }
        public float maxHeight { get; }
        protected LayoutElement layoutElement { get; }
        public virtual float preferredWidth { get; }
        public virtual float preferredHeight { get; }
        public virtual float renderedWidth { get; }
        public virtual float renderedHeight { get; }
        public int layoutPriority { get; }

        public static event Func<int, string, TMP_FontAsset> OnFontAssetRequest;
        public static event Func<int, string, TMP_SpriteAsset> OnSpriteAssetRequest;
        public virtual event Action<TMP_TextInfo> OnPreRenderText;

        protected virtual void LoadFontAsset();
        protected virtual void SetSharedMaterial(Material mat);
        protected virtual Material GetMaterial(Material mat);
        protected virtual void SetFontBaseMaterial(Material mat);
        protected virtual Material[] GetSharedMaterials();
        protected virtual void SetSharedMaterials(Material[] materials);
        protected virtual Material[] GetMaterials(Material[] mats);
        protected virtual Material CreateMaterialInstance(Material source);
        protected void SetVertexColorGradient(TMP_ColorGradient gradient);
        protected void SetTextSortingOrder(VertexSortingOrder order);
        protected void SetTextSortingOrder(int[] order);
        protected virtual void SetFaceColor(Color32 color);
        protected virtual void SetOutlineColor(Color32 color);
        protected virtual void SetOutlineThickness(float thickness);
        protected virtual void SetShaderDepth();
        protected virtual void SetCulling();
        protected virtual float GetPaddingForMaterial();
        protected virtual float GetPaddingForMaterial(Material mat);
        protected virtual Vector3[] GetTextContainerLocalCorners();
        public virtual void ForceMeshUpdate(bool ignoreActiveState = False, bool forceTextReparsing = False);
        public virtual void UpdateGeometry(Mesh mesh, int index);
        public virtual void UpdateVertexData(TMP_VertexDataUpdateFlags flags);
        public virtual void UpdateVertexData();
        public virtual void SetVertices(Vector3[] vertices);
        public virtual void UpdateMeshPadding();
        public override void CrossFadeColor(Color targetColor, float duration, bool ignoreTimeScale, bool useAlpha);
        public override void CrossFadeAlpha(float alpha, float duration, bool ignoreTimeScale);
        protected virtual void InternalCrossFadeColor(Color targetColor, float duration, bool ignoreTimeScale, bool useAlpha);
        protected virtual void InternalCrossFadeAlpha(float alpha, float duration, bool ignoreTimeScale);
        protected void ParseInputText();
        public void SetText(string sourceText, bool syncTextInputBox = True);
        public void SetText(string sourceText, float arg0);
        public void SetText(string sourceText, float arg0, float arg1);
        public void SetText(string sourceText, float arg0, float arg1, float arg2);
        public void SetText(string sourceText, float arg0, float arg1, float arg2, float arg3);
        public void SetText(string sourceText, float arg0, float arg1, float arg2, float arg3, float arg4);
        public void SetText(string sourceText, float arg0, float arg1, float arg2, float arg3, float arg4, float arg5);
        public void SetText(string sourceText, float arg0, float arg1, float arg2, float arg3, float arg4, float arg5, float arg6);
        public void SetText(string sourceText, float arg0, float arg1, float arg2, float arg3, float arg4, float arg5, float arg6, float arg7);
        public void SetText(StringBuilder sourceText);
        public void SetText(char[] sourceText);
        public void SetText(char[] sourceText, int start, int length);
        public void SetCharArray(char[] sourceText);
        public void SetCharArray(char[] sourceText, int start, int length);
        public Vector2 GetPreferredValues();
        public Vector2 GetPreferredValues(float width, float height);
        public Vector2 GetPreferredValues(string text);
        public Vector2 GetPreferredValues(string text, float width, float height);
        protected float GetPreferredWidth();
        protected float GetPreferredHeight();
        public Vector2 GetRenderedValues();
        public Vector2 GetRenderedValues(bool onlyVisibleCharacters);
        protected float GetRenderedWidth(bool onlyVisibleCharacters);
        protected float GetRenderedHeight(bool onlyVisibleCharacters);
        protected virtual Vector2 CalculatePreferredValues(ref float fontSize, Vector2 marginSize, bool isTextAutoSizingEnabled, bool isWordWrappingEnabled);
        protected virtual Bounds GetCompoundBounds();
        protected Bounds GetTextBounds();
        protected Bounds GetTextBounds(bool onlyVisibleCharacters);
        protected void AdjustLineOffset(int startIndex, int endIndex, float offset);
        protected void ResizeLineExtents(int size);
        public virtual TMP_TextInfo GetTextInfo(string text);
        public virtual void ComputeMarginSize();
        protected void InsertNewLine(int i, float baseScale, float currentElementScale, float currentEmScale, float glyphAdjustment, float boldSpacingAdjustment, float characterSpacingAdjustment, float width, float lineGap, ref bool isMaxVisibleDescenderSet, ref float maxVisibleDescender);
        protected void SaveWordWrappingState(ref WordWrapState state, int index, int count);
        protected int RestoreWordWrappingState(ref WordWrapState state);
        protected virtual void SaveGlyphVertexInfo(float padding, float style_padding, Color32 vertexColor);
        protected virtual void SaveSpriteVertexInfo(Color32 vertexColor);
        protected virtual void FillCharacterVertexBuffers(int i, int index_X4);
        protected virtual void FillCharacterVertexBuffers(int i, int index_X4, bool isVolumetric);
        protected virtual void FillSpriteVertexBuffers(int i, int index_X4);
        protected virtual void DrawUnderlineMesh(Vector3 start, Vector3 end, ref int index, float startScale, float endScale, float maxScale, float sdfScale, Color32 underlineColor);
        protected virtual void DrawTextHighlight(Vector3 start, Vector3 end, ref int index, Color32 highlightColor);
        protected void LoadDefaultSettings();
        protected void GetSpecialCharacters(TMP_FontAsset fontAsset);
        protected void GetEllipsisSpecialCharacter(TMP_FontAsset fontAsset);
        protected void GetUnderlineSpecialCharacter(TMP_FontAsset fontAsset);
        protected void ReplaceTagWithCharacter(int[] chars, int insertionIndex, int tagLength, char c);
        protected TMP_FontAsset GetFontAssetForWeight(int fontWeight);
        protected virtual void SetActiveSubMeshes(bool state);
        protected virtual void DestroySubMeshObjects();
        public virtual void ClearMesh();
        public virtual void ClearMesh(bool uploadGeometry);
        public virtual string GetParsedText();
        protected Vector2 PackUV(float x, float y, float scale);
        protected float PackUV(float x, float y);
        protected int HexToInt(char hex);
        protected int GetUTF16(string text, int i);
        protected int GetUTF16(int[] text, int i);
        protected int GetUTF16(StringBuilder text, int i);
        protected int GetUTF32(string text, int i);
        protected int GetUTF32(int[] text, int i);
        protected int GetUTF32(StringBuilder text, int i);
        protected Color32 HexCharsToColor(char[] hexChars, int tagCount);
        protected Color32 HexCharsToColor(char[] hexChars, int startIndex, int length);
        protected float ConvertToFloat(char[] chars, int startIndex, int length);
        protected float ConvertToFloat(char[] chars, int startIndex, int length, out int lastIndex);

        protected struct CharacterSubstitution
        {
            public int index;
            public uint unicode;

            public CharacterSubstitution(int index, uint unicode);
        }
        protected struct SpecialCharacter
        {
            public TMP_Character character;
            public TMP_FontAsset fontAsset;
            public Material material;
            public int materialIndex;

            public SpecialCharacter(TMP_Character character, int materialIndex);
        }
    }
}
namespace TMPro
{
    public enum TextElementType
    {
        Character = 1,
        Sprite = 2
    }
}
using UnityEngine;
using UnityEngine.TextCore;

namespace TMPro
{
    public class TMP_TextElement
    {
        [SerializeField]
        protected TextElementType m_ElementType;

        public TMP_TextElement();

        public TextElementType elementType { get; }
        public uint unicode { get; set; }
        public TMP_Asset textAsset { get; set; }
        public Glyph glyph { get; set; }
        public uint glyphIndex { get; set; }
        public float scale { get; set; }
    }
}
namespace TMPro
{
    public class TMP_TextElement_Legacy
    {
        public int id;
        public float x;
        public float y;
        public float width;
        public float height;
        public float xOffset;
        public float yOffset;
        public float xAdvance;
        public float scale;

        public TMP_TextElement_Legacy();
    }
}
namespace TMPro
{
    public class TMP_TextInfo
    {
        public TMP_Text textComponent;
        public int characterCount;
        public int spriteCount;
        public int spaceCount;
        public int wordCount;
        public int linkCount;
        public int lineCount;
        public int pageCount;
        public int materialCount;
        public TMP_CharacterInfo[] characterInfo;
        public TMP_WordInfo[] wordInfo;
        public TMP_LinkInfo[] linkInfo;
        public TMP_LineInfo[] lineInfo;
        public TMP_PageInfo[] pageInfo;
        public TMP_MeshInfo[] meshInfo;

        public TMP_TextInfo();
        public TMP_TextInfo(TMP_Text textComponent);

        public void Clear();
        public void ClearMeshInfo(bool updateMesh);
        public void ClearAllMeshInfo();
        public void ResetVertexLayout(bool isVolumetric);
        public void ClearUnusedVertices(MaterialReference[] materials);
        public void ClearLineInfo();
        public TMP_MeshInfo[] CopyMeshInfoVertexData();
        public static void Resize<T>(ref T[] array, int size);
        public static void Resize<T>(ref T[] array, int size, bool isBlockAllocated);
    }
}
namespace TMPro
{
    public class TMP_TextParsingUtilities
    {
        public TMP_TextParsingUtilities();

        public static TMP_TextParsingUtilities instance { get; }

        public static int GetHashCode(string s);
        public static int GetHashCodeCaseSensitive(string s);
        public static char ToLowerASCIIFast(char c);
        public static char ToUpperASCIIFast(char c);
        public static uint ToUpperASCIIFast(uint c);
        public static uint ToLowerASCIIFast(uint c);
        public static bool IsHighSurrogate(uint c);
        public static bool IsLowSurrogate(uint c);
    }
}
namespace TMPro
{
    public struct TMP_FontStyleStack
    {
        public byte bold;
        public byte italic;
        public byte underline;
        public byte strikethrough;
        public byte highlight;
        public byte superscript;
        public byte subscript;
        public byte uppercase;
        public byte lowercase;
        public byte smallcaps;

        public void Clear();
        public byte Add(FontStyles style);
        public byte Remove(FontStyles style);
    }
}
using System.Diagnostics;

namespace TMPro
{
    [DebuggerDisplay("Item count = {m_Count}")]
    public struct TMP_TextProcessingStack<T>
    {
        public T[] itemStack;
        public int index;

        public TMP_TextProcessingStack(T[] stack);
        public TMP_TextProcessingStack(int capacity);
        public TMP_TextProcessingStack(int capacity, int rolloverSize);

        public int Count { get; }
        public T current { get; }
        public int rolloverSize { get; set; }

        public void Clear();
        public void SetDefault(T item);
        public void Add(T item);
        public T Remove();
        public void Push(T item);
        public T Pop();
        public T Peek();
        public T CurrentItem();
        public T PreviousItem();
    }
}
namespace TMPro
{
    public enum CaretPosition
    {
        None = 0,
        Left = 1,
        Right = 2
    }
}
namespace TMPro
{
    public struct CaretInfo
    {
        public int index;
        public CaretPosition position;

        public CaretInfo(int index, CaretPosition position);
    }
}
using UnityEngine;

namespace TMPro
{
    public static class TMP_TextUtilities
    {
        public static int GetCursorIndexFromPosition(TMP_Text textComponent, Vector3 position, Camera camera);
        public static int GetCursorIndexFromPosition(TMP_Text textComponent, Vector3 position, Camera camera, out CaretPosition cursor);
        public static int FindNearestLine(TMP_Text text, Vector3 position, Camera camera);
        public static int FindNearestCharacterOnLine(TMP_Text text, Vector3 position, int line, Camera camera, bool visibleOnly);
        public static bool IsIntersectingRectTransform(RectTransform rectTransform, Vector3 position, Camera camera);
        public static int FindIntersectingCharacter(TMP_Text text, Vector3 position, Camera camera, bool visibleOnly);
        public static int FindNearestCharacter(TMP_Text text, Vector3 position, Camera camera, bool visibleOnly);
        public static int FindIntersectingWord(TMP_Text text, Vector3 position, Camera camera);
        public static int FindNearestWord(TMP_Text text, Vector3 position, Camera camera);
        public static int FindIntersectingLine(TMP_Text text, Vector3 position, Camera camera);
        public static int FindIntersectingLink(TMP_Text text, Vector3 position, Camera camera);
        public static int FindNearestLink(TMP_Text text, Vector3 position, Camera camera);
        public static bool ScreenPointToWorldPointInRectangle(Transform transform, Vector2 screenPoint, Camera cam, out Vector3 worldPoint);
        public static float DistanceToLine(Vector3 a, Vector3 b, Vector3 point);
        public static char ToLowerFast(char c);
        public static char ToUpperFast(char c);
        public static int GetHashCode(string s);
        public static int GetSimpleHashCode(string s);
        public static uint GetSimpleHashCodeLowercase(string s);
        public static int HexToInt(char hex);
        public static int StringHexToInt(string s);
    }
}
namespace TMPro
{
    public class TMP_UpdateManager
    {
        public static void RegisterTextElementForLayoutRebuild(TMP_Text element);
        public static void RegisterTextElementForGraphicRebuild(TMP_Text element);
        public static void RegisterTextElementForCullingUpdate(TMP_Text element);
        public static void UnRegisterTextElementForRebuild(TMP_Text element);
    }
}
using UnityEngine.UI;

namespace TMPro
{
    public class TMP_UpdateRegistry
    {
        protected TMP_UpdateRegistry();

        public static TMP_UpdateRegistry instance { get; }

        public static void RegisterCanvasElementForLayoutRebuild(ICanvasElement element);
        public static void RegisterCanvasElementForGraphicRebuild(ICanvasElement element);
        public static void UnRegisterCanvasElementForRebuild(ICanvasElement element);
    }
}
namespace TMPro
{
    public enum Compute_DistanceTransform_EventTypes
    {
        Processing = 0,
        Completed = 1
    }
}
using UnityEngine;

namespace TMPro
{
    public static class TMPro_EventManager
    {
        public static readonly FastAction<object, Compute_DT_EventArgs> COMPUTE_DT_EVENT;
        public static readonly FastAction<bool, Material> MATERIAL_PROPERTY_EVENT;
        public static readonly FastAction<bool, Object> FONT_PROPERTY_EVENT;
        public static readonly FastAction<bool, Object> SPRITE_ASSET_PROPERTY_EVENT;
        public static readonly FastAction<bool, Object> TEXTMESHPRO_PROPERTY_EVENT;
        public static readonly FastAction<GameObject, Material, Material> DRAG_AND_DROP_MATERIAL_EVENT;
        public static readonly FastAction<bool> TEXT_STYLE_PROPERTY_EVENT;
        public static readonly FastAction<Object> COLOR_GRADIENT_PROPERTY_EVENT;
        public static readonly FastAction TMP_SETTINGS_PROPERTY_EVENT;
        public static readonly FastAction RESOURCE_LOAD_EVENT;
        public static readonly FastAction<bool, Object> TEXTMESHPRO_UGUI_PROPERTY_EVENT;
        public static readonly FastAction<Object> TEXT_CHANGED_EVENT;

        public static void ON_MATERIAL_PROPERTY_CHANGED(bool isChanged, Material mat);
        public static void ON_FONT_PROPERTY_CHANGED(bool isChanged, Object obj);
        public static void ON_SPRITE_ASSET_PROPERTY_CHANGED(bool isChanged, Object obj);
        public static void ON_TEXTMESHPRO_PROPERTY_CHANGED(bool isChanged, Object obj);
        public static void ON_DRAG_AND_DROP_MATERIAL_CHANGED(GameObject sender, Material currentMaterial, Material newMaterial);
        public static void ON_TEXT_STYLE_PROPERTY_CHANGED(bool isChanged);
        public static void ON_COLOR_GRADIENT_PROPERTY_CHANGED(Object obj);
        public static void ON_TEXT_CHANGED(Object obj);
        public static void ON_TMP_SETTINGS_CHANGED();
        public static void ON_RESOURCES_LOADED();
        public static void ON_TEXTMESHPRO_UGUI_PROPERTY_CHANGED(bool isChanged, Object obj);
        public static void ON_COMPUTE_DT_EVENT(object Sender, Compute_DT_EventArgs e);
    }
}
using UnityEngine;

namespace TMPro
{
    public class Compute_DT_EventArgs
    {
        public Compute_DistanceTransform_EventTypes EventType;
        public float ProgressPercentage;
        public Color[] Colors;

        public Compute_DT_EventArgs(Compute_DistanceTransform_EventTypes type, float progress);
        public Compute_DT_EventArgs(Compute_DistanceTransform_EventTypes type, Color[] colors);
    }
}
using System.Collections.Generic;
using UnityEngine;

namespace TMPro
{
    public static class TMPro_ExtensionMethods
    {
        public static int[] ToIntArray(this string text);
        public static string ArrayToString(this char[] chars);
        public static string IntToString(this int[] unicodes);
        public static string IntToString(this int[] unicodes, int start, int length);
        public static int FindInstanceID<T>(this List<T> list, T target) where T : Object;
        public static bool Compare(this Color32 a, Color32 b);
        public static bool CompareRGB(this Color32 a, Color32 b);
        public static bool Compare(this Color a, Color b);
        public static bool CompareRGB(this Color a, Color b);
        public static Color32 Multiply(this Color32 c1, Color32 c2);
        public static Color32 Tint(this Color32 c1, Color32 c2);
        public static Color32 Tint(this Color32 c1, float tint);
        public static Color MinAlpha(this Color c1, Color c2);
        public static bool Compare(this Vector3 v1, Vector3 v2, int accuracy);
        public static bool Compare(this Quaternion q1, Quaternion q2, int accuracy);
    }
}
using UnityEngine;

namespace TMPro
{
    public static class TMP_Math
    {
        public const float FLOAT_MAX = 32767;
        public const float FLOAT_MIN = -32767;
        public const int INT_MAX = 2147483647;
        public const int INT_MIN = -2147483647;
        public const float FLOAT_UNSET = -32767;
        public const int INT_UNSET = -32767;
        public static Vector2 MAX_16BIT;
        public static Vector2 MIN_16BIT;

        public static bool Approximately(float a, float b);
        public static int Mod(int a, int b);
    }
}
namespace TMPro
{
    public enum TMP_VertexDataUpdateFlags
    {
        None = 0,
        Vertices = 1,
        Uv0 = 2,
        Uv2 = 4,
        Uv4 = 8,
        Colors32 = 16,
        All = 255
    }
}
using UnityEngine;

namespace TMPro
{
    public struct VertexGradient
    {
        public Color topLeft;
        public Color topRight;
        public Color bottomLeft;
        public Color bottomRight;

        public VertexGradient(Color color);
        public VertexGradient(Color color0, Color color1, Color color2, Color color3);
    }
}
namespace TMPro
{
    public struct TMP_PageInfo
    {
        public int firstCharacterIndex;
        public int lastCharacterIndex;
        public float ascender;
        public float baseLine;
        public float descender;
    }
}
namespace TMPro
{
    public struct TMP_LinkInfo
    {
        public TMP_Text textComponent;
        public int hashCode;
        public int linkIdFirstCharacterIndex;
        public int linkIdLength;
        public int linkTextfirstCharacterIndex;
        public int linkTextLength;

        public string GetLinkText();
        public string GetLinkID();
    }
}
namespace TMPro
{
    public struct TMP_WordInfo
    {
        public TMP_Text textComponent;
        public int firstCharacterIndex;
        public int lastCharacterIndex;
        public int characterCount;

        public string GetWord();
    }
}
namespace TMPro
{
    public struct TMP_SpriteInfo
    {
        public int spriteIndex;
        public int characterIndex;
        public int vertexIndex;
    }
}
using UnityEngine;

namespace TMPro
{
    public struct Extents
    {
        public Vector2 min;
        public Vector2 max;

        public Extents(Vector2 min, Vector2 max);

        public override string ToString();
    }
}
using UnityEngine;

namespace TMPro
{
    public struct Mesh_Extents
    {
        public Vector2 min;
        public Vector2 max;

        public Mesh_Extents(Vector2 min, Vector2 max);

        public override string ToString();
    }
}
using UnityEngine;

namespace TMPro
{
    public struct WordWrapState
    {
        public int previous_WordBreak;
        public int total_CharacterCount;
        public int visible_CharacterCount;
        public int visible_SpriteCount;
        public int visible_LinkCount;
        public int firstCharacterIndex;
        public int firstVisibleCharacterIndex;
        public int lastCharacterIndex;
        public int lastVisibleCharIndex;
        public int lineNumber;
        public float maxCapHeight;
        public float maxAscender;
        public float maxDescender;
        public float startOfLineAscender;
        public float maxLineAscender;
        public float maxLineDescender;
        public float pageAscender;
        public HorizontalAlignmentOptions horizontalAlignment;
        public float marginLeft;
        public float marginRight;
        public float xAdvance;
        public float preferredWidth;
        public float preferredHeight;
        public float previousLineScale;
        public int wordCount;
        public FontStyles fontStyle;
        public int italicAngle;
        public float fontScaleMultiplier;
        public float currentFontSize;
        public float baselineOffset;
        public float lineOffset;
        public bool isDrivenLineSpacing;
        public float glyphHorizontalAdvanceAdjustment;
        public float cSpace;
        public float mSpace;
        public TMP_TextInfo textInfo;
        public TMP_LineInfo lineInfo;
        public Color32 vertexColor;
        public Color32 underlineColor;
        public Color32 strikethroughColor;
        public Color32 highlightColor;
        public TMP_FontStyleStack basicStyleStack;
        public TMP_TextProcessingStack<int> italicAngleStack;
        public TMP_TextProcessingStack<Color32> colorStack;
        public TMP_TextProcessingStack<Color32> underlineColorStack;
        public TMP_TextProcessingStack<Color32> strikethroughColorStack;
        public TMP_TextProcessingStack<Color32> highlightColorStack;
        public TMP_TextProcessingStack<HighlightState> highlightStateStack;
        public TMP_TextProcessingStack<TMP_ColorGradient> colorGradientStack;
        public TMP_TextProcessingStack<float> sizeStack;
        public TMP_TextProcessingStack<float> indentStack;
        public TMP_TextProcessingStack<FontWeight> fontWeightStack;
        public TMP_TextProcessingStack<int> styleStack;
        public TMP_TextProcessingStack<float> baselineStack;
        public TMP_TextProcessingStack<int> actionStack;
        public TMP_TextProcessingStack<MaterialReference> materialReferenceStack;
        public TMP_TextProcessingStack<HorizontalAlignmentOptions> lineJustificationStack;
        public int spriteAnimationID;
        public TMP_FontAsset currentFontAsset;
        public TMP_SpriteAsset currentSpriteAsset;
        public Material currentMaterial;
        public int currentMaterialIndex;
        public Extents meshExtents;
        public bool tagNoParsing;
        public bool isNonBreakingSpace;
    }
}
namespace TMPro
{
    public struct TagAttribute
    {
        public int startIndex;
        public int length;
        public int hashCode;
    }
}
namespace TMPro
{
    public struct RichTextTagAttribute
    {
        public int nameHashCode;
        public int valueHashCode;
        public TagValueType valueType;
        public int valueStartIndex;
        public int valueLength;
        public TagUnitType unitType;
    }
}
using System;
using UnityEngine;
using UnityEngine.UI;

namespace TMPro
{
    [DisallowMultipleComponent]
    [RequireComponent(typeof(MeshRenderer))]
    [AddComponentMenu("Mesh/TextMeshPro - Text")]
    [ExecuteAlways]
    [HelpURL("https://docs.unity3d.com/Packages/com.unity.textmeshpro@3.0")]
    public class TextMeshPro : TMP_Text, ILayoutElement
    {
        public TextMeshPro();

        public int sortingLayerID { get; set; }
        public int sortingOrder { get; set; }
        public override bool autoSizeTextContainer { get; set; }
        [Obsolete("The TextContainer is now obsolete. Use the RectTransform instead.")]
        public TextContainer textContainer { get; }
        public Transform transform { get; }
        public Renderer renderer { get; }
        public override Mesh mesh { get; }
        public MeshFilter meshFilter { get; }
        public MaskingTypes maskType { get; set; }

        public override event Action<TMP_TextInfo> OnPreRenderText;

        protected override void Awake();
        protected override void OnEnable();
        protected override void OnDisable();
        protected override void OnDestroy();
        protected override void Reset();
        protected override void OnValidate();
        protected override void LoadFontAsset();
        protected override Material GetMaterial(Material mat);
        protected override Material[] GetMaterials(Material[] mats);
        protected override void SetSharedMaterial(Material mat);
        protected override Material[] GetSharedMaterials();
        protected override void SetSharedMaterials(Material[] materials);
        protected override void SetOutlineThickness(float thickness);
        protected override void SetFaceColor(Color32 color);
        protected override void SetOutlineColor(Color32 color);
        protected override void SetShaderDepth();
        protected override void SetCulling();
        public override void ComputeMarginSize();
        protected override void OnDidApplyAnimationProperties();
        protected override void OnTransformParentChanged();
        protected override void OnRectTransformDimensionsChange();
        protected virtual void GenerateTextMesh();
        protected override Vector3[] GetTextContainerLocalCorners();
        protected override void SetActiveSubMeshes(bool state);
        protected void SetActiveSubTextObjectRenderers(bool state);
        protected override void DestroySubMeshObjects();
        protected override Bounds GetCompoundBounds();
        public void SetMask(MaskingTypes type, Vector4 maskCoords);
        public void SetMask(MaskingTypes type, Vector4 maskCoords, float softnessX, float softnessY);
        public override void SetVerticesDirty();
        public override void SetLayoutDirty();
        public override void SetMaterialDirty();
        public override void SetAllDirty();
        public override void Rebuild(CanvasUpdate update);
        protected override void UpdateMaterial();
        public override void UpdateMeshPadding();
        public override void ForceMeshUpdate(bool ignoreActiveState = False, bool forceTextReparsing = False);
        public override TMP_TextInfo GetTextInfo(string text);
        public override void ClearMesh(bool updateMesh);
        public override void UpdateGeometry(Mesh mesh, int index);
        public override void UpdateVertexData(TMP_VertexDataUpdateFlags flags);
        public override void UpdateVertexData();
        public void UpdateFontAsset();
        public void CalculateLayoutInputHorizontal();
        public void CalculateLayoutInputVertical();
    }
}
using System;
using UnityEngine;
using UnityEngine.UI;

namespace TMPro
{
    [DisallowMultipleComponent]
    [RequireComponent(typeof(RectTransform))]
    [RequireComponent(typeof(CanvasRenderer))]
    [AddComponentMenu("UI/TextMeshPro - Text (UI)", 11)]
    [ExecuteAlways]
    [HelpURL("https://docs.unity3d.com/Packages/com.unity.textmeshpro@3.0")]
    public class TextMeshProUGUI : TMP_Text, ILayoutElement
    {
        protected TMP_SubMeshUI[] m_subTextObjects;

        public TextMeshProUGUI();

        public override Material materialForRendering { get; }
        public override bool autoSizeTextContainer { get; set; }
        public override Mesh mesh { get; }
        public CanvasRenderer canvasRenderer { get; }
        public Vector4 maskOffset { get; set; }

        public override event Action<TMP_TextInfo> OnPreRenderText;

        protected override void Awake();
        protected override void OnEnable();
        protected override void OnDisable();
        protected override void OnDestroy();
        protected override void Reset();
        protected override void OnValidate();
        protected override void LoadFontAsset();
        protected override Material GetMaterial(Material mat);
        protected override Material[] GetMaterials(Material[] mats);
        protected override void SetSharedMaterial(Material mat);
        protected override Material[] GetSharedMaterials();
        protected override void SetSharedMaterials(Material[] materials);
        protected override void SetOutlineThickness(float thickness);
        protected override void SetFaceColor(Color32 color);
        protected override void SetOutlineColor(Color32 color);
        protected override void SetShaderDepth();
        protected override void SetCulling();
        public override void ComputeMarginSize();
        protected override void OnDidApplyAnimationProperties();
        protected override void OnCanvasHierarchyChanged();
        protected override void OnTransformParentChanged();
        protected override void OnRectTransformDimensionsChange();
        protected virtual void GenerateTextMesh();
        protected override Vector3[] GetTextContainerLocalCorners();
        protected override void SetActiveSubMeshes(bool state);
        protected override void DestroySubMeshObjects();
        protected override Bounds GetCompoundBounds();
        public void CalculateLayoutInputHorizontal();
        public void CalculateLayoutInputVertical();
        public override void SetVerticesDirty();
        public override void SetLayoutDirty();
        public override void SetMaterialDirty();
        public override void SetAllDirty();
        public override void Rebuild(CanvasUpdate update);
        public override Material GetModifiedMaterial(Material baseMaterial);
        protected override void UpdateMaterial();
        public override void RecalculateClipping();
        public override void Cull(Rect clipRect, bool validRect);
        public override void UpdateMeshPadding();
        protected override void InternalCrossFadeColor(Color targetColor, float duration, bool ignoreTimeScale, bool useAlpha);
        protected override void InternalCrossFadeAlpha(float alpha, float duration, bool ignoreTimeScale);
        public override void ForceMeshUpdate(bool ignoreActiveState = False, bool forceTextReparsing = False);
        public override TMP_TextInfo GetTextInfo(string text);
        public override void ClearMesh();
        public override void UpdateGeometry(Mesh mesh, int index);
        public override void UpdateVertexData(TMP_VertexDataUpdateFlags flags);
        public override void UpdateVertexData();
        public void UpdateFontAsset();
    }
}
namespace TMPro
{
    public enum TextContainerAnchors
    {
        TopLeft = 0,
        Top = 1,
        TopRight = 2,
        Left = 3,
        Middle = 4,
        Right = 5,
        BottomLeft = 6,
        Bottom = 7,
        BottomRight = 8,
        Custom = 9
    }
}
using UnityEngine;
using UnityEngine.EventSystems;

namespace TMPro
{
    [RequireComponent(typeof(RectTransform))]
    public class TextContainer : UIBehaviour
    {
        public TextContainer();

        public bool hasChanged { get; set; }
        public Vector2 pivot { get; set; }
        public TextContainerAnchors anchorPosition { get; set; }
        public Rect rect { get; set; }
        public Vector2 size { get; set; }
        public float width { get; set; }
        public float height { get; set; }
        public bool isDefaultWidth { get; }
        public bool isDefaultHeight { get; }
        public bool isAutoFitting { get; set; }
        public Vector3[] corners { get; }
        public Vector3[] worldCorners { get; }
        public Vector4 margins { get; set; }
        public RectTransform rectTransform { get; }
        public TextMeshPro textMeshPro { get; }

        protected override void Awake();
        protected override void OnEnable();
        protected override void OnDisable();
        protected override void OnValidate();
        protected override void OnRectTransformDimensionsChange();
    }
}
namespace TMPro.SpriteAssetUtilities
{
    public enum SpriteAssetImportFormats
    {
        None = 0,
        TexturePackerJsonArray = 1
    }
}
using System.Collections.Generic;
using UnityEngine;

namespace TMPro.SpriteAssetUtilities
{
    public class TexturePacker_JsonArray
    {
        public TexturePacker_JsonArray();

        public struct SpriteFrame
        {
            public float x;
            public float y;
            public float w;
            public float h;

            public override string ToString();
        }
        public struct SpriteSize
        {
            public float w;
            public float h;

            public override string ToString();
        }
        public struct Frame
        {
            public string filename;
            public SpriteFrame frame;
            public bool rotated;
            public bool trimmed;
            public SpriteFrame spriteSourceSize;
            public SpriteSize sourceSize;
            public Vector2 pivot;
        }
        public struct Meta
        {
            public string app;
            public string version;
            public string image;
            public string format;
            public SpriteSize size;
            public float scale;
            public string smartupdate;
        }
        public class SpriteDataObject
        {
            public List<Frame> frames;
            public Meta meta;

            public SpriteDataObject();
        }
    }
}
-------- {UnityEditor.TestRunner(D:\Documents\GitHub\Rogue-like-game-i-guess\The game is liar\Library\ScriptAssemblies\UnityEditor.TestRunner.dll)}:  283 --------
using System.Collections;
using System.Runtime.CompilerServices;

namespace UnityEngine.TestTools
{
    public class EnterPlayMode : IEditModeTestYieldInstruction
    {
        public EnterPlayMode(bool expectDomainReload = True);

        public bool ExpectDomainReload { get; }
        public bool ExpectedPlaymodeState { get; }

        [IteratorStateMachine(typeof(<Perform>d__8))]
        public IEnumerator Perform();
    }
}
using System.Collections;
using System.Runtime.CompilerServices;

namespace UnityEngine.TestTools
{
    public class ExitPlayMode : IEditModeTestYieldInstruction
    {
        public ExitPlayMode();

        public bool ExpectDomainReload { get; }
        public bool ExpectedPlaymodeState { get; }

        [IteratorStateMachine(typeof(<Perform>d__8))]
        public IEnumerator Perform();
    }
}
using System.Collections;
using System.Runtime.CompilerServices;

namespace UnityEngine.TestTools
{
    public class RecompileScripts : IEditModeTestYieldInstruction
    {
        public RecompileScripts();
        public RecompileScripts(bool expectScriptCompilation);
        public RecompileScripts(bool expectScriptCompilation, bool expectScriptCompilationSuccess);

        public bool ExpectDomainReload { get; }
        public bool ExpectedPlaymodeState { get; }
        public bool ExpectScriptCompilation { get; }
        public bool ExpectScriptCompilationSuccess { get; }
        public static RecompileScripts Current { get; }

        [IteratorStateMachine(typeof(<Perform>d__22))]
        public IEnumerator Perform();
    }
}
using System.Collections;
using System.Runtime.CompilerServices;

namespace UnityEngine.TestTools
{
    public class WaitForDomainReload : IEditModeTestYieldInstruction
    {
        public WaitForDomainReload();

        public bool ExpectDomainReload { get; }
        public bool ExpectedPlaymodeState { get; }

        [IteratorStateMachine(typeof(<Perform>d__7))]
        public IEnumerator Perform();
    }
}
namespace UnityEditor.TestTools
{
    public interface ITestPlayerBuildModifier
    {
        BuildPlayerOptions ModifyOptions(BuildPlayerOptions playerOptions);
    }
}
using System;

namespace UnityEditor.TestTools
{
    [AttributeUsage(Assembly)]
    public class TestPlayerBuildModifierAttribute : Attribute
    {
        public TestPlayerBuildModifierAttribute(Type type);
    }
}
using NUnit.Framework;
using NUnit.Framework.Interfaces;
using System;

namespace UnityEditor.TestTools
{
    [AttributeUsage(Assembly, Class, Method)]
    public class RequirePlatformSupportAttribute : NUnitAttribute, IApplyToTest
    {
        public RequirePlatformSupportAttribute(params BuildTarget[] platforms);

        public BuildTarget[] platforms { get; }
    }
}
namespace UnityEditor.TestTools.TestRunner
{
    public class TestRunnerWindow : EditorWindow, IHasCustomMenu
    {
        public TestRunnerWindow();

        [MenuItem("Window/General/Test Runner", False, 201, False)]
        public static void ShowWindow();
        public void AddItemsToMenu(GenericMenu menu);
    }
}
using UnityEngine;

namespace UnityEditor.TestTools.TestRunner.Api
{
    public class ExecutionSettings
    {
        public ITestRunSettings overloadTestRunSettings;
        [SerializeField]
        public Filter[] filters;
        [SerializeField]
        public bool runSynchronously;
        [SerializeField]
        public int playerHeartbeatTimeout;

        public ExecutionSettings(params Filter[] filtersToExecute);
    }
}
using UnityEngine;

namespace UnityEditor.TestTools.TestRunner.Api
{
    public class Filter
    {
        [SerializeField]
        public TestMode testMode;
        [SerializeField]
        public string[] testNames;
        [SerializeField]
        public string[] groupNames;
        [SerializeField]
        public string[] categoryNames;
        [SerializeField]
        public string[] assemblyNames;
        [SerializeField]
        public BuildTarget? targetPlatform;

        public Filter();
    }
}
namespace UnityEditor.TestTools.TestRunner.Api
{
    public interface ICallbacks
    {
        void RunStarted(ITestAdaptor testsToRun);
        void RunFinished(ITestResultAdaptor result);
        void TestStarted(ITestAdaptor test);
        void TestFinished(ITestResultAdaptor result);
    }
}
namespace UnityEditor.TestTools.TestRunner.Api
{
    public interface IErrorCallbacks : ICallbacks
    {
        void OnError(string message);
    }
}
using NUnit.Framework.Interfaces;
using System.Collections.Generic;

namespace UnityEditor.TestTools.TestRunner.Api
{
    public interface ITestAdaptor
    {
        string Id { get; }
        string Name { get; }
        string FullName { get; }
        int TestCaseCount { get; }
        bool HasChildren { get; }
        bool IsSuite { get; }
        IEnumerable<ITestAdaptor> Children { get; }
        ITestAdaptor Parent { get; }
        int TestCaseTimeout { get; }
        ITypeInfo TypeInfo { get; }
        IMethodInfo Method { get; }
        string[] Categories { get; }
        bool IsTestAssembly { get; }
        RunState RunState { get; }
        string Description { get; }
        string SkipReason { get; }
        string ParentId { get; }
        string ParentFullName { get; }
        string UniqueName { get; }
        string ParentUniqueName { get; }
        int ChildIndex { get; }
        TestMode TestMode { get; }
    }
}
using NUnit.Framework.Interfaces;
using System;
using System.Collections.Generic;

namespace UnityEditor.TestTools.TestRunner.Api
{
    public interface ITestResultAdaptor
    {
        ITestAdaptor Test { get; }
        string Name { get; }
        string FullName { get; }
        string ResultState { get; }
        TestStatus TestStatus { get; }
        double Duration { get; }
        DateTime StartTime { get; }
        DateTime EndTime { get; }
        string Message { get; }
        string StackTrace { get; }
        int AssertCount { get; }
        int FailCount { get; }
        int PassCount { get; }
        int SkipCount { get; }
        int InconclusiveCount { get; }
        bool HasChildren { get; }
        IEnumerable<ITestResultAdaptor> Children { get; }
        string Output { get; }

        TNode ToXml();
    }
}
using System;

namespace UnityEditor.TestTools.TestRunner.Api
{
    public interface ITestRunSettings : IDisposable
    {
        void Apply();
    }
}
namespace UnityEditor.TestTools.TestRunner.Api
{
    public enum RunState
    {
        NotRunnable = 0,
        Runnable = 1,
        Explicit = 2,
        Skipped = 3,
        Ignored = 4
    }
}
using System;

namespace UnityEditor.TestTools.TestRunner.Api
{
    [Flags]
    public enum TestMode
    {
        EditMode = 1,
        PlayMode = 2
    }
}
using System;
using UnityEngine;

namespace UnityEditor.TestTools.TestRunner.Api
{
    public class TestRunnerApi : ScriptableObject, ITestRunnerApi
    {
        public TestRunnerApi();

        public string Execute(ExecutionSettings executionSettings);
        public void RegisterCallbacks<T>(T testCallbacks, int priority = 0) where T : ICallbacks;
        public void UnregisterCallbacks<T>(T testCallbacks) where T : ICallbacks;
        public void RetrieveTestList(TestMode testMode, Action<ITestAdaptor> callback);
    }
}
namespace UnityEditor.TestTools.TestRunner.Api
{
    public enum TestStatus
    {
        Inconclusive = 0,
        Skipped = 1,
        Passed = 2,
        Failed = 3
    }
}
-------- {Unity.Searcher.Editor(D:\Documents\GitHub\Rogue-like-game-i-guess\The game is liar\Library\ScriptAssemblies\Unity.Searcher.Editor.dll)}:   22 --------
using JetBrains.Annotations;
using System;
using System.Collections.Generic;

namespace UnityEditor.Searcher
{
    [PublicAPI]
    public class Searcher
    {
        public Searcher(SearcherDatabaseBase database, string title);
        public Searcher(IEnumerable<SearcherDatabaseBase> databases, string title);
        public Searcher(SearcherDatabaseBase database, ISearcherAdapter adapter = null);
        public Searcher(IEnumerable<SearcherDatabaseBase> databases, ISearcherAdapter adapter = null);

        public ISearcherAdapter Adapter { get; }
        public Comparison<SearcherItem> SortComparison { get; set; }

        public void BuildIndices();
        public IEnumerable<SearcherItem> Search(string query);

        [PublicAPI]
        public class AnalyticsEvent
        {
            public readonly EventType eventType;
            public readonly string currentSearchFieldText;

            public AnalyticsEvent(EventType eventType, string currentSearchFieldText);

            [PublicAPI]
            public enum EventType
            {
                Pending = 0,
                Picked = 1,
                Cancelled = 2
            }
        }
    }
}
namespace UnityEditor.Searcher
{
    public enum ItemExpanderState
    {
        Hidden = 0,
        Collapsed = 1,
        Expanded = 2
    }
}
using JetBrains.Annotations;
using System.Collections.Generic;
using UnityEngine.UIElements;

namespace UnityEditor.Searcher
{
    [PublicAPI]
    public interface ISearcherAdapter
    {
        string Title { get; }
        bool HasDetailsPanel { get; }
        bool AddAllChildResults { get; }
        float InitialSplitterDetailRatio { get; }

        VisualElement MakeItem();
        VisualElement Bind(VisualElement target, SearcherItem item, ItemExpanderState expanderState, string text);
        void OnSelectionChanged(IEnumerable<SearcherItem> items);
        void InitDetailsPanel(VisualElement detailsPanel);
    }
}
using JetBrains.Annotations;
using System.Collections.Generic;
using UnityEngine.UIElements;

namespace UnityEditor.Searcher
{
    [PublicAPI]
    public class SearcherAdapter : ISearcherAdapter
    {
        public SearcherAdapter(string title);

        public virtual string Title { get; }
        public virtual bool HasDetailsPanel { get; }
        public virtual bool AddAllChildResults { get; }
        public virtual float InitialSplitterDetailRatio { get; }

        public virtual VisualElement MakeItem();
        public virtual VisualElement Bind(VisualElement element, SearcherItem item, ItemExpanderState expanderState, string query);
        public virtual void InitDetailsPanel(VisualElement detailsPanel);
        public virtual void OnSelectionChanged(IEnumerable<SearcherItem> items);
    }
}
using JetBrains.Annotations;
using System;
using System.Collections.Generic;

namespace UnityEditor.Searcher
{
    [PublicAPI]
    public class SearcherDatabase : SearcherDatabaseBase
    {
        public SearcherDatabase(IReadOnlyCollection<SearcherItem> db);

        public Func<string, SearcherItem, bool> MatchFilter { get; set; }

        public static SearcherDatabase Create(List<SearcherItem> items, string databaseDirectory, bool serializeToFile = True);
        public static SearcherDatabase Load(string databaseDirectory);
        public override List<SearcherItem> Search(string query, out float localMaxScore);
        protected virtual bool Match(string query, IReadOnlyList<string> tokenizedQuery, SearcherItem item, out float score);
        public override void BuildIndex();
    }
}
using JetBrains.Annotations;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace UnityEditor.Searcher
{
    [PublicAPI]
    public abstract class SearcherDatabaseBase
    {
        protected const string k_SerializedJsonFile = "/SerializedDatabase.json";
        [SerializeField]
        protected List<SearcherItem> m_ItemList;

        protected SearcherDatabaseBase(string databaseDirectory);

        public string DatabaseDirectory { get; set; }
        public IList<SearcherItem> ItemList { get; }

        public virtual void BuildIndex();
        public abstract List<SearcherItem> Search(string query, out float localMaxScore);
        protected void LoadFromFile();
        protected void SerializeToFile();
        protected void AddItemToIndex(SearcherItem item, ref int lastId, Action<SearcherItem> action);
    }
}
using JetBrains.Annotations;
using System.Collections.Generic;

namespace UnityEditor.Searcher
{
    [PublicAPI]
    public class SearcherItem
    {
        public SearcherItem(string name, string help = "", List<SearcherItem> children = null);

        public int Id { get; }
        public virtual string Name { get; }
        public string Path { get; }
        public string Help { get; }
        public string[] Synonyms { get; set; }
        public int Depth { get; }
        public SearcherItem Parent { get; }
        public SearcherDatabaseBase Database { get; }
        public List<SearcherItem> Children { get; }
        public bool HasChildren { get; }

        public void AddChild(SearcherItem child);
        public override string ToString();
    }
}
using JetBrains.Annotations;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace UnityEditor.Searcher
{
    [PublicAPI]
    public class SearcherWindow : EditorWindow
    {
        public SearcherWindow();

        public static void Show(EditorWindow host, IList<SearcherItem> items, string title, Func<SearcherItem, bool> itemSelectedDelegate, Vector2 displayPosition, Alignment align = null);
        public static void Show(EditorWindow host, IList<SearcherItem> items, ISearcherAdapter adapter, Func<SearcherItem, bool> itemSelectedDelegate, Vector2 displayPosition, Action<Searcher.AnalyticsEvent> analyticsDataDelegate, Alignment align = null);
        public static void Show(EditorWindow host, IList<SearcherItem> items, string title, string directoryPath, Func<SearcherItem, bool> itemSelectedDelegate, Vector2 displayPosition, Alignment align = null);
        public static void Show(EditorWindow host, IEnumerable<SearcherItem> items, ISearcherAdapter adapter, string directoryPath, Func<SearcherItem, bool> itemSelectedDelegate, Vector2 displayPosition, Action<Searcher.AnalyticsEvent> analyticsDataDelegate, Alignment align = null);
        public static void Show(EditorWindow host, Searcher searcher, Func<SearcherItem, bool> itemSelectedDelegate, Vector2 displayPosition, Action<Searcher.AnalyticsEvent> analyticsDataDelegate, Alignment align = null);
        public static void Show(EditorWindow host, Searcher searcher, Func<SearcherItem, bool> itemSelectedDelegate, Action<Searcher.AnalyticsEvent> analyticsDataDelegate, Rect rect);
        public static Vector2 GetPositionWithAlignment(Vector2 pos, Vector2 size, Alignment align);

        [PublicAPI]
        public struct Alignment
        {
            public readonly Vertical vertical;
            public readonly Horizontal horizontal;

            public Alignment(Vertical v, Horizontal h);

            [PublicAPI]
            public enum Horizontal
            {
                Left = 0,
                Center = 1,
                Right = 2
            }
            [PublicAPI]
            public enum Vertical
            {
                Top = 0,
                Center = 1,
                Bottom = 2
            }
        }
    }
}
-------- {Unity.MemoryProfiler.Editor(D:\Documents\GitHub\Rogue-like-game-i-guess\The game is liar\Library\ScriptAssemblies\Unity.MemoryProfiler.Editor.dll)}:  726 --------
namespace Unity.MemoryProfiler.Editor.UI
{
    public enum IssueLevel
    {
        Info = 0,
        Warning = 1,
        Error = 2
    }
}
using System;
using UnityEditor;
using UnityEditor.IMGUI.Controls;

namespace Unity.MemoryProfiler.Editor.UI.PathsToRoot
{
    public class MultiColumnHeaderWithTruncateTypeName : MultiColumnHeader
    {
        public MultiColumnHeaderWithTruncateTypeName(MultiColumnHeaderState state);

        public event Action<bool> TruncationChangedViaThisHeader;

        protected override void AddColumnHeaderContextMenuItems(GenericMenu menu);
    }
}
namespace Unity.MemoryProfiler.Editor.UI.PathsToRoot
{
    public static class PathsToRootUtils
    {
    }
}
namespace Unity.MemoryProfiler.Editor.UI.MemoryMap
{
    public enum RegionType
    {
        Native = 0,
        VirtualMemory = 1,
        Managed = 2,
        ManagedStack = 3,
        ManagedDomain = 4
    }
}
namespace Unity.MemoryProfiler.Editor.Format
{
    public enum FormatVersion
    {
        SnapshotMinSupportedFormatVersion = 8,
        NativeConnectionsAsInstanceIdsVersion = 10,
        ProfileTargetInfoAndMemStatsVersion = 11,
        MemLabelSizeAndHeapIdVersion = 12,
        SceneRootsAndAssetBundlesVersion = 13,
        GfxResourceReferencesAndAllocatorsVersion = 14
    }
}
namespace Unity.MemoryProfiler.Editor.Format.QueriedSnapshot
{
    public enum EntryFormat
    {
        Undefined = 0,
        SingleElement = 1,
        ConstantSizeElementArray = 2,
        DynamicSizeElementArray = 3
    }
}
namespace Unity.MemoryProfiler.Editor.Format.QueriedSnapshot
{
    public enum EntryType
    {
        Metadata_Version = 0,
        Metadata_RecordDate = 1,
        Metadata_UserMetadata = 2,
        Metadata_CaptureFlags = 3,
        Metadata_VirtualMachineInformation = 4,
        NativeTypes_Name = 5,
        NativeTypes_NativeBaseTypeArrayIndex = 6,
        NativeObjects_NativeTypeArrayIndex = 7,
        NativeObjects_HideFlags = 8,
        NativeObjects_Flags = 9,
        NativeObjects_InstanceId = 10,
        NativeObjects_Name = 11,
        NativeObjects_NativeObjectAddress = 12,
        NativeObjects_Size = 13,
        NativeObjects_RootReferenceId = 14,
        GCHandles_Target = 15,
        Connections_From = 16,
        Connections_To = 17,
        ManagedHeapSections_StartAddress = 18,
        ManagedHeapSections_Bytes = 19,
        ManagedStacks_StartAddress = 20,
        ManagedStacks_Bytes = 21,
        TypeDescriptions_Flags = 22,
        TypeDescriptions_Name = 23,
        TypeDescriptions_Assembly = 24,
        TypeDescriptions_FieldIndices = 25,
        TypeDescriptions_StaticFieldBytes = 26,
        TypeDescriptions_BaseOrElementTypeIndex = 27,
        TypeDescriptions_Size = 28,
        TypeDescriptions_TypeInfoAddress = 29,
        TypeDescriptions_TypeIndex = 30,
        FieldDescriptions_Offset = 31,
        FieldDescriptions_TypeIndex = 32,
        FieldDescriptions_Name = 33,
        FieldDescriptions_IsStatic = 34,
        NativeRootReferences_Id = 35,
        NativeRootReferences_AreaName = 36,
        NativeRootReferences_ObjectName = 37,
        NativeRootReferences_AccumulatedSize = 38,
        NativeAllocations_MemoryRegionIndex = 39,
        NativeAllocations_RootReferenceId = 40,
        NativeAllocations_AllocationSiteId = 41,
        NativeAllocations_Address = 42,
        NativeAllocations_Size = 43,
        NativeAllocations_OverheadSize = 44,
        NativeAllocations_PaddingSize = 45,
        NativeMemoryRegions_Name = 46,
        NativeMemoryRegions_ParentIndex = 47,
        NativeMemoryRegions_AddressBase = 48,
        NativeMemoryRegions_AddressSize = 49,
        NativeMemoryRegions_FirstAllocationIndex = 50,
        NativeMemoryRegions_NumAllocations = 51,
        NativeMemoryLabels_Name = 52,
        NativeAllocationSites_Id = 53,
        NativeAllocationSites_MemoryLabelIndex = 54,
        NativeAllocationSites_CallstackSymbols = 55,
        NativeCallstackSymbol_Symbol = 56,
        NativeCallstackSymbol_ReadableStackTrace = 57,
        NativeObjects_GCHandleIndex = 58,
        ProfileTarget_Info = 59,
        ProfileTarget_MemoryStats = 60,
        NativeMemoryLabels_Size = 61,
        SceneObjects_Name = 62,
        SceneObjects_Path = 63,
        SceneObjects_AssetPath = 64,
        SceneObjects_BuildIndex = 65,
        SceneObjects_RootIdCounts = 66,
        SceneObjects_RootIdOffsets = 67,
        SceneObjects_RootIds = 68,
        NativeMemoryLabels_AllocatorIdentifier = 69,
        NativeGfxResourceReferences_Id = 70,
        NativeGfxResourceReferences_Size = 71,
        NativeGfxResourceReferences_RootId = 72,
        NativeAllocatorInfo_AllocatorName = 73,
        NativeAllocatorInfo_Identifier = 74,
        NativeAllocatorInfo_UsedSize = 75,
        NativeAllocatorInfo_ReservedSize = 76,
        NativeAllocatorInfo_OverheadSize = 77,
        NativeAllocatorInfo_PeakUsedSize = 78,
        NativeAllocatorInfo_AllocationCount = 79,
        NativeAllocatorInfo_Flags = 80,
        Count = 81
    }
}
using Unity.IO.LowLevel.Unsafe;

namespace Unity.MemoryProfiler.Editor.Format.QueriedSnapshot
{
    public struct ScheduleResult
    {
        public ReadHandle handle;
        public ReadError error;
    }
}
using System;
using Unity.Collections;
using Unity.MemoryProfiler.Editor.Containers;

namespace Unity.MemoryProfiler.Editor.Format.QueriedSnapshot
{
    public struct FileReader : IFileReader, IReader, IDisposable
    {
        public bool HasOpenFile { get; }
        public string FullPath { get; }
        public FormatVersion FormatVersion { get; }
        public uint FormatVersionNumeric { get; }

        public ReadError Open(string filePath);
        public EntryFormat GetEntryFormat(EntryType type);
        public long GetSizeForEntryRange(EntryType entry, long offset, long count);
        public uint GetEntryCount(EntryType entry);
        public GenericReadOperation Read(EntryType entry, DynamicArray<byte> buffer, long offset, long count);
        public GenericReadOperation Read(EntryType entry, long offset, long count, Allocator allocator);
        public ReadError ReadUnsafe(EntryType entry, void* buffer, long bufferLength, long offset, long count);
        public GenericReadOperation AsyncRead(EntryType entry, long offset, long count, Allocator allocator);
        public GenericReadOperation AsyncRead(EntryType entry, DynamicArray<byte> buffer, long offset, long count);
        public void Close();
        public void Dispose();
    }
}
using Unity.MemoryProfiler.Editor.Containers;
using UnityEngine;

namespace Unity.MemoryProfiler.Editor.Format.QueriedSnapshot
{
    public class GenericReadOperation : CustomYieldInstruction
    {
        public override bool keepWaiting { get; }
        public ReadError Error { get; }
        public DynamicArray<byte> Result { get; }
        public bool IsDone { get; }

        public void Complete();
        public void Dispose();
    }
}
namespace Unity.MemoryProfiler.Editor.Format.QueriedSnapshot
{
    public enum ReadError
    {
        None = 0,
        Success = 1,
        InProgress = 2,
        FileReadFailed = 3,
        FileNotFound = 4,
        InvalidHeaderSignature = 5,
        InvalidDirectorySignature = 6,
        InvalidFooterSignature = 7,
        InvalidChapterLocation = 8,
        InvalidChapterSectionVersion = 9,
        InvalidBlockSectionVersion = 10,
        InvalidBlockSectionCount = 11,
        InvalidEntryFormat = 12,
        EmptyFormatEntry = 13
    }
}
namespace Unity.MemoryProfiler.Editor.Format.LowLevel.IO
{
    public enum ReadMode
    {
        Async = 0,
        Blocking = 1
    }
}
using System;
using Unity.IO.LowLevel.Unsafe;

namespace Unity.MemoryProfiler.Editor.Format.LowLevel.IO
{
    public struct LowLevelFileReader : IDisposable
    {
        public LowLevelFileReader(string filePath);

        public long FileLength { get; }
        public bool IsCreated { get; }
        public string FilePath { get; }

        public void Dispose();
        public ReadHandle Read(ReadCommand* readCmds, uint cmdCount, ReadMode mode = Async);
    }
}
using Unity.IO.LowLevel.Unsafe;

namespace Unity.MemoryProfiler.Editor.Format.LowLevel.IO
{
    public static class ReadCommandBufferUtils
    {
        public static ReadCommand GetCommand(void* buffer, long readSize, long offset);
    }
}
namespace Unity.MemoryProfiler.Editor.Database
{
    public enum DataMatchMethod
    {
        AsString = 0,
        AsNumber = 1,
        AsEnum = 2
    }
}
using System;
using System.Reflection;
using Unity.Collections;

namespace Unity.MemoryProfiler.Editor.Containers
{
    [DefaultMember("Item")]
    public struct DynamicArray<T> : IDisposable where T : unmanaged
    {
        public DynamicArray(Allocator label);
        public DynamicArray(long initialSize, Allocator label, bool memClear = False);

        public T this[long idx] { get; set; }
        public long Count { get; }
        public long Capacity { get; set; }
        public bool IsCreated { get; }

        public DynamicArray<U> Reinterpret<U>() where U : unmanaged;
        public DynamicArray<U> Reinterpret<U>(int expectedTypeSize) where U : unmanaged;
        public void CopyFrom(T[] arr);
        public void* GetUnsafePtr();
        public T Back();
        public void Resize(long newSize, bool memClear);
        public void Push(T value);
        public T Pop();
        public void Clear(bool stomp);
        public void ShrinkToFit();
        public void Dispose();
    }
}
using System;
using System.Reflection;

namespace Unity.MemoryProfiler.Editor.Containers
{
    [DefaultMember("Item")]
    public struct DynamicBlockArray<T> : IDisposable where T : struct
    {
        public const int k_InitialBlockSlots = 8;

        public DynamicBlockArray(int blockSize, int initialCapacity);

        public T this[long idx] { get; set; }
        public uint Count { get; }
        public uint Capacity { get; set; }

        public T Back();
        public void Push(T value);
        public T Pop();
        public void Clear(bool stomp);
        public void Dispose();
    }
}
-------- {Unity.2D.Sprite.Editor(D:\Documents\GitHub\Rogue-like-game-i-guess\The game is liar\Library\ScriptAssemblies\Unity.2D.Sprite.Editor.dll)}:  118 --------
using UnityEngine;

namespace UnityEditor
{
    public class SpriteRect
    {
        public SpriteRect();

        public string name { get; set; }
        public Vector2 pivot { get; set; }
        public SpriteAlignment alignment { get; set; }
        public Vector4 border { get; set; }
        public Rect rect { get; set; }
        public GUID spriteID { get; set; }

        public static GUID GetSpriteIDFromSerializedProperty(SerializedProperty sp);
    }
}
using System;
using UnityEngine;

namespace UnityEditor.U2D.Sprites
{
    public interface ISpriteEditorDataProvider
    {
        SpriteImportMode spriteImportMode { get; }
        float pixelsPerUnit { get; }
        UnityEngine.Object targetObject { get; }

        SpriteRect[] GetSpriteRects();
        void SetSpriteRects(SpriteRect[] spriteRects);
        void Apply();
        void InitSpriteEditorDataProvider();
        T GetDataProvider<T>() where T : class;
        bool HasDataProvider(Type type);
    }
}
using System.Collections.Generic;
using UnityEngine.U2D;

namespace UnityEditor.U2D.Sprites
{
    public interface ISpriteBoneDataProvider
    {
        List<SpriteBone> GetBones(GUID guid);
        void SetBones(GUID guid, List<SpriteBone> bones);
    }
}
using System.Collections.Generic;
using UnityEngine;

namespace UnityEditor.U2D.Sprites
{
    public interface ISpriteOutlineDataProvider
    {
        List<Vector2[]> GetOutlines(GUID guid);
        void SetOutlines(GUID guid, List<Vector2[]> data);
        float GetTessellationDetail(GUID guid);
        void SetTessellationDetail(GUID guid, float value);
    }
}
using System.Collections.Generic;
using UnityEngine;

namespace UnityEditor.U2D.Sprites
{
    public interface ISpritePhysicsOutlineDataProvider
    {
        List<Vector2[]> GetOutlines(GUID guid);
        void SetOutlines(GUID guid, List<Vector2[]> data);
        float GetTessellationDetail(GUID guid);
        void SetTessellationDetail(GUID guid, float value);
    }
}
using UnityEngine;

namespace UnityEditor.U2D.Sprites
{
    public interface ITextureDataProvider
    {
        Texture2D texture { get; }
        Texture2D previewTexture { get; }

        void GetTextureActualWidthAndHeight(out int width, out int height);
        Texture2D GetReadableTexture2D();
    }
}
using UnityEngine;

namespace UnityEditor.U2D.Sprites
{
    public interface ISecondaryTextureDataProvider
    {
        SecondarySpriteTexture[] textures { get; set; }
    }
}
using UnityEngine;

namespace UnityEditor.U2D.Sprites
{
    public struct Vertex2DMetaData
    {
        public Vector2 position;
        public BoneWeight boneWeight;
    }
}
using UnityEngine;

namespace UnityEditor.U2D.Sprites
{
    public interface ISpriteMeshDataProvider
    {
        Vertex2DMetaData[] GetVertices(GUID guid);
        void SetVertices(GUID guid, Vertex2DMetaData[] vertices);
        int[] GetIndices(GUID guid);
        void SetIndices(GUID guid, int[] indices);
        Vector2Int[] GetEdges(GUID guid);
        void SetEdges(GUID guid, Vector2Int[] edges);
    }
}
namespace UnityEditor.U2D.Sprites
{
    public interface ISpriteDataProviderFactory<T>
    {
        ISpriteEditorDataProvider CreateDataProvider(T obj);
    }
}
using UnityEngine;

namespace UnityEditor.U2D.Sprites
{
    public class SpriteDataProviderFactories
    {
        public SpriteDataProviderFactories();

        public void Init();
        public ISpriteEditorDataProvider GetSpriteEditorDataProviderFromObject(Object obj);
    }
}
using UnityEngine;

namespace UnityEditor.U2D.Sprites
{
    public abstract class SpriteEditorModuleBase
    {
        protected SpriteEditorModuleBase();

        public ISpriteEditor spriteEditor { get; }
        public abstract string moduleName { get; }

        public abstract bool CanBeActivated();
        public abstract void DoMainGUI();
        public abstract void DoToolbarGUI(Rect drawArea);
        public abstract void OnModuleActivate();
        public abstract void OnModuleDeactivate();
        public abstract void DoPostGUI();
        public abstract bool ApplyRevert(bool apply);
    }
}
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.U2D.Sprites
{
    public interface ISpriteEditor
    {
        List<SpriteRect> spriteRects { set; }
        SpriteRect selectedSpriteRect { get; set; }
        bool enableMouseMoveEvent { set; }
        bool editingDisabled { get; }
        Rect windowDimension { get; }
        float zoomLevel { get; set; }
        Vector2 scrollPosition { get; set; }
        bool showAlpha { get; set; }
        float mipLevel { get; set; }

        T GetDataProvider<T>() where T : class;
        bool HandleSpriteSelection();
        void RequestRepaint();
        void SetDataModified();
        void ApplyOrRevertModification(bool apply);
        VisualElement GetMainVisualContainer();
        void SetPreviewTexture(Texture2D texture, int width, int height);
        void ResetZoomAndScroll();
    }
}
using System;

namespace UnityEditor.U2D.Sprites
{
    [AttributeUsage(Class, Inherited = False, AllowMultiple = False)]
    public class RequireSpriteDataProviderAttribute : Attribute
    {
        public RequireSpriteDataProviderAttribute(params Type[] types);
    }
}
using System;

namespace UnityEditor.U2D.Sprites.Obsolete
{
    public static class ObsoleteSupport
    {
        [Obsolete("Sprite Packer is no longer supported. Consider switching to the new Sprite Altas System")]
        public static void ShowSpritePacker();
    }
}
-------- {Unity.ShaderGraph.Utilities(D:\Documents\GitHub\Rogue-like-game-i-guess\The game is liar\Library\ScriptAssemblies\Unity.ShaderGraph.Utilities.dll)}:    2 --------
-------- {Unity.RenderPipelines.Core.Runtime(D:\Documents\GitHub\Rogue-like-game-i-guess\The game is liar\Library\ScriptAssemblies\Unity.RenderPipelines.Core.Runtime.dll)}:  288 --------
using UnityEngine;
using UnityEngine.Rendering;

[ExecuteAlways]
public class SceneRenderPipeline : MonoBehaviour
{
    public RenderPipelineAsset renderPipelineAsset;

    public SceneRenderPipeline();
}
namespace UnityEngine
{
    public class InputManagerEntry
    {
        public string name;
        public string desc;
        public string btnNegative;
        public string btnPositive;
        public string altBtnNegative;
        public string altBtnPositive;
        public float gravity;
        public float deadZone;
        public float sensitivity;
        public bool snap;
        public bool invert;
        public Kind kind;
        public Axis axis;
        public Joy joystick;

        public InputManagerEntry();

        public enum Kind
        {
            KeyOrButton = 0,
            Mouse = 1,
            Axis = 2
        }
        public enum Axis
        {
            X = 0,
            Y = 1,
            Third = 2,
            Fourth = 3,
            Fifth = 4,
            Sixth = 5,
            Seventh = 6,
            Eigth = 7
        }
        public enum Joy
        {
            All = 0,
            First = 1,
            Second = 2
        }
    }
}
using System.Collections.Generic;

namespace UnityEngine
{
    public static class InputRegistering
    {
        public static void RegisterInputs(List<InputManagerEntry> entries);
    }
}
using UnityEngine.Rendering;

namespace UnityEngine.Experimental.Rendering
{
    public struct RendererList
    {
        public static readonly RendererList nullRendererList;
        public CullingResults cullingResult;
        public DrawingSettings drawSettings;
        public FilteringSettings filteringSettings;
        public RenderStateBlock? stateBlock;

        public bool isValid { get; }

        public static RendererList Create(in RendererListDesc desc);
    }
}
using UnityEngine.Rendering;

namespace UnityEngine.Experimental.Rendering
{
    public struct RendererListDesc
    {
        public SortingCriteria sortingCriteria;
        public PerObjectData rendererConfiguration;
        public RenderQueueRange renderQueueRange;
        public RenderStateBlock? stateBlock;
        public Material overrideMaterial;
        public bool excludeObjectMotionVectors;
        public int layerMask;
        public int overrideMaterialPassIndex;

        public RendererListDesc(ShaderTagId passName, CullingResults cullingResult, Camera camera);
        public RendererListDesc(ShaderTagId[] passNames, CullingResults cullingResult, Camera camera);

        public bool IsValid();
    }
}
using System;

namespace UnityEngine.Experimental.Rendering.RenderGraphModule
{
    [Flags]
    public enum DepthAccess
    {
        Read = 1,
        Write = 2,
        ReadWrite = 3
    }
}
using UnityEngine.Rendering;

namespace UnityEngine.Experimental.Rendering.RenderGraphModule
{
    public class RenderGraphContext
    {
        public ScriptableRenderContext renderContext;
        public CommandBuffer cmd;
        public RenderGraphObjectPool renderGraphPool;
        public RenderGraphDefaultResources defaultResources;

        public RenderGraphContext();
    }
}
using UnityEngine.Rendering;

namespace UnityEngine.Experimental.Rendering.RenderGraphModule
{
    public struct RenderGraphParameters
    {
        public int currentFrameIndex;
        public ScriptableRenderContext scriptableRenderContext;
        public CommandBuffer commandBuffer;
    }
}
namespace UnityEngine.Experimental.Rendering.RenderGraphModule
{
    public delegate void RenderFunc<PassData>(PassData data, RenderGraphContext renderGraphContext) where PassData : class, new();
}
using UnityEngine.Rendering;

namespace UnityEngine.Experimental.Rendering.RenderGraphModule
{
    public class RenderGraph
    {
        public static readonly int kMaxMRTCount;

        public RenderGraph(string name = "RenderGraph");

        public string name { get; }
        public RenderGraphDefaultResources defaultResources { get; }

        public void Cleanup();
        public void EndFrame();
        public TextureHandle ImportTexture(RTHandle rt);
        public TextureHandle ImportBackbuffer(RenderTargetIdentifier rt);
        public TextureHandle CreateTexture(in TextureDesc desc);
        public TextureHandle CreateTexture(TextureHandle texture);
        public void CreateTextureIfInvalid(in TextureDesc desc, ref TextureHandle texture);
        public TextureDesc GetTextureDesc(TextureHandle texture);
        public RendererListHandle CreateRendererList(in RendererListDesc desc);
        public ComputeBufferHandle ImportComputeBuffer(ComputeBuffer computeBuffer);
        public ComputeBufferHandle CreateComputeBuffer(in ComputeBufferDesc desc);
        public ComputeBufferHandle CreateComputeBuffer(in ComputeBufferHandle computeBuffer);
        public ComputeBufferDesc GetComputeBufferDesc(in ComputeBufferHandle computeBuffer);
        public RenderGraphBuilder AddRenderPass<PassData>(string passName, out PassData passData, ProfilingSampler sampler) where PassData : class, new();
        public RenderGraphBuilder AddRenderPass<PassData>(string passName, out PassData passData) where PassData : class, new();
        public void Begin(in RenderGraphParameters parameters);
        public void Execute();
        public void BeginProfilingSampler(ProfilingSampler sampler);
        public void EndProfilingSampler(ProfilingSampler sampler);
    }
}
using System;
using UnityEngine.Rendering;

namespace UnityEngine.Experimental.Rendering.RenderGraphModule
{
    public struct RenderGraphProfilingScope : IDisposable
    {
        public RenderGraphProfilingScope(RenderGraph renderGraph, ProfilingSampler sampler);

        public void Dispose();
    }
}
using System;

namespace UnityEngine.Experimental.Rendering.RenderGraphModule
{
    public struct RenderGraphBuilder : IDisposable
    {
        public TextureHandle UseColorBuffer(in TextureHandle input, int index);
        public TextureHandle UseDepthBuffer(in TextureHandle input, DepthAccess flags);
        public TextureHandle ReadTexture(in TextureHandle input);
        public TextureHandle WriteTexture(in TextureHandle input);
        public TextureHandle ReadWriteTexture(in TextureHandle input);
        public TextureHandle CreateTransientTexture(in TextureDesc desc);
        public TextureHandle CreateTransientTexture(in TextureHandle texture);
        public RendererListHandle UseRendererList(in RendererListHandle input);
        public ComputeBufferHandle ReadComputeBuffer(in ComputeBufferHandle input);
        public ComputeBufferHandle WriteComputeBuffer(in ComputeBufferHandle input);
        public ComputeBufferHandle CreateTransientComputeBuffer(in ComputeBufferDesc desc);
        public ComputeBufferHandle CreateTransientComputeBuffer(in ComputeBufferHandle computebuffer);
        public void SetRenderFunc<PassData>(RenderFunc<PassData> renderFunc) where PassData : class, new();
        public void EnableAsyncCompute(bool value);
        public void AllowPassCulling(bool value);
        public void Dispose();
    }
}
namespace UnityEngine.Experimental.Rendering.RenderGraphModule
{
    public class RenderGraphDefaultResources
    {
        public TextureHandle blackTexture { get; }
        public TextureHandle whiteTexture { get; }
        public TextureHandle clearTextureXR { get; }
        public TextureHandle magentaTextureXR { get; }
        public TextureHandle blackTextureXR { get; }
        public TextureHandle blackTextureArrayXR { get; }
        public TextureHandle blackUIntTextureXR { get; }
        public TextureHandle blackTexture3DXR { get; }
        public TextureHandle whiteTextureXR { get; }
        public TextureHandle defaultShadowTexture { get; }
    }
}
namespace UnityEngine.Experimental.Rendering.RenderGraphModule
{
    public sealed class RenderGraphObjectPool
    {
        public T[] GetTempArray<T>(int size);
        public MaterialPropertyBlock GetTempMaterialPropertyBlock();
    }
}
using System.Diagnostics;
using UnityEngine.Rendering;

namespace UnityEngine.Experimental.Rendering.RenderGraphModule
{
    [DebuggerDisplay("Texture ({handle.index})")]
    public struct TextureHandle
    {
        public static TextureHandle nullHandle { get; }

        public bool IsValid();

        public static implicit operator RTHandle(TextureHandle texture);
        public static implicit operator RenderTargetIdentifier(TextureHandle texture);
        public static implicit operator RenderTexture(TextureHandle texture);
    }
}
using System.Diagnostics;

namespace UnityEngine.Experimental.Rendering.RenderGraphModule
{
    [DebuggerDisplay("ComputeBuffer ({handle.index})")]
    public struct ComputeBufferHandle
    {
        public static ComputeBufferHandle nullHandle { get; }

        public bool IsValid();

        public static implicit operator ComputeBuffer(ComputeBufferHandle buffer);
    }
}
using System.Diagnostics;

namespace UnityEngine.Experimental.Rendering.RenderGraphModule
{
    [DebuggerDisplay("RendererList ({handle})")]
    public struct RendererListHandle
    {
        public bool IsValid();

        public static implicit operator int(RendererListHandle handle);
        public static implicit operator RendererList(RendererListHandle rendererList);
    }
}
namespace UnityEngine.Experimental.Rendering.RenderGraphModule
{
    public enum TextureSizeMode
    {
        Explicit = 0,
        Scale = 1,
        Functor = 2
    }
}
using UnityEngine.Rendering;

namespace UnityEngine.Experimental.Rendering.RenderGraphModule
{
    public struct FastMemoryDesc
    {
        public bool inFastMemory;
        public FastMemoryFlags flags;
        public float residencyFraction;
    }
}
using UnityEngine.Rendering;

namespace UnityEngine.Experimental.Rendering.RenderGraphModule
{
    public struct TextureDesc
    {
        public TextureSizeMode sizeMode;
        public int width;
        public int height;
        public int slices;
        public Vector2 scale;
        public ScaleFunc func;
        public DepthBits depthBufferBits;
        public GraphicsFormat colorFormat;
        public FilterMode filterMode;
        public TextureWrapMode wrapMode;
        public TextureDimension dimension;
        public bool enableRandomWrite;
        public bool useMipMap;
        public bool autoGenerateMips;
        public bool isShadowMap;
        public int anisoLevel;
        public float mipMapBias;
        public bool enableMSAA;
        public MSAASamples msaaSamples;
        public bool bindTextureMS;
        public bool useDynamicScale;
        public RenderTextureMemoryless memoryless;
        public string name;
        public FastMemoryDesc fastMemoryDesc;
        public bool fallBackToBlackTexture;
        public bool clearBuffer;
        public Color clearColor;

        public TextureDesc(int width, int height, bool dynamicResolution = False, bool xrReady = False);
        public TextureDesc(Vector2 scale, bool dynamicResolution = False, bool xrReady = False);
        public TextureDesc(ScaleFunc func, bool dynamicResolution = False, bool xrReady = False);
        public TextureDesc(TextureDesc input);

        public override int GetHashCode();
    }
}
namespace UnityEngine.Experimental.Rendering.RenderGraphModule
{
    public struct ComputeBufferDesc
    {
        public int count;
        public int stride;
        public ComputeBufferType type;
        public string name;

        public ComputeBufferDesc(int count, int stride);
        public ComputeBufferDesc(int count, int stride, ComputeBufferType type);

        public override int GetHashCode();
    }
}
namespace UnityEngine.Rendering
{
    [HelpURL("https://docs.unity3d.com/Packages/com.unity.render-pipelines.core@10.10/manual/Camera-Switcher.html")]
    public class CameraSwitcher : MonoBehaviour
    {
        public Camera[] m_Cameras;

        public CameraSwitcher();
    }
}
namespace UnityEngine.Rendering
{
    [HelpURL("https://docs.unity3d.com/Packages/com.unity.render-pipelines.core@10.10/manual/Free-Camera.html")]
    public class FreeCamera : MonoBehaviour
    {
        public float m_LookSpeedController;
        public float m_LookSpeedMouse;
        public float m_MoveSpeed;
        public float m_MoveSpeedIncrement;
        public float m_Turbo;

        public FreeCamera();
    }
}
namespace UnityEngine.Rendering
{
    public static class CommandBufferPool
    {
        public static CommandBuffer Get();
        public static CommandBuffer Get(string name);
        public static void Release(CommandBuffer buffer);
    }
}
using System;

namespace UnityEngine.Rendering
{
    [Flags]
    public enum ClearFlag
    {
        None = 0,
        Color = 1,
        Depth = 2,
        All = 3
    }
}
namespace UnityEngine.Rendering
{
    public static class ComponentSingleton<TType> where TType : Component
    {
        public static TType instance { get; }

        public static void Release();
    }
}
namespace UnityEngine.Rendering
{
    public class ConstantBuffer
    {
        public ConstantBuffer();

        public static void PushGlobal<CBType>(CommandBuffer cmd, in CBType data, int shaderId) where CBType : struct;
        public static void Push<CBType>(CommandBuffer cmd, in CBType data, ComputeShader cs, int shaderId) where CBType : struct;
        public static void Push<CBType>(CommandBuffer cmd, in CBType data, Material mat, int shaderId) where CBType : struct;
        public static void UpdateData<CBType>(CommandBuffer cmd, in CBType data) where CBType : struct;
        public static void SetGlobal<CBType>(CommandBuffer cmd, int shaderId) where CBType : struct;
        public static void Set<CBType>(CommandBuffer cmd, ComputeShader cs, int shaderId) where CBType : struct;
        public static void Set<CBType>(Material mat, int shaderId) where CBType : struct;
        public static void ReleaseAll();
    }
}
namespace UnityEngine.Rendering
{
    public abstract class ConstantBufferBase
    {
        protected ConstantBufferBase();

        public abstract void Release();
    }
}
namespace UnityEngine.Rendering
{
    public class ConstantBuffer<CBType> : ConstantBufferBase where CBType : struct
    {
        public ConstantBuffer();

        public void UpdateData(CommandBuffer cmd, in CBType data);
        public void SetGlobal(CommandBuffer cmd, int shaderId);
        public void Set(CommandBuffer cmd, ComputeShader cs, int shaderId);
        public void Set(Material mat, int shaderId);
        public void PushGlobal(CommandBuffer cmd, in CBType data, int shaderId);
        public override void Release();
    }
}
using System;

namespace UnityEngine.Rendering
{
    [AttributeUsage(Field)]
    public class DisplayInfoAttribute : Attribute
    {
        public string name;
        public int order;

        public DisplayInfoAttribute();
    }
}
using System;
using System.Collections.Generic;

namespace UnityEngine.Rendering
{
    public static class CoreUnsafeUtils
    {
        public static void CopyTo<T>(this List<T> list, void* dest, int count) where T : struct;
        public static void CopyTo<T>(this T[] list, void* dest, int count) where T : struct;
        public static void QuickSort(uint[] arr, int left, int right);
        public static void QuickSort<T>(int count, void* data) where T : IComparable<T>, struct;
        public static void QuickSort<TValue, TKey, TGetter>(int count, void* data) where TValue : struct where TKey : IComparable<TKey>, struct where TGetter : IKeyGetter<TValue, TKey>, struct;
        public static void QuickSort<TValue, TKey, TGetter>(void* data, int left, int right) where TValue : struct where TKey : IComparable<TKey>, struct where TGetter : IKeyGetter<TValue, TKey>, struct;
        public static int IndexOf<T>(void* data, int count, T v) where T : IEquatable<T>, struct;
        public static int CompareHashes<TOldValue, TOldGetter, TNewValue, TNewGetter>(int oldHashCount, void* oldHashes, int newHashCount, void* newHashes, int* addIndices, int* removeIndices, out int addCount, out int remCount) where TOldValue : struct where TOldGetter : IKeyGetter<TOldValue, Hash128>, struct where TNewValue : struct where TNewGetter : IKeyGetter<TNewValue, Hash128>, struct;
        public static int CompareHashes(int oldHashCount, Hash128* oldHashes, int newHashCount, Hash128* newHashes, int* addIndices, int* removeIndices, out int addCount, out int remCount);
        public static void CombineHashes<TValue, TGetter>(int count, void* hashes, Hash128* outHash) where TValue : struct where TGetter : IKeyGetter<TValue, Hash128>, struct;
        public static void CombineHashes(int count, Hash128* hashes, Hash128* outHash);
        public static bool HaveDuplicates(int[] arr);

        public struct FixedBufferStringQueue
        {
            public FixedBufferStringQueue(byte* ptr, int length);

            public int Count { get; }

            public bool TryPush(string v);
            public bool TryPop(out string v);
            public void Clear();
        }
        public interface IKeyGetter<TValue, TKey>
        {
            TKey Get(ref TValue v);
        }
    }
}
using System.Reflection;

namespace UnityEngine.Rendering
{
    [DefaultMember("Item")]
    public class DynamicArray<T> where T : new()
    {
        public DynamicArray();
        public DynamicArray(int size);

        public ref T this[int index] { get; }
        public int size { get; }
        public int capacity { get; }

        public void Clear();
        public int Add(in T value);
        public void Resize(int newSize, bool keepContent = False);
    }
}
namespace UnityEngine.Rendering
{
    public delegate float PerformDynamicRes();
}
namespace UnityEngine.Rendering
{
    public enum DynamicResScalePolicyType
    {
        ReturnsPercentage = 0,
        ReturnsMinMaxLerpFactor = 1
    }
}
using System;

namespace UnityEngine.Rendering
{
    public class DynamicResolutionHandler
    {
        public DynamicResUpscaleFilter filter { get; set; }
        public Vector2Int finalViewport { get; set; }
        public static DynamicResolutionHandler instance { get; }

        public Vector2 GetResolvedScale();
        public static void SetDynamicResScaler(PerformDynamicRes scaler, DynamicResScalePolicyType scalerType = ReturnsMinMaxLerpFactor);
        public static void ClearSelectedCamera();
        public void SetCurrentCameraRequest(bool cameraRequest);
        public static void UpdateAndUseCamera(Camera camera, GlobalDynamicResolutionSettings? settings = null, Action OnResolutionChange = null);
        public void Update(GlobalDynamicResolutionSettings settings, Action OnResolutionChange = null);
        public bool SoftwareDynamicResIsEnabled();
        public bool HardwareDynamicResIsEnabled();
        public bool RequestsHardwareDynamicResolution();
        public bool DynamicResolutionEnabled();
        public void ForceSoftwareFallback();
        public Vector2Int GetScaledSize(Vector2Int size);
        public Vector2Int ApplyScalesOnSize(Vector2Int size);
        public float GetCurrentScale();
        public Vector2Int GetLastScaledSize();
    }
}
namespace UnityEngine.Rendering
{
    public enum DynamicResolutionType
    {
        Software = 0,
        Hardware = 1
    }
}
namespace UnityEngine.Rendering
{
    public enum DynamicResUpscaleFilter
    {
        Bilinear = 0,
        CatmullRom = 1,
        Lanczos = 2,
        ContrastAdaptiveSharpen = 3
    }
}
namespace UnityEngine.Rendering
{
    public struct GlobalDynamicResolutionSettings
    {
        public bool enabled;
        public float maxPercentage;
        public float minPercentage;
        public DynamicResolutionType dynResType;
        public DynamicResUpscaleFilter upsampleFilter;
        public bool forceResolution;
        public float forcedPercentage;

        public static GlobalDynamicResolutionSettings NewDefault();
    }
}
namespace UnityEngine.Rendering
{
    public interface IVirtualTexturingEnabledRenderPipeline
    {
        bool virtualTexturingEnabled { get; }
    }
}
using System.Reflection;

namespace UnityEngine.Rendering
{
    [DefaultMember("Item")]
    public struct ListBuffer<T> where T : unmanaged
    {
        public ListBuffer(T* bufferPtr, int* countPtr, int capacity);

        public ref T this[in int index] { get; }
        public int Count { get; }
        public int Capacity { get; }

        public ref T GetUnchecked(in int index);
        public bool TryAdd(in T value);
        public void CopyTo(T* dstBuffer, int startDstIndex, int copyCount);
        public bool TryCopyTo(ListBuffer<T> other);
        public bool TryCopyFrom(T* srcPtr, int count);
    }
}
using System;

namespace UnityEngine.Rendering
{
    public static class ListBufferExtensions
    {
        public static void QuickSort<T>(this ListBuffer<T> self) where T : IComparable<T>, unmanaged;
    }
}
using System;
using UnityEngine.Events;

namespace UnityEngine.Rendering
{
    public class ObjectPool<T> where T : new()
    {
        public ObjectPool(UnityAction<T> actionOnGet, UnityAction<T> actionOnRelease, bool collectionCheck = True);

        public int countAll { get; }
        public int countActive { get; }
        public int countInactive { get; }

        public T Get();
        public PooledObject Get(out T v);
        public void Release(T element);

        public struct PooledObject : IDisposable
        {
        }
    }
}
namespace UnityEngine.Rendering
{
    public static class GenericPool<T> where T : new()
    {
        public static T Get();
        public static ObjectPool<T>.PooledObject Get(out T value);
        public static void Release(T toRelease);
    }
}
namespace UnityEngine.Rendering
{
    public static class UnsafeGenericPool<T> where T : new()
    {
        public static T Get();
        public static ObjectPool<T>.PooledObject Get(out T value);
        public static void Release(T toRelease);
    }
}
using System.Collections.Generic;

namespace UnityEngine.Rendering
{
    public static class ListPool<T>
    {
        public static List<T> Get();
        public static ObjectPool<List<T>>.PooledObject Get(out List<T> value);
        public static void Release(List<T> toRelease);
    }
}
using System.Collections.Generic;

namespace UnityEngine.Rendering
{
    public static class HashSetPool<T>
    {
        public static HashSet<T> Get();
        public static ObjectPool<HashSet<T>>.PooledObject Get(out HashSet<T> value);
        public static void Release(HashSet<T> toRelease);
    }
}
using System.Collections.Generic;

namespace UnityEngine.Rendering
{
    public static class DictionaryPool<TKey, TValue>
    {
        public static Dictionary<TKey, TValue> Get();
        public static ObjectPool<Dictionary<TKey, TValue>>.PooledObject Get(out Dictionary<TKey, TValue> value);
        public static void Release(Dictionary<TKey, TValue> toRelease);
    }
}
using System;

namespace UnityEngine.Rendering
{
    public sealed class ListChangedEventArgs<T> : EventArgs
    {
        public readonly int index;
        public readonly T item;

        public ListChangedEventArgs(int index, T item);
    }
}
namespace UnityEngine.Rendering
{
    public delegate void ListChangedEventHandler<T>(ObservableList<T> sender, ListChangedEventArgs<T> e);
}
using System.Collections;
using System.Collections.Generic;
using System.Reflection;

namespace UnityEngine.Rendering
{
    [DefaultMember("Item")]
    public class ObservableList<T> : IEnumerable, IList<T>, ICollection<T>, IEnumerable<T>
    {
        public ObservableList();
        public ObservableList(int capacity);
        public ObservableList(IEnumerable<T> collection);

        public T this[int index] { get; set; }
        public int Count { get; }
        public bool IsReadOnly { get; }

        public event ListChangedEventHandler<T> ItemAdded;
        public event ListChangedEventHandler<T> ItemRemoved;

        public bool Contains(T item);
        public int IndexOf(T item);
        public void Add(T item);
        public void Add(params T[] items);
        public void Insert(int index, T item);
        public bool Remove(T item);
        public int Remove(params T[] items);
        public void RemoveAt(int index);
        public void Clear();
        public void CopyTo(T[] array, int arrayIndex);
        public IEnumerator<T> GetEnumerator();
    }
}
using System.Collections.Generic;

namespace UnityEngine.Rendering
{
    public class SerializedDictionary<K, V> : Dictionary<K, V>, ISerializationCallbackReceiver
    {
        public SerializedDictionary();

        public void OnBeforeSerialize();
        public void OnAfterDeserialize();
    }
}
namespace UnityEngine.Rendering
{
    public class XRGraphics
    {
        public XRGraphics();

        public static float eyeTextureResolutionScale { get; set; }
        public static float renderViewportScale { get; }
        public static bool tryEnable { get; }
        public static bool enabled { get; }
        public static bool isDeviceActive { get; }
        public static string loadedDeviceName { get; }
        public static string[] supportedDevices { get; }
        public static StereoRenderingMode stereoRenderingMode { get; }
        public static RenderTextureDescriptor eyeTextureDesc { get; }
        public static int eyeTextureWidth { get; }
        public static int eyeTextureHeight { get; }

        public enum StereoRenderingMode
        {
            MultiPass = 0,
            SinglePass = 1,
            SinglePassInstanced = 2,
            SinglePassMultiView = 3
        }
    }
}
using System;
using System.Collections.ObjectModel;

namespace UnityEngine.Rendering
{
    public sealed class DebugManager
    {
        public bool refreshEditorRequested;

        public static DebugManager instance { get; }
        public ReadOnlyCollection<DebugUI.Panel> panels { get; }
        public bool displayEditorUI { get; }
        public bool enableRuntimeUI { get; set; }
        public bool displayRuntimeUI { get; set; }
        public bool displayPersistentRuntimeUI { get; set; }

        public event Action<bool> onDisplayRuntimeUIChanged;
        public event Action onSetDirty;

        public void ToggleEditorUI(bool open);
        public void RefreshEditor();
        public void Reset();
        public void ReDrawOnScreenDebug();
        public void RegisterData(IDebugData data);
        public void UnregisterData(IDebugData data);
        public int GetState();
        public DebugUI.Panel GetPanel(string displayName, bool createIfNull = False, int groupIndex = 0, bool overrideIfExist = False);
        public void RemovePanel(string displayName);
        public void RemovePanel(DebugUI.Panel panel);
        public DebugUI.Widget GetItem(string queryPath);
    }
}
using System;

namespace UnityEngine.Rendering
{
    public interface IDebugData
    {
        Action GetReset();
    }
}
namespace UnityEngine.Rendering
{
    public class DebugShapes
    {
        public DebugShapes();

        public static DebugShapes instance { get; }

        public Mesh RequestSphereMesh();
        public Mesh RequestBoxMesh();
        public Mesh RequestConeMesh();
        public Mesh RequestPyramidMesh();
    }
}
using System;
using UnityEditor.IMGUI.Controls;

namespace UnityEngine.Rendering
{
    public class DebugUI
    {
        public DebugUI();

        public class Container : Widget, IContainer
        {
            public Container();
            public Container(string displayName, ObservableList<Widget> children);

            public ObservableList<Widget> children { get; }
            public override Panel panel { get; }

            protected virtual void OnItemAdded(ObservableList<Widget> sender, ListChangedEventArgs<Widget> e);
            protected virtual void OnItemRemoved(ObservableList<Widget> sender, ListChangedEventArgs<Widget> e);
            public override int GetHashCode();
        }
        public class Foldout : Container, IValueField
        {
            public bool opened;

            public Foldout();
            public Foldout(string displayName, ObservableList<Widget> children, string[] columnLabels = null);

            public bool isReadOnly { get; }
            public string[] columnLabels { get; set; }

            public bool GetValue();
            public void SetValue(object value);
            public object ValidateValue(object value);
            public void SetValue(bool value);
        }
        public class HBox : Container
        {
            public HBox();
        }
        public class VBox : Container
        {
            public VBox();
        }
        public class Table : Container
        {
            public bool isReadOnly;
            public Vector2 scroll;

            public Table();

            public MultiColumnHeader Header { get; }

            public void SetColumnVisibility(int index, bool visible);
            public bool GetColumnVisibility(int index);
            protected override void OnItemAdded(ObservableList<Widget> sender, ListChangedEventArgs<Widget> e);
            protected override void OnItemRemoved(ObservableList<Widget> sender, ListChangedEventArgs<Widget> e);

            public class Row : Foldout
            {
                public Row();
            }
        }
        public abstract class Field<T> : Widget, IValueField
        {
            public Action<Field<T>, T> onValueChanged;

            protected Field();

            public Func<T> getter { get; set; }
            public Action<T> setter { get; set; }

            public virtual T ValidateValue(T value);
            public T GetValue();
            public void SetValue(object value);
            public void SetValue(T value);
        }
        public class BoolField : Field<bool>
        {
            public BoolField();
        }
        public class HistoryBoolField : BoolField
        {
            public HistoryBoolField();

            public Func<bool>[] historyGetter { get; set; }
            public int historyDepth { get; }

            public bool GetHistoryValue(int historyIndex);
        }
        public class IntField : Field<int>
        {
            public Func<int> min;
            public Func<int> max;
            public int incStep;
            public int intStepMult;

            public IntField();

            public override int ValidateValue(int value);
        }
        public class UIntField : Field<uint>
        {
            public Func<uint> min;
            public Func<uint> max;
            public uint incStep;
            public uint intStepMult;

            public UIntField();

            public override uint ValidateValue(uint value);
        }
        public class FloatField : Field<float>
        {
            public Func<float> min;
            public Func<float> max;
            public float incStep;
            public float incStepMult;
            public int decimals;

            public FloatField();

            public override float ValidateValue(float value);
        }
        public class EnumField : Field<int>
        {
            public GUIContent[] enumNames;
            public int[] enumValues;

            public EnumField();

            public Func<int> getIndex { get; set; }
            public Action<int> setIndex { get; set; }
            public int currentIndex { get; set; }
            public Type autoEnum { set; }
        }
        public class HistoryEnumField : EnumField
        {
            public HistoryEnumField();

            public Func<int>[] historyIndexGetter { get; set; }
            public int historyDepth { get; }

            public int GetHistoryValue(int historyIndex);
        }
        public class BitField : Field<Enum>
        {
            public BitField();

            public GUIContent[] enumNames { get; }
            public int[] enumValues { get; }
            public Type enumType { get; set; }
        }
        public class ColorField : Field<Color>
        {
            public bool hdr;
            public bool showAlpha;
            public bool showPicker;
            public float incStep;
            public float incStepMult;
            public int decimals;

            public ColorField();

            public override Color ValidateValue(Color value);
        }
        public class Vector2Field : Field<Vector2>
        {
            public float incStep;
            public float incStepMult;
            public int decimals;

            public Vector2Field();
        }
        public class Vector3Field : Field<Vector3>
        {
            public float incStep;
            public float incStepMult;
            public int decimals;

            public Vector3Field();
        }
        public class Vector4Field : Field<Vector4>
        {
            public float incStep;
            public float incStepMult;
            public int decimals;

            public Vector4Field();
        }
        public class Panel : IComparable<Panel>, IContainer
        {
            public Panel();

            public Flags flags { get; set; }
            public string displayName { get; set; }
            public int groupIndex { get; set; }
            public string queryPath { get; }
            public bool isEditorOnly { get; }
            public bool isRuntimeOnly { get; }
            public bool isInactiveInEditor { get; }
            public bool editorForceUpdate { get; }
            public ObservableList<Widget> children { get; }

            public event Action<Panel> onSetDirty;

            protected virtual void OnItemAdded(ObservableList<Widget> sender, ListChangedEventArgs<Widget> e);
            protected virtual void OnItemRemoved(ObservableList<Widget> sender, ListChangedEventArgs<Widget> e);
            public void SetDirty();
            public override int GetHashCode();
        }
        [Flags]
        public enum Flags
        {
            None = 0,
            EditorOnly = 2,
            RuntimeOnly = 4,
            EditorForceUpdate = 8
        }
        public abstract class Widget
        {
            protected Panel m_Panel;
            protected IContainer m_Parent;

            protected Widget();

            public virtual Panel panel { get; }
            public virtual IContainer parent { get; }
            public Flags flags { get; set; }
            public string displayName { get; set; }
            public string queryPath { get; }
            public bool isEditorOnly { get; }
            public bool isRuntimeOnly { get; }
            public bool isInactiveInEditor { get; }

            public override int GetHashCode();
        }
        public interface IContainer
        {
            ObservableList<Widget> children { get; }
            string displayName { get; set; }
            string queryPath { get; }
        }
        public interface IValueField
        {
            object GetValue();
            void SetValue(object value);
            object ValidateValue(object value);
        }
        public class Button : Widget
        {
            public Button();

            public Action action { get; set; }
        }
        public class Value : Widget
        {
            public float refreshRate;

            public Value();

            public Func<object> getter { get; set; }

            public object GetValue();
        }
    }
}
namespace UnityEngine.Rendering
{
    public class MousePositionDebug
    {
        public MousePositionDebug();

        public static MousePositionDebug instance { get; }

        public void Build();
        public void Cleanup();
        public Vector2 GetMousePosition(float ScreenHeight, bool sceneView);
        public Vector2 GetMouseClickPosition(float ScreenHeight);
    }
}
using System;

namespace UnityEngine.Rendering
{
    public class ProfilingSampler
    {
        public ProfilingSampler(string name);

        public string name { get; }
        public bool enableRecording { set; }
        public float gpuElapsedTime { get; }
        public int gpuSampleCount { get; }
        public float cpuElapsedTime { get; }
        public int cpuSampleCount { get; }
        public float inlineCpuElapsedTime { get; }
        public int inlineCpuSampleCount { get; }

        public static ProfilingSampler Get<TEnum>(TEnum marker) where TEnum : Enum;
        public void Begin(CommandBuffer cmd);
        public void End(CommandBuffer cmd);
    }
}
using System;

namespace UnityEngine.Rendering
{
    public struct ProfilingScope : IDisposable
    {
        public ProfilingScope(CommandBuffer cmd, ProfilingSampler sampler);

        public void Dispose();
    }
}
using System;
using UnityEngine.Profiling;

namespace UnityEngine.Rendering
{
    [Obsolete("Please use ProfilingScope")]
    public struct ProfilingSample : IDisposable
    {
        public ProfilingSample(CommandBuffer cmd, string name, CustomSampler sampler = null);
        public ProfilingSample(CommandBuffer cmd, string format, object arg);
        public ProfilingSample(CommandBuffer cmd, string format, params object[] args);

        public void Dispose();
    }
}
namespace UnityEngine.Rendering
{
    public class DocumentationInfo
    {
        public const string version = "10.10";

        public DocumentationInfo();
    }
}
namespace UnityEngine.Rendering
{
    public enum PackingRules
    {
        Exact = 0,
        Aggressive = 1
    }
}
namespace UnityEngine.Rendering
{
    public enum FieldPacking
    {
        NoPacking = 0,
        R11G11B10 = 1,
        PackedFloat = 2,
        PackedUint = 3
    }
}
namespace UnityEngine.Rendering
{
    public enum FieldPrecision
    {
        Half = 0,
        Real = 1,
        Default = 2
    }
}
using System;

namespace UnityEngine.Rendering
{
    [AttributeUsage(Class, Struct, Enum)]
    public class GenerateHLSL : Attribute
    {
        public PackingRules packingRules;
        public bool containsPackedFields;
        public bool needAccessors;
        public bool needSetters;
        public bool needParamDebug;
        public int paramDefinesStart;
        public bool omitStructDeclaration;
        public bool generateCBuffer;
        public int constantRegister;

        public GenerateHLSL(PackingRules rules = Exact, bool needAccessors = True, bool needSetters = False, bool needParamDebug = False, int paramDefinesStart = 1, bool omitStructDeclaration = False, bool containsPackedFields = False, bool generateCBuffer = False, int constantRegister = -1);
    }
}
using System;

namespace UnityEngine.Rendering
{
    [AttributeUsage(Field)]
    public class SurfaceDataAttributes : Attribute
    {
        public string[] displayNames;
        public bool isDirection;
        public bool sRGBDisplay;
        public FieldPrecision precision;
        public bool checkIsNormalized;
        public string preprocessor;

        public SurfaceDataAttributes(string displayName = "", bool isDirection = False, bool sRGBDisplay = False, FieldPrecision precision = Default, bool checkIsNormalized = False, string preprocessor = "");
        public SurfaceDataAttributes(string[] displayNames, bool isDirection = False, bool sRGBDisplay = False, FieldPrecision precision = Default, bool checkIsNormalized = False, string preprocessor = "");
    }
}
using System;

namespace UnityEngine.Rendering
{
    [AttributeUsage(Field)]
    public class HLSLArray : Attribute
    {
        public int arraySize;
        public Type elementType;

        public HLSLArray(int arraySize, Type elementType);
    }
}
using System;

namespace UnityEngine.Rendering
{
    [AttributeUsage(Field, AllowMultiple = True)]
    public class PackingAttribute : Attribute
    {
        public string[] displayNames;
        public float[] range;
        public FieldPacking packingScheme;
        public int offsetInSource;
        public int sizeInBits;
        public bool isDirection;
        public bool sRGBDisplay;
        public bool checkIsNormalized;
        public string preprocessor;

        public PackingAttribute(string[] displayNames, FieldPacking packingScheme = NoPacking, int bitSize = 32, int offsetInSource = 0, float minValue = 0, float maxValue = 1, bool isDirection = False, bool sRGBDisplay = False, bool checkIsNormalized = False, string preprocessor = "");
        public PackingAttribute(string displayName = "", FieldPacking packingScheme = NoPacking, int bitSize = 0, int offsetInSource = 0, float minValue = 0, float maxValue = 1, bool isDirection = False, bool sRGBDisplay = False, bool checkIsNormalized = False, string preprocessor = "");
    }
}
namespace UnityEngine.Rendering
{
    public struct ShaderGenUInt4
    {
    }
}
using System;

namespace UnityEngine.Rendering
{
    public class BufferedRTHandleSystem : IDisposable
    {
        public BufferedRTHandleSystem();

        public int maxWidth { get; }
        public int maxHeight { get; }
        public RTHandleProperties rtHandleProperties { get; }

        public RTHandle GetFrameRT(int bufferId, int frameIndex);
        public void AllocBuffer(int bufferId, Func<RTHandleSystem, int, RTHandle> allocator, int bufferCount);
        public void ReleaseBuffer(int bufferId);
        public void SwapAndSetReferenceSize(int width, int height, MSAASamples msaaSamples);
        public void ResetReferenceSize(int width, int height);
        public int GetNumFramesAllocated(int bufferId);
        public void Dispose();
        public void ReleaseAll();
    }
}
namespace UnityEngine.Rendering
{
    public enum DepthBits
    {
        None = 0,
        Depth8 = 8,
        Depth16 = 16,
        Depth24 = 24,
        Depth32 = 32
    }
}
namespace UnityEngine.Rendering
{
    public enum MSAASamples
    {
        None = 1,
        MSAA2x = 2,
        MSAA4x = 4,
        MSAA8x = 8
    }
}
namespace UnityEngine.Rendering
{
    public class RTHandle
    {
        public Vector2 scaleFactor { get; }
        public bool useScaling { get; }
        public Vector2Int referenceSize { get; }
        public RTHandleProperties rtHandleProperties { get; }
        public RenderTexture rt { get; }
        public RenderTargetIdentifier nameID { get; }
        public string name { get; }
        public bool isMSAAEnabled { get; }

        public void Release();
        public Vector2Int GetScaledSize(Vector2Int refSize);
        public void SwitchToFastMemory(CommandBuffer cmd, float residencyFraction = 1, FastMemoryFlags flags = SpillTop, bool copyContents = False);
        public void CopyToFastMemory(CommandBuffer cmd, float residencyFraction = 1, FastMemoryFlags flags = SpillTop);
        public void SwitchOutFastMemory(CommandBuffer cmd, bool copyContents = True);

        public static implicit operator RenderTexture(RTHandle handle);
        public static implicit operator Texture(RTHandle handle);
        public static implicit operator RenderTargetIdentifier(RTHandle handle);
    }
}
namespace UnityEngine.Rendering
{
    public delegate Vector2Int ScaleFunc(Vector2Int size);
}
namespace UnityEngine.Rendering
{
    public struct RTHandleProperties
    {
        public Vector2Int previousViewportSize;
        public Vector2Int previousRenderTargetSize;
        public Vector2Int currentViewportSize;
        public Vector2Int currentRenderTargetSize;
        public Vector4 rtHandleScale;
    }
}
using System;
using UnityEngine.Experimental.Rendering;

namespace UnityEngine.Rendering
{
    public class RTHandleSystem : IDisposable
    {
        public RTHandleSystem();

        public RTHandleProperties rtHandleProperties { get; }

        public void Dispose();
        public void Initialize(int width, int height, bool scaledRTsupportsMSAA, MSAASamples scaledRTMSAASamples);
        public void Release(RTHandle rth);
        public void ResetReferenceSize(int width, int height);
        public void SetReferenceSize(int width, int height, MSAASamples msaaSamples);
        public void SetReferenceSize(int width, int height, MSAASamples msaaSamples, bool reset);
        public void SetHardwareDynamicResolutionState(bool enableHWDynamicRes);
        public int GetMaxWidth();
        public int GetMaxHeight();
        public RTHandle Alloc(int width, int height, int slices = 1, DepthBits depthBufferBits = None, GraphicsFormat colorFormat = R8G8B8A8_SRGB, FilterMode filterMode = Point, TextureWrapMode wrapMode = Repeat, TextureDimension dimension = Tex2D, bool enableRandomWrite = False, bool useMipMap = False, bool autoGenerateMips = True, bool isShadowMap = False, int anisoLevel = 1, float mipMapBias = 0, MSAASamples msaaSamples = None, bool bindTextureMS = False, bool useDynamicScale = False, RenderTextureMemoryless memoryless = None, string name = "");
        public RTHandle Alloc(Vector2 scaleFactor, int slices = 1, DepthBits depthBufferBits = None, GraphicsFormat colorFormat = R8G8B8A8_SRGB, FilterMode filterMode = Point, TextureWrapMode wrapMode = Repeat, TextureDimension dimension = Tex2D, bool enableRandomWrite = False, bool useMipMap = False, bool autoGenerateMips = True, bool isShadowMap = False, int anisoLevel = 1, float mipMapBias = 0, bool enableMSAA = False, bool bindTextureMS = False, bool useDynamicScale = False, RenderTextureMemoryless memoryless = None, string name = "");
        public RTHandle Alloc(ScaleFunc scaleFunc, int slices = 1, DepthBits depthBufferBits = None, GraphicsFormat colorFormat = R8G8B8A8_SRGB, FilterMode filterMode = Point, TextureWrapMode wrapMode = Repeat, TextureDimension dimension = Tex2D, bool enableRandomWrite = False, bool useMipMap = False, bool autoGenerateMips = True, bool isShadowMap = False, int anisoLevel = 1, float mipMapBias = 0, bool enableMSAA = False, bool bindTextureMS = False, bool useDynamicScale = False, RenderTextureMemoryless memoryless = None, string name = "");
        public RTHandle Alloc(RenderTexture texture);
        public RTHandle Alloc(Texture texture);
        public RTHandle Alloc(RenderTargetIdentifier texture);
        public RTHandle Alloc(RenderTargetIdentifier texture, string name);
    }
}
using UnityEngine.Experimental.Rendering;

namespace UnityEngine.Rendering
{
    public static class RTHandles
    {
        public static int maxWidth { get; }
        public static int maxHeight { get; }
        public static RTHandleProperties rtHandleProperties { get; }

        public static RTHandle Alloc(int width, int height, int slices = 1, DepthBits depthBufferBits = None, GraphicsFormat colorFormat = R8G8B8A8_SRGB, FilterMode filterMode = Point, TextureWrapMode wrapMode = Repeat, TextureDimension dimension = Tex2D, bool enableRandomWrite = False, bool useMipMap = False, bool autoGenerateMips = True, bool isShadowMap = False, int anisoLevel = 1, float mipMapBias = 0, MSAASamples msaaSamples = None, bool bindTextureMS = False, bool useDynamicScale = False, RenderTextureMemoryless memoryless = None, string name = "");
        public static RTHandle Alloc(Vector2 scaleFactor, int slices = 1, DepthBits depthBufferBits = None, GraphicsFormat colorFormat = R8G8B8A8_SRGB, FilterMode filterMode = Point, TextureWrapMode wrapMode = Repeat, TextureDimension dimension = Tex2D, bool enableRandomWrite = False, bool useMipMap = False, bool autoGenerateMips = True, bool isShadowMap = False, int anisoLevel = 1, float mipMapBias = 0, bool enableMSAA = False, bool bindTextureMS = False, bool useDynamicScale = False, RenderTextureMemoryless memoryless = None, string name = "");
        public static RTHandle Alloc(ScaleFunc scaleFunc, int slices = 1, DepthBits depthBufferBits = None, GraphicsFormat colorFormat = R8G8B8A8_SRGB, FilterMode filterMode = Point, TextureWrapMode wrapMode = Repeat, TextureDimension dimension = Tex2D, bool enableRandomWrite = False, bool useMipMap = False, bool autoGenerateMips = True, bool isShadowMap = False, int anisoLevel = 1, float mipMapBias = 0, bool enableMSAA = False, bool bindTextureMS = False, bool useDynamicScale = False, RenderTextureMemoryless memoryless = None, string name = "");
        public static RTHandle Alloc(Texture tex);
        public static RTHandle Alloc(RenderTexture tex);
        public static RTHandle Alloc(RenderTargetIdentifier tex);
        public static RTHandle Alloc(RenderTargetIdentifier tex, string name);
        public static void Initialize(int width, int height, bool scaledRTsupportsMSAA, MSAASamples scaledRTMSAASamples);
        public static void Release(RTHandle rth);
        public static void SetHardwareDynamicResolutionState(bool hwDynamicResRequested);
        public static void SetReferenceSize(int width, int height, MSAASamples msaaSamples);
        public static void ResetReferenceSize(int width, int height);
    }
}
namespace UnityEngine.Rendering
{
    public static class TextureXR
    {
        public static int maxViews { set; }
        public static int slices { get; }
        public static bool useTexArray { get; }
        public static TextureDimension dimension { get; }

        public static RTHandle GetBlackUIntTexture();
        public static RTHandle GetClearTexture();
        public static RTHandle GetMagentaTexture();
        public static RTHandle GetBlackTexture();
        public static RTHandle GetBlackTextureArray();
        public static RTHandle GetBlackTexture3D();
        public static RTHandle GetWhiteTexture();
        public static void Initialize(CommandBuffer cmd, ComputeShader clearR32_UIntShader);
    }
}
using System.Reflection;

namespace UnityEngine.Rendering
{
    [DefaultMember("Item")]
    public interface IBitArray
    {
        bool this[uint index] { get; set; }
        uint capacity { get; }
        bool allFalse { get; }
        bool allTrue { get; }
        string humanizedData { get; }

        IBitArray BitAnd(IBitArray other);
        IBitArray BitOr(IBitArray other);
        IBitArray BitNot();
    }
}
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;

namespace UnityEngine.Rendering
{
    [DefaultMember("Item")]
    [DebuggerDisplay("{this.GetType().Name} {humanizedData}")]
    public struct BitArray8 : IBitArray
    {
        public BitArray8(byte initValue);
        public BitArray8(IEnumerable<uint> bitIndexTrue);

        public bool this[uint index] { get; set; }
        public uint capacity { get; }
        public bool allFalse { get; }
        public bool allTrue { get; }
        public string humanizedData { get; }

        public IBitArray BitAnd(IBitArray other);
        public IBitArray BitOr(IBitArray other);
        public IBitArray BitNot();
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static BitArray8 operator ~(BitArray8 a);
        public static BitArray8 operator |(BitArray8 a, BitArray8 b);
        public static BitArray8 operator &(BitArray8 a, BitArray8 b);
        public static bool operator ==(BitArray8 a, BitArray8 b);
        public static bool operator !=(BitArray8 a, BitArray8 b);
    }
}
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;

namespace UnityEngine.Rendering
{
    [DefaultMember("Item")]
    [DebuggerDisplay("{this.GetType().Name} {humanizedData}")]
    public struct BitArray16 : IBitArray
    {
        public BitArray16(ushort initValue);
        public BitArray16(IEnumerable<uint> bitIndexTrue);

        public bool this[uint index] { get; set; }
        public uint capacity { get; }
        public bool allFalse { get; }
        public bool allTrue { get; }
        public string humanizedData { get; }

        public IBitArray BitAnd(IBitArray other);
        public IBitArray BitOr(IBitArray other);
        public IBitArray BitNot();
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static BitArray16 operator ~(BitArray16 a);
        public static BitArray16 operator |(BitArray16 a, BitArray16 b);
        public static BitArray16 operator &(BitArray16 a, BitArray16 b);
        public static bool operator ==(BitArray16 a, BitArray16 b);
        public static bool operator !=(BitArray16 a, BitArray16 b);
    }
}
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;

namespace UnityEngine.Rendering
{
    [DefaultMember("Item")]
    [DebuggerDisplay("{this.GetType().Name} {humanizedData}")]
    public struct BitArray32 : IBitArray
    {
        public BitArray32(uint initValue);
        public BitArray32(IEnumerable<uint> bitIndexTrue);

        public bool this[uint index] { get; set; }
        public uint capacity { get; }
        public bool allFalse { get; }
        public bool allTrue { get; }
        public string humanizedData { get; }

        public IBitArray BitAnd(IBitArray other);
        public IBitArray BitOr(IBitArray other);
        public IBitArray BitNot();
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static BitArray32 operator ~(BitArray32 a);
        public static BitArray32 operator |(BitArray32 a, BitArray32 b);
        public static BitArray32 operator &(BitArray32 a, BitArray32 b);
        public static bool operator ==(BitArray32 a, BitArray32 b);
        public static bool operator !=(BitArray32 a, BitArray32 b);
    }
}
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;

namespace UnityEngine.Rendering
{
    [DefaultMember("Item")]
    [DebuggerDisplay("{this.GetType().Name} {humanizedData}")]
    public struct BitArray64 : IBitArray
    {
        public BitArray64(ulong initValue);
        public BitArray64(IEnumerable<uint> bitIndexTrue);

        public bool this[uint index] { get; set; }
        public uint capacity { get; }
        public bool allFalse { get; }
        public bool allTrue { get; }
        public string humanizedData { get; }

        public IBitArray BitAnd(IBitArray other);
        public IBitArray BitOr(IBitArray other);
        public IBitArray BitNot();
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static BitArray64 operator ~(BitArray64 a);
        public static BitArray64 operator |(BitArray64 a, BitArray64 b);
        public static BitArray64 operator &(BitArray64 a, BitArray64 b);
        public static bool operator ==(BitArray64 a, BitArray64 b);
        public static bool operator !=(BitArray64 a, BitArray64 b);
    }
}
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;

namespace UnityEngine.Rendering
{
    [DefaultMember("Item")]
    [DebuggerDisplay("{this.GetType().Name} {humanizedData}")]
    public struct BitArray128 : IBitArray
    {
        public BitArray128(ulong initValue1, ulong initValue2);
        public BitArray128(IEnumerable<uint> bitIndexTrue);

        public bool this[uint index] { get; set; }
        public uint capacity { get; }
        public bool allFalse { get; }
        public bool allTrue { get; }
        public string humanizedData { get; }

        public IBitArray BitAnd(IBitArray other);
        public IBitArray BitOr(IBitArray other);
        public IBitArray BitNot();
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static BitArray128 operator ~(BitArray128 a);
        public static BitArray128 operator |(BitArray128 a, BitArray128 b);
        public static BitArray128 operator &(BitArray128 a, BitArray128 b);
        public static bool operator ==(BitArray128 a, BitArray128 b);
        public static bool operator !=(BitArray128 a, BitArray128 b);
    }
}
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;

namespace UnityEngine.Rendering
{
    [DefaultMember("Item")]
    [DebuggerDisplay("{this.GetType().Name} {humanizedData}")]
    public struct BitArray256 : IBitArray
    {
        public BitArray256(ulong initValue1, ulong initValue2, ulong initValue3, ulong initValue4);
        public BitArray256(IEnumerable<uint> bitIndexTrue);

        public bool this[uint index] { get; set; }
        public uint capacity { get; }
        public bool allFalse { get; }
        public bool allTrue { get; }
        public string humanizedData { get; }

        public IBitArray BitAnd(IBitArray other);
        public IBitArray BitOr(IBitArray other);
        public IBitArray BitNot();
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static BitArray256 operator ~(BitArray256 a);
        public static BitArray256 operator |(BitArray256 a, BitArray256 b);
        public static BitArray256 operator &(BitArray256 a, BitArray256 b);
        public static bool operator ==(BitArray256 a, BitArray256 b);
        public static bool operator !=(BitArray256 a, BitArray256 b);
    }
}
namespace UnityEngine.Rendering
{
    public static class BitArrayUtilities
    {
        public static bool Get8(uint index, byte data);
        public static bool Get16(uint index, ushort data);
        public static bool Get32(uint index, uint data);
        public static bool Get64(uint index, ulong data);
        public static bool Get128(uint index, ulong data1, ulong data2);
        public static bool Get256(uint index, ulong data1, ulong data2, ulong data3, ulong data4);
        public static void Set8(uint index, ref byte data, bool value);
        public static void Set16(uint index, ref ushort data, bool value);
        public static void Set32(uint index, ref uint data, bool value);
        public static void Set64(uint index, ref ulong data, bool value);
        public static void Set128(uint index, ref ulong data1, ref ulong data2, bool value);
        public static void Set256(uint index, ref ulong data1, ref ulong data2, ref ulong data3, ref ulong data4, bool value);
    }
}
using System;
using System.Collections.Generic;

namespace UnityEngine.Rendering
{
    public static class CameraCaptureBridge
    {
        public static bool enabled { get; set; }

        public static IEnumerator<Action<RenderTargetIdentifier, CommandBuffer>> GetCaptureActions(Camera camera);
        public static void AddCaptureAction(Camera camera, Action<RenderTargetIdentifier, CommandBuffer> action);
        public static void RemoveCaptureAction(Camera camera, Action<RenderTargetIdentifier, CommandBuffer> action);
    }
}
namespace UnityEngine.Rendering
{
    public static class ColorUtils
    {
        public static float s_LightMeterCalibrationConstant;
        public static float s_LensAttenuation;

        public static float lensImperfectionExposureScale { get; }

        public static float StandardIlluminantY(float x);
        public static Vector3 CIExyToLMS(float x, float y);
        public static Vector3 ColorBalanceToLMSCoeffs(float temperature, float tint);
        public static (Vector4, Vector4, Vector4) PrepareShadowsMidtonesHighlights(in Vector4 inShadows, in Vector4 inMidtones, in Vector4 inHighlights);
        public static (Vector4, Vector4, Vector4) PrepareLiftGammaGain(in Vector4 inLift, in Vector4 inGamma, in Vector4 inGain);
        public static (Vector4, Vector4) PrepareSplitToning(in Vector4 inShadows, in Vector4 inHighlights, float balance);
        public static float Luminance(in Color color);
        public static float ComputeEV100(float aperture, float shutterSpeed, float ISO);
        public static float ConvertEV100ToExposure(float EV100);
        public static float ConvertExposureToEV100(float exposure);
        public static float ComputeEV100FromAvgLuminance(float avgLuminance);
        public static float ComputeISO(float aperture, float shutterSpeed, float targetEV100);
        public static uint ToHex(Color c);
        public static Color ToRGBA(uint hex);
    }
}
namespace UnityEngine.Rendering
{
    public static class CoreMatrixUtils
    {
        public static void MatrixTimesTranslation(ref Matrix4x4 inOutMatrix, Vector3 translation);
        public static void TranslationTimesMatrix(ref Matrix4x4 inOutMatrix, Vector3 translation);
        public static Matrix4x4 MultiplyPerspectiveMatrix(Matrix4x4 perspective, Matrix4x4 rhs);
        public static Matrix4x4 MultiplyOrthoMatrix(Matrix4x4 ortho, Matrix4x4 rhs, bool centered);
        public static Matrix4x4 MultiplyProjectionMatrix(Matrix4x4 projMatrix, Matrix4x4 rhs, bool orthoCentered);
    }
}
namespace UnityEngine.Rendering
{
    public static class CoreRenderPipelinePreferences
    {
        public static Color volumeGizmoColor { get; set; }
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.Experimental.Rendering;

namespace UnityEngine.Rendering
{
    public static class CoreUtils
    {
        public static readonly Vector3[] lookAtList;
        public static readonly Vector3[] upVectorList;
        public const int editMenuPriority1 = 320;
        public const int editMenuPriority2 = 331;
        public const int editMenuPriority3 = 342;
        public const int editMenuPriority4 = 353;
        public const int assetCreateMenuPriority1 = 230;
        public const int assetCreateMenuPriority2 = 241;
        public const int assetCreateMenuPriority3 = 300;
        public const int gameObjectMenuPriority = 10;

        public static Cubemap blackCubeTexture { get; }
        public static Cubemap magentaCubeTexture { get; }
        public static CubemapArray magentaCubeTextureArray { get; }
        public static Cubemap whiteCubeTexture { get; }
        public static RenderTexture emptyUAV { get; }
        public static Texture3D blackVolumeTexture { get; }

        public static void ClearRenderTarget(CommandBuffer cmd, ClearFlag clearFlag, Color clearColor);
        public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier buffer, ClearFlag clearFlag, Color clearColor, int miplevel = 0, CubemapFace cubemapFace = Unknown, int depthSlice = -1);
        public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier buffer, ClearFlag clearFlag = None, int miplevel = 0, CubemapFace cubemapFace = Unknown, int depthSlice = -1);
        public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier colorBuffer, RenderTargetIdentifier depthBuffer, int miplevel = 0, CubemapFace cubemapFace = Unknown, int depthSlice = -1);
        public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier colorBuffer, RenderTargetIdentifier depthBuffer, ClearFlag clearFlag, int miplevel = 0, CubemapFace cubemapFace = Unknown, int depthSlice = -1);
        public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier colorBuffer, RenderTargetIdentifier depthBuffer, ClearFlag clearFlag, Color clearColor, int miplevel = 0, CubemapFace cubemapFace = Unknown, int depthSlice = -1);
        public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier[] colorBuffers, RenderTargetIdentifier depthBuffer);
        public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier[] colorBuffers, RenderTargetIdentifier depthBuffer, ClearFlag clearFlag = None);
        public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier[] colorBuffers, RenderTargetIdentifier depthBuffer, ClearFlag clearFlag, Color clearColor);
        public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier buffer, RenderBufferLoadAction loadAction, RenderBufferStoreAction storeAction, ClearFlag clearFlag, Color clearColor);
        public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier buffer, RenderBufferLoadAction loadAction, RenderBufferStoreAction storeAction, ClearFlag clearFlag);
        public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier colorBuffer, RenderBufferLoadAction colorLoadAction, RenderBufferStoreAction colorStoreAction, RenderTargetIdentifier depthBuffer, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction, ClearFlag clearFlag, Color clearColor);
        public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier colorBuffer, RenderBufferLoadAction colorLoadAction, RenderBufferStoreAction colorStoreAction, RenderTargetIdentifier depthBuffer, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction, ClearFlag clearFlag);
        public static void SetRenderTarget(CommandBuffer cmd, RTHandle buffer, ClearFlag clearFlag, Color clearColor, int miplevel = 0, CubemapFace cubemapFace = Unknown, int depthSlice = -1);
        public static void SetRenderTarget(CommandBuffer cmd, RTHandle buffer, ClearFlag clearFlag = None, int miplevel = 0, CubemapFace cubemapFace = Unknown, int depthSlice = -1);
        public static void SetRenderTarget(CommandBuffer cmd, RTHandle colorBuffer, RTHandle depthBuffer, int miplevel = 0, CubemapFace cubemapFace = Unknown, int depthSlice = -1);
        public static void SetRenderTarget(CommandBuffer cmd, RTHandle colorBuffer, RTHandle depthBuffer, ClearFlag clearFlag, int miplevel = 0, CubemapFace cubemapFace = Unknown, int depthSlice = -1);
        public static void SetRenderTarget(CommandBuffer cmd, RTHandle colorBuffer, RTHandle depthBuffer, ClearFlag clearFlag, Color clearColor, int miplevel = 0, CubemapFace cubemapFace = Unknown, int depthSlice = -1);
        public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier[] colorBuffers, RTHandle depthBuffer);
        public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier[] colorBuffers, RTHandle depthBuffer, ClearFlag clearFlag = None);
        public static void SetRenderTarget(CommandBuffer cmd, RenderTargetIdentifier[] colorBuffers, RTHandle depthBuffer, ClearFlag clearFlag, Color clearColor);
        public static void SetViewport(CommandBuffer cmd, RTHandle target);
        public static string GetRenderTargetAutoName(int width, int height, int depth, RenderTextureFormat format, string name, bool mips = False, bool enableMSAA = False, MSAASamples msaaSamples = None);
        public static string GetRenderTargetAutoName(int width, int height, int depth, GraphicsFormat format, string name, bool mips = False, bool enableMSAA = False, MSAASamples msaaSamples = None);
        public static string GetRenderTargetAutoName(int width, int height, int depth, GraphicsFormat format, TextureDimension dim, string name, bool mips = False, bool enableMSAA = False, MSAASamples msaaSamples = None, bool dynamicRes = False);
        public static string GetTextureAutoName(int width, int height, TextureFormat format, TextureDimension dim = None, string name = "", bool mips = False, int depth = 0);
        public static string GetTextureAutoName(int width, int height, GraphicsFormat format, TextureDimension dim = None, string name = "", bool mips = False, int depth = 0);
        public static void ClearCubemap(CommandBuffer cmd, RenderTexture renderTexture, Color clearColor, bool clearMips = False);
        public static void DrawFullScreen(CommandBuffer commandBuffer, Material material, MaterialPropertyBlock properties = null, int shaderPassId = 0);
        public static void DrawFullScreen(CommandBuffer commandBuffer, Material material, RenderTargetIdentifier colorBuffer, MaterialPropertyBlock properties = null, int shaderPassId = 0);
        public static void DrawFullScreen(CommandBuffer commandBuffer, Material material, RenderTargetIdentifier colorBuffer, RenderTargetIdentifier depthStencilBuffer, MaterialPropertyBlock properties = null, int shaderPassId = 0);
        public static void DrawFullScreen(CommandBuffer commandBuffer, Material material, RenderTargetIdentifier[] colorBuffers, RenderTargetIdentifier depthStencilBuffer, MaterialPropertyBlock properties = null, int shaderPassId = 0);
        public static void DrawFullScreen(CommandBuffer commandBuffer, Material material, RenderTargetIdentifier[] colorBuffers, MaterialPropertyBlock properties = null, int shaderPassId = 0);
        public static Color ConvertSRGBToActiveColorSpace(Color color);
        public static Color ConvertLinearToActiveColorSpace(Color color);
        public static Material CreateEngineMaterial(string shaderPath);
        public static Material CreateEngineMaterial(Shader shader);
        public static bool HasFlag<T>(T mask, T flag) where T : IConvertible;
        public static void Swap<T>(ref T a, ref T b);
        public static void SetKeyword(CommandBuffer cmd, string keyword, bool state);
        public static void SetKeyword(Material material, string keyword, bool state);
        public static void SetKeyword(ComputeShader cs, string keyword, bool state);
        public static void Destroy(Object obj);
        public static IEnumerable<Type> GetAllAssemblyTypes();
        public static IEnumerable<Type> GetAllTypesDerivedFrom<T>();
        public static void SafeRelease(ComputeBuffer buffer);
        public static Mesh CreateCubeMesh(Vector3 min, Vector3 max);
        public static bool ArePostProcessesEnabled(Camera camera);
        public static bool AreAnimatedMaterialsEnabled(Camera camera);
        public static bool IsSceneLightingDisabled(Camera camera);
        public static bool IsLightOverlapDebugEnabled(Camera camera);
        public static bool IsSceneViewFogEnabled(Camera camera);
        public static void DrawRendererList(ScriptableRenderContext renderContext, CommandBuffer cmd, RendererList rendererList);
    }
}
using System;

namespace UnityEngine.Rendering
{
    public static class DelegateUtility
    {
        public static Delegate Cast(Delegate source, Type type);
    }
}
namespace UnityEngine.Rendering
{
    public class HableCurve
    {
        public readonly Segment[] segments;
        public readonly Uniforms uniforms;

        public HableCurve();

        public float whitePoint { get; }
        public float inverseWhitePoint { get; }
        public float x0 { get; }
        public float x1 { get; }

        public float Eval(float x);
        public void Init(float toeStrength, float toeLength, float shoulderStrength, float shoulderLength, float shoulderAngle, float gamma);

        public class Segment
        {
            public float offsetX;
            public float offsetY;
            public float scaleX;
            public float scaleY;
            public float lnA;
            public float B;

            public Segment();

            public float Eval(float x);
        }
        public class Uniforms
        {
            public Vector4 curve { get; }
            public Vector4 toeSegmentA { get; }
            public Vector4 toeSegmentB { get; }
            public Vector4 midSegmentA { get; }
            public Vector4 midSegmentB { get; }
            public Vector4 shoSegmentA { get; }
            public Vector4 shoSegmentB { get; }
        }
    }
}
namespace UnityEngine.Rendering
{
    public static class HaltonSequence
    {
        public static float Get(int index, int radix);
    }
}
using System;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering
{
    [Flags]
    [MovedFrom("Utilities")]
    public enum MaterialQuality
    {
        Low = 1,
        Medium = 2,
        High = 4
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEngine.Rendering
{
    [MovedFrom("Utilities")]
    public static class MaterialQualityUtilities
    {
        public static string[] KeywordNames;
        public static string[] EnumNames;
        public static ShaderKeyword[] Keywords;

        public static MaterialQuality GetHighestQuality(this MaterialQuality levels);
        public static MaterialQuality GetClosestQuality(this MaterialQuality availableLevels, MaterialQuality requestedLevel);
        public static void SetGlobalShaderKeywords(this MaterialQuality level);
        public static void SetGlobalShaderKeywords(this MaterialQuality level, CommandBuffer cmd);
        public static int ToFirstIndex(this MaterialQuality level);
        public static MaterialQuality FromIndex(int index);
    }
}
using System.Runtime.CompilerServices;

namespace UnityEngine.Rendering
{
    public static class ResourceReloader
    {
        [return: TupleElementNames(new[] {"hasChange", "assetDatabaseNotReady" })]
        public static (bool hasChange, bool assetDatabaseNotReady) TryReloadAllNullIn(object container, string basePath);
        public static bool ReloadAllNullIn(object container, string basePath);
    }
}
using System;

namespace UnityEngine.Rendering
{
    [AttributeUsage(Field)]
    public sealed class ReloadAttribute : Attribute
    {
        public readonly Package package;
        public readonly string[] paths;

        public ReloadAttribute(string[] paths, Package package = Root);
        public ReloadAttribute(string path, Package package = Root);
        public ReloadAttribute(string pathFormat, int rangeMin, int rangeMax, Package package = Root);

        public enum Package
        {
            Builtin = 0,
            Root = 1
        }
    }
}
using System;

namespace UnityEngine.Rendering
{
    [AttributeUsage(Class)]
    public sealed class ReloadGroupAttribute : Attribute
    {
        public ReloadGroupAttribute();
    }
}
using System;
using System.Reflection;

namespace UnityEngine.Rendering
{
    [DefaultMember("Item")]
    public class TextureCurve : IDisposable
    {
        public TextureCurve(AnimationCurve baseCurve, float zeroValue, bool loop, in Vector2 bounds);
        public TextureCurve(Keyframe[] keys, float zeroValue, bool loop, in Vector2 bounds);

        ~TextureCurve();

        public Keyframe this[int index] { get; }
        public int length { get; }

        [Obsolete("Please use Release() instead.")]
        public void Dispose();
        public void Release();
        public void SetDirty();
        public Texture2D GetTexture();
        public float Evaluate(float time);
        public int AddKey(float time, float value);
        public int MoveKey(int index, in Keyframe key);
        public void RemoveKey(int index);
        public void SmoothTangents(int index, float weight);
    }
}
namespace UnityEngine.Rendering
{
    public class TextureCurveParameter : VolumeParameter<TextureCurve>
    {
        public TextureCurveParameter(TextureCurve value, bool overrideState = False);

        public override void Release();
    }
}
namespace UnityEngine.Rendering
{
    public static class TileLayoutUtils
    {
        public static bool TryLayoutByTiles(RectInt src, uint tileSize, out RectInt main, out RectInt topRow, out RectInt rightCol, out RectInt topRight);
        public static bool TryLayoutByRow(RectInt src, uint tileSize, out RectInt main, out RectInt other);
        public static bool TryLayoutByCol(RectInt src, uint tileSize, out RectInt main, out RectInt other);
    }
}
namespace UnityEngine.Rendering
{
    public static class XRUtils
    {
        public static void DrawOcclusionMesh(CommandBuffer cmd, Camera camera, bool stereoEnabled = True);
    }
}
namespace UnityEngine.Rendering
{
    [HelpURL("https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@10.10/manual/Volumes.html")]
    [ExecuteAlways]
    [AddComponentMenu("Miscellaneous/Volume")]
    public class Volume : MonoBehaviour
    {
        [Tooltip("When enabled, HDRP applies this Volume to the entire Scene.")]
        public bool isGlobal;
        [Tooltip("Sets the Volume priority in the stack. A higher value means higher priority. You can use negative values.")]
        public float priority;
        [Tooltip("Sets the outer distance to start blending from. A value of 0 means no blending and Unity applies the Volume overrides immediately upon entry.")]
        public float blendDistance;
        [Range(0, 1)]
        [Tooltip("Sets the total weight of this Volume in the Scene. 0 means no effect and 1 means full effect.")]
        public float weight;
        public VolumeProfile sharedProfile;

        public Volume();

        public VolumeProfile profile { get; set; }

        public bool HasInstantiatedProfile();
    }
}
using System;

namespace UnityEngine.Rendering
{
    [AttributeUsage(Class, AllowMultiple = False)]
    public sealed class VolumeComponentMenu : Attribute
    {
        public readonly string menu;

        public VolumeComponentMenu(string menu);
    }
}
using System;

namespace UnityEngine.Rendering
{
    [AttributeUsage(Class, AllowMultiple = False)]
    public sealed class VolumeComponentDeprecated : Attribute
    {
        public VolumeComponentDeprecated();
    }
}
using System.Collections.ObjectModel;

namespace UnityEngine.Rendering
{
    public class VolumeComponent : ScriptableObject
    {
        public bool active;

        public VolumeComponent();

        public string displayName { get; protected set; }
        public ReadOnlyCollection<VolumeParameter> parameters { get; }

        protected virtual void OnEnable();
        protected virtual void OnDisable();
        public virtual void Override(VolumeComponent state, float interpFactor);
        public void SetAllOverridesTo(bool state);
        public override int GetHashCode();
        public bool AnyPropertiesIsOverridden();
        protected virtual void OnDestroy();
        public void Release();
    }
}
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    public sealed class VolumeManager
    {
        public static VolumeManager instance { get; }
        public VolumeStack stack { get; set; }
        [Obsolete("Please use baseComponentTypeArray instead.")]
        public IEnumerable<Type> baseComponentTypes { get; }
        public Type[] baseComponentTypeArray { get; }

        public VolumeStack CreateStack();
        public void ResetMainStack();
        public void DestroyStack(VolumeStack stack);
        public void Register(Volume volume, int layer);
        public void Unregister(Volume volume, int layer);
        public bool IsComponentActiveInMask<T>(LayerMask layerMask) where T : VolumeComponent;
        [Conditional("UNITY_EDITOR")]
        public void CheckBaseTypes();
        [Conditional("UNITY_EDITOR")]
        public void CheckStack(VolumeStack stack);
        public void Update(Transform trigger, LayerMask layerMask);
        public void Update(VolumeStack stack, Transform trigger, LayerMask layerMask);
        public Volume[] GetVolumes(LayerMask layerMask);
    }
}
using System;

namespace UnityEngine.Rendering
{
    [Obsolete("VolumeIsolationScope is deprecated, it does not have any effect anymore.")]
    public struct VolumeIsolationScope : IDisposable
    {
        public VolumeIsolationScope(bool unused);
    }
}
using System;

namespace UnityEngine.Rendering
{
    public abstract class VolumeParameter
    {
        public const string k_DebuggerDisplay = "{m_Value} ({m_OverrideState})";
        [SerializeField]
        protected bool m_OverrideState;

        protected VolumeParameter();

        public virtual bool overrideState { get; set; }

        public T GetValue<T>();
        public abstract void SetValue(VolumeParameter parameter);
        protected internal virtual void OnEnable();
        protected internal virtual void OnDisable();
        public static bool IsObjectParameter(Type type);
        public virtual void Release();
    }
}
using System;
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class VolumeParameter<T> : VolumeParameter, IEquatable<VolumeParameter<T>>
    {
        [SerializeField]
        protected T m_Value;

        public VolumeParameter();
        protected VolumeParameter(T value, bool overrideState);

        public virtual T value { get; set; }

        public virtual void Interp(T from, T to, float t);
        public void Override(T x);
        public override void SetValue(VolumeParameter parameter);
        public override int GetHashCode();
        public override string ToString();
        public bool Equals(VolumeParameter<T> other);
        public override bool Equals(object obj);

        public static bool operator ==(VolumeParameter<T> lhs, T rhs);
        public static bool operator !=(VolumeParameter<T> lhs, T rhs);

        public static explicit operator T(VolumeParameter<T> prop);
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class BoolParameter : VolumeParameter<bool>
    {
        public BoolParameter(bool value, bool overrideState = False);
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class LayerMaskParameter : VolumeParameter<LayerMask>
    {
        public LayerMaskParameter(LayerMask value, bool overrideState = False);
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class IntParameter : VolumeParameter<int>
    {
        public IntParameter(int value, bool overrideState = False);

        public sealed override void Interp(int from, int to, float t);
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class NoInterpIntParameter : VolumeParameter<int>
    {
        public NoInterpIntParameter(int value, bool overrideState = False);
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class MinIntParameter : IntParameter
    {
        public int min;

        public MinIntParameter(int value, int min, bool overrideState = False);

        public override int value { get; set; }
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class NoInterpMinIntParameter : VolumeParameter<int>
    {
        public int min;

        public NoInterpMinIntParameter(int value, int min, bool overrideState = False);

        public override int value { get; set; }
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class MaxIntParameter : IntParameter
    {
        public int max;

        public MaxIntParameter(int value, int max, bool overrideState = False);

        public override int value { get; set; }
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class NoInterpMaxIntParameter : VolumeParameter<int>
    {
        public int max;

        public NoInterpMaxIntParameter(int value, int max, bool overrideState = False);

        public override int value { get; set; }
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class ClampedIntParameter : IntParameter
    {
        public int min;
        public int max;

        public ClampedIntParameter(int value, int min, int max, bool overrideState = False);

        public override int value { get; set; }
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class NoInterpClampedIntParameter : VolumeParameter<int>
    {
        public int min;
        public int max;

        public NoInterpClampedIntParameter(int value, int min, int max, bool overrideState = False);

        public override int value { get; set; }
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class FloatParameter : VolumeParameter<float>
    {
        public FloatParameter(float value, bool overrideState = False);

        public sealed override void Interp(float from, float to, float t);
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class NoInterpFloatParameter : VolumeParameter<float>
    {
        public NoInterpFloatParameter(float value, bool overrideState = False);
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class MinFloatParameter : FloatParameter
    {
        public float min;

        public MinFloatParameter(float value, float min, bool overrideState = False);

        public override float value { get; set; }
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class NoInterpMinFloatParameter : VolumeParameter<float>
    {
        public float min;

        public NoInterpMinFloatParameter(float value, float min, bool overrideState = False);

        public override float value { get; set; }
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class MaxFloatParameter : FloatParameter
    {
        public float max;

        public MaxFloatParameter(float value, float max, bool overrideState = False);

        public override float value { get; set; }
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class NoInterpMaxFloatParameter : VolumeParameter<float>
    {
        public float max;

        public NoInterpMaxFloatParameter(float value, float max, bool overrideState = False);

        public override float value { get; set; }
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class ClampedFloatParameter : FloatParameter
    {
        public float min;
        public float max;

        public ClampedFloatParameter(float value, float min, float max, bool overrideState = False);

        public override float value { get; set; }
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class NoInterpClampedFloatParameter : VolumeParameter<float>
    {
        public float min;
        public float max;

        public NoInterpClampedFloatParameter(float value, float min, float max, bool overrideState = False);

        public override float value { get; set; }
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class FloatRangeParameter : VolumeParameter<Vector2>
    {
        public float min;
        public float max;

        public FloatRangeParameter(Vector2 value, float min, float max, bool overrideState = False);

        public override Vector2 value { get; set; }

        public override void Interp(Vector2 from, Vector2 to, float t);
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class NoInterpFloatRangeParameter : VolumeParameter<Vector2>
    {
        public float min;
        public float max;

        public NoInterpFloatRangeParameter(Vector2 value, float min, float max, bool overrideState = False);

        public override Vector2 value { get; set; }
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class ColorParameter : VolumeParameter<Color>
    {
        public bool hdr;
        public bool showAlpha;
        public bool showEyeDropper;

        public ColorParameter(Color value, bool overrideState = False);
        public ColorParameter(Color value, bool hdr, bool showAlpha, bool showEyeDropper, bool overrideState = False);

        public override void Interp(Color from, Color to, float t);
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class NoInterpColorParameter : VolumeParameter<Color>
    {
        public bool hdr;
        public bool showAlpha;
        public bool showEyeDropper;

        public NoInterpColorParameter(Color value, bool overrideState = False);
        public NoInterpColorParameter(Color value, bool hdr, bool showAlpha, bool showEyeDropper, bool overrideState = False);
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class Vector2Parameter : VolumeParameter<Vector2>
    {
        public Vector2Parameter(Vector2 value, bool overrideState = False);

        public override void Interp(Vector2 from, Vector2 to, float t);
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class NoInterpVector2Parameter : VolumeParameter<Vector2>
    {
        public NoInterpVector2Parameter(Vector2 value, bool overrideState = False);
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class Vector3Parameter : VolumeParameter<Vector3>
    {
        public Vector3Parameter(Vector3 value, bool overrideState = False);

        public override void Interp(Vector3 from, Vector3 to, float t);
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class NoInterpVector3Parameter : VolumeParameter<Vector3>
    {
        public NoInterpVector3Parameter(Vector3 value, bool overrideState = False);
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class Vector4Parameter : VolumeParameter<Vector4>
    {
        public Vector4Parameter(Vector4 value, bool overrideState = False);

        public override void Interp(Vector4 from, Vector4 to, float t);
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class NoInterpVector4Parameter : VolumeParameter<Vector4>
    {
        public NoInterpVector4Parameter(Vector4 value, bool overrideState = False);
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class TextureParameter : VolumeParameter<Texture>
    {
        public TextureParameter(Texture value, bool overrideState = False);
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class NoInterpTextureParameter : VolumeParameter<Texture>
    {
        public NoInterpTextureParameter(Texture value, bool overrideState = False);
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class RenderTextureParameter : VolumeParameter<RenderTexture>
    {
        public RenderTextureParameter(RenderTexture value, bool overrideState = False);
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class NoInterpRenderTextureParameter : VolumeParameter<RenderTexture>
    {
        public NoInterpRenderTextureParameter(RenderTexture value, bool overrideState = False);
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class CubemapParameter : VolumeParameter<Cubemap>
    {
        public CubemapParameter(Cubemap value, bool overrideState = False);
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class NoInterpCubemapParameter : VolumeParameter<Cubemap>
    {
        public NoInterpCubemapParameter(Cubemap value, bool overrideState = False);
    }
}
using System.Diagnostics;

namespace UnityEngine.Rendering
{
    [DebuggerDisplay("{m_Value} ({m_OverrideState})")]
    public class ObjectParameter<T> : VolumeParameter<T>
    {
        public ObjectParameter(T value);

        public sealed override bool overrideState { get; set; }
        public sealed override T value { get; set; }
    }
}
namespace UnityEngine.Rendering
{
    public class AnimationCurveParameter : VolumeParameter<AnimationCurve>
    {
        public AnimationCurveParameter(AnimationCurve value, bool overrideState = False);
    }
}
using System;
using System.Collections.Generic;

namespace UnityEngine.Rendering
{
    [HelpURL("https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@10.10/manual/Volume-Profile.html")]
    public sealed class VolumeProfile : ScriptableObject
    {
        public List<VolumeComponent> components;
        public bool isDirty;

        public VolumeProfile();

        public void Reset();
        public T Add<T>(bool overrides = False) where T : VolumeComponent;
        public VolumeComponent Add(Type type, bool overrides = False);
        public void Remove<T>() where T : VolumeComponent;
        public void Remove(Type type);
        public bool Has<T>() where T : VolumeComponent;
        public bool Has(Type type);
        public bool HasSubclassOf(Type type);
        public bool TryGet<T>(out T component) where T : VolumeComponent;
        public bool TryGet<T>(Type type, out T component) where T : VolumeComponent;
        public bool TryGetSubclassOf<T>(Type type, out T component) where T : VolumeComponent;
        public bool TryGetAllSubclassOf<T>(Type type, List<T> result) where T : VolumeComponent;
        public override int GetHashCode();
    }
}
using System;

namespace UnityEngine.Rendering
{
    public sealed class VolumeStack : IDisposable
    {
        public T GetComponent<T>() where T : VolumeComponent;
        public VolumeComponent GetComponent(Type type);
        public void Dispose();
    }
}
namespace UnityEngine.Rendering
{
    public static class XRGraphicsAutomatedTests
    {
        public static bool running;

        public static bool enabled { get; }
    }
}
using System.Collections.Generic;

namespace UnityEngine.Rendering.LookDev
{
    public interface IDataProvider
    {
        IEnumerable<string> supportedDebugModes { get; }

        void FirstInitScene(StageRuntimeInterface stage);
        void UpdateSky(Camera camera, Sky sky, StageRuntimeInterface stage);
        void UpdateDebugMode(int debugIndex);
        void GetShadowMask(ref RenderTexture output, StageRuntimeInterface stage);
        void OnBeginRendering(StageRuntimeInterface stage);
        void OnEndRendering(StageRuntimeInterface stage);
        void Cleanup(StageRuntimeInterface SRI);
    }
}
namespace UnityEngine.Rendering.LookDev
{
    public struct Sky
    {
        public Cubemap cubemap;
        public float longitudeOffset;
        public float exposure;
    }
}
using System;

namespace UnityEngine.Rendering.LookDev
{
    public class StageRuntimeInterface
    {
        public object SRPData;

        public StageRuntimeInterface(Func<bool, GameObject> AddGameObject, Func<Camera> GetCamera, Func<Light> GetSunLight);

        public Camera camera { get; }
        public Light sunLight { get; }

        public GameObject AddGameObject(bool persistent = False);
    }
}
using System.Collections.Generic;
using UnityEngine.UI;

namespace UnityEngine.Rendering.UI
{
    public class DebugUIHandlerBitField : DebugUIHandlerWidget
    {
        public Text nameLabel;
        public UIFoldout valueToggle;
        public List<DebugUIHandlerIndirectToggle> toggles;

        public DebugUIHandlerBitField();

        public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous);
        public override void OnDeselection();
        public override void OnIncrement(bool fast);
        public override void OnDecrement(bool fast);
        public override void OnAction();
        public override DebugUIHandlerWidget Next();
    }
}
using UnityEngine.UI;

namespace UnityEngine.Rendering.UI
{
    public class DebugUIHandlerButton : DebugUIHandlerWidget
    {
        public Text nameLabel;

        public DebugUIHandlerButton();

        public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous);
        public override void OnDeselection();
        public override void OnAction();
    }
}
namespace UnityEngine.Rendering.UI
{
    public class DebugUIPrefabBundle
    {
        public string type;
        public RectTransform prefab;

        public DebugUIPrefabBundle();
    }
}
using System.Collections.Generic;

namespace UnityEngine.Rendering.UI
{
    public class DebugUIHandlerCanvas : MonoBehaviour
    {
        public Transform panelPrefab;
        public List<DebugUIPrefabBundle> prefabs;

        public DebugUIHandlerCanvas();
    }
}
using UnityEngine.UI;

namespace UnityEngine.Rendering.UI
{
    public class DebugUIHandlerColor : DebugUIHandlerWidget
    {
        public Text nameLabel;
        public UIFoldout valueToggle;
        public Image colorImage;
        public DebugUIHandlerIndirectFloatField fieldR;
        public DebugUIHandlerIndirectFloatField fieldG;
        public DebugUIHandlerIndirectFloatField fieldB;
        public DebugUIHandlerIndirectFloatField fieldA;

        public DebugUIHandlerColor();

        public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous);
        public override void OnDeselection();
        public override void OnIncrement(bool fast);
        public override void OnDecrement(bool fast);
        public override void OnAction();
        public override DebugUIHandlerWidget Next();
    }
}
namespace UnityEngine.Rendering.UI
{
    public class DebugUIHandlerContainer : MonoBehaviour
    {
        [SerializeField]
        public RectTransform contentHolder;

        public DebugUIHandlerContainer();
    }
}
using UnityEngine.UI;

namespace UnityEngine.Rendering.UI
{
    public class DebugUIHandlerEnumField : DebugUIHandlerWidget
    {
        public Text nameLabel;
        public Text valueLabel;
        protected internal DebugUI.EnumField m_Field;

        public DebugUIHandlerEnumField();

        public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous);
        public override void OnDeselection();
        public override void OnAction();
        public override void OnIncrement(bool fast);
        public override void OnDecrement(bool fast);
        protected virtual void UpdateValueLabel();
    }
}
namespace UnityEngine.Rendering.UI
{
    public class DebugUIHandlerEnumHistory : DebugUIHandlerEnumField
    {
        public DebugUIHandlerEnumHistory();

        protected override void UpdateValueLabel();
    }
}
using UnityEngine.UI;

namespace UnityEngine.Rendering.UI
{
    public class DebugUIHandlerFloatField : DebugUIHandlerWidget
    {
        public Text nameLabel;
        public Text valueLabel;

        public DebugUIHandlerFloatField();

        public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous);
        public override void OnDeselection();
        public override void OnIncrement(bool fast);
        public override void OnDecrement(bool fast);
    }
}
using UnityEngine.UI;

namespace UnityEngine.Rendering.UI
{
    public class DebugUIHandlerFoldout : DebugUIHandlerWidget
    {
        public Text nameLabel;
        public UIFoldout valueToggle;

        public DebugUIHandlerFoldout();

        public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous);
        public override void OnDeselection();
        public override void OnIncrement(bool fast);
        public override void OnDecrement(bool fast);
        public override void OnAction();
        public override DebugUIHandlerWidget Next();
    }
}
using UnityEngine.UI;

namespace UnityEngine.Rendering.UI
{
    public class DebugUIHandlerGroup : DebugUIHandlerWidget
    {
        public Text nameLabel;
        public Transform header;

        public DebugUIHandlerGroup();

        public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous);
        public override DebugUIHandlerWidget Next();
    }
}
namespace UnityEngine.Rendering.UI
{
    public class DebugUIHandlerHBox : DebugUIHandlerWidget
    {
        public DebugUIHandlerHBox();

        public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous);
        public override DebugUIHandlerWidget Next();
    }
}
using System;
using UnityEngine.UI;

namespace UnityEngine.Rendering.UI
{
    public class DebugUIHandlerIndirectFloatField : DebugUIHandlerWidget
    {
        public Text nameLabel;
        public Text valueLabel;
        public Func<float> getter;
        public Action<float> setter;
        public Func<float> incStepGetter;
        public Func<float> incStepMultGetter;
        public Func<float> decimalsGetter;

        public DebugUIHandlerIndirectFloatField();

        public void Init();
        public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous);
        public override void OnDeselection();
        public override void OnIncrement(bool fast);
        public override void OnDecrement(bool fast);
    }
}
using System;
using UnityEngine.UI;

namespace UnityEngine.Rendering.UI
{
    public class DebugUIHandlerIndirectToggle : DebugUIHandlerWidget
    {
        public Text nameLabel;
        public Toggle valueToggle;
        public Image checkmarkImage;
        public Func<int, bool> getter;
        public Action<int, bool> setter;

        public DebugUIHandlerIndirectToggle();

        public void Init();
        public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous);
        public override void OnDeselection();
        public override void OnAction();
    }
}
using UnityEngine.UI;

namespace UnityEngine.Rendering.UI
{
    public class DebugUIHandlerIntField : DebugUIHandlerWidget
    {
        public Text nameLabel;
        public Text valueLabel;

        public DebugUIHandlerIntField();

        public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous);
        public override void OnDeselection();
        public override void OnIncrement(bool fast);
        public override void OnDecrement(bool fast);
    }
}
using UnityEngine.UI;

namespace UnityEngine.Rendering.UI
{
    public class DebugUIHandlerPanel : MonoBehaviour
    {
        public Text nameLabel;
        public ScrollRect scrollRect;
        public RectTransform viewport;
        protected internal DebugUI.Panel m_Panel;

        public DebugUIHandlerPanel();
    }
}
namespace UnityEngine.Rendering.UI
{
    public class DebugUIHandlerRow : DebugUIHandlerFoldout
    {
        public DebugUIHandlerRow();

        protected override void OnEnable();
        protected void Update();
    }
}
using UnityEngine.UI;

namespace UnityEngine.Rendering.UI
{
    public class DebugUIHandlerToggle : DebugUIHandlerWidget
    {
        public Text nameLabel;
        public Toggle valueToggle;
        public Image checkmarkImage;
        protected internal DebugUI.BoolField m_Field;

        public DebugUIHandlerToggle();

        public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous);
        public override void OnDeselection();
        public override void OnAction();
        protected internal virtual void UpdateValueLabel();
    }
}
namespace UnityEngine.Rendering.UI
{
    public class DebugUIHandlerToggleHistory : DebugUIHandlerToggle
    {
        public DebugUIHandlerToggleHistory();

        protected internal override void UpdateValueLabel();
    }
}
using UnityEngine.UI;

namespace UnityEngine.Rendering.UI
{
    public class DebugUIHandlerUIntField : DebugUIHandlerWidget
    {
        public Text nameLabel;
        public Text valueLabel;

        public DebugUIHandlerUIntField();

        public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous);
        public override void OnDeselection();
        public override void OnIncrement(bool fast);
        public override void OnDecrement(bool fast);
    }
}
namespace UnityEngine.Rendering.UI
{
    public class DebugUIHandlerVBox : DebugUIHandlerWidget
    {
        public DebugUIHandlerVBox();

        public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous);
        public override DebugUIHandlerWidget Next();
    }
}
using UnityEngine.UI;

namespace UnityEngine.Rendering.UI
{
    public class DebugUIHandlerValue : DebugUIHandlerWidget
    {
        public Text nameLabel;
        public Text valueLabel;

        public DebugUIHandlerValue();

        protected override void OnEnable();
        public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous);
        public override void OnDeselection();
    }
}
using UnityEngine.UI;

namespace UnityEngine.Rendering.UI
{
    public class DebugUIHandlerVector2 : DebugUIHandlerWidget
    {
        public Text nameLabel;
        public UIFoldout valueToggle;
        public DebugUIHandlerIndirectFloatField fieldX;
        public DebugUIHandlerIndirectFloatField fieldY;

        public DebugUIHandlerVector2();

        public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous);
        public override void OnDeselection();
        public override void OnIncrement(bool fast);
        public override void OnDecrement(bool fast);
        public override void OnAction();
        public override DebugUIHandlerWidget Next();
    }
}
using UnityEngine.UI;

namespace UnityEngine.Rendering.UI
{
    public class DebugUIHandlerVector3 : DebugUIHandlerWidget
    {
        public Text nameLabel;
        public UIFoldout valueToggle;
        public DebugUIHandlerIndirectFloatField fieldX;
        public DebugUIHandlerIndirectFloatField fieldY;
        public DebugUIHandlerIndirectFloatField fieldZ;

        public DebugUIHandlerVector3();

        public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous);
        public override void OnDeselection();
        public override void OnIncrement(bool fast);
        public override void OnDecrement(bool fast);
        public override void OnAction();
        public override DebugUIHandlerWidget Next();
    }
}
using UnityEngine.UI;

namespace UnityEngine.Rendering.UI
{
    public class DebugUIHandlerVector4 : DebugUIHandlerWidget
    {
        public Text nameLabel;
        public UIFoldout valueToggle;
        public DebugUIHandlerIndirectFloatField fieldX;
        public DebugUIHandlerIndirectFloatField fieldY;
        public DebugUIHandlerIndirectFloatField fieldZ;
        public DebugUIHandlerIndirectFloatField fieldW;

        public DebugUIHandlerVector4();

        public override bool OnSelection(bool fromNext, DebugUIHandlerWidget previous);
        public override void OnDeselection();
        public override void OnIncrement(bool fast);
        public override void OnDecrement(bool fast);
        public override void OnAction();
        public override DebugUIHandlerWidget Next();
    }
}
namespace UnityEngine.Rendering.UI
{
    public class DebugUIHandlerWidget : MonoBehaviour
    {
        [HideInInspector]
        public Color colorDefault;
        [HideInInspector]
        public Color colorSelected;
        protected DebugUI.Widget m_Widget;

        public DebugUIHandlerWidget();

        public DebugUIHandlerWidget parentUIHandler { get; set; }
        public DebugUIHandlerWidget previousUIHandler { get; set; }
        public DebugUIHandlerWidget nextUIHandler { get; set; }

        protected virtual void OnEnable();
        protected T CastWidget<T>() where T : DebugUI.Widget;
        public virtual bool OnSelection(bool fromNext, DebugUIHandlerWidget previous);
        public virtual void OnDeselection();
        public virtual void OnAction();
        public virtual void OnIncrement(bool fast);
        public virtual void OnDecrement(bool fast);
        public virtual DebugUIHandlerWidget Previous();
        public virtual DebugUIHandlerWidget Next();
    }
}
using UnityEngine.UI;

namespace UnityEngine.Rendering.UI
{
    [ExecuteAlways]
    public class UIFoldout : Toggle
    {
        public GameObject content;
        public GameObject arrowOpened;
        public GameObject arrowClosed;

        public UIFoldout();

        protected override void Start();
        public void SetState(bool state);
        public void SetState(bool state, bool rebuildLayout);
    }
}
-------- {UnityEditor.UI(D:\Documents\GitHub\Rogue-like-game-i-guess\The game is liar\Library\ScriptAssemblies\UnityEditor.UI.dll)}:   53 --------
using UnityEngine.UI;

namespace UnityEditor.UI
{
    [CustomEditor(typeof(AspectRatioFitter), True)]
    [CanEditMultipleObjects]
    public class AspectRatioFitterEditor : SelfControllerEditor
    {
        public AspectRatioFitterEditor();

        protected virtual void OnEnable();
        public override void OnInspectorGUI();
        protected virtual void OnDisable();
    }
}
using UnityEngine.UI;

namespace UnityEditor.UI
{
    [CustomEditor(typeof(Button), True)]
    [CanEditMultipleObjects]
    public class ButtonEditor : SelectableEditor
    {
        public ButtonEditor();

        protected override void OnEnable();
        public override void OnInspectorGUI();
    }
}
using UnityEngine.UI;

namespace UnityEditor.UI
{
    [CustomEditor(typeof(CanvasScaler), True)]
    [CanEditMultipleObjects]
    public class CanvasScalerEditor : Editor
    {
        public CanvasScalerEditor();

        protected virtual void OnEnable();
        public override void OnInspectorGUI();
    }
}
using UnityEngine.UI;

namespace UnityEditor.UI
{
    [CustomEditor(typeof(ContentSizeFitter), True)]
    [CanEditMultipleObjects]
    public class ContentSizeFitterEditor : SelfControllerEditor
    {
        public ContentSizeFitterEditor();

        protected virtual void OnEnable();
        public override void OnInspectorGUI();
    }
}
using UnityEngine.UI;

namespace UnityEditor.UI
{
    [CustomEditor(typeof(Dropdown), True)]
    [CanEditMultipleObjects]
    public class DropdownEditor : SelectableEditor
    {
        public DropdownEditor();

        protected override void OnEnable();
        public override void OnInspectorGUI();
    }
}
using UnityEditor.AnimatedValues;
using UnityEngine.UI;

namespace UnityEditor.UI
{
    [CustomEditor(typeof(MaskableGraphic), False)]
    [CanEditMultipleObjects]
    public class GraphicEditor : Editor
    {
        protected SerializedProperty m_Script;
        protected SerializedProperty m_Color;
        protected SerializedProperty m_Material;
        protected SerializedProperty m_RaycastTarget;
        protected SerializedProperty m_RaycastPadding;
        protected SerializedProperty m_Maskable;
        protected AnimBool m_ShowNativeSize;

        public GraphicEditor();

        protected virtual void OnDisable();
        protected virtual void OnEnable();
        public override void OnInspectorGUI();
        protected void SetShowNativeSize(bool show, bool instant);
        protected void NativeSizeButtonGUI();
        protected void MaskableControlsGUI();
        protected void AppearanceControlsGUI();
        protected void RaycastControlsGUI();
    }
}
using UnityEngine.UI;

namespace UnityEditor.UI
{
    [CustomEditor(typeof(GridLayoutGroup), True)]
    [CanEditMultipleObjects]
    public class GridLayoutGroupEditor : Editor
    {
        public GridLayoutGroupEditor();

        protected virtual void OnEnable();
        public override void OnInspectorGUI();
    }
}
using UnityEngine.UI;

namespace UnityEditor.UI
{
    [CustomEditor(typeof(HorizontalOrVerticalLayoutGroup), True)]
    [CanEditMultipleObjects]
    public class HorizontalOrVerticalLayoutGroupEditor : Editor
    {
        public HorizontalOrVerticalLayoutGroupEditor();

        protected virtual void OnEnable();
        public override void OnInspectorGUI();
    }
}
using UnityEngine;
using UnityEngine.UI;

namespace UnityEditor.UI
{
    [CustomEditor(typeof(Image), True)]
    [CanEditMultipleObjects]
    public class ImageEditor : GraphicEditor
    {
        public ImageEditor();

        protected override void OnEnable();
        protected override void OnDisable();
        public override void OnInspectorGUI();
        protected void SpriteGUI();
        protected void TypeGUI();
        public override bool HasPreviewGUI();
        public override void OnPreviewGUI(Rect rect, GUIStyle background);
        public override string GetInfoString();
    }
}
using UnityEngine.UI;

namespace UnityEditor.UI
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(InputField), True)]
    public class InputFieldEditor : SelectableEditor
    {
        public InputFieldEditor();

        protected override void OnEnable();
        protected override void OnDisable();
        public override void OnInspectorGUI();
    }
}
using UnityEngine.UI;

namespace UnityEditor.UI
{
    [CustomEditor(typeof(LayoutElement), True)]
    [CanEditMultipleObjects]
    public class LayoutElementEditor : Editor
    {
        public LayoutElementEditor();

        protected virtual void OnEnable();
        public override void OnInspectorGUI();
    }
}
using UnityEngine.UI;

namespace UnityEditor.UI
{
    [CustomEditor(typeof(Mask), True)]
    [CanEditMultipleObjects]
    public class MaskEditor : Editor
    {
        public MaskEditor();

        protected virtual void OnEnable();
        public override void OnInspectorGUI();
    }
}
using UnityEngine;
using UnityEngine.UI;

namespace UnityEditor.UI
{
    [CustomPropertyDrawer(typeof(AnimationTriggers), True)]
    public class AnimationTriggersDrawer : PropertyDrawer
    {
        public AnimationTriggersDrawer();

        public override void OnGUI(Rect rect, SerializedProperty prop, GUIContent label);
        public override float GetPropertyHeight(SerializedProperty prop, GUIContent label);
    }
}
using UnityEngine;
using UnityEngine.UI;

namespace UnityEditor.UI
{
    [CustomPropertyDrawer(typeof(ColorBlock), True)]
    public class ColorBlockDrawer : PropertyDrawer
    {
        public ColorBlockDrawer();

        public override void OnGUI(Rect rect, SerializedProperty prop, GUIContent label);
        public override float GetPropertyHeight(SerializedProperty prop, GUIContent label);
    }
}
using UnityEngine;
using UnityEngine.UI;

namespace UnityEditor.UI
{
    [CustomPropertyDrawer(typeof(FontData), True)]
    public class FontDataDrawer : PropertyDrawer
    {
        public FontDataDrawer();

        protected void Init(SerializedProperty property);
        public override float GetPropertyHeight(SerializedProperty property, GUIContent label);
        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label);
    }
}
using UnityEngine;
using UnityEngine.UI;

namespace UnityEditor.UI
{
    [CustomPropertyDrawer(typeof(Navigation), True)]
    public class NavigationDrawer : PropertyDrawer
    {
        public NavigationDrawer();

        public override void OnGUI(Rect pos, SerializedProperty prop, GUIContent label);
        public override float GetPropertyHeight(SerializedProperty prop, GUIContent label);
    }
}
using UnityEngine;
using UnityEngine.UI;

namespace UnityEditor.UI
{
    [CustomPropertyDrawer(typeof(SpriteState), True)]
    public class SpriteStateDrawer : PropertyDrawer
    {
        public SpriteStateDrawer();

        public override void OnGUI(Rect rect, SerializedProperty prop, GUIContent label);
        public override float GetPropertyHeight(SerializedProperty prop, GUIContent label);
    }
}
using UnityEngine;
using UnityEngine.UI;

namespace UnityEditor.UI
{
    [CustomEditor(typeof(RawImage), True)]
    [CanEditMultipleObjects]
    public class RawImageEditor : GraphicEditor
    {
        public RawImageEditor();

        protected override void OnEnable();
        public override void OnInspectorGUI();
        public override bool HasPreviewGUI();
        public override void OnPreviewGUI(Rect rect, GUIStyle background);
        public override string GetInfoString();
    }
}
using UnityEngine.UI;

namespace UnityEditor.UI
{
    [CustomEditor(typeof(RectMask2D), True)]
    [CanEditMultipleObjects]
    public class RectMask2DEditor : Editor
    {
        public RectMask2DEditor();

        protected virtual void OnEnable();
        public override void OnInspectorGUI();
    }
}
using UnityEngine.UI;

namespace UnityEditor.UI
{
    [CustomEditor(typeof(ScrollRect), True)]
    [CanEditMultipleObjects]
    public class ScrollRectEditor : Editor
    {
        public ScrollRectEditor();

        protected virtual void OnEnable();
        protected virtual void OnDisable();
        public override void OnInspectorGUI();
    }
}
using UnityEngine.UI;

namespace UnityEditor.UI
{
    [CustomEditor(typeof(Scrollbar), True)]
    [CanEditMultipleObjects]
    public class ScrollbarEditor : SelectableEditor
    {
        public ScrollbarEditor();

        protected override void OnEnable();
        public override void OnInspectorGUI();
    }
}
using UnityEngine.UI;

namespace UnityEditor.UI
{
    [CustomEditor(typeof(Selectable), True)]
    public class SelectableEditor : Editor
    {
        public SelectableEditor();

        protected virtual void OnEnable();
        protected virtual void OnDisable();
        public override void OnInspectorGUI();
    }
}
namespace UnityEditor.UI
{
    public class SelfControllerEditor : Editor
    {
        public SelfControllerEditor();

        public override void OnInspectorGUI();
    }
}
using UnityEngine.UI;

namespace UnityEditor.UI
{
    [CustomEditor(typeof(Slider), True)]
    [CanEditMultipleObjects]
    public class SliderEditor : SelectableEditor
    {
        public SliderEditor();

        protected override void OnEnable();
        public override void OnInspectorGUI();
    }
}
using UnityEngine.UI;

namespace UnityEditor.UI
{
    [CustomEditor(typeof(Text), True)]
    [CanEditMultipleObjects]
    public class TextEditor : GraphicEditor
    {
        public TextEditor();

        protected override void OnEnable();
        public override void OnInspectorGUI();
    }
}
using UnityEngine.UI;

namespace UnityEditor.UI
{
    [CustomEditor(typeof(Toggle), True)]
    [CanEditMultipleObjects]
    public class ToggleEditor : SelectableEditor
    {
        public ToggleEditor();

        protected override void OnEnable();
        public override void OnInspectorGUI();
    }
}
using UnityEngine;
using UnityEngine.EventSystems;

namespace UnityEditor.EventSystems
{
    [CustomEditor(typeof(EventSystem), True)]
    public class EventSystemEditor : Editor
    {
        public EventSystemEditor();

        protected GUIStyle previewLabelStyle { get; }

        public override void OnInspectorGUI();
        public override bool HasPreviewGUI();
        public override bool RequiresConstantRepaint();
        public override void OnPreviewGUI(Rect rect, GUIStyle background);
    }
}
using UnityEngine.EventSystems;

namespace UnityEditor.EventSystems
{
    [CustomEditor(typeof(EventTrigger), True)]
    public class EventTriggerEditor : Editor
    {
        public EventTriggerEditor();

        protected virtual void OnEnable();
        public override void OnInspectorGUI();
    }
}
using UnityEngine.EventSystems;

namespace UnityEditor.EventSystems
{
    [CustomEditor(typeof(Physics2DRaycaster), True)]
    public class Physics2DRaycasterEditor : Editor
    {
        public Physics2DRaycasterEditor();

        public override void OnInspectorGUI();
    }
}
using UnityEngine.EventSystems;

namespace UnityEditor.EventSystems
{
    [CustomEditor(typeof(PhysicsRaycaster), True)]
    public class PhysicsRaycasterEditor : Editor
    {
        public PhysicsRaycasterEditor();

        public override void OnInspectorGUI();
    }
}
-------- {Unity.2D.Tilemap.Extras.Editor(D:\Documents\GitHub\Rogue-like-game-i-guess\The game is liar\Library\ScriptAssemblies\Unity.2D.Tilemap.Extras.Editor.dll)}:   42 --------
using UnityEngine;

namespace UnityEditor
{
    [CustomEditor(typeof(HexagonalRuleTile), True)]
    [CanEditMultipleObjects]
    public class HexagonalRuleTileEditor : RuleTileEditor
    {
        public HexagonalRuleTileEditor();

        public HexagonalRuleTile hexTile { get; }

        public override int GetArrowIndex(Vector3Int position);
        public override BoundsInt GetRuleGUIBounds(BoundsInt bounds, RuleTile.TilingRule rule);
        public override Vector2 GetMatrixSize(BoundsInt bounds);
        public override void RuleMatrixOnGUI(RuleTile tile, Rect rect, BoundsInt bounds, RuleTile.TilingRule tilingRule);
        protected override void CreatePreview();
    }
}
using UnityEngine;

namespace UnityEditor
{
    [CustomEditor(typeof(IsometricRuleTile), True)]
    [CanEditMultipleObjects]
    public class IsometricRuleTileEditor : RuleTileEditor
    {
        public IsometricRuleTileEditor();

        public override int GetArrowIndex(Vector3Int position);
        public override Vector2 GetMatrixSize(BoundsInt bounds);
        public override void RuleMatrixOnGUI(RuleTile tile, Rect rect, BoundsInt bounds, RuleTile.TilingRule tilingRule);
        public override bool ContainsMousePosition(Rect rect);
        public override void OnPreviewSettings();
        protected override void CreatePreview();
    }
}
using UnityEngine;
using UnityEngine.Tilemaps;

namespace UnityEditor
{
    [CustomEditor(typeof(AdvancedRuleOverrideTile))]
    public class AdvancedRuleOverrideTileEditor : RuleOverrideTileEditor
    {
        public AdvancedRuleOverrideTileEditor();

        public AdvancedRuleOverrideTile overrideTile { get; }

        public override void OnEnable();
        public override void OnInspectorGUI();
        public void DrawRulesHeader(Rect rect);
        public void DrawRuleElement(Rect rect, int index, bool active, bool focused);
        public void DrawRule(Rect rect, RuleTile.TilingRuleOutput rule, bool isOverride, RuleTile.TilingRule originalRule, bool isMissing);
        public float GetRuleElementHeight(int index);
    }
}
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Tilemaps;

namespace UnityEditor
{
    [CustomEditor(typeof(RuleOverrideTile))]
    public class RuleOverrideTileEditor : Editor
    {
        public List<KeyValuePair<Sprite, Sprite>> m_Sprites;
        public List<KeyValuePair<GameObject, GameObject>> m_GameObjects;
        public static float k_SpriteElementHeight;
        public static float k_GameObjectElementHeight;
        public static float k_PaddingBetweenRules;

        public RuleOverrideTileEditor();

        public RuleOverrideTile overrideTile { get; }
        public RuleTileEditor ruleTileEditor { get; }

        public virtual void OnEnable();
        public virtual void OnDisable();
        public override void OnInspectorGUI();
        public void DrawSpriteListHeader(Rect rect);
        public void DrawGameObjectListHeader(Rect rect);
        public float GetSpriteElementHeight(int index);
        public float GetGameObjectElementHeight(int index);
        public void DrawSpriteElement(Rect rect, int index, bool active, bool focused);
        public void DrawGameObjectElement(Rect rect, int index, bool active, bool focused);
        public void DrawTileField();
        public void DrawCustomFields();
        public void SaveTile();
        public override Texture2D RenderStaticPreview(string assetPath, Object[] subAssets, int width, int height);
        public override bool HasPreviewGUI();
        public override void OnPreviewSettings();
        public override void OnPreviewGUI(Rect rect, GUIStyle background);
    }
}
using System.Collections.Generic;
using UnityEditorInternal;
using UnityEngine;
using UnityEngine.Tilemaps;

namespace UnityEditor
{
    [CustomEditor(typeof(RuleTile), True)]
    [CanEditMultipleObjects]
    public class RuleTileEditor : Editor
    {
        public bool extendNeighbor;
        public PreviewRenderUtility m_PreviewUtility;
        public Grid m_PreviewGrid;
        public List<Tilemap> m_PreviewTilemaps;
        public List<TilemapRenderer> m_PreviewTilemapRenderers;
        public const float k_DefaultElementHeight = 48;
        public const float k_PaddingBetweenRules = 26;
        public const float k_SingleLineHeight = 16;
        public const float k_LabelWidth = 80;

        public RuleTileEditor();

        public static Texture2D[] arrows { get; }
        public static Texture2D[] autoTransforms { get; }
        public RuleTile tile { get; }

        public virtual void OnEnable();
        public virtual void OnDisable();
        public virtual BoundsInt GetRuleGUIBounds(BoundsInt bounds, RuleTile.TilingRule rule);
        public void ListUpdated(ReorderableList list);
        public float GetElementHeight(RuleTile.TilingRule rule);
        public float GetElementHeight(RuleTile.TilingRuleOutput rule);
        public virtual Vector2 GetMatrixSize(BoundsInt bounds);
        protected virtual void OnDrawElement(Rect rect, int index, bool isactive, bool isfocused);
        public void SaveTile();
        public static void UpdateAffectedOverrideTiles(RuleTile target);
        public static List<RuleOverrideTile> FindAffectedOverrideTiles(RuleTile target);
        public void OnDrawHeader(Rect rect);
        public override void OnInspectorGUI();
        public void DrawCustomFields(bool isOverrideInstance);
        public virtual int GetArrowIndex(Vector3Int position);
        public virtual void RuleOnGUI(Rect rect, Vector3Int position, int neighbor);
        public void RuleTooltipOnGUI(Rect rect, int neighbor);
        public virtual void RuleTransformOnGUI(Rect rect, RuleTile.TilingRuleOutput.Transform ruleTransform);
        public void RuleNeighborUpdate(Rect rect, RuleTile.TilingRule tilingRule, Dictionary<Vector3Int, int> neighbors, Vector3Int position);
        public void RuleTransformUpdate(Rect rect, RuleTile.TilingRule tilingRule);
        public virtual bool ContainsMousePosition(Rect rect);
        public static int GetMouseChange();
        public virtual void RuleMatrixOnGUI(RuleTile tile, Rect rect, BoundsInt bounds, RuleTile.TilingRule tilingRule);
        public void RuleMatrixIconOnGUI(RuleTile.TilingRule tilingRule, Dictionary<Vector3Int, int> neighbors, Vector3Int position, Rect rect);
        public virtual void SpriteOnGUI(Rect rect, RuleTile.TilingRuleOutput tilingRule);
        public void RuleInspectorOnGUI(Rect rect, RuleTile.TilingRuleOutput tilingRule);
        public override bool HasPreviewGUI();
        public override void OnPreviewGUI(Rect rect, GUIStyle background);
        protected virtual void CreatePreview();
        protected virtual void DestroyPreview();
        public override Texture2D RenderStaticPreview(string assetPath, Object[] subAssets, int width, int height);
        public static Texture2D Base64ToTexture(string base64);
        [MenuItem("CONTEXT/RuleTile/Copy All Rules")]
        public static void CopyAllRules(MenuCommand item);
        [MenuItem("CONTEXT/RuleTile/Paste Rules")]
        public static void PasteRules(MenuCommand item);
    }
}
using UnityEngine;

namespace UnityEditor.Tilemaps
{
    [CustomGridBrush(True, False, False, "Coordinate Brush")]
    public class CoordinateBrush : GridBrush
    {
        public CoordinateBrush();
    }
}
using UnityEngine;

namespace UnityEditor.Tilemaps
{
    [CustomEditor(typeof(CoordinateBrush))]
    public class CoordinateBrushEditor : GridBrushEditor
    {
        public CoordinateBrushEditor();

        public override void OnPaintSceneGUI(GridLayout grid, GameObject brushTarget, BoundsInt position, GridBrushBase.Tool tool, bool executing);
    }
}
using UnityEngine;

namespace UnityEditor.Tilemaps
{
    [HelpURL("https://docs.unity3d.com/Packages/com.unity.2d.tilemap.extras@latest/index.html?subfolder=/manual/GameObjectBrush.html")]
    [CustomGridBrush(True, False, False, "GameObject Brush")]
    public class GameObjectBrush : GridBrushBase
    {
        [HideInInspector]
        public GameObject hiddenGrid;
        public Vector3 m_Anchor;

        public GameObjectBrush();

        public Vector3Int size { get; set; }
        public Vector3Int pivot { get; set; }
        public BrushCell[] cells { get; }
        public int cellCount { get; }

        public void Init(Vector3Int size);
        public void Init(Vector3Int size, Vector3Int pivot);
        public override void Paint(GridLayout gridLayout, GameObject brushTarget, Vector3Int position);
        public override void Erase(GridLayout gridLayout, GameObject brushTarget, Vector3Int position);
        public override void BoxFill(GridLayout gridLayout, GameObject brushTarget, BoundsInt position);
        public override void BoxErase(GridLayout gridLayout, GameObject brushTarget, BoundsInt position);
        public override void FloodFill(GridLayout gridLayout, GameObject brushTarget, Vector3Int position);
        public override void Rotate(GridBrushBase.RotationDirection direction, GridLayout.CellLayout layout);
        public override void Flip(GridBrushBase.FlipAxis flip, GridLayout.CellLayout layout);
        public override void Pick(GridLayout gridLayout, GameObject brushTarget, BoundsInt position, Vector3Int pivot);
        public override void MoveStart(GridLayout gridLayout, GameObject brushTarget, BoundsInt position);
        public override void MoveEnd(GridLayout gridLayout, GameObject brushTarget, BoundsInt position);
        public void Reset();
        public void UpdateSizeAndPivot(Vector3Int size, Vector3Int pivot);
        public void SetGameObject(Vector3Int position, GameObject go);
        public void SetOffset(Vector3Int position, Vector3 offset);
        public void SetOrientation(Vector3Int position, Quaternion orientation);
        public void SetScale(Vector3Int position, Vector3 scale);
        public int GetCellIndex(Vector3Int brushPosition);
        public int GetCellIndex(int x, int y, int z);
        public int GetCellIndex(int x, int y, int z, int sizex, int sizey, int sizez);
        public int GetCellIndexWrapAround(int x, int y, int z);
        public override int GetHashCode();

        public class BrushCell
        {
            public BrushCell();

            public GameObject gameObject { get; set; }
            public Vector3 offset { get; set; }
            public Vector3 scale { get; set; }
            public Quaternion orientation { get; set; }

            public override int GetHashCode();
        }
    }
}
using UnityEngine;

namespace UnityEditor.Tilemaps
{
    [CustomEditor(typeof(GameObjectBrush))]
    public class GameObjectBrushEditor : GridBrushEditorBase
    {
        public GameObjectBrushEditor();

        public GameObjectBrush brush { get; }
        public override GameObject[] validTargets { get; }

        public override void OnPaintSceneGUI(GridLayout gridLayout, GameObject brushTarget, BoundsInt position, GridBrushBase.Tool tool, bool executing);
        public override void OnPaintInspectorGUI();
    }
}
using UnityEngine;

namespace UnityEditor.Tilemaps
{
    [HelpURL("https://docs.unity3d.com/Packages/com.unity.2d.tilemap.extras@latest/index.html?subfolder=/manual/GroupBrush.html")]
    [CustomGridBrush(True, False, False, "Group Brush")]
    public class GroupBrush : GridBrush
    {
        public GroupBrush();

        public Vector3Int gap { get; set; }
        public Vector3Int limit { get; set; }

        public override void Pick(GridLayout grid, GameObject brushTarget, BoundsInt position, Vector3Int pickStart);
    }
}
namespace UnityEditor.Tilemaps
{
    [CustomEditor(typeof(GroupBrush))]
    public class GroupBrushEditor : GridBrushEditor
    {
        public GroupBrushEditor();
    }
}
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace UnityEditor.Tilemaps
{
    [HelpURL("https://docs.unity3d.com/Packages/com.unity.2d.tilemap.extras@latest/index.html?subfolder=/manual/LineBrush.html")]
    [CustomGridBrush(True, False, False, "Line Brush")]
    public class LineBrush : GridBrush
    {
        public bool lineStartActive;
        public bool fillGaps;
        public Vector3Int lineStart;

        public LineBrush();

        public bool IsMoving { get; }

        public override void Paint(GridLayout grid, GameObject brushTarget, Vector3Int position);
        public override void MoveStart(GridLayout grid, GameObject brushTarget, BoundsInt position);
        public override void MoveEnd(GridLayout grid, GameObject brushTarget, BoundsInt position);
        public static IEnumerable<Vector2Int> GetPointsOnLine(Vector2Int startPos, Vector2Int endPos, bool fillGaps);
        [IteratorStateMachine(typeof(<GetPointsOnLine>d__11))]
        public static IEnumerable<Vector2Int> GetPointsOnLine(Vector2Int p1, Vector2Int p2);
    }
}
using UnityEngine;

namespace UnityEditor.Tilemaps
{
    [CustomEditor(typeof(LineBrush))]
    public class LineBrushEditor : GridBrushEditor
    {
        public LineBrushEditor();

        public override void OnPaintSceneGUI(GridLayout grid, GameObject brushTarget, BoundsInt position, GridBrushBase.Tool tool, bool executing);
        public override void ClearPreview();
    }
}
using System.Collections.Generic;
using UnityEngine;

namespace UnityEditor.Tilemaps
{
    public class BasePrefabBrush : GridBrush
    {
        public Vector3 m_Anchor;

        public BasePrefabBrush();

        protected List<GameObject> GetObjectsInCell(GridLayout grid, Transform parent, Vector3Int position);
        protected void InstantiatePrefabInCell(GridLayout grid, GameObject brushTarget, Vector3Int position, GameObject prefab, Quaternion rotation = null);
    }
}
namespace UnityEditor.Tilemaps
{
    public class BasePrefabBrushEditor : GridBrushEditor
    {
        protected SerializedObject m_SerializedObject;

        public BasePrefabBrushEditor();

        protected override void OnEnable();
        public override void OnPaintInspectorGUI();
    }
}
using UnityEngine;

namespace UnityEditor.Tilemaps
{
    [CreateAssetMenu(fileName = "New Prefab Brush", menuName = "2D/Brushes/Prefab Brush", order = 84)]
    [CustomGridBrush(False, True, False, "Prefab Brush")]
    public class PrefabBrush : BasePrefabBrush
    {
        public PrefabBrush();

        public override void Rotate(GridBrushBase.RotationDirection direction, GridLayout.CellLayout layout);
        public override void Paint(GridLayout grid, GameObject brushTarget, Vector3Int position);
        public override void BoxFill(GridLayout grid, GameObject brushTarget, BoundsInt bounds);
        public override void Erase(GridLayout grid, GameObject brushTarget, Vector3Int position);

        [CustomEditor(typeof(PrefabBrush))]
        public class PrefabBrushEditor : BasePrefabBrushEditor
        {
            public PrefabBrushEditor();

            protected override void OnEnable();
            public override void OnPaintInspectorGUI();
        }
    }
}
using UnityEngine;

namespace UnityEditor.Tilemaps
{
    [CreateAssetMenu(fileName = "New Prefab Random Brush", menuName = "2D/Brushes/Prefab Random Brush", order = 84)]
    [CustomGridBrush(False, True, False, "Prefab Random Brush")]
    public class PrefabRandomBrush : BasePrefabBrush
    {
        public PrefabRandomBrush();

        public override void Paint(GridLayout grid, GameObject brushTarget, Vector3Int position);
        public override void Erase(GridLayout grid, GameObject brushTarget, Vector3Int position);

        [CustomEditor(typeof(PrefabRandomBrush))]
        public class PrefabRandomBrushEditor : BasePrefabBrushEditor
        {
            public PrefabRandomBrushEditor();

            protected override void OnEnable();
            public override void OnPaintInspectorGUI();
        }
    }
}
using UnityEngine;
using UnityEngine.Tilemaps;

namespace UnityEditor.Tilemaps
{
    [HelpURL("https://docs.unity3d.com/Packages/com.unity.2d.tilemap.extras@latest/index.html?subfolder=/manual/RandomBrush.html")]
    [CustomGridBrush(False, False, False, "Random Brush")]
    [CreateAssetMenu(fileName = "New Random Brush", menuName = "2D/Brushes/Random Brush", order = 84)]
    public class RandomBrush : GridBrush
    {
        public Vector3Int randomTileSetSize;
        public RandomTileSet[] randomTileSets;
        public bool pickRandomTiles;
        public bool addToRandomTiles;

        public RandomBrush();

        public override void Paint(GridLayout grid, GameObject brushTarget, Vector3Int position);
        public override void Pick(GridLayout gridLayout, GameObject brushTarget, BoundsInt bounds, Vector3Int pickStart);

        public struct RandomTileSet
        {
            public TileBase[] randomTiles;
        }
    }
}
using UnityEngine;

namespace UnityEditor.Tilemaps
{
    [CustomEditor(typeof(RandomBrush))]
    public class RandomBrushEditor : GridBrushEditor
    {
        public RandomBrushEditor();

        public override void PaintPreview(GridLayout grid, GameObject brushTarget, Vector3Int position);
        public override void ClearPreview();
        public override void OnPaintInspectorGUI();
    }
}
using UnityEngine;

namespace UnityEditor.Tilemaps
{
    [CustomGridBrush(True, False, False, "Tint Brush")]
    public class TintBrush : GridBrushBase
    {
        public Color m_Color;

        public TintBrush();

        public override void Paint(GridLayout grid, GameObject brushTarget, Vector3Int position);
        public override void Erase(GridLayout grid, GameObject brushTarget, Vector3Int position);
    }
}
using UnityEngine;

namespace UnityEditor.Tilemaps
{
    [CustomEditor(typeof(TintBrush))]
    public class TintBrushEditor : GridBrushEditorBase
    {
        public TintBrushEditor();

        public override GameObject[] validTargets { get; }
    }
}
using UnityEngine;

namespace UnityEditor.Tilemaps
{
    [CustomGridBrush(False, False, False, "Tint Brush (Smooth)")]
    public class TintBrushSmooth : GridBrushBase
    {
        public float m_Blend;
        public Color m_Color;

        public TintBrushSmooth();

        public override void Paint(GridLayout grid, GameObject brushTarget, Vector3Int position);
        public override void Erase(GridLayout grid, GameObject brushTarget, Vector3Int position);
        public override void Pick(GridLayout grid, GameObject brushTarget, BoundsInt position, Vector3Int pivot);
    }
}
using UnityEngine;

namespace UnityEditor.Tilemaps
{
    [CustomEditor(typeof(TintBrushSmooth))]
    public class TintBrushSmoothEditor : GridBrushEditorBase
    {
        public TintBrushSmoothEditor();

        public TintBrushSmooth brush { get; }
        public override GameObject[] validTargets { get; }

        public override void OnPaintInspectorGUI();
    }
}
using UnityEngine;
using UnityEngine.Scripting.APIUpdating;
using UnityEngine.Tilemaps;

namespace UnityEditor.Tilemaps
{
    [MovedFrom(True, "UnityEditor", null, null)]
    public class PopulateRuleOverideTileWizard : ScriptableWizard
    {
        public Texture2D m_spriteSet;

        public PopulateRuleOverideTileWizard();

        public static void CreateWizard(RuleOverrideTile target);
        public static void CloneWizard(PopulateRuleOverideTileWizard oldWizard);
    }
}
-------- {Unity.RenderPipelines.Core.ShaderLibrary(D:\Documents\GitHub\Rogue-like-game-i-guess\The game is liar\Library\ScriptAssemblies\Unity.RenderPipelines.Core.ShaderLibrary.dll)}:    0 --------
-------- {UnityEngine.UI(D:\Documents\GitHub\Rogue-like-game-i-guess\The game is liar\Library\ScriptAssemblies\UnityEngine.UI.dll)}:  195 --------
namespace UnityEngine.UI
{
    public class AnimationTriggers
    {
        public AnimationTriggers();

        public string normalTrigger { get; set; }
        public string highlightedTrigger { get; set; }
        public string pressedTrigger { get; set; }
        public string selectedTrigger { get; set; }
        public string disabledTrigger { get; set; }
    }
}
using UnityEngine.Events;
using UnityEngine.EventSystems;

namespace UnityEngine.UI
{
    [AddComponentMenu("UI/Button", 30)]
    public class Button : Selectable, ISubmitHandler, IPointerClickHandler
    {
        protected Button();

        public ButtonClickedEvent onClick { get; set; }

        public virtual void OnPointerClick(PointerEventData eventData);
        public virtual void OnSubmit(BaseEventData eventData);

        public class ButtonClickedEvent : UnityEvent
        {
            public ButtonClickedEvent();
        }
    }
}
namespace UnityEngine.UI
{
    public enum CanvasUpdate
    {
        Prelayout = 0,
        Layout = 1,
        PostLayout = 2,
        PreRender = 3,
        LatePreRender = 4,
        MaxUpdateValue = 5
    }
}
namespace UnityEngine.UI
{
    public interface ICanvasElement
    {
        Transform transform { get; }

        void Rebuild(CanvasUpdate executing);
        void LayoutComplete();
        void GraphicUpdateComplete();
        bool IsDestroyed();
    }
}
namespace UnityEngine.UI
{
    public class CanvasUpdateRegistry
    {
        protected CanvasUpdateRegistry();

        public static CanvasUpdateRegistry instance { get; }

        public static void RegisterCanvasElementForLayoutRebuild(ICanvasElement element);
        public static bool TryRegisterCanvasElementForLayoutRebuild(ICanvasElement element);
        public static void RegisterCanvasElementForGraphicRebuild(ICanvasElement element);
        public static bool TryRegisterCanvasElementForGraphicRebuild(ICanvasElement element);
        public static void UnRegisterCanvasElementForRebuild(ICanvasElement element);
        public static bool IsRebuildingLayout();
        public static bool IsRebuildingGraphics();
    }
}
using System;

namespace UnityEngine.UI
{
    public struct ColorBlock : IEquatable<ColorBlock>
    {
        public static ColorBlock defaultColorBlock;

        public Color normalColor { get; set; }
        public Color highlightedColor { get; set; }
        public Color pressedColor { get; set; }
        public Color selectedColor { get; set; }
        public Color disabledColor { get; set; }
        public float colorMultiplier { get; set; }
        public float fadeDuration { get; set; }

        public override bool Equals(object obj);
        public bool Equals(ColorBlock other);
        public override int GetHashCode();

        public static bool operator ==(ColorBlock point1, ColorBlock point2);
        public static bool operator !=(ColorBlock point1, ColorBlock point2);
    }
}
namespace UnityEngine.UI
{
    public class ClipperRegistry
    {
        protected ClipperRegistry();

        public static ClipperRegistry instance { get; }

        public void Cull();
        public static void Register(IClipper c);
        public static void Unregister(IClipper c);
    }
}
using System.Collections.Generic;

namespace UnityEngine.UI
{
    public static class Clipping
    {
        public static Rect FindCullAndClipWorldRect(List<RectMask2D> rectMaskParents, out bool validRect);
    }
}
namespace UnityEngine.UI
{
    public interface IClipper
    {
        void PerformClipping();
    }
}
namespace UnityEngine.UI
{
    public interface IClippable
    {
        GameObject gameObject { get; }
        RectTransform rectTransform { get; }

        void RecalculateClipping();
        void Cull(Rect clipRect, bool validRect);
        void SetClipRect(Rect value, bool validRect);
        void SetClipSoftness(Vector2 clipSoftness);
    }
}
using System;

namespace UnityEngine.UI
{
    public static class DefaultControls
    {
        public static IFactoryControls factory { get; set; }

        public static GameObject CreatePanel(Resources resources);
        public static GameObject CreateButton(Resources resources);
        public static GameObject CreateText(Resources resources);
        public static GameObject CreateImage(Resources resources);
        public static GameObject CreateRawImage(Resources resources);
        public static GameObject CreateSlider(Resources resources);
        public static GameObject CreateScrollbar(Resources resources);
        public static GameObject CreateToggle(Resources resources);
        public static GameObject CreateInputField(Resources resources);
        public static GameObject CreateDropdown(Resources resources);
        public static GameObject CreateScrollView(Resources resources);

        public interface IFactoryControls
        {
            GameObject CreateGameObject(string name, params Type[] components);
        }
        public struct Resources
        {
            public Sprite standard;
            public Sprite background;
            public Sprite inputField;
            public Sprite knob;
            public Sprite checkmark;
            public Sprite dropdown;
            public Sprite mask;
        }
    }
}
using System.Collections.Generic;
using UnityEngine.Events;
using UnityEngine.EventSystems;

namespace UnityEngine.UI
{
    [AddComponentMenu("UI/Dropdown", 35)]
    [RequireComponent(typeof(RectTransform))]
    public class Dropdown : Selectable, ISubmitHandler, IPointerClickHandler, ICancelHandler
    {
        protected Dropdown();

        public RectTransform template { get; set; }
        public Text captionText { get; set; }
        public Image captionImage { get; set; }
        public Text itemText { get; set; }
        public Image itemImage { get; set; }
        public List<OptionData> options { get; set; }
        public DropdownEvent onValueChanged { get; set; }
        public float alphaFadeSpeed { get; set; }
        public int value { get; set; }

        public void SetValueWithoutNotify(int input);
        protected override void Awake();
        protected override void Start();
        protected override void OnValidate();
        protected override void OnDisable();
        public void RefreshShownValue();
        public void AddOptions(List<OptionData> options);
        public void AddOptions(List<string> options);
        public void AddOptions(List<Sprite> options);
        public void ClearOptions();
        public virtual void OnPointerClick(PointerEventData eventData);
        public virtual void OnSubmit(BaseEventData eventData);
        public virtual void OnCancel(BaseEventData eventData);
        public void Show();
        protected virtual GameObject CreateBlocker(Canvas rootCanvas);
        protected virtual void DestroyBlocker(GameObject blocker);
        protected virtual GameObject CreateDropdownList(GameObject template);
        protected virtual void DestroyDropdownList(GameObject dropdownList);
        protected virtual DropdownItem CreateItem(DropdownItem itemTemplate);
        protected virtual void DestroyItem(DropdownItem item);
        public void Hide();

        protected internal class DropdownItem : MonoBehaviour, IEventSystemHandler, IPointerEnterHandler, ICancelHandler
        {
            public DropdownItem();

            public Text text { get; set; }
            public Image image { get; set; }
            public RectTransform rectTransform { get; set; }
            public Toggle toggle { get; set; }

            public virtual void OnPointerEnter(PointerEventData eventData);
            public virtual void OnCancel(BaseEventData eventData);
        }
        public class OptionData
        {
            public OptionData();
            public OptionData(string text);
            public OptionData(Sprite image);
            public OptionData(string text, Sprite image);

            public string text { get; set; }
            public Sprite image { get; set; }
        }
        public class OptionDataList
        {
            public OptionDataList();

            public List<OptionData> options { get; set; }
        }
        public class DropdownEvent : UnityEvent<int>
        {
            public DropdownEvent();
        }
    }
}
namespace UnityEngine.UI
{
    public class FontData : ISerializationCallbackReceiver
    {
        public FontData();

        public static FontData defaultFontData { get; }
        public Font font { get; set; }
        public int fontSize { get; set; }
        public FontStyle fontStyle { get; set; }
        public bool bestFit { get; set; }
        public int minSize { get; set; }
        public int maxSize { get; set; }
        public TextAnchor alignment { get; set; }
        public bool alignByGeometry { get; set; }
        public bool richText { get; set; }
        public HorizontalWrapMode horizontalOverflow { get; set; }
        public VerticalWrapMode verticalOverflow { get; set; }
        public float lineSpacing { get; set; }
    }
}
namespace UnityEngine.UI
{
    public static class FontUpdateTracker
    {
        public static void TrackText(Text t);
        public static void UntrackText(Text t);
    }
}
using System;
using System.Collections.Generic;
using System.ComponentModel;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.Serialization;

namespace UnityEngine.UI
{
    [DisallowMultipleComponent]
    [RequireComponent(typeof(RectTransform))]
    [ExecuteAlways]
    public abstract class Graphic : UIBehaviour, ICanvasElement
    {
        protected static Material s_DefaultUI;
        protected static Texture2D s_WhiteTexture;
        [FormerlySerializedAs("m_Mat")]
        [SerializeField]
        protected Material m_Material;
        protected bool m_SkipLayoutUpdate;
        protected bool m_SkipMaterialUpdate;
        protected UnityAction m_OnDirtyLayoutCallback;
        protected UnityAction m_OnDirtyVertsCallback;
        protected UnityAction m_OnDirtyMaterialCallback;
        protected static Mesh s_Mesh;
        protected Mesh m_CachedMesh;
        protected Vector2[] m_CachedUvs;

        protected Graphic();

        public static Material defaultGraphicMaterial { get; }
        public virtual Color color { get; set; }
        public virtual bool raycastTarget { get; set; }
        public Vector4 raycastPadding { get; set; }
        protected bool useLegacyMeshGeneration { get; set; }
        public int depth { get; }
        public RectTransform rectTransform { get; }
        public Canvas canvas { get; }
        public CanvasRenderer canvasRenderer { get; }
        public virtual Material defaultMaterial { get; }
        public virtual Material material { get; set; }
        public virtual Material materialForRendering { get; }
        public virtual Texture mainTexture { get; }
        protected static Mesh workerMesh { get; }

        public virtual void SetAllDirty();
        public virtual void SetLayoutDirty();
        public virtual void SetVerticesDirty();
        public virtual void SetMaterialDirty();
        protected override void OnRectTransformDimensionsChange();
        protected override void OnBeforeTransformParentChanged();
        protected override void OnTransformParentChanged();
        protected override void OnEnable();
        protected override void OnDisable();
        protected override void OnDestroy();
        protected override void OnCanvasHierarchyChanged();
        public virtual void OnCullingChanged();
        public virtual void Rebuild(CanvasUpdate update);
        public virtual void LayoutComplete();
        public virtual void GraphicUpdateComplete();
        protected virtual void UpdateMaterial();
        protected virtual void UpdateGeometry();
        [EditorBrowsable(Never)]
        [Obsolete("Use OnPopulateMesh instead.", True)]
        protected virtual void OnFillVBO(List<UIVertex> vbo);
        [Obsolete("Use OnPopulateMesh(VertexHelper vh) instead.", False)]
        protected virtual void OnPopulateMesh(Mesh m);
        protected virtual void OnPopulateMesh(VertexHelper vh);
        public virtual void OnRebuildRequested();
        protected override void Reset();
        protected override void OnDidApplyAnimationProperties();
        public virtual void SetNativeSize();
        public virtual bool Raycast(Vector2 sp, Camera eventCamera);
        protected override void OnValidate();
        public Vector2 PixelAdjustPoint(Vector2 point);
        public Rect GetPixelAdjustedRect();
        public virtual void CrossFadeColor(Color targetColor, float duration, bool ignoreTimeScale, bool useAlpha);
        public virtual void CrossFadeColor(Color targetColor, float duration, bool ignoreTimeScale, bool useAlpha, bool useRGB);
        public virtual void CrossFadeAlpha(float alpha, float duration, bool ignoreTimeScale);
        public void RegisterDirtyLayoutCallback(UnityAction action);
        public void UnregisterDirtyLayoutCallback(UnityAction action);
        public void RegisterDirtyVerticesCallback(UnityAction action);
        public void UnregisterDirtyVerticesCallback(UnityAction action);
        public void RegisterDirtyMaterialCallback(UnityAction action);
        public void UnregisterDirtyMaterialCallback(UnityAction action);
    }
}
using System.Collections.Generic;
using UnityEngine.EventSystems;

namespace UnityEngine.UI
{
    [AddComponentMenu("Event/Graphic Raycaster")]
    [RequireComponent(typeof(Canvas))]
    public class GraphicRaycaster : BaseRaycaster
    {
        protected const int kNoEventMaskSet = -1;
        [SerializeField]
        protected LayerMask m_BlockingMask;

        protected GraphicRaycaster();

        public override int sortOrderPriority { get; }
        public override int renderOrderPriority { get; }
        public bool ignoreReversedGraphics { get; set; }
        public BlockingObjects blockingObjects { get; set; }
        public LayerMask blockingMask { get; set; }
        public override Camera eventCamera { get; }

        public override void Raycast(PointerEventData eventData, List<RaycastResult> resultAppendList);

        public enum BlockingObjects
        {
            None = 0,
            TwoD = 1,
            ThreeD = 2,
            All = 3
        }
    }
}
namespace UnityEngine.UI
{
    public static class GraphicRebuildTracker
    {
        public static void TrackGraphic(Graphic g);
        public static void UnTrackGraphic(Graphic g);
    }
}
using System.Collections.Generic;

namespace UnityEngine.UI
{
    public class GraphicRegistry
    {
        protected GraphicRegistry();

        public static GraphicRegistry instance { get; }

        public static void RegisterGraphicForCanvas(Canvas c, Graphic graphic);
        public static void RegisterRaycastGraphicForCanvas(Canvas c, Graphic graphic);
        public static void UnregisterGraphicForCanvas(Canvas c, Graphic graphic);
        public static void UnregisterRaycastGraphicForCanvas(Canvas c, Graphic graphic);
        public static IList<Graphic> GetGraphicsForCanvas(Canvas canvas);
        public static IList<Graphic> GetRaycastableGraphicsForCanvas(Canvas canvas);
    }
}
using System;
using System.ComponentModel;

namespace UnityEngine.UI
{
    [EditorBrowsable(Never)]
    [Obsolete("Not supported anymore.", True)]
    public interface IMask
    {
        RectTransform rectTransform { get; }

        bool Enabled();
    }
}
namespace UnityEngine.UI
{
    public interface IMaskable
    {
        void RecalculateMasking();
    }
}
using System;

namespace UnityEngine.UI
{
    [RequireComponent(typeof(CanvasRenderer))]
    [AddComponentMenu("UI/Image", 11)]
    public class Image : MaskableGraphic, ICanvasRaycastFilter, ISerializationCallbackReceiver, ILayoutElement
    {
        protected static Material s_ETC1DefaultUI;

        protected Image();

        public Sprite sprite { get; set; }
        public Sprite overrideSprite { get; set; }
        public Type type { get; set; }
        public bool preserveAspect { get; set; }
        public bool fillCenter { get; set; }
        public FillMethod fillMethod { get; set; }
        public float fillAmount { get; set; }
        public bool fillClockwise { get; set; }
        public int fillOrigin { get; set; }
        [Obsolete("eventAlphaThreshold has been deprecated. Use eventMinimumAlphaThreshold instead (UnityUpgradable) -> alphaHitTestMinimumThreshold")]
        public float eventAlphaThreshold { get; set; }
        public float alphaHitTestMinimumThreshold { get; set; }
        public bool useSpriteMesh { get; set; }
        public static Material defaultETC1GraphicMaterial { get; }
        public override Texture mainTexture { get; }
        public bool hasBorder { get; }
        public float pixelsPerUnitMultiplier { get; set; }
        public float pixelsPerUnit { get; }
        protected float multipliedPixelsPerUnit { get; }
        public override Material material { get; set; }
        public virtual float minWidth { get; }
        public virtual float preferredWidth { get; }
        public virtual float flexibleWidth { get; }
        public virtual float minHeight { get; }
        public virtual float preferredHeight { get; }
        public virtual float flexibleHeight { get; }
        public virtual int layoutPriority { get; }

        public void DisableSpriteOptimizations();
        public virtual void OnBeforeSerialize();
        public virtual void OnAfterDeserialize();
        public override void SetNativeSize();
        protected override void OnPopulateMesh(VertexHelper toFill);
        protected override void OnEnable();
        protected override void OnDisable();
        protected override void UpdateMaterial();
        protected override void OnCanvasHierarchyChanged();
        public virtual void CalculateLayoutInputHorizontal();
        public virtual void CalculateLayoutInputVertical();
        public virtual bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera);
        protected override void OnDidApplyAnimationProperties();
        protected override void OnValidate();

        public enum Type
        {
            Simple = 0,
            Sliced = 1,
            Tiled = 2,
            Filled = 3
        }
        public enum FillMethod
        {
            Horizontal = 0,
            Vertical = 1,
            Radial90 = 2,
            Radial180 = 3,
            Radial360 = 4
        }
        public enum OriginHorizontal
        {
            Left = 0,
            Right = 1
        }
        public enum OriginVertical
        {
            Bottom = 0,
            Top = 1
        }
        public enum Origin90
        {
            BottomLeft = 0,
            TopLeft = 1,
            TopRight = 2,
            BottomRight = 3
        }
        public enum Origin180
        {
            Bottom = 0,
            Left = 1,
            Top = 2,
            Right = 3
        }
        public enum Origin360
        {
            Bottom = 0,
            Right = 1,
            Top = 2,
            Left = 3
        }
    }
}
using System;
using System.ComponentModel;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.Serialization;

namespace UnityEngine.UI
{
    [AddComponentMenu("UI/Input Field", 31)]
    public class InputField : Selectable, IDragHandler, IEndDragHandler, ICanvasElement, IUpdateSelectedHandler, ILayoutElement, ISubmitHandler, IPointerClickHandler, IBeginDragHandler
    {
        protected TouchScreenKeyboard m_Keyboard;
        [SerializeField]
        [FormerlySerializedAs("text")]
        protected Text m_TextComponent;
        [SerializeField]
        protected Graphic m_Placeholder;
        [SerializeField]
        [FormerlySerializedAs("mValue")]
        protected string m_Text;
        protected int m_CaretPosition;
        protected int m_CaretSelectPosition;
        protected UIVertex[] m_CursorVerts;
        protected Mesh m_Mesh;
        protected bool m_CaretVisible;
        protected int m_DrawStart;
        protected int m_DrawEnd;

        protected InputField();

        protected Mesh mesh { get; }
        protected TextGenerator cachedInputTextGenerator { get; }
        public bool shouldHideMobileInput { get; set; }
        public virtual bool shouldActivateOnSelect { get; set; }
        public string text { get; set; }
        public bool isFocused { get; }
        public float caretBlinkRate { get; set; }
        public int caretWidth { get; set; }
        public Text textComponent { get; set; }
        public Graphic placeholder { get; set; }
        public Color caretColor { get; set; }
        public bool customCaretColor { get; set; }
        public Color selectionColor { get; set; }
        public SubmitEvent onEndEdit { get; set; }
        [Obsolete("onValueChange has been renamed to onValueChanged")]
        public OnChangeEvent onValueChange { get; set; }
        public OnChangeEvent onValueChanged { get; set; }
        public OnValidateInput onValidateInput { get; set; }
        public int characterLimit { get; set; }
        public ContentType contentType { get; set; }
        public LineType lineType { get; set; }
        public InputType inputType { get; set; }
        public TouchScreenKeyboard touchScreenKeyboard { get; }
        public TouchScreenKeyboardType keyboardType { get; set; }
        public CharacterValidation characterValidation { get; set; }
        public bool readOnly { get; set; }
        public bool multiLine { get; }
        public char asteriskChar { get; set; }
        public bool wasCanceled { get; }
        protected int caretPositionInternal { get; set; }
        protected int caretSelectPositionInternal { get; set; }
        [EditorBrowsable(Never)]
        [Obsolete("caretSelectPosition has been deprecated. Use selectionFocusPosition instead (UnityUpgradable) -> selectionFocusPosition", True)]
        public int caretSelectPosition { get; protected set; }
        public int caretPosition { get; set; }
        public int selectionAnchorPosition { get; set; }
        public int selectionFocusPosition { get; set; }
        public virtual float minWidth { get; }
        public virtual float preferredWidth { get; }
        public virtual float flexibleWidth { get; }
        public virtual float minHeight { get; }
        public virtual float preferredHeight { get; }
        public virtual float flexibleHeight { get; }
        public virtual int layoutPriority { get; }

        public void SetTextWithoutNotify(string input);
        protected void ClampPos(ref int pos);
        protected override void OnValidate();
        protected override void OnEnable();
        protected override void OnDisable();
        protected void OnFocus();
        protected void SelectAll();
        public void MoveTextEnd(bool shift);
        public void MoveTextStart(bool shift);
        protected virtual void LateUpdate();
        [Obsolete("This function is no longer used. Please use RectTransformUtility.ScreenPointToLocalPointInRectangle() instead.")]
        public Vector2 ScreenToLocal(Vector2 screen);
        protected int GetCharacterIndexFromPosition(Vector2 pos);
        public virtual void OnBeginDrag(PointerEventData eventData);
        public virtual void OnDrag(PointerEventData eventData);
        public virtual void OnEndDrag(PointerEventData eventData);
        public override void OnPointerDown(PointerEventData eventData);
        protected EditState KeyPressed(Event evt);
        public void ProcessEvent(Event e);
        public virtual void OnUpdateSelected(BaseEventData eventData);
        protected void SendOnSubmit();
        protected virtual void Append(string input);
        protected virtual void Append(char input);
        protected void UpdateLabel();
        public void ForceLabelUpdate();
        public virtual void Rebuild(CanvasUpdate update);
        public virtual void LayoutComplete();
        public virtual void GraphicUpdateComplete();
        protected char Validate(string text, int pos, char ch);
        public void ActivateInputField();
        public override void OnSelect(BaseEventData eventData);
        public virtual void OnPointerClick(PointerEventData eventData);
        public void DeactivateInputField();
        public override void OnDeselect(BaseEventData eventData);
        public virtual void OnSubmit(BaseEventData eventData);
        protected override void DoStateTransition(Selectable.SelectionState state, bool instant);
        public virtual void CalculateLayoutInputHorizontal();
        public virtual void CalculateLayoutInputVertical();

        public enum ContentType
        {
            Standard = 0,
            Autocorrected = 1,
            IntegerNumber = 2,
            DecimalNumber = 3,
            Alphanumeric = 4,
            Name = 5,
            EmailAddress = 6,
            Password = 7,
            Pin = 8,
            Custom = 9
        }
        public enum InputType
        {
            Standard = 0,
            AutoCorrect = 1,
            Password = 2
        }
        public enum CharacterValidation
        {
            None = 0,
            Integer = 1,
            Decimal = 2,
            Alphanumeric = 3,
            Name = 4,
            EmailAddress = 5
        }
        public enum LineType
        {
            SingleLine = 0,
            MultiLineSubmit = 1,
            MultiLineNewline = 2
        }
        public delegate char OnValidateInput(string text, int charIndex, char addedChar);
        public class SubmitEvent : UnityEvent<string>
        {
            public SubmitEvent();
        }
        public class OnChangeEvent : UnityEvent<string>
        {
            public OnChangeEvent();
        }
        protected enum EditState
        {
            Continue = 0,
            Finish = 1
        }
    }
}
using UnityEngine.EventSystems;

namespace UnityEngine.UI
{
    [AddComponentMenu("Layout/Aspect Ratio Fitter", 142)]
    [ExecuteAlways]
    [RequireComponent(typeof(RectTransform))]
    [DisallowMultipleComponent]
    public class AspectRatioFitter : UIBehaviour, ILayoutSelfController, ILayoutController
    {
        protected AspectRatioFitter();

        public AspectMode aspectMode { get; set; }
        public float aspectRatio { get; set; }

        protected override void OnEnable();
        protected override void Start();
        protected override void OnDisable();
        protected override void OnTransformParentChanged();
        protected virtual void Update();
        protected override void OnRectTransformDimensionsChange();
        public virtual void SetLayoutHorizontal();
        public virtual void SetLayoutVertical();
        protected void SetDirty();
        public bool IsComponentValidOnObject();
        public bool IsAspectModeValid();
        protected override void OnValidate();

        public enum AspectMode
        {
            None = 0,
            WidthControlsHeight = 1,
            HeightControlsWidth = 2,
            FitInParent = 3,
            EnvelopeParent = 4
        }
    }
}
using UnityEngine.EventSystems;

namespace UnityEngine.UI
{
    [RequireComponent(typeof(Canvas))]
    [ExecuteAlways]
    [AddComponentMenu("Layout/Canvas Scaler", 101)]
    [DisallowMultipleComponent]
    public class CanvasScaler : UIBehaviour
    {
        [Tooltip("If a sprite has this 'Pixels Per Unit' setting, then one pixel in the sprite will cover one unit in the UI.")]
        [SerializeField]
        protected float m_ReferencePixelsPerUnit;
        [Tooltip("Scales all UI elements in the Canvas by this factor.")]
        [SerializeField]
        protected float m_ScaleFactor;
        [Tooltip("The resolution the UI layout is designed for. If the screen resolution is larger, the UI will be scaled up, and if it's smaller, the UI will be scaled down. This is done in accordance with the Screen Match Mode.")]
        [SerializeField]
        protected Vector2 m_ReferenceResolution;
        [Tooltip("A mode used to scale the canvas area if the aspect ratio of the current resolution doesn't fit the reference resolution.")]
        [SerializeField]
        protected ScreenMatchMode m_ScreenMatchMode;
        [Tooltip("Determines if the scaling is using the width or height as reference, or a mix in between.")]
        [Range(0, 1)]
        [SerializeField]
        protected float m_MatchWidthOrHeight;
        [Tooltip("The physical unit to specify positions and sizes in.")]
        [SerializeField]
        protected Unit m_PhysicalUnit;
        [Tooltip("The DPI to assume if the screen DPI is not known.")]
        [SerializeField]
        protected float m_FallbackScreenDPI;
        [Tooltip("The pixels per inch to use for sprites that have a 'Pixels Per Unit' setting that matches the 'Reference Pixels Per Unit' setting.")]
        [SerializeField]
        protected float m_DefaultSpriteDPI;
        [Tooltip("The amount of pixels per unit to use for dynamically created bitmaps in the UI, such as Text.")]
        [SerializeField]
        protected float m_DynamicPixelsPerUnit;
        [SerializeField]
        protected bool m_PresetInfoIsWorld;

        protected CanvasScaler();

        public ScaleMode uiScaleMode { get; set; }
        public float referencePixelsPerUnit { get; set; }
        public float scaleFactor { get; set; }
        public Vector2 referenceResolution { get; set; }
        public ScreenMatchMode screenMatchMode { get; set; }
        public float matchWidthOrHeight { get; set; }
        public Unit physicalUnit { get; set; }
        public float fallbackScreenDPI { get; set; }
        public float defaultSpriteDPI { get; set; }
        public float dynamicPixelsPerUnit { get; set; }

        protected override void OnEnable();
        protected override void OnDisable();
        protected virtual void Handle();
        protected virtual void HandleWorldCanvas();
        protected virtual void HandleConstantPixelSize();
        protected virtual void HandleScaleWithScreenSize();
        protected virtual void HandleConstantPhysicalSize();
        protected void SetScaleFactor(float scaleFactor);
        protected void SetReferencePixelsPerUnit(float referencePixelsPerUnit);
        protected override void OnValidate();

        public enum ScaleMode
        {
            ConstantPixelSize = 0,
            ScaleWithScreenSize = 1,
            ConstantPhysicalSize = 2
        }
        public enum ScreenMatchMode
        {
            MatchWidthOrHeight = 0,
            Expand = 1,
            Shrink = 2
        }
        public enum Unit
        {
            Centimeters = 0,
            Millimeters = 1,
            Inches = 2,
            Points = 3,
            Picas = 4
        }
    }
}
using UnityEngine.EventSystems;

namespace UnityEngine.UI
{
    [AddComponentMenu("Layout/Content Size Fitter", 141)]
    [ExecuteAlways]
    [RequireComponent(typeof(RectTransform))]
    public class ContentSizeFitter : UIBehaviour, ILayoutSelfController, ILayoutController
    {
        [SerializeField]
        protected FitMode m_HorizontalFit;
        [SerializeField]
        protected FitMode m_VerticalFit;

        protected ContentSizeFitter();

        public FitMode horizontalFit { get; set; }
        public FitMode verticalFit { get; set; }

        protected override void OnEnable();
        protected override void OnDisable();
        protected override void OnRectTransformDimensionsChange();
        public virtual void SetLayoutHorizontal();
        public virtual void SetLayoutVertical();
        protected void SetDirty();
        protected override void OnValidate();

        public enum FitMode
        {
            Unconstrained = 0,
            MinSize = 1,
            PreferredSize = 2
        }
    }
}
namespace UnityEngine.UI
{
    [AddComponentMenu("Layout/Grid Layout Group", 152)]
    public class GridLayoutGroup : LayoutGroup
    {
        [SerializeField]
        protected Corner m_StartCorner;
        [SerializeField]
        protected Axis m_StartAxis;
        [SerializeField]
        protected Vector2 m_CellSize;
        [SerializeField]
        protected Vector2 m_Spacing;
        [SerializeField]
        protected Constraint m_Constraint;
        [SerializeField]
        protected int m_ConstraintCount;

        protected GridLayoutGroup();

        public Corner startCorner { get; set; }
        public Axis startAxis { get; set; }
        public Vector2 cellSize { get; set; }
        public Vector2 spacing { get; set; }
        public Constraint constraint { get; set; }
        public int constraintCount { get; set; }

        protected override void OnValidate();
        public override void CalculateLayoutInputHorizontal();
        public override void CalculateLayoutInputVertical();
        public override void SetLayoutHorizontal();
        public override void SetLayoutVertical();

        public enum Corner
        {
            UpperLeft = 0,
            UpperRight = 1,
            LowerLeft = 2,
            LowerRight = 3
        }
        public enum Axis
        {
            Horizontal = 0,
            Vertical = 1
        }
        public enum Constraint
        {
            Flexible = 0,
            FixedColumnCount = 1,
            FixedRowCount = 2
        }
    }
}
namespace UnityEngine.UI
{
    [AddComponentMenu("Layout/Horizontal Layout Group", 150)]
    public class HorizontalLayoutGroup : HorizontalOrVerticalLayoutGroup
    {
        protected HorizontalLayoutGroup();

        public override void CalculateLayoutInputHorizontal();
        public override void CalculateLayoutInputVertical();
        public override void SetLayoutHorizontal();
        public override void SetLayoutVertical();
    }
}
namespace UnityEngine.UI
{
    [ExecuteAlways]
    public abstract class HorizontalOrVerticalLayoutGroup : LayoutGroup
    {
        [SerializeField]
        protected float m_Spacing;
        [SerializeField]
        protected bool m_ChildForceExpandWidth;
        [SerializeField]
        protected bool m_ChildForceExpandHeight;
        [SerializeField]
        protected bool m_ChildControlWidth;
        [SerializeField]
        protected bool m_ChildControlHeight;
        [SerializeField]
        protected bool m_ChildScaleWidth;
        [SerializeField]
        protected bool m_ChildScaleHeight;
        [SerializeField]
        protected bool m_ReverseArrangement;

        protected HorizontalOrVerticalLayoutGroup();

        public float spacing { get; set; }
        public bool childForceExpandWidth { get; set; }
        public bool childForceExpandHeight { get; set; }
        public bool childControlWidth { get; set; }
        public bool childControlHeight { get; set; }
        public bool childScaleWidth { get; set; }
        public bool childScaleHeight { get; set; }
        public bool reverseArrangement { get; set; }

        protected void CalcAlongAxis(int axis, bool isVertical);
        protected void SetChildrenAlongAxis(int axis, bool isVertical);
        protected override void Reset();
        protected virtual void Update();
    }
}
namespace UnityEngine.UI
{
    public interface ILayoutElement
    {
        float minWidth { get; }
        float preferredWidth { get; }
        float flexibleWidth { get; }
        float minHeight { get; }
        float preferredHeight { get; }
        float flexibleHeight { get; }
        int layoutPriority { get; }

        void CalculateLayoutInputHorizontal();
        void CalculateLayoutInputVertical();
    }
}
namespace UnityEngine.UI
{
    public interface ILayoutController
    {
        void SetLayoutHorizontal();
        void SetLayoutVertical();
    }
}
namespace UnityEngine.UI
{
    public interface ILayoutGroup : ILayoutController
    {
    }
}
namespace UnityEngine.UI
{
    public interface ILayoutSelfController : ILayoutController
    {
    }
}
namespace UnityEngine.UI
{
    public interface ILayoutIgnorer
    {
        bool ignoreLayout { get; }
    }
}
using UnityEngine.EventSystems;

namespace UnityEngine.UI
{
    [AddComponentMenu("Layout/Layout Element", 140)]
    [RequireComponent(typeof(RectTransform))]
    [ExecuteAlways]
    public class LayoutElement : UIBehaviour, ILayoutIgnorer, ILayoutElement
    {
        protected LayoutElement();

        public virtual bool ignoreLayout { get; set; }
        public virtual float minWidth { get; set; }
        public virtual float minHeight { get; set; }
        public virtual float preferredWidth { get; set; }
        public virtual float preferredHeight { get; set; }
        public virtual float flexibleWidth { get; set; }
        public virtual float flexibleHeight { get; set; }
        public virtual int layoutPriority { get; set; }

        public virtual void CalculateLayoutInputHorizontal();
        public virtual void CalculateLayoutInputVertical();
        protected override void OnEnable();
        protected override void OnTransformParentChanged();
        protected override void OnDisable();
        protected override void OnDidApplyAnimationProperties();
        protected override void OnBeforeTransformParentChanged();
        protected void SetDirty();
        protected override void OnValidate();
    }
}
using System.Collections.Generic;
using UnityEngine.EventSystems;

namespace UnityEngine.UI
{
    [DisallowMultipleComponent]
    [ExecuteAlways]
    [RequireComponent(typeof(RectTransform))]
    public abstract class LayoutGroup : UIBehaviour, ILayoutGroup, ILayoutElement, ILayoutController
    {
        [SerializeField]
        protected RectOffset m_Padding;
        [SerializeField]
        protected TextAnchor m_ChildAlignment;
        protected DrivenRectTransformTracker m_Tracker;

        protected LayoutGroup();

        public RectOffset padding { get; set; }
        public TextAnchor childAlignment { get; set; }
        protected RectTransform rectTransform { get; }
        protected List<RectTransform> rectChildren { get; }
        public virtual float minWidth { get; }
        public virtual float preferredWidth { get; }
        public virtual float flexibleWidth { get; }
        public virtual float minHeight { get; }
        public virtual float preferredHeight { get; }
        public virtual float flexibleHeight { get; }
        public virtual int layoutPriority { get; }

        public virtual void CalculateLayoutInputHorizontal();
        public abstract void CalculateLayoutInputVertical();
        public abstract void SetLayoutHorizontal();
        public abstract void SetLayoutVertical();
        protected override void OnEnable();
        protected override void OnDisable();
        protected override void OnDidApplyAnimationProperties();
        protected float GetTotalMinSize(int axis);
        protected float GetTotalPreferredSize(int axis);
        protected float GetTotalFlexibleSize(int axis);
        protected float GetStartOffset(int axis, float requiredSpaceWithoutPadding);
        protected float GetAlignmentOnAxis(int axis);
        protected void SetLayoutInputForAxis(float totalMin, float totalPreferred, float totalFlexible, int axis);
        protected void SetChildAlongAxis(RectTransform rect, int axis, float pos);
        protected void SetChildAlongAxisWithScale(RectTransform rect, int axis, float pos, float scaleFactor);
        protected void SetChildAlongAxis(RectTransform rect, int axis, float pos, float size);
        protected void SetChildAlongAxisWithScale(RectTransform rect, int axis, float pos, float size, float scaleFactor);
        protected override void OnRectTransformDimensionsChange();
        protected virtual void OnTransformChildrenChanged();
        protected void SetProperty<T>(ref T currentValue, T newValue);
        protected void SetDirty();
        protected override void OnValidate();
    }
}
namespace UnityEngine.UI
{
    public class LayoutRebuilder : ICanvasElement
    {
        public LayoutRebuilder();

        public Transform transform { get; }

        public bool IsDestroyed();
        public static void ForceRebuildLayoutImmediate(RectTransform layoutRoot);
        public void Rebuild(CanvasUpdate executing);
        public static void MarkLayoutForRebuild(RectTransform rect);
        public void LayoutComplete();
        public void GraphicUpdateComplete();
        public override int GetHashCode();
        public override bool Equals(object obj);
        public override string ToString();
    }
}
using System;

namespace UnityEngine.UI
{
    public static class LayoutUtility
    {
        public static float GetMinSize(RectTransform rect, int axis);
        public static float GetPreferredSize(RectTransform rect, int axis);
        public static float GetFlexibleSize(RectTransform rect, int axis);
        public static float GetMinWidth(RectTransform rect);
        public static float GetPreferredWidth(RectTransform rect);
        public static float GetFlexibleWidth(RectTransform rect);
        public static float GetMinHeight(RectTransform rect);
        public static float GetPreferredHeight(RectTransform rect);
        public static float GetFlexibleHeight(RectTransform rect);
        public static float GetLayoutProperty(RectTransform rect, Func<ILayoutElement, float> property, float defaultValue);
        public static float GetLayoutProperty(RectTransform rect, Func<ILayoutElement, float> property, float defaultValue, out ILayoutElement source);
    }
}
namespace UnityEngine.UI
{
    [AddComponentMenu("Layout/Vertical Layout Group", 151)]
    public class VerticalLayoutGroup : HorizontalOrVerticalLayoutGroup
    {
        protected VerticalLayoutGroup();

        public override void CalculateLayoutInputHorizontal();
        public override void CalculateLayoutInputVertical();
        public override void SetLayoutHorizontal();
        public override void SetLayoutVertical();
    }
}
using System;
using UnityEngine.EventSystems;

namespace UnityEngine.UI
{
    [AddComponentMenu("UI/Mask", 13)]
    [ExecuteAlways]
    [RequireComponent(typeof(RectTransform))]
    [DisallowMultipleComponent]
    public class Mask : UIBehaviour, IMaterialModifier, ICanvasRaycastFilter
    {
        protected Mask();

        public RectTransform rectTransform { get; }
        public bool showMaskGraphic { get; set; }
        public Graphic graphic { get; }

        public virtual bool MaskEnabled();
        [Obsolete("Not used anymore.")]
        public virtual void OnSiblingGraphicEnabledDisabled();
        protected override void OnEnable();
        protected override void OnDisable();
        protected override void OnValidate();
        public virtual bool IsRaycastLocationValid(Vector2 sp, Camera eventCamera);
        public virtual Material GetModifiedMaterial(Material baseMaterial);
    }
}
using System.Collections.Generic;

namespace UnityEngine.UI
{
    public class MaskUtilities
    {
        public MaskUtilities();

        public static void Notify2DMaskStateChanged(Component mask);
        public static void NotifyStencilStateChanged(Component mask);
        public static Transform FindRootSortOverrideCanvas(Transform start);
        public static int GetStencilDepth(Transform transform, Transform stopAfter);
        public static bool IsDescendantOrSelf(Transform father, Transform child);
        public static RectMask2D GetRectMaskForClippable(IClippable clippable);
        public static void GetRectMasksForClip(RectMask2D clipper, List<RectMask2D> masks);
    }
}
using System;
using System.ComponentModel;
using UnityEngine.Events;

namespace UnityEngine.UI
{
    public abstract class MaskableGraphic : Graphic, IMaterialModifier, IMaskable, IClippable
    {
        protected bool m_ShouldRecalculateStencil;
        protected Material m_MaskMaterial;
        [EditorBrowsable(Never)]
        [Obsolete("Not used anymore.", True)]
        protected bool m_IncludeForMasking;
        [EditorBrowsable(Never)]
        [Obsolete("Not used anymore", True)]
        protected bool m_ShouldRecalculate;
        protected int m_StencilValue;

        protected MaskableGraphic();

        public CullStateChangedEvent onCullStateChanged { get; set; }
        public bool maskable { get; set; }
        public bool isMaskingGraphic { get; set; }

        public virtual Material GetModifiedMaterial(Material baseMaterial);
        public virtual void Cull(Rect clipRect, bool validRect);
        public virtual void SetClipRect(Rect clipRect, bool validRect);
        public virtual void SetClipSoftness(Vector2 clipSoftness);
        protected override void OnEnable();
        protected override void OnDisable();
        protected override void OnValidate();
        protected override void OnTransformParentChanged();
        [EditorBrowsable(Never)]
        [Obsolete("Not used anymore.", True)]
        public virtual void ParentMaskStateChanged();
        protected override void OnCanvasHierarchyChanged();
        public virtual void RecalculateClipping();
        public virtual void RecalculateMasking();

        public class CullStateChangedEvent : UnityEvent<bool>
        {
            public CullStateChangedEvent();
        }
    }
}
namespace UnityEngine.UI
{
    public interface IMaterialModifier
    {
        Material GetModifiedMaterial(Material baseMaterial);
    }
}
using System;

namespace UnityEngine.UI
{
    public struct Navigation : IEquatable<Navigation>
    {
        public Mode mode { get; set; }
        public bool wrapAround { get; set; }
        public Selectable selectOnUp { get; set; }
        public Selectable selectOnDown { get; set; }
        public Selectable selectOnLeft { get; set; }
        public Selectable selectOnRight { get; set; }
        public static Navigation defaultNavigation { get; }

        public bool Equals(Navigation other);

        [Flags]
        public enum Mode
        {
            None = 0,
            Horizontal = 1,
            Vertical = 2,
            Automatic = 3,
            Explicit = 4
        }
    }
}
namespace UnityEngine.UI
{
    [RequireComponent(typeof(CanvasRenderer))]
    [AddComponentMenu("UI/Raw Image", 12)]
    public class RawImage : MaskableGraphic
    {
        protected RawImage();

        public override Texture mainTexture { get; }
        public Texture texture { get; set; }
        public Rect uvRect { get; set; }

        public override void SetNativeSize();
        protected override void OnPopulateMesh(VertexHelper vh);
        protected override void OnDidApplyAnimationProperties();
    }
}
using UnityEngine.EventSystems;

namespace UnityEngine.UI
{
    [AddComponentMenu("UI/Rect Mask 2D", 13)]
    [ExecuteAlways]
    [DisallowMultipleComponent]
    [RequireComponent(typeof(RectTransform))]
    public class RectMask2D : UIBehaviour, ICanvasRaycastFilter, IClipper
    {
        protected RectMask2D();

        public Vector4 padding { get; set; }
        public Vector2Int softness { get; set; }
        public Rect canvasRect { get; }
        public RectTransform rectTransform { get; }

        protected override void OnEnable();
        protected override void OnDisable();
        protected override void OnValidate();
        public virtual bool IsRaycastLocationValid(Vector2 sp, Camera eventCamera);
        public virtual void PerformClipping();
        public virtual void UpdateClipSoftness();
        public void AddClippable(IClippable clippable);
        public void RemoveClippable(IClippable clippable);
        protected override void OnTransformParentChanged();
        protected override void OnCanvasHierarchyChanged();
    }
}
using UnityEngine.Events;
using UnityEngine.EventSystems;

namespace UnityEngine.UI
{
    [AddComponentMenu("UI/Scroll Rect", 37)]
    [SelectionBase]
    [ExecuteAlways]
    [DisallowMultipleComponent]
    [RequireComponent(typeof(RectTransform))]
    public class ScrollRect : UIBehaviour, ILayoutGroup, IInitializePotentialDragHandler, IDragHandler, IEndDragHandler, ICanvasElement, IScrollHandler, IEventSystemHandler, ILayoutElement, ILayoutController, IBeginDragHandler
    {
        protected Vector2 m_ContentStartPosition;
        protected Bounds m_ContentBounds;

        protected ScrollRect();

        public RectTransform content { get; set; }
        public bool horizontal { get; set; }
        public bool vertical { get; set; }
        public MovementType movementType { get; set; }
        public float elasticity { get; set; }
        public bool inertia { get; set; }
        public float decelerationRate { get; set; }
        public float scrollSensitivity { get; set; }
        public RectTransform viewport { get; set; }
        public Scrollbar horizontalScrollbar { get; set; }
        public Scrollbar verticalScrollbar { get; set; }
        public ScrollbarVisibility horizontalScrollbarVisibility { get; set; }
        public ScrollbarVisibility verticalScrollbarVisibility { get; set; }
        public float horizontalScrollbarSpacing { get; set; }
        public float verticalScrollbarSpacing { get; set; }
        public ScrollRectEvent onValueChanged { get; set; }
        protected RectTransform viewRect { get; }
        public Vector2 velocity { get; set; }
        public Vector2 normalizedPosition { get; set; }
        public float horizontalNormalizedPosition { get; set; }
        public float verticalNormalizedPosition { get; set; }
        public virtual float minWidth { get; }
        public virtual float preferredWidth { get; }
        public virtual float flexibleWidth { get; }
        public virtual float minHeight { get; }
        public virtual float preferredHeight { get; }
        public virtual float flexibleHeight { get; }
        public virtual int layoutPriority { get; }

        public virtual void Rebuild(CanvasUpdate executing);
        public virtual void LayoutComplete();
        public virtual void GraphicUpdateComplete();
        protected override void OnEnable();
        protected override void OnDisable();
        public override bool IsActive();
        public virtual void StopMovement();
        public virtual void OnScroll(PointerEventData data);
        public virtual void OnInitializePotentialDrag(PointerEventData eventData);
        public virtual void OnBeginDrag(PointerEventData eventData);
        public virtual void OnEndDrag(PointerEventData eventData);
        public virtual void OnDrag(PointerEventData eventData);
        protected virtual void SetContentAnchoredPosition(Vector2 position);
        protected virtual void LateUpdate();
        protected void UpdatePrevData();
        protected virtual void SetNormalizedPosition(float value, int axis);
        protected override void OnRectTransformDimensionsChange();
        public virtual void CalculateLayoutInputHorizontal();
        public virtual void CalculateLayoutInputVertical();
        public virtual void SetLayoutHorizontal();
        public virtual void SetLayoutVertical();
        protected void UpdateBounds();
        protected void SetDirty();
        protected void SetDirtyCaching();
        protected override void OnValidate();

        public enum MovementType
        {
            Unrestricted = 0,
            Elastic = 1,
            Clamped = 2
        }
        public enum ScrollbarVisibility
        {
            Permanent = 0,
            AutoHide = 1,
            AutoHideAndExpandViewport = 2
        }
        public class ScrollRectEvent : UnityEvent<Vector2>
        {
            public ScrollRectEvent();
        }
    }
}
using System.Collections;
using System.Runtime.CompilerServices;
using UnityEngine.Events;
using UnityEngine.EventSystems;

namespace UnityEngine.UI
{
    [AddComponentMenu("UI/Scrollbar", 34)]
    [ExecuteAlways]
    [RequireComponent(typeof(RectTransform))]
    public class Scrollbar : Selectable, IInitializePotentialDragHandler, IDragHandler, ICanvasElement, IBeginDragHandler
    {
        protected Scrollbar();

        public RectTransform handleRect { get; set; }
        public Direction direction { get; set; }
        public float value { get; set; }
        public float size { get; set; }
        public int numberOfSteps { get; set; }
        public ScrollEvent onValueChanged { get; set; }

        public virtual void SetValueWithoutNotify(float input);
        protected override void OnValidate();
        public virtual void Rebuild(CanvasUpdate executing);
        public virtual void LayoutComplete();
        public virtual void GraphicUpdateComplete();
        protected override void OnEnable();
        protected override void OnDisable();
        protected virtual void Update();
        protected override void OnRectTransformDimensionsChange();
        public virtual void OnBeginDrag(PointerEventData eventData);
        public virtual void OnDrag(PointerEventData eventData);
        public override void OnPointerDown(PointerEventData eventData);
        protected IEnumerator ClickRepeat(PointerEventData eventData);
        [IteratorStateMachine(typeof(<ClickRepeat>d__59))]
        protected IEnumerator ClickRepeat(Vector2 screenPosition, Camera camera);
        public override void OnPointerUp(PointerEventData eventData);
        public override void OnMove(AxisEventData eventData);
        public override Selectable FindSelectableOnLeft();
        public override Selectable FindSelectableOnRight();
        public override Selectable FindSelectableOnUp();
        public override Selectable FindSelectableOnDown();
        public virtual void OnInitializePotentialDrag(PointerEventData eventData);
        public void SetDirection(Direction direction, bool includeRectLayouts);

        public enum Direction
        {
            LeftToRight = 0,
            RightToLeft = 1,
            BottomToTop = 2,
            TopToBottom = 3
        }
        public class ScrollEvent : UnityEvent<float>
        {
            public ScrollEvent();
        }
    }
}
using System;
using System.Collections.Generic;
using UnityEngine.EventSystems;

namespace UnityEngine.UI
{
    [AddComponentMenu("UI/Selectable", 70)]
    [ExecuteAlways]
    [SelectionBase]
    [DisallowMultipleComponent]
    public class Selectable : UIBehaviour, IEventSystemHandler, IPointerEnterHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IPointerUpHandler, IMoveHandler
    {
        protected static Selectable[] s_Selectables;
        protected static int s_SelectableCount;
        protected int m_CurrentIndex;

        protected Selectable();

        public static Selectable[] allSelectablesArray { get; }
        public static int allSelectableCount { get; }
        [Obsolete("Replaced with allSelectablesArray to have better performance when disabling a element", False)]
        public static List<Selectable> allSelectables { get; }
        public Navigation navigation { get; set; }
        public Transition transition { get; set; }
        public ColorBlock colors { get; set; }
        public SpriteState spriteState { get; set; }
        public AnimationTriggers animationTriggers { get; set; }
        public Graphic targetGraphic { get; set; }
        public bool interactable { get; set; }
        public Image image { get; set; }
        public Animator animator { get; }
        protected SelectionState currentSelectionState { get; }

        public static int AllSelectablesNoAlloc(Selectable[] selectables);
        protected override void Awake();
        protected override void OnCanvasGroupChanged();
        public virtual bool IsInteractable();
        protected override void OnDidApplyAnimationProperties();
        protected override void OnEnable();
        protected override void OnTransformParentChanged();
        protected override void OnDisable();
        protected override void OnValidate();
        protected override void Reset();
        protected virtual void InstantClearState();
        protected virtual void DoStateTransition(SelectionState state, bool instant);
        public Selectable FindSelectable(Vector3 dir);
        public virtual Selectable FindSelectableOnLeft();
        public virtual Selectable FindSelectableOnRight();
        public virtual Selectable FindSelectableOnUp();
        public virtual Selectable FindSelectableOnDown();
        public virtual void OnMove(AxisEventData eventData);
        protected bool IsHighlighted();
        protected bool IsPressed();
        public virtual void OnPointerDown(PointerEventData eventData);
        public virtual void OnPointerUp(PointerEventData eventData);
        public virtual void OnPointerEnter(PointerEventData eventData);
        public virtual void OnPointerExit(PointerEventData eventData);
        public virtual void OnSelect(BaseEventData eventData);
        public virtual void OnDeselect(BaseEventData eventData);
        public virtual void Select();

        public enum Transition
        {
            None = 0,
            ColorTint = 1,
            SpriteSwap = 2,
            Animation = 3
        }
        protected enum SelectionState
        {
            Normal = 0,
            Highlighted = 1,
            Pressed = 2,
            Selected = 3,
            Disabled = 4
        }
    }
}
using UnityEngine.Events;
using UnityEngine.EventSystems;

namespace UnityEngine.UI
{
    [AddComponentMenu("UI/Slider", 33)]
    [ExecuteAlways]
    [RequireComponent(typeof(RectTransform))]
    public class Slider : Selectable, IInitializePotentialDragHandler, IDragHandler, ICanvasElement
    {
        [SerializeField]
        protected float m_Value;

        protected Slider();

        public RectTransform fillRect { get; set; }
        public RectTransform handleRect { get; set; }
        public Direction direction { get; set; }
        public float minValue { get; set; }
        public float maxValue { get; set; }
        public bool wholeNumbers { get; set; }
        public virtual float value { get; set; }
        public float normalizedValue { get; set; }
        public SliderEvent onValueChanged { get; set; }

        public virtual void SetValueWithoutNotify(float input);
        protected override void OnValidate();
        public virtual void Rebuild(CanvasUpdate executing);
        public virtual void LayoutComplete();
        public virtual void GraphicUpdateComplete();
        protected override void OnEnable();
        protected override void OnDisable();
        protected virtual void Update();
        protected override void OnDidApplyAnimationProperties();
        protected virtual void Set(float input, bool sendCallback = True);
        protected override void OnRectTransformDimensionsChange();
        public override void OnPointerDown(PointerEventData eventData);
        public virtual void OnDrag(PointerEventData eventData);
        public override void OnMove(AxisEventData eventData);
        public override Selectable FindSelectableOnLeft();
        public override Selectable FindSelectableOnRight();
        public override Selectable FindSelectableOnUp();
        public override Selectable FindSelectableOnDown();
        public virtual void OnInitializePotentialDrag(PointerEventData eventData);
        public void SetDirection(Direction direction, bool includeRectLayouts);

        public enum Direction
        {
            LeftToRight = 0,
            RightToLeft = 1,
            BottomToTop = 2,
            TopToBottom = 3
        }
        public class SliderEvent : UnityEvent<float>
        {
            public SliderEvent();
        }
    }
}
using System;

namespace UnityEngine.UI
{
    public struct SpriteState : IEquatable<SpriteState>
    {
        public Sprite highlightedSprite { get; set; }
        public Sprite pressedSprite { get; set; }
        public Sprite selectedSprite { get; set; }
        public Sprite disabledSprite { get; set; }

        public bool Equals(SpriteState other);
    }
}
using System;
using System.ComponentModel;
using UnityEngine.Rendering;

namespace UnityEngine.UI
{
    public static class StencilMaterial
    {
        [EditorBrowsable(Never)]
        [Obsolete("Use Material.Add instead.", True)]
        public static Material Add(Material baseMat, int stencilID);
        public static Material Add(Material baseMat, int stencilID, StencilOp operation, CompareFunction compareFunction, ColorWriteMask colorWriteMask);
        public static Material Add(Material baseMat, int stencilID, StencilOp operation, CompareFunction compareFunction, ColorWriteMask colorWriteMask, int readMask, int writeMask);
        public static void Remove(Material customMat);
        public static void ClearAll();
    }
}
namespace UnityEngine.UI
{
    [RequireComponent(typeof(CanvasRenderer))]
    [AddComponentMenu("UI/Text", 10)]
    public class Text : MaskableGraphic, ILayoutElement
    {
        [TextArea(3, 10)]
        [SerializeField]
        protected string m_Text;
        protected static Material s_DefaultText;
        protected bool m_DisableFontTextureRebuiltCallback;

        protected Text();

        public TextGenerator cachedTextGenerator { get; }
        public TextGenerator cachedTextGeneratorForLayout { get; }
        public override Texture mainTexture { get; }
        public Font font { get; set; }
        public virtual string text { get; set; }
        public bool supportRichText { get; set; }
        public bool resizeTextForBestFit { get; set; }
        public int resizeTextMinSize { get; set; }
        public int resizeTextMaxSize { get; set; }
        public TextAnchor alignment { get; set; }
        public bool alignByGeometry { get; set; }
        public int fontSize { get; set; }
        public HorizontalWrapMode horizontalOverflow { get; set; }
        public VerticalWrapMode verticalOverflow { get; set; }
        public float lineSpacing { get; set; }
        public FontStyle fontStyle { get; set; }
        public float pixelsPerUnit { get; }
        public virtual float minWidth { get; }
        public virtual float preferredWidth { get; }
        public virtual float flexibleWidth { get; }
        public virtual float minHeight { get; }
        public virtual float preferredHeight { get; }
        public virtual float flexibleHeight { get; }
        public virtual int layoutPriority { get; }

        public void FontTextureChanged();
        protected override void OnEnable();
        protected override void OnDisable();
        protected override void UpdateGeometry();
        protected override void Reset();
        public TextGenerationSettings GetGenerationSettings(Vector2 extents);
        public static Vector2 GetTextAnchorPivot(TextAnchor anchor);
        protected override void OnPopulateMesh(VertexHelper toFill);
        public virtual void CalculateLayoutInputHorizontal();
        public virtual void CalculateLayoutInputVertical();
        public override void OnRebuildRequested();
        protected override void OnValidate();
    }
}
using UnityEngine.Events;
using UnityEngine.EventSystems;

namespace UnityEngine.UI
{
    [AddComponentMenu("UI/Toggle", 31)]
    [RequireComponent(typeof(RectTransform))]
    public class Toggle : Selectable, ICanvasElement, ISubmitHandler, IPointerClickHandler
    {
        public ToggleTransition toggleTransition;
        public Graphic graphic;
        public ToggleEvent onValueChanged;

        protected Toggle();

        public ToggleGroup group { get; set; }
        public bool isOn { get; set; }

        protected override void OnValidate();
        public virtual void Rebuild(CanvasUpdate executing);
        public virtual void LayoutComplete();
        public virtual void GraphicUpdateComplete();
        protected override void OnDestroy();
        protected override void OnEnable();
        protected override void OnDisable();
        protected override void OnDidApplyAnimationProperties();
        public void SetIsOnWithoutNotify(bool value);
        protected override void Start();
        public virtual void OnPointerClick(PointerEventData eventData);
        public virtual void OnSubmit(BaseEventData eventData);

        public enum ToggleTransition
        {
            None = 0,
            Fade = 1
        }
        public class ToggleEvent : UnityEvent<bool>
        {
            public ToggleEvent();
        }
    }
}
using System.Collections.Generic;
using UnityEngine.EventSystems;

namespace UnityEngine.UI
{
    [AddComponentMenu("UI/Toggle Group", 32)]
    [DisallowMultipleComponent]
    public class ToggleGroup : UIBehaviour
    {
        protected List<Toggle> m_Toggles;

        protected ToggleGroup();

        public bool allowSwitchOff { get; set; }

        protected override void Start();
        protected override void OnEnable();
        public void NotifyToggleOn(Toggle toggle, bool sendCallback = True);
        public void UnregisterToggle(Toggle toggle);
        public void RegisterToggle(Toggle toggle);
        public void EnsureValidState();
        public bool AnyTogglesOn();
        public IEnumerable<Toggle> ActiveToggles();
        public Toggle GetFirstActiveToggle();
        public void SetAllTogglesOff(bool sendCallback = True);
    }
}
using System;
using System.Collections.Generic;

namespace UnityEngine.UI
{
    public class VertexHelper : IDisposable
    {
        public VertexHelper();
        public VertexHelper(Mesh m);

        public int currentVertCount { get; }
        public int currentIndexCount { get; }

        public void Dispose();
        public void Clear();
        public void PopulateUIVertex(ref UIVertex vertex, int i);
        public void SetUIVertex(UIVertex vertex, int i);
        public void FillMesh(Mesh mesh);
        public void AddVert(Vector3 position, Color32 color, Vector4 uv0, Vector4 uv1, Vector4 uv2, Vector4 uv3, Vector3 normal, Vector4 tangent);
        public void AddVert(Vector3 position, Color32 color, Vector4 uv0, Vector4 uv1, Vector3 normal, Vector4 tangent);
        public void AddVert(Vector3 position, Color32 color, Vector4 uv0);
        public void AddVert(UIVertex v);
        public void AddTriangle(int idx0, int idx1, int idx2);
        public void AddUIVertexQuad(UIVertex[] verts);
        public void AddUIVertexStream(List<UIVertex> verts, List<int> indices);
        public void AddUIVertexTriangleStream(List<UIVertex> verts);
        public void GetUIVertexStream(List<UIVertex> stream);
    }
}
using System;
using System.Collections.Generic;
using System.ComponentModel;

namespace UnityEngine.UI
{
    [Obsolete("Use BaseMeshEffect instead", True)]
    public abstract class BaseVertexEffect
    {
        protected BaseVertexEffect();

        [EditorBrowsable(Never)]
        [Obsolete("Use BaseMeshEffect.ModifyMeshes instead", True)]
        public abstract void ModifyVertices(List<UIVertex> vertices);
    }
}
using UnityEngine.EventSystems;

namespace UnityEngine.UI
{
    [ExecuteAlways]
    public abstract class BaseMeshEffect : UIBehaviour, IMeshModifier
    {
        protected BaseMeshEffect();

        protected Graphic graphic { get; }

        protected override void OnEnable();
        protected override void OnDisable();
        protected override void OnDidApplyAnimationProperties();
        protected override void OnValidate();
        public virtual void ModifyMesh(Mesh mesh);
        public abstract void ModifyMesh(VertexHelper vh);
    }
}
using System;
using System.Collections.Generic;
using System.ComponentModel;

namespace UnityEngine.UI
{
    [EditorBrowsable(Never)]
    [Obsolete("Use IMeshModifier instead", True)]
    public interface IVertexModifier
    {
        [EditorBrowsable(Never)]
        [Obsolete("use IMeshModifier.ModifyMesh (VertexHelper verts)  instead", True)]
        void ModifyVertices(List<UIVertex> verts);
    }
}
using System;

namespace UnityEngine.UI
{
    public interface IMeshModifier
    {
        [Obsolete("use IMeshModifier.ModifyMesh (VertexHelper verts) instead", False)]
        void ModifyMesh(Mesh mesh);
        void ModifyMesh(VertexHelper verts);
    }
}
namespace UnityEngine.UI
{
    [AddComponentMenu("UI/Effects/Outline", 15)]
    public class Outline : Shadow
    {
        protected Outline();

        public override void ModifyMesh(VertexHelper vh);
    }
}
namespace UnityEngine.UI
{
    [AddComponentMenu("UI/Effects/Position As UV1", 16)]
    public class PositionAsUV1 : BaseMeshEffect
    {
        protected PositionAsUV1();

        public override void ModifyMesh(VertexHelper vh);
    }
}
using System.Collections.Generic;

namespace UnityEngine.UI
{
    [AddComponentMenu("UI/Effects/Shadow", 14)]
    public class Shadow : BaseMeshEffect
    {
        protected Shadow();

        public Color effectColor { get; set; }
        public Vector2 effectDistance { get; set; }
        public bool useGraphicAlpha { get; set; }

        protected override void OnValidate();
        protected void ApplyShadowZeroAlloc(List<UIVertex> verts, Color32 color, int start, int end, float x, float y);
        protected void ApplyShadow(List<UIVertex> verts, Color32 color, int start, int end, float x, float y);
        public override void ModifyMesh(VertexHelper vh);
    }
}
namespace UnityEngine.EventSystems
{
    public class AxisEventData : BaseEventData
    {
        public AxisEventData(EventSystem eventSystem);

        public Vector2 moveVector { get; set; }
        public MoveDirection moveDir { get; set; }
    }
}
namespace UnityEngine.EventSystems
{
    public abstract class AbstractEventData
    {
        protected bool m_Used;

        protected AbstractEventData();

        public virtual bool used { get; }

        public virtual void Reset();
        public virtual void Use();
    }
}
namespace UnityEngine.EventSystems
{
    public class BaseEventData : AbstractEventData
    {
        public BaseEventData(EventSystem eventSystem);

        public BaseInputModule currentInputModule { get; }
        public GameObject selectedObject { get; set; }
    }
}
using System;
using System.Collections.Generic;

namespace UnityEngine.EventSystems
{
    public class PointerEventData : BaseEventData
    {
        public List<GameObject> hovered;

        public PointerEventData(EventSystem eventSystem);

        public GameObject pointerEnter { get; set; }
        public GameObject lastPress { get; }
        public GameObject rawPointerPress { get; set; }
        public GameObject pointerDrag { get; set; }
        public GameObject pointerClick { get; set; }
        public RaycastResult pointerCurrentRaycast { get; set; }
        public RaycastResult pointerPressRaycast { get; set; }
        public bool eligibleForClick { get; set; }
        public int pointerId { get; set; }
        public Vector2 position { get; set; }
        public Vector2 delta { get; set; }
        public Vector2 pressPosition { get; set; }
        [Obsolete("Use either pointerCurrentRaycast.worldPosition or pointerPressRaycast.worldPosition")]
        public Vector3 worldPosition { get; set; }
        [Obsolete("Use either pointerCurrentRaycast.worldNormal or pointerPressRaycast.worldNormal")]
        public Vector3 worldNormal { get; set; }
        public float clickTime { get; set; }
        public int clickCount { get; set; }
        public Vector2 scrollDelta { get; set; }
        public bool useDragThreshold { get; set; }
        public bool dragging { get; set; }
        public InputButton button { get; set; }
        public Camera enterEventCamera { get; }
        public Camera pressEventCamera { get; }
        public GameObject pointerPress { get; set; }

        public bool IsPointerMoving();
        public bool IsScrolling();
        public override string ToString();

        public enum InputButton
        {
            Left = 0,
            Right = 1,
            Middle = 2
        }
        public enum FramePressState
        {
            Pressed = 0,
            Released = 1,
            PressedAndReleased = 2,
            NotChanged = 3
        }
    }
}
using System;

namespace UnityEngine.EventSystems
{
    [Flags]
    public enum EventHandle
    {
        Unused = 0,
        Used = 1
    }
}
namespace UnityEngine.EventSystems
{
    public interface IEventSystemHandler
    {
    }
}
namespace UnityEngine.EventSystems
{
    public interface IPointerEnterHandler : IEventSystemHandler
    {
        void OnPointerEnter(PointerEventData eventData);
    }
}
namespace UnityEngine.EventSystems
{
    public interface IPointerExitHandler : IEventSystemHandler
    {
        void OnPointerExit(PointerEventData eventData);
    }
}
namespace UnityEngine.EventSystems
{
    public interface IPointerDownHandler : IEventSystemHandler
    {
        void OnPointerDown(PointerEventData eventData);
    }
}
namespace UnityEngine.EventSystems
{
    public interface IPointerUpHandler : IEventSystemHandler
    {
        void OnPointerUp(PointerEventData eventData);
    }
}
namespace UnityEngine.EventSystems
{
    public interface IPointerClickHandler : IEventSystemHandler
    {
        void OnPointerClick(PointerEventData eventData);
    }
}
namespace UnityEngine.EventSystems
{
    public interface IBeginDragHandler : IEventSystemHandler
    {
        void OnBeginDrag(PointerEventData eventData);
    }
}
namespace UnityEngine.EventSystems
{
    public interface IInitializePotentialDragHandler : IEventSystemHandler
    {
        void OnInitializePotentialDrag(PointerEventData eventData);
    }
}
namespace UnityEngine.EventSystems
{
    public interface IDragHandler : IEventSystemHandler
    {
        void OnDrag(PointerEventData eventData);
    }
}
namespace UnityEngine.EventSystems
{
    public interface IEndDragHandler : IEventSystemHandler
    {
        void OnEndDrag(PointerEventData eventData);
    }
}
namespace UnityEngine.EventSystems
{
    public interface IDropHandler : IEventSystemHandler
    {
        void OnDrop(PointerEventData eventData);
    }
}
namespace UnityEngine.EventSystems
{
    public interface IScrollHandler : IEventSystemHandler
    {
        void OnScroll(PointerEventData eventData);
    }
}
namespace UnityEngine.EventSystems
{
    public interface IUpdateSelectedHandler : IEventSystemHandler
    {
        void OnUpdateSelected(BaseEventData eventData);
    }
}
namespace UnityEngine.EventSystems
{
    public interface ISelectHandler : IEventSystemHandler
    {
        void OnSelect(BaseEventData eventData);
    }
}
namespace UnityEngine.EventSystems
{
    public interface IDeselectHandler : IEventSystemHandler
    {
        void OnDeselect(BaseEventData eventData);
    }
}
namespace UnityEngine.EventSystems
{
    public interface IMoveHandler : IEventSystemHandler
    {
        void OnMove(AxisEventData eventData);
    }
}
namespace UnityEngine.EventSystems
{
    public interface ISubmitHandler : IEventSystemHandler
    {
        void OnSubmit(BaseEventData eventData);
    }
}
namespace UnityEngine.EventSystems
{
    public interface ICancelHandler : IEventSystemHandler
    {
        void OnCancel(BaseEventData eventData);
    }
}
using System;
using System.Collections.Generic;

namespace UnityEngine.EventSystems
{
    [AddComponentMenu("Event/Event System")]
    [DisallowMultipleComponent]
    public class EventSystem : UIBehaviour
    {
        protected EventSystem();

        public static EventSystem current { get; set; }
        public bool sendNavigationEvents { get; set; }
        public int pixelDragThreshold { get; set; }
        public BaseInputModule currentInputModule { get; }
        public GameObject firstSelectedGameObject { get; set; }
        public GameObject currentSelectedGameObject { get; }
        [Obsolete("lastSelectedGameObject is no longer supported")]
        public GameObject lastSelectedGameObject { get; }
        public bool isFocused { get; }
        public bool alreadySelecting { get; }

        public void UpdateModules();
        public void SetSelectedGameObject(GameObject selected, BaseEventData pointer);
        public void SetSelectedGameObject(GameObject selected);
        public void RaycastAll(PointerEventData eventData, List<RaycastResult> raycastResults);
        public bool IsPointerOverGameObject();
        public bool IsPointerOverGameObject(int pointerId);
        protected override void OnEnable();
        protected override void OnDisable();
        protected virtual void OnApplicationFocus(bool hasFocus);
        protected virtual void Update();
        public override string ToString();
    }
}
using System;
using System.Collections.Generic;
using System.ComponentModel;
using UnityEngine.Events;

namespace UnityEngine.EventSystems
{
    [AddComponentMenu("Event/Event Trigger")]
    public class EventTrigger : MonoBehaviour, IInitializePotentialDragHandler, IDragHandler, IEndDragHandler, IDropHandler, IScrollHandler, IEventSystemHandler, IUpdateSelectedHandler, IPointerEnterHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IMoveHandler, IPointerUpHandler, ISubmitHandler, IPointerClickHandler, ICancelHandler, IBeginDragHandler
    {
        protected EventTrigger();

        [EditorBrowsable(Never)]
        [Obsolete("Please use triggers instead (UnityUpgradable) -> triggers", True)]
        public List<Entry> delegates { get; set; }
        public List<Entry> triggers { get; set; }

        public virtual void OnPointerEnter(PointerEventData eventData);
        public virtual void OnPointerExit(PointerEventData eventData);
        public virtual void OnDrag(PointerEventData eventData);
        public virtual void OnDrop(PointerEventData eventData);
        public virtual void OnPointerDown(PointerEventData eventData);
        public virtual void OnPointerUp(PointerEventData eventData);
        public virtual void OnPointerClick(PointerEventData eventData);
        public virtual void OnSelect(BaseEventData eventData);
        public virtual void OnDeselect(BaseEventData eventData);
        public virtual void OnScroll(PointerEventData eventData);
        public virtual void OnMove(AxisEventData eventData);
        public virtual void OnUpdateSelected(BaseEventData eventData);
        public virtual void OnInitializePotentialDrag(PointerEventData eventData);
        public virtual void OnBeginDrag(PointerEventData eventData);
        public virtual void OnEndDrag(PointerEventData eventData);
        public virtual void OnSubmit(BaseEventData eventData);
        public virtual void OnCancel(BaseEventData eventData);

        public class TriggerEvent : UnityEvent<BaseEventData>
        {
            public TriggerEvent();
        }
        public class Entry
        {
            public EventTriggerType eventID;
            public TriggerEvent callback;

            public Entry();
        }
    }
}
namespace UnityEngine.EventSystems
{
    public enum EventTriggerType
    {
        PointerEnter = 0,
        PointerExit = 1,
        PointerDown = 2,
        PointerUp = 3,
        PointerClick = 4,
        Drag = 5,
        Drop = 6,
        Scroll = 7,
        UpdateSelected = 8,
        Select = 9,
        Deselect = 10,
        Move = 11,
        InitializePotentialDrag = 12,
        BeginDrag = 13,
        EndDrag = 14,
        Submit = 15,
        Cancel = 16
    }
}
namespace UnityEngine.EventSystems
{
    public static class ExecuteEvents
    {
        public static EventFunction<IPointerEnterHandler> pointerEnterHandler { get; }
        public static EventFunction<IPointerExitHandler> pointerExitHandler { get; }
        public static EventFunction<IPointerDownHandler> pointerDownHandler { get; }
        public static EventFunction<IPointerUpHandler> pointerUpHandler { get; }
        public static EventFunction<IPointerClickHandler> pointerClickHandler { get; }
        public static EventFunction<IInitializePotentialDragHandler> initializePotentialDrag { get; }
        public static EventFunction<IBeginDragHandler> beginDragHandler { get; }
        public static EventFunction<IDragHandler> dragHandler { get; }
        public static EventFunction<IEndDragHandler> endDragHandler { get; }
        public static EventFunction<IDropHandler> dropHandler { get; }
        public static EventFunction<IScrollHandler> scrollHandler { get; }
        public static EventFunction<IUpdateSelectedHandler> updateSelectedHandler { get; }
        public static EventFunction<ISelectHandler> selectHandler { get; }
        public static EventFunction<IDeselectHandler> deselectHandler { get; }
        public static EventFunction<IMoveHandler> moveHandler { get; }
        public static EventFunction<ISubmitHandler> submitHandler { get; }
        public static EventFunction<ICancelHandler> cancelHandler { get; }

        public static T ValidateEventData<T>(BaseEventData data) where T : class;
        public static bool Execute<T>(GameObject target, BaseEventData eventData, EventFunction<T> functor) where T : IEventSystemHandler;
        public static GameObject ExecuteHierarchy<T>(GameObject root, BaseEventData eventData, EventFunction<T> callbackFunction) where T : IEventSystemHandler;
        public static bool CanHandleEvent<T>(GameObject go) where T : IEventSystemHandler;
        public static GameObject GetEventHandler<T>(GameObject root) where T : IEventSystemHandler;

        public delegate void EventFunction<T1>(T1 handler, BaseEventData eventData);
    }
}
namespace UnityEngine.EventSystems
{
    public class BaseInput : UIBehaviour
    {
        public BaseInput();

        public virtual string compositionString { get; }
        public virtual IMECompositionMode imeCompositionMode { get; set; }
        public virtual Vector2 compositionCursorPos { get; set; }
        public virtual bool mousePresent { get; }
        public virtual Vector2 mousePosition { get; }
        public virtual Vector2 mouseScrollDelta { get; }
        public virtual bool touchSupported { get; }
        public virtual int touchCount { get; }

        public virtual bool GetMouseButtonDown(int button);
        public virtual bool GetMouseButtonUp(int button);
        public virtual bool GetMouseButton(int button);
        public virtual Touch GetTouch(int index);
        public virtual float GetAxisRaw(string axisName);
        public virtual bool GetButtonDown(string buttonName);
    }
}
using System.Collections.Generic;

namespace UnityEngine.EventSystems
{
    [RequireComponent(typeof(EventSystem))]
    public abstract class BaseInputModule : UIBehaviour
    {
        protected List<RaycastResult> m_RaycastResultCache;
        protected BaseInput m_InputOverride;

        protected BaseInputModule();

        public BaseInput input { get; }
        public BaseInput inputOverride { get; set; }
        protected EventSystem eventSystem { get; }

        protected override void OnEnable();
        protected override void OnDisable();
        public abstract void Process();
        protected static RaycastResult FindFirstRaycast(List<RaycastResult> candidates);
        protected static MoveDirection DetermineMoveDirection(float x, float y);
        protected static MoveDirection DetermineMoveDirection(float x, float y, float deadZone);
        protected static GameObject FindCommonRoot(GameObject g1, GameObject g2);
        protected void HandlePointerExitAndEnter(PointerEventData currentPointerData, GameObject newEnterTarget);
        protected virtual AxisEventData GetAxisEventData(float x, float y, float moveDeadZone);
        protected virtual BaseEventData GetBaseEventData();
        public virtual bool IsPointerOverGameObject(int pointerId);
        public virtual bool ShouldActivateModule();
        public virtual void DeactivateModule();
        public virtual void ActivateModule();
        public virtual void UpdateModule();
        public virtual bool IsModuleSupported();
    }
}
using System.Collections.Generic;

namespace UnityEngine.EventSystems
{
    public abstract class PointerInputModule : BaseInputModule
    {
        public const int kMouseLeftId = -1;
        public const int kMouseRightId = -2;
        public const int kMouseMiddleId = -3;
        public const int kFakeTouchesId = -4;
        protected Dictionary<int, PointerEventData> m_PointerData;

        protected PointerInputModule();

        protected bool GetPointerData(int id, out PointerEventData data, bool create);
        protected void RemovePointerData(PointerEventData data);
        protected PointerEventData GetTouchPointerEventData(Touch input, out bool pressed, out bool released);
        protected void CopyFromTo(PointerEventData from, PointerEventData to);
        protected PointerEventData.FramePressState StateForMouseButton(int buttonId);
        protected virtual MouseState GetMousePointerEventData();
        protected virtual MouseState GetMousePointerEventData(int id);
        protected PointerEventData GetLastPointerEventData(int id);
        protected virtual void ProcessMove(PointerEventData pointerEvent);
        protected virtual void ProcessDrag(PointerEventData pointerEvent);
        public override bool IsPointerOverGameObject(int pointerId);
        protected void ClearSelection();
        public override string ToString();
        protected void DeselectIfSelectionChanged(GameObject currentOverGo, BaseEventData pointerEvent);

        protected class ButtonState
        {
            public ButtonState();

            public MouseButtonEventData eventData { get; set; }
            public PointerEventData.InputButton button { get; set; }
        }
        protected class MouseState
        {
            public MouseState();

            public bool AnyPressesThisFrame();
            public bool AnyReleasesThisFrame();
            public ButtonState GetButtonState(PointerEventData.InputButton button);
            public void SetButtonState(PointerEventData.InputButton button, PointerEventData.FramePressState stateForMouseButton, PointerEventData data);
        }
        public class MouseButtonEventData
        {
            public PointerEventData.FramePressState buttonState;
            public PointerEventData buttonData;

            public MouseButtonEventData();

            public bool PressedThisFrame();
            public bool ReleasedThisFrame();
        }
    }
}
using System;

namespace UnityEngine.EventSystems
{
    [AddComponentMenu("Event/Standalone Input Module")]
    public class StandaloneInputModule : PointerInputModule
    {
        protected StandaloneInputModule();

        [Obsolete("Mode is no longer needed on input module as it handles both mouse and keyboard simultaneously.", False)]
        public InputMode inputMode { get; }
        [Obsolete("allowActivationOnMobileDevice has been deprecated. Use forceModuleActive instead (UnityUpgradable) -> forceModuleActive")]
        public bool allowActivationOnMobileDevice { get; set; }
        public bool forceModuleActive { get; set; }
        public float inputActionsPerSecond { get; set; }
        public float repeatDelay { get; set; }
        public string horizontalAxis { get; set; }
        public string verticalAxis { get; set; }
        public string submitButton { get; set; }
        public string cancelButton { get; set; }

        public override void UpdateModule();
        public override bool IsModuleSupported();
        public override bool ShouldActivateModule();
        public override void ActivateModule();
        public override void DeactivateModule();
        public override void Process();
        protected void ProcessTouchPress(PointerEventData pointerEvent, bool pressed, bool released);
        protected bool SendSubmitEventToSelectedObject();
        protected bool SendMoveEventToSelectedObject();
        protected void ProcessMouseEvent();
        [Obsolete("This method is no longer checked, overriding it with return true does nothing!")]
        protected virtual bool ForceAutoSelect();
        protected void ProcessMouseEvent(int id);
        protected bool SendUpdateEventToSelectedObject();
        protected void ProcessMousePress(PointerInputModule.MouseButtonEventData data);
        protected GameObject GetCurrentFocusedGameObject();

        [Obsolete("Mode is no longer needed on input module as it handles both mouse and keyboard simultaneously.", False)]
        public enum InputMode
        {
            Mouse = 0,
            Buttons = 1
        }
    }
}
using System;

namespace UnityEngine.EventSystems
{
    [Obsolete("TouchInputModule is no longer required as Touch input is now handled in StandaloneInputModule.")]
    [AddComponentMenu("Event/Touch Input Module")]
    public class TouchInputModule : PointerInputModule
    {
        protected TouchInputModule();

        [Obsolete("allowActivationOnStandalone has been deprecated. Use forceModuleActive instead (UnityUpgradable) -> forceModuleActive")]
        public bool allowActivationOnStandalone { get; set; }
        public bool forceModuleActive { get; set; }

        public override void UpdateModule();
        public override bool IsModuleSupported();
        public override bool ShouldActivateModule();
        public override void Process();
        protected void ProcessTouchPress(PointerEventData pointerEvent, bool pressed, bool released);
        public override void DeactivateModule();
        public override string ToString();
    }
}
namespace UnityEngine.EventSystems
{
    public enum MoveDirection
    {
        Left = 0,
        Up = 1,
        Right = 2,
        Down = 3,
        None = 4
    }
}
namespace UnityEngine.EventSystems
{
    public struct RaycastResult
    {
        public BaseRaycaster module;
        public float distance;
        public float index;
        public int depth;
        public int sortingLayer;
        public int sortingOrder;
        public Vector3 worldPosition;
        public Vector3 worldNormal;
        public Vector2 screenPosition;
        public int displayIndex;

        public GameObject gameObject { get; set; }
        public bool isValid { get; }

        public void Clear();
        public override string ToString();
    }
}
using System.Collections.Generic;

namespace UnityEngine.EventSystems
{
    public static class RaycasterManager
    {
        public static List<BaseRaycaster> GetRaycasters();
    }
}
using System;
using System.Collections.Generic;

namespace UnityEngine.EventSystems
{
    public abstract class BaseRaycaster : UIBehaviour
    {
        protected BaseRaycaster();

        public abstract Camera eventCamera { get; }
        [Obsolete("Please use sortOrderPriority and renderOrderPriority", False)]
        public virtual int priority { get; }
        public virtual int sortOrderPriority { get; }
        public virtual int renderOrderPriority { get; }
        public BaseRaycaster rootRaycaster { get; }

        public abstract void Raycast(PointerEventData eventData, List<RaycastResult> resultAppendList);
        public override string ToString();
        protected override void OnEnable();
        protected override void OnDisable();
        protected override void OnCanvasHierarchyChanged();
        protected override void OnTransformParentChanged();
    }
}
using System.Collections.Generic;

namespace UnityEngine.EventSystems
{
    [AddComponentMenu("Event/Physics 2D Raycaster")]
    [RequireComponent(typeof(Camera))]
    public class Physics2DRaycaster : PhysicsRaycaster
    {
        protected Physics2DRaycaster();

        public override void Raycast(PointerEventData eventData, List<RaycastResult> resultAppendList);
    }
}
using System.Collections.Generic;

namespace UnityEngine.EventSystems
{
    [AddComponentMenu("Event/Physics Raycaster")]
    [RequireComponent(typeof(Camera))]
    public class PhysicsRaycaster : BaseRaycaster
    {
        protected const int kNoEventMaskSet = -1;
        protected Camera m_EventCamera;
        [SerializeField]
        protected LayerMask m_EventMask;
        [SerializeField]
        protected int m_MaxRayIntersections;
        protected int m_LastMaxRayIntersections;

        protected PhysicsRaycaster();

        public override Camera eventCamera { get; }
        public virtual int depth { get; }
        public int finalEventMask { get; }
        public LayerMask eventMask { get; set; }
        public int maxRayIntersections { get; set; }

        protected bool ComputeRayAndDistance(PointerEventData eventData, ref Ray ray, ref int eventDisplayIndex, ref float distanceToClipPlane);
        public override void Raycast(PointerEventData eventData, List<RaycastResult> resultAppendList);
    }
}
namespace UnityEngine.EventSystems
{
    public abstract class UIBehaviour : MonoBehaviour
    {
        protected UIBehaviour();

        protected virtual void Awake();
        protected virtual void OnEnable();
        protected virtual void Start();
        protected virtual void OnDisable();
        protected virtual void OnDestroy();
        public virtual bool IsActive();
        protected virtual void OnValidate();
        protected virtual void Reset();
        protected virtual void OnRectTransformDimensionsChange();
        protected virtual void OnBeforeTransformParentChanged();
        protected virtual void OnTransformParentChanged();
        protected virtual void OnDidApplyAnimationProperties();
        protected virtual void OnCanvasGroupChanged();
        protected virtual void OnCanvasHierarchyChanged();
        public bool IsDestroyed();
    }
}
-------- {Unity.EditorCoroutines.Editor(D:\Documents\GitHub\Rogue-like-game-i-guess\The game is liar\Library\ScriptAssemblies\Unity.EditorCoroutines.Editor.dll)}:    6 --------
namespace Unity.EditorCoroutines.Editor
{
    public class EditorCoroutine
    {
    }
}
using System.Collections;

namespace Unity.EditorCoroutines.Editor
{
    public static class EditorCoroutineUtility
    {
        public static EditorCoroutine StartCoroutine(IEnumerator routine, object owner);
        public static EditorCoroutine StartCoroutineOwnerless(IEnumerator routine);
        public static void StopCoroutine(EditorCoroutine coroutine);
    }
}
namespace Unity.EditorCoroutines.Editor
{
    public class EditorWaitForSeconds
    {
        public EditorWaitForSeconds(float time);

        public float WaitTime { get; }
    }
}
using System.Collections;
using UnityEditor;

namespace Unity.EditorCoroutines.Editor
{
    public static class EditorWindowCoroutineExtension
    {
        public static EditorCoroutine StartCoroutine(this EditorWindow window, IEnumerator routine);
        public static void StopCoroutine(this EditorWindow window, EditorCoroutine coroutine);
    }
}
-------- {Unity.Mathematics(D:\Documents\GitHub\Rogue-like-game-i-guess\The game is liar\Library\ScriptAssemblies\Unity.Mathematics.dll)}:   92 --------
namespace Unity.Mathematics
{
    public static class noise
    {
        public static float2 cellular(float2 P);
        public static float2 cellular2x2(float2 P);
        public static float2 cellular2x2x2(float3 P);
        public static float2 cellular(float3 P);
        public static float cnoise(float2 P);
        public static float pnoise(float2 P, float2 rep);
        public static float cnoise(float3 P);
        public static float pnoise(float3 P, float3 rep);
        public static float cnoise(float4 P);
        public static float pnoise(float4 P, float4 rep);
        public static float snoise(float2 v);
        public static float snoise(float3 v);
        public static float snoise(float3 v, out float3 gradient);
        public static float snoise(float4 v);
        public static float3 psrdnoise(float2 pos, float2 per, float rot);
        public static float3 psrdnoise(float2 pos, float2 per);
        public static float psrnoise(float2 pos, float2 per, float rot);
        public static float psrnoise(float2 pos, float2 per);
        public static float3 srdnoise(float2 pos, float rot);
        public static float3 srdnoise(float2 pos);
        public static float srnoise(float2 pos, float rot);
        public static float srnoise(float2 pos);
    }
}
using UnityEngine;

namespace Unity.Mathematics
{
    public class PostNormalizeAttribute : PropertyAttribute
    {
        public PostNormalizeAttribute();
    }
}
using UnityEngine;

namespace Unity.Mathematics
{
    public class DoNotNormalizeAttribute : PropertyAttribute
    {
        public DoNotNormalizeAttribute();
    }
}
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    [DebuggerTypeProxy(typeof(DebuggerProxy))]
    public struct bool2 : IEquatable<bool2>
    {
        public bool x;
        public bool y;

        public bool2(bool x, bool y);
        public bool2(bool2 xy);
        public bool2(bool v);

        public bool this[int index] { get; set; }
        [EditorBrowsable(Never)]
        public bool4 xxxx { get; }
        [EditorBrowsable(Never)]
        public bool4 xxxy { get; }
        [EditorBrowsable(Never)]
        public bool4 xxyx { get; }
        [EditorBrowsable(Never)]
        public bool4 xxyy { get; }
        [EditorBrowsable(Never)]
        public bool4 xyxx { get; }
        [EditorBrowsable(Never)]
        public bool4 xyxy { get; }
        [EditorBrowsable(Never)]
        public bool4 xyyx { get; }
        [EditorBrowsable(Never)]
        public bool4 xyyy { get; }
        [EditorBrowsable(Never)]
        public bool4 yxxx { get; }
        [EditorBrowsable(Never)]
        public bool4 yxxy { get; }
        [EditorBrowsable(Never)]
        public bool4 yxyx { get; }
        [EditorBrowsable(Never)]
        public bool4 yxyy { get; }
        [EditorBrowsable(Never)]
        public bool4 yyxx { get; }
        [EditorBrowsable(Never)]
        public bool4 yyxy { get; }
        [EditorBrowsable(Never)]
        public bool4 yyyx { get; }
        [EditorBrowsable(Never)]
        public bool4 yyyy { get; }
        [EditorBrowsable(Never)]
        public bool3 xxx { get; }
        [EditorBrowsable(Never)]
        public bool3 xxy { get; }
        [EditorBrowsable(Never)]
        public bool3 xyx { get; }
        [EditorBrowsable(Never)]
        public bool3 xyy { get; }
        [EditorBrowsable(Never)]
        public bool3 yxx { get; }
        [EditorBrowsable(Never)]
        public bool3 yxy { get; }
        [EditorBrowsable(Never)]
        public bool3 yyx { get; }
        [EditorBrowsable(Never)]
        public bool3 yyy { get; }
        [EditorBrowsable(Never)]
        public bool2 xx { get; }
        [EditorBrowsable(Never)]
        public bool2 xy { get; set; }
        [EditorBrowsable(Never)]
        public bool2 yx { get; set; }
        [EditorBrowsable(Never)]
        public bool2 yy { get; }

        public bool Equals(bool2 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();

        public static bool2 operator ==(bool2 lhs, bool2 rhs);
        public static bool2 operator ==(bool2 lhs, bool rhs);
        public static bool2 operator ==(bool lhs, bool2 rhs);
        public static bool2 operator !=(bool2 lhs, bool2 rhs);
        public static bool2 operator !=(bool2 lhs, bool rhs);
        public static bool2 operator !=(bool lhs, bool2 rhs);
        public static bool2 operator !(bool2 val);
        public static bool2 operator &(bool2 lhs, bool2 rhs);
        public static bool2 operator &(bool2 lhs, bool rhs);
        public static bool2 operator &(bool lhs, bool2 rhs);
        public static bool2 operator |(bool2 lhs, bool2 rhs);
        public static bool2 operator |(bool2 lhs, bool rhs);
        public static bool2 operator |(bool lhs, bool2 rhs);
        public static bool2 operator ^(bool2 lhs, bool2 rhs);
        public static bool2 operator ^(bool2 lhs, bool rhs);
        public static bool2 operator ^(bool lhs, bool2 rhs);

        public static implicit operator bool2(bool v);
    }
}
namespace Unity.Mathematics
{
    public static class math
    {
        public const double E_DBL = 2.71828182845905;
        public const double LOG2E_DBL = 1.44269504088896;
        public const double LOG10E_DBL = 0.434294481903252;
        public const double LN2_DBL = 0.693147180559945;
        public const double LN10_DBL = 2.30258509299405;
        public const double PI_DBL = 3.14159265358979;
        public const double SQRT2_DBL = 1.4142135623731;
        public const float FLT_MIN_NORMAL = 1.175494E-38F;
        public const double DBL_MIN_NORMAL = 2.2250738585072E-308;
        public const float E = 2.718282F;
        public const float LOG2E = 1.442695F;
        public const float LOG10E = 0.4342945F;
        public const float LN2 = 0.6931472F;
        public const float LN10 = 2.302585F;
        public const float PI = 3.141593F;
        public const float SQRT2 = 1.414214F;

        public static bool2 bool2(bool x, bool y);
        public static bool2 bool2(bool2 xy);
        public static bool2 bool2(bool v);
        public static uint hash(bool2 v);
        public static uint2 hashwide(bool2 v);
        public static bool shuffle(bool2 a, bool2 b, ShuffleComponent x);
        public static bool2 shuffle(bool2 a, bool2 b, ShuffleComponent x, ShuffleComponent y);
        public static bool3 shuffle(bool2 a, bool2 b, ShuffleComponent x, ShuffleComponent y, ShuffleComponent z);
        public static bool4 shuffle(bool2 a, bool2 b, ShuffleComponent x, ShuffleComponent y, ShuffleComponent z, ShuffleComponent w);
        public static bool2x2 bool2x2(bool2 c0, bool2 c1);
        public static bool2x2 bool2x2(bool m00, bool m01, bool m10, bool m11);
        public static bool2x2 bool2x2(bool v);
        public static bool2x2 transpose(bool2x2 v);
        public static uint hash(bool2x2 v);
        public static uint2 hashwide(bool2x2 v);
        public static bool2x3 bool2x3(bool2 c0, bool2 c1, bool2 c2);
        public static bool2x3 bool2x3(bool m00, bool m01, bool m02, bool m10, bool m11, bool m12);
        public static bool2x3 bool2x3(bool v);
        public static bool3x2 transpose(bool2x3 v);
        public static uint hash(bool2x3 v);
        public static uint2 hashwide(bool2x3 v);
        public static bool2x4 bool2x4(bool2 c0, bool2 c1, bool2 c2, bool2 c3);
        public static bool2x4 bool2x4(bool m00, bool m01, bool m02, bool m03, bool m10, bool m11, bool m12, bool m13);
        public static bool2x4 bool2x4(bool v);
        public static bool4x2 transpose(bool2x4 v);
        public static uint hash(bool2x4 v);
        public static uint2 hashwide(bool2x4 v);
        public static bool3 bool3(bool x, bool y, bool z);
        public static bool3 bool3(bool x, bool2 yz);
        public static bool3 bool3(bool2 xy, bool z);
        public static bool3 bool3(bool3 xyz);
        public static bool3 bool3(bool v);
        public static uint hash(bool3 v);
        public static uint3 hashwide(bool3 v);
        public static bool shuffle(bool3 a, bool3 b, ShuffleComponent x);
        public static bool2 shuffle(bool3 a, bool3 b, ShuffleComponent x, ShuffleComponent y);
        public static bool3 shuffle(bool3 a, bool3 b, ShuffleComponent x, ShuffleComponent y, ShuffleComponent z);
        public static bool4 shuffle(bool3 a, bool3 b, ShuffleComponent x, ShuffleComponent y, ShuffleComponent z, ShuffleComponent w);
        public static bool3x2 bool3x2(bool3 c0, bool3 c1);
        public static bool3x2 bool3x2(bool m00, bool m01, bool m10, bool m11, bool m20, bool m21);
        public static bool3x2 bool3x2(bool v);
        public static bool2x3 transpose(bool3x2 v);
        public static uint hash(bool3x2 v);
        public static uint3 hashwide(bool3x2 v);
        public static bool3x3 bool3x3(bool3 c0, bool3 c1, bool3 c2);
        public static bool3x3 bool3x3(bool m00, bool m01, bool m02, bool m10, bool m11, bool m12, bool m20, bool m21, bool m22);
        public static bool3x3 bool3x3(bool v);
        public static bool3x3 transpose(bool3x3 v);
        public static uint hash(bool3x3 v);
        public static uint3 hashwide(bool3x3 v);
        public static bool3x4 bool3x4(bool3 c0, bool3 c1, bool3 c2, bool3 c3);
        public static bool3x4 bool3x4(bool m00, bool m01, bool m02, bool m03, bool m10, bool m11, bool m12, bool m13, bool m20, bool m21, bool m22, bool m23);
        public static bool3x4 bool3x4(bool v);
        public static bool4x3 transpose(bool3x4 v);
        public static uint hash(bool3x4 v);
        public static uint3 hashwide(bool3x4 v);
        public static bool4 bool4(bool x, bool y, bool z, bool w);
        public static bool4 bool4(bool x, bool y, bool2 zw);
        public static bool4 bool4(bool x, bool2 yz, bool w);
        public static bool4 bool4(bool x, bool3 yzw);
        public static bool4 bool4(bool2 xy, bool z, bool w);
        public static bool4 bool4(bool2 xy, bool2 zw);
        public static bool4 bool4(bool3 xyz, bool w);
        public static bool4 bool4(bool4 xyzw);
        public static bool4 bool4(bool v);
        public static uint hash(bool4 v);
        public static uint4 hashwide(bool4 v);
        public static bool shuffle(bool4 a, bool4 b, ShuffleComponent x);
        public static bool2 shuffle(bool4 a, bool4 b, ShuffleComponent x, ShuffleComponent y);
        public static bool3 shuffle(bool4 a, bool4 b, ShuffleComponent x, ShuffleComponent y, ShuffleComponent z);
        public static bool4 shuffle(bool4 a, bool4 b, ShuffleComponent x, ShuffleComponent y, ShuffleComponent z, ShuffleComponent w);
        public static bool4x2 bool4x2(bool4 c0, bool4 c1);
        public static bool4x2 bool4x2(bool m00, bool m01, bool m10, bool m11, bool m20, bool m21, bool m30, bool m31);
        public static bool4x2 bool4x2(bool v);
        public static bool2x4 transpose(bool4x2 v);
        public static uint hash(bool4x2 v);
        public static uint4 hashwide(bool4x2 v);
        public static bool4x3 bool4x3(bool4 c0, bool4 c1, bool4 c2);
        public static bool4x3 bool4x3(bool m00, bool m01, bool m02, bool m10, bool m11, bool m12, bool m20, bool m21, bool m22, bool m30, bool m31, bool m32);
        public static bool4x3 bool4x3(bool v);
        public static bool3x4 transpose(bool4x3 v);
        public static uint hash(bool4x3 v);
        public static uint4 hashwide(bool4x3 v);
        public static bool4x4 bool4x4(bool4 c0, bool4 c1, bool4 c2, bool4 c3);
        public static bool4x4 bool4x4(bool m00, bool m01, bool m02, bool m03, bool m10, bool m11, bool m12, bool m13, bool m20, bool m21, bool m22, bool m23, bool m30, bool m31, bool m32, bool m33);
        public static bool4x4 bool4x4(bool v);
        public static bool4x4 transpose(bool4x4 v);
        public static uint hash(bool4x4 v);
        public static uint4 hashwide(bool4x4 v);
        public static double2 double2(double x, double y);
        public static double2 double2(double2 xy);
        public static double2 double2(double v);
        public static double2 double2(bool v);
        public static double2 double2(bool2 v);
        public static double2 double2(int v);
        public static double2 double2(int2 v);
        public static double2 double2(uint v);
        public static double2 double2(uint2 v);
        public static double2 double2(half v);
        public static double2 double2(half2 v);
        public static double2 double2(float v);
        public static double2 double2(float2 v);
        public static uint hash(double2 v);
        public static uint2 hashwide(double2 v);
        public static double shuffle(double2 a, double2 b, ShuffleComponent x);
        public static double2 shuffle(double2 a, double2 b, ShuffleComponent x, ShuffleComponent y);
        public static double3 shuffle(double2 a, double2 b, ShuffleComponent x, ShuffleComponent y, ShuffleComponent z);
        public static double4 shuffle(double2 a, double2 b, ShuffleComponent x, ShuffleComponent y, ShuffleComponent z, ShuffleComponent w);
        public static double2x2 double2x2(double2 c0, double2 c1);
        public static double2x2 double2x2(double m00, double m01, double m10, double m11);
        public static double2x2 double2x2(double v);
        public static double2x2 double2x2(bool v);
        public static double2x2 double2x2(bool2x2 v);
        public static double2x2 double2x2(int v);
        public static double2x2 double2x2(int2x2 v);
        public static double2x2 double2x2(uint v);
        public static double2x2 double2x2(uint2x2 v);
        public static double2x2 double2x2(float v);
        public static double2x2 double2x2(float2x2 v);
        public static double2x2 transpose(double2x2 v);
        public static double2x2 inverse(double2x2 m);
        public static double determinant(double2x2 m);
        public static uint hash(double2x2 v);
        public static uint2 hashwide(double2x2 v);
        public static double2x3 double2x3(double2 c0, double2 c1, double2 c2);
        public static double2x3 double2x3(double m00, double m01, double m02, double m10, double m11, double m12);
        public static double2x3 double2x3(double v);
        public static double2x3 double2x3(bool v);
        public static double2x3 double2x3(bool2x3 v);
        public static double2x3 double2x3(int v);
        public static double2x3 double2x3(int2x3 v);
        public static double2x3 double2x3(uint v);
        public static double2x3 double2x3(uint2x3 v);
        public static double2x3 double2x3(float v);
        public static double2x3 double2x3(float2x3 v);
        public static double3x2 transpose(double2x3 v);
        public static uint hash(double2x3 v);
        public static uint2 hashwide(double2x3 v);
        public static double2x4 double2x4(double2 c0, double2 c1, double2 c2, double2 c3);
        public static double2x4 double2x4(double m00, double m01, double m02, double m03, double m10, double m11, double m12, double m13);
        public static double2x4 double2x4(double v);
        public static double2x4 double2x4(bool v);
        public static double2x4 double2x4(bool2x4 v);
        public static double2x4 double2x4(int v);
        public static double2x4 double2x4(int2x4 v);
        public static double2x4 double2x4(uint v);
        public static double2x4 double2x4(uint2x4 v);
        public static double2x4 double2x4(float v);
        public static double2x4 double2x4(float2x4 v);
        public static double4x2 transpose(double2x4 v);
        public static uint hash(double2x4 v);
        public static uint2 hashwide(double2x4 v);
        public static double3 double3(double x, double y, double z);
        public static double3 double3(double x, double2 yz);
        public static double3 double3(double2 xy, double z);
        public static double3 double3(double3 xyz);
        public static double3 double3(double v);
        public static double3 double3(bool v);
        public static double3 double3(bool3 v);
        public static double3 double3(int v);
        public static double3 double3(int3 v);
        public static double3 double3(uint v);
        public static double3 double3(uint3 v);
        public static double3 double3(half v);
        public static double3 double3(half3 v);
        public static double3 double3(float v);
        public static double3 double3(float3 v);
        public static uint hash(double3 v);
        public static uint3 hashwide(double3 v);
        public static double shuffle(double3 a, double3 b, ShuffleComponent x);
        public static double2 shuffle(double3 a, double3 b, ShuffleComponent x, ShuffleComponent y);
        public static double3 shuffle(double3 a, double3 b, ShuffleComponent x, ShuffleComponent y, ShuffleComponent z);
        public static double4 shuffle(double3 a, double3 b, ShuffleComponent x, ShuffleComponent y, ShuffleComponent z, ShuffleComponent w);
        public static double3x2 double3x2(double3 c0, double3 c1);
        public static double3x2 double3x2(double m00, double m01, double m10, double m11, double m20, double m21);
        public static double3x2 double3x2(double v);
        public static double3x2 double3x2(bool v);
        public static double3x2 double3x2(bool3x2 v);
        public static double3x2 double3x2(int v);
        public static double3x2 double3x2(int3x2 v);
        public static double3x2 double3x2(uint v);
        public static double3x2 double3x2(uint3x2 v);
        public static double3x2 double3x2(float v);
        public static double3x2 double3x2(float3x2 v);
        public static double2x3 transpose(double3x2 v);
        public static uint hash(double3x2 v);
        public static uint3 hashwide(double3x2 v);
        public static double3x3 double3x3(double3 c0, double3 c1, double3 c2);
        public static double3x3 double3x3(double m00, double m01, double m02, double m10, double m11, double m12, double m20, double m21, double m22);
        public static double3x3 double3x3(double v);
        public static double3x3 double3x3(bool v);
        public static double3x3 double3x3(bool3x3 v);
        public static double3x3 double3x3(int v);
        public static double3x3 double3x3(int3x3 v);
        public static double3x3 double3x3(uint v);
        public static double3x3 double3x3(uint3x3 v);
        public static double3x3 double3x3(float v);
        public static double3x3 double3x3(float3x3 v);
        public static double3x3 transpose(double3x3 v);
        public static double3x3 inverse(double3x3 m);
        public static double determinant(double3x3 m);
        public static uint hash(double3x3 v);
        public static uint3 hashwide(double3x3 v);
        public static double3x4 double3x4(double3 c0, double3 c1, double3 c2, double3 c3);
        public static double3x4 double3x4(double m00, double m01, double m02, double m03, double m10, double m11, double m12, double m13, double m20, double m21, double m22, double m23);
        public static double3x4 double3x4(double v);
        public static double3x4 double3x4(bool v);
        public static double3x4 double3x4(bool3x4 v);
        public static double3x4 double3x4(int v);
        public static double3x4 double3x4(int3x4 v);
        public static double3x4 double3x4(uint v);
        public static double3x4 double3x4(uint3x4 v);
        public static double3x4 double3x4(float v);
        public static double3x4 double3x4(float3x4 v);
        public static double4x3 transpose(double3x4 v);
        public static double3x4 fastinverse(double3x4 m);
        public static uint hash(double3x4 v);
        public static uint3 hashwide(double3x4 v);
        public static double4 double4(double x, double y, double z, double w);
        public static double4 double4(double x, double y, double2 zw);
        public static double4 double4(double x, double2 yz, double w);
        public static double4 double4(double x, double3 yzw);
        public static double4 double4(double2 xy, double z, double w);
        public static double4 double4(double2 xy, double2 zw);
        public static double4 double4(double3 xyz, double w);
        public static double4 double4(double4 xyzw);
        public static double4 double4(double v);
        public static double4 double4(bool v);
        public static double4 double4(bool4 v);
        public static double4 double4(int v);
        public static double4 double4(int4 v);
        public static double4 double4(uint v);
        public static double4 double4(uint4 v);
        public static double4 double4(half v);
        public static double4 double4(half4 v);
        public static double4 double4(float v);
        public static double4 double4(float4 v);
        public static uint hash(double4 v);
        public static uint4 hashwide(double4 v);
        public static double shuffle(double4 a, double4 b, ShuffleComponent x);
        public static double2 shuffle(double4 a, double4 b, ShuffleComponent x, ShuffleComponent y);
        public static double3 shuffle(double4 a, double4 b, ShuffleComponent x, ShuffleComponent y, ShuffleComponent z);
        public static double4 shuffle(double4 a, double4 b, ShuffleComponent x, ShuffleComponent y, ShuffleComponent z, ShuffleComponent w);
        public static double4x2 double4x2(double4 c0, double4 c1);
        public static double4x2 double4x2(double m00, double m01, double m10, double m11, double m20, double m21, double m30, double m31);
        public static double4x2 double4x2(double v);
        public static double4x2 double4x2(bool v);
        public static double4x2 double4x2(bool4x2 v);
        public static double4x2 double4x2(int v);
        public static double4x2 double4x2(int4x2 v);
        public static double4x2 double4x2(uint v);
        public static double4x2 double4x2(uint4x2 v);
        public static double4x2 double4x2(float v);
        public static double4x2 double4x2(float4x2 v);
        public static double2x4 transpose(double4x2 v);
        public static uint hash(double4x2 v);
        public static uint4 hashwide(double4x2 v);
        public static double4x3 double4x3(double4 c0, double4 c1, double4 c2);
        public static double4x3 double4x3(double m00, double m01, double m02, double m10, double m11, double m12, double m20, double m21, double m22, double m30, double m31, double m32);
        public static double4x3 double4x3(double v);
        public static double4x3 double4x3(bool v);
        public static double4x3 double4x3(bool4x3 v);
        public static double4x3 double4x3(int v);
        public static double4x3 double4x3(int4x3 v);
        public static double4x3 double4x3(uint v);
        public static double4x3 double4x3(uint4x3 v);
        public static double4x3 double4x3(float v);
        public static double4x3 double4x3(float4x3 v);
        public static double3x4 transpose(double4x3 v);
        public static uint hash(double4x3 v);
        public static uint4 hashwide(double4x3 v);
        public static double4x4 double4x4(double4 c0, double4 c1, double4 c2, double4 c3);
        public static double4x4 double4x4(double m00, double m01, double m02, double m03, double m10, double m11, double m12, double m13, double m20, double m21, double m22, double m23, double m30, double m31, double m32, double m33);
        public static double4x4 double4x4(double v);
        public static double4x4 double4x4(bool v);
        public static double4x4 double4x4(bool4x4 v);
        public static double4x4 double4x4(int v);
        public static double4x4 double4x4(int4x4 v);
        public static double4x4 double4x4(uint v);
        public static double4x4 double4x4(uint4x4 v);
        public static double4x4 double4x4(float v);
        public static double4x4 double4x4(float4x4 v);
        public static double3 rotate(double4x4 a, double3 b);
        public static double3 transform(double4x4 a, double3 b);
        public static double4x4 transpose(double4x4 v);
        public static double4x4 inverse(double4x4 m);
        public static double4x4 fastinverse(double4x4 m);
        public static double determinant(double4x4 m);
        public static uint hash(double4x4 v);
        public static uint4 hashwide(double4x4 v);
        public static float2 float2(float x, float y);
        public static float2 float2(float2 xy);
        public static float2 float2(float v);
        public static float2 float2(bool v);
        public static float2 float2(bool2 v);
        public static float2 float2(int v);
        public static float2 float2(int2 v);
        public static float2 float2(uint v);
        public static float2 float2(uint2 v);
        public static float2 float2(half v);
        public static float2 float2(half2 v);
        public static float2 float2(double v);
        public static float2 float2(double2 v);
        public static uint hash(float2 v);
        public static uint2 hashwide(float2 v);
        public static float shuffle(float2 a, float2 b, ShuffleComponent x);
        public static float2 shuffle(float2 a, float2 b, ShuffleComponent x, ShuffleComponent y);
        public static float3 shuffle(float2 a, float2 b, ShuffleComponent x, ShuffleComponent y, ShuffleComponent z);
        public static float4 shuffle(float2 a, float2 b, ShuffleComponent x, ShuffleComponent y, ShuffleComponent z, ShuffleComponent w);
        public static float2x2 float2x2(float2 c0, float2 c1);
        public static float2x2 float2x2(float m00, float m01, float m10, float m11);
        public static float2x2 float2x2(float v);
        public static float2x2 float2x2(bool v);
        public static float2x2 float2x2(bool2x2 v);
        public static float2x2 float2x2(int v);
        public static float2x2 float2x2(int2x2 v);
        public static float2x2 float2x2(uint v);
        public static float2x2 float2x2(uint2x2 v);
        public static float2x2 float2x2(double v);
        public static float2x2 float2x2(double2x2 v);
        public static float2x2 transpose(float2x2 v);
        public static float2x2 inverse(float2x2 m);
        public static float determinant(float2x2 m);
        public static uint hash(float2x2 v);
        public static uint2 hashwide(float2x2 v);
        public static float2x3 float2x3(float2 c0, float2 c1, float2 c2);
        public static float2x3 float2x3(float m00, float m01, float m02, float m10, float m11, float m12);
        public static float2x3 float2x3(float v);
        public static float2x3 float2x3(bool v);
        public static float2x3 float2x3(bool2x3 v);
        public static float2x3 float2x3(int v);
        public static float2x3 float2x3(int2x3 v);
        public static float2x3 float2x3(uint v);
        public static float2x3 float2x3(uint2x3 v);
        public static float2x3 float2x3(double v);
        public static float2x3 float2x3(double2x3 v);
        public static float3x2 transpose(float2x3 v);
        public static uint hash(float2x3 v);
        public static uint2 hashwide(float2x3 v);
        public static float2x4 float2x4(float2 c0, float2 c1, float2 c2, float2 c3);
        public static float2x4 float2x4(float m00, float m01, float m02, float m03, float m10, float m11, float m12, float m13);
        public static float2x4 float2x4(float v);
        public static float2x4 float2x4(bool v);
        public static float2x4 float2x4(bool2x4 v);
        public static float2x4 float2x4(int v);
        public static float2x4 float2x4(int2x4 v);
        public static float2x4 float2x4(uint v);
        public static float2x4 float2x4(uint2x4 v);
        public static float2x4 float2x4(double v);
        public static float2x4 float2x4(double2x4 v);
        public static float4x2 transpose(float2x4 v);
        public static uint hash(float2x4 v);
        public static uint2 hashwide(float2x4 v);
        public static float3 float3(float x, float y, float z);
        public static float3 float3(float x, float2 yz);
        public static float3 float3(float2 xy, float z);
        public static float3 float3(float3 xyz);
        public static float3 float3(float v);
        public static float3 float3(bool v);
        public static float3 float3(bool3 v);
        public static float3 float3(int v);
        public static float3 float3(int3 v);
        public static float3 float3(uint v);
        public static float3 float3(uint3 v);
        public static float3 float3(half v);
        public static float3 float3(half3 v);
        public static float3 float3(double v);
        public static float3 float3(double3 v);
        public static uint hash(float3 v);
        public static uint3 hashwide(float3 v);
        public static float shuffle(float3 a, float3 b, ShuffleComponent x);
        public static float2 shuffle(float3 a, float3 b, ShuffleComponent x, ShuffleComponent y);
        public static float3 shuffle(float3 a, float3 b, ShuffleComponent x, ShuffleComponent y, ShuffleComponent z);
        public static float4 shuffle(float3 a, float3 b, ShuffleComponent x, ShuffleComponent y, ShuffleComponent z, ShuffleComponent w);
        public static float3x2 float3x2(float3 c0, float3 c1);
        public static float3x2 float3x2(float m00, float m01, float m10, float m11, float m20, float m21);
        public static float3x2 float3x2(float v);
        public static float3x2 float3x2(bool v);
        public static float3x2 float3x2(bool3x2 v);
        public static float3x2 float3x2(int v);
        public static float3x2 float3x2(int3x2 v);
        public static float3x2 float3x2(uint v);
        public static float3x2 float3x2(uint3x2 v);
        public static float3x2 float3x2(double v);
        public static float3x2 float3x2(double3x2 v);
        public static float2x3 transpose(float3x2 v);
        public static uint hash(float3x2 v);
        public static uint3 hashwide(float3x2 v);
        public static float3x3 float3x3(float3 c0, float3 c1, float3 c2);
        public static float3x3 float3x3(float m00, float m01, float m02, float m10, float m11, float m12, float m20, float m21, float m22);
        public static float3x3 float3x3(float v);
        public static float3x3 float3x3(bool v);
        public static float3x3 float3x3(bool3x3 v);
        public static float3x3 float3x3(int v);
        public static float3x3 float3x3(int3x3 v);
        public static float3x3 float3x3(uint v);
        public static float3x3 float3x3(uint3x3 v);
        public static float3x3 float3x3(double v);
        public static float3x3 float3x3(double3x3 v);
        public static float3x3 transpose(float3x3 v);
        public static float3x3 inverse(float3x3 m);
        public static float determinant(float3x3 m);
        public static uint hash(float3x3 v);
        public static uint3 hashwide(float3x3 v);
        public static float3x4 float3x4(float3 c0, float3 c1, float3 c2, float3 c3);
        public static float3x4 float3x4(float m00, float m01, float m02, float m03, float m10, float m11, float m12, float m13, float m20, float m21, float m22, float m23);
        public static float3x4 float3x4(float v);
        public static float3x4 float3x4(bool v);
        public static float3x4 float3x4(bool3x4 v);
        public static float3x4 float3x4(int v);
        public static float3x4 float3x4(int3x4 v);
        public static float3x4 float3x4(uint v);
        public static float3x4 float3x4(uint3x4 v);
        public static float3x4 float3x4(double v);
        public static float3x4 float3x4(double3x4 v);
        public static float4x3 transpose(float3x4 v);
        public static float3x4 fastinverse(float3x4 m);
        public static uint hash(float3x4 v);
        public static uint3 hashwide(float3x4 v);
        public static float4 float4(float x, float y, float z, float w);
        public static float4 float4(float x, float y, float2 zw);
        public static float4 float4(float x, float2 yz, float w);
        public static float4 float4(float x, float3 yzw);
        public static float4 float4(float2 xy, float z, float w);
        public static float4 float4(float2 xy, float2 zw);
        public static float4 float4(float3 xyz, float w);
        public static float4 float4(float4 xyzw);
        public static float4 float4(float v);
        public static float4 float4(bool v);
        public static float4 float4(bool4 v);
        public static float4 float4(int v);
        public static float4 float4(int4 v);
        public static float4 float4(uint v);
        public static float4 float4(uint4 v);
        public static float4 float4(half v);
        public static float4 float4(half4 v);
        public static float4 float4(double v);
        public static float4 float4(double4 v);
        public static uint hash(float4 v);
        public static uint4 hashwide(float4 v);
        public static float shuffle(float4 a, float4 b, ShuffleComponent x);
        public static float2 shuffle(float4 a, float4 b, ShuffleComponent x, ShuffleComponent y);
        public static float3 shuffle(float4 a, float4 b, ShuffleComponent x, ShuffleComponent y, ShuffleComponent z);
        public static float4 shuffle(float4 a, float4 b, ShuffleComponent x, ShuffleComponent y, ShuffleComponent z, ShuffleComponent w);
        public static float4x2 float4x2(float4 c0, float4 c1);
        public static float4x2 float4x2(float m00, float m01, float m10, float m11, float m20, float m21, float m30, float m31);
        public static float4x2 float4x2(float v);
        public static float4x2 float4x2(bool v);
        public static float4x2 float4x2(bool4x2 v);
        public static float4x2 float4x2(int v);
        public static float4x2 float4x2(int4x2 v);
        public static float4x2 float4x2(uint v);
        public static float4x2 float4x2(uint4x2 v);
        public static float4x2 float4x2(double v);
        public static float4x2 float4x2(double4x2 v);
        public static float2x4 transpose(float4x2 v);
        public static uint hash(float4x2 v);
        public static uint4 hashwide(float4x2 v);
        public static float4x3 float4x3(float4 c0, float4 c1, float4 c2);
        public static float4x3 float4x3(float m00, float m01, float m02, float m10, float m11, float m12, float m20, float m21, float m22, float m30, float m31, float m32);
        public static float4x3 float4x3(float v);
        public static float4x3 float4x3(bool v);
        public static float4x3 float4x3(bool4x3 v);
        public static float4x3 float4x3(int v);
        public static float4x3 float4x3(int4x3 v);
        public static float4x3 float4x3(uint v);
        public static float4x3 float4x3(uint4x3 v);
        public static float4x3 float4x3(double v);
        public static float4x3 float4x3(double4x3 v);
        public static float3x4 transpose(float4x3 v);
        public static uint hash(float4x3 v);
        public static uint4 hashwide(float4x3 v);
        public static float4x4 float4x4(float4 c0, float4 c1, float4 c2, float4 c3);
        public static float4x4 float4x4(float m00, float m01, float m02, float m03, float m10, float m11, float m12, float m13, float m20, float m21, float m22, float m23, float m30, float m31, float m32, float m33);
        public static float4x4 float4x4(float v);
        public static float4x4 float4x4(bool v);
        public static float4x4 float4x4(bool4x4 v);
        public static float4x4 float4x4(int v);
        public static float4x4 float4x4(int4x4 v);
        public static float4x4 float4x4(uint v);
        public static float4x4 float4x4(uint4x4 v);
        public static float4x4 float4x4(double v);
        public static float4x4 float4x4(double4x4 v);
        public static float3 rotate(float4x4 a, float3 b);
        public static float3 transform(float4x4 a, float3 b);
        public static float4x4 transpose(float4x4 v);
        public static float4x4 inverse(float4x4 m);
        public static float4x4 fastinverse(float4x4 m);
        public static float determinant(float4x4 m);
        public static uint hash(float4x4 v);
        public static uint4 hashwide(float4x4 v);
        public static half half(half x);
        public static half half(float v);
        public static half half(double v);
        public static uint hash(half v);
        public static half2 half2(half x, half y);
        public static half2 half2(half2 xy);
        public static half2 half2(half v);
        public static half2 half2(float v);
        public static half2 half2(float2 v);
        public static half2 half2(double v);
        public static half2 half2(double2 v);
        public static uint hash(half2 v);
        public static uint2 hashwide(half2 v);
        public static half3 half3(half x, half y, half z);
        public static half3 half3(half x, half2 yz);
        public static half3 half3(half2 xy, half z);
        public static half3 half3(half3 xyz);
        public static half3 half3(half v);
        public static half3 half3(float v);
        public static half3 half3(float3 v);
        public static half3 half3(double v);
        public static half3 half3(double3 v);
        public static uint hash(half3 v);
        public static uint3 hashwide(half3 v);
        public static half4 half4(half x, half y, half z, half w);
        public static half4 half4(half x, half y, half2 zw);
        public static half4 half4(half x, half2 yz, half w);
        public static half4 half4(half x, half3 yzw);
        public static half4 half4(half2 xy, half z, half w);
        public static half4 half4(half2 xy, half2 zw);
        public static half4 half4(half3 xyz, half w);
        public static half4 half4(half4 xyzw);
        public static half4 half4(half v);
        public static half4 half4(float v);
        public static half4 half4(float4 v);
        public static half4 half4(double v);
        public static half4 half4(double4 v);
        public static uint hash(half4 v);
        public static uint4 hashwide(half4 v);
        public static int2 int2(int x, int y);
        public static int2 int2(int2 xy);
        public static int2 int2(int v);
        public static int2 int2(bool v);
        public static int2 int2(bool2 v);
        public static int2 int2(uint v);
        public static int2 int2(uint2 v);
        public static int2 int2(float v);
        public static int2 int2(float2 v);
        public static int2 int2(double v);
        public static int2 int2(double2 v);
        public static uint hash(int2 v);
        public static uint2 hashwide(int2 v);
        public static int shuffle(int2 a, int2 b, ShuffleComponent x);
        public static int2 shuffle(int2 a, int2 b, ShuffleComponent x, ShuffleComponent y);
        public static int3 shuffle(int2 a, int2 b, ShuffleComponent x, ShuffleComponent y, ShuffleComponent z);
        public static int4 shuffle(int2 a, int2 b, ShuffleComponent x, ShuffleComponent y, ShuffleComponent z, ShuffleComponent w);
        public static int2x2 int2x2(int2 c0, int2 c1);
        public static int2x2 int2x2(int m00, int m01, int m10, int m11);
        public static int2x2 int2x2(int v);
        public static int2x2 int2x2(bool v);
        public static int2x2 int2x2(bool2x2 v);
        public static int2x2 int2x2(uint v);
        public static int2x2 int2x2(uint2x2 v);
        public static int2x2 int2x2(float v);
        public static int2x2 int2x2(float2x2 v);
        public static int2x2 int2x2(double v);
        public static int2x2 int2x2(double2x2 v);
        public static int2x2 transpose(int2x2 v);
        public static int determinant(int2x2 m);
        public static uint hash(int2x2 v);
        public static uint2 hashwide(int2x2 v);
        public static int2x3 int2x3(int2 c0, int2 c1, int2 c2);
        public static int2x3 int2x3(int m00, int m01, int m02, int m10, int m11, int m12);
        public static int2x3 int2x3(int v);
        public static int2x3 int2x3(bool v);
        public static int2x3 int2x3(bool2x3 v);
        public static int2x3 int2x3(uint v);
        public static int2x3 int2x3(uint2x3 v);
        public static int2x3 int2x3(float v);
        public static int2x3 int2x3(float2x3 v);
        public static int2x3 int2x3(double v);
        public static int2x3 int2x3(double2x3 v);
        public static int3x2 transpose(int2x3 v);
        public static uint hash(int2x3 v);
        public static uint2 hashwide(int2x3 v);
        public static int2x4 int2x4(int2 c0, int2 c1, int2 c2, int2 c3);
        public static int2x4 int2x4(int m00, int m01, int m02, int m03, int m10, int m11, int m12, int m13);
        public static int2x4 int2x4(int v);
        public static int2x4 int2x4(bool v);
        public static int2x4 int2x4(bool2x4 v);
        public static int2x4 int2x4(uint v);
        public static int2x4 int2x4(uint2x4 v);
        public static int2x4 int2x4(float v);
        public static int2x4 int2x4(float2x4 v);
        public static int2x4 int2x4(double v);
        public static int2x4 int2x4(double2x4 v);
        public static int4x2 transpose(int2x4 v);
        public static uint hash(int2x4 v);
        public static uint2 hashwide(int2x4 v);
        public static int3 int3(int x, int y, int z);
        public static int3 int3(int x, int2 yz);
        public static int3 int3(int2 xy, int z);
        public static int3 int3(int3 xyz);
        public static int3 int3(int v);
        public static int3 int3(bool v);
        public static int3 int3(bool3 v);
        public static int3 int3(uint v);
        public static int3 int3(uint3 v);
        public static int3 int3(float v);
        public static int3 int3(float3 v);
        public static int3 int3(double v);
        public static int3 int3(double3 v);
        public static uint hash(int3 v);
        public static uint3 hashwide(int3 v);
        public static int shuffle(int3 a, int3 b, ShuffleComponent x);
        public static int2 shuffle(int3 a, int3 b, ShuffleComponent x, ShuffleComponent y);
        public static int3 shuffle(int3 a, int3 b, ShuffleComponent x, ShuffleComponent y, ShuffleComponent z);
        public static int4 shuffle(int3 a, int3 b, ShuffleComponent x, ShuffleComponent y, ShuffleComponent z, ShuffleComponent w);
        public static int3x2 int3x2(int3 c0, int3 c1);
        public static int3x2 int3x2(int m00, int m01, int m10, int m11, int m20, int m21);
        public static int3x2 int3x2(int v);
        public static int3x2 int3x2(bool v);
        public static int3x2 int3x2(bool3x2 v);
        public static int3x2 int3x2(uint v);
        public static int3x2 int3x2(uint3x2 v);
        public static int3x2 int3x2(float v);
        public static int3x2 int3x2(float3x2 v);
        public static int3x2 int3x2(double v);
        public static int3x2 int3x2(double3x2 v);
        public static int2x3 transpose(int3x2 v);
        public static uint hash(int3x2 v);
        public static uint3 hashwide(int3x2 v);
        public static int3x3 int3x3(int3 c0, int3 c1, int3 c2);
        public static int3x3 int3x3(int m00, int m01, int m02, int m10, int m11, int m12, int m20, int m21, int m22);
        public static int3x3 int3x3(int v);
        public static int3x3 int3x3(bool v);
        public static int3x3 int3x3(bool3x3 v);
        public static int3x3 int3x3(uint v);
        public static int3x3 int3x3(uint3x3 v);
        public static int3x3 int3x3(float v);
        public static int3x3 int3x3(float3x3 v);
        public static int3x3 int3x3(double v);
        public static int3x3 int3x3(double3x3 v);
        public static int3x3 transpose(int3x3 v);
        public static int determinant(int3x3 m);
        public static uint hash(int3x3 v);
        public static uint3 hashwide(int3x3 v);
        public static int3x4 int3x4(int3 c0, int3 c1, int3 c2, int3 c3);
        public static int3x4 int3x4(int m00, int m01, int m02, int m03, int m10, int m11, int m12, int m13, int m20, int m21, int m22, int m23);
        public static int3x4 int3x4(int v);
        public static int3x4 int3x4(bool v);
        public static int3x4 int3x4(bool3x4 v);
        public static int3x4 int3x4(uint v);
        public static int3x4 int3x4(uint3x4 v);
        public static int3x4 int3x4(float v);
        public static int3x4 int3x4(float3x4 v);
        public static int3x4 int3x4(double v);
        public static int3x4 int3x4(double3x4 v);
        public static int4x3 transpose(int3x4 v);
        public static uint hash(int3x4 v);
        public static uint3 hashwide(int3x4 v);
        public static int4 int4(int x, int y, int z, int w);
        public static int4 int4(int x, int y, int2 zw);
        public static int4 int4(int x, int2 yz, int w);
        public static int4 int4(int x, int3 yzw);
        public static int4 int4(int2 xy, int z, int w);
        public static int4 int4(int2 xy, int2 zw);
        public static int4 int4(int3 xyz, int w);
        public static int4 int4(int4 xyzw);
        public static int4 int4(int v);
        public static int4 int4(bool v);
        public static int4 int4(bool4 v);
        public static int4 int4(uint v);
        public static int4 int4(uint4 v);
        public static int4 int4(float v);
        public static int4 int4(float4 v);
        public static int4 int4(double v);
        public static int4 int4(double4 v);
        public static uint hash(int4 v);
        public static uint4 hashwide(int4 v);
        public static int shuffle(int4 a, int4 b, ShuffleComponent x);
        public static int2 shuffle(int4 a, int4 b, ShuffleComponent x, ShuffleComponent y);
        public static int3 shuffle(int4 a, int4 b, ShuffleComponent x, ShuffleComponent y, ShuffleComponent z);
        public static int4 shuffle(int4 a, int4 b, ShuffleComponent x, ShuffleComponent y, ShuffleComponent z, ShuffleComponent w);
        public static int4x2 int4x2(int4 c0, int4 c1);
        public static int4x2 int4x2(int m00, int m01, int m10, int m11, int m20, int m21, int m30, int m31);
        public static int4x2 int4x2(int v);
        public static int4x2 int4x2(bool v);
        public static int4x2 int4x2(bool4x2 v);
        public static int4x2 int4x2(uint v);
        public static int4x2 int4x2(uint4x2 v);
        public static int4x2 int4x2(float v);
        public static int4x2 int4x2(float4x2 v);
        public static int4x2 int4x2(double v);
        public static int4x2 int4x2(double4x2 v);
        public static int2x4 transpose(int4x2 v);
        public static uint hash(int4x2 v);
        public static uint4 hashwide(int4x2 v);
        public static int4x3 int4x3(int4 c0, int4 c1, int4 c2);
        public static int4x3 int4x3(int m00, int m01, int m02, int m10, int m11, int m12, int m20, int m21, int m22, int m30, int m31, int m32);
        public static int4x3 int4x3(int v);
        public static int4x3 int4x3(bool v);
        public static int4x3 int4x3(bool4x3 v);
        public static int4x3 int4x3(uint v);
        public static int4x3 int4x3(uint4x3 v);
        public static int4x3 int4x3(float v);
        public static int4x3 int4x3(float4x3 v);
        public static int4x3 int4x3(double v);
        public static int4x3 int4x3(double4x3 v);
        public static int3x4 transpose(int4x3 v);
        public static uint hash(int4x3 v);
        public static uint4 hashwide(int4x3 v);
        public static int4x4 int4x4(int4 c0, int4 c1, int4 c2, int4 c3);
        public static int4x4 int4x4(int m00, int m01, int m02, int m03, int m10, int m11, int m12, int m13, int m20, int m21, int m22, int m23, int m30, int m31, int m32, int m33);
        public static int4x4 int4x4(int v);
        public static int4x4 int4x4(bool v);
        public static int4x4 int4x4(bool4x4 v);
        public static int4x4 int4x4(uint v);
        public static int4x4 int4x4(uint4x4 v);
        public static int4x4 int4x4(float v);
        public static int4x4 int4x4(float4x4 v);
        public static int4x4 int4x4(double v);
        public static int4x4 int4x4(double4x4 v);
        public static int4x4 transpose(int4x4 v);
        public static int determinant(int4x4 m);
        public static uint hash(int4x4 v);
        public static uint4 hashwide(int4x4 v);
        public static int asint(uint x);
        public static int2 asint(uint2 x);
        public static int3 asint(uint3 x);
        public static int4 asint(uint4 x);
        public static int asint(float x);
        public static int2 asint(float2 x);
        public static int3 asint(float3 x);
        public static int4 asint(float4 x);
        public static uint asuint(int x);
        public static uint2 asuint(int2 x);
        public static uint3 asuint(int3 x);
        public static uint4 asuint(int4 x);
        public static uint asuint(float x);
        public static uint2 asuint(float2 x);
        public static uint3 asuint(float3 x);
        public static uint4 asuint(float4 x);
        public static long aslong(ulong x);
        public static long aslong(double x);
        public static ulong asulong(long x);
        public static ulong asulong(double x);
        public static float asfloat(int x);
        public static float2 asfloat(int2 x);
        public static float3 asfloat(int3 x);
        public static float4 asfloat(int4 x);
        public static float asfloat(uint x);
        public static float2 asfloat(uint2 x);
        public static float3 asfloat(uint3 x);
        public static float4 asfloat(uint4 x);
        public static int bitmask(bool4 value);
        public static double asdouble(long x);
        public static double asdouble(ulong x);
        public static bool isfinite(float x);
        public static bool2 isfinite(float2 x);
        public static bool3 isfinite(float3 x);
        public static bool4 isfinite(float4 x);
        public static bool isfinite(double x);
        public static bool2 isfinite(double2 x);
        public static bool3 isfinite(double3 x);
        public static bool4 isfinite(double4 x);
        public static bool isinf(float x);
        public static bool2 isinf(float2 x);
        public static bool3 isinf(float3 x);
        public static bool4 isinf(float4 x);
        public static bool isinf(double x);
        public static bool2 isinf(double2 x);
        public static bool3 isinf(double3 x);
        public static bool4 isinf(double4 x);
        public static bool isnan(float x);
        public static bool2 isnan(float2 x);
        public static bool3 isnan(float3 x);
        public static bool4 isnan(float4 x);
        public static bool isnan(double x);
        public static bool2 isnan(double2 x);
        public static bool3 isnan(double3 x);
        public static bool4 isnan(double4 x);
        public static int min(int x, int y);
        public static int2 min(int2 x, int2 y);
        public static int3 min(int3 x, int3 y);
        public static int4 min(int4 x, int4 y);
        public static uint min(uint x, uint y);
        public static uint2 min(uint2 x, uint2 y);
        public static uint3 min(uint3 x, uint3 y);
        public static uint4 min(uint4 x, uint4 y);
        public static long min(long x, long y);
        public static ulong min(ulong x, ulong y);
        public static float min(float x, float y);
        public static float2 min(float2 x, float2 y);
        public static float3 min(float3 x, float3 y);
        public static float4 min(float4 x, float4 y);
        public static double min(double x, double y);
        public static double2 min(double2 x, double2 y);
        public static double3 min(double3 x, double3 y);
        public static double4 min(double4 x, double4 y);
        public static int max(int x, int y);
        public static int2 max(int2 x, int2 y);
        public static int3 max(int3 x, int3 y);
        public static int4 max(int4 x, int4 y);
        public static uint max(uint x, uint y);
        public static uint2 max(uint2 x, uint2 y);
        public static uint3 max(uint3 x, uint3 y);
        public static uint4 max(uint4 x, uint4 y);
        public static long max(long x, long y);
        public static ulong max(ulong x, ulong y);
        public static float max(float x, float y);
        public static float2 max(float2 x, float2 y);
        public static float3 max(float3 x, float3 y);
        public static float4 max(float4 x, float4 y);
        public static double max(double x, double y);
        public static double2 max(double2 x, double2 y);
        public static double3 max(double3 x, double3 y);
        public static double4 max(double4 x, double4 y);
        public static float lerp(float x, float y, float s);
        public static float2 lerp(float2 x, float2 y, float s);
        public static float3 lerp(float3 x, float3 y, float s);
        public static float4 lerp(float4 x, float4 y, float s);
        public static float2 lerp(float2 x, float2 y, float2 s);
        public static float3 lerp(float3 x, float3 y, float3 s);
        public static float4 lerp(float4 x, float4 y, float4 s);
        public static double lerp(double x, double y, double s);
        public static double2 lerp(double2 x, double2 y, double s);
        public static double3 lerp(double3 x, double3 y, double s);
        public static double4 lerp(double4 x, double4 y, double s);
        public static double2 lerp(double2 x, double2 y, double2 s);
        public static double3 lerp(double3 x, double3 y, double3 s);
        public static double4 lerp(double4 x, double4 y, double4 s);
        public static float unlerp(float a, float b, float x);
        public static float2 unlerp(float2 a, float2 b, float2 x);
        public static float3 unlerp(float3 a, float3 b, float3 x);
        public static float4 unlerp(float4 a, float4 b, float4 x);
        public static double unlerp(double a, double b, double x);
        public static double2 unlerp(double2 a, double2 b, double2 x);
        public static double3 unlerp(double3 a, double3 b, double3 x);
        public static double4 unlerp(double4 a, double4 b, double4 x);
        public static float remap(float a, float b, float c, float d, float x);
        public static float2 remap(float2 a, float2 b, float2 c, float2 d, float2 x);
        public static float3 remap(float3 a, float3 b, float3 c, float3 d, float3 x);
        public static float4 remap(float4 a, float4 b, float4 c, float4 d, float4 x);
        public static double remap(double a, double b, double c, double d, double x);
        public static double2 remap(double2 a, double2 b, double2 c, double2 d, double2 x);
        public static double3 remap(double3 a, double3 b, double3 c, double3 d, double3 x);
        public static double4 remap(double4 a, double4 b, double4 c, double4 d, double4 x);
        public static int mad(int a, int b, int c);
        public static int2 mad(int2 a, int2 b, int2 c);
        public static int3 mad(int3 a, int3 b, int3 c);
        public static int4 mad(int4 a, int4 b, int4 c);
        public static uint mad(uint a, uint b, uint c);
        public static uint2 mad(uint2 a, uint2 b, uint2 c);
        public static uint3 mad(uint3 a, uint3 b, uint3 c);
        public static uint4 mad(uint4 a, uint4 b, uint4 c);
        public static long mad(long a, long b, long c);
        public static ulong mad(ulong a, ulong b, ulong c);
        public static float mad(float a, float b, float c);
        public static float2 mad(float2 a, float2 b, float2 c);
        public static float3 mad(float3 a, float3 b, float3 c);
        public static float4 mad(float4 a, float4 b, float4 c);
        public static double mad(double a, double b, double c);
        public static double2 mad(double2 a, double2 b, double2 c);
        public static double3 mad(double3 a, double3 b, double3 c);
        public static double4 mad(double4 a, double4 b, double4 c);
        public static int clamp(int x, int a, int b);
        public static int2 clamp(int2 x, int2 a, int2 b);
        public static int3 clamp(int3 x, int3 a, int3 b);
        public static int4 clamp(int4 x, int4 a, int4 b);
        public static uint clamp(uint x, uint a, uint b);
        public static uint2 clamp(uint2 x, uint2 a, uint2 b);
        public static uint3 clamp(uint3 x, uint3 a, uint3 b);
        public static uint4 clamp(uint4 x, uint4 a, uint4 b);
        public static long clamp(long x, long a, long b);
        public static ulong clamp(ulong x, ulong a, ulong b);
        public static float clamp(float x, float a, float b);
        public static float2 clamp(float2 x, float2 a, float2 b);
        public static float3 clamp(float3 x, float3 a, float3 b);
        public static float4 clamp(float4 x, float4 a, float4 b);
        public static double clamp(double x, double a, double b);
        public static double2 clamp(double2 x, double2 a, double2 b);
        public static double3 clamp(double3 x, double3 a, double3 b);
        public static double4 clamp(double4 x, double4 a, double4 b);
        public static float saturate(float x);
        public static float2 saturate(float2 x);
        public static float3 saturate(float3 x);
        public static float4 saturate(float4 x);
        public static double saturate(double x);
        public static double2 saturate(double2 x);
        public static double3 saturate(double3 x);
        public static double4 saturate(double4 x);
        public static int abs(int x);
        public static int2 abs(int2 x);
        public static int3 abs(int3 x);
        public static int4 abs(int4 x);
        public static long abs(long x);
        public static float abs(float x);
        public static float2 abs(float2 x);
        public static float3 abs(float3 x);
        public static float4 abs(float4 x);
        public static double abs(double x);
        public static double2 abs(double2 x);
        public static double3 abs(double3 x);
        public static double4 abs(double4 x);
        public static int dot(int x, int y);
        public static int dot(int2 x, int2 y);
        public static int dot(int3 x, int3 y);
        public static int dot(int4 x, int4 y);
        public static uint dot(uint x, uint y);
        public static uint dot(uint2 x, uint2 y);
        public static uint dot(uint3 x, uint3 y);
        public static uint dot(uint4 x, uint4 y);
        public static float dot(float x, float y);
        public static float dot(float2 x, float2 y);
        public static float dot(float3 x, float3 y);
        public static float dot(float4 x, float4 y);
        public static double dot(double x, double y);
        public static double dot(double2 x, double2 y);
        public static double dot(double3 x, double3 y);
        public static double dot(double4 x, double4 y);
        public static float tan(float x);
        public static float2 tan(float2 x);
        public static float3 tan(float3 x);
        public static float4 tan(float4 x);
        public static double tan(double x);
        public static double2 tan(double2 x);
        public static double3 tan(double3 x);
        public static double4 tan(double4 x);
        public static float tanh(float x);
        public static float2 tanh(float2 x);
        public static float3 tanh(float3 x);
        public static float4 tanh(float4 x);
        public static double tanh(double x);
        public static double2 tanh(double2 x);
        public static double3 tanh(double3 x);
        public static double4 tanh(double4 x);
        public static float atan(float x);
        public static float2 atan(float2 x);
        public static float3 atan(float3 x);
        public static float4 atan(float4 x);
        public static double atan(double x);
        public static double2 atan(double2 x);
        public static double3 atan(double3 x);
        public static double4 atan(double4 x);
        public static float atan2(float y, float x);
        public static float2 atan2(float2 y, float2 x);
        public static float3 atan2(float3 y, float3 x);
        public static float4 atan2(float4 y, float4 x);
        public static double atan2(double y, double x);
        public static double2 atan2(double2 y, double2 x);
        public static double3 atan2(double3 y, double3 x);
        public static double4 atan2(double4 y, double4 x);
        public static float cos(float x);
        public static float2 cos(float2 x);
        public static float3 cos(float3 x);
        public static float4 cos(float4 x);
        public static double cos(double x);
        public static double2 cos(double2 x);
        public static double3 cos(double3 x);
        public static double4 cos(double4 x);
        public static float cosh(float x);
        public static float2 cosh(float2 x);
        public static float3 cosh(float3 x);
        public static float4 cosh(float4 x);
        public static double cosh(double x);
        public static double2 cosh(double2 x);
        public static double3 cosh(double3 x);
        public static double4 cosh(double4 x);
        public static float acos(float x);
        public static float2 acos(float2 x);
        public static float3 acos(float3 x);
        public static float4 acos(float4 x);
        public static double acos(double x);
        public static double2 acos(double2 x);
        public static double3 acos(double3 x);
        public static double4 acos(double4 x);
        public static float sin(float x);
        public static float2 sin(float2 x);
        public static float3 sin(float3 x);
        public static float4 sin(float4 x);
        public static double sin(double x);
        public static double2 sin(double2 x);
        public static double3 sin(double3 x);
        public static double4 sin(double4 x);
        public static float sinh(float x);
        public static float2 sinh(float2 x);
        public static float3 sinh(float3 x);
        public static float4 sinh(float4 x);
        public static double sinh(double x);
        public static double2 sinh(double2 x);
        public static double3 sinh(double3 x);
        public static double4 sinh(double4 x);
        public static float asin(float x);
        public static float2 asin(float2 x);
        public static float3 asin(float3 x);
        public static float4 asin(float4 x);
        public static double asin(double x);
        public static double2 asin(double2 x);
        public static double3 asin(double3 x);
        public static double4 asin(double4 x);
        public static float floor(float x);
        public static float2 floor(float2 x);
        public static float3 floor(float3 x);
        public static float4 floor(float4 x);
        public static double floor(double x);
        public static double2 floor(double2 x);
        public static double3 floor(double3 x);
        public static double4 floor(double4 x);
        public static float ceil(float x);
        public static float2 ceil(float2 x);
        public static float3 ceil(float3 x);
        public static float4 ceil(float4 x);
        public static double ceil(double x);
        public static double2 ceil(double2 x);
        public static double3 ceil(double3 x);
        public static double4 ceil(double4 x);
        public static float round(float x);
        public static float2 round(float2 x);
        public static float3 round(float3 x);
        public static float4 round(float4 x);
        public static double round(double x);
        public static double2 round(double2 x);
        public static double3 round(double3 x);
        public static double4 round(double4 x);
        public static float trunc(float x);
        public static float2 trunc(float2 x);
        public static float3 trunc(float3 x);
        public static float4 trunc(float4 x);
        public static double trunc(double x);
        public static double2 trunc(double2 x);
        public static double3 trunc(double3 x);
        public static double4 trunc(double4 x);
        public static float frac(float x);
        public static float2 frac(float2 x);
        public static float3 frac(float3 x);
        public static float4 frac(float4 x);
        public static double frac(double x);
        public static double2 frac(double2 x);
        public static double3 frac(double3 x);
        public static double4 frac(double4 x);
        public static float rcp(float x);
        public static float2 rcp(float2 x);
        public static float3 rcp(float3 x);
        public static float4 rcp(float4 x);
        public static double rcp(double x);
        public static double2 rcp(double2 x);
        public static double3 rcp(double3 x);
        public static double4 rcp(double4 x);
        public static float sign(float x);
        public static float2 sign(float2 x);
        public static float3 sign(float3 x);
        public static float4 sign(float4 x);
        public static double sign(double x);
        public static double2 sign(double2 x);
        public static double3 sign(double3 x);
        public static double4 sign(double4 x);
        public static float pow(float x, float y);
        public static float2 pow(float2 x, float2 y);
        public static float3 pow(float3 x, float3 y);
        public static float4 pow(float4 x, float4 y);
        public static double pow(double x, double y);
        public static double2 pow(double2 x, double2 y);
        public static double3 pow(double3 x, double3 y);
        public static double4 pow(double4 x, double4 y);
        public static float exp(float x);
        public static float2 exp(float2 x);
        public static float3 exp(float3 x);
        public static float4 exp(float4 x);
        public static double exp(double x);
        public static double2 exp(double2 x);
        public static double3 exp(double3 x);
        public static double4 exp(double4 x);
        public static float exp2(float x);
        public static float2 exp2(float2 x);
        public static float3 exp2(float3 x);
        public static float4 exp2(float4 x);
        public static double exp2(double x);
        public static double2 exp2(double2 x);
        public static double3 exp2(double3 x);
        public static double4 exp2(double4 x);
        public static float exp10(float x);
        public static float2 exp10(float2 x);
        public static float3 exp10(float3 x);
        public static float4 exp10(float4 x);
        public static double exp10(double x);
        public static double2 exp10(double2 x);
        public static double3 exp10(double3 x);
        public static double4 exp10(double4 x);
        public static float log(float x);
        public static float2 log(float2 x);
        public static float3 log(float3 x);
        public static float4 log(float4 x);
        public static double log(double x);
        public static double2 log(double2 x);
        public static double3 log(double3 x);
        public static double4 log(double4 x);
        public static float log2(float x);
        public static float2 log2(float2 x);
        public static float3 log2(float3 x);
        public static float4 log2(float4 x);
        public static double log2(double x);
        public static double2 log2(double2 x);
        public static double3 log2(double3 x);
        public static double4 log2(double4 x);
        public static float log10(float x);
        public static float2 log10(float2 x);
        public static float3 log10(float3 x);
        public static float4 log10(float4 x);
        public static double log10(double x);
        public static double2 log10(double2 x);
        public static double3 log10(double3 x);
        public static double4 log10(double4 x);
        public static float fmod(float x, float y);
        public static float2 fmod(float2 x, float2 y);
        public static float3 fmod(float3 x, float3 y);
        public static float4 fmod(float4 x, float4 y);
        public static double fmod(double x, double y);
        public static double2 fmod(double2 x, double2 y);
        public static double3 fmod(double3 x, double3 y);
        public static double4 fmod(double4 x, double4 y);
        public static float modf(float x, out float i);
        public static float2 modf(float2 x, out float2 i);
        public static float3 modf(float3 x, out float3 i);
        public static float4 modf(float4 x, out float4 i);
        public static double modf(double x, out double i);
        public static double2 modf(double2 x, out double2 i);
        public static double3 modf(double3 x, out double3 i);
        public static double4 modf(double4 x, out double4 i);
        public static float sqrt(float x);
        public static float2 sqrt(float2 x);
        public static float3 sqrt(float3 x);
        public static float4 sqrt(float4 x);
        public static double sqrt(double x);
        public static double2 sqrt(double2 x);
        public static double3 sqrt(double3 x);
        public static double4 sqrt(double4 x);
        public static float rsqrt(float x);
        public static float2 rsqrt(float2 x);
        public static float3 rsqrt(float3 x);
        public static float4 rsqrt(float4 x);
        public static double rsqrt(double x);
        public static double2 rsqrt(double2 x);
        public static double3 rsqrt(double3 x);
        public static double4 rsqrt(double4 x);
        public static float2 normalize(float2 x);
        public static float3 normalize(float3 x);
        public static float4 normalize(float4 x);
        public static double2 normalize(double2 x);
        public static double3 normalize(double3 x);
        public static double4 normalize(double4 x);
        public static float2 normalizesafe(float2 x, float2 defaultvalue = null);
        public static float3 normalizesafe(float3 x, float3 defaultvalue = null);
        public static float4 normalizesafe(float4 x, float4 defaultvalue = null);
        public static double2 normalizesafe(double2 x, double2 defaultvalue = null);
        public static double3 normalizesafe(double3 x, double3 defaultvalue = null);
        public static double4 normalizesafe(double4 x, double4 defaultvalue = null);
        public static float length(float x);
        public static float length(float2 x);
        public static float length(float3 x);
        public static float length(float4 x);
        public static double length(double x);
        public static double length(double2 x);
        public static double length(double3 x);
        public static double length(double4 x);
        public static float lengthsq(float x);
        public static float lengthsq(float2 x);
        public static float lengthsq(float3 x);
        public static float lengthsq(float4 x);
        public static double lengthsq(double x);
        public static double lengthsq(double2 x);
        public static double lengthsq(double3 x);
        public static double lengthsq(double4 x);
        public static float distance(float x, float y);
        public static float distance(float2 x, float2 y);
        public static float distance(float3 x, float3 y);
        public static float distance(float4 x, float4 y);
        public static double distance(double x, double y);
        public static double distance(double2 x, double2 y);
        public static double distance(double3 x, double3 y);
        public static double distance(double4 x, double4 y);
        public static float distancesq(float x, float y);
        public static float distancesq(float2 x, float2 y);
        public static float distancesq(float3 x, float3 y);
        public static float distancesq(float4 x, float4 y);
        public static double distancesq(double x, double y);
        public static double distancesq(double2 x, double2 y);
        public static double distancesq(double3 x, double3 y);
        public static double distancesq(double4 x, double4 y);
        public static float3 cross(float3 x, float3 y);
        public static double3 cross(double3 x, double3 y);
        public static float smoothstep(float a, float b, float x);
        public static float2 smoothstep(float2 a, float2 b, float2 x);
        public static float3 smoothstep(float3 a, float3 b, float3 x);
        public static float4 smoothstep(float4 a, float4 b, float4 x);
        public static double smoothstep(double a, double b, double x);
        public static double2 smoothstep(double2 a, double2 b, double2 x);
        public static double3 smoothstep(double3 a, double3 b, double3 x);
        public static double4 smoothstep(double4 a, double4 b, double4 x);
        public static bool any(bool2 x);
        public static bool any(bool3 x);
        public static bool any(bool4 x);
        public static bool any(int2 x);
        public static bool any(int3 x);
        public static bool any(int4 x);
        public static bool any(uint2 x);
        public static bool any(uint3 x);
        public static bool any(uint4 x);
        public static bool any(float2 x);
        public static bool any(float3 x);
        public static bool any(float4 x);
        public static bool any(double2 x);
        public static bool any(double3 x);
        public static bool any(double4 x);
        public static bool all(bool2 x);
        public static bool all(bool3 x);
        public static bool all(bool4 x);
        public static bool all(int2 x);
        public static bool all(int3 x);
        public static bool all(int4 x);
        public static bool all(uint2 x);
        public static bool all(uint3 x);
        public static bool all(uint4 x);
        public static bool all(float2 x);
        public static bool all(float3 x);
        public static bool all(float4 x);
        public static bool all(double2 x);
        public static bool all(double3 x);
        public static bool all(double4 x);
        public static int select(int a, int b, bool c);
        public static int2 select(int2 a, int2 b, bool c);
        public static int3 select(int3 a, int3 b, bool c);
        public static int4 select(int4 a, int4 b, bool c);
        public static int2 select(int2 a, int2 b, bool2 c);
        public static int3 select(int3 a, int3 b, bool3 c);
        public static int4 select(int4 a, int4 b, bool4 c);
        public static uint select(uint a, uint b, bool c);
        public static uint2 select(uint2 a, uint2 b, bool c);
        public static uint3 select(uint3 a, uint3 b, bool c);
        public static uint4 select(uint4 a, uint4 b, bool c);
        public static uint2 select(uint2 a, uint2 b, bool2 c);
        public static uint3 select(uint3 a, uint3 b, bool3 c);
        public static uint4 select(uint4 a, uint4 b, bool4 c);
        public static long select(long a, long b, bool c);
        public static ulong select(ulong a, ulong b, bool c);
        public static float select(float a, float b, bool c);
        public static float2 select(float2 a, float2 b, bool c);
        public static float3 select(float3 a, float3 b, bool c);
        public static float4 select(float4 a, float4 b, bool c);
        public static float2 select(float2 a, float2 b, bool2 c);
        public static float3 select(float3 a, float3 b, bool3 c);
        public static float4 select(float4 a, float4 b, bool4 c);
        public static double select(double a, double b, bool c);
        public static double2 select(double2 a, double2 b, bool c);
        public static double3 select(double3 a, double3 b, bool c);
        public static double4 select(double4 a, double4 b, bool c);
        public static double2 select(double2 a, double2 b, bool2 c);
        public static double3 select(double3 a, double3 b, bool3 c);
        public static double4 select(double4 a, double4 b, bool4 c);
        public static float step(float y, float x);
        public static float2 step(float2 y, float2 x);
        public static float3 step(float3 y, float3 x);
        public static float4 step(float4 y, float4 x);
        public static double step(double y, double x);
        public static double2 step(double2 y, double2 x);
        public static double3 step(double3 y, double3 x);
        public static double4 step(double4 y, double4 x);
        public static float2 reflect(float2 i, float2 n);
        public static float3 reflect(float3 i, float3 n);
        public static float4 reflect(float4 i, float4 n);
        public static double2 reflect(double2 i, double2 n);
        public static double3 reflect(double3 i, double3 n);
        public static double4 reflect(double4 i, double4 n);
        public static float2 refract(float2 i, float2 n, float eta);
        public static float3 refract(float3 i, float3 n, float eta);
        public static float4 refract(float4 i, float4 n, float eta);
        public static double2 refract(double2 i, double2 n, double eta);
        public static double3 refract(double3 i, double3 n, double eta);
        public static double4 refract(double4 i, double4 n, double eta);
        public static float2 faceforward(float2 n, float2 i, float2 ng);
        public static float3 faceforward(float3 n, float3 i, float3 ng);
        public static float4 faceforward(float4 n, float4 i, float4 ng);
        public static double2 faceforward(double2 n, double2 i, double2 ng);
        public static double3 faceforward(double3 n, double3 i, double3 ng);
        public static double4 faceforward(double4 n, double4 i, double4 ng);
        public static void sincos(float x, out float s, out float c);
        public static void sincos(float2 x, out float2 s, out float2 c);
        public static void sincos(float3 x, out float3 s, out float3 c);
        public static void sincos(float4 x, out float4 s, out float4 c);
        public static void sincos(double x, out double s, out double c);
        public static void sincos(double2 x, out double2 s, out double2 c);
        public static void sincos(double3 x, out double3 s, out double3 c);
        public static void sincos(double4 x, out double4 s, out double4 c);
        public static int countbits(int x);
        public static int2 countbits(int2 x);
        public static int3 countbits(int3 x);
        public static int4 countbits(int4 x);
        public static int countbits(uint x);
        public static int2 countbits(uint2 x);
        public static int3 countbits(uint3 x);
        public static int4 countbits(uint4 x);
        public static int countbits(ulong x);
        public static int countbits(long x);
        public static int lzcnt(int x);
        public static int2 lzcnt(int2 x);
        public static int3 lzcnt(int3 x);
        public static int4 lzcnt(int4 x);
        public static int lzcnt(uint x);
        public static int2 lzcnt(uint2 x);
        public static int3 lzcnt(uint3 x);
        public static int4 lzcnt(uint4 x);
        public static int lzcnt(long x);
        public static int lzcnt(ulong x);
        public static int tzcnt(int x);
        public static int2 tzcnt(int2 x);
        public static int3 tzcnt(int3 v);
        public static int4 tzcnt(int4 v);
        public static int tzcnt(uint x);
        public static int2 tzcnt(uint2 x);
        public static int3 tzcnt(uint3 x);
        public static int4 tzcnt(uint4 x);
        public static int tzcnt(long x);
        public static int tzcnt(ulong x);
        public static int reversebits(int x);
        public static int2 reversebits(int2 x);
        public static int3 reversebits(int3 x);
        public static int4 reversebits(int4 x);
        public static uint reversebits(uint x);
        public static uint2 reversebits(uint2 x);
        public static uint3 reversebits(uint3 x);
        public static uint4 reversebits(uint4 x);
        public static long reversebits(long x);
        public static ulong reversebits(ulong x);
        public static int rol(int x, int n);
        public static int2 rol(int2 x, int n);
        public static int3 rol(int3 x, int n);
        public static int4 rol(int4 x, int n);
        public static uint rol(uint x, int n);
        public static uint2 rol(uint2 x, int n);
        public static uint3 rol(uint3 x, int n);
        public static uint4 rol(uint4 x, int n);
        public static long rol(long x, int n);
        public static ulong rol(ulong x, int n);
        public static int ror(int x, int n);
        public static int2 ror(int2 x, int n);
        public static int3 ror(int3 x, int n);
        public static int4 ror(int4 x, int n);
        public static uint ror(uint x, int n);
        public static uint2 ror(uint2 x, int n);
        public static uint3 ror(uint3 x, int n);
        public static uint4 ror(uint4 x, int n);
        public static long ror(long x, int n);
        public static ulong ror(ulong x, int n);
        public static int ceilpow2(int x);
        public static int2 ceilpow2(int2 x);
        public static int3 ceilpow2(int3 x);
        public static int4 ceilpow2(int4 x);
        public static uint ceilpow2(uint x);
        public static uint2 ceilpow2(uint2 x);
        public static uint3 ceilpow2(uint3 x);
        public static uint4 ceilpow2(uint4 x);
        public static long ceilpow2(long x);
        public static ulong ceilpow2(ulong x);
        public static float radians(float x);
        public static float2 radians(float2 x);
        public static float3 radians(float3 x);
        public static float4 radians(float4 x);
        public static double radians(double x);
        public static double2 radians(double2 x);
        public static double3 radians(double3 x);
        public static double4 radians(double4 x);
        public static float degrees(float x);
        public static float2 degrees(float2 x);
        public static float3 degrees(float3 x);
        public static float4 degrees(float4 x);
        public static double degrees(double x);
        public static double2 degrees(double2 x);
        public static double3 degrees(double3 x);
        public static double4 degrees(double4 x);
        public static int cmin(int2 x);
        public static int cmin(int3 x);
        public static int cmin(int4 x);
        public static uint cmin(uint2 x);
        public static uint cmin(uint3 x);
        public static uint cmin(uint4 x);
        public static float cmin(float2 x);
        public static float cmin(float3 x);
        public static float cmin(float4 x);
        public static double cmin(double2 x);
        public static double cmin(double3 x);
        public static double cmin(double4 x);
        public static int cmax(int2 x);
        public static int cmax(int3 x);
        public static int cmax(int4 x);
        public static uint cmax(uint2 x);
        public static uint cmax(uint3 x);
        public static uint cmax(uint4 x);
        public static float cmax(float2 x);
        public static float cmax(float3 x);
        public static float cmax(float4 x);
        public static double cmax(double2 x);
        public static double cmax(double3 x);
        public static double cmax(double4 x);
        public static int csum(int2 x);
        public static int csum(int3 x);
        public static int csum(int4 x);
        public static uint csum(uint2 x);
        public static uint csum(uint3 x);
        public static uint csum(uint4 x);
        public static float csum(float2 x);
        public static float csum(float3 x);
        public static float csum(float4 x);
        public static double csum(double2 x);
        public static double csum(double3 x);
        public static double csum(double4 x);
        public static int compress(int* output, int index, int4 val, bool4 mask);
        public static float f16tof32(uint x);
        public static float2 f16tof32(uint2 x);
        public static float3 f16tof32(uint3 x);
        public static float4 f16tof32(uint4 x);
        public static uint f32tof16(float x);
        public static uint2 f32tof16(float2 x);
        public static uint3 f32tof16(float3 x);
        public static uint4 f32tof16(float4 x);
        public static uint hash(void* pBuffer, int numBytes, uint seed = 0);
        public static float3 up();
        public static float3x3 float3x3(quaternion rotation);
        public static float4x4 float4x4(float3x3 rotation, float3 translation);
        public static float4x4 float4x4(quaternion rotation, float3 translation);
        public static float4x4 float4x4(RigidTransform transform);
        public static float3x3 orthonormalize(float3x3 i);
        public static float mul(float a, float b);
        public static float mul(float2 a, float2 b);
        public static float2 mul(float2 a, float2x2 b);
        public static float3 mul(float2 a, float2x3 b);
        public static float4 mul(float2 a, float2x4 b);
        public static float mul(float3 a, float3 b);
        public static float2 mul(float3 a, float3x2 b);
        public static float3 mul(float3 a, float3x3 b);
        public static float4 mul(float3 a, float3x4 b);
        public static float mul(float4 a, float4 b);
        public static float2 mul(float4 a, float4x2 b);
        public static float3 mul(float4 a, float4x3 b);
        public static float4 mul(float4 a, float4x4 b);
        public static float2 mul(float2x2 a, float2 b);
        public static float2x2 mul(float2x2 a, float2x2 b);
        public static float2x3 mul(float2x2 a, float2x3 b);
        public static float2x4 mul(float2x2 a, float2x4 b);
        public static float2 mul(float2x3 a, float3 b);
        public static float2x2 mul(float2x3 a, float3x2 b);
        public static float2x3 mul(float2x3 a, float3x3 b);
        public static float2x4 mul(float2x3 a, float3x4 b);
        public static float2 mul(float2x4 a, float4 b);
        public static float2x2 mul(float2x4 a, float4x2 b);
        public static float2x3 mul(float2x4 a, float4x3 b);
        public static float2x4 mul(float2x4 a, float4x4 b);
        public static float3 mul(float3x2 a, float2 b);
        public static float3x2 mul(float3x2 a, float2x2 b);
        public static float3x3 mul(float3x2 a, float2x3 b);
        public static float3x4 mul(float3x2 a, float2x4 b);
        public static float3 mul(float3x3 a, float3 b);
        public static float3x2 mul(float3x3 a, float3x2 b);
        public static float3x3 mul(float3x3 a, float3x3 b);
        public static float3x4 mul(float3x3 a, float3x4 b);
        public static float3 mul(float3x4 a, float4 b);
        public static float3x2 mul(float3x4 a, float4x2 b);
        public static float3x3 mul(float3x4 a, float4x3 b);
        public static float3x4 mul(float3x4 a, float4x4 b);
        public static float4 mul(float4x2 a, float2 b);
        public static float4x2 mul(float4x2 a, float2x2 b);
        public static float4x3 mul(float4x2 a, float2x3 b);
        public static float4x4 mul(float4x2 a, float2x4 b);
        public static float4 mul(float4x3 a, float3 b);
        public static float4x2 mul(float4x3 a, float3x2 b);
        public static float4x3 mul(float4x3 a, float3x3 b);
        public static float4x4 mul(float4x3 a, float3x4 b);
        public static float4 mul(float4x4 a, float4 b);
        public static float4x2 mul(float4x4 a, float4x2 b);
        public static float4x3 mul(float4x4 a, float4x3 b);
        public static float4x4 mul(float4x4 a, float4x4 b);
        public static double mul(double a, double b);
        public static double mul(double2 a, double2 b);
        public static double2 mul(double2 a, double2x2 b);
        public static double3 mul(double2 a, double2x3 b);
        public static double4 mul(double2 a, double2x4 b);
        public static double mul(double3 a, double3 b);
        public static double2 mul(double3 a, double3x2 b);
        public static double3 mul(double3 a, double3x3 b);
        public static double4 mul(double3 a, double3x4 b);
        public static double mul(double4 a, double4 b);
        public static double2 mul(double4 a, double4x2 b);
        public static double3 mul(double4 a, double4x3 b);
        public static double4 mul(double4 a, double4x4 b);
        public static double2 mul(double2x2 a, double2 b);
        public static double2x2 mul(double2x2 a, double2x2 b);
        public static double2x3 mul(double2x2 a, double2x3 b);
        public static double2x4 mul(double2x2 a, double2x4 b);
        public static double2 mul(double2x3 a, double3 b);
        public static double2x2 mul(double2x3 a, double3x2 b);
        public static double2x3 mul(double2x3 a, double3x3 b);
        public static double2x4 mul(double2x3 a, double3x4 b);
        public static double2 mul(double2x4 a, double4 b);
        public static double2x2 mul(double2x4 a, double4x2 b);
        public static double2x3 mul(double2x4 a, double4x3 b);
        public static double2x4 mul(double2x4 a, double4x4 b);
        public static double3 mul(double3x2 a, double2 b);
        public static double3x2 mul(double3x2 a, double2x2 b);
        public static double3x3 mul(double3x2 a, double2x3 b);
        public static double3x4 mul(double3x2 a, double2x4 b);
        public static double3 mul(double3x3 a, double3 b);
        public static double3x2 mul(double3x3 a, double3x2 b);
        public static double3x3 mul(double3x3 a, double3x3 b);
        public static double3x4 mul(double3x3 a, double3x4 b);
        public static double3 mul(double3x4 a, double4 b);
        public static double3x2 mul(double3x4 a, double4x2 b);
        public static double3x3 mul(double3x4 a, double4x3 b);
        public static double3x4 mul(double3x4 a, double4x4 b);
        public static double4 mul(double4x2 a, double2 b);
        public static double4x2 mul(double4x2 a, double2x2 b);
        public static double4x3 mul(double4x2 a, double2x3 b);
        public static double4x4 mul(double4x2 a, double2x4 b);
        public static double4 mul(double4x3 a, double3 b);
        public static double4x2 mul(double4x3 a, double3x2 b);
        public static double4x3 mul(double4x3 a, double3x3 b);
        public static double4x4 mul(double4x3 a, double3x4 b);
        public static double4 mul(double4x4 a, double4 b);
        public static double4x2 mul(double4x4 a, double4x2 b);
        public static double4x3 mul(double4x4 a, double4x3 b);
        public static double4x4 mul(double4x4 a, double4x4 b);
        public static int mul(int a, int b);
        public static int mul(int2 a, int2 b);
        public static int2 mul(int2 a, int2x2 b);
        public static int3 mul(int2 a, int2x3 b);
        public static int4 mul(int2 a, int2x4 b);
        public static int mul(int3 a, int3 b);
        public static int2 mul(int3 a, int3x2 b);
        public static int3 mul(int3 a, int3x3 b);
        public static int4 mul(int3 a, int3x4 b);
        public static int mul(int4 a, int4 b);
        public static int2 mul(int4 a, int4x2 b);
        public static int3 mul(int4 a, int4x3 b);
        public static int4 mul(int4 a, int4x4 b);
        public static int2 mul(int2x2 a, int2 b);
        public static int2x2 mul(int2x2 a, int2x2 b);
        public static int2x3 mul(int2x2 a, int2x3 b);
        public static int2x4 mul(int2x2 a, int2x4 b);
        public static int2 mul(int2x3 a, int3 b);
        public static int2x2 mul(int2x3 a, int3x2 b);
        public static int2x3 mul(int2x3 a, int3x3 b);
        public static int2x4 mul(int2x3 a, int3x4 b);
        public static int2 mul(int2x4 a, int4 b);
        public static int2x2 mul(int2x4 a, int4x2 b);
        public static int2x3 mul(int2x4 a, int4x3 b);
        public static int2x4 mul(int2x4 a, int4x4 b);
        public static int3 mul(int3x2 a, int2 b);
        public static int3x2 mul(int3x2 a, int2x2 b);
        public static int3x3 mul(int3x2 a, int2x3 b);
        public static int3x4 mul(int3x2 a, int2x4 b);
        public static int3 mul(int3x3 a, int3 b);
        public static int3x2 mul(int3x3 a, int3x2 b);
        public static int3x3 mul(int3x3 a, int3x3 b);
        public static int3x4 mul(int3x3 a, int3x4 b);
        public static int3 mul(int3x4 a, int4 b);
        public static int3x2 mul(int3x4 a, int4x2 b);
        public static int3x3 mul(int3x4 a, int4x3 b);
        public static int3x4 mul(int3x4 a, int4x4 b);
        public static int4 mul(int4x2 a, int2 b);
        public static int4x2 mul(int4x2 a, int2x2 b);
        public static int4x3 mul(int4x2 a, int2x3 b);
        public static int4x4 mul(int4x2 a, int2x4 b);
        public static int4 mul(int4x3 a, int3 b);
        public static int4x2 mul(int4x3 a, int3x2 b);
        public static int4x3 mul(int4x3 a, int3x3 b);
        public static int4x4 mul(int4x3 a, int3x4 b);
        public static int4 mul(int4x4 a, int4 b);
        public static int4x2 mul(int4x4 a, int4x2 b);
        public static int4x3 mul(int4x4 a, int4x3 b);
        public static int4x4 mul(int4x4 a, int4x4 b);
        public static uint mul(uint a, uint b);
        public static uint mul(uint2 a, uint2 b);
        public static uint2 mul(uint2 a, uint2x2 b);
        public static uint3 mul(uint2 a, uint2x3 b);
        public static uint4 mul(uint2 a, uint2x4 b);
        public static uint mul(uint3 a, uint3 b);
        public static uint2 mul(uint3 a, uint3x2 b);
        public static uint3 mul(uint3 a, uint3x3 b);
        public static uint4 mul(uint3 a, uint3x4 b);
        public static uint mul(uint4 a, uint4 b);
        public static uint2 mul(uint4 a, uint4x2 b);
        public static uint3 mul(uint4 a, uint4x3 b);
        public static uint4 mul(uint4 a, uint4x4 b);
        public static uint2 mul(uint2x2 a, uint2 b);
        public static uint2x2 mul(uint2x2 a, uint2x2 b);
        public static uint2x3 mul(uint2x2 a, uint2x3 b);
        public static uint2x4 mul(uint2x2 a, uint2x4 b);
        public static uint2 mul(uint2x3 a, uint3 b);
        public static uint2x2 mul(uint2x3 a, uint3x2 b);
        public static uint2x3 mul(uint2x3 a, uint3x3 b);
        public static uint2x4 mul(uint2x3 a, uint3x4 b);
        public static uint2 mul(uint2x4 a, uint4 b);
        public static uint2x2 mul(uint2x4 a, uint4x2 b);
        public static uint2x3 mul(uint2x4 a, uint4x3 b);
        public static uint2x4 mul(uint2x4 a, uint4x4 b);
        public static uint3 mul(uint3x2 a, uint2 b);
        public static uint3x2 mul(uint3x2 a, uint2x2 b);
        public static uint3x3 mul(uint3x2 a, uint2x3 b);
        public static uint3x4 mul(uint3x2 a, uint2x4 b);
        public static uint3 mul(uint3x3 a, uint3 b);
        public static uint3x2 mul(uint3x3 a, uint3x2 b);
        public static uint3x3 mul(uint3x3 a, uint3x3 b);
        public static uint3x4 mul(uint3x3 a, uint3x4 b);
        public static uint3 mul(uint3x4 a, uint4 b);
        public static uint3x2 mul(uint3x4 a, uint4x2 b);
        public static uint3x3 mul(uint3x4 a, uint4x3 b);
        public static uint3x4 mul(uint3x4 a, uint4x4 b);
        public static uint4 mul(uint4x2 a, uint2 b);
        public static uint4x2 mul(uint4x2 a, uint2x2 b);
        public static uint4x3 mul(uint4x2 a, uint2x3 b);
        public static uint4x4 mul(uint4x2 a, uint2x4 b);
        public static uint4 mul(uint4x3 a, uint3 b);
        public static uint4x2 mul(uint4x3 a, uint3x2 b);
        public static uint4x3 mul(uint4x3 a, uint3x3 b);
        public static uint4x4 mul(uint4x3 a, uint3x4 b);
        public static uint4 mul(uint4x4 a, uint4 b);
        public static uint4x2 mul(uint4x4 a, uint4x2 b);
        public static uint4x3 mul(uint4x4 a, uint4x3 b);
        public static uint4x4 mul(uint4x4 a, uint4x4 b);
        public static quaternion quaternion(float x, float y, float z, float w);
        public static quaternion quaternion(float4 value);
        public static quaternion quaternion(float3x3 m);
        public static quaternion quaternion(float4x4 m);
        public static quaternion conjugate(quaternion q);
        public static quaternion inverse(quaternion q);
        public static float dot(quaternion a, quaternion b);
        public static float length(quaternion q);
        public static float lengthsq(quaternion q);
        public static quaternion normalize(quaternion q);
        public static quaternion normalizesafe(quaternion q);
        public static quaternion normalizesafe(quaternion q, quaternion defaultvalue);
        public static quaternion unitexp(quaternion q);
        public static quaternion exp(quaternion q);
        public static quaternion unitlog(quaternion q);
        public static quaternion log(quaternion q);
        public static quaternion mul(quaternion a, quaternion b);
        public static float3 mul(quaternion q, float3 v);
        public static float3 rotate(quaternion q, float3 v);
        public static quaternion nlerp(quaternion q1, quaternion q2, float t);
        public static quaternion slerp(quaternion q1, quaternion q2, float t);
        public static uint hash(quaternion q);
        public static uint4 hashwide(quaternion q);
        public static float3 forward(quaternion q);
        public static RigidTransform RigidTransform(quaternion rot, float3 pos);
        public static RigidTransform RigidTransform(float3x3 rotation, float3 translation);
        public static RigidTransform RigidTransform(float4x4 transform);
        public static RigidTransform inverse(RigidTransform t);
        public static RigidTransform mul(RigidTransform a, RigidTransform b);
        public static float4 mul(RigidTransform a, float4 pos);
        public static float3 rotate(RigidTransform a, float3 dir);
        public static float3 transform(RigidTransform a, float3 pos);
        public static uint hash(RigidTransform t);
        public static uint4 hashwide(RigidTransform t);
        public static uint2 uint2(uint x, uint y);
        public static uint2 uint2(uint2 xy);
        public static uint2 uint2(uint v);
        public static uint2 uint2(bool v);
        public static uint2 uint2(bool2 v);
        public static uint2 uint2(int v);
        public static uint2 uint2(int2 v);
        public static uint2 uint2(float v);
        public static uint2 uint2(float2 v);
        public static uint2 uint2(double v);
        public static uint2 uint2(double2 v);
        public static uint hash(uint2 v);
        public static uint2 hashwide(uint2 v);
        public static uint shuffle(uint2 a, uint2 b, ShuffleComponent x);
        public static uint2 shuffle(uint2 a, uint2 b, ShuffleComponent x, ShuffleComponent y);
        public static uint3 shuffle(uint2 a, uint2 b, ShuffleComponent x, ShuffleComponent y, ShuffleComponent z);
        public static uint4 shuffle(uint2 a, uint2 b, ShuffleComponent x, ShuffleComponent y, ShuffleComponent z, ShuffleComponent w);
        public static uint2x2 uint2x2(uint2 c0, uint2 c1);
        public static uint2x2 uint2x2(uint m00, uint m01, uint m10, uint m11);
        public static uint2x2 uint2x2(uint v);
        public static uint2x2 uint2x2(bool v);
        public static uint2x2 uint2x2(bool2x2 v);
        public static uint2x2 uint2x2(int v);
        public static uint2x2 uint2x2(int2x2 v);
        public static uint2x2 uint2x2(float v);
        public static uint2x2 uint2x2(float2x2 v);
        public static uint2x2 uint2x2(double v);
        public static uint2x2 uint2x2(double2x2 v);
        public static uint2x2 transpose(uint2x2 v);
        public static uint hash(uint2x2 v);
        public static uint2 hashwide(uint2x2 v);
        public static uint2x3 uint2x3(uint2 c0, uint2 c1, uint2 c2);
        public static uint2x3 uint2x3(uint m00, uint m01, uint m02, uint m10, uint m11, uint m12);
        public static uint2x3 uint2x3(uint v);
        public static uint2x3 uint2x3(bool v);
        public static uint2x3 uint2x3(bool2x3 v);
        public static uint2x3 uint2x3(int v);
        public static uint2x3 uint2x3(int2x3 v);
        public static uint2x3 uint2x3(float v);
        public static uint2x3 uint2x3(float2x3 v);
        public static uint2x3 uint2x3(double v);
        public static uint2x3 uint2x3(double2x3 v);
        public static uint3x2 transpose(uint2x3 v);
        public static uint hash(uint2x3 v);
        public static uint2 hashwide(uint2x3 v);
        public static uint2x4 uint2x4(uint2 c0, uint2 c1, uint2 c2, uint2 c3);
        public static uint2x4 uint2x4(uint m00, uint m01, uint m02, uint m03, uint m10, uint m11, uint m12, uint m13);
        public static uint2x4 uint2x4(uint v);
        public static uint2x4 uint2x4(bool v);
        public static uint2x4 uint2x4(bool2x4 v);
        public static uint2x4 uint2x4(int v);
        public static uint2x4 uint2x4(int2x4 v);
        public static uint2x4 uint2x4(float v);
        public static uint2x4 uint2x4(float2x4 v);
        public static uint2x4 uint2x4(double v);
        public static uint2x4 uint2x4(double2x4 v);
        public static uint4x2 transpose(uint2x4 v);
        public static uint hash(uint2x4 v);
        public static uint2 hashwide(uint2x4 v);
        public static uint3 uint3(uint x, uint y, uint z);
        public static uint3 uint3(uint x, uint2 yz);
        public static uint3 uint3(uint2 xy, uint z);
        public static uint3 uint3(uint3 xyz);
        public static uint3 uint3(uint v);
        public static uint3 uint3(bool v);
        public static uint3 uint3(bool3 v);
        public static uint3 uint3(int v);
        public static uint3 uint3(int3 v);
        public static uint3 uint3(float v);
        public static uint3 uint3(float3 v);
        public static uint3 uint3(double v);
        public static uint3 uint3(double3 v);
        public static uint hash(uint3 v);
        public static uint3 hashwide(uint3 v);
        public static uint shuffle(uint3 a, uint3 b, ShuffleComponent x);
        public static uint2 shuffle(uint3 a, uint3 b, ShuffleComponent x, ShuffleComponent y);
        public static uint3 shuffle(uint3 a, uint3 b, ShuffleComponent x, ShuffleComponent y, ShuffleComponent z);
        public static uint4 shuffle(uint3 a, uint3 b, ShuffleComponent x, ShuffleComponent y, ShuffleComponent z, ShuffleComponent w);
        public static uint3x2 uint3x2(uint3 c0, uint3 c1);
        public static uint3x2 uint3x2(uint m00, uint m01, uint m10, uint m11, uint m20, uint m21);
        public static uint3x2 uint3x2(uint v);
        public static uint3x2 uint3x2(bool v);
        public static uint3x2 uint3x2(bool3x2 v);
        public static uint3x2 uint3x2(int v);
        public static uint3x2 uint3x2(int3x2 v);
        public static uint3x2 uint3x2(float v);
        public static uint3x2 uint3x2(float3x2 v);
        public static uint3x2 uint3x2(double v);
        public static uint3x2 uint3x2(double3x2 v);
        public static uint2x3 transpose(uint3x2 v);
        public static uint hash(uint3x2 v);
        public static uint3 hashwide(uint3x2 v);
        public static uint3x3 uint3x3(uint3 c0, uint3 c1, uint3 c2);
        public static uint3x3 uint3x3(uint m00, uint m01, uint m02, uint m10, uint m11, uint m12, uint m20, uint m21, uint m22);
        public static uint3x3 uint3x3(uint v);
        public static uint3x3 uint3x3(bool v);
        public static uint3x3 uint3x3(bool3x3 v);
        public static uint3x3 uint3x3(int v);
        public static uint3x3 uint3x3(int3x3 v);
        public static uint3x3 uint3x3(float v);
        public static uint3x3 uint3x3(float3x3 v);
        public static uint3x3 uint3x3(double v);
        public static uint3x3 uint3x3(double3x3 v);
        public static uint3x3 transpose(uint3x3 v);
        public static uint hash(uint3x3 v);
        public static uint3 hashwide(uint3x3 v);
        public static uint3x4 uint3x4(uint3 c0, uint3 c1, uint3 c2, uint3 c3);
        public static uint3x4 uint3x4(uint m00, uint m01, uint m02, uint m03, uint m10, uint m11, uint m12, uint m13, uint m20, uint m21, uint m22, uint m23);
        public static uint3x4 uint3x4(uint v);
        public static uint3x4 uint3x4(bool v);
        public static uint3x4 uint3x4(bool3x4 v);
        public static uint3x4 uint3x4(int v);
        public static uint3x4 uint3x4(int3x4 v);
        public static uint3x4 uint3x4(float v);
        public static uint3x4 uint3x4(float3x4 v);
        public static uint3x4 uint3x4(double v);
        public static uint3x4 uint3x4(double3x4 v);
        public static uint4x3 transpose(uint3x4 v);
        public static uint hash(uint3x4 v);
        public static uint3 hashwide(uint3x4 v);
        public static uint4 uint4(uint x, uint y, uint z, uint w);
        public static uint4 uint4(uint x, uint y, uint2 zw);
        public static uint4 uint4(uint x, uint2 yz, uint w);
        public static uint4 uint4(uint x, uint3 yzw);
        public static uint4 uint4(uint2 xy, uint z, uint w);
        public static uint4 uint4(uint2 xy, uint2 zw);
        public static uint4 uint4(uint3 xyz, uint w);
        public static uint4 uint4(uint4 xyzw);
        public static uint4 uint4(uint v);
        public static uint4 uint4(bool v);
        public static uint4 uint4(bool4 v);
        public static uint4 uint4(int v);
        public static uint4 uint4(int4 v);
        public static uint4 uint4(float v);
        public static uint4 uint4(float4 v);
        public static uint4 uint4(double v);
        public static uint4 uint4(double4 v);
        public static uint hash(uint4 v);
        public static uint4 hashwide(uint4 v);
        public static uint shuffle(uint4 a, uint4 b, ShuffleComponent x);
        public static uint2 shuffle(uint4 a, uint4 b, ShuffleComponent x, ShuffleComponent y);
        public static uint3 shuffle(uint4 a, uint4 b, ShuffleComponent x, ShuffleComponent y, ShuffleComponent z);
        public static uint4 shuffle(uint4 a, uint4 b, ShuffleComponent x, ShuffleComponent y, ShuffleComponent z, ShuffleComponent w);
        public static uint4x2 uint4x2(uint4 c0, uint4 c1);
        public static uint4x2 uint4x2(uint m00, uint m01, uint m10, uint m11, uint m20, uint m21, uint m30, uint m31);
        public static uint4x2 uint4x2(uint v);
        public static uint4x2 uint4x2(bool v);
        public static uint4x2 uint4x2(bool4x2 v);
        public static uint4x2 uint4x2(int v);
        public static uint4x2 uint4x2(int4x2 v);
        public static uint4x2 uint4x2(float v);
        public static uint4x2 uint4x2(float4x2 v);
        public static uint4x2 uint4x2(double v);
        public static uint4x2 uint4x2(double4x2 v);
        public static uint2x4 transpose(uint4x2 v);
        public static uint hash(uint4x2 v);
        public static uint4 hashwide(uint4x2 v);
        public static uint4x3 uint4x3(uint4 c0, uint4 c1, uint4 c2);
        public static uint4x3 uint4x3(uint m00, uint m01, uint m02, uint m10, uint m11, uint m12, uint m20, uint m21, uint m22, uint m30, uint m31, uint m32);
        public static uint4x3 uint4x3(uint v);
        public static uint4x3 uint4x3(bool v);
        public static uint4x3 uint4x3(bool4x3 v);
        public static uint4x3 uint4x3(int v);
        public static uint4x3 uint4x3(int4x3 v);
        public static uint4x3 uint4x3(float v);
        public static uint4x3 uint4x3(float4x3 v);
        public static uint4x3 uint4x3(double v);
        public static uint4x3 uint4x3(double4x3 v);
        public static uint3x4 transpose(uint4x3 v);
        public static uint hash(uint4x3 v);
        public static uint4 hashwide(uint4x3 v);
        public static uint4x4 uint4x4(uint4 c0, uint4 c1, uint4 c2, uint4 c3);
        public static uint4x4 uint4x4(uint m00, uint m01, uint m02, uint m03, uint m10, uint m11, uint m12, uint m13, uint m20, uint m21, uint m22, uint m23, uint m30, uint m31, uint m32, uint m33);
        public static uint4x4 uint4x4(uint v);
        public static uint4x4 uint4x4(bool v);
        public static uint4x4 uint4x4(bool4x4 v);
        public static uint4x4 uint4x4(int v);
        public static uint4x4 uint4x4(int4x4 v);
        public static uint4x4 uint4x4(float v);
        public static uint4x4 uint4x4(float4x4 v);
        public static uint4x4 uint4x4(double v);
        public static uint4x4 uint4x4(double4x4 v);
        public static uint4x4 transpose(uint4x4 v);
        public static uint hash(uint4x4 v);
        public static uint4 hashwide(uint4x4 v);

        public enum RotationOrder
        {
            XYZ = 0,
            XZY = 1,
            YXZ = 2,
            YZX = 3,
            ZXY = 4,
            ZYX = 5,
            Default = 4
        }
        public enum ShuffleComponent
        {
            LeftX = 0,
            LeftY = 1,
            LeftZ = 2,
            LeftW = 3,
            RightX = 4,
            RightY = 5,
            RightZ = 6,
            RightW = 7
        }
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct bool2x2 : IEquatable<bool2x2>
    {
        public bool2 c0;
        public bool2 c1;

        public bool2x2(bool2 c0, bool2 c1);
        public bool2x2(bool m00, bool m01, bool m10, bool m11);
        public bool2x2(bool v);

        public ref bool2 this[int index] { get; }

        public bool Equals(bool2x2 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();

        public static bool2x2 operator ==(bool2x2 lhs, bool2x2 rhs);
        public static bool2x2 operator ==(bool2x2 lhs, bool rhs);
        public static bool2x2 operator ==(bool lhs, bool2x2 rhs);
        public static bool2x2 operator !=(bool2x2 lhs, bool2x2 rhs);
        public static bool2x2 operator !=(bool2x2 lhs, bool rhs);
        public static bool2x2 operator !=(bool lhs, bool2x2 rhs);
        public static bool2x2 operator !(bool2x2 val);
        public static bool2x2 operator &(bool2x2 lhs, bool2x2 rhs);
        public static bool2x2 operator &(bool2x2 lhs, bool rhs);
        public static bool2x2 operator &(bool lhs, bool2x2 rhs);
        public static bool2x2 operator |(bool2x2 lhs, bool2x2 rhs);
        public static bool2x2 operator |(bool2x2 lhs, bool rhs);
        public static bool2x2 operator |(bool lhs, bool2x2 rhs);
        public static bool2x2 operator ^(bool2x2 lhs, bool2x2 rhs);
        public static bool2x2 operator ^(bool2x2 lhs, bool rhs);
        public static bool2x2 operator ^(bool lhs, bool2x2 rhs);

        public static implicit operator bool2x2(bool v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct bool2x3 : IEquatable<bool2x3>
    {
        public bool2 c0;
        public bool2 c1;
        public bool2 c2;

        public bool2x3(bool2 c0, bool2 c1, bool2 c2);
        public bool2x3(bool m00, bool m01, bool m02, bool m10, bool m11, bool m12);
        public bool2x3(bool v);

        public ref bool2 this[int index] { get; }

        public bool Equals(bool2x3 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();

        public static bool2x3 operator ==(bool2x3 lhs, bool2x3 rhs);
        public static bool2x3 operator ==(bool2x3 lhs, bool rhs);
        public static bool2x3 operator ==(bool lhs, bool2x3 rhs);
        public static bool2x3 operator !=(bool2x3 lhs, bool2x3 rhs);
        public static bool2x3 operator !=(bool2x3 lhs, bool rhs);
        public static bool2x3 operator !=(bool lhs, bool2x3 rhs);
        public static bool2x3 operator !(bool2x3 val);
        public static bool2x3 operator &(bool2x3 lhs, bool2x3 rhs);
        public static bool2x3 operator &(bool2x3 lhs, bool rhs);
        public static bool2x3 operator &(bool lhs, bool2x3 rhs);
        public static bool2x3 operator |(bool2x3 lhs, bool2x3 rhs);
        public static bool2x3 operator |(bool2x3 lhs, bool rhs);
        public static bool2x3 operator |(bool lhs, bool2x3 rhs);
        public static bool2x3 operator ^(bool2x3 lhs, bool2x3 rhs);
        public static bool2x3 operator ^(bool2x3 lhs, bool rhs);
        public static bool2x3 operator ^(bool lhs, bool2x3 rhs);

        public static implicit operator bool2x3(bool v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct bool2x4 : IEquatable<bool2x4>
    {
        public bool2 c0;
        public bool2 c1;
        public bool2 c2;
        public bool2 c3;

        public bool2x4(bool2 c0, bool2 c1, bool2 c2, bool2 c3);
        public bool2x4(bool m00, bool m01, bool m02, bool m03, bool m10, bool m11, bool m12, bool m13);
        public bool2x4(bool v);

        public ref bool2 this[int index] { get; }

        public bool Equals(bool2x4 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();

        public static bool2x4 operator ==(bool2x4 lhs, bool2x4 rhs);
        public static bool2x4 operator ==(bool2x4 lhs, bool rhs);
        public static bool2x4 operator ==(bool lhs, bool2x4 rhs);
        public static bool2x4 operator !=(bool2x4 lhs, bool2x4 rhs);
        public static bool2x4 operator !=(bool2x4 lhs, bool rhs);
        public static bool2x4 operator !=(bool lhs, bool2x4 rhs);
        public static bool2x4 operator !(bool2x4 val);
        public static bool2x4 operator &(bool2x4 lhs, bool2x4 rhs);
        public static bool2x4 operator &(bool2x4 lhs, bool rhs);
        public static bool2x4 operator &(bool lhs, bool2x4 rhs);
        public static bool2x4 operator |(bool2x4 lhs, bool2x4 rhs);
        public static bool2x4 operator |(bool2x4 lhs, bool rhs);
        public static bool2x4 operator |(bool lhs, bool2x4 rhs);
        public static bool2x4 operator ^(bool2x4 lhs, bool2x4 rhs);
        public static bool2x4 operator ^(bool2x4 lhs, bool rhs);
        public static bool2x4 operator ^(bool lhs, bool2x4 rhs);

        public static implicit operator bool2x4(bool v);
    }
}
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    [DebuggerTypeProxy(typeof(DebuggerProxy))]
    public struct bool3 : IEquatable<bool3>
    {
        public bool x;
        public bool y;
        public bool z;

        public bool3(bool x, bool y, bool z);
        public bool3(bool x, bool2 yz);
        public bool3(bool2 xy, bool z);
        public bool3(bool3 xyz);
        public bool3(bool v);

        public bool this[int index] { get; set; }
        [EditorBrowsable(Never)]
        public bool4 xxxx { get; }
        [EditorBrowsable(Never)]
        public bool4 xxxy { get; }
        [EditorBrowsable(Never)]
        public bool4 xxxz { get; }
        [EditorBrowsable(Never)]
        public bool4 xxyx { get; }
        [EditorBrowsable(Never)]
        public bool4 xxyy { get; }
        [EditorBrowsable(Never)]
        public bool4 xxyz { get; }
        [EditorBrowsable(Never)]
        public bool4 xxzx { get; }
        [EditorBrowsable(Never)]
        public bool4 xxzy { get; }
        [EditorBrowsable(Never)]
        public bool4 xxzz { get; }
        [EditorBrowsable(Never)]
        public bool4 xyxx { get; }
        [EditorBrowsable(Never)]
        public bool4 xyxy { get; }
        [EditorBrowsable(Never)]
        public bool4 xyxz { get; }
        [EditorBrowsable(Never)]
        public bool4 xyyx { get; }
        [EditorBrowsable(Never)]
        public bool4 xyyy { get; }
        [EditorBrowsable(Never)]
        public bool4 xyyz { get; }
        [EditorBrowsable(Never)]
        public bool4 xyzx { get; }
        [EditorBrowsable(Never)]
        public bool4 xyzy { get; }
        [EditorBrowsable(Never)]
        public bool4 xyzz { get; }
        [EditorBrowsable(Never)]
        public bool4 xzxx { get; }
        [EditorBrowsable(Never)]
        public bool4 xzxy { get; }
        [EditorBrowsable(Never)]
        public bool4 xzxz { get; }
        [EditorBrowsable(Never)]
        public bool4 xzyx { get; }
        [EditorBrowsable(Never)]
        public bool4 xzyy { get; }
        [EditorBrowsable(Never)]
        public bool4 xzyz { get; }
        [EditorBrowsable(Never)]
        public bool4 xzzx { get; }
        [EditorBrowsable(Never)]
        public bool4 xzzy { get; }
        [EditorBrowsable(Never)]
        public bool4 xzzz { get; }
        [EditorBrowsable(Never)]
        public bool4 yxxx { get; }
        [EditorBrowsable(Never)]
        public bool4 yxxy { get; }
        [EditorBrowsable(Never)]
        public bool4 yxxz { get; }
        [EditorBrowsable(Never)]
        public bool4 yxyx { get; }
        [EditorBrowsable(Never)]
        public bool4 yxyy { get; }
        [EditorBrowsable(Never)]
        public bool4 yxyz { get; }
        [EditorBrowsable(Never)]
        public bool4 yxzx { get; }
        [EditorBrowsable(Never)]
        public bool4 yxzy { get; }
        [EditorBrowsable(Never)]
        public bool4 yxzz { get; }
        [EditorBrowsable(Never)]
        public bool4 yyxx { get; }
        [EditorBrowsable(Never)]
        public bool4 yyxy { get; }
        [EditorBrowsable(Never)]
        public bool4 yyxz { get; }
        [EditorBrowsable(Never)]
        public bool4 yyyx { get; }
        [EditorBrowsable(Never)]
        public bool4 yyyy { get; }
        [EditorBrowsable(Never)]
        public bool4 yyyz { get; }
        [EditorBrowsable(Never)]
        public bool4 yyzx { get; }
        [EditorBrowsable(Never)]
        public bool4 yyzy { get; }
        [EditorBrowsable(Never)]
        public bool4 yyzz { get; }
        [EditorBrowsable(Never)]
        public bool4 yzxx { get; }
        [EditorBrowsable(Never)]
        public bool4 yzxy { get; }
        [EditorBrowsable(Never)]
        public bool4 yzxz { get; }
        [EditorBrowsable(Never)]
        public bool4 yzyx { get; }
        [EditorBrowsable(Never)]
        public bool4 yzyy { get; }
        [EditorBrowsable(Never)]
        public bool4 yzyz { get; }
        [EditorBrowsable(Never)]
        public bool4 yzzx { get; }
        [EditorBrowsable(Never)]
        public bool4 yzzy { get; }
        [EditorBrowsable(Never)]
        public bool4 yzzz { get; }
        [EditorBrowsable(Never)]
        public bool4 zxxx { get; }
        [EditorBrowsable(Never)]
        public bool4 zxxy { get; }
        [EditorBrowsable(Never)]
        public bool4 zxxz { get; }
        [EditorBrowsable(Never)]
        public bool4 zxyx { get; }
        [EditorBrowsable(Never)]
        public bool4 zxyy { get; }
        [EditorBrowsable(Never)]
        public bool4 zxyz { get; }
        [EditorBrowsable(Never)]
        public bool4 zxzx { get; }
        [EditorBrowsable(Never)]
        public bool4 zxzy { get; }
        [EditorBrowsable(Never)]
        public bool4 zxzz { get; }
        [EditorBrowsable(Never)]
        public bool4 zyxx { get; }
        [EditorBrowsable(Never)]
        public bool4 zyxy { get; }
        [EditorBrowsable(Never)]
        public bool4 zyxz { get; }
        [EditorBrowsable(Never)]
        public bool4 zyyx { get; }
        [EditorBrowsable(Never)]
        public bool4 zyyy { get; }
        [EditorBrowsable(Never)]
        public bool4 zyyz { get; }
        [EditorBrowsable(Never)]
        public bool4 zyzx { get; }
        [EditorBrowsable(Never)]
        public bool4 zyzy { get; }
        [EditorBrowsable(Never)]
        public bool4 zyzz { get; }
        [EditorBrowsable(Never)]
        public bool4 zzxx { get; }
        [EditorBrowsable(Never)]
        public bool4 zzxy { get; }
        [EditorBrowsable(Never)]
        public bool4 zzxz { get; }
        [EditorBrowsable(Never)]
        public bool4 zzyx { get; }
        [EditorBrowsable(Never)]
        public bool4 zzyy { get; }
        [EditorBrowsable(Never)]
        public bool4 zzyz { get; }
        [EditorBrowsable(Never)]
        public bool4 zzzx { get; }
        [EditorBrowsable(Never)]
        public bool4 zzzy { get; }
        [EditorBrowsable(Never)]
        public bool4 zzzz { get; }
        [EditorBrowsable(Never)]
        public bool3 xxx { get; }
        [EditorBrowsable(Never)]
        public bool3 xxy { get; }
        [EditorBrowsable(Never)]
        public bool3 xxz { get; }
        [EditorBrowsable(Never)]
        public bool3 xyx { get; }
        [EditorBrowsable(Never)]
        public bool3 xyy { get; }
        [EditorBrowsable(Never)]
        public bool3 xyz { get; set; }
        [EditorBrowsable(Never)]
        public bool3 xzx { get; }
        [EditorBrowsable(Never)]
        public bool3 xzy { get; set; }
        [EditorBrowsable(Never)]
        public bool3 xzz { get; }
        [EditorBrowsable(Never)]
        public bool3 yxx { get; }
        [EditorBrowsable(Never)]
        public bool3 yxy { get; }
        [EditorBrowsable(Never)]
        public bool3 yxz { get; set; }
        [EditorBrowsable(Never)]
        public bool3 yyx { get; }
        [EditorBrowsable(Never)]
        public bool3 yyy { get; }
        [EditorBrowsable(Never)]
        public bool3 yyz { get; }
        [EditorBrowsable(Never)]
        public bool3 yzx { get; set; }
        [EditorBrowsable(Never)]
        public bool3 yzy { get; }
        [EditorBrowsable(Never)]
        public bool3 yzz { get; }
        [EditorBrowsable(Never)]
        public bool3 zxx { get; }
        [EditorBrowsable(Never)]
        public bool3 zxy { get; set; }
        [EditorBrowsable(Never)]
        public bool3 zxz { get; }
        [EditorBrowsable(Never)]
        public bool3 zyx { get; set; }
        [EditorBrowsable(Never)]
        public bool3 zyy { get; }
        [EditorBrowsable(Never)]
        public bool3 zyz { get; }
        [EditorBrowsable(Never)]
        public bool3 zzx { get; }
        [EditorBrowsable(Never)]
        public bool3 zzy { get; }
        [EditorBrowsable(Never)]
        public bool3 zzz { get; }
        [EditorBrowsable(Never)]
        public bool2 xx { get; }
        [EditorBrowsable(Never)]
        public bool2 xy { get; set; }
        [EditorBrowsable(Never)]
        public bool2 xz { get; set; }
        [EditorBrowsable(Never)]
        public bool2 yx { get; set; }
        [EditorBrowsable(Never)]
        public bool2 yy { get; }
        [EditorBrowsable(Never)]
        public bool2 yz { get; set; }
        [EditorBrowsable(Never)]
        public bool2 zx { get; set; }
        [EditorBrowsable(Never)]
        public bool2 zy { get; set; }
        [EditorBrowsable(Never)]
        public bool2 zz { get; }

        public bool Equals(bool3 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();

        public static bool3 operator ==(bool3 lhs, bool3 rhs);
        public static bool3 operator ==(bool3 lhs, bool rhs);
        public static bool3 operator ==(bool lhs, bool3 rhs);
        public static bool3 operator !=(bool3 lhs, bool3 rhs);
        public static bool3 operator !=(bool3 lhs, bool rhs);
        public static bool3 operator !=(bool lhs, bool3 rhs);
        public static bool3 operator !(bool3 val);
        public static bool3 operator &(bool3 lhs, bool3 rhs);
        public static bool3 operator &(bool3 lhs, bool rhs);
        public static bool3 operator &(bool lhs, bool3 rhs);
        public static bool3 operator |(bool3 lhs, bool3 rhs);
        public static bool3 operator |(bool3 lhs, bool rhs);
        public static bool3 operator |(bool lhs, bool3 rhs);
        public static bool3 operator ^(bool3 lhs, bool3 rhs);
        public static bool3 operator ^(bool3 lhs, bool rhs);
        public static bool3 operator ^(bool lhs, bool3 rhs);

        public static implicit operator bool3(bool v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct bool3x2 : IEquatable<bool3x2>
    {
        public bool3 c0;
        public bool3 c1;

        public bool3x2(bool3 c0, bool3 c1);
        public bool3x2(bool m00, bool m01, bool m10, bool m11, bool m20, bool m21);
        public bool3x2(bool v);

        public ref bool3 this[int index] { get; }

        public bool Equals(bool3x2 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();

        public static bool3x2 operator ==(bool3x2 lhs, bool3x2 rhs);
        public static bool3x2 operator ==(bool3x2 lhs, bool rhs);
        public static bool3x2 operator ==(bool lhs, bool3x2 rhs);
        public static bool3x2 operator !=(bool3x2 lhs, bool3x2 rhs);
        public static bool3x2 operator !=(bool3x2 lhs, bool rhs);
        public static bool3x2 operator !=(bool lhs, bool3x2 rhs);
        public static bool3x2 operator !(bool3x2 val);
        public static bool3x2 operator &(bool3x2 lhs, bool3x2 rhs);
        public static bool3x2 operator &(bool3x2 lhs, bool rhs);
        public static bool3x2 operator &(bool lhs, bool3x2 rhs);
        public static bool3x2 operator |(bool3x2 lhs, bool3x2 rhs);
        public static bool3x2 operator |(bool3x2 lhs, bool rhs);
        public static bool3x2 operator |(bool lhs, bool3x2 rhs);
        public static bool3x2 operator ^(bool3x2 lhs, bool3x2 rhs);
        public static bool3x2 operator ^(bool3x2 lhs, bool rhs);
        public static bool3x2 operator ^(bool lhs, bool3x2 rhs);

        public static implicit operator bool3x2(bool v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct bool3x3 : IEquatable<bool3x3>
    {
        public bool3 c0;
        public bool3 c1;
        public bool3 c2;

        public bool3x3(bool3 c0, bool3 c1, bool3 c2);
        public bool3x3(bool m00, bool m01, bool m02, bool m10, bool m11, bool m12, bool m20, bool m21, bool m22);
        public bool3x3(bool v);

        public ref bool3 this[int index] { get; }

        public bool Equals(bool3x3 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();

        public static bool3x3 operator ==(bool3x3 lhs, bool3x3 rhs);
        public static bool3x3 operator ==(bool3x3 lhs, bool rhs);
        public static bool3x3 operator ==(bool lhs, bool3x3 rhs);
        public static bool3x3 operator !=(bool3x3 lhs, bool3x3 rhs);
        public static bool3x3 operator !=(bool3x3 lhs, bool rhs);
        public static bool3x3 operator !=(bool lhs, bool3x3 rhs);
        public static bool3x3 operator !(bool3x3 val);
        public static bool3x3 operator &(bool3x3 lhs, bool3x3 rhs);
        public static bool3x3 operator &(bool3x3 lhs, bool rhs);
        public static bool3x3 operator &(bool lhs, bool3x3 rhs);
        public static bool3x3 operator |(bool3x3 lhs, bool3x3 rhs);
        public static bool3x3 operator |(bool3x3 lhs, bool rhs);
        public static bool3x3 operator |(bool lhs, bool3x3 rhs);
        public static bool3x3 operator ^(bool3x3 lhs, bool3x3 rhs);
        public static bool3x3 operator ^(bool3x3 lhs, bool rhs);
        public static bool3x3 operator ^(bool lhs, bool3x3 rhs);

        public static implicit operator bool3x3(bool v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct bool3x4 : IEquatable<bool3x4>
    {
        public bool3 c0;
        public bool3 c1;
        public bool3 c2;
        public bool3 c3;

        public bool3x4(bool3 c0, bool3 c1, bool3 c2, bool3 c3);
        public bool3x4(bool m00, bool m01, bool m02, bool m03, bool m10, bool m11, bool m12, bool m13, bool m20, bool m21, bool m22, bool m23);
        public bool3x4(bool v);

        public ref bool3 this[int index] { get; }

        public bool Equals(bool3x4 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();

        public static bool3x4 operator ==(bool3x4 lhs, bool3x4 rhs);
        public static bool3x4 operator ==(bool3x4 lhs, bool rhs);
        public static bool3x4 operator ==(bool lhs, bool3x4 rhs);
        public static bool3x4 operator !=(bool3x4 lhs, bool3x4 rhs);
        public static bool3x4 operator !=(bool3x4 lhs, bool rhs);
        public static bool3x4 operator !=(bool lhs, bool3x4 rhs);
        public static bool3x4 operator !(bool3x4 val);
        public static bool3x4 operator &(bool3x4 lhs, bool3x4 rhs);
        public static bool3x4 operator &(bool3x4 lhs, bool rhs);
        public static bool3x4 operator &(bool lhs, bool3x4 rhs);
        public static bool3x4 operator |(bool3x4 lhs, bool3x4 rhs);
        public static bool3x4 operator |(bool3x4 lhs, bool rhs);
        public static bool3x4 operator |(bool lhs, bool3x4 rhs);
        public static bool3x4 operator ^(bool3x4 lhs, bool3x4 rhs);
        public static bool3x4 operator ^(bool3x4 lhs, bool rhs);
        public static bool3x4 operator ^(bool lhs, bool3x4 rhs);

        public static implicit operator bool3x4(bool v);
    }
}
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    [DebuggerTypeProxy(typeof(DebuggerProxy))]
    public struct bool4 : IEquatable<bool4>
    {
        public bool x;
        public bool y;
        public bool z;
        public bool w;

        public bool4(bool x, bool y, bool z, bool w);
        public bool4(bool x, bool y, bool2 zw);
        public bool4(bool x, bool2 yz, bool w);
        public bool4(bool x, bool3 yzw);
        public bool4(bool2 xy, bool z, bool w);
        public bool4(bool2 xy, bool2 zw);
        public bool4(bool3 xyz, bool w);
        public bool4(bool4 xyzw);
        public bool4(bool v);

        public bool this[int index] { get; set; }
        [EditorBrowsable(Never)]
        public bool4 xxxx { get; }
        [EditorBrowsable(Never)]
        public bool4 xxxy { get; }
        [EditorBrowsable(Never)]
        public bool4 xxxz { get; }
        [EditorBrowsable(Never)]
        public bool4 xxxw { get; }
        [EditorBrowsable(Never)]
        public bool4 xxyx { get; }
        [EditorBrowsable(Never)]
        public bool4 xxyy { get; }
        [EditorBrowsable(Never)]
        public bool4 xxyz { get; }
        [EditorBrowsable(Never)]
        public bool4 xxyw { get; }
        [EditorBrowsable(Never)]
        public bool4 xxzx { get; }
        [EditorBrowsable(Never)]
        public bool4 xxzy { get; }
        [EditorBrowsable(Never)]
        public bool4 xxzz { get; }
        [EditorBrowsable(Never)]
        public bool4 xxzw { get; }
        [EditorBrowsable(Never)]
        public bool4 xxwx { get; }
        [EditorBrowsable(Never)]
        public bool4 xxwy { get; }
        [EditorBrowsable(Never)]
        public bool4 xxwz { get; }
        [EditorBrowsable(Never)]
        public bool4 xxww { get; }
        [EditorBrowsable(Never)]
        public bool4 xyxx { get; }
        [EditorBrowsable(Never)]
        public bool4 xyxy { get; }
        [EditorBrowsable(Never)]
        public bool4 xyxz { get; }
        [EditorBrowsable(Never)]
        public bool4 xyxw { get; }
        [EditorBrowsable(Never)]
        public bool4 xyyx { get; }
        [EditorBrowsable(Never)]
        public bool4 xyyy { get; }
        [EditorBrowsable(Never)]
        public bool4 xyyz { get; }
        [EditorBrowsable(Never)]
        public bool4 xyyw { get; }
        [EditorBrowsable(Never)]
        public bool4 xyzx { get; }
        [EditorBrowsable(Never)]
        public bool4 xyzy { get; }
        [EditorBrowsable(Never)]
        public bool4 xyzz { get; }
        [EditorBrowsable(Never)]
        public bool4 xyzw { get; set; }
        [EditorBrowsable(Never)]
        public bool4 xywx { get; }
        [EditorBrowsable(Never)]
        public bool4 xywy { get; }
        [EditorBrowsable(Never)]
        public bool4 xywz { get; set; }
        [EditorBrowsable(Never)]
        public bool4 xyww { get; }
        [EditorBrowsable(Never)]
        public bool4 xzxx { get; }
        [EditorBrowsable(Never)]
        public bool4 xzxy { get; }
        [EditorBrowsable(Never)]
        public bool4 xzxz { get; }
        [EditorBrowsable(Never)]
        public bool4 xzxw { get; }
        [EditorBrowsable(Never)]
        public bool4 xzyx { get; }
        [EditorBrowsable(Never)]
        public bool4 xzyy { get; }
        [EditorBrowsable(Never)]
        public bool4 xzyz { get; }
        [EditorBrowsable(Never)]
        public bool4 xzyw { get; set; }
        [EditorBrowsable(Never)]
        public bool4 xzzx { get; }
        [EditorBrowsable(Never)]
        public bool4 xzzy { get; }
        [EditorBrowsable(Never)]
        public bool4 xzzz { get; }
        [EditorBrowsable(Never)]
        public bool4 xzzw { get; }
        [EditorBrowsable(Never)]
        public bool4 xzwx { get; }
        [EditorBrowsable(Never)]
        public bool4 xzwy { get; set; }
        [EditorBrowsable(Never)]
        public bool4 xzwz { get; }
        [EditorBrowsable(Never)]
        public bool4 xzww { get; }
        [EditorBrowsable(Never)]
        public bool4 xwxx { get; }
        [EditorBrowsable(Never)]
        public bool4 xwxy { get; }
        [EditorBrowsable(Never)]
        public bool4 xwxz { get; }
        [EditorBrowsable(Never)]
        public bool4 xwxw { get; }
        [EditorBrowsable(Never)]
        public bool4 xwyx { get; }
        [EditorBrowsable(Never)]
        public bool4 xwyy { get; }
        [EditorBrowsable(Never)]
        public bool4 xwyz { get; set; }
        [EditorBrowsable(Never)]
        public bool4 xwyw { get; }
        [EditorBrowsable(Never)]
        public bool4 xwzx { get; }
        [EditorBrowsable(Never)]
        public bool4 xwzy { get; set; }
        [EditorBrowsable(Never)]
        public bool4 xwzz { get; }
        [EditorBrowsable(Never)]
        public bool4 xwzw { get; }
        [EditorBrowsable(Never)]
        public bool4 xwwx { get; }
        [EditorBrowsable(Never)]
        public bool4 xwwy { get; }
        [EditorBrowsable(Never)]
        public bool4 xwwz { get; }
        [EditorBrowsable(Never)]
        public bool4 xwww { get; }
        [EditorBrowsable(Never)]
        public bool4 yxxx { get; }
        [EditorBrowsable(Never)]
        public bool4 yxxy { get; }
        [EditorBrowsable(Never)]
        public bool4 yxxz { get; }
        [EditorBrowsable(Never)]
        public bool4 yxxw { get; }
        [EditorBrowsable(Never)]
        public bool4 yxyx { get; }
        [EditorBrowsable(Never)]
        public bool4 yxyy { get; }
        [EditorBrowsable(Never)]
        public bool4 yxyz { get; }
        [EditorBrowsable(Never)]
        public bool4 yxyw { get; }
        [EditorBrowsable(Never)]
        public bool4 yxzx { get; }
        [EditorBrowsable(Never)]
        public bool4 yxzy { get; }
        [EditorBrowsable(Never)]
        public bool4 yxzz { get; }
        [EditorBrowsable(Never)]
        public bool4 yxzw { get; set; }
        [EditorBrowsable(Never)]
        public bool4 yxwx { get; }
        [EditorBrowsable(Never)]
        public bool4 yxwy { get; }
        [EditorBrowsable(Never)]
        public bool4 yxwz { get; set; }
        [EditorBrowsable(Never)]
        public bool4 yxww { get; }
        [EditorBrowsable(Never)]
        public bool4 yyxx { get; }
        [EditorBrowsable(Never)]
        public bool4 yyxy { get; }
        [EditorBrowsable(Never)]
        public bool4 yyxz { get; }
        [EditorBrowsable(Never)]
        public bool4 yyxw { get; }
        [EditorBrowsable(Never)]
        public bool4 yyyx { get; }
        [EditorBrowsable(Never)]
        public bool4 yyyy { get; }
        [EditorBrowsable(Never)]
        public bool4 yyyz { get; }
        [EditorBrowsable(Never)]
        public bool4 yyyw { get; }
        [EditorBrowsable(Never)]
        public bool4 yyzx { get; }
        [EditorBrowsable(Never)]
        public bool4 yyzy { get; }
        [EditorBrowsable(Never)]
        public bool4 yyzz { get; }
        [EditorBrowsable(Never)]
        public bool4 yyzw { get; }
        [EditorBrowsable(Never)]
        public bool4 yywx { get; }
        [EditorBrowsable(Never)]
        public bool4 yywy { get; }
        [EditorBrowsable(Never)]
        public bool4 yywz { get; }
        [EditorBrowsable(Never)]
        public bool4 yyww { get; }
        [EditorBrowsable(Never)]
        public bool4 yzxx { get; }
        [EditorBrowsable(Never)]
        public bool4 yzxy { get; }
        [EditorBrowsable(Never)]
        public bool4 yzxz { get; }
        [EditorBrowsable(Never)]
        public bool4 yzxw { get; set; }
        [EditorBrowsable(Never)]
        public bool4 yzyx { get; }
        [EditorBrowsable(Never)]
        public bool4 yzyy { get; }
        [EditorBrowsable(Never)]
        public bool4 yzyz { get; }
        [EditorBrowsable(Never)]
        public bool4 yzyw { get; }
        [EditorBrowsable(Never)]
        public bool4 yzzx { get; }
        [EditorBrowsable(Never)]
        public bool4 yzzy { get; }
        [EditorBrowsable(Never)]
        public bool4 yzzz { get; }
        [EditorBrowsable(Never)]
        public bool4 yzzw { get; }
        [EditorBrowsable(Never)]
        public bool4 yzwx { get; set; }
        [EditorBrowsable(Never)]
        public bool4 yzwy { get; }
        [EditorBrowsable(Never)]
        public bool4 yzwz { get; }
        [EditorBrowsable(Never)]
        public bool4 yzww { get; }
        [EditorBrowsable(Never)]
        public bool4 ywxx { get; }
        [EditorBrowsable(Never)]
        public bool4 ywxy { get; }
        [EditorBrowsable(Never)]
        public bool4 ywxz { get; set; }
        [EditorBrowsable(Never)]
        public bool4 ywxw { get; }
        [EditorBrowsable(Never)]
        public bool4 ywyx { get; }
        [EditorBrowsable(Never)]
        public bool4 ywyy { get; }
        [EditorBrowsable(Never)]
        public bool4 ywyz { get; }
        [EditorBrowsable(Never)]
        public bool4 ywyw { get; }
        [EditorBrowsable(Never)]
        public bool4 ywzx { get; set; }
        [EditorBrowsable(Never)]
        public bool4 ywzy { get; }
        [EditorBrowsable(Never)]
        public bool4 ywzz { get; }
        [EditorBrowsable(Never)]
        public bool4 ywzw { get; }
        [EditorBrowsable(Never)]
        public bool4 ywwx { get; }
        [EditorBrowsable(Never)]
        public bool4 ywwy { get; }
        [EditorBrowsable(Never)]
        public bool4 ywwz { get; }
        [EditorBrowsable(Never)]
        public bool4 ywww { get; }
        [EditorBrowsable(Never)]
        public bool4 zxxx { get; }
        [EditorBrowsable(Never)]
        public bool4 zxxy { get; }
        [EditorBrowsable(Never)]
        public bool4 zxxz { get; }
        [EditorBrowsable(Never)]
        public bool4 zxxw { get; }
        [EditorBrowsable(Never)]
        public bool4 zxyx { get; }
        [EditorBrowsable(Never)]
        public bool4 zxyy { get; }
        [EditorBrowsable(Never)]
        public bool4 zxyz { get; }
        [EditorBrowsable(Never)]
        public bool4 zxyw { get; set; }
        [EditorBrowsable(Never)]
        public bool4 zxzx { get; }
        [EditorBrowsable(Never)]
        public bool4 zxzy { get; }
        [EditorBrowsable(Never)]
        public bool4 zxzz { get; }
        [EditorBrowsable(Never)]
        public bool4 zxzw { get; }
        [EditorBrowsable(Never)]
        public bool4 zxwx { get; }
        [EditorBrowsable(Never)]
        public bool4 zxwy { get; set; }
        [EditorBrowsable(Never)]
        public bool4 zxwz { get; }
        [EditorBrowsable(Never)]
        public bool4 zxww { get; }
        [EditorBrowsable(Never)]
        public bool4 zyxx { get; }
        [EditorBrowsable(Never)]
        public bool4 zyxy { get; }
        [EditorBrowsable(Never)]
        public bool4 zyxz { get; }
        [EditorBrowsable(Never)]
        public bool4 zyxw { get; set; }
        [EditorBrowsable(Never)]
        public bool4 zyyx { get; }
        [EditorBrowsable(Never)]
        public bool4 zyyy { get; }
        [EditorBrowsable(Never)]
        public bool4 zyyz { get; }
        [EditorBrowsable(Never)]
        public bool4 zyyw { get; }
        [EditorBrowsable(Never)]
        public bool4 zyzx { get; }
        [EditorBrowsable(Never)]
        public bool4 zyzy { get; }
        [EditorBrowsable(Never)]
        public bool4 zyzz { get; }
        [EditorBrowsable(Never)]
        public bool4 zyzw { get; }
        [EditorBrowsable(Never)]
        public bool4 zywx { get; set; }
        [EditorBrowsable(Never)]
        public bool4 zywy { get; }
        [EditorBrowsable(Never)]
        public bool4 zywz { get; }
        [EditorBrowsable(Never)]
        public bool4 zyww { get; }
        [EditorBrowsable(Never)]
        public bool4 zzxx { get; }
        [EditorBrowsable(Never)]
        public bool4 zzxy { get; }
        [EditorBrowsable(Never)]
        public bool4 zzxz { get; }
        [EditorBrowsable(Never)]
        public bool4 zzxw { get; }
        [EditorBrowsable(Never)]
        public bool4 zzyx { get; }
        [EditorBrowsable(Never)]
        public bool4 zzyy { get; }
        [EditorBrowsable(Never)]
        public bool4 zzyz { get; }
        [EditorBrowsable(Never)]
        public bool4 zzyw { get; }
        [EditorBrowsable(Never)]
        public bool4 zzzx { get; }
        [EditorBrowsable(Never)]
        public bool4 zzzy { get; }
        [EditorBrowsable(Never)]
        public bool4 zzzz { get; }
        [EditorBrowsable(Never)]
        public bool4 zzzw { get; }
        [EditorBrowsable(Never)]
        public bool4 zzwx { get; }
        [EditorBrowsable(Never)]
        public bool4 zzwy { get; }
        [EditorBrowsable(Never)]
        public bool4 zzwz { get; }
        [EditorBrowsable(Never)]
        public bool4 zzww { get; }
        [EditorBrowsable(Never)]
        public bool4 zwxx { get; }
        [EditorBrowsable(Never)]
        public bool4 zwxy { get; set; }
        [EditorBrowsable(Never)]
        public bool4 zwxz { get; }
        [EditorBrowsable(Never)]
        public bool4 zwxw { get; }
        [EditorBrowsable(Never)]
        public bool4 zwyx { get; set; }
        [EditorBrowsable(Never)]
        public bool4 zwyy { get; }
        [EditorBrowsable(Never)]
        public bool4 zwyz { get; }
        [EditorBrowsable(Never)]
        public bool4 zwyw { get; }
        [EditorBrowsable(Never)]
        public bool4 zwzx { get; }
        [EditorBrowsable(Never)]
        public bool4 zwzy { get; }
        [EditorBrowsable(Never)]
        public bool4 zwzz { get; }
        [EditorBrowsable(Never)]
        public bool4 zwzw { get; }
        [EditorBrowsable(Never)]
        public bool4 zwwx { get; }
        [EditorBrowsable(Never)]
        public bool4 zwwy { get; }
        [EditorBrowsable(Never)]
        public bool4 zwwz { get; }
        [EditorBrowsable(Never)]
        public bool4 zwww { get; }
        [EditorBrowsable(Never)]
        public bool4 wxxx { get; }
        [EditorBrowsable(Never)]
        public bool4 wxxy { get; }
        [EditorBrowsable(Never)]
        public bool4 wxxz { get; }
        [EditorBrowsable(Never)]
        public bool4 wxxw { get; }
        [EditorBrowsable(Never)]
        public bool4 wxyx { get; }
        [EditorBrowsable(Never)]
        public bool4 wxyy { get; }
        [EditorBrowsable(Never)]
        public bool4 wxyz { get; set; }
        [EditorBrowsable(Never)]
        public bool4 wxyw { get; }
        [EditorBrowsable(Never)]
        public bool4 wxzx { get; }
        [EditorBrowsable(Never)]
        public bool4 wxzy { get; set; }
        [EditorBrowsable(Never)]
        public bool4 wxzz { get; }
        [EditorBrowsable(Never)]
        public bool4 wxzw { get; }
        [EditorBrowsable(Never)]
        public bool4 wxwx { get; }
        [EditorBrowsable(Never)]
        public bool4 wxwy { get; }
        [EditorBrowsable(Never)]
        public bool4 wxwz { get; }
        [EditorBrowsable(Never)]
        public bool4 wxww { get; }
        [EditorBrowsable(Never)]
        public bool4 wyxx { get; }
        [EditorBrowsable(Never)]
        public bool4 wyxy { get; }
        [EditorBrowsable(Never)]
        public bool4 wyxz { get; set; }
        [EditorBrowsable(Never)]
        public bool4 wyxw { get; }
        [EditorBrowsable(Never)]
        public bool4 wyyx { get; }
        [EditorBrowsable(Never)]
        public bool4 wyyy { get; }
        [EditorBrowsable(Never)]
        public bool4 wyyz { get; }
        [EditorBrowsable(Never)]
        public bool4 wyyw { get; }
        [EditorBrowsable(Never)]
        public bool4 wyzx { get; set; }
        [EditorBrowsable(Never)]
        public bool4 wyzy { get; }
        [EditorBrowsable(Never)]
        public bool4 wyzz { get; }
        [EditorBrowsable(Never)]
        public bool4 wyzw { get; }
        [EditorBrowsable(Never)]
        public bool4 wywx { get; }
        [EditorBrowsable(Never)]
        public bool4 wywy { get; }
        [EditorBrowsable(Never)]
        public bool4 wywz { get; }
        [EditorBrowsable(Never)]
        public bool4 wyww { get; }
        [EditorBrowsable(Never)]
        public bool4 wzxx { get; }
        [EditorBrowsable(Never)]
        public bool4 wzxy { get; set; }
        [EditorBrowsable(Never)]
        public bool4 wzxz { get; }
        [EditorBrowsable(Never)]
        public bool4 wzxw { get; }
        [EditorBrowsable(Never)]
        public bool4 wzyx { get; set; }
        [EditorBrowsable(Never)]
        public bool4 wzyy { get; }
        [EditorBrowsable(Never)]
        public bool4 wzyz { get; }
        [EditorBrowsable(Never)]
        public bool4 wzyw { get; }
        [EditorBrowsable(Never)]
        public bool4 wzzx { get; }
        [EditorBrowsable(Never)]
        public bool4 wzzy { get; }
        [EditorBrowsable(Never)]
        public bool4 wzzz { get; }
        [EditorBrowsable(Never)]
        public bool4 wzzw { get; }
        [EditorBrowsable(Never)]
        public bool4 wzwx { get; }
        [EditorBrowsable(Never)]
        public bool4 wzwy { get; }
        [EditorBrowsable(Never)]
        public bool4 wzwz { get; }
        [EditorBrowsable(Never)]
        public bool4 wzww { get; }
        [EditorBrowsable(Never)]
        public bool4 wwxx { get; }
        [EditorBrowsable(Never)]
        public bool4 wwxy { get; }
        [EditorBrowsable(Never)]
        public bool4 wwxz { get; }
        [EditorBrowsable(Never)]
        public bool4 wwxw { get; }
        [EditorBrowsable(Never)]
        public bool4 wwyx { get; }
        [EditorBrowsable(Never)]
        public bool4 wwyy { get; }
        [EditorBrowsable(Never)]
        public bool4 wwyz { get; }
        [EditorBrowsable(Never)]
        public bool4 wwyw { get; }
        [EditorBrowsable(Never)]
        public bool4 wwzx { get; }
        [EditorBrowsable(Never)]
        public bool4 wwzy { get; }
        [EditorBrowsable(Never)]
        public bool4 wwzz { get; }
        [EditorBrowsable(Never)]
        public bool4 wwzw { get; }
        [EditorBrowsable(Never)]
        public bool4 wwwx { get; }
        [EditorBrowsable(Never)]
        public bool4 wwwy { get; }
        [EditorBrowsable(Never)]
        public bool4 wwwz { get; }
        [EditorBrowsable(Never)]
        public bool4 wwww { get; }
        [EditorBrowsable(Never)]
        public bool3 xxx { get; }
        [EditorBrowsable(Never)]
        public bool3 xxy { get; }
        [EditorBrowsable(Never)]
        public bool3 xxz { get; }
        [EditorBrowsable(Never)]
        public bool3 xxw { get; }
        [EditorBrowsable(Never)]
        public bool3 xyx { get; }
        [EditorBrowsable(Never)]
        public bool3 xyy { get; }
        [EditorBrowsable(Never)]
        public bool3 xyz { get; set; }
        [EditorBrowsable(Never)]
        public bool3 xyw { get; set; }
        [EditorBrowsable(Never)]
        public bool3 xzx { get; }
        [EditorBrowsable(Never)]
        public bool3 xzy { get; set; }
        [EditorBrowsable(Never)]
        public bool3 xzz { get; }
        [EditorBrowsable(Never)]
        public bool3 xzw { get; set; }
        [EditorBrowsable(Never)]
        public bool3 xwx { get; }
        [EditorBrowsable(Never)]
        public bool3 xwy { get; set; }
        [EditorBrowsable(Never)]
        public bool3 xwz { get; set; }
        [EditorBrowsable(Never)]
        public bool3 xww { get; }
        [EditorBrowsable(Never)]
        public bool3 yxx { get; }
        [EditorBrowsable(Never)]
        public bool3 yxy { get; }
        [EditorBrowsable(Never)]
        public bool3 yxz { get; set; }
        [EditorBrowsable(Never)]
        public bool3 yxw { get; set; }
        [EditorBrowsable(Never)]
        public bool3 yyx { get; }
        [EditorBrowsable(Never)]
        public bool3 yyy { get; }
        [EditorBrowsable(Never)]
        public bool3 yyz { get; }
        [EditorBrowsable(Never)]
        public bool3 yyw { get; }
        [EditorBrowsable(Never)]
        public bool3 yzx { get; set; }
        [EditorBrowsable(Never)]
        public bool3 yzy { get; }
        [EditorBrowsable(Never)]
        public bool3 yzz { get; }
        [EditorBrowsable(Never)]
        public bool3 yzw { get; set; }
        [EditorBrowsable(Never)]
        public bool3 ywx { get; set; }
        [EditorBrowsable(Never)]
        public bool3 ywy { get; }
        [EditorBrowsable(Never)]
        public bool3 ywz { get; set; }
        [EditorBrowsable(Never)]
        public bool3 yww { get; }
        [EditorBrowsable(Never)]
        public bool3 zxx { get; }
        [EditorBrowsable(Never)]
        public bool3 zxy { get; set; }
        [EditorBrowsable(Never)]
        public bool3 zxz { get; }
        [EditorBrowsable(Never)]
        public bool3 zxw { get; set; }
        [EditorBrowsable(Never)]
        public bool3 zyx { get; set; }
        [EditorBrowsable(Never)]
        public bool3 zyy { get; }
        [EditorBrowsable(Never)]
        public bool3 zyz { get; }
        [EditorBrowsable(Never)]
        public bool3 zyw { get; set; }
        [EditorBrowsable(Never)]
        public bool3 zzx { get; }
        [EditorBrowsable(Never)]
        public bool3 zzy { get; }
        [EditorBrowsable(Never)]
        public bool3 zzz { get; }
        [EditorBrowsable(Never)]
        public bool3 zzw { get; }
        [EditorBrowsable(Never)]
        public bool3 zwx { get; set; }
        [EditorBrowsable(Never)]
        public bool3 zwy { get; set; }
        [EditorBrowsable(Never)]
        public bool3 zwz { get; }
        [EditorBrowsable(Never)]
        public bool3 zww { get; }
        [EditorBrowsable(Never)]
        public bool3 wxx { get; }
        [EditorBrowsable(Never)]
        public bool3 wxy { get; set; }
        [EditorBrowsable(Never)]
        public bool3 wxz { get; set; }
        [EditorBrowsable(Never)]
        public bool3 wxw { get; }
        [EditorBrowsable(Never)]
        public bool3 wyx { get; set; }
        [EditorBrowsable(Never)]
        public bool3 wyy { get; }
        [EditorBrowsable(Never)]
        public bool3 wyz { get; set; }
        [EditorBrowsable(Never)]
        public bool3 wyw { get; }
        [EditorBrowsable(Never)]
        public bool3 wzx { get; set; }
        [EditorBrowsable(Never)]
        public bool3 wzy { get; set; }
        [EditorBrowsable(Never)]
        public bool3 wzz { get; }
        [EditorBrowsable(Never)]
        public bool3 wzw { get; }
        [EditorBrowsable(Never)]
        public bool3 wwx { get; }
        [EditorBrowsable(Never)]
        public bool3 wwy { get; }
        [EditorBrowsable(Never)]
        public bool3 wwz { get; }
        [EditorBrowsable(Never)]
        public bool3 www { get; }
        [EditorBrowsable(Never)]
        public bool2 xx { get; }
        [EditorBrowsable(Never)]
        public bool2 xy { get; set; }
        [EditorBrowsable(Never)]
        public bool2 xz { get; set; }
        [EditorBrowsable(Never)]
        public bool2 xw { get; set; }
        [EditorBrowsable(Never)]
        public bool2 yx { get; set; }
        [EditorBrowsable(Never)]
        public bool2 yy { get; }
        [EditorBrowsable(Never)]
        public bool2 yz { get; set; }
        [EditorBrowsable(Never)]
        public bool2 yw { get; set; }
        [EditorBrowsable(Never)]
        public bool2 zx { get; set; }
        [EditorBrowsable(Never)]
        public bool2 zy { get; set; }
        [EditorBrowsable(Never)]
        public bool2 zz { get; }
        [EditorBrowsable(Never)]
        public bool2 zw { get; set; }
        [EditorBrowsable(Never)]
        public bool2 wx { get; set; }
        [EditorBrowsable(Never)]
        public bool2 wy { get; set; }
        [EditorBrowsable(Never)]
        public bool2 wz { get; set; }
        [EditorBrowsable(Never)]
        public bool2 ww { get; }

        public bool Equals(bool4 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();

        public static bool4 operator ==(bool4 lhs, bool4 rhs);
        public static bool4 operator ==(bool4 lhs, bool rhs);
        public static bool4 operator ==(bool lhs, bool4 rhs);
        public static bool4 operator !=(bool4 lhs, bool4 rhs);
        public static bool4 operator !=(bool4 lhs, bool rhs);
        public static bool4 operator !=(bool lhs, bool4 rhs);
        public static bool4 operator !(bool4 val);
        public static bool4 operator &(bool4 lhs, bool4 rhs);
        public static bool4 operator &(bool4 lhs, bool rhs);
        public static bool4 operator &(bool lhs, bool4 rhs);
        public static bool4 operator |(bool4 lhs, bool4 rhs);
        public static bool4 operator |(bool4 lhs, bool rhs);
        public static bool4 operator |(bool lhs, bool4 rhs);
        public static bool4 operator ^(bool4 lhs, bool4 rhs);
        public static bool4 operator ^(bool4 lhs, bool rhs);
        public static bool4 operator ^(bool lhs, bool4 rhs);

        public static implicit operator bool4(bool v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct bool4x2 : IEquatable<bool4x2>
    {
        public bool4 c0;
        public bool4 c1;

        public bool4x2(bool4 c0, bool4 c1);
        public bool4x2(bool m00, bool m01, bool m10, bool m11, bool m20, bool m21, bool m30, bool m31);
        public bool4x2(bool v);

        public ref bool4 this[int index] { get; }

        public bool Equals(bool4x2 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();

        public static bool4x2 operator ==(bool4x2 lhs, bool4x2 rhs);
        public static bool4x2 operator ==(bool4x2 lhs, bool rhs);
        public static bool4x2 operator ==(bool lhs, bool4x2 rhs);
        public static bool4x2 operator !=(bool4x2 lhs, bool4x2 rhs);
        public static bool4x2 operator !=(bool4x2 lhs, bool rhs);
        public static bool4x2 operator !=(bool lhs, bool4x2 rhs);
        public static bool4x2 operator !(bool4x2 val);
        public static bool4x2 operator &(bool4x2 lhs, bool4x2 rhs);
        public static bool4x2 operator &(bool4x2 lhs, bool rhs);
        public static bool4x2 operator &(bool lhs, bool4x2 rhs);
        public static bool4x2 operator |(bool4x2 lhs, bool4x2 rhs);
        public static bool4x2 operator |(bool4x2 lhs, bool rhs);
        public static bool4x2 operator |(bool lhs, bool4x2 rhs);
        public static bool4x2 operator ^(bool4x2 lhs, bool4x2 rhs);
        public static bool4x2 operator ^(bool4x2 lhs, bool rhs);
        public static bool4x2 operator ^(bool lhs, bool4x2 rhs);

        public static implicit operator bool4x2(bool v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct bool4x3 : IEquatable<bool4x3>
    {
        public bool4 c0;
        public bool4 c1;
        public bool4 c2;

        public bool4x3(bool4 c0, bool4 c1, bool4 c2);
        public bool4x3(bool m00, bool m01, bool m02, bool m10, bool m11, bool m12, bool m20, bool m21, bool m22, bool m30, bool m31, bool m32);
        public bool4x3(bool v);

        public ref bool4 this[int index] { get; }

        public bool Equals(bool4x3 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();

        public static bool4x3 operator ==(bool4x3 lhs, bool4x3 rhs);
        public static bool4x3 operator ==(bool4x3 lhs, bool rhs);
        public static bool4x3 operator ==(bool lhs, bool4x3 rhs);
        public static bool4x3 operator !=(bool4x3 lhs, bool4x3 rhs);
        public static bool4x3 operator !=(bool4x3 lhs, bool rhs);
        public static bool4x3 operator !=(bool lhs, bool4x3 rhs);
        public static bool4x3 operator !(bool4x3 val);
        public static bool4x3 operator &(bool4x3 lhs, bool4x3 rhs);
        public static bool4x3 operator &(bool4x3 lhs, bool rhs);
        public static bool4x3 operator &(bool lhs, bool4x3 rhs);
        public static bool4x3 operator |(bool4x3 lhs, bool4x3 rhs);
        public static bool4x3 operator |(bool4x3 lhs, bool rhs);
        public static bool4x3 operator |(bool lhs, bool4x3 rhs);
        public static bool4x3 operator ^(bool4x3 lhs, bool4x3 rhs);
        public static bool4x3 operator ^(bool4x3 lhs, bool rhs);
        public static bool4x3 operator ^(bool lhs, bool4x3 rhs);

        public static implicit operator bool4x3(bool v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct bool4x4 : IEquatable<bool4x4>
    {
        public bool4 c0;
        public bool4 c1;
        public bool4 c2;
        public bool4 c3;

        public bool4x4(bool4 c0, bool4 c1, bool4 c2, bool4 c3);
        public bool4x4(bool m00, bool m01, bool m02, bool m03, bool m10, bool m11, bool m12, bool m13, bool m20, bool m21, bool m22, bool m23, bool m30, bool m31, bool m32, bool m33);
        public bool4x4(bool v);

        public ref bool4 this[int index] { get; }

        public bool Equals(bool4x4 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();

        public static bool4x4 operator ==(bool4x4 lhs, bool4x4 rhs);
        public static bool4x4 operator ==(bool4x4 lhs, bool rhs);
        public static bool4x4 operator ==(bool lhs, bool4x4 rhs);
        public static bool4x4 operator !=(bool4x4 lhs, bool4x4 rhs);
        public static bool4x4 operator !=(bool4x4 lhs, bool rhs);
        public static bool4x4 operator !=(bool lhs, bool4x4 rhs);
        public static bool4x4 operator !(bool4x4 val);
        public static bool4x4 operator &(bool4x4 lhs, bool4x4 rhs);
        public static bool4x4 operator &(bool4x4 lhs, bool rhs);
        public static bool4x4 operator &(bool lhs, bool4x4 rhs);
        public static bool4x4 operator |(bool4x4 lhs, bool4x4 rhs);
        public static bool4x4 operator |(bool4x4 lhs, bool rhs);
        public static bool4x4 operator |(bool lhs, bool4x4 rhs);
        public static bool4x4 operator ^(bool4x4 lhs, bool4x4 rhs);
        public static bool4x4 operator ^(bool4x4 lhs, bool rhs);
        public static bool4x4 operator ^(bool lhs, bool4x4 rhs);

        public static implicit operator bool4x4(bool v);
    }
}
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    [DebuggerTypeProxy(typeof(DebuggerProxy))]
    public struct double2 : IEquatable<double2>, IFormattable
    {
        public double x;
        public double y;
        public static readonly double2 zero;

        public double2(double x, double y);
        public double2(double2 xy);
        public double2(double v);
        public double2(bool v);
        public double2(bool2 v);
        public double2(int v);
        public double2(int2 v);
        public double2(uint v);
        public double2(uint2 v);
        public double2(half v);
        public double2(half2 v);
        public double2(float v);
        public double2(float2 v);

        public double this[int index] { get; set; }
        [EditorBrowsable(Never)]
        public double4 xxxx { get; }
        [EditorBrowsable(Never)]
        public double4 xxxy { get; }
        [EditorBrowsable(Never)]
        public double4 xxyx { get; }
        [EditorBrowsable(Never)]
        public double4 xxyy { get; }
        [EditorBrowsable(Never)]
        public double4 xyxx { get; }
        [EditorBrowsable(Never)]
        public double4 xyxy { get; }
        [EditorBrowsable(Never)]
        public double4 xyyx { get; }
        [EditorBrowsable(Never)]
        public double4 xyyy { get; }
        [EditorBrowsable(Never)]
        public double4 yxxx { get; }
        [EditorBrowsable(Never)]
        public double4 yxxy { get; }
        [EditorBrowsable(Never)]
        public double4 yxyx { get; }
        [EditorBrowsable(Never)]
        public double4 yxyy { get; }
        [EditorBrowsable(Never)]
        public double4 yyxx { get; }
        [EditorBrowsable(Never)]
        public double4 yyxy { get; }
        [EditorBrowsable(Never)]
        public double4 yyyx { get; }
        [EditorBrowsable(Never)]
        public double4 yyyy { get; }
        [EditorBrowsable(Never)]
        public double3 xxx { get; }
        [EditorBrowsable(Never)]
        public double3 xxy { get; }
        [EditorBrowsable(Never)]
        public double3 xyx { get; }
        [EditorBrowsable(Never)]
        public double3 xyy { get; }
        [EditorBrowsable(Never)]
        public double3 yxx { get; }
        [EditorBrowsable(Never)]
        public double3 yxy { get; }
        [EditorBrowsable(Never)]
        public double3 yyx { get; }
        [EditorBrowsable(Never)]
        public double3 yyy { get; }
        [EditorBrowsable(Never)]
        public double2 xx { get; }
        [EditorBrowsable(Never)]
        public double2 xy { get; set; }
        [EditorBrowsable(Never)]
        public double2 yx { get; set; }
        [EditorBrowsable(Never)]
        public double2 yy { get; }

        public bool Equals(double2 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static double2 operator *(double2 lhs, double2 rhs);
        public static double2 operator *(double2 lhs, double rhs);
        public static double2 operator *(double lhs, double2 rhs);
        public static double2 operator +(double2 lhs, double2 rhs);
        public static double2 operator +(double2 lhs, double rhs);
        public static double2 operator +(double lhs, double2 rhs);
        public static double2 operator -(double2 lhs, double2 rhs);
        public static double2 operator -(double2 lhs, double rhs);
        public static double2 operator -(double lhs, double2 rhs);
        public static double2 operator /(double2 lhs, double2 rhs);
        public static double2 operator /(double2 lhs, double rhs);
        public static double2 operator /(double lhs, double2 rhs);
        public static double2 operator %(double2 lhs, double2 rhs);
        public static double2 operator %(double2 lhs, double rhs);
        public static double2 operator %(double lhs, double2 rhs);
        public static double2 operator ++(double2 val);
        public static double2 operator --(double2 val);
        public static bool2 operator <(double2 lhs, double2 rhs);
        public static bool2 operator <(double2 lhs, double rhs);
        public static bool2 operator <(double lhs, double2 rhs);
        public static bool2 operator <=(double2 lhs, double2 rhs);
        public static bool2 operator <=(double2 lhs, double rhs);
        public static bool2 operator <=(double lhs, double2 rhs);
        public static bool2 operator >(double2 lhs, double2 rhs);
        public static bool2 operator >(double2 lhs, double rhs);
        public static bool2 operator >(double lhs, double2 rhs);
        public static bool2 operator >=(double2 lhs, double2 rhs);
        public static bool2 operator >=(double2 lhs, double rhs);
        public static bool2 operator >=(double lhs, double2 rhs);
        public static double2 operator -(double2 val);
        public static double2 operator +(double2 val);
        public static bool2 operator ==(double2 lhs, double2 rhs);
        public static bool2 operator ==(double2 lhs, double rhs);
        public static bool2 operator ==(double lhs, double2 rhs);
        public static bool2 operator !=(double2 lhs, double2 rhs);
        public static bool2 operator !=(double2 lhs, double rhs);
        public static bool2 operator !=(double lhs, double2 rhs);

        public static implicit operator double2(double v);
        public static explicit operator double2(bool v);
        public static explicit operator double2(bool2 v);
        public static implicit operator double2(int v);
        public static implicit operator double2(int2 v);
        public static implicit operator double2(uint v);
        public static implicit operator double2(uint2 v);
        public static implicit operator double2(half v);
        public static implicit operator double2(half2 v);
        public static implicit operator double2(float v);
        public static implicit operator double2(float2 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct double2x2 : IEquatable<double2x2>, IFormattable
    {
        public double2 c0;
        public double2 c1;
        public static readonly double2x2 identity;
        public static readonly double2x2 zero;

        public double2x2(double2 c0, double2 c1);
        public double2x2(double m00, double m01, double m10, double m11);
        public double2x2(double v);
        public double2x2(bool v);
        public double2x2(bool2x2 v);
        public double2x2(int v);
        public double2x2(int2x2 v);
        public double2x2(uint v);
        public double2x2(uint2x2 v);
        public double2x2(float v);
        public double2x2(float2x2 v);

        public ref double2 this[int index] { get; }

        public bool Equals(double2x2 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static double2x2 operator *(double2x2 lhs, double2x2 rhs);
        public static double2x2 operator *(double2x2 lhs, double rhs);
        public static double2x2 operator *(double lhs, double2x2 rhs);
        public static double2x2 operator +(double2x2 lhs, double2x2 rhs);
        public static double2x2 operator +(double2x2 lhs, double rhs);
        public static double2x2 operator +(double lhs, double2x2 rhs);
        public static double2x2 operator -(double2x2 lhs, double2x2 rhs);
        public static double2x2 operator -(double2x2 lhs, double rhs);
        public static double2x2 operator -(double lhs, double2x2 rhs);
        public static double2x2 operator /(double2x2 lhs, double2x2 rhs);
        public static double2x2 operator /(double2x2 lhs, double rhs);
        public static double2x2 operator /(double lhs, double2x2 rhs);
        public static double2x2 operator %(double2x2 lhs, double2x2 rhs);
        public static double2x2 operator %(double2x2 lhs, double rhs);
        public static double2x2 operator %(double lhs, double2x2 rhs);
        public static double2x2 operator ++(double2x2 val);
        public static double2x2 operator --(double2x2 val);
        public static bool2x2 operator <(double2x2 lhs, double2x2 rhs);
        public static bool2x2 operator <(double2x2 lhs, double rhs);
        public static bool2x2 operator <(double lhs, double2x2 rhs);
        public static bool2x2 operator <=(double2x2 lhs, double2x2 rhs);
        public static bool2x2 operator <=(double2x2 lhs, double rhs);
        public static bool2x2 operator <=(double lhs, double2x2 rhs);
        public static bool2x2 operator >(double2x2 lhs, double2x2 rhs);
        public static bool2x2 operator >(double2x2 lhs, double rhs);
        public static bool2x2 operator >(double lhs, double2x2 rhs);
        public static bool2x2 operator >=(double2x2 lhs, double2x2 rhs);
        public static bool2x2 operator >=(double2x2 lhs, double rhs);
        public static bool2x2 operator >=(double lhs, double2x2 rhs);
        public static double2x2 operator -(double2x2 val);
        public static double2x2 operator +(double2x2 val);
        public static bool2x2 operator ==(double2x2 lhs, double2x2 rhs);
        public static bool2x2 operator ==(double2x2 lhs, double rhs);
        public static bool2x2 operator ==(double lhs, double2x2 rhs);
        public static bool2x2 operator !=(double2x2 lhs, double2x2 rhs);
        public static bool2x2 operator !=(double2x2 lhs, double rhs);
        public static bool2x2 operator !=(double lhs, double2x2 rhs);

        public static implicit operator double2x2(double v);
        public static explicit operator double2x2(bool v);
        public static explicit operator double2x2(bool2x2 v);
        public static implicit operator double2x2(int v);
        public static implicit operator double2x2(int2x2 v);
        public static implicit operator double2x2(uint v);
        public static implicit operator double2x2(uint2x2 v);
        public static implicit operator double2x2(float v);
        public static implicit operator double2x2(float2x2 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct double2x3 : IEquatable<double2x3>, IFormattable
    {
        public double2 c0;
        public double2 c1;
        public double2 c2;
        public static readonly double2x3 zero;

        public double2x3(double2 c0, double2 c1, double2 c2);
        public double2x3(double m00, double m01, double m02, double m10, double m11, double m12);
        public double2x3(double v);
        public double2x3(bool v);
        public double2x3(bool2x3 v);
        public double2x3(int v);
        public double2x3(int2x3 v);
        public double2x3(uint v);
        public double2x3(uint2x3 v);
        public double2x3(float v);
        public double2x3(float2x3 v);

        public ref double2 this[int index] { get; }

        public bool Equals(double2x3 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static double2x3 operator *(double2x3 lhs, double2x3 rhs);
        public static double2x3 operator *(double2x3 lhs, double rhs);
        public static double2x3 operator *(double lhs, double2x3 rhs);
        public static double2x3 operator +(double2x3 lhs, double2x3 rhs);
        public static double2x3 operator +(double2x3 lhs, double rhs);
        public static double2x3 operator +(double lhs, double2x3 rhs);
        public static double2x3 operator -(double2x3 lhs, double2x3 rhs);
        public static double2x3 operator -(double2x3 lhs, double rhs);
        public static double2x3 operator -(double lhs, double2x3 rhs);
        public static double2x3 operator /(double2x3 lhs, double2x3 rhs);
        public static double2x3 operator /(double2x3 lhs, double rhs);
        public static double2x3 operator /(double lhs, double2x3 rhs);
        public static double2x3 operator %(double2x3 lhs, double2x3 rhs);
        public static double2x3 operator %(double2x3 lhs, double rhs);
        public static double2x3 operator %(double lhs, double2x3 rhs);
        public static double2x3 operator ++(double2x3 val);
        public static double2x3 operator --(double2x3 val);
        public static bool2x3 operator <(double2x3 lhs, double2x3 rhs);
        public static bool2x3 operator <(double2x3 lhs, double rhs);
        public static bool2x3 operator <(double lhs, double2x3 rhs);
        public static bool2x3 operator <=(double2x3 lhs, double2x3 rhs);
        public static bool2x3 operator <=(double2x3 lhs, double rhs);
        public static bool2x3 operator <=(double lhs, double2x3 rhs);
        public static bool2x3 operator >(double2x3 lhs, double2x3 rhs);
        public static bool2x3 operator >(double2x3 lhs, double rhs);
        public static bool2x3 operator >(double lhs, double2x3 rhs);
        public static bool2x3 operator >=(double2x3 lhs, double2x3 rhs);
        public static bool2x3 operator >=(double2x3 lhs, double rhs);
        public static bool2x3 operator >=(double lhs, double2x3 rhs);
        public static double2x3 operator -(double2x3 val);
        public static double2x3 operator +(double2x3 val);
        public static bool2x3 operator ==(double2x3 lhs, double2x3 rhs);
        public static bool2x3 operator ==(double2x3 lhs, double rhs);
        public static bool2x3 operator ==(double lhs, double2x3 rhs);
        public static bool2x3 operator !=(double2x3 lhs, double2x3 rhs);
        public static bool2x3 operator !=(double2x3 lhs, double rhs);
        public static bool2x3 operator !=(double lhs, double2x3 rhs);

        public static implicit operator double2x3(double v);
        public static explicit operator double2x3(bool v);
        public static explicit operator double2x3(bool2x3 v);
        public static implicit operator double2x3(int v);
        public static implicit operator double2x3(int2x3 v);
        public static implicit operator double2x3(uint v);
        public static implicit operator double2x3(uint2x3 v);
        public static implicit operator double2x3(float v);
        public static implicit operator double2x3(float2x3 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct double2x4 : IEquatable<double2x4>, IFormattable
    {
        public double2 c0;
        public double2 c1;
        public double2 c2;
        public double2 c3;
        public static readonly double2x4 zero;

        public double2x4(double2 c0, double2 c1, double2 c2, double2 c3);
        public double2x4(double m00, double m01, double m02, double m03, double m10, double m11, double m12, double m13);
        public double2x4(double v);
        public double2x4(bool v);
        public double2x4(bool2x4 v);
        public double2x4(int v);
        public double2x4(int2x4 v);
        public double2x4(uint v);
        public double2x4(uint2x4 v);
        public double2x4(float v);
        public double2x4(float2x4 v);

        public ref double2 this[int index] { get; }

        public bool Equals(double2x4 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static double2x4 operator *(double2x4 lhs, double2x4 rhs);
        public static double2x4 operator *(double2x4 lhs, double rhs);
        public static double2x4 operator *(double lhs, double2x4 rhs);
        public static double2x4 operator +(double2x4 lhs, double2x4 rhs);
        public static double2x4 operator +(double2x4 lhs, double rhs);
        public static double2x4 operator +(double lhs, double2x4 rhs);
        public static double2x4 operator -(double2x4 lhs, double2x4 rhs);
        public static double2x4 operator -(double2x4 lhs, double rhs);
        public static double2x4 operator -(double lhs, double2x4 rhs);
        public static double2x4 operator /(double2x4 lhs, double2x4 rhs);
        public static double2x4 operator /(double2x4 lhs, double rhs);
        public static double2x4 operator /(double lhs, double2x4 rhs);
        public static double2x4 operator %(double2x4 lhs, double2x4 rhs);
        public static double2x4 operator %(double2x4 lhs, double rhs);
        public static double2x4 operator %(double lhs, double2x4 rhs);
        public static double2x4 operator ++(double2x4 val);
        public static double2x4 operator --(double2x4 val);
        public static bool2x4 operator <(double2x4 lhs, double2x4 rhs);
        public static bool2x4 operator <(double2x4 lhs, double rhs);
        public static bool2x4 operator <(double lhs, double2x4 rhs);
        public static bool2x4 operator <=(double2x4 lhs, double2x4 rhs);
        public static bool2x4 operator <=(double2x4 lhs, double rhs);
        public static bool2x4 operator <=(double lhs, double2x4 rhs);
        public static bool2x4 operator >(double2x4 lhs, double2x4 rhs);
        public static bool2x4 operator >(double2x4 lhs, double rhs);
        public static bool2x4 operator >(double lhs, double2x4 rhs);
        public static bool2x4 operator >=(double2x4 lhs, double2x4 rhs);
        public static bool2x4 operator >=(double2x4 lhs, double rhs);
        public static bool2x4 operator >=(double lhs, double2x4 rhs);
        public static double2x4 operator -(double2x4 val);
        public static double2x4 operator +(double2x4 val);
        public static bool2x4 operator ==(double2x4 lhs, double2x4 rhs);
        public static bool2x4 operator ==(double2x4 lhs, double rhs);
        public static bool2x4 operator ==(double lhs, double2x4 rhs);
        public static bool2x4 operator !=(double2x4 lhs, double2x4 rhs);
        public static bool2x4 operator !=(double2x4 lhs, double rhs);
        public static bool2x4 operator !=(double lhs, double2x4 rhs);

        public static implicit operator double2x4(double v);
        public static explicit operator double2x4(bool v);
        public static explicit operator double2x4(bool2x4 v);
        public static implicit operator double2x4(int v);
        public static implicit operator double2x4(int2x4 v);
        public static implicit operator double2x4(uint v);
        public static implicit operator double2x4(uint2x4 v);
        public static implicit operator double2x4(float v);
        public static implicit operator double2x4(float2x4 v);
    }
}
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    [DebuggerTypeProxy(typeof(DebuggerProxy))]
    public struct double3 : IEquatable<double3>, IFormattable
    {
        public double x;
        public double y;
        public double z;
        public static readonly double3 zero;

        public double3(double x, double y, double z);
        public double3(double x, double2 yz);
        public double3(double2 xy, double z);
        public double3(double3 xyz);
        public double3(double v);
        public double3(bool v);
        public double3(bool3 v);
        public double3(int v);
        public double3(int3 v);
        public double3(uint v);
        public double3(uint3 v);
        public double3(half v);
        public double3(half3 v);
        public double3(float v);
        public double3(float3 v);

        public double this[int index] { get; set; }
        [EditorBrowsable(Never)]
        public double4 xxxx { get; }
        [EditorBrowsable(Never)]
        public double4 xxxy { get; }
        [EditorBrowsable(Never)]
        public double4 xxxz { get; }
        [EditorBrowsable(Never)]
        public double4 xxyx { get; }
        [EditorBrowsable(Never)]
        public double4 xxyy { get; }
        [EditorBrowsable(Never)]
        public double4 xxyz { get; }
        [EditorBrowsable(Never)]
        public double4 xxzx { get; }
        [EditorBrowsable(Never)]
        public double4 xxzy { get; }
        [EditorBrowsable(Never)]
        public double4 xxzz { get; }
        [EditorBrowsable(Never)]
        public double4 xyxx { get; }
        [EditorBrowsable(Never)]
        public double4 xyxy { get; }
        [EditorBrowsable(Never)]
        public double4 xyxz { get; }
        [EditorBrowsable(Never)]
        public double4 xyyx { get; }
        [EditorBrowsable(Never)]
        public double4 xyyy { get; }
        [EditorBrowsable(Never)]
        public double4 xyyz { get; }
        [EditorBrowsable(Never)]
        public double4 xyzx { get; }
        [EditorBrowsable(Never)]
        public double4 xyzy { get; }
        [EditorBrowsable(Never)]
        public double4 xyzz { get; }
        [EditorBrowsable(Never)]
        public double4 xzxx { get; }
        [EditorBrowsable(Never)]
        public double4 xzxy { get; }
        [EditorBrowsable(Never)]
        public double4 xzxz { get; }
        [EditorBrowsable(Never)]
        public double4 xzyx { get; }
        [EditorBrowsable(Never)]
        public double4 xzyy { get; }
        [EditorBrowsable(Never)]
        public double4 xzyz { get; }
        [EditorBrowsable(Never)]
        public double4 xzzx { get; }
        [EditorBrowsable(Never)]
        public double4 xzzy { get; }
        [EditorBrowsable(Never)]
        public double4 xzzz { get; }
        [EditorBrowsable(Never)]
        public double4 yxxx { get; }
        [EditorBrowsable(Never)]
        public double4 yxxy { get; }
        [EditorBrowsable(Never)]
        public double4 yxxz { get; }
        [EditorBrowsable(Never)]
        public double4 yxyx { get; }
        [EditorBrowsable(Never)]
        public double4 yxyy { get; }
        [EditorBrowsable(Never)]
        public double4 yxyz { get; }
        [EditorBrowsable(Never)]
        public double4 yxzx { get; }
        [EditorBrowsable(Never)]
        public double4 yxzy { get; }
        [EditorBrowsable(Never)]
        public double4 yxzz { get; }
        [EditorBrowsable(Never)]
        public double4 yyxx { get; }
        [EditorBrowsable(Never)]
        public double4 yyxy { get; }
        [EditorBrowsable(Never)]
        public double4 yyxz { get; }
        [EditorBrowsable(Never)]
        public double4 yyyx { get; }
        [EditorBrowsable(Never)]
        public double4 yyyy { get; }
        [EditorBrowsable(Never)]
        public double4 yyyz { get; }
        [EditorBrowsable(Never)]
        public double4 yyzx { get; }
        [EditorBrowsable(Never)]
        public double4 yyzy { get; }
        [EditorBrowsable(Never)]
        public double4 yyzz { get; }
        [EditorBrowsable(Never)]
        public double4 yzxx { get; }
        [EditorBrowsable(Never)]
        public double4 yzxy { get; }
        [EditorBrowsable(Never)]
        public double4 yzxz { get; }
        [EditorBrowsable(Never)]
        public double4 yzyx { get; }
        [EditorBrowsable(Never)]
        public double4 yzyy { get; }
        [EditorBrowsable(Never)]
        public double4 yzyz { get; }
        [EditorBrowsable(Never)]
        public double4 yzzx { get; }
        [EditorBrowsable(Never)]
        public double4 yzzy { get; }
        [EditorBrowsable(Never)]
        public double4 yzzz { get; }
        [EditorBrowsable(Never)]
        public double4 zxxx { get; }
        [EditorBrowsable(Never)]
        public double4 zxxy { get; }
        [EditorBrowsable(Never)]
        public double4 zxxz { get; }
        [EditorBrowsable(Never)]
        public double4 zxyx { get; }
        [EditorBrowsable(Never)]
        public double4 zxyy { get; }
        [EditorBrowsable(Never)]
        public double4 zxyz { get; }
        [EditorBrowsable(Never)]
        public double4 zxzx { get; }
        [EditorBrowsable(Never)]
        public double4 zxzy { get; }
        [EditorBrowsable(Never)]
        public double4 zxzz { get; }
        [EditorBrowsable(Never)]
        public double4 zyxx { get; }
        [EditorBrowsable(Never)]
        public double4 zyxy { get; }
        [EditorBrowsable(Never)]
        public double4 zyxz { get; }
        [EditorBrowsable(Never)]
        public double4 zyyx { get; }
        [EditorBrowsable(Never)]
        public double4 zyyy { get; }
        [EditorBrowsable(Never)]
        public double4 zyyz { get; }
        [EditorBrowsable(Never)]
        public double4 zyzx { get; }
        [EditorBrowsable(Never)]
        public double4 zyzy { get; }
        [EditorBrowsable(Never)]
        public double4 zyzz { get; }
        [EditorBrowsable(Never)]
        public double4 zzxx { get; }
        [EditorBrowsable(Never)]
        public double4 zzxy { get; }
        [EditorBrowsable(Never)]
        public double4 zzxz { get; }
        [EditorBrowsable(Never)]
        public double4 zzyx { get; }
        [EditorBrowsable(Never)]
        public double4 zzyy { get; }
        [EditorBrowsable(Never)]
        public double4 zzyz { get; }
        [EditorBrowsable(Never)]
        public double4 zzzx { get; }
        [EditorBrowsable(Never)]
        public double4 zzzy { get; }
        [EditorBrowsable(Never)]
        public double4 zzzz { get; }
        [EditorBrowsable(Never)]
        public double3 xxx { get; }
        [EditorBrowsable(Never)]
        public double3 xxy { get; }
        [EditorBrowsable(Never)]
        public double3 xxz { get; }
        [EditorBrowsable(Never)]
        public double3 xyx { get; }
        [EditorBrowsable(Never)]
        public double3 xyy { get; }
        [EditorBrowsable(Never)]
        public double3 xyz { get; set; }
        [EditorBrowsable(Never)]
        public double3 xzx { get; }
        [EditorBrowsable(Never)]
        public double3 xzy { get; set; }
        [EditorBrowsable(Never)]
        public double3 xzz { get; }
        [EditorBrowsable(Never)]
        public double3 yxx { get; }
        [EditorBrowsable(Never)]
        public double3 yxy { get; }
        [EditorBrowsable(Never)]
        public double3 yxz { get; set; }
        [EditorBrowsable(Never)]
        public double3 yyx { get; }
        [EditorBrowsable(Never)]
        public double3 yyy { get; }
        [EditorBrowsable(Never)]
        public double3 yyz { get; }
        [EditorBrowsable(Never)]
        public double3 yzx { get; set; }
        [EditorBrowsable(Never)]
        public double3 yzy { get; }
        [EditorBrowsable(Never)]
        public double3 yzz { get; }
        [EditorBrowsable(Never)]
        public double3 zxx { get; }
        [EditorBrowsable(Never)]
        public double3 zxy { get; set; }
        [EditorBrowsable(Never)]
        public double3 zxz { get; }
        [EditorBrowsable(Never)]
        public double3 zyx { get; set; }
        [EditorBrowsable(Never)]
        public double3 zyy { get; }
        [EditorBrowsable(Never)]
        public double3 zyz { get; }
        [EditorBrowsable(Never)]
        public double3 zzx { get; }
        [EditorBrowsable(Never)]
        public double3 zzy { get; }
        [EditorBrowsable(Never)]
        public double3 zzz { get; }
        [EditorBrowsable(Never)]
        public double2 xx { get; }
        [EditorBrowsable(Never)]
        public double2 xy { get; set; }
        [EditorBrowsable(Never)]
        public double2 xz { get; set; }
        [EditorBrowsable(Never)]
        public double2 yx { get; set; }
        [EditorBrowsable(Never)]
        public double2 yy { get; }
        [EditorBrowsable(Never)]
        public double2 yz { get; set; }
        [EditorBrowsable(Never)]
        public double2 zx { get; set; }
        [EditorBrowsable(Never)]
        public double2 zy { get; set; }
        [EditorBrowsable(Never)]
        public double2 zz { get; }

        public bool Equals(double3 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static double3 operator *(double3 lhs, double3 rhs);
        public static double3 operator *(double3 lhs, double rhs);
        public static double3 operator *(double lhs, double3 rhs);
        public static double3 operator +(double3 lhs, double3 rhs);
        public static double3 operator +(double3 lhs, double rhs);
        public static double3 operator +(double lhs, double3 rhs);
        public static double3 operator -(double3 lhs, double3 rhs);
        public static double3 operator -(double3 lhs, double rhs);
        public static double3 operator -(double lhs, double3 rhs);
        public static double3 operator /(double3 lhs, double3 rhs);
        public static double3 operator /(double3 lhs, double rhs);
        public static double3 operator /(double lhs, double3 rhs);
        public static double3 operator %(double3 lhs, double3 rhs);
        public static double3 operator %(double3 lhs, double rhs);
        public static double3 operator %(double lhs, double3 rhs);
        public static double3 operator ++(double3 val);
        public static double3 operator --(double3 val);
        public static bool3 operator <(double3 lhs, double3 rhs);
        public static bool3 operator <(double3 lhs, double rhs);
        public static bool3 operator <(double lhs, double3 rhs);
        public static bool3 operator <=(double3 lhs, double3 rhs);
        public static bool3 operator <=(double3 lhs, double rhs);
        public static bool3 operator <=(double lhs, double3 rhs);
        public static bool3 operator >(double3 lhs, double3 rhs);
        public static bool3 operator >(double3 lhs, double rhs);
        public static bool3 operator >(double lhs, double3 rhs);
        public static bool3 operator >=(double3 lhs, double3 rhs);
        public static bool3 operator >=(double3 lhs, double rhs);
        public static bool3 operator >=(double lhs, double3 rhs);
        public static double3 operator -(double3 val);
        public static double3 operator +(double3 val);
        public static bool3 operator ==(double3 lhs, double3 rhs);
        public static bool3 operator ==(double3 lhs, double rhs);
        public static bool3 operator ==(double lhs, double3 rhs);
        public static bool3 operator !=(double3 lhs, double3 rhs);
        public static bool3 operator !=(double3 lhs, double rhs);
        public static bool3 operator !=(double lhs, double3 rhs);

        public static implicit operator double3(double v);
        public static explicit operator double3(bool v);
        public static explicit operator double3(bool3 v);
        public static implicit operator double3(int v);
        public static implicit operator double3(int3 v);
        public static implicit operator double3(uint v);
        public static implicit operator double3(uint3 v);
        public static implicit operator double3(half v);
        public static implicit operator double3(half3 v);
        public static implicit operator double3(float v);
        public static implicit operator double3(float3 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct double3x2 : IEquatable<double3x2>, IFormattable
    {
        public double3 c0;
        public double3 c1;
        public static readonly double3x2 zero;

        public double3x2(double3 c0, double3 c1);
        public double3x2(double m00, double m01, double m10, double m11, double m20, double m21);
        public double3x2(double v);
        public double3x2(bool v);
        public double3x2(bool3x2 v);
        public double3x2(int v);
        public double3x2(int3x2 v);
        public double3x2(uint v);
        public double3x2(uint3x2 v);
        public double3x2(float v);
        public double3x2(float3x2 v);

        public ref double3 this[int index] { get; }

        public bool Equals(double3x2 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static double3x2 operator *(double3x2 lhs, double3x2 rhs);
        public static double3x2 operator *(double3x2 lhs, double rhs);
        public static double3x2 operator *(double lhs, double3x2 rhs);
        public static double3x2 operator +(double3x2 lhs, double3x2 rhs);
        public static double3x2 operator +(double3x2 lhs, double rhs);
        public static double3x2 operator +(double lhs, double3x2 rhs);
        public static double3x2 operator -(double3x2 lhs, double3x2 rhs);
        public static double3x2 operator -(double3x2 lhs, double rhs);
        public static double3x2 operator -(double lhs, double3x2 rhs);
        public static double3x2 operator /(double3x2 lhs, double3x2 rhs);
        public static double3x2 operator /(double3x2 lhs, double rhs);
        public static double3x2 operator /(double lhs, double3x2 rhs);
        public static double3x2 operator %(double3x2 lhs, double3x2 rhs);
        public static double3x2 operator %(double3x2 lhs, double rhs);
        public static double3x2 operator %(double lhs, double3x2 rhs);
        public static double3x2 operator ++(double3x2 val);
        public static double3x2 operator --(double3x2 val);
        public static bool3x2 operator <(double3x2 lhs, double3x2 rhs);
        public static bool3x2 operator <(double3x2 lhs, double rhs);
        public static bool3x2 operator <(double lhs, double3x2 rhs);
        public static bool3x2 operator <=(double3x2 lhs, double3x2 rhs);
        public static bool3x2 operator <=(double3x2 lhs, double rhs);
        public static bool3x2 operator <=(double lhs, double3x2 rhs);
        public static bool3x2 operator >(double3x2 lhs, double3x2 rhs);
        public static bool3x2 operator >(double3x2 lhs, double rhs);
        public static bool3x2 operator >(double lhs, double3x2 rhs);
        public static bool3x2 operator >=(double3x2 lhs, double3x2 rhs);
        public static bool3x2 operator >=(double3x2 lhs, double rhs);
        public static bool3x2 operator >=(double lhs, double3x2 rhs);
        public static double3x2 operator -(double3x2 val);
        public static double3x2 operator +(double3x2 val);
        public static bool3x2 operator ==(double3x2 lhs, double3x2 rhs);
        public static bool3x2 operator ==(double3x2 lhs, double rhs);
        public static bool3x2 operator ==(double lhs, double3x2 rhs);
        public static bool3x2 operator !=(double3x2 lhs, double3x2 rhs);
        public static bool3x2 operator !=(double3x2 lhs, double rhs);
        public static bool3x2 operator !=(double lhs, double3x2 rhs);

        public static implicit operator double3x2(double v);
        public static explicit operator double3x2(bool v);
        public static explicit operator double3x2(bool3x2 v);
        public static implicit operator double3x2(int v);
        public static implicit operator double3x2(int3x2 v);
        public static implicit operator double3x2(uint v);
        public static implicit operator double3x2(uint3x2 v);
        public static implicit operator double3x2(float v);
        public static implicit operator double3x2(float3x2 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct double3x3 : IEquatable<double3x3>, IFormattable
    {
        public double3 c0;
        public double3 c1;
        public double3 c2;
        public static readonly double3x3 identity;
        public static readonly double3x3 zero;

        public double3x3(double3 c0, double3 c1, double3 c2);
        public double3x3(double m00, double m01, double m02, double m10, double m11, double m12, double m20, double m21, double m22);
        public double3x3(double v);
        public double3x3(bool v);
        public double3x3(bool3x3 v);
        public double3x3(int v);
        public double3x3(int3x3 v);
        public double3x3(uint v);
        public double3x3(uint3x3 v);
        public double3x3(float v);
        public double3x3(float3x3 v);

        public ref double3 this[int index] { get; }

        public bool Equals(double3x3 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static double3x3 operator *(double3x3 lhs, double3x3 rhs);
        public static double3x3 operator *(double3x3 lhs, double rhs);
        public static double3x3 operator *(double lhs, double3x3 rhs);
        public static double3x3 operator +(double3x3 lhs, double3x3 rhs);
        public static double3x3 operator +(double3x3 lhs, double rhs);
        public static double3x3 operator +(double lhs, double3x3 rhs);
        public static double3x3 operator -(double3x3 lhs, double3x3 rhs);
        public static double3x3 operator -(double3x3 lhs, double rhs);
        public static double3x3 operator -(double lhs, double3x3 rhs);
        public static double3x3 operator /(double3x3 lhs, double3x3 rhs);
        public static double3x3 operator /(double3x3 lhs, double rhs);
        public static double3x3 operator /(double lhs, double3x3 rhs);
        public static double3x3 operator %(double3x3 lhs, double3x3 rhs);
        public static double3x3 operator %(double3x3 lhs, double rhs);
        public static double3x3 operator %(double lhs, double3x3 rhs);
        public static double3x3 operator ++(double3x3 val);
        public static double3x3 operator --(double3x3 val);
        public static bool3x3 operator <(double3x3 lhs, double3x3 rhs);
        public static bool3x3 operator <(double3x3 lhs, double rhs);
        public static bool3x3 operator <(double lhs, double3x3 rhs);
        public static bool3x3 operator <=(double3x3 lhs, double3x3 rhs);
        public static bool3x3 operator <=(double3x3 lhs, double rhs);
        public static bool3x3 operator <=(double lhs, double3x3 rhs);
        public static bool3x3 operator >(double3x3 lhs, double3x3 rhs);
        public static bool3x3 operator >(double3x3 lhs, double rhs);
        public static bool3x3 operator >(double lhs, double3x3 rhs);
        public static bool3x3 operator >=(double3x3 lhs, double3x3 rhs);
        public static bool3x3 operator >=(double3x3 lhs, double rhs);
        public static bool3x3 operator >=(double lhs, double3x3 rhs);
        public static double3x3 operator -(double3x3 val);
        public static double3x3 operator +(double3x3 val);
        public static bool3x3 operator ==(double3x3 lhs, double3x3 rhs);
        public static bool3x3 operator ==(double3x3 lhs, double rhs);
        public static bool3x3 operator ==(double lhs, double3x3 rhs);
        public static bool3x3 operator !=(double3x3 lhs, double3x3 rhs);
        public static bool3x3 operator !=(double3x3 lhs, double rhs);
        public static bool3x3 operator !=(double lhs, double3x3 rhs);

        public static implicit operator double3x3(double v);
        public static explicit operator double3x3(bool v);
        public static explicit operator double3x3(bool3x3 v);
        public static implicit operator double3x3(int v);
        public static implicit operator double3x3(int3x3 v);
        public static implicit operator double3x3(uint v);
        public static implicit operator double3x3(uint3x3 v);
        public static implicit operator double3x3(float v);
        public static implicit operator double3x3(float3x3 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct double3x4 : IEquatable<double3x4>, IFormattable
    {
        public double3 c0;
        public double3 c1;
        public double3 c2;
        public double3 c3;
        public static readonly double3x4 zero;

        public double3x4(double3 c0, double3 c1, double3 c2, double3 c3);
        public double3x4(double m00, double m01, double m02, double m03, double m10, double m11, double m12, double m13, double m20, double m21, double m22, double m23);
        public double3x4(double v);
        public double3x4(bool v);
        public double3x4(bool3x4 v);
        public double3x4(int v);
        public double3x4(int3x4 v);
        public double3x4(uint v);
        public double3x4(uint3x4 v);
        public double3x4(float v);
        public double3x4(float3x4 v);

        public ref double3 this[int index] { get; }

        public bool Equals(double3x4 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static double3x4 operator *(double3x4 lhs, double3x4 rhs);
        public static double3x4 operator *(double3x4 lhs, double rhs);
        public static double3x4 operator *(double lhs, double3x4 rhs);
        public static double3x4 operator +(double3x4 lhs, double3x4 rhs);
        public static double3x4 operator +(double3x4 lhs, double rhs);
        public static double3x4 operator +(double lhs, double3x4 rhs);
        public static double3x4 operator -(double3x4 lhs, double3x4 rhs);
        public static double3x4 operator -(double3x4 lhs, double rhs);
        public static double3x4 operator -(double lhs, double3x4 rhs);
        public static double3x4 operator /(double3x4 lhs, double3x4 rhs);
        public static double3x4 operator /(double3x4 lhs, double rhs);
        public static double3x4 operator /(double lhs, double3x4 rhs);
        public static double3x4 operator %(double3x4 lhs, double3x4 rhs);
        public static double3x4 operator %(double3x4 lhs, double rhs);
        public static double3x4 operator %(double lhs, double3x4 rhs);
        public static double3x4 operator ++(double3x4 val);
        public static double3x4 operator --(double3x4 val);
        public static bool3x4 operator <(double3x4 lhs, double3x4 rhs);
        public static bool3x4 operator <(double3x4 lhs, double rhs);
        public static bool3x4 operator <(double lhs, double3x4 rhs);
        public static bool3x4 operator <=(double3x4 lhs, double3x4 rhs);
        public static bool3x4 operator <=(double3x4 lhs, double rhs);
        public static bool3x4 operator <=(double lhs, double3x4 rhs);
        public static bool3x4 operator >(double3x4 lhs, double3x4 rhs);
        public static bool3x4 operator >(double3x4 lhs, double rhs);
        public static bool3x4 operator >(double lhs, double3x4 rhs);
        public static bool3x4 operator >=(double3x4 lhs, double3x4 rhs);
        public static bool3x4 operator >=(double3x4 lhs, double rhs);
        public static bool3x4 operator >=(double lhs, double3x4 rhs);
        public static double3x4 operator -(double3x4 val);
        public static double3x4 operator +(double3x4 val);
        public static bool3x4 operator ==(double3x4 lhs, double3x4 rhs);
        public static bool3x4 operator ==(double3x4 lhs, double rhs);
        public static bool3x4 operator ==(double lhs, double3x4 rhs);
        public static bool3x4 operator !=(double3x4 lhs, double3x4 rhs);
        public static bool3x4 operator !=(double3x4 lhs, double rhs);
        public static bool3x4 operator !=(double lhs, double3x4 rhs);

        public static implicit operator double3x4(double v);
        public static explicit operator double3x4(bool v);
        public static explicit operator double3x4(bool3x4 v);
        public static implicit operator double3x4(int v);
        public static implicit operator double3x4(int3x4 v);
        public static implicit operator double3x4(uint v);
        public static implicit operator double3x4(uint3x4 v);
        public static implicit operator double3x4(float v);
        public static implicit operator double3x4(float3x4 v);
    }
}
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    [DebuggerTypeProxy(typeof(DebuggerProxy))]
    public struct double4 : IEquatable<double4>, IFormattable
    {
        public double x;
        public double y;
        public double z;
        public double w;
        public static readonly double4 zero;

        public double4(double x, double y, double z, double w);
        public double4(double x, double y, double2 zw);
        public double4(double x, double2 yz, double w);
        public double4(double x, double3 yzw);
        public double4(double2 xy, double z, double w);
        public double4(double2 xy, double2 zw);
        public double4(double3 xyz, double w);
        public double4(double4 xyzw);
        public double4(double v);
        public double4(bool v);
        public double4(bool4 v);
        public double4(int v);
        public double4(int4 v);
        public double4(uint v);
        public double4(uint4 v);
        public double4(half v);
        public double4(half4 v);
        public double4(float v);
        public double4(float4 v);

        public double this[int index] { get; set; }
        [EditorBrowsable(Never)]
        public double4 xxxx { get; }
        [EditorBrowsable(Never)]
        public double4 xxxy { get; }
        [EditorBrowsable(Never)]
        public double4 xxxz { get; }
        [EditorBrowsable(Never)]
        public double4 xxxw { get; }
        [EditorBrowsable(Never)]
        public double4 xxyx { get; }
        [EditorBrowsable(Never)]
        public double4 xxyy { get; }
        [EditorBrowsable(Never)]
        public double4 xxyz { get; }
        [EditorBrowsable(Never)]
        public double4 xxyw { get; }
        [EditorBrowsable(Never)]
        public double4 xxzx { get; }
        [EditorBrowsable(Never)]
        public double4 xxzy { get; }
        [EditorBrowsable(Never)]
        public double4 xxzz { get; }
        [EditorBrowsable(Never)]
        public double4 xxzw { get; }
        [EditorBrowsable(Never)]
        public double4 xxwx { get; }
        [EditorBrowsable(Never)]
        public double4 xxwy { get; }
        [EditorBrowsable(Never)]
        public double4 xxwz { get; }
        [EditorBrowsable(Never)]
        public double4 xxww { get; }
        [EditorBrowsable(Never)]
        public double4 xyxx { get; }
        [EditorBrowsable(Never)]
        public double4 xyxy { get; }
        [EditorBrowsable(Never)]
        public double4 xyxz { get; }
        [EditorBrowsable(Never)]
        public double4 xyxw { get; }
        [EditorBrowsable(Never)]
        public double4 xyyx { get; }
        [EditorBrowsable(Never)]
        public double4 xyyy { get; }
        [EditorBrowsable(Never)]
        public double4 xyyz { get; }
        [EditorBrowsable(Never)]
        public double4 xyyw { get; }
        [EditorBrowsable(Never)]
        public double4 xyzx { get; }
        [EditorBrowsable(Never)]
        public double4 xyzy { get; }
        [EditorBrowsable(Never)]
        public double4 xyzz { get; }
        [EditorBrowsable(Never)]
        public double4 xyzw { get; set; }
        [EditorBrowsable(Never)]
        public double4 xywx { get; }
        [EditorBrowsable(Never)]
        public double4 xywy { get; }
        [EditorBrowsable(Never)]
        public double4 xywz { get; set; }
        [EditorBrowsable(Never)]
        public double4 xyww { get; }
        [EditorBrowsable(Never)]
        public double4 xzxx { get; }
        [EditorBrowsable(Never)]
        public double4 xzxy { get; }
        [EditorBrowsable(Never)]
        public double4 xzxz { get; }
        [EditorBrowsable(Never)]
        public double4 xzxw { get; }
        [EditorBrowsable(Never)]
        public double4 xzyx { get; }
        [EditorBrowsable(Never)]
        public double4 xzyy { get; }
        [EditorBrowsable(Never)]
        public double4 xzyz { get; }
        [EditorBrowsable(Never)]
        public double4 xzyw { get; set; }
        [EditorBrowsable(Never)]
        public double4 xzzx { get; }
        [EditorBrowsable(Never)]
        public double4 xzzy { get; }
        [EditorBrowsable(Never)]
        public double4 xzzz { get; }
        [EditorBrowsable(Never)]
        public double4 xzzw { get; }
        [EditorBrowsable(Never)]
        public double4 xzwx { get; }
        [EditorBrowsable(Never)]
        public double4 xzwy { get; set; }
        [EditorBrowsable(Never)]
        public double4 xzwz { get; }
        [EditorBrowsable(Never)]
        public double4 xzww { get; }
        [EditorBrowsable(Never)]
        public double4 xwxx { get; }
        [EditorBrowsable(Never)]
        public double4 xwxy { get; }
        [EditorBrowsable(Never)]
        public double4 xwxz { get; }
        [EditorBrowsable(Never)]
        public double4 xwxw { get; }
        [EditorBrowsable(Never)]
        public double4 xwyx { get; }
        [EditorBrowsable(Never)]
        public double4 xwyy { get; }
        [EditorBrowsable(Never)]
        public double4 xwyz { get; set; }
        [EditorBrowsable(Never)]
        public double4 xwyw { get; }
        [EditorBrowsable(Never)]
        public double4 xwzx { get; }
        [EditorBrowsable(Never)]
        public double4 xwzy { get; set; }
        [EditorBrowsable(Never)]
        public double4 xwzz { get; }
        [EditorBrowsable(Never)]
        public double4 xwzw { get; }
        [EditorBrowsable(Never)]
        public double4 xwwx { get; }
        [EditorBrowsable(Never)]
        public double4 xwwy { get; }
        [EditorBrowsable(Never)]
        public double4 xwwz { get; }
        [EditorBrowsable(Never)]
        public double4 xwww { get; }
        [EditorBrowsable(Never)]
        public double4 yxxx { get; }
        [EditorBrowsable(Never)]
        public double4 yxxy { get; }
        [EditorBrowsable(Never)]
        public double4 yxxz { get; }
        [EditorBrowsable(Never)]
        public double4 yxxw { get; }
        [EditorBrowsable(Never)]
        public double4 yxyx { get; }
        [EditorBrowsable(Never)]
        public double4 yxyy { get; }
        [EditorBrowsable(Never)]
        public double4 yxyz { get; }
        [EditorBrowsable(Never)]
        public double4 yxyw { get; }
        [EditorBrowsable(Never)]
        public double4 yxzx { get; }
        [EditorBrowsable(Never)]
        public double4 yxzy { get; }
        [EditorBrowsable(Never)]
        public double4 yxzz { get; }
        [EditorBrowsable(Never)]
        public double4 yxzw { get; set; }
        [EditorBrowsable(Never)]
        public double4 yxwx { get; }
        [EditorBrowsable(Never)]
        public double4 yxwy { get; }
        [EditorBrowsable(Never)]
        public double4 yxwz { get; set; }
        [EditorBrowsable(Never)]
        public double4 yxww { get; }
        [EditorBrowsable(Never)]
        public double4 yyxx { get; }
        [EditorBrowsable(Never)]
        public double4 yyxy { get; }
        [EditorBrowsable(Never)]
        public double4 yyxz { get; }
        [EditorBrowsable(Never)]
        public double4 yyxw { get; }
        [EditorBrowsable(Never)]
        public double4 yyyx { get; }
        [EditorBrowsable(Never)]
        public double4 yyyy { get; }
        [EditorBrowsable(Never)]
        public double4 yyyz { get; }
        [EditorBrowsable(Never)]
        public double4 yyyw { get; }
        [EditorBrowsable(Never)]
        public double4 yyzx { get; }
        [EditorBrowsable(Never)]
        public double4 yyzy { get; }
        [EditorBrowsable(Never)]
        public double4 yyzz { get; }
        [EditorBrowsable(Never)]
        public double4 yyzw { get; }
        [EditorBrowsable(Never)]
        public double4 yywx { get; }
        [EditorBrowsable(Never)]
        public double4 yywy { get; }
        [EditorBrowsable(Never)]
        public double4 yywz { get; }
        [EditorBrowsable(Never)]
        public double4 yyww { get; }
        [EditorBrowsable(Never)]
        public double4 yzxx { get; }
        [EditorBrowsable(Never)]
        public double4 yzxy { get; }
        [EditorBrowsable(Never)]
        public double4 yzxz { get; }
        [EditorBrowsable(Never)]
        public double4 yzxw { get; set; }
        [EditorBrowsable(Never)]
        public double4 yzyx { get; }
        [EditorBrowsable(Never)]
        public double4 yzyy { get; }
        [EditorBrowsable(Never)]
        public double4 yzyz { get; }
        [EditorBrowsable(Never)]
        public double4 yzyw { get; }
        [EditorBrowsable(Never)]
        public double4 yzzx { get; }
        [EditorBrowsable(Never)]
        public double4 yzzy { get; }
        [EditorBrowsable(Never)]
        public double4 yzzz { get; }
        [EditorBrowsable(Never)]
        public double4 yzzw { get; }
        [EditorBrowsable(Never)]
        public double4 yzwx { get; set; }
        [EditorBrowsable(Never)]
        public double4 yzwy { get; }
        [EditorBrowsable(Never)]
        public double4 yzwz { get; }
        [EditorBrowsable(Never)]
        public double4 yzww { get; }
        [EditorBrowsable(Never)]
        public double4 ywxx { get; }
        [EditorBrowsable(Never)]
        public double4 ywxy { get; }
        [EditorBrowsable(Never)]
        public double4 ywxz { get; set; }
        [EditorBrowsable(Never)]
        public double4 ywxw { get; }
        [EditorBrowsable(Never)]
        public double4 ywyx { get; }
        [EditorBrowsable(Never)]
        public double4 ywyy { get; }
        [EditorBrowsable(Never)]
        public double4 ywyz { get; }
        [EditorBrowsable(Never)]
        public double4 ywyw { get; }
        [EditorBrowsable(Never)]
        public double4 ywzx { get; set; }
        [EditorBrowsable(Never)]
        public double4 ywzy { get; }
        [EditorBrowsable(Never)]
        public double4 ywzz { get; }
        [EditorBrowsable(Never)]
        public double4 ywzw { get; }
        [EditorBrowsable(Never)]
        public double4 ywwx { get; }
        [EditorBrowsable(Never)]
        public double4 ywwy { get; }
        [EditorBrowsable(Never)]
        public double4 ywwz { get; }
        [EditorBrowsable(Never)]
        public double4 ywww { get; }
        [EditorBrowsable(Never)]
        public double4 zxxx { get; }
        [EditorBrowsable(Never)]
        public double4 zxxy { get; }
        [EditorBrowsable(Never)]
        public double4 zxxz { get; }
        [EditorBrowsable(Never)]
        public double4 zxxw { get; }
        [EditorBrowsable(Never)]
        public double4 zxyx { get; }
        [EditorBrowsable(Never)]
        public double4 zxyy { get; }
        [EditorBrowsable(Never)]
        public double4 zxyz { get; }
        [EditorBrowsable(Never)]
        public double4 zxyw { get; set; }
        [EditorBrowsable(Never)]
        public double4 zxzx { get; }
        [EditorBrowsable(Never)]
        public double4 zxzy { get; }
        [EditorBrowsable(Never)]
        public double4 zxzz { get; }
        [EditorBrowsable(Never)]
        public double4 zxzw { get; }
        [EditorBrowsable(Never)]
        public double4 zxwx { get; }
        [EditorBrowsable(Never)]
        public double4 zxwy { get; set; }
        [EditorBrowsable(Never)]
        public double4 zxwz { get; }
        [EditorBrowsable(Never)]
        public double4 zxww { get; }
        [EditorBrowsable(Never)]
        public double4 zyxx { get; }
        [EditorBrowsable(Never)]
        public double4 zyxy { get; }
        [EditorBrowsable(Never)]
        public double4 zyxz { get; }
        [EditorBrowsable(Never)]
        public double4 zyxw { get; set; }
        [EditorBrowsable(Never)]
        public double4 zyyx { get; }
        [EditorBrowsable(Never)]
        public double4 zyyy { get; }
        [EditorBrowsable(Never)]
        public double4 zyyz { get; }
        [EditorBrowsable(Never)]
        public double4 zyyw { get; }
        [EditorBrowsable(Never)]
        public double4 zyzx { get; }
        [EditorBrowsable(Never)]
        public double4 zyzy { get; }
        [EditorBrowsable(Never)]
        public double4 zyzz { get; }
        [EditorBrowsable(Never)]
        public double4 zyzw { get; }
        [EditorBrowsable(Never)]
        public double4 zywx { get; set; }
        [EditorBrowsable(Never)]
        public double4 zywy { get; }
        [EditorBrowsable(Never)]
        public double4 zywz { get; }
        [EditorBrowsable(Never)]
        public double4 zyww { get; }
        [EditorBrowsable(Never)]
        public double4 zzxx { get; }
        [EditorBrowsable(Never)]
        public double4 zzxy { get; }
        [EditorBrowsable(Never)]
        public double4 zzxz { get; }
        [EditorBrowsable(Never)]
        public double4 zzxw { get; }
        [EditorBrowsable(Never)]
        public double4 zzyx { get; }
        [EditorBrowsable(Never)]
        public double4 zzyy { get; }
        [EditorBrowsable(Never)]
        public double4 zzyz { get; }
        [EditorBrowsable(Never)]
        public double4 zzyw { get; }
        [EditorBrowsable(Never)]
        public double4 zzzx { get; }
        [EditorBrowsable(Never)]
        public double4 zzzy { get; }
        [EditorBrowsable(Never)]
        public double4 zzzz { get; }
        [EditorBrowsable(Never)]
        public double4 zzzw { get; }
        [EditorBrowsable(Never)]
        public double4 zzwx { get; }
        [EditorBrowsable(Never)]
        public double4 zzwy { get; }
        [EditorBrowsable(Never)]
        public double4 zzwz { get; }
        [EditorBrowsable(Never)]
        public double4 zzww { get; }
        [EditorBrowsable(Never)]
        public double4 zwxx { get; }
        [EditorBrowsable(Never)]
        public double4 zwxy { get; set; }
        [EditorBrowsable(Never)]
        public double4 zwxz { get; }
        [EditorBrowsable(Never)]
        public double4 zwxw { get; }
        [EditorBrowsable(Never)]
        public double4 zwyx { get; set; }
        [EditorBrowsable(Never)]
        public double4 zwyy { get; }
        [EditorBrowsable(Never)]
        public double4 zwyz { get; }
        [EditorBrowsable(Never)]
        public double4 zwyw { get; }
        [EditorBrowsable(Never)]
        public double4 zwzx { get; }
        [EditorBrowsable(Never)]
        public double4 zwzy { get; }
        [EditorBrowsable(Never)]
        public double4 zwzz { get; }
        [EditorBrowsable(Never)]
        public double4 zwzw { get; }
        [EditorBrowsable(Never)]
        public double4 zwwx { get; }
        [EditorBrowsable(Never)]
        public double4 zwwy { get; }
        [EditorBrowsable(Never)]
        public double4 zwwz { get; }
        [EditorBrowsable(Never)]
        public double4 zwww { get; }
        [EditorBrowsable(Never)]
        public double4 wxxx { get; }
        [EditorBrowsable(Never)]
        public double4 wxxy { get; }
        [EditorBrowsable(Never)]
        public double4 wxxz { get; }
        [EditorBrowsable(Never)]
        public double4 wxxw { get; }
        [EditorBrowsable(Never)]
        public double4 wxyx { get; }
        [EditorBrowsable(Never)]
        public double4 wxyy { get; }
        [EditorBrowsable(Never)]
        public double4 wxyz { get; set; }
        [EditorBrowsable(Never)]
        public double4 wxyw { get; }
        [EditorBrowsable(Never)]
        public double4 wxzx { get; }
        [EditorBrowsable(Never)]
        public double4 wxzy { get; set; }
        [EditorBrowsable(Never)]
        public double4 wxzz { get; }
        [EditorBrowsable(Never)]
        public double4 wxzw { get; }
        [EditorBrowsable(Never)]
        public double4 wxwx { get; }
        [EditorBrowsable(Never)]
        public double4 wxwy { get; }
        [EditorBrowsable(Never)]
        public double4 wxwz { get; }
        [EditorBrowsable(Never)]
        public double4 wxww { get; }
        [EditorBrowsable(Never)]
        public double4 wyxx { get; }
        [EditorBrowsable(Never)]
        public double4 wyxy { get; }
        [EditorBrowsable(Never)]
        public double4 wyxz { get; set; }
        [EditorBrowsable(Never)]
        public double4 wyxw { get; }
        [EditorBrowsable(Never)]
        public double4 wyyx { get; }
        [EditorBrowsable(Never)]
        public double4 wyyy { get; }
        [EditorBrowsable(Never)]
        public double4 wyyz { get; }
        [EditorBrowsable(Never)]
        public double4 wyyw { get; }
        [EditorBrowsable(Never)]
        public double4 wyzx { get; set; }
        [EditorBrowsable(Never)]
        public double4 wyzy { get; }
        [EditorBrowsable(Never)]
        public double4 wyzz { get; }
        [EditorBrowsable(Never)]
        public double4 wyzw { get; }
        [EditorBrowsable(Never)]
        public double4 wywx { get; }
        [EditorBrowsable(Never)]
        public double4 wywy { get; }
        [EditorBrowsable(Never)]
        public double4 wywz { get; }
        [EditorBrowsable(Never)]
        public double4 wyww { get; }
        [EditorBrowsable(Never)]
        public double4 wzxx { get; }
        [EditorBrowsable(Never)]
        public double4 wzxy { get; set; }
        [EditorBrowsable(Never)]
        public double4 wzxz { get; }
        [EditorBrowsable(Never)]
        public double4 wzxw { get; }
        [EditorBrowsable(Never)]
        public double4 wzyx { get; set; }
        [EditorBrowsable(Never)]
        public double4 wzyy { get; }
        [EditorBrowsable(Never)]
        public double4 wzyz { get; }
        [EditorBrowsable(Never)]
        public double4 wzyw { get; }
        [EditorBrowsable(Never)]
        public double4 wzzx { get; }
        [EditorBrowsable(Never)]
        public double4 wzzy { get; }
        [EditorBrowsable(Never)]
        public double4 wzzz { get; }
        [EditorBrowsable(Never)]
        public double4 wzzw { get; }
        [EditorBrowsable(Never)]
        public double4 wzwx { get; }
        [EditorBrowsable(Never)]
        public double4 wzwy { get; }
        [EditorBrowsable(Never)]
        public double4 wzwz { get; }
        [EditorBrowsable(Never)]
        public double4 wzww { get; }
        [EditorBrowsable(Never)]
        public double4 wwxx { get; }
        [EditorBrowsable(Never)]
        public double4 wwxy { get; }
        [EditorBrowsable(Never)]
        public double4 wwxz { get; }
        [EditorBrowsable(Never)]
        public double4 wwxw { get; }
        [EditorBrowsable(Never)]
        public double4 wwyx { get; }
        [EditorBrowsable(Never)]
        public double4 wwyy { get; }
        [EditorBrowsable(Never)]
        public double4 wwyz { get; }
        [EditorBrowsable(Never)]
        public double4 wwyw { get; }
        [EditorBrowsable(Never)]
        public double4 wwzx { get; }
        [EditorBrowsable(Never)]
        public double4 wwzy { get; }
        [EditorBrowsable(Never)]
        public double4 wwzz { get; }
        [EditorBrowsable(Never)]
        public double4 wwzw { get; }
        [EditorBrowsable(Never)]
        public double4 wwwx { get; }
        [EditorBrowsable(Never)]
        public double4 wwwy { get; }
        [EditorBrowsable(Never)]
        public double4 wwwz { get; }
        [EditorBrowsable(Never)]
        public double4 wwww { get; }
        [EditorBrowsable(Never)]
        public double3 xxx { get; }
        [EditorBrowsable(Never)]
        public double3 xxy { get; }
        [EditorBrowsable(Never)]
        public double3 xxz { get; }
        [EditorBrowsable(Never)]
        public double3 xxw { get; }
        [EditorBrowsable(Never)]
        public double3 xyx { get; }
        [EditorBrowsable(Never)]
        public double3 xyy { get; }
        [EditorBrowsable(Never)]
        public double3 xyz { get; set; }
        [EditorBrowsable(Never)]
        public double3 xyw { get; set; }
        [EditorBrowsable(Never)]
        public double3 xzx { get; }
        [EditorBrowsable(Never)]
        public double3 xzy { get; set; }
        [EditorBrowsable(Never)]
        public double3 xzz { get; }
        [EditorBrowsable(Never)]
        public double3 xzw { get; set; }
        [EditorBrowsable(Never)]
        public double3 xwx { get; }
        [EditorBrowsable(Never)]
        public double3 xwy { get; set; }
        [EditorBrowsable(Never)]
        public double3 xwz { get; set; }
        [EditorBrowsable(Never)]
        public double3 xww { get; }
        [EditorBrowsable(Never)]
        public double3 yxx { get; }
        [EditorBrowsable(Never)]
        public double3 yxy { get; }
        [EditorBrowsable(Never)]
        public double3 yxz { get; set; }
        [EditorBrowsable(Never)]
        public double3 yxw { get; set; }
        [EditorBrowsable(Never)]
        public double3 yyx { get; }
        [EditorBrowsable(Never)]
        public double3 yyy { get; }
        [EditorBrowsable(Never)]
        public double3 yyz { get; }
        [EditorBrowsable(Never)]
        public double3 yyw { get; }
        [EditorBrowsable(Never)]
        public double3 yzx { get; set; }
        [EditorBrowsable(Never)]
        public double3 yzy { get; }
        [EditorBrowsable(Never)]
        public double3 yzz { get; }
        [EditorBrowsable(Never)]
        public double3 yzw { get; set; }
        [EditorBrowsable(Never)]
        public double3 ywx { get; set; }
        [EditorBrowsable(Never)]
        public double3 ywy { get; }
        [EditorBrowsable(Never)]
        public double3 ywz { get; set; }
        [EditorBrowsable(Never)]
        public double3 yww { get; }
        [EditorBrowsable(Never)]
        public double3 zxx { get; }
        [EditorBrowsable(Never)]
        public double3 zxy { get; set; }
        [EditorBrowsable(Never)]
        public double3 zxz { get; }
        [EditorBrowsable(Never)]
        public double3 zxw { get; set; }
        [EditorBrowsable(Never)]
        public double3 zyx { get; set; }
        [EditorBrowsable(Never)]
        public double3 zyy { get; }
        [EditorBrowsable(Never)]
        public double3 zyz { get; }
        [EditorBrowsable(Never)]
        public double3 zyw { get; set; }
        [EditorBrowsable(Never)]
        public double3 zzx { get; }
        [EditorBrowsable(Never)]
        public double3 zzy { get; }
        [EditorBrowsable(Never)]
        public double3 zzz { get; }
        [EditorBrowsable(Never)]
        public double3 zzw { get; }
        [EditorBrowsable(Never)]
        public double3 zwx { get; set; }
        [EditorBrowsable(Never)]
        public double3 zwy { get; set; }
        [EditorBrowsable(Never)]
        public double3 zwz { get; }
        [EditorBrowsable(Never)]
        public double3 zww { get; }
        [EditorBrowsable(Never)]
        public double3 wxx { get; }
        [EditorBrowsable(Never)]
        public double3 wxy { get; set; }
        [EditorBrowsable(Never)]
        public double3 wxz { get; set; }
        [EditorBrowsable(Never)]
        public double3 wxw { get; }
        [EditorBrowsable(Never)]
        public double3 wyx { get; set; }
        [EditorBrowsable(Never)]
        public double3 wyy { get; }
        [EditorBrowsable(Never)]
        public double3 wyz { get; set; }
        [EditorBrowsable(Never)]
        public double3 wyw { get; }
        [EditorBrowsable(Never)]
        public double3 wzx { get; set; }
        [EditorBrowsable(Never)]
        public double3 wzy { get; set; }
        [EditorBrowsable(Never)]
        public double3 wzz { get; }
        [EditorBrowsable(Never)]
        public double3 wzw { get; }
        [EditorBrowsable(Never)]
        public double3 wwx { get; }
        [EditorBrowsable(Never)]
        public double3 wwy { get; }
        [EditorBrowsable(Never)]
        public double3 wwz { get; }
        [EditorBrowsable(Never)]
        public double3 www { get; }
        [EditorBrowsable(Never)]
        public double2 xx { get; }
        [EditorBrowsable(Never)]
        public double2 xy { get; set; }
        [EditorBrowsable(Never)]
        public double2 xz { get; set; }
        [EditorBrowsable(Never)]
        public double2 xw { get; set; }
        [EditorBrowsable(Never)]
        public double2 yx { get; set; }
        [EditorBrowsable(Never)]
        public double2 yy { get; }
        [EditorBrowsable(Never)]
        public double2 yz { get; set; }
        [EditorBrowsable(Never)]
        public double2 yw { get; set; }
        [EditorBrowsable(Never)]
        public double2 zx { get; set; }
        [EditorBrowsable(Never)]
        public double2 zy { get; set; }
        [EditorBrowsable(Never)]
        public double2 zz { get; }
        [EditorBrowsable(Never)]
        public double2 zw { get; set; }
        [EditorBrowsable(Never)]
        public double2 wx { get; set; }
        [EditorBrowsable(Never)]
        public double2 wy { get; set; }
        [EditorBrowsable(Never)]
        public double2 wz { get; set; }
        [EditorBrowsable(Never)]
        public double2 ww { get; }

        public bool Equals(double4 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static double4 operator *(double4 lhs, double4 rhs);
        public static double4 operator *(double4 lhs, double rhs);
        public static double4 operator *(double lhs, double4 rhs);
        public static double4 operator +(double4 lhs, double4 rhs);
        public static double4 operator +(double4 lhs, double rhs);
        public static double4 operator +(double lhs, double4 rhs);
        public static double4 operator -(double4 lhs, double4 rhs);
        public static double4 operator -(double4 lhs, double rhs);
        public static double4 operator -(double lhs, double4 rhs);
        public static double4 operator /(double4 lhs, double4 rhs);
        public static double4 operator /(double4 lhs, double rhs);
        public static double4 operator /(double lhs, double4 rhs);
        public static double4 operator %(double4 lhs, double4 rhs);
        public static double4 operator %(double4 lhs, double rhs);
        public static double4 operator %(double lhs, double4 rhs);
        public static double4 operator ++(double4 val);
        public static double4 operator --(double4 val);
        public static bool4 operator <(double4 lhs, double4 rhs);
        public static bool4 operator <(double4 lhs, double rhs);
        public static bool4 operator <(double lhs, double4 rhs);
        public static bool4 operator <=(double4 lhs, double4 rhs);
        public static bool4 operator <=(double4 lhs, double rhs);
        public static bool4 operator <=(double lhs, double4 rhs);
        public static bool4 operator >(double4 lhs, double4 rhs);
        public static bool4 operator >(double4 lhs, double rhs);
        public static bool4 operator >(double lhs, double4 rhs);
        public static bool4 operator >=(double4 lhs, double4 rhs);
        public static bool4 operator >=(double4 lhs, double rhs);
        public static bool4 operator >=(double lhs, double4 rhs);
        public static double4 operator -(double4 val);
        public static double4 operator +(double4 val);
        public static bool4 operator ==(double4 lhs, double4 rhs);
        public static bool4 operator ==(double4 lhs, double rhs);
        public static bool4 operator ==(double lhs, double4 rhs);
        public static bool4 operator !=(double4 lhs, double4 rhs);
        public static bool4 operator !=(double4 lhs, double rhs);
        public static bool4 operator !=(double lhs, double4 rhs);

        public static implicit operator double4(double v);
        public static explicit operator double4(bool v);
        public static explicit operator double4(bool4 v);
        public static implicit operator double4(int v);
        public static implicit operator double4(int4 v);
        public static implicit operator double4(uint v);
        public static implicit operator double4(uint4 v);
        public static implicit operator double4(half v);
        public static implicit operator double4(half4 v);
        public static implicit operator double4(float v);
        public static implicit operator double4(float4 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct double4x2 : IEquatable<double4x2>, IFormattable
    {
        public double4 c0;
        public double4 c1;
        public static readonly double4x2 zero;

        public double4x2(double4 c0, double4 c1);
        public double4x2(double m00, double m01, double m10, double m11, double m20, double m21, double m30, double m31);
        public double4x2(double v);
        public double4x2(bool v);
        public double4x2(bool4x2 v);
        public double4x2(int v);
        public double4x2(int4x2 v);
        public double4x2(uint v);
        public double4x2(uint4x2 v);
        public double4x2(float v);
        public double4x2(float4x2 v);

        public ref double4 this[int index] { get; }

        public bool Equals(double4x2 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static double4x2 operator *(double4x2 lhs, double4x2 rhs);
        public static double4x2 operator *(double4x2 lhs, double rhs);
        public static double4x2 operator *(double lhs, double4x2 rhs);
        public static double4x2 operator +(double4x2 lhs, double4x2 rhs);
        public static double4x2 operator +(double4x2 lhs, double rhs);
        public static double4x2 operator +(double lhs, double4x2 rhs);
        public static double4x2 operator -(double4x2 lhs, double4x2 rhs);
        public static double4x2 operator -(double4x2 lhs, double rhs);
        public static double4x2 operator -(double lhs, double4x2 rhs);
        public static double4x2 operator /(double4x2 lhs, double4x2 rhs);
        public static double4x2 operator /(double4x2 lhs, double rhs);
        public static double4x2 operator /(double lhs, double4x2 rhs);
        public static double4x2 operator %(double4x2 lhs, double4x2 rhs);
        public static double4x2 operator %(double4x2 lhs, double rhs);
        public static double4x2 operator %(double lhs, double4x2 rhs);
        public static double4x2 operator ++(double4x2 val);
        public static double4x2 operator --(double4x2 val);
        public static bool4x2 operator <(double4x2 lhs, double4x2 rhs);
        public static bool4x2 operator <(double4x2 lhs, double rhs);
        public static bool4x2 operator <(double lhs, double4x2 rhs);
        public static bool4x2 operator <=(double4x2 lhs, double4x2 rhs);
        public static bool4x2 operator <=(double4x2 lhs, double rhs);
        public static bool4x2 operator <=(double lhs, double4x2 rhs);
        public static bool4x2 operator >(double4x2 lhs, double4x2 rhs);
        public static bool4x2 operator >(double4x2 lhs, double rhs);
        public static bool4x2 operator >(double lhs, double4x2 rhs);
        public static bool4x2 operator >=(double4x2 lhs, double4x2 rhs);
        public static bool4x2 operator >=(double4x2 lhs, double rhs);
        public static bool4x2 operator >=(double lhs, double4x2 rhs);
        public static double4x2 operator -(double4x2 val);
        public static double4x2 operator +(double4x2 val);
        public static bool4x2 operator ==(double4x2 lhs, double4x2 rhs);
        public static bool4x2 operator ==(double4x2 lhs, double rhs);
        public static bool4x2 operator ==(double lhs, double4x2 rhs);
        public static bool4x2 operator !=(double4x2 lhs, double4x2 rhs);
        public static bool4x2 operator !=(double4x2 lhs, double rhs);
        public static bool4x2 operator !=(double lhs, double4x2 rhs);

        public static implicit operator double4x2(double v);
        public static explicit operator double4x2(bool v);
        public static explicit operator double4x2(bool4x2 v);
        public static implicit operator double4x2(int v);
        public static implicit operator double4x2(int4x2 v);
        public static implicit operator double4x2(uint v);
        public static implicit operator double4x2(uint4x2 v);
        public static implicit operator double4x2(float v);
        public static implicit operator double4x2(float4x2 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct double4x3 : IEquatable<double4x3>, IFormattable
    {
        public double4 c0;
        public double4 c1;
        public double4 c2;
        public static readonly double4x3 zero;

        public double4x3(double4 c0, double4 c1, double4 c2);
        public double4x3(double m00, double m01, double m02, double m10, double m11, double m12, double m20, double m21, double m22, double m30, double m31, double m32);
        public double4x3(double v);
        public double4x3(bool v);
        public double4x3(bool4x3 v);
        public double4x3(int v);
        public double4x3(int4x3 v);
        public double4x3(uint v);
        public double4x3(uint4x3 v);
        public double4x3(float v);
        public double4x3(float4x3 v);

        public ref double4 this[int index] { get; }

        public bool Equals(double4x3 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static double4x3 operator *(double4x3 lhs, double4x3 rhs);
        public static double4x3 operator *(double4x3 lhs, double rhs);
        public static double4x3 operator *(double lhs, double4x3 rhs);
        public static double4x3 operator +(double4x3 lhs, double4x3 rhs);
        public static double4x3 operator +(double4x3 lhs, double rhs);
        public static double4x3 operator +(double lhs, double4x3 rhs);
        public static double4x3 operator -(double4x3 lhs, double4x3 rhs);
        public static double4x3 operator -(double4x3 lhs, double rhs);
        public static double4x3 operator -(double lhs, double4x3 rhs);
        public static double4x3 operator /(double4x3 lhs, double4x3 rhs);
        public static double4x3 operator /(double4x3 lhs, double rhs);
        public static double4x3 operator /(double lhs, double4x3 rhs);
        public static double4x3 operator %(double4x3 lhs, double4x3 rhs);
        public static double4x3 operator %(double4x3 lhs, double rhs);
        public static double4x3 operator %(double lhs, double4x3 rhs);
        public static double4x3 operator ++(double4x3 val);
        public static double4x3 operator --(double4x3 val);
        public static bool4x3 operator <(double4x3 lhs, double4x3 rhs);
        public static bool4x3 operator <(double4x3 lhs, double rhs);
        public static bool4x3 operator <(double lhs, double4x3 rhs);
        public static bool4x3 operator <=(double4x3 lhs, double4x3 rhs);
        public static bool4x3 operator <=(double4x3 lhs, double rhs);
        public static bool4x3 operator <=(double lhs, double4x3 rhs);
        public static bool4x3 operator >(double4x3 lhs, double4x3 rhs);
        public static bool4x3 operator >(double4x3 lhs, double rhs);
        public static bool4x3 operator >(double lhs, double4x3 rhs);
        public static bool4x3 operator >=(double4x3 lhs, double4x3 rhs);
        public static bool4x3 operator >=(double4x3 lhs, double rhs);
        public static bool4x3 operator >=(double lhs, double4x3 rhs);
        public static double4x3 operator -(double4x3 val);
        public static double4x3 operator +(double4x3 val);
        public static bool4x3 operator ==(double4x3 lhs, double4x3 rhs);
        public static bool4x3 operator ==(double4x3 lhs, double rhs);
        public static bool4x3 operator ==(double lhs, double4x3 rhs);
        public static bool4x3 operator !=(double4x3 lhs, double4x3 rhs);
        public static bool4x3 operator !=(double4x3 lhs, double rhs);
        public static bool4x3 operator !=(double lhs, double4x3 rhs);

        public static implicit operator double4x3(double v);
        public static explicit operator double4x3(bool v);
        public static explicit operator double4x3(bool4x3 v);
        public static implicit operator double4x3(int v);
        public static implicit operator double4x3(int4x3 v);
        public static implicit operator double4x3(uint v);
        public static implicit operator double4x3(uint4x3 v);
        public static implicit operator double4x3(float v);
        public static implicit operator double4x3(float4x3 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct double4x4 : IEquatable<double4x4>, IFormattable
    {
        public double4 c0;
        public double4 c1;
        public double4 c2;
        public double4 c3;
        public static readonly double4x4 identity;
        public static readonly double4x4 zero;

        public double4x4(double4 c0, double4 c1, double4 c2, double4 c3);
        public double4x4(double m00, double m01, double m02, double m03, double m10, double m11, double m12, double m13, double m20, double m21, double m22, double m23, double m30, double m31, double m32, double m33);
        public double4x4(double v);
        public double4x4(bool v);
        public double4x4(bool4x4 v);
        public double4x4(int v);
        public double4x4(int4x4 v);
        public double4x4(uint v);
        public double4x4(uint4x4 v);
        public double4x4(float v);
        public double4x4(float4x4 v);

        public ref double4 this[int index] { get; }

        public bool Equals(double4x4 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static double4x4 operator *(double4x4 lhs, double4x4 rhs);
        public static double4x4 operator *(double4x4 lhs, double rhs);
        public static double4x4 operator *(double lhs, double4x4 rhs);
        public static double4x4 operator +(double4x4 lhs, double4x4 rhs);
        public static double4x4 operator +(double4x4 lhs, double rhs);
        public static double4x4 operator +(double lhs, double4x4 rhs);
        public static double4x4 operator -(double4x4 lhs, double4x4 rhs);
        public static double4x4 operator -(double4x4 lhs, double rhs);
        public static double4x4 operator -(double lhs, double4x4 rhs);
        public static double4x4 operator /(double4x4 lhs, double4x4 rhs);
        public static double4x4 operator /(double4x4 lhs, double rhs);
        public static double4x4 operator /(double lhs, double4x4 rhs);
        public static double4x4 operator %(double4x4 lhs, double4x4 rhs);
        public static double4x4 operator %(double4x4 lhs, double rhs);
        public static double4x4 operator %(double lhs, double4x4 rhs);
        public static double4x4 operator ++(double4x4 val);
        public static double4x4 operator --(double4x4 val);
        public static bool4x4 operator <(double4x4 lhs, double4x4 rhs);
        public static bool4x4 operator <(double4x4 lhs, double rhs);
        public static bool4x4 operator <(double lhs, double4x4 rhs);
        public static bool4x4 operator <=(double4x4 lhs, double4x4 rhs);
        public static bool4x4 operator <=(double4x4 lhs, double rhs);
        public static bool4x4 operator <=(double lhs, double4x4 rhs);
        public static bool4x4 operator >(double4x4 lhs, double4x4 rhs);
        public static bool4x4 operator >(double4x4 lhs, double rhs);
        public static bool4x4 operator >(double lhs, double4x4 rhs);
        public static bool4x4 operator >=(double4x4 lhs, double4x4 rhs);
        public static bool4x4 operator >=(double4x4 lhs, double rhs);
        public static bool4x4 operator >=(double lhs, double4x4 rhs);
        public static double4x4 operator -(double4x4 val);
        public static double4x4 operator +(double4x4 val);
        public static bool4x4 operator ==(double4x4 lhs, double4x4 rhs);
        public static bool4x4 operator ==(double4x4 lhs, double rhs);
        public static bool4x4 operator ==(double lhs, double4x4 rhs);
        public static bool4x4 operator !=(double4x4 lhs, double4x4 rhs);
        public static bool4x4 operator !=(double4x4 lhs, double rhs);
        public static bool4x4 operator !=(double lhs, double4x4 rhs);

        public static implicit operator double4x4(double v);
        public static explicit operator double4x4(bool v);
        public static explicit operator double4x4(bool4x4 v);
        public static implicit operator double4x4(int v);
        public static implicit operator double4x4(int4x4 v);
        public static implicit operator double4x4(uint v);
        public static implicit operator double4x4(uint4x4 v);
        public static implicit operator double4x4(float v);
        public static implicit operator double4x4(float4x4 v);
    }
}
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Reflection;
using UnityEngine;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    [DebuggerTypeProxy(typeof(DebuggerProxy))]
    public struct float2 : IEquatable<float2>, IFormattable
    {
        public float x;
        public float y;
        public static readonly float2 zero;

        public float2(float x, float y);
        public float2(float2 xy);
        public float2(float v);
        public float2(bool v);
        public float2(bool2 v);
        public float2(int v);
        public float2(int2 v);
        public float2(uint v);
        public float2(uint2 v);
        public float2(half v);
        public float2(half2 v);
        public float2(double v);
        public float2(double2 v);

        public float this[int index] { get; set; }
        [EditorBrowsable(Never)]
        public float4 xxxx { get; }
        [EditorBrowsable(Never)]
        public float4 xxxy { get; }
        [EditorBrowsable(Never)]
        public float4 xxyx { get; }
        [EditorBrowsable(Never)]
        public float4 xxyy { get; }
        [EditorBrowsable(Never)]
        public float4 xyxx { get; }
        [EditorBrowsable(Never)]
        public float4 xyxy { get; }
        [EditorBrowsable(Never)]
        public float4 xyyx { get; }
        [EditorBrowsable(Never)]
        public float4 xyyy { get; }
        [EditorBrowsable(Never)]
        public float4 yxxx { get; }
        [EditorBrowsable(Never)]
        public float4 yxxy { get; }
        [EditorBrowsable(Never)]
        public float4 yxyx { get; }
        [EditorBrowsable(Never)]
        public float4 yxyy { get; }
        [EditorBrowsable(Never)]
        public float4 yyxx { get; }
        [EditorBrowsable(Never)]
        public float4 yyxy { get; }
        [EditorBrowsable(Never)]
        public float4 yyyx { get; }
        [EditorBrowsable(Never)]
        public float4 yyyy { get; }
        [EditorBrowsable(Never)]
        public float3 xxx { get; }
        [EditorBrowsable(Never)]
        public float3 xxy { get; }
        [EditorBrowsable(Never)]
        public float3 xyx { get; }
        [EditorBrowsable(Never)]
        public float3 xyy { get; }
        [EditorBrowsable(Never)]
        public float3 yxx { get; }
        [EditorBrowsable(Never)]
        public float3 yxy { get; }
        [EditorBrowsable(Never)]
        public float3 yyx { get; }
        [EditorBrowsable(Never)]
        public float3 yyy { get; }
        [EditorBrowsable(Never)]
        public float2 xx { get; }
        [EditorBrowsable(Never)]
        public float2 xy { get; set; }
        [EditorBrowsable(Never)]
        public float2 yx { get; set; }
        [EditorBrowsable(Never)]
        public float2 yy { get; }

        public bool Equals(float2 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static float2 operator *(float2 lhs, float2 rhs);
        public static float2 operator *(float2 lhs, float rhs);
        public static float2 operator *(float lhs, float2 rhs);
        public static float2 operator +(float2 lhs, float2 rhs);
        public static float2 operator +(float2 lhs, float rhs);
        public static float2 operator +(float lhs, float2 rhs);
        public static float2 operator -(float2 lhs, float2 rhs);
        public static float2 operator -(float2 lhs, float rhs);
        public static float2 operator -(float lhs, float2 rhs);
        public static float2 operator /(float2 lhs, float2 rhs);
        public static float2 operator /(float2 lhs, float rhs);
        public static float2 operator /(float lhs, float2 rhs);
        public static float2 operator %(float2 lhs, float2 rhs);
        public static float2 operator %(float2 lhs, float rhs);
        public static float2 operator %(float lhs, float2 rhs);
        public static float2 operator ++(float2 val);
        public static float2 operator --(float2 val);
        public static bool2 operator <(float2 lhs, float2 rhs);
        public static bool2 operator <(float2 lhs, float rhs);
        public static bool2 operator <(float lhs, float2 rhs);
        public static bool2 operator <=(float2 lhs, float2 rhs);
        public static bool2 operator <=(float2 lhs, float rhs);
        public static bool2 operator <=(float lhs, float2 rhs);
        public static bool2 operator >(float2 lhs, float2 rhs);
        public static bool2 operator >(float2 lhs, float rhs);
        public static bool2 operator >(float lhs, float2 rhs);
        public static bool2 operator >=(float2 lhs, float2 rhs);
        public static bool2 operator >=(float2 lhs, float rhs);
        public static bool2 operator >=(float lhs, float2 rhs);
        public static float2 operator -(float2 val);
        public static float2 operator +(float2 val);
        public static bool2 operator ==(float2 lhs, float2 rhs);
        public static bool2 operator ==(float2 lhs, float rhs);
        public static bool2 operator ==(float lhs, float2 rhs);
        public static bool2 operator !=(float2 lhs, float2 rhs);
        public static bool2 operator !=(float2 lhs, float rhs);
        public static bool2 operator !=(float lhs, float2 rhs);

        public static implicit operator float2(float v);
        public static explicit operator float2(bool v);
        public static explicit operator float2(bool2 v);
        public static implicit operator float2(int v);
        public static implicit operator float2(int2 v);
        public static implicit operator float2(uint v);
        public static implicit operator float2(uint2 v);
        public static implicit operator float2(half v);
        public static implicit operator float2(half2 v);
        public static explicit operator float2(double v);
        public static explicit operator float2(double2 v);
        public static implicit operator Vector2(float2 v);
        public static implicit operator float2(Vector2 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct float2x2 : IEquatable<float2x2>, IFormattable
    {
        public float2 c0;
        public float2 c1;
        public static readonly float2x2 identity;
        public static readonly float2x2 zero;

        public float2x2(float2 c0, float2 c1);
        public float2x2(float m00, float m01, float m10, float m11);
        public float2x2(float v);
        public float2x2(bool v);
        public float2x2(bool2x2 v);
        public float2x2(int v);
        public float2x2(int2x2 v);
        public float2x2(uint v);
        public float2x2(uint2x2 v);
        public float2x2(double v);
        public float2x2(double2x2 v);

        public ref float2 this[int index] { get; }

        public bool Equals(float2x2 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);
        public static float2x2 Rotate(float angle);
        public static float2x2 Scale(float s);
        public static float2x2 Scale(float x, float y);
        public static float2x2 Scale(float2 v);

        public static float2x2 operator *(float2x2 lhs, float2x2 rhs);
        public static float2x2 operator *(float2x2 lhs, float rhs);
        public static float2x2 operator *(float lhs, float2x2 rhs);
        public static float2x2 operator +(float2x2 lhs, float2x2 rhs);
        public static float2x2 operator +(float2x2 lhs, float rhs);
        public static float2x2 operator +(float lhs, float2x2 rhs);
        public static float2x2 operator -(float2x2 lhs, float2x2 rhs);
        public static float2x2 operator -(float2x2 lhs, float rhs);
        public static float2x2 operator -(float lhs, float2x2 rhs);
        public static float2x2 operator /(float2x2 lhs, float2x2 rhs);
        public static float2x2 operator /(float2x2 lhs, float rhs);
        public static float2x2 operator /(float lhs, float2x2 rhs);
        public static float2x2 operator %(float2x2 lhs, float2x2 rhs);
        public static float2x2 operator %(float2x2 lhs, float rhs);
        public static float2x2 operator %(float lhs, float2x2 rhs);
        public static float2x2 operator ++(float2x2 val);
        public static float2x2 operator --(float2x2 val);
        public static bool2x2 operator <(float2x2 lhs, float2x2 rhs);
        public static bool2x2 operator <(float2x2 lhs, float rhs);
        public static bool2x2 operator <(float lhs, float2x2 rhs);
        public static bool2x2 operator <=(float2x2 lhs, float2x2 rhs);
        public static bool2x2 operator <=(float2x2 lhs, float rhs);
        public static bool2x2 operator <=(float lhs, float2x2 rhs);
        public static bool2x2 operator >(float2x2 lhs, float2x2 rhs);
        public static bool2x2 operator >(float2x2 lhs, float rhs);
        public static bool2x2 operator >(float lhs, float2x2 rhs);
        public static bool2x2 operator >=(float2x2 lhs, float2x2 rhs);
        public static bool2x2 operator >=(float2x2 lhs, float rhs);
        public static bool2x2 operator >=(float lhs, float2x2 rhs);
        public static float2x2 operator -(float2x2 val);
        public static float2x2 operator +(float2x2 val);
        public static bool2x2 operator ==(float2x2 lhs, float2x2 rhs);
        public static bool2x2 operator ==(float2x2 lhs, float rhs);
        public static bool2x2 operator ==(float lhs, float2x2 rhs);
        public static bool2x2 operator !=(float2x2 lhs, float2x2 rhs);
        public static bool2x2 operator !=(float2x2 lhs, float rhs);
        public static bool2x2 operator !=(float lhs, float2x2 rhs);

        public static implicit operator float2x2(float v);
        public static explicit operator float2x2(bool v);
        public static explicit operator float2x2(bool2x2 v);
        public static implicit operator float2x2(int v);
        public static implicit operator float2x2(int2x2 v);
        public static implicit operator float2x2(uint v);
        public static implicit operator float2x2(uint2x2 v);
        public static explicit operator float2x2(double v);
        public static explicit operator float2x2(double2x2 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct float2x3 : IEquatable<float2x3>, IFormattable
    {
        public float2 c0;
        public float2 c1;
        public float2 c2;
        public static readonly float2x3 zero;

        public float2x3(float2 c0, float2 c1, float2 c2);
        public float2x3(float m00, float m01, float m02, float m10, float m11, float m12);
        public float2x3(float v);
        public float2x3(bool v);
        public float2x3(bool2x3 v);
        public float2x3(int v);
        public float2x3(int2x3 v);
        public float2x3(uint v);
        public float2x3(uint2x3 v);
        public float2x3(double v);
        public float2x3(double2x3 v);

        public ref float2 this[int index] { get; }

        public bool Equals(float2x3 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static float2x3 operator *(float2x3 lhs, float2x3 rhs);
        public static float2x3 operator *(float2x3 lhs, float rhs);
        public static float2x3 operator *(float lhs, float2x3 rhs);
        public static float2x3 operator +(float2x3 lhs, float2x3 rhs);
        public static float2x3 operator +(float2x3 lhs, float rhs);
        public static float2x3 operator +(float lhs, float2x3 rhs);
        public static float2x3 operator -(float2x3 lhs, float2x3 rhs);
        public static float2x3 operator -(float2x3 lhs, float rhs);
        public static float2x3 operator -(float lhs, float2x3 rhs);
        public static float2x3 operator /(float2x3 lhs, float2x3 rhs);
        public static float2x3 operator /(float2x3 lhs, float rhs);
        public static float2x3 operator /(float lhs, float2x3 rhs);
        public static float2x3 operator %(float2x3 lhs, float2x3 rhs);
        public static float2x3 operator %(float2x3 lhs, float rhs);
        public static float2x3 operator %(float lhs, float2x3 rhs);
        public static float2x3 operator ++(float2x3 val);
        public static float2x3 operator --(float2x3 val);
        public static bool2x3 operator <(float2x3 lhs, float2x3 rhs);
        public static bool2x3 operator <(float2x3 lhs, float rhs);
        public static bool2x3 operator <(float lhs, float2x3 rhs);
        public static bool2x3 operator <=(float2x3 lhs, float2x3 rhs);
        public static bool2x3 operator <=(float2x3 lhs, float rhs);
        public static bool2x3 operator <=(float lhs, float2x3 rhs);
        public static bool2x3 operator >(float2x3 lhs, float2x3 rhs);
        public static bool2x3 operator >(float2x3 lhs, float rhs);
        public static bool2x3 operator >(float lhs, float2x3 rhs);
        public static bool2x3 operator >=(float2x3 lhs, float2x3 rhs);
        public static bool2x3 operator >=(float2x3 lhs, float rhs);
        public static bool2x3 operator >=(float lhs, float2x3 rhs);
        public static float2x3 operator -(float2x3 val);
        public static float2x3 operator +(float2x3 val);
        public static bool2x3 operator ==(float2x3 lhs, float2x3 rhs);
        public static bool2x3 operator ==(float2x3 lhs, float rhs);
        public static bool2x3 operator ==(float lhs, float2x3 rhs);
        public static bool2x3 operator !=(float2x3 lhs, float2x3 rhs);
        public static bool2x3 operator !=(float2x3 lhs, float rhs);
        public static bool2x3 operator !=(float lhs, float2x3 rhs);

        public static implicit operator float2x3(float v);
        public static explicit operator float2x3(bool v);
        public static explicit operator float2x3(bool2x3 v);
        public static implicit operator float2x3(int v);
        public static implicit operator float2x3(int2x3 v);
        public static implicit operator float2x3(uint v);
        public static implicit operator float2x3(uint2x3 v);
        public static explicit operator float2x3(double v);
        public static explicit operator float2x3(double2x3 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct float2x4 : IEquatable<float2x4>, IFormattable
    {
        public float2 c0;
        public float2 c1;
        public float2 c2;
        public float2 c3;
        public static readonly float2x4 zero;

        public float2x4(float2 c0, float2 c1, float2 c2, float2 c3);
        public float2x4(float m00, float m01, float m02, float m03, float m10, float m11, float m12, float m13);
        public float2x4(float v);
        public float2x4(bool v);
        public float2x4(bool2x4 v);
        public float2x4(int v);
        public float2x4(int2x4 v);
        public float2x4(uint v);
        public float2x4(uint2x4 v);
        public float2x4(double v);
        public float2x4(double2x4 v);

        public ref float2 this[int index] { get; }

        public bool Equals(float2x4 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static float2x4 operator *(float2x4 lhs, float2x4 rhs);
        public static float2x4 operator *(float2x4 lhs, float rhs);
        public static float2x4 operator *(float lhs, float2x4 rhs);
        public static float2x4 operator +(float2x4 lhs, float2x4 rhs);
        public static float2x4 operator +(float2x4 lhs, float rhs);
        public static float2x4 operator +(float lhs, float2x4 rhs);
        public static float2x4 operator -(float2x4 lhs, float2x4 rhs);
        public static float2x4 operator -(float2x4 lhs, float rhs);
        public static float2x4 operator -(float lhs, float2x4 rhs);
        public static float2x4 operator /(float2x4 lhs, float2x4 rhs);
        public static float2x4 operator /(float2x4 lhs, float rhs);
        public static float2x4 operator /(float lhs, float2x4 rhs);
        public static float2x4 operator %(float2x4 lhs, float2x4 rhs);
        public static float2x4 operator %(float2x4 lhs, float rhs);
        public static float2x4 operator %(float lhs, float2x4 rhs);
        public static float2x4 operator ++(float2x4 val);
        public static float2x4 operator --(float2x4 val);
        public static bool2x4 operator <(float2x4 lhs, float2x4 rhs);
        public static bool2x4 operator <(float2x4 lhs, float rhs);
        public static bool2x4 operator <(float lhs, float2x4 rhs);
        public static bool2x4 operator <=(float2x4 lhs, float2x4 rhs);
        public static bool2x4 operator <=(float2x4 lhs, float rhs);
        public static bool2x4 operator <=(float lhs, float2x4 rhs);
        public static bool2x4 operator >(float2x4 lhs, float2x4 rhs);
        public static bool2x4 operator >(float2x4 lhs, float rhs);
        public static bool2x4 operator >(float lhs, float2x4 rhs);
        public static bool2x4 operator >=(float2x4 lhs, float2x4 rhs);
        public static bool2x4 operator >=(float2x4 lhs, float rhs);
        public static bool2x4 operator >=(float lhs, float2x4 rhs);
        public static float2x4 operator -(float2x4 val);
        public static float2x4 operator +(float2x4 val);
        public static bool2x4 operator ==(float2x4 lhs, float2x4 rhs);
        public static bool2x4 operator ==(float2x4 lhs, float rhs);
        public static bool2x4 operator ==(float lhs, float2x4 rhs);
        public static bool2x4 operator !=(float2x4 lhs, float2x4 rhs);
        public static bool2x4 operator !=(float2x4 lhs, float rhs);
        public static bool2x4 operator !=(float lhs, float2x4 rhs);

        public static implicit operator float2x4(float v);
        public static explicit operator float2x4(bool v);
        public static explicit operator float2x4(bool2x4 v);
        public static implicit operator float2x4(int v);
        public static implicit operator float2x4(int2x4 v);
        public static implicit operator float2x4(uint v);
        public static implicit operator float2x4(uint2x4 v);
        public static explicit operator float2x4(double v);
        public static explicit operator float2x4(double2x4 v);
    }
}
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Reflection;
using UnityEngine;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    [DebuggerTypeProxy(typeof(DebuggerProxy))]
    public struct float3 : IEquatable<float3>, IFormattable
    {
        public float x;
        public float y;
        public float z;
        public static readonly float3 zero;

        public float3(float x, float y, float z);
        public float3(float x, float2 yz);
        public float3(float2 xy, float z);
        public float3(float3 xyz);
        public float3(float v);
        public float3(bool v);
        public float3(bool3 v);
        public float3(int v);
        public float3(int3 v);
        public float3(uint v);
        public float3(uint3 v);
        public float3(half v);
        public float3(half3 v);
        public float3(double v);
        public float3(double3 v);

        public float this[int index] { get; set; }
        [EditorBrowsable(Never)]
        public float4 xxxx { get; }
        [EditorBrowsable(Never)]
        public float4 xxxy { get; }
        [EditorBrowsable(Never)]
        public float4 xxxz { get; }
        [EditorBrowsable(Never)]
        public float4 xxyx { get; }
        [EditorBrowsable(Never)]
        public float4 xxyy { get; }
        [EditorBrowsable(Never)]
        public float4 xxyz { get; }
        [EditorBrowsable(Never)]
        public float4 xxzx { get; }
        [EditorBrowsable(Never)]
        public float4 xxzy { get; }
        [EditorBrowsable(Never)]
        public float4 xxzz { get; }
        [EditorBrowsable(Never)]
        public float4 xyxx { get; }
        [EditorBrowsable(Never)]
        public float4 xyxy { get; }
        [EditorBrowsable(Never)]
        public float4 xyxz { get; }
        [EditorBrowsable(Never)]
        public float4 xyyx { get; }
        [EditorBrowsable(Never)]
        public float4 xyyy { get; }
        [EditorBrowsable(Never)]
        public float4 xyyz { get; }
        [EditorBrowsable(Never)]
        public float4 xyzx { get; }
        [EditorBrowsable(Never)]
        public float4 xyzy { get; }
        [EditorBrowsable(Never)]
        public float4 xyzz { get; }
        [EditorBrowsable(Never)]
        public float4 xzxx { get; }
        [EditorBrowsable(Never)]
        public float4 xzxy { get; }
        [EditorBrowsable(Never)]
        public float4 xzxz { get; }
        [EditorBrowsable(Never)]
        public float4 xzyx { get; }
        [EditorBrowsable(Never)]
        public float4 xzyy { get; }
        [EditorBrowsable(Never)]
        public float4 xzyz { get; }
        [EditorBrowsable(Never)]
        public float4 xzzx { get; }
        [EditorBrowsable(Never)]
        public float4 xzzy { get; }
        [EditorBrowsable(Never)]
        public float4 xzzz { get; }
        [EditorBrowsable(Never)]
        public float4 yxxx { get; }
        [EditorBrowsable(Never)]
        public float4 yxxy { get; }
        [EditorBrowsable(Never)]
        public float4 yxxz { get; }
        [EditorBrowsable(Never)]
        public float4 yxyx { get; }
        [EditorBrowsable(Never)]
        public float4 yxyy { get; }
        [EditorBrowsable(Never)]
        public float4 yxyz { get; }
        [EditorBrowsable(Never)]
        public float4 yxzx { get; }
        [EditorBrowsable(Never)]
        public float4 yxzy { get; }
        [EditorBrowsable(Never)]
        public float4 yxzz { get; }
        [EditorBrowsable(Never)]
        public float4 yyxx { get; }
        [EditorBrowsable(Never)]
        public float4 yyxy { get; }
        [EditorBrowsable(Never)]
        public float4 yyxz { get; }
        [EditorBrowsable(Never)]
        public float4 yyyx { get; }
        [EditorBrowsable(Never)]
        public float4 yyyy { get; }
        [EditorBrowsable(Never)]
        public float4 yyyz { get; }
        [EditorBrowsable(Never)]
        public float4 yyzx { get; }
        [EditorBrowsable(Never)]
        public float4 yyzy { get; }
        [EditorBrowsable(Never)]
        public float4 yyzz { get; }
        [EditorBrowsable(Never)]
        public float4 yzxx { get; }
        [EditorBrowsable(Never)]
        public float4 yzxy { get; }
        [EditorBrowsable(Never)]
        public float4 yzxz { get; }
        [EditorBrowsable(Never)]
        public float4 yzyx { get; }
        [EditorBrowsable(Never)]
        public float4 yzyy { get; }
        [EditorBrowsable(Never)]
        public float4 yzyz { get; }
        [EditorBrowsable(Never)]
        public float4 yzzx { get; }
        [EditorBrowsable(Never)]
        public float4 yzzy { get; }
        [EditorBrowsable(Never)]
        public float4 yzzz { get; }
        [EditorBrowsable(Never)]
        public float4 zxxx { get; }
        [EditorBrowsable(Never)]
        public float4 zxxy { get; }
        [EditorBrowsable(Never)]
        public float4 zxxz { get; }
        [EditorBrowsable(Never)]
        public float4 zxyx { get; }
        [EditorBrowsable(Never)]
        public float4 zxyy { get; }
        [EditorBrowsable(Never)]
        public float4 zxyz { get; }
        [EditorBrowsable(Never)]
        public float4 zxzx { get; }
        [EditorBrowsable(Never)]
        public float4 zxzy { get; }
        [EditorBrowsable(Never)]
        public float4 zxzz { get; }
        [EditorBrowsable(Never)]
        public float4 zyxx { get; }
        [EditorBrowsable(Never)]
        public float4 zyxy { get; }
        [EditorBrowsable(Never)]
        public float4 zyxz { get; }
        [EditorBrowsable(Never)]
        public float4 zyyx { get; }
        [EditorBrowsable(Never)]
        public float4 zyyy { get; }
        [EditorBrowsable(Never)]
        public float4 zyyz { get; }
        [EditorBrowsable(Never)]
        public float4 zyzx { get; }
        [EditorBrowsable(Never)]
        public float4 zyzy { get; }
        [EditorBrowsable(Never)]
        public float4 zyzz { get; }
        [EditorBrowsable(Never)]
        public float4 zzxx { get; }
        [EditorBrowsable(Never)]
        public float4 zzxy { get; }
        [EditorBrowsable(Never)]
        public float4 zzxz { get; }
        [EditorBrowsable(Never)]
        public float4 zzyx { get; }
        [EditorBrowsable(Never)]
        public float4 zzyy { get; }
        [EditorBrowsable(Never)]
        public float4 zzyz { get; }
        [EditorBrowsable(Never)]
        public float4 zzzx { get; }
        [EditorBrowsable(Never)]
        public float4 zzzy { get; }
        [EditorBrowsable(Never)]
        public float4 zzzz { get; }
        [EditorBrowsable(Never)]
        public float3 xxx { get; }
        [EditorBrowsable(Never)]
        public float3 xxy { get; }
        [EditorBrowsable(Never)]
        public float3 xxz { get; }
        [EditorBrowsable(Never)]
        public float3 xyx { get; }
        [EditorBrowsable(Never)]
        public float3 xyy { get; }
        [EditorBrowsable(Never)]
        public float3 xyz { get; set; }
        [EditorBrowsable(Never)]
        public float3 xzx { get; }
        [EditorBrowsable(Never)]
        public float3 xzy { get; set; }
        [EditorBrowsable(Never)]
        public float3 xzz { get; }
        [EditorBrowsable(Never)]
        public float3 yxx { get; }
        [EditorBrowsable(Never)]
        public float3 yxy { get; }
        [EditorBrowsable(Never)]
        public float3 yxz { get; set; }
        [EditorBrowsable(Never)]
        public float3 yyx { get; }
        [EditorBrowsable(Never)]
        public float3 yyy { get; }
        [EditorBrowsable(Never)]
        public float3 yyz { get; }
        [EditorBrowsable(Never)]
        public float3 yzx { get; set; }
        [EditorBrowsable(Never)]
        public float3 yzy { get; }
        [EditorBrowsable(Never)]
        public float3 yzz { get; }
        [EditorBrowsable(Never)]
        public float3 zxx { get; }
        [EditorBrowsable(Never)]
        public float3 zxy { get; set; }
        [EditorBrowsable(Never)]
        public float3 zxz { get; }
        [EditorBrowsable(Never)]
        public float3 zyx { get; set; }
        [EditorBrowsable(Never)]
        public float3 zyy { get; }
        [EditorBrowsable(Never)]
        public float3 zyz { get; }
        [EditorBrowsable(Never)]
        public float3 zzx { get; }
        [EditorBrowsable(Never)]
        public float3 zzy { get; }
        [EditorBrowsable(Never)]
        public float3 zzz { get; }
        [EditorBrowsable(Never)]
        public float2 xx { get; }
        [EditorBrowsable(Never)]
        public float2 xy { get; set; }
        [EditorBrowsable(Never)]
        public float2 xz { get; set; }
        [EditorBrowsable(Never)]
        public float2 yx { get; set; }
        [EditorBrowsable(Never)]
        public float2 yy { get; }
        [EditorBrowsable(Never)]
        public float2 yz { get; set; }
        [EditorBrowsable(Never)]
        public float2 zx { get; set; }
        [EditorBrowsable(Never)]
        public float2 zy { get; set; }
        [EditorBrowsable(Never)]
        public float2 zz { get; }

        public bool Equals(float3 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static float3 operator *(float3 lhs, float3 rhs);
        public static float3 operator *(float3 lhs, float rhs);
        public static float3 operator *(float lhs, float3 rhs);
        public static float3 operator +(float3 lhs, float3 rhs);
        public static float3 operator +(float3 lhs, float rhs);
        public static float3 operator +(float lhs, float3 rhs);
        public static float3 operator -(float3 lhs, float3 rhs);
        public static float3 operator -(float3 lhs, float rhs);
        public static float3 operator -(float lhs, float3 rhs);
        public static float3 operator /(float3 lhs, float3 rhs);
        public static float3 operator /(float3 lhs, float rhs);
        public static float3 operator /(float lhs, float3 rhs);
        public static float3 operator %(float3 lhs, float3 rhs);
        public static float3 operator %(float3 lhs, float rhs);
        public static float3 operator %(float lhs, float3 rhs);
        public static float3 operator ++(float3 val);
        public static float3 operator --(float3 val);
        public static bool3 operator <(float3 lhs, float3 rhs);
        public static bool3 operator <(float3 lhs, float rhs);
        public static bool3 operator <(float lhs, float3 rhs);
        public static bool3 operator <=(float3 lhs, float3 rhs);
        public static bool3 operator <=(float3 lhs, float rhs);
        public static bool3 operator <=(float lhs, float3 rhs);
        public static bool3 operator >(float3 lhs, float3 rhs);
        public static bool3 operator >(float3 lhs, float rhs);
        public static bool3 operator >(float lhs, float3 rhs);
        public static bool3 operator >=(float3 lhs, float3 rhs);
        public static bool3 operator >=(float3 lhs, float rhs);
        public static bool3 operator >=(float lhs, float3 rhs);
        public static float3 operator -(float3 val);
        public static float3 operator +(float3 val);
        public static bool3 operator ==(float3 lhs, float3 rhs);
        public static bool3 operator ==(float3 lhs, float rhs);
        public static bool3 operator ==(float lhs, float3 rhs);
        public static bool3 operator !=(float3 lhs, float3 rhs);
        public static bool3 operator !=(float3 lhs, float rhs);
        public static bool3 operator !=(float lhs, float3 rhs);

        public static implicit operator float3(float v);
        public static explicit operator float3(bool v);
        public static explicit operator float3(bool3 v);
        public static implicit operator float3(int v);
        public static implicit operator float3(int3 v);
        public static implicit operator float3(uint v);
        public static implicit operator float3(uint3 v);
        public static implicit operator float3(half v);
        public static implicit operator float3(half3 v);
        public static explicit operator float3(double v);
        public static explicit operator float3(double3 v);
        public static implicit operator Vector3(float3 v);
        public static implicit operator float3(Vector3 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct float3x2 : IEquatable<float3x2>, IFormattable
    {
        public float3 c0;
        public float3 c1;
        public static readonly float3x2 zero;

        public float3x2(float3 c0, float3 c1);
        public float3x2(float m00, float m01, float m10, float m11, float m20, float m21);
        public float3x2(float v);
        public float3x2(bool v);
        public float3x2(bool3x2 v);
        public float3x2(int v);
        public float3x2(int3x2 v);
        public float3x2(uint v);
        public float3x2(uint3x2 v);
        public float3x2(double v);
        public float3x2(double3x2 v);

        public ref float3 this[int index] { get; }

        public bool Equals(float3x2 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static float3x2 operator *(float3x2 lhs, float3x2 rhs);
        public static float3x2 operator *(float3x2 lhs, float rhs);
        public static float3x2 operator *(float lhs, float3x2 rhs);
        public static float3x2 operator +(float3x2 lhs, float3x2 rhs);
        public static float3x2 operator +(float3x2 lhs, float rhs);
        public static float3x2 operator +(float lhs, float3x2 rhs);
        public static float3x2 operator -(float3x2 lhs, float3x2 rhs);
        public static float3x2 operator -(float3x2 lhs, float rhs);
        public static float3x2 operator -(float lhs, float3x2 rhs);
        public static float3x2 operator /(float3x2 lhs, float3x2 rhs);
        public static float3x2 operator /(float3x2 lhs, float rhs);
        public static float3x2 operator /(float lhs, float3x2 rhs);
        public static float3x2 operator %(float3x2 lhs, float3x2 rhs);
        public static float3x2 operator %(float3x2 lhs, float rhs);
        public static float3x2 operator %(float lhs, float3x2 rhs);
        public static float3x2 operator ++(float3x2 val);
        public static float3x2 operator --(float3x2 val);
        public static bool3x2 operator <(float3x2 lhs, float3x2 rhs);
        public static bool3x2 operator <(float3x2 lhs, float rhs);
        public static bool3x2 operator <(float lhs, float3x2 rhs);
        public static bool3x2 operator <=(float3x2 lhs, float3x2 rhs);
        public static bool3x2 operator <=(float3x2 lhs, float rhs);
        public static bool3x2 operator <=(float lhs, float3x2 rhs);
        public static bool3x2 operator >(float3x2 lhs, float3x2 rhs);
        public static bool3x2 operator >(float3x2 lhs, float rhs);
        public static bool3x2 operator >(float lhs, float3x2 rhs);
        public static bool3x2 operator >=(float3x2 lhs, float3x2 rhs);
        public static bool3x2 operator >=(float3x2 lhs, float rhs);
        public static bool3x2 operator >=(float lhs, float3x2 rhs);
        public static float3x2 operator -(float3x2 val);
        public static float3x2 operator +(float3x2 val);
        public static bool3x2 operator ==(float3x2 lhs, float3x2 rhs);
        public static bool3x2 operator ==(float3x2 lhs, float rhs);
        public static bool3x2 operator ==(float lhs, float3x2 rhs);
        public static bool3x2 operator !=(float3x2 lhs, float3x2 rhs);
        public static bool3x2 operator !=(float3x2 lhs, float rhs);
        public static bool3x2 operator !=(float lhs, float3x2 rhs);

        public static implicit operator float3x2(float v);
        public static explicit operator float3x2(bool v);
        public static explicit operator float3x2(bool3x2 v);
        public static implicit operator float3x2(int v);
        public static implicit operator float3x2(int3x2 v);
        public static implicit operator float3x2(uint v);
        public static implicit operator float3x2(uint3x2 v);
        public static explicit operator float3x2(double v);
        public static explicit operator float3x2(double3x2 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct float3x3 : IEquatable<float3x3>, IFormattable
    {
        public float3 c0;
        public float3 c1;
        public float3 c2;
        public static readonly float3x3 identity;
        public static readonly float3x3 zero;

        public float3x3(float3 c0, float3 c1, float3 c2);
        public float3x3(float m00, float m01, float m02, float m10, float m11, float m12, float m20, float m21, float m22);
        public float3x3(float v);
        public float3x3(bool v);
        public float3x3(bool3x3 v);
        public float3x3(int v);
        public float3x3(int3x3 v);
        public float3x3(uint v);
        public float3x3(uint3x3 v);
        public float3x3(double v);
        public float3x3(double3x3 v);
        public float3x3(quaternion q);

        public ref float3 this[int index] { get; }

        public bool Equals(float3x3 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);
        public static float3x3 AxisAngle(float3 axis, float angle);
        public static float3x3 EulerXYZ(float3 xyz);
        public static float3x3 EulerXZY(float3 xyz);
        public static float3x3 EulerYXZ(float3 xyz);
        public static float3x3 EulerYZX(float3 xyz);
        public static float3x3 EulerZXY(float3 xyz);
        public static float3x3 EulerZYX(float3 xyz);
        public static float3x3 EulerXYZ(float x, float y, float z);
        public static float3x3 EulerXZY(float x, float y, float z);
        public static float3x3 EulerYXZ(float x, float y, float z);
        public static float3x3 EulerYZX(float x, float y, float z);
        public static float3x3 EulerZXY(float x, float y, float z);
        public static float3x3 EulerZYX(float x, float y, float z);
        public static float3x3 Euler(float3 xyz, math.RotationOrder order = Default);
        public static float3x3 Euler(float x, float y, float z, math.RotationOrder order = Default);
        public static float3x3 RotateX(float angle);
        public static float3x3 RotateY(float angle);
        public static float3x3 RotateZ(float angle);
        public static float3x3 Scale(float s);
        public static float3x3 Scale(float x, float y, float z);
        public static float3x3 Scale(float3 v);
        public static float3x3 LookRotation(float3 forward, float3 up);
        public static float3x3 LookRotationSafe(float3 forward, float3 up);

        public static float3x3 operator *(float3x3 lhs, float3x3 rhs);
        public static float3x3 operator *(float3x3 lhs, float rhs);
        public static float3x3 operator *(float lhs, float3x3 rhs);
        public static float3x3 operator +(float3x3 lhs, float3x3 rhs);
        public static float3x3 operator +(float3x3 lhs, float rhs);
        public static float3x3 operator +(float lhs, float3x3 rhs);
        public static float3x3 operator -(float3x3 lhs, float3x3 rhs);
        public static float3x3 operator -(float3x3 lhs, float rhs);
        public static float3x3 operator -(float lhs, float3x3 rhs);
        public static float3x3 operator /(float3x3 lhs, float3x3 rhs);
        public static float3x3 operator /(float3x3 lhs, float rhs);
        public static float3x3 operator /(float lhs, float3x3 rhs);
        public static float3x3 operator %(float3x3 lhs, float3x3 rhs);
        public static float3x3 operator %(float3x3 lhs, float rhs);
        public static float3x3 operator %(float lhs, float3x3 rhs);
        public static float3x3 operator ++(float3x3 val);
        public static float3x3 operator --(float3x3 val);
        public static bool3x3 operator <(float3x3 lhs, float3x3 rhs);
        public static bool3x3 operator <(float3x3 lhs, float rhs);
        public static bool3x3 operator <(float lhs, float3x3 rhs);
        public static bool3x3 operator <=(float3x3 lhs, float3x3 rhs);
        public static bool3x3 operator <=(float3x3 lhs, float rhs);
        public static bool3x3 operator <=(float lhs, float3x3 rhs);
        public static bool3x3 operator >(float3x3 lhs, float3x3 rhs);
        public static bool3x3 operator >(float3x3 lhs, float rhs);
        public static bool3x3 operator >(float lhs, float3x3 rhs);
        public static bool3x3 operator >=(float3x3 lhs, float3x3 rhs);
        public static bool3x3 operator >=(float3x3 lhs, float rhs);
        public static bool3x3 operator >=(float lhs, float3x3 rhs);
        public static float3x3 operator -(float3x3 val);
        public static float3x3 operator +(float3x3 val);
        public static bool3x3 operator ==(float3x3 lhs, float3x3 rhs);
        public static bool3x3 operator ==(float3x3 lhs, float rhs);
        public static bool3x3 operator ==(float lhs, float3x3 rhs);
        public static bool3x3 operator !=(float3x3 lhs, float3x3 rhs);
        public static bool3x3 operator !=(float3x3 lhs, float rhs);
        public static bool3x3 operator !=(float lhs, float3x3 rhs);

        public static implicit operator float3x3(float v);
        public static explicit operator float3x3(bool v);
        public static explicit operator float3x3(bool3x3 v);
        public static implicit operator float3x3(int v);
        public static implicit operator float3x3(int3x3 v);
        public static implicit operator float3x3(uint v);
        public static implicit operator float3x3(uint3x3 v);
        public static explicit operator float3x3(double v);
        public static explicit operator float3x3(double3x3 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct float3x4 : IEquatable<float3x4>, IFormattable
    {
        public float3 c0;
        public float3 c1;
        public float3 c2;
        public float3 c3;
        public static readonly float3x4 zero;

        public float3x4(float3 c0, float3 c1, float3 c2, float3 c3);
        public float3x4(float m00, float m01, float m02, float m03, float m10, float m11, float m12, float m13, float m20, float m21, float m22, float m23);
        public float3x4(float v);
        public float3x4(bool v);
        public float3x4(bool3x4 v);
        public float3x4(int v);
        public float3x4(int3x4 v);
        public float3x4(uint v);
        public float3x4(uint3x4 v);
        public float3x4(double v);
        public float3x4(double3x4 v);

        public ref float3 this[int index] { get; }

        public bool Equals(float3x4 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static float3x4 operator *(float3x4 lhs, float3x4 rhs);
        public static float3x4 operator *(float3x4 lhs, float rhs);
        public static float3x4 operator *(float lhs, float3x4 rhs);
        public static float3x4 operator +(float3x4 lhs, float3x4 rhs);
        public static float3x4 operator +(float3x4 lhs, float rhs);
        public static float3x4 operator +(float lhs, float3x4 rhs);
        public static float3x4 operator -(float3x4 lhs, float3x4 rhs);
        public static float3x4 operator -(float3x4 lhs, float rhs);
        public static float3x4 operator -(float lhs, float3x4 rhs);
        public static float3x4 operator /(float3x4 lhs, float3x4 rhs);
        public static float3x4 operator /(float3x4 lhs, float rhs);
        public static float3x4 operator /(float lhs, float3x4 rhs);
        public static float3x4 operator %(float3x4 lhs, float3x4 rhs);
        public static float3x4 operator %(float3x4 lhs, float rhs);
        public static float3x4 operator %(float lhs, float3x4 rhs);
        public static float3x4 operator ++(float3x4 val);
        public static float3x4 operator --(float3x4 val);
        public static bool3x4 operator <(float3x4 lhs, float3x4 rhs);
        public static bool3x4 operator <(float3x4 lhs, float rhs);
        public static bool3x4 operator <(float lhs, float3x4 rhs);
        public static bool3x4 operator <=(float3x4 lhs, float3x4 rhs);
        public static bool3x4 operator <=(float3x4 lhs, float rhs);
        public static bool3x4 operator <=(float lhs, float3x4 rhs);
        public static bool3x4 operator >(float3x4 lhs, float3x4 rhs);
        public static bool3x4 operator >(float3x4 lhs, float rhs);
        public static bool3x4 operator >(float lhs, float3x4 rhs);
        public static bool3x4 operator >=(float3x4 lhs, float3x4 rhs);
        public static bool3x4 operator >=(float3x4 lhs, float rhs);
        public static bool3x4 operator >=(float lhs, float3x4 rhs);
        public static float3x4 operator -(float3x4 val);
        public static float3x4 operator +(float3x4 val);
        public static bool3x4 operator ==(float3x4 lhs, float3x4 rhs);
        public static bool3x4 operator ==(float3x4 lhs, float rhs);
        public static bool3x4 operator ==(float lhs, float3x4 rhs);
        public static bool3x4 operator !=(float3x4 lhs, float3x4 rhs);
        public static bool3x4 operator !=(float3x4 lhs, float rhs);
        public static bool3x4 operator !=(float lhs, float3x4 rhs);

        public static implicit operator float3x4(float v);
        public static explicit operator float3x4(bool v);
        public static explicit operator float3x4(bool3x4 v);
        public static implicit operator float3x4(int v);
        public static implicit operator float3x4(int3x4 v);
        public static implicit operator float3x4(uint v);
        public static implicit operator float3x4(uint3x4 v);
        public static explicit operator float3x4(double v);
        public static explicit operator float3x4(double3x4 v);
    }
}
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Reflection;
using UnityEngine;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    [DebuggerTypeProxy(typeof(DebuggerProxy))]
    public struct float4 : IEquatable<float4>, IFormattable
    {
        public float x;
        public float y;
        public float z;
        public float w;
        public static readonly float4 zero;

        public float4(float x, float y, float z, float w);
        public float4(float x, float y, float2 zw);
        public float4(float x, float2 yz, float w);
        public float4(float x, float3 yzw);
        public float4(float2 xy, float z, float w);
        public float4(float2 xy, float2 zw);
        public float4(float3 xyz, float w);
        public float4(float4 xyzw);
        public float4(float v);
        public float4(bool v);
        public float4(bool4 v);
        public float4(int v);
        public float4(int4 v);
        public float4(uint v);
        public float4(uint4 v);
        public float4(half v);
        public float4(half4 v);
        public float4(double v);
        public float4(double4 v);

        public float this[int index] { get; set; }
        [EditorBrowsable(Never)]
        public float4 xxxx { get; }
        [EditorBrowsable(Never)]
        public float4 xxxy { get; }
        [EditorBrowsable(Never)]
        public float4 xxxz { get; }
        [EditorBrowsable(Never)]
        public float4 xxxw { get; }
        [EditorBrowsable(Never)]
        public float4 xxyx { get; }
        [EditorBrowsable(Never)]
        public float4 xxyy { get; }
        [EditorBrowsable(Never)]
        public float4 xxyz { get; }
        [EditorBrowsable(Never)]
        public float4 xxyw { get; }
        [EditorBrowsable(Never)]
        public float4 xxzx { get; }
        [EditorBrowsable(Never)]
        public float4 xxzy { get; }
        [EditorBrowsable(Never)]
        public float4 xxzz { get; }
        [EditorBrowsable(Never)]
        public float4 xxzw { get; }
        [EditorBrowsable(Never)]
        public float4 xxwx { get; }
        [EditorBrowsable(Never)]
        public float4 xxwy { get; }
        [EditorBrowsable(Never)]
        public float4 xxwz { get; }
        [EditorBrowsable(Never)]
        public float4 xxww { get; }
        [EditorBrowsable(Never)]
        public float4 xyxx { get; }
        [EditorBrowsable(Never)]
        public float4 xyxy { get; }
        [EditorBrowsable(Never)]
        public float4 xyxz { get; }
        [EditorBrowsable(Never)]
        public float4 xyxw { get; }
        [EditorBrowsable(Never)]
        public float4 xyyx { get; }
        [EditorBrowsable(Never)]
        public float4 xyyy { get; }
        [EditorBrowsable(Never)]
        public float4 xyyz { get; }
        [EditorBrowsable(Never)]
        public float4 xyyw { get; }
        [EditorBrowsable(Never)]
        public float4 xyzx { get; }
        [EditorBrowsable(Never)]
        public float4 xyzy { get; }
        [EditorBrowsable(Never)]
        public float4 xyzz { get; }
        [EditorBrowsable(Never)]
        public float4 xyzw { get; set; }
        [EditorBrowsable(Never)]
        public float4 xywx { get; }
        [EditorBrowsable(Never)]
        public float4 xywy { get; }
        [EditorBrowsable(Never)]
        public float4 xywz { get; set; }
        [EditorBrowsable(Never)]
        public float4 xyww { get; }
        [EditorBrowsable(Never)]
        public float4 xzxx { get; }
        [EditorBrowsable(Never)]
        public float4 xzxy { get; }
        [EditorBrowsable(Never)]
        public float4 xzxz { get; }
        [EditorBrowsable(Never)]
        public float4 xzxw { get; }
        [EditorBrowsable(Never)]
        public float4 xzyx { get; }
        [EditorBrowsable(Never)]
        public float4 xzyy { get; }
        [EditorBrowsable(Never)]
        public float4 xzyz { get; }
        [EditorBrowsable(Never)]
        public float4 xzyw { get; set; }
        [EditorBrowsable(Never)]
        public float4 xzzx { get; }
        [EditorBrowsable(Never)]
        public float4 xzzy { get; }
        [EditorBrowsable(Never)]
        public float4 xzzz { get; }
        [EditorBrowsable(Never)]
        public float4 xzzw { get; }
        [EditorBrowsable(Never)]
        public float4 xzwx { get; }
        [EditorBrowsable(Never)]
        public float4 xzwy { get; set; }
        [EditorBrowsable(Never)]
        public float4 xzwz { get; }
        [EditorBrowsable(Never)]
        public float4 xzww { get; }
        [EditorBrowsable(Never)]
        public float4 xwxx { get; }
        [EditorBrowsable(Never)]
        public float4 xwxy { get; }
        [EditorBrowsable(Never)]
        public float4 xwxz { get; }
        [EditorBrowsable(Never)]
        public float4 xwxw { get; }
        [EditorBrowsable(Never)]
        public float4 xwyx { get; }
        [EditorBrowsable(Never)]
        public float4 xwyy { get; }
        [EditorBrowsable(Never)]
        public float4 xwyz { get; set; }
        [EditorBrowsable(Never)]
        public float4 xwyw { get; }
        [EditorBrowsable(Never)]
        public float4 xwzx { get; }
        [EditorBrowsable(Never)]
        public float4 xwzy { get; set; }
        [EditorBrowsable(Never)]
        public float4 xwzz { get; }
        [EditorBrowsable(Never)]
        public float4 xwzw { get; }
        [EditorBrowsable(Never)]
        public float4 xwwx { get; }
        [EditorBrowsable(Never)]
        public float4 xwwy { get; }
        [EditorBrowsable(Never)]
        public float4 xwwz { get; }
        [EditorBrowsable(Never)]
        public float4 xwww { get; }
        [EditorBrowsable(Never)]
        public float4 yxxx { get; }
        [EditorBrowsable(Never)]
        public float4 yxxy { get; }
        [EditorBrowsable(Never)]
        public float4 yxxz { get; }
        [EditorBrowsable(Never)]
        public float4 yxxw { get; }
        [EditorBrowsable(Never)]
        public float4 yxyx { get; }
        [EditorBrowsable(Never)]
        public float4 yxyy { get; }
        [EditorBrowsable(Never)]
        public float4 yxyz { get; }
        [EditorBrowsable(Never)]
        public float4 yxyw { get; }
        [EditorBrowsable(Never)]
        public float4 yxzx { get; }
        [EditorBrowsable(Never)]
        public float4 yxzy { get; }
        [EditorBrowsable(Never)]
        public float4 yxzz { get; }
        [EditorBrowsable(Never)]
        public float4 yxzw { get; set; }
        [EditorBrowsable(Never)]
        public float4 yxwx { get; }
        [EditorBrowsable(Never)]
        public float4 yxwy { get; }
        [EditorBrowsable(Never)]
        public float4 yxwz { get; set; }
        [EditorBrowsable(Never)]
        public float4 yxww { get; }
        [EditorBrowsable(Never)]
        public float4 yyxx { get; }
        [EditorBrowsable(Never)]
        public float4 yyxy { get; }
        [EditorBrowsable(Never)]
        public float4 yyxz { get; }
        [EditorBrowsable(Never)]
        public float4 yyxw { get; }
        [EditorBrowsable(Never)]
        public float4 yyyx { get; }
        [EditorBrowsable(Never)]
        public float4 yyyy { get; }
        [EditorBrowsable(Never)]
        public float4 yyyz { get; }
        [EditorBrowsable(Never)]
        public float4 yyyw { get; }
        [EditorBrowsable(Never)]
        public float4 yyzx { get; }
        [EditorBrowsable(Never)]
        public float4 yyzy { get; }
        [EditorBrowsable(Never)]
        public float4 yyzz { get; }
        [EditorBrowsable(Never)]
        public float4 yyzw { get; }
        [EditorBrowsable(Never)]
        public float4 yywx { get; }
        [EditorBrowsable(Never)]
        public float4 yywy { get; }
        [EditorBrowsable(Never)]
        public float4 yywz { get; }
        [EditorBrowsable(Never)]
        public float4 yyww { get; }
        [EditorBrowsable(Never)]
        public float4 yzxx { get; }
        [EditorBrowsable(Never)]
        public float4 yzxy { get; }
        [EditorBrowsable(Never)]
        public float4 yzxz { get; }
        [EditorBrowsable(Never)]
        public float4 yzxw { get; set; }
        [EditorBrowsable(Never)]
        public float4 yzyx { get; }
        [EditorBrowsable(Never)]
        public float4 yzyy { get; }
        [EditorBrowsable(Never)]
        public float4 yzyz { get; }
        [EditorBrowsable(Never)]
        public float4 yzyw { get; }
        [EditorBrowsable(Never)]
        public float4 yzzx { get; }
        [EditorBrowsable(Never)]
        public float4 yzzy { get; }
        [EditorBrowsable(Never)]
        public float4 yzzz { get; }
        [EditorBrowsable(Never)]
        public float4 yzzw { get; }
        [EditorBrowsable(Never)]
        public float4 yzwx { get; set; }
        [EditorBrowsable(Never)]
        public float4 yzwy { get; }
        [EditorBrowsable(Never)]
        public float4 yzwz { get; }
        [EditorBrowsable(Never)]
        public float4 yzww { get; }
        [EditorBrowsable(Never)]
        public float4 ywxx { get; }
        [EditorBrowsable(Never)]
        public float4 ywxy { get; }
        [EditorBrowsable(Never)]
        public float4 ywxz { get; set; }
        [EditorBrowsable(Never)]
        public float4 ywxw { get; }
        [EditorBrowsable(Never)]
        public float4 ywyx { get; }
        [EditorBrowsable(Never)]
        public float4 ywyy { get; }
        [EditorBrowsable(Never)]
        public float4 ywyz { get; }
        [EditorBrowsable(Never)]
        public float4 ywyw { get; }
        [EditorBrowsable(Never)]
        public float4 ywzx { get; set; }
        [EditorBrowsable(Never)]
        public float4 ywzy { get; }
        [EditorBrowsable(Never)]
        public float4 ywzz { get; }
        [EditorBrowsable(Never)]
        public float4 ywzw { get; }
        [EditorBrowsable(Never)]
        public float4 ywwx { get; }
        [EditorBrowsable(Never)]
        public float4 ywwy { get; }
        [EditorBrowsable(Never)]
        public float4 ywwz { get; }
        [EditorBrowsable(Never)]
        public float4 ywww { get; }
        [EditorBrowsable(Never)]
        public float4 zxxx { get; }
        [EditorBrowsable(Never)]
        public float4 zxxy { get; }
        [EditorBrowsable(Never)]
        public float4 zxxz { get; }
        [EditorBrowsable(Never)]
        public float4 zxxw { get; }
        [EditorBrowsable(Never)]
        public float4 zxyx { get; }
        [EditorBrowsable(Never)]
        public float4 zxyy { get; }
        [EditorBrowsable(Never)]
        public float4 zxyz { get; }
        [EditorBrowsable(Never)]
        public float4 zxyw { get; set; }
        [EditorBrowsable(Never)]
        public float4 zxzx { get; }
        [EditorBrowsable(Never)]
        public float4 zxzy { get; }
        [EditorBrowsable(Never)]
        public float4 zxzz { get; }
        [EditorBrowsable(Never)]
        public float4 zxzw { get; }
        [EditorBrowsable(Never)]
        public float4 zxwx { get; }
        [EditorBrowsable(Never)]
        public float4 zxwy { get; set; }
        [EditorBrowsable(Never)]
        public float4 zxwz { get; }
        [EditorBrowsable(Never)]
        public float4 zxww { get; }
        [EditorBrowsable(Never)]
        public float4 zyxx { get; }
        [EditorBrowsable(Never)]
        public float4 zyxy { get; }
        [EditorBrowsable(Never)]
        public float4 zyxz { get; }
        [EditorBrowsable(Never)]
        public float4 zyxw { get; set; }
        [EditorBrowsable(Never)]
        public float4 zyyx { get; }
        [EditorBrowsable(Never)]
        public float4 zyyy { get; }
        [EditorBrowsable(Never)]
        public float4 zyyz { get; }
        [EditorBrowsable(Never)]
        public float4 zyyw { get; }
        [EditorBrowsable(Never)]
        public float4 zyzx { get; }
        [EditorBrowsable(Never)]
        public float4 zyzy { get; }
        [EditorBrowsable(Never)]
        public float4 zyzz { get; }
        [EditorBrowsable(Never)]
        public float4 zyzw { get; }
        [EditorBrowsable(Never)]
        public float4 zywx { get; set; }
        [EditorBrowsable(Never)]
        public float4 zywy { get; }
        [EditorBrowsable(Never)]
        public float4 zywz { get; }
        [EditorBrowsable(Never)]
        public float4 zyww { get; }
        [EditorBrowsable(Never)]
        public float4 zzxx { get; }
        [EditorBrowsable(Never)]
        public float4 zzxy { get; }
        [EditorBrowsable(Never)]
        public float4 zzxz { get; }
        [EditorBrowsable(Never)]
        public float4 zzxw { get; }
        [EditorBrowsable(Never)]
        public float4 zzyx { get; }
        [EditorBrowsable(Never)]
        public float4 zzyy { get; }
        [EditorBrowsable(Never)]
        public float4 zzyz { get; }
        [EditorBrowsable(Never)]
        public float4 zzyw { get; }
        [EditorBrowsable(Never)]
        public float4 zzzx { get; }
        [EditorBrowsable(Never)]
        public float4 zzzy { get; }
        [EditorBrowsable(Never)]
        public float4 zzzz { get; }
        [EditorBrowsable(Never)]
        public float4 zzzw { get; }
        [EditorBrowsable(Never)]
        public float4 zzwx { get; }
        [EditorBrowsable(Never)]
        public float4 zzwy { get; }
        [EditorBrowsable(Never)]
        public float4 zzwz { get; }
        [EditorBrowsable(Never)]
        public float4 zzww { get; }
        [EditorBrowsable(Never)]
        public float4 zwxx { get; }
        [EditorBrowsable(Never)]
        public float4 zwxy { get; set; }
        [EditorBrowsable(Never)]
        public float4 zwxz { get; }
        [EditorBrowsable(Never)]
        public float4 zwxw { get; }
        [EditorBrowsable(Never)]
        public float4 zwyx { get; set; }
        [EditorBrowsable(Never)]
        public float4 zwyy { get; }
        [EditorBrowsable(Never)]
        public float4 zwyz { get; }
        [EditorBrowsable(Never)]
        public float4 zwyw { get; }
        [EditorBrowsable(Never)]
        public float4 zwzx { get; }
        [EditorBrowsable(Never)]
        public float4 zwzy { get; }
        [EditorBrowsable(Never)]
        public float4 zwzz { get; }
        [EditorBrowsable(Never)]
        public float4 zwzw { get; }
        [EditorBrowsable(Never)]
        public float4 zwwx { get; }
        [EditorBrowsable(Never)]
        public float4 zwwy { get; }
        [EditorBrowsable(Never)]
        public float4 zwwz { get; }
        [EditorBrowsable(Never)]
        public float4 zwww { get; }
        [EditorBrowsable(Never)]
        public float4 wxxx { get; }
        [EditorBrowsable(Never)]
        public float4 wxxy { get; }
        [EditorBrowsable(Never)]
        public float4 wxxz { get; }
        [EditorBrowsable(Never)]
        public float4 wxxw { get; }
        [EditorBrowsable(Never)]
        public float4 wxyx { get; }
        [EditorBrowsable(Never)]
        public float4 wxyy { get; }
        [EditorBrowsable(Never)]
        public float4 wxyz { get; set; }
        [EditorBrowsable(Never)]
        public float4 wxyw { get; }
        [EditorBrowsable(Never)]
        public float4 wxzx { get; }
        [EditorBrowsable(Never)]
        public float4 wxzy { get; set; }
        [EditorBrowsable(Never)]
        public float4 wxzz { get; }
        [EditorBrowsable(Never)]
        public float4 wxzw { get; }
        [EditorBrowsable(Never)]
        public float4 wxwx { get; }
        [EditorBrowsable(Never)]
        public float4 wxwy { get; }
        [EditorBrowsable(Never)]
        public float4 wxwz { get; }
        [EditorBrowsable(Never)]
        public float4 wxww { get; }
        [EditorBrowsable(Never)]
        public float4 wyxx { get; }
        [EditorBrowsable(Never)]
        public float4 wyxy { get; }
        [EditorBrowsable(Never)]
        public float4 wyxz { get; set; }
        [EditorBrowsable(Never)]
        public float4 wyxw { get; }
        [EditorBrowsable(Never)]
        public float4 wyyx { get; }
        [EditorBrowsable(Never)]
        public float4 wyyy { get; }
        [EditorBrowsable(Never)]
        public float4 wyyz { get; }
        [EditorBrowsable(Never)]
        public float4 wyyw { get; }
        [EditorBrowsable(Never)]
        public float4 wyzx { get; set; }
        [EditorBrowsable(Never)]
        public float4 wyzy { get; }
        [EditorBrowsable(Never)]
        public float4 wyzz { get; }
        [EditorBrowsable(Never)]
        public float4 wyzw { get; }
        [EditorBrowsable(Never)]
        public float4 wywx { get; }
        [EditorBrowsable(Never)]
        public float4 wywy { get; }
        [EditorBrowsable(Never)]
        public float4 wywz { get; }
        [EditorBrowsable(Never)]
        public float4 wyww { get; }
        [EditorBrowsable(Never)]
        public float4 wzxx { get; }
        [EditorBrowsable(Never)]
        public float4 wzxy { get; set; }
        [EditorBrowsable(Never)]
        public float4 wzxz { get; }
        [EditorBrowsable(Never)]
        public float4 wzxw { get; }
        [EditorBrowsable(Never)]
        public float4 wzyx { get; set; }
        [EditorBrowsable(Never)]
        public float4 wzyy { get; }
        [EditorBrowsable(Never)]
        public float4 wzyz { get; }
        [EditorBrowsable(Never)]
        public float4 wzyw { get; }
        [EditorBrowsable(Never)]
        public float4 wzzx { get; }
        [EditorBrowsable(Never)]
        public float4 wzzy { get; }
        [EditorBrowsable(Never)]
        public float4 wzzz { get; }
        [EditorBrowsable(Never)]
        public float4 wzzw { get; }
        [EditorBrowsable(Never)]
        public float4 wzwx { get; }
        [EditorBrowsable(Never)]
        public float4 wzwy { get; }
        [EditorBrowsable(Never)]
        public float4 wzwz { get; }
        [EditorBrowsable(Never)]
        public float4 wzww { get; }
        [EditorBrowsable(Never)]
        public float4 wwxx { get; }
        [EditorBrowsable(Never)]
        public float4 wwxy { get; }
        [EditorBrowsable(Never)]
        public float4 wwxz { get; }
        [EditorBrowsable(Never)]
        public float4 wwxw { get; }
        [EditorBrowsable(Never)]
        public float4 wwyx { get; }
        [EditorBrowsable(Never)]
        public float4 wwyy { get; }
        [EditorBrowsable(Never)]
        public float4 wwyz { get; }
        [EditorBrowsable(Never)]
        public float4 wwyw { get; }
        [EditorBrowsable(Never)]
        public float4 wwzx { get; }
        [EditorBrowsable(Never)]
        public float4 wwzy { get; }
        [EditorBrowsable(Never)]
        public float4 wwzz { get; }
        [EditorBrowsable(Never)]
        public float4 wwzw { get; }
        [EditorBrowsable(Never)]
        public float4 wwwx { get; }
        [EditorBrowsable(Never)]
        public float4 wwwy { get; }
        [EditorBrowsable(Never)]
        public float4 wwwz { get; }
        [EditorBrowsable(Never)]
        public float4 wwww { get; }
        [EditorBrowsable(Never)]
        public float3 xxx { get; }
        [EditorBrowsable(Never)]
        public float3 xxy { get; }
        [EditorBrowsable(Never)]
        public float3 xxz { get; }
        [EditorBrowsable(Never)]
        public float3 xxw { get; }
        [EditorBrowsable(Never)]
        public float3 xyx { get; }
        [EditorBrowsable(Never)]
        public float3 xyy { get; }
        [EditorBrowsable(Never)]
        public float3 xyz { get; set; }
        [EditorBrowsable(Never)]
        public float3 xyw { get; set; }
        [EditorBrowsable(Never)]
        public float3 xzx { get; }
        [EditorBrowsable(Never)]
        public float3 xzy { get; set; }
        [EditorBrowsable(Never)]
        public float3 xzz { get; }
        [EditorBrowsable(Never)]
        public float3 xzw { get; set; }
        [EditorBrowsable(Never)]
        public float3 xwx { get; }
        [EditorBrowsable(Never)]
        public float3 xwy { get; set; }
        [EditorBrowsable(Never)]
        public float3 xwz { get; set; }
        [EditorBrowsable(Never)]
        public float3 xww { get; }
        [EditorBrowsable(Never)]
        public float3 yxx { get; }
        [EditorBrowsable(Never)]
        public float3 yxy { get; }
        [EditorBrowsable(Never)]
        public float3 yxz { get; set; }
        [EditorBrowsable(Never)]
        public float3 yxw { get; set; }
        [EditorBrowsable(Never)]
        public float3 yyx { get; }
        [EditorBrowsable(Never)]
        public float3 yyy { get; }
        [EditorBrowsable(Never)]
        public float3 yyz { get; }
        [EditorBrowsable(Never)]
        public float3 yyw { get; }
        [EditorBrowsable(Never)]
        public float3 yzx { get; set; }
        [EditorBrowsable(Never)]
        public float3 yzy { get; }
        [EditorBrowsable(Never)]
        public float3 yzz { get; }
        [EditorBrowsable(Never)]
        public float3 yzw { get; set; }
        [EditorBrowsable(Never)]
        public float3 ywx { get; set; }
        [EditorBrowsable(Never)]
        public float3 ywy { get; }
        [EditorBrowsable(Never)]
        public float3 ywz { get; set; }
        [EditorBrowsable(Never)]
        public float3 yww { get; }
        [EditorBrowsable(Never)]
        public float3 zxx { get; }
        [EditorBrowsable(Never)]
        public float3 zxy { get; set; }
        [EditorBrowsable(Never)]
        public float3 zxz { get; }
        [EditorBrowsable(Never)]
        public float3 zxw { get; set; }
        [EditorBrowsable(Never)]
        public float3 zyx { get; set; }
        [EditorBrowsable(Never)]
        public float3 zyy { get; }
        [EditorBrowsable(Never)]
        public float3 zyz { get; }
        [EditorBrowsable(Never)]
        public float3 zyw { get; set; }
        [EditorBrowsable(Never)]
        public float3 zzx { get; }
        [EditorBrowsable(Never)]
        public float3 zzy { get; }
        [EditorBrowsable(Never)]
        public float3 zzz { get; }
        [EditorBrowsable(Never)]
        public float3 zzw { get; }
        [EditorBrowsable(Never)]
        public float3 zwx { get; set; }
        [EditorBrowsable(Never)]
        public float3 zwy { get; set; }
        [EditorBrowsable(Never)]
        public float3 zwz { get; }
        [EditorBrowsable(Never)]
        public float3 zww { get; }
        [EditorBrowsable(Never)]
        public float3 wxx { get; }
        [EditorBrowsable(Never)]
        public float3 wxy { get; set; }
        [EditorBrowsable(Never)]
        public float3 wxz { get; set; }
        [EditorBrowsable(Never)]
        public float3 wxw { get; }
        [EditorBrowsable(Never)]
        public float3 wyx { get; set; }
        [EditorBrowsable(Never)]
        public float3 wyy { get; }
        [EditorBrowsable(Never)]
        public float3 wyz { get; set; }
        [EditorBrowsable(Never)]
        public float3 wyw { get; }
        [EditorBrowsable(Never)]
        public float3 wzx { get; set; }
        [EditorBrowsable(Never)]
        public float3 wzy { get; set; }
        [EditorBrowsable(Never)]
        public float3 wzz { get; }
        [EditorBrowsable(Never)]
        public float3 wzw { get; }
        [EditorBrowsable(Never)]
        public float3 wwx { get; }
        [EditorBrowsable(Never)]
        public float3 wwy { get; }
        [EditorBrowsable(Never)]
        public float3 wwz { get; }
        [EditorBrowsable(Never)]
        public float3 www { get; }
        [EditorBrowsable(Never)]
        public float2 xx { get; }
        [EditorBrowsable(Never)]
        public float2 xy { get; set; }
        [EditorBrowsable(Never)]
        public float2 xz { get; set; }
        [EditorBrowsable(Never)]
        public float2 xw { get; set; }
        [EditorBrowsable(Never)]
        public float2 yx { get; set; }
        [EditorBrowsable(Never)]
        public float2 yy { get; }
        [EditorBrowsable(Never)]
        public float2 yz { get; set; }
        [EditorBrowsable(Never)]
        public float2 yw { get; set; }
        [EditorBrowsable(Never)]
        public float2 zx { get; set; }
        [EditorBrowsable(Never)]
        public float2 zy { get; set; }
        [EditorBrowsable(Never)]
        public float2 zz { get; }
        [EditorBrowsable(Never)]
        public float2 zw { get; set; }
        [EditorBrowsable(Never)]
        public float2 wx { get; set; }
        [EditorBrowsable(Never)]
        public float2 wy { get; set; }
        [EditorBrowsable(Never)]
        public float2 wz { get; set; }
        [EditorBrowsable(Never)]
        public float2 ww { get; }

        public bool Equals(float4 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static float4 operator *(float4 lhs, float4 rhs);
        public static float4 operator *(float4 lhs, float rhs);
        public static float4 operator *(float lhs, float4 rhs);
        public static float4 operator +(float4 lhs, float4 rhs);
        public static float4 operator +(float4 lhs, float rhs);
        public static float4 operator +(float lhs, float4 rhs);
        public static float4 operator -(float4 lhs, float4 rhs);
        public static float4 operator -(float4 lhs, float rhs);
        public static float4 operator -(float lhs, float4 rhs);
        public static float4 operator /(float4 lhs, float4 rhs);
        public static float4 operator /(float4 lhs, float rhs);
        public static float4 operator /(float lhs, float4 rhs);
        public static float4 operator %(float4 lhs, float4 rhs);
        public static float4 operator %(float4 lhs, float rhs);
        public static float4 operator %(float lhs, float4 rhs);
        public static float4 operator ++(float4 val);
        public static float4 operator --(float4 val);
        public static bool4 operator <(float4 lhs, float4 rhs);
        public static bool4 operator <(float4 lhs, float rhs);
        public static bool4 operator <(float lhs, float4 rhs);
        public static bool4 operator <=(float4 lhs, float4 rhs);
        public static bool4 operator <=(float4 lhs, float rhs);
        public static bool4 operator <=(float lhs, float4 rhs);
        public static bool4 operator >(float4 lhs, float4 rhs);
        public static bool4 operator >(float4 lhs, float rhs);
        public static bool4 operator >(float lhs, float4 rhs);
        public static bool4 operator >=(float4 lhs, float4 rhs);
        public static bool4 operator >=(float4 lhs, float rhs);
        public static bool4 operator >=(float lhs, float4 rhs);
        public static float4 operator -(float4 val);
        public static float4 operator +(float4 val);
        public static bool4 operator ==(float4 lhs, float4 rhs);
        public static bool4 operator ==(float4 lhs, float rhs);
        public static bool4 operator ==(float lhs, float4 rhs);
        public static bool4 operator !=(float4 lhs, float4 rhs);
        public static bool4 operator !=(float4 lhs, float rhs);
        public static bool4 operator !=(float lhs, float4 rhs);

        public static implicit operator float4(float v);
        public static explicit operator float4(bool v);
        public static explicit operator float4(bool4 v);
        public static implicit operator float4(int v);
        public static implicit operator float4(int4 v);
        public static implicit operator float4(uint v);
        public static implicit operator float4(uint4 v);
        public static implicit operator float4(half v);
        public static implicit operator float4(half4 v);
        public static explicit operator float4(double v);
        public static explicit operator float4(double4 v);
        public static implicit operator float4(Vector4 v);
        public static implicit operator Vector4(float4 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct float4x2 : IEquatable<float4x2>, IFormattable
    {
        public float4 c0;
        public float4 c1;
        public static readonly float4x2 zero;

        public float4x2(float4 c0, float4 c1);
        public float4x2(float m00, float m01, float m10, float m11, float m20, float m21, float m30, float m31);
        public float4x2(float v);
        public float4x2(bool v);
        public float4x2(bool4x2 v);
        public float4x2(int v);
        public float4x2(int4x2 v);
        public float4x2(uint v);
        public float4x2(uint4x2 v);
        public float4x2(double v);
        public float4x2(double4x2 v);

        public ref float4 this[int index] { get; }

        public bool Equals(float4x2 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static float4x2 operator *(float4x2 lhs, float4x2 rhs);
        public static float4x2 operator *(float4x2 lhs, float rhs);
        public static float4x2 operator *(float lhs, float4x2 rhs);
        public static float4x2 operator +(float4x2 lhs, float4x2 rhs);
        public static float4x2 operator +(float4x2 lhs, float rhs);
        public static float4x2 operator +(float lhs, float4x2 rhs);
        public static float4x2 operator -(float4x2 lhs, float4x2 rhs);
        public static float4x2 operator -(float4x2 lhs, float rhs);
        public static float4x2 operator -(float lhs, float4x2 rhs);
        public static float4x2 operator /(float4x2 lhs, float4x2 rhs);
        public static float4x2 operator /(float4x2 lhs, float rhs);
        public static float4x2 operator /(float lhs, float4x2 rhs);
        public static float4x2 operator %(float4x2 lhs, float4x2 rhs);
        public static float4x2 operator %(float4x2 lhs, float rhs);
        public static float4x2 operator %(float lhs, float4x2 rhs);
        public static float4x2 operator ++(float4x2 val);
        public static float4x2 operator --(float4x2 val);
        public static bool4x2 operator <(float4x2 lhs, float4x2 rhs);
        public static bool4x2 operator <(float4x2 lhs, float rhs);
        public static bool4x2 operator <(float lhs, float4x2 rhs);
        public static bool4x2 operator <=(float4x2 lhs, float4x2 rhs);
        public static bool4x2 operator <=(float4x2 lhs, float rhs);
        public static bool4x2 operator <=(float lhs, float4x2 rhs);
        public static bool4x2 operator >(float4x2 lhs, float4x2 rhs);
        public static bool4x2 operator >(float4x2 lhs, float rhs);
        public static bool4x2 operator >(float lhs, float4x2 rhs);
        public static bool4x2 operator >=(float4x2 lhs, float4x2 rhs);
        public static bool4x2 operator >=(float4x2 lhs, float rhs);
        public static bool4x2 operator >=(float lhs, float4x2 rhs);
        public static float4x2 operator -(float4x2 val);
        public static float4x2 operator +(float4x2 val);
        public static bool4x2 operator ==(float4x2 lhs, float4x2 rhs);
        public static bool4x2 operator ==(float4x2 lhs, float rhs);
        public static bool4x2 operator ==(float lhs, float4x2 rhs);
        public static bool4x2 operator !=(float4x2 lhs, float4x2 rhs);
        public static bool4x2 operator !=(float4x2 lhs, float rhs);
        public static bool4x2 operator !=(float lhs, float4x2 rhs);

        public static implicit operator float4x2(float v);
        public static explicit operator float4x2(bool v);
        public static explicit operator float4x2(bool4x2 v);
        public static implicit operator float4x2(int v);
        public static implicit operator float4x2(int4x2 v);
        public static implicit operator float4x2(uint v);
        public static implicit operator float4x2(uint4x2 v);
        public static explicit operator float4x2(double v);
        public static explicit operator float4x2(double4x2 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct float4x3 : IEquatable<float4x3>, IFormattable
    {
        public float4 c0;
        public float4 c1;
        public float4 c2;
        public static readonly float4x3 zero;

        public float4x3(float4 c0, float4 c1, float4 c2);
        public float4x3(float m00, float m01, float m02, float m10, float m11, float m12, float m20, float m21, float m22, float m30, float m31, float m32);
        public float4x3(float v);
        public float4x3(bool v);
        public float4x3(bool4x3 v);
        public float4x3(int v);
        public float4x3(int4x3 v);
        public float4x3(uint v);
        public float4x3(uint4x3 v);
        public float4x3(double v);
        public float4x3(double4x3 v);

        public ref float4 this[int index] { get; }

        public bool Equals(float4x3 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static float4x3 operator *(float4x3 lhs, float4x3 rhs);
        public static float4x3 operator *(float4x3 lhs, float rhs);
        public static float4x3 operator *(float lhs, float4x3 rhs);
        public static float4x3 operator +(float4x3 lhs, float4x3 rhs);
        public static float4x3 operator +(float4x3 lhs, float rhs);
        public static float4x3 operator +(float lhs, float4x3 rhs);
        public static float4x3 operator -(float4x3 lhs, float4x3 rhs);
        public static float4x3 operator -(float4x3 lhs, float rhs);
        public static float4x3 operator -(float lhs, float4x3 rhs);
        public static float4x3 operator /(float4x3 lhs, float4x3 rhs);
        public static float4x3 operator /(float4x3 lhs, float rhs);
        public static float4x3 operator /(float lhs, float4x3 rhs);
        public static float4x3 operator %(float4x3 lhs, float4x3 rhs);
        public static float4x3 operator %(float4x3 lhs, float rhs);
        public static float4x3 operator %(float lhs, float4x3 rhs);
        public static float4x3 operator ++(float4x3 val);
        public static float4x3 operator --(float4x3 val);
        public static bool4x3 operator <(float4x3 lhs, float4x3 rhs);
        public static bool4x3 operator <(float4x3 lhs, float rhs);
        public static bool4x3 operator <(float lhs, float4x3 rhs);
        public static bool4x3 operator <=(float4x3 lhs, float4x3 rhs);
        public static bool4x3 operator <=(float4x3 lhs, float rhs);
        public static bool4x3 operator <=(float lhs, float4x3 rhs);
        public static bool4x3 operator >(float4x3 lhs, float4x3 rhs);
        public static bool4x3 operator >(float4x3 lhs, float rhs);
        public static bool4x3 operator >(float lhs, float4x3 rhs);
        public static bool4x3 operator >=(float4x3 lhs, float4x3 rhs);
        public static bool4x3 operator >=(float4x3 lhs, float rhs);
        public static bool4x3 operator >=(float lhs, float4x3 rhs);
        public static float4x3 operator -(float4x3 val);
        public static float4x3 operator +(float4x3 val);
        public static bool4x3 operator ==(float4x3 lhs, float4x3 rhs);
        public static bool4x3 operator ==(float4x3 lhs, float rhs);
        public static bool4x3 operator ==(float lhs, float4x3 rhs);
        public static bool4x3 operator !=(float4x3 lhs, float4x3 rhs);
        public static bool4x3 operator !=(float4x3 lhs, float rhs);
        public static bool4x3 operator !=(float lhs, float4x3 rhs);

        public static implicit operator float4x3(float v);
        public static explicit operator float4x3(bool v);
        public static explicit operator float4x3(bool4x3 v);
        public static implicit operator float4x3(int v);
        public static implicit operator float4x3(int4x3 v);
        public static implicit operator float4x3(uint v);
        public static implicit operator float4x3(uint4x3 v);
        public static explicit operator float4x3(double v);
        public static explicit operator float4x3(double4x3 v);
    }
}
using System;
using System.Reflection;
using UnityEngine;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct float4x4 : IEquatable<float4x4>, IFormattable
    {
        public float4 c0;
        public float4 c1;
        public float4 c2;
        public float4 c3;
        public static readonly float4x4 identity;
        public static readonly float4x4 zero;

        public float4x4(float4 c0, float4 c1, float4 c2, float4 c3);
        public float4x4(float m00, float m01, float m02, float m03, float m10, float m11, float m12, float m13, float m20, float m21, float m22, float m23, float m30, float m31, float m32, float m33);
        public float4x4(float v);
        public float4x4(bool v);
        public float4x4(bool4x4 v);
        public float4x4(int v);
        public float4x4(int4x4 v);
        public float4x4(uint v);
        public float4x4(uint4x4 v);
        public float4x4(double v);
        public float4x4(double4x4 v);
        public float4x4(float3x3 rotation, float3 translation);
        public float4x4(quaternion rotation, float3 translation);
        public float4x4(RigidTransform transform);

        public ref float4 this[int index] { get; }

        public bool Equals(float4x4 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);
        public static float4x4 AxisAngle(float3 axis, float angle);
        public static float4x4 EulerXYZ(float3 xyz);
        public static float4x4 EulerXZY(float3 xyz);
        public static float4x4 EulerYXZ(float3 xyz);
        public static float4x4 EulerYZX(float3 xyz);
        public static float4x4 EulerZXY(float3 xyz);
        public static float4x4 EulerZYX(float3 xyz);
        public static float4x4 EulerXYZ(float x, float y, float z);
        public static float4x4 EulerXZY(float x, float y, float z);
        public static float4x4 EulerYXZ(float x, float y, float z);
        public static float4x4 EulerYZX(float x, float y, float z);
        public static float4x4 EulerZXY(float x, float y, float z);
        public static float4x4 EulerZYX(float x, float y, float z);
        public static float4x4 Euler(float3 xyz, math.RotationOrder order = Default);
        public static float4x4 Euler(float x, float y, float z, math.RotationOrder order = Default);
        public static float4x4 RotateX(float angle);
        public static float4x4 RotateY(float angle);
        public static float4x4 RotateZ(float angle);
        public static float4x4 Scale(float s);
        public static float4x4 Scale(float x, float y, float z);
        public static float4x4 Scale(float3 scales);
        public static float4x4 Translate(float3 vector);
        public static float4x4 LookAt(float3 eye, float3 target, float3 up);
        public static float4x4 Ortho(float width, float height, float near, float far);
        public static float4x4 OrthoOffCenter(float left, float right, float bottom, float top, float near, float far);
        public static float4x4 PerspectiveFov(float verticalFov, float aspect, float near, float far);
        public static float4x4 PerspectiveOffCenter(float left, float right, float bottom, float top, float near, float far);
        public static float4x4 TRS(float3 translation, quaternion rotation, float3 scale);

        public static float4x4 operator *(float4x4 lhs, float4x4 rhs);
        public static float4x4 operator *(float4x4 lhs, float rhs);
        public static float4x4 operator *(float lhs, float4x4 rhs);
        public static float4x4 operator +(float4x4 lhs, float4x4 rhs);
        public static float4x4 operator +(float4x4 lhs, float rhs);
        public static float4x4 operator +(float lhs, float4x4 rhs);
        public static float4x4 operator -(float4x4 lhs, float4x4 rhs);
        public static float4x4 operator -(float4x4 lhs, float rhs);
        public static float4x4 operator -(float lhs, float4x4 rhs);
        public static float4x4 operator /(float4x4 lhs, float4x4 rhs);
        public static float4x4 operator /(float4x4 lhs, float rhs);
        public static float4x4 operator /(float lhs, float4x4 rhs);
        public static float4x4 operator %(float4x4 lhs, float4x4 rhs);
        public static float4x4 operator %(float4x4 lhs, float rhs);
        public static float4x4 operator %(float lhs, float4x4 rhs);
        public static float4x4 operator ++(float4x4 val);
        public static float4x4 operator --(float4x4 val);
        public static bool4x4 operator <(float4x4 lhs, float4x4 rhs);
        public static bool4x4 operator <(float4x4 lhs, float rhs);
        public static bool4x4 operator <(float lhs, float4x4 rhs);
        public static bool4x4 operator <=(float4x4 lhs, float4x4 rhs);
        public static bool4x4 operator <=(float4x4 lhs, float rhs);
        public static bool4x4 operator <=(float lhs, float4x4 rhs);
        public static bool4x4 operator >(float4x4 lhs, float4x4 rhs);
        public static bool4x4 operator >(float4x4 lhs, float rhs);
        public static bool4x4 operator >(float lhs, float4x4 rhs);
        public static bool4x4 operator >=(float4x4 lhs, float4x4 rhs);
        public static bool4x4 operator >=(float4x4 lhs, float rhs);
        public static bool4x4 operator >=(float lhs, float4x4 rhs);
        public static float4x4 operator -(float4x4 val);
        public static float4x4 operator +(float4x4 val);
        public static bool4x4 operator ==(float4x4 lhs, float4x4 rhs);
        public static bool4x4 operator ==(float4x4 lhs, float rhs);
        public static bool4x4 operator ==(float lhs, float4x4 rhs);
        public static bool4x4 operator !=(float4x4 lhs, float4x4 rhs);
        public static bool4x4 operator !=(float4x4 lhs, float rhs);
        public static bool4x4 operator !=(float lhs, float4x4 rhs);

        public static implicit operator float4x4(float v);
        public static explicit operator float4x4(bool v);
        public static explicit operator float4x4(bool4x4 v);
        public static implicit operator float4x4(int v);
        public static implicit operator float4x4(int4x4 v);
        public static implicit operator float4x4(uint v);
        public static implicit operator float4x4(uint4x4 v);
        public static explicit operator float4x4(double v);
        public static explicit operator float4x4(double4x4 v);
        public static implicit operator float4x4(Matrix4x4 m);
        public static implicit operator Matrix4x4(float4x4 m);
    }
}
using System;

namespace Unity.Mathematics
{
    public struct half : IEquatable<half>, IFormattable
    {
        public ushort value;
        public static readonly half zero;

        public half(half x);
        public half(float v);
        public half(double v);

        public static float MaxValue { get; }
        public static float MinValue { get; }

        public bool Equals(half rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static bool operator ==(half lhs, half rhs);
        public static bool operator !=(half lhs, half rhs);

        public static explicit operator half(float v);
        public static explicit operator half(double v);
        public static implicit operator float(half d);
        public static implicit operator double(half d);
    }
}
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    [DebuggerTypeProxy(typeof(DebuggerProxy))]
    public struct half2 : IEquatable<half2>, IFormattable
    {
        public half x;
        public half y;
        public static readonly half2 zero;

        public half2(half x, half y);
        public half2(half2 xy);
        public half2(half v);
        public half2(float v);
        public half2(float2 v);
        public half2(double v);
        public half2(double2 v);

        public half this[int index] { get; set; }
        [EditorBrowsable(Never)]
        public half4 xxxx { get; }
        [EditorBrowsable(Never)]
        public half4 xxxy { get; }
        [EditorBrowsable(Never)]
        public half4 xxyx { get; }
        [EditorBrowsable(Never)]
        public half4 xxyy { get; }
        [EditorBrowsable(Never)]
        public half4 xyxx { get; }
        [EditorBrowsable(Never)]
        public half4 xyxy { get; }
        [EditorBrowsable(Never)]
        public half4 xyyx { get; }
        [EditorBrowsable(Never)]
        public half4 xyyy { get; }
        [EditorBrowsable(Never)]
        public half4 yxxx { get; }
        [EditorBrowsable(Never)]
        public half4 yxxy { get; }
        [EditorBrowsable(Never)]
        public half4 yxyx { get; }
        [EditorBrowsable(Never)]
        public half4 yxyy { get; }
        [EditorBrowsable(Never)]
        public half4 yyxx { get; }
        [EditorBrowsable(Never)]
        public half4 yyxy { get; }
        [EditorBrowsable(Never)]
        public half4 yyyx { get; }
        [EditorBrowsable(Never)]
        public half4 yyyy { get; }
        [EditorBrowsable(Never)]
        public half3 xxx { get; }
        [EditorBrowsable(Never)]
        public half3 xxy { get; }
        [EditorBrowsable(Never)]
        public half3 xyx { get; }
        [EditorBrowsable(Never)]
        public half3 xyy { get; }
        [EditorBrowsable(Never)]
        public half3 yxx { get; }
        [EditorBrowsable(Never)]
        public half3 yxy { get; }
        [EditorBrowsable(Never)]
        public half3 yyx { get; }
        [EditorBrowsable(Never)]
        public half3 yyy { get; }
        [EditorBrowsable(Never)]
        public half2 xx { get; }
        [EditorBrowsable(Never)]
        public half2 xy { get; set; }
        [EditorBrowsable(Never)]
        public half2 yx { get; set; }
        [EditorBrowsable(Never)]
        public half2 yy { get; }

        public bool Equals(half2 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static bool2 operator ==(half2 lhs, half2 rhs);
        public static bool2 operator ==(half2 lhs, half rhs);
        public static bool2 operator ==(half lhs, half2 rhs);
        public static bool2 operator !=(half2 lhs, half2 rhs);
        public static bool2 operator !=(half2 lhs, half rhs);
        public static bool2 operator !=(half lhs, half2 rhs);

        public static implicit operator half2(half v);
        public static explicit operator half2(float v);
        public static explicit operator half2(float2 v);
        public static explicit operator half2(double v);
        public static explicit operator half2(double2 v);
    }
}
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    [DebuggerTypeProxy(typeof(DebuggerProxy))]
    public struct half3 : IEquatable<half3>, IFormattable
    {
        public half x;
        public half y;
        public half z;
        public static readonly half3 zero;

        public half3(half x, half y, half z);
        public half3(half x, half2 yz);
        public half3(half2 xy, half z);
        public half3(half3 xyz);
        public half3(half v);
        public half3(float v);
        public half3(float3 v);
        public half3(double v);
        public half3(double3 v);

        public half this[int index] { get; set; }
        [EditorBrowsable(Never)]
        public half4 xxxx { get; }
        [EditorBrowsable(Never)]
        public half4 xxxy { get; }
        [EditorBrowsable(Never)]
        public half4 xxxz { get; }
        [EditorBrowsable(Never)]
        public half4 xxyx { get; }
        [EditorBrowsable(Never)]
        public half4 xxyy { get; }
        [EditorBrowsable(Never)]
        public half4 xxyz { get; }
        [EditorBrowsable(Never)]
        public half4 xxzx { get; }
        [EditorBrowsable(Never)]
        public half4 xxzy { get; }
        [EditorBrowsable(Never)]
        public half4 xxzz { get; }
        [EditorBrowsable(Never)]
        public half4 xyxx { get; }
        [EditorBrowsable(Never)]
        public half4 xyxy { get; }
        [EditorBrowsable(Never)]
        public half4 xyxz { get; }
        [EditorBrowsable(Never)]
        public half4 xyyx { get; }
        [EditorBrowsable(Never)]
        public half4 xyyy { get; }
        [EditorBrowsable(Never)]
        public half4 xyyz { get; }
        [EditorBrowsable(Never)]
        public half4 xyzx { get; }
        [EditorBrowsable(Never)]
        public half4 xyzy { get; }
        [EditorBrowsable(Never)]
        public half4 xyzz { get; }
        [EditorBrowsable(Never)]
        public half4 xzxx { get; }
        [EditorBrowsable(Never)]
        public half4 xzxy { get; }
        [EditorBrowsable(Never)]
        public half4 xzxz { get; }
        [EditorBrowsable(Never)]
        public half4 xzyx { get; }
        [EditorBrowsable(Never)]
        public half4 xzyy { get; }
        [EditorBrowsable(Never)]
        public half4 xzyz { get; }
        [EditorBrowsable(Never)]
        public half4 xzzx { get; }
        [EditorBrowsable(Never)]
        public half4 xzzy { get; }
        [EditorBrowsable(Never)]
        public half4 xzzz { get; }
        [EditorBrowsable(Never)]
        public half4 yxxx { get; }
        [EditorBrowsable(Never)]
        public half4 yxxy { get; }
        [EditorBrowsable(Never)]
        public half4 yxxz { get; }
        [EditorBrowsable(Never)]
        public half4 yxyx { get; }
        [EditorBrowsable(Never)]
        public half4 yxyy { get; }
        [EditorBrowsable(Never)]
        public half4 yxyz { get; }
        [EditorBrowsable(Never)]
        public half4 yxzx { get; }
        [EditorBrowsable(Never)]
        public half4 yxzy { get; }
        [EditorBrowsable(Never)]
        public half4 yxzz { get; }
        [EditorBrowsable(Never)]
        public half4 yyxx { get; }
        [EditorBrowsable(Never)]
        public half4 yyxy { get; }
        [EditorBrowsable(Never)]
        public half4 yyxz { get; }
        [EditorBrowsable(Never)]
        public half4 yyyx { get; }
        [EditorBrowsable(Never)]
        public half4 yyyy { get; }
        [EditorBrowsable(Never)]
        public half4 yyyz { get; }
        [EditorBrowsable(Never)]
        public half4 yyzx { get; }
        [EditorBrowsable(Never)]
        public half4 yyzy { get; }
        [EditorBrowsable(Never)]
        public half4 yyzz { get; }
        [EditorBrowsable(Never)]
        public half4 yzxx { get; }
        [EditorBrowsable(Never)]
        public half4 yzxy { get; }
        [EditorBrowsable(Never)]
        public half4 yzxz { get; }
        [EditorBrowsable(Never)]
        public half4 yzyx { get; }
        [EditorBrowsable(Never)]
        public half4 yzyy { get; }
        [EditorBrowsable(Never)]
        public half4 yzyz { get; }
        [EditorBrowsable(Never)]
        public half4 yzzx { get; }
        [EditorBrowsable(Never)]
        public half4 yzzy { get; }
        [EditorBrowsable(Never)]
        public half4 yzzz { get; }
        [EditorBrowsable(Never)]
        public half4 zxxx { get; }
        [EditorBrowsable(Never)]
        public half4 zxxy { get; }
        [EditorBrowsable(Never)]
        public half4 zxxz { get; }
        [EditorBrowsable(Never)]
        public half4 zxyx { get; }
        [EditorBrowsable(Never)]
        public half4 zxyy { get; }
        [EditorBrowsable(Never)]
        public half4 zxyz { get; }
        [EditorBrowsable(Never)]
        public half4 zxzx { get; }
        [EditorBrowsable(Never)]
        public half4 zxzy { get; }
        [EditorBrowsable(Never)]
        public half4 zxzz { get; }
        [EditorBrowsable(Never)]
        public half4 zyxx { get; }
        [EditorBrowsable(Never)]
        public half4 zyxy { get; }
        [EditorBrowsable(Never)]
        public half4 zyxz { get; }
        [EditorBrowsable(Never)]
        public half4 zyyx { get; }
        [EditorBrowsable(Never)]
        public half4 zyyy { get; }
        [EditorBrowsable(Never)]
        public half4 zyyz { get; }
        [EditorBrowsable(Never)]
        public half4 zyzx { get; }
        [EditorBrowsable(Never)]
        public half4 zyzy { get; }
        [EditorBrowsable(Never)]
        public half4 zyzz { get; }
        [EditorBrowsable(Never)]
        public half4 zzxx { get; }
        [EditorBrowsable(Never)]
        public half4 zzxy { get; }
        [EditorBrowsable(Never)]
        public half4 zzxz { get; }
        [EditorBrowsable(Never)]
        public half4 zzyx { get; }
        [EditorBrowsable(Never)]
        public half4 zzyy { get; }
        [EditorBrowsable(Never)]
        public half4 zzyz { get; }
        [EditorBrowsable(Never)]
        public half4 zzzx { get; }
        [EditorBrowsable(Never)]
        public half4 zzzy { get; }
        [EditorBrowsable(Never)]
        public half4 zzzz { get; }
        [EditorBrowsable(Never)]
        public half3 xxx { get; }
        [EditorBrowsable(Never)]
        public half3 xxy { get; }
        [EditorBrowsable(Never)]
        public half3 xxz { get; }
        [EditorBrowsable(Never)]
        public half3 xyx { get; }
        [EditorBrowsable(Never)]
        public half3 xyy { get; }
        [EditorBrowsable(Never)]
        public half3 xyz { get; set; }
        [EditorBrowsable(Never)]
        public half3 xzx { get; }
        [EditorBrowsable(Never)]
        public half3 xzy { get; set; }
        [EditorBrowsable(Never)]
        public half3 xzz { get; }
        [EditorBrowsable(Never)]
        public half3 yxx { get; }
        [EditorBrowsable(Never)]
        public half3 yxy { get; }
        [EditorBrowsable(Never)]
        public half3 yxz { get; set; }
        [EditorBrowsable(Never)]
        public half3 yyx { get; }
        [EditorBrowsable(Never)]
        public half3 yyy { get; }
        [EditorBrowsable(Never)]
        public half3 yyz { get; }
        [EditorBrowsable(Never)]
        public half3 yzx { get; set; }
        [EditorBrowsable(Never)]
        public half3 yzy { get; }
        [EditorBrowsable(Never)]
        public half3 yzz { get; }
        [EditorBrowsable(Never)]
        public half3 zxx { get; }
        [EditorBrowsable(Never)]
        public half3 zxy { get; set; }
        [EditorBrowsable(Never)]
        public half3 zxz { get; }
        [EditorBrowsable(Never)]
        public half3 zyx { get; set; }
        [EditorBrowsable(Never)]
        public half3 zyy { get; }
        [EditorBrowsable(Never)]
        public half3 zyz { get; }
        [EditorBrowsable(Never)]
        public half3 zzx { get; }
        [EditorBrowsable(Never)]
        public half3 zzy { get; }
        [EditorBrowsable(Never)]
        public half3 zzz { get; }
        [EditorBrowsable(Never)]
        public half2 xx { get; }
        [EditorBrowsable(Never)]
        public half2 xy { get; set; }
        [EditorBrowsable(Never)]
        public half2 xz { get; set; }
        [EditorBrowsable(Never)]
        public half2 yx { get; set; }
        [EditorBrowsable(Never)]
        public half2 yy { get; }
        [EditorBrowsable(Never)]
        public half2 yz { get; set; }
        [EditorBrowsable(Never)]
        public half2 zx { get; set; }
        [EditorBrowsable(Never)]
        public half2 zy { get; set; }
        [EditorBrowsable(Never)]
        public half2 zz { get; }

        public bool Equals(half3 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static bool3 operator ==(half3 lhs, half3 rhs);
        public static bool3 operator ==(half3 lhs, half rhs);
        public static bool3 operator ==(half lhs, half3 rhs);
        public static bool3 operator !=(half3 lhs, half3 rhs);
        public static bool3 operator !=(half3 lhs, half rhs);
        public static bool3 operator !=(half lhs, half3 rhs);

        public static implicit operator half3(half v);
        public static explicit operator half3(float v);
        public static explicit operator half3(float3 v);
        public static explicit operator half3(double v);
        public static explicit operator half3(double3 v);
    }
}
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    [DebuggerTypeProxy(typeof(DebuggerProxy))]
    public struct half4 : IEquatable<half4>, IFormattable
    {
        public half x;
        public half y;
        public half z;
        public half w;
        public static readonly half4 zero;

        public half4(half x, half y, half z, half w);
        public half4(half x, half y, half2 zw);
        public half4(half x, half2 yz, half w);
        public half4(half x, half3 yzw);
        public half4(half2 xy, half z, half w);
        public half4(half2 xy, half2 zw);
        public half4(half3 xyz, half w);
        public half4(half4 xyzw);
        public half4(half v);
        public half4(float v);
        public half4(float4 v);
        public half4(double v);
        public half4(double4 v);

        public half this[int index] { get; set; }
        [EditorBrowsable(Never)]
        public half4 xxxx { get; }
        [EditorBrowsable(Never)]
        public half4 xxxy { get; }
        [EditorBrowsable(Never)]
        public half4 xxxz { get; }
        [EditorBrowsable(Never)]
        public half4 xxxw { get; }
        [EditorBrowsable(Never)]
        public half4 xxyx { get; }
        [EditorBrowsable(Never)]
        public half4 xxyy { get; }
        [EditorBrowsable(Never)]
        public half4 xxyz { get; }
        [EditorBrowsable(Never)]
        public half4 xxyw { get; }
        [EditorBrowsable(Never)]
        public half4 xxzx { get; }
        [EditorBrowsable(Never)]
        public half4 xxzy { get; }
        [EditorBrowsable(Never)]
        public half4 xxzz { get; }
        [EditorBrowsable(Never)]
        public half4 xxzw { get; }
        [EditorBrowsable(Never)]
        public half4 xxwx { get; }
        [EditorBrowsable(Never)]
        public half4 xxwy { get; }
        [EditorBrowsable(Never)]
        public half4 xxwz { get; }
        [EditorBrowsable(Never)]
        public half4 xxww { get; }
        [EditorBrowsable(Never)]
        public half4 xyxx { get; }
        [EditorBrowsable(Never)]
        public half4 xyxy { get; }
        [EditorBrowsable(Never)]
        public half4 xyxz { get; }
        [EditorBrowsable(Never)]
        public half4 xyxw { get; }
        [EditorBrowsable(Never)]
        public half4 xyyx { get; }
        [EditorBrowsable(Never)]
        public half4 xyyy { get; }
        [EditorBrowsable(Never)]
        public half4 xyyz { get; }
        [EditorBrowsable(Never)]
        public half4 xyyw { get; }
        [EditorBrowsable(Never)]
        public half4 xyzx { get; }
        [EditorBrowsable(Never)]
        public half4 xyzy { get; }
        [EditorBrowsable(Never)]
        public half4 xyzz { get; }
        [EditorBrowsable(Never)]
        public half4 xyzw { get; set; }
        [EditorBrowsable(Never)]
        public half4 xywx { get; }
        [EditorBrowsable(Never)]
        public half4 xywy { get; }
        [EditorBrowsable(Never)]
        public half4 xywz { get; set; }
        [EditorBrowsable(Never)]
        public half4 xyww { get; }
        [EditorBrowsable(Never)]
        public half4 xzxx { get; }
        [EditorBrowsable(Never)]
        public half4 xzxy { get; }
        [EditorBrowsable(Never)]
        public half4 xzxz { get; }
        [EditorBrowsable(Never)]
        public half4 xzxw { get; }
        [EditorBrowsable(Never)]
        public half4 xzyx { get; }
        [EditorBrowsable(Never)]
        public half4 xzyy { get; }
        [EditorBrowsable(Never)]
        public half4 xzyz { get; }
        [EditorBrowsable(Never)]
        public half4 xzyw { get; set; }
        [EditorBrowsable(Never)]
        public half4 xzzx { get; }
        [EditorBrowsable(Never)]
        public half4 xzzy { get; }
        [EditorBrowsable(Never)]
        public half4 xzzz { get; }
        [EditorBrowsable(Never)]
        public half4 xzzw { get; }
        [EditorBrowsable(Never)]
        public half4 xzwx { get; }
        [EditorBrowsable(Never)]
        public half4 xzwy { get; set; }
        [EditorBrowsable(Never)]
        public half4 xzwz { get; }
        [EditorBrowsable(Never)]
        public half4 xzww { get; }
        [EditorBrowsable(Never)]
        public half4 xwxx { get; }
        [EditorBrowsable(Never)]
        public half4 xwxy { get; }
        [EditorBrowsable(Never)]
        public half4 xwxz { get; }
        [EditorBrowsable(Never)]
        public half4 xwxw { get; }
        [EditorBrowsable(Never)]
        public half4 xwyx { get; }
        [EditorBrowsable(Never)]
        public half4 xwyy { get; }
        [EditorBrowsable(Never)]
        public half4 xwyz { get; set; }
        [EditorBrowsable(Never)]
        public half4 xwyw { get; }
        [EditorBrowsable(Never)]
        public half4 xwzx { get; }
        [EditorBrowsable(Never)]
        public half4 xwzy { get; set; }
        [EditorBrowsable(Never)]
        public half4 xwzz { get; }
        [EditorBrowsable(Never)]
        public half4 xwzw { get; }
        [EditorBrowsable(Never)]
        public half4 xwwx { get; }
        [EditorBrowsable(Never)]
        public half4 xwwy { get; }
        [EditorBrowsable(Never)]
        public half4 xwwz { get; }
        [EditorBrowsable(Never)]
        public half4 xwww { get; }
        [EditorBrowsable(Never)]
        public half4 yxxx { get; }
        [EditorBrowsable(Never)]
        public half4 yxxy { get; }
        [EditorBrowsable(Never)]
        public half4 yxxz { get; }
        [EditorBrowsable(Never)]
        public half4 yxxw { get; }
        [EditorBrowsable(Never)]
        public half4 yxyx { get; }
        [EditorBrowsable(Never)]
        public half4 yxyy { get; }
        [EditorBrowsable(Never)]
        public half4 yxyz { get; }
        [EditorBrowsable(Never)]
        public half4 yxyw { get; }
        [EditorBrowsable(Never)]
        public half4 yxzx { get; }
        [EditorBrowsable(Never)]
        public half4 yxzy { get; }
        [EditorBrowsable(Never)]
        public half4 yxzz { get; }
        [EditorBrowsable(Never)]
        public half4 yxzw { get; set; }
        [EditorBrowsable(Never)]
        public half4 yxwx { get; }
        [EditorBrowsable(Never)]
        public half4 yxwy { get; }
        [EditorBrowsable(Never)]
        public half4 yxwz { get; set; }
        [EditorBrowsable(Never)]
        public half4 yxww { get; }
        [EditorBrowsable(Never)]
        public half4 yyxx { get; }
        [EditorBrowsable(Never)]
        public half4 yyxy { get; }
        [EditorBrowsable(Never)]
        public half4 yyxz { get; }
        [EditorBrowsable(Never)]
        public half4 yyxw { get; }
        [EditorBrowsable(Never)]
        public half4 yyyx { get; }
        [EditorBrowsable(Never)]
        public half4 yyyy { get; }
        [EditorBrowsable(Never)]
        public half4 yyyz { get; }
        [EditorBrowsable(Never)]
        public half4 yyyw { get; }
        [EditorBrowsable(Never)]
        public half4 yyzx { get; }
        [EditorBrowsable(Never)]
        public half4 yyzy { get; }
        [EditorBrowsable(Never)]
        public half4 yyzz { get; }
        [EditorBrowsable(Never)]
        public half4 yyzw { get; }
        [EditorBrowsable(Never)]
        public half4 yywx { get; }
        [EditorBrowsable(Never)]
        public half4 yywy { get; }
        [EditorBrowsable(Never)]
        public half4 yywz { get; }
        [EditorBrowsable(Never)]
        public half4 yyww { get; }
        [EditorBrowsable(Never)]
        public half4 yzxx { get; }
        [EditorBrowsable(Never)]
        public half4 yzxy { get; }
        [EditorBrowsable(Never)]
        public half4 yzxz { get; }
        [EditorBrowsable(Never)]
        public half4 yzxw { get; set; }
        [EditorBrowsable(Never)]
        public half4 yzyx { get; }
        [EditorBrowsable(Never)]
        public half4 yzyy { get; }
        [EditorBrowsable(Never)]
        public half4 yzyz { get; }
        [EditorBrowsable(Never)]
        public half4 yzyw { get; }
        [EditorBrowsable(Never)]
        public half4 yzzx { get; }
        [EditorBrowsable(Never)]
        public half4 yzzy { get; }
        [EditorBrowsable(Never)]
        public half4 yzzz { get; }
        [EditorBrowsable(Never)]
        public half4 yzzw { get; }
        [EditorBrowsable(Never)]
        public half4 yzwx { get; set; }
        [EditorBrowsable(Never)]
        public half4 yzwy { get; }
        [EditorBrowsable(Never)]
        public half4 yzwz { get; }
        [EditorBrowsable(Never)]
        public half4 yzww { get; }
        [EditorBrowsable(Never)]
        public half4 ywxx { get; }
        [EditorBrowsable(Never)]
        public half4 ywxy { get; }
        [EditorBrowsable(Never)]
        public half4 ywxz { get; set; }
        [EditorBrowsable(Never)]
        public half4 ywxw { get; }
        [EditorBrowsable(Never)]
        public half4 ywyx { get; }
        [EditorBrowsable(Never)]
        public half4 ywyy { get; }
        [EditorBrowsable(Never)]
        public half4 ywyz { get; }
        [EditorBrowsable(Never)]
        public half4 ywyw { get; }
        [EditorBrowsable(Never)]
        public half4 ywzx { get; set; }
        [EditorBrowsable(Never)]
        public half4 ywzy { get; }
        [EditorBrowsable(Never)]
        public half4 ywzz { get; }
        [EditorBrowsable(Never)]
        public half4 ywzw { get; }
        [EditorBrowsable(Never)]
        public half4 ywwx { get; }
        [EditorBrowsable(Never)]
        public half4 ywwy { get; }
        [EditorBrowsable(Never)]
        public half4 ywwz { get; }
        [EditorBrowsable(Never)]
        public half4 ywww { get; }
        [EditorBrowsable(Never)]
        public half4 zxxx { get; }
        [EditorBrowsable(Never)]
        public half4 zxxy { get; }
        [EditorBrowsable(Never)]
        public half4 zxxz { get; }
        [EditorBrowsable(Never)]
        public half4 zxxw { get; }
        [EditorBrowsable(Never)]
        public half4 zxyx { get; }
        [EditorBrowsable(Never)]
        public half4 zxyy { get; }
        [EditorBrowsable(Never)]
        public half4 zxyz { get; }
        [EditorBrowsable(Never)]
        public half4 zxyw { get; set; }
        [EditorBrowsable(Never)]
        public half4 zxzx { get; }
        [EditorBrowsable(Never)]
        public half4 zxzy { get; }
        [EditorBrowsable(Never)]
        public half4 zxzz { get; }
        [EditorBrowsable(Never)]
        public half4 zxzw { get; }
        [EditorBrowsable(Never)]
        public half4 zxwx { get; }
        [EditorBrowsable(Never)]
        public half4 zxwy { get; set; }
        [EditorBrowsable(Never)]
        public half4 zxwz { get; }
        [EditorBrowsable(Never)]
        public half4 zxww { get; }
        [EditorBrowsable(Never)]
        public half4 zyxx { get; }
        [EditorBrowsable(Never)]
        public half4 zyxy { get; }
        [EditorBrowsable(Never)]
        public half4 zyxz { get; }
        [EditorBrowsable(Never)]
        public half4 zyxw { get; set; }
        [EditorBrowsable(Never)]
        public half4 zyyx { get; }
        [EditorBrowsable(Never)]
        public half4 zyyy { get; }
        [EditorBrowsable(Never)]
        public half4 zyyz { get; }
        [EditorBrowsable(Never)]
        public half4 zyyw { get; }
        [EditorBrowsable(Never)]
        public half4 zyzx { get; }
        [EditorBrowsable(Never)]
        public half4 zyzy { get; }
        [EditorBrowsable(Never)]
        public half4 zyzz { get; }
        [EditorBrowsable(Never)]
        public half4 zyzw { get; }
        [EditorBrowsable(Never)]
        public half4 zywx { get; set; }
        [EditorBrowsable(Never)]
        public half4 zywy { get; }
        [EditorBrowsable(Never)]
        public half4 zywz { get; }
        [EditorBrowsable(Never)]
        public half4 zyww { get; }
        [EditorBrowsable(Never)]
        public half4 zzxx { get; }
        [EditorBrowsable(Never)]
        public half4 zzxy { get; }
        [EditorBrowsable(Never)]
        public half4 zzxz { get; }
        [EditorBrowsable(Never)]
        public half4 zzxw { get; }
        [EditorBrowsable(Never)]
        public half4 zzyx { get; }
        [EditorBrowsable(Never)]
        public half4 zzyy { get; }
        [EditorBrowsable(Never)]
        public half4 zzyz { get; }
        [EditorBrowsable(Never)]
        public half4 zzyw { get; }
        [EditorBrowsable(Never)]
        public half4 zzzx { get; }
        [EditorBrowsable(Never)]
        public half4 zzzy { get; }
        [EditorBrowsable(Never)]
        public half4 zzzz { get; }
        [EditorBrowsable(Never)]
        public half4 zzzw { get; }
        [EditorBrowsable(Never)]
        public half4 zzwx { get; }
        [EditorBrowsable(Never)]
        public half4 zzwy { get; }
        [EditorBrowsable(Never)]
        public half4 zzwz { get; }
        [EditorBrowsable(Never)]
        public half4 zzww { get; }
        [EditorBrowsable(Never)]
        public half4 zwxx { get; }
        [EditorBrowsable(Never)]
        public half4 zwxy { get; set; }
        [EditorBrowsable(Never)]
        public half4 zwxz { get; }
        [EditorBrowsable(Never)]
        public half4 zwxw { get; }
        [EditorBrowsable(Never)]
        public half4 zwyx { get; set; }
        [EditorBrowsable(Never)]
        public half4 zwyy { get; }
        [EditorBrowsable(Never)]
        public half4 zwyz { get; }
        [EditorBrowsable(Never)]
        public half4 zwyw { get; }
        [EditorBrowsable(Never)]
        public half4 zwzx { get; }
        [EditorBrowsable(Never)]
        public half4 zwzy { get; }
        [EditorBrowsable(Never)]
        public half4 zwzz { get; }
        [EditorBrowsable(Never)]
        public half4 zwzw { get; }
        [EditorBrowsable(Never)]
        public half4 zwwx { get; }
        [EditorBrowsable(Never)]
        public half4 zwwy { get; }
        [EditorBrowsable(Never)]
        public half4 zwwz { get; }
        [EditorBrowsable(Never)]
        public half4 zwww { get; }
        [EditorBrowsable(Never)]
        public half4 wxxx { get; }
        [EditorBrowsable(Never)]
        public half4 wxxy { get; }
        [EditorBrowsable(Never)]
        public half4 wxxz { get; }
        [EditorBrowsable(Never)]
        public half4 wxxw { get; }
        [EditorBrowsable(Never)]
        public half4 wxyx { get; }
        [EditorBrowsable(Never)]
        public half4 wxyy { get; }
        [EditorBrowsable(Never)]
        public half4 wxyz { get; set; }
        [EditorBrowsable(Never)]
        public half4 wxyw { get; }
        [EditorBrowsable(Never)]
        public half4 wxzx { get; }
        [EditorBrowsable(Never)]
        public half4 wxzy { get; set; }
        [EditorBrowsable(Never)]
        public half4 wxzz { get; }
        [EditorBrowsable(Never)]
        public half4 wxzw { get; }
        [EditorBrowsable(Never)]
        public half4 wxwx { get; }
        [EditorBrowsable(Never)]
        public half4 wxwy { get; }
        [EditorBrowsable(Never)]
        public half4 wxwz { get; }
        [EditorBrowsable(Never)]
        public half4 wxww { get; }
        [EditorBrowsable(Never)]
        public half4 wyxx { get; }
        [EditorBrowsable(Never)]
        public half4 wyxy { get; }
        [EditorBrowsable(Never)]
        public half4 wyxz { get; set; }
        [EditorBrowsable(Never)]
        public half4 wyxw { get; }
        [EditorBrowsable(Never)]
        public half4 wyyx { get; }
        [EditorBrowsable(Never)]
        public half4 wyyy { get; }
        [EditorBrowsable(Never)]
        public half4 wyyz { get; }
        [EditorBrowsable(Never)]
        public half4 wyyw { get; }
        [EditorBrowsable(Never)]
        public half4 wyzx { get; set; }
        [EditorBrowsable(Never)]
        public half4 wyzy { get; }
        [EditorBrowsable(Never)]
        public half4 wyzz { get; }
        [EditorBrowsable(Never)]
        public half4 wyzw { get; }
        [EditorBrowsable(Never)]
        public half4 wywx { get; }
        [EditorBrowsable(Never)]
        public half4 wywy { get; }
        [EditorBrowsable(Never)]
        public half4 wywz { get; }
        [EditorBrowsable(Never)]
        public half4 wyww { get; }
        [EditorBrowsable(Never)]
        public half4 wzxx { get; }
        [EditorBrowsable(Never)]
        public half4 wzxy { get; set; }
        [EditorBrowsable(Never)]
        public half4 wzxz { get; }
        [EditorBrowsable(Never)]
        public half4 wzxw { get; }
        [EditorBrowsable(Never)]
        public half4 wzyx { get; set; }
        [EditorBrowsable(Never)]
        public half4 wzyy { get; }
        [EditorBrowsable(Never)]
        public half4 wzyz { get; }
        [EditorBrowsable(Never)]
        public half4 wzyw { get; }
        [EditorBrowsable(Never)]
        public half4 wzzx { get; }
        [EditorBrowsable(Never)]
        public half4 wzzy { get; }
        [EditorBrowsable(Never)]
        public half4 wzzz { get; }
        [EditorBrowsable(Never)]
        public half4 wzzw { get; }
        [EditorBrowsable(Never)]
        public half4 wzwx { get; }
        [EditorBrowsable(Never)]
        public half4 wzwy { get; }
        [EditorBrowsable(Never)]
        public half4 wzwz { get; }
        [EditorBrowsable(Never)]
        public half4 wzww { get; }
        [EditorBrowsable(Never)]
        public half4 wwxx { get; }
        [EditorBrowsable(Never)]
        public half4 wwxy { get; }
        [EditorBrowsable(Never)]
        public half4 wwxz { get; }
        [EditorBrowsable(Never)]
        public half4 wwxw { get; }
        [EditorBrowsable(Never)]
        public half4 wwyx { get; }
        [EditorBrowsable(Never)]
        public half4 wwyy { get; }
        [EditorBrowsable(Never)]
        public half4 wwyz { get; }
        [EditorBrowsable(Never)]
        public half4 wwyw { get; }
        [EditorBrowsable(Never)]
        public half4 wwzx { get; }
        [EditorBrowsable(Never)]
        public half4 wwzy { get; }
        [EditorBrowsable(Never)]
        public half4 wwzz { get; }
        [EditorBrowsable(Never)]
        public half4 wwzw { get; }
        [EditorBrowsable(Never)]
        public half4 wwwx { get; }
        [EditorBrowsable(Never)]
        public half4 wwwy { get; }
        [EditorBrowsable(Never)]
        public half4 wwwz { get; }
        [EditorBrowsable(Never)]
        public half4 wwww { get; }
        [EditorBrowsable(Never)]
        public half3 xxx { get; }
        [EditorBrowsable(Never)]
        public half3 xxy { get; }
        [EditorBrowsable(Never)]
        public half3 xxz { get; }
        [EditorBrowsable(Never)]
        public half3 xxw { get; }
        [EditorBrowsable(Never)]
        public half3 xyx { get; }
        [EditorBrowsable(Never)]
        public half3 xyy { get; }
        [EditorBrowsable(Never)]
        public half3 xyz { get; set; }
        [EditorBrowsable(Never)]
        public half3 xyw { get; set; }
        [EditorBrowsable(Never)]
        public half3 xzx { get; }
        [EditorBrowsable(Never)]
        public half3 xzy { get; set; }
        [EditorBrowsable(Never)]
        public half3 xzz { get; }
        [EditorBrowsable(Never)]
        public half3 xzw { get; set; }
        [EditorBrowsable(Never)]
        public half3 xwx { get; }
        [EditorBrowsable(Never)]
        public half3 xwy { get; set; }
        [EditorBrowsable(Never)]
        public half3 xwz { get; set; }
        [EditorBrowsable(Never)]
        public half3 xww { get; }
        [EditorBrowsable(Never)]
        public half3 yxx { get; }
        [EditorBrowsable(Never)]
        public half3 yxy { get; }
        [EditorBrowsable(Never)]
        public half3 yxz { get; set; }
        [EditorBrowsable(Never)]
        public half3 yxw { get; set; }
        [EditorBrowsable(Never)]
        public half3 yyx { get; }
        [EditorBrowsable(Never)]
        public half3 yyy { get; }
        [EditorBrowsable(Never)]
        public half3 yyz { get; }
        [EditorBrowsable(Never)]
        public half3 yyw { get; }
        [EditorBrowsable(Never)]
        public half3 yzx { get; set; }
        [EditorBrowsable(Never)]
        public half3 yzy { get; }
        [EditorBrowsable(Never)]
        public half3 yzz { get; }
        [EditorBrowsable(Never)]
        public half3 yzw { get; set; }
        [EditorBrowsable(Never)]
        public half3 ywx { get; set; }
        [EditorBrowsable(Never)]
        public half3 ywy { get; }
        [EditorBrowsable(Never)]
        public half3 ywz { get; set; }
        [EditorBrowsable(Never)]
        public half3 yww { get; }
        [EditorBrowsable(Never)]
        public half3 zxx { get; }
        [EditorBrowsable(Never)]
        public half3 zxy { get; set; }
        [EditorBrowsable(Never)]
        public half3 zxz { get; }
        [EditorBrowsable(Never)]
        public half3 zxw { get; set; }
        [EditorBrowsable(Never)]
        public half3 zyx { get; set; }
        [EditorBrowsable(Never)]
        public half3 zyy { get; }
        [EditorBrowsable(Never)]
        public half3 zyz { get; }
        [EditorBrowsable(Never)]
        public half3 zyw { get; set; }
        [EditorBrowsable(Never)]
        public half3 zzx { get; }
        [EditorBrowsable(Never)]
        public half3 zzy { get; }
        [EditorBrowsable(Never)]
        public half3 zzz { get; }
        [EditorBrowsable(Never)]
        public half3 zzw { get; }
        [EditorBrowsable(Never)]
        public half3 zwx { get; set; }
        [EditorBrowsable(Never)]
        public half3 zwy { get; set; }
        [EditorBrowsable(Never)]
        public half3 zwz { get; }
        [EditorBrowsable(Never)]
        public half3 zww { get; }
        [EditorBrowsable(Never)]
        public half3 wxx { get; }
        [EditorBrowsable(Never)]
        public half3 wxy { get; set; }
        [EditorBrowsable(Never)]
        public half3 wxz { get; set; }
        [EditorBrowsable(Never)]
        public half3 wxw { get; }
        [EditorBrowsable(Never)]
        public half3 wyx { get; set; }
        [EditorBrowsable(Never)]
        public half3 wyy { get; }
        [EditorBrowsable(Never)]
        public half3 wyz { get; set; }
        [EditorBrowsable(Never)]
        public half3 wyw { get; }
        [EditorBrowsable(Never)]
        public half3 wzx { get; set; }
        [EditorBrowsable(Never)]
        public half3 wzy { get; set; }
        [EditorBrowsable(Never)]
        public half3 wzz { get; }
        [EditorBrowsable(Never)]
        public half3 wzw { get; }
        [EditorBrowsable(Never)]
        public half3 wwx { get; }
        [EditorBrowsable(Never)]
        public half3 wwy { get; }
        [EditorBrowsable(Never)]
        public half3 wwz { get; }
        [EditorBrowsable(Never)]
        public half3 www { get; }
        [EditorBrowsable(Never)]
        public half2 xx { get; }
        [EditorBrowsable(Never)]
        public half2 xy { get; set; }
        [EditorBrowsable(Never)]
        public half2 xz { get; set; }
        [EditorBrowsable(Never)]
        public half2 xw { get; set; }
        [EditorBrowsable(Never)]
        public half2 yx { get; set; }
        [EditorBrowsable(Never)]
        public half2 yy { get; }
        [EditorBrowsable(Never)]
        public half2 yz { get; set; }
        [EditorBrowsable(Never)]
        public half2 yw { get; set; }
        [EditorBrowsable(Never)]
        public half2 zx { get; set; }
        [EditorBrowsable(Never)]
        public half2 zy { get; set; }
        [EditorBrowsable(Never)]
        public half2 zz { get; }
        [EditorBrowsable(Never)]
        public half2 zw { get; set; }
        [EditorBrowsable(Never)]
        public half2 wx { get; set; }
        [EditorBrowsable(Never)]
        public half2 wy { get; set; }
        [EditorBrowsable(Never)]
        public half2 wz { get; set; }
        [EditorBrowsable(Never)]
        public half2 ww { get; }

        public bool Equals(half4 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static bool4 operator ==(half4 lhs, half4 rhs);
        public static bool4 operator ==(half4 lhs, half rhs);
        public static bool4 operator ==(half lhs, half4 rhs);
        public static bool4 operator !=(half4 lhs, half4 rhs);
        public static bool4 operator !=(half4 lhs, half rhs);
        public static bool4 operator !=(half lhs, half4 rhs);

        public static implicit operator half4(half v);
        public static explicit operator half4(float v);
        public static explicit operator half4(float4 v);
        public static explicit operator half4(double v);
        public static explicit operator half4(double4 v);
    }
}
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    [DebuggerTypeProxy(typeof(DebuggerProxy))]
    public struct int2 : IEquatable<int2>, IFormattable
    {
        public int x;
        public int y;
        public static readonly int2 zero;

        public int2(int x, int y);
        public int2(int2 xy);
        public int2(int v);
        public int2(bool v);
        public int2(bool2 v);
        public int2(uint v);
        public int2(uint2 v);
        public int2(float v);
        public int2(float2 v);
        public int2(double v);
        public int2(double2 v);

        public int this[int index] { get; set; }
        [EditorBrowsable(Never)]
        public int4 xxxx { get; }
        [EditorBrowsable(Never)]
        public int4 xxxy { get; }
        [EditorBrowsable(Never)]
        public int4 xxyx { get; }
        [EditorBrowsable(Never)]
        public int4 xxyy { get; }
        [EditorBrowsable(Never)]
        public int4 xyxx { get; }
        [EditorBrowsable(Never)]
        public int4 xyxy { get; }
        [EditorBrowsable(Never)]
        public int4 xyyx { get; }
        [EditorBrowsable(Never)]
        public int4 xyyy { get; }
        [EditorBrowsable(Never)]
        public int4 yxxx { get; }
        [EditorBrowsable(Never)]
        public int4 yxxy { get; }
        [EditorBrowsable(Never)]
        public int4 yxyx { get; }
        [EditorBrowsable(Never)]
        public int4 yxyy { get; }
        [EditorBrowsable(Never)]
        public int4 yyxx { get; }
        [EditorBrowsable(Never)]
        public int4 yyxy { get; }
        [EditorBrowsable(Never)]
        public int4 yyyx { get; }
        [EditorBrowsable(Never)]
        public int4 yyyy { get; }
        [EditorBrowsable(Never)]
        public int3 xxx { get; }
        [EditorBrowsable(Never)]
        public int3 xxy { get; }
        [EditorBrowsable(Never)]
        public int3 xyx { get; }
        [EditorBrowsable(Never)]
        public int3 xyy { get; }
        [EditorBrowsable(Never)]
        public int3 yxx { get; }
        [EditorBrowsable(Never)]
        public int3 yxy { get; }
        [EditorBrowsable(Never)]
        public int3 yyx { get; }
        [EditorBrowsable(Never)]
        public int3 yyy { get; }
        [EditorBrowsable(Never)]
        public int2 xx { get; }
        [EditorBrowsable(Never)]
        public int2 xy { get; set; }
        [EditorBrowsable(Never)]
        public int2 yx { get; set; }
        [EditorBrowsable(Never)]
        public int2 yy { get; }

        public bool Equals(int2 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static int2 operator *(int2 lhs, int2 rhs);
        public static int2 operator *(int2 lhs, int rhs);
        public static int2 operator *(int lhs, int2 rhs);
        public static int2 operator +(int2 lhs, int2 rhs);
        public static int2 operator +(int2 lhs, int rhs);
        public static int2 operator +(int lhs, int2 rhs);
        public static int2 operator -(int2 lhs, int2 rhs);
        public static int2 operator -(int2 lhs, int rhs);
        public static int2 operator -(int lhs, int2 rhs);
        public static int2 operator /(int2 lhs, int2 rhs);
        public static int2 operator /(int2 lhs, int rhs);
        public static int2 operator /(int lhs, int2 rhs);
        public static int2 operator %(int2 lhs, int2 rhs);
        public static int2 operator %(int2 lhs, int rhs);
        public static int2 operator %(int lhs, int2 rhs);
        public static int2 operator ++(int2 val);
        public static int2 operator --(int2 val);
        public static bool2 operator <(int2 lhs, int2 rhs);
        public static bool2 operator <(int2 lhs, int rhs);
        public static bool2 operator <(int lhs, int2 rhs);
        public static bool2 operator <=(int2 lhs, int2 rhs);
        public static bool2 operator <=(int2 lhs, int rhs);
        public static bool2 operator <=(int lhs, int2 rhs);
        public static bool2 operator >(int2 lhs, int2 rhs);
        public static bool2 operator >(int2 lhs, int rhs);
        public static bool2 operator >(int lhs, int2 rhs);
        public static bool2 operator >=(int2 lhs, int2 rhs);
        public static bool2 operator >=(int2 lhs, int rhs);
        public static bool2 operator >=(int lhs, int2 rhs);
        public static int2 operator -(int2 val);
        public static int2 operator +(int2 val);
        public static int2 operator <<(int2 x, int n);
        public static int2 operator >>(int2 x, int n);
        public static bool2 operator ==(int2 lhs, int2 rhs);
        public static bool2 operator ==(int2 lhs, int rhs);
        public static bool2 operator ==(int lhs, int2 rhs);
        public static bool2 operator !=(int2 lhs, int2 rhs);
        public static bool2 operator !=(int2 lhs, int rhs);
        public static bool2 operator !=(int lhs, int2 rhs);
        public static int2 operator ~(int2 val);
        public static int2 operator &(int2 lhs, int2 rhs);
        public static int2 operator &(int2 lhs, int rhs);
        public static int2 operator &(int lhs, int2 rhs);
        public static int2 operator |(int2 lhs, int2 rhs);
        public static int2 operator |(int2 lhs, int rhs);
        public static int2 operator |(int lhs, int2 rhs);
        public static int2 operator ^(int2 lhs, int2 rhs);
        public static int2 operator ^(int2 lhs, int rhs);
        public static int2 operator ^(int lhs, int2 rhs);

        public static implicit operator int2(int v);
        public static explicit operator int2(bool v);
        public static explicit operator int2(bool2 v);
        public static explicit operator int2(uint v);
        public static explicit operator int2(uint2 v);
        public static explicit operator int2(float v);
        public static explicit operator int2(float2 v);
        public static explicit operator int2(double v);
        public static explicit operator int2(double2 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct int2x2 : IEquatable<int2x2>, IFormattable
    {
        public int2 c0;
        public int2 c1;
        public static readonly int2x2 identity;
        public static readonly int2x2 zero;

        public int2x2(int2 c0, int2 c1);
        public int2x2(int m00, int m01, int m10, int m11);
        public int2x2(int v);
        public int2x2(bool v);
        public int2x2(bool2x2 v);
        public int2x2(uint v);
        public int2x2(uint2x2 v);
        public int2x2(float v);
        public int2x2(float2x2 v);
        public int2x2(double v);
        public int2x2(double2x2 v);

        public ref int2 this[int index] { get; }

        public bool Equals(int2x2 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static int2x2 operator *(int2x2 lhs, int2x2 rhs);
        public static int2x2 operator *(int2x2 lhs, int rhs);
        public static int2x2 operator *(int lhs, int2x2 rhs);
        public static int2x2 operator +(int2x2 lhs, int2x2 rhs);
        public static int2x2 operator +(int2x2 lhs, int rhs);
        public static int2x2 operator +(int lhs, int2x2 rhs);
        public static int2x2 operator -(int2x2 lhs, int2x2 rhs);
        public static int2x2 operator -(int2x2 lhs, int rhs);
        public static int2x2 operator -(int lhs, int2x2 rhs);
        public static int2x2 operator /(int2x2 lhs, int2x2 rhs);
        public static int2x2 operator /(int2x2 lhs, int rhs);
        public static int2x2 operator /(int lhs, int2x2 rhs);
        public static int2x2 operator %(int2x2 lhs, int2x2 rhs);
        public static int2x2 operator %(int2x2 lhs, int rhs);
        public static int2x2 operator %(int lhs, int2x2 rhs);
        public static int2x2 operator ++(int2x2 val);
        public static int2x2 operator --(int2x2 val);
        public static bool2x2 operator <(int2x2 lhs, int2x2 rhs);
        public static bool2x2 operator <(int2x2 lhs, int rhs);
        public static bool2x2 operator <(int lhs, int2x2 rhs);
        public static bool2x2 operator <=(int2x2 lhs, int2x2 rhs);
        public static bool2x2 operator <=(int2x2 lhs, int rhs);
        public static bool2x2 operator <=(int lhs, int2x2 rhs);
        public static bool2x2 operator >(int2x2 lhs, int2x2 rhs);
        public static bool2x2 operator >(int2x2 lhs, int rhs);
        public static bool2x2 operator >(int lhs, int2x2 rhs);
        public static bool2x2 operator >=(int2x2 lhs, int2x2 rhs);
        public static bool2x2 operator >=(int2x2 lhs, int rhs);
        public static bool2x2 operator >=(int lhs, int2x2 rhs);
        public static int2x2 operator -(int2x2 val);
        public static int2x2 operator +(int2x2 val);
        public static int2x2 operator <<(int2x2 x, int n);
        public static int2x2 operator >>(int2x2 x, int n);
        public static bool2x2 operator ==(int2x2 lhs, int2x2 rhs);
        public static bool2x2 operator ==(int2x2 lhs, int rhs);
        public static bool2x2 operator ==(int lhs, int2x2 rhs);
        public static bool2x2 operator !=(int2x2 lhs, int2x2 rhs);
        public static bool2x2 operator !=(int2x2 lhs, int rhs);
        public static bool2x2 operator !=(int lhs, int2x2 rhs);
        public static int2x2 operator ~(int2x2 val);
        public static int2x2 operator &(int2x2 lhs, int2x2 rhs);
        public static int2x2 operator &(int2x2 lhs, int rhs);
        public static int2x2 operator &(int lhs, int2x2 rhs);
        public static int2x2 operator |(int2x2 lhs, int2x2 rhs);
        public static int2x2 operator |(int2x2 lhs, int rhs);
        public static int2x2 operator |(int lhs, int2x2 rhs);
        public static int2x2 operator ^(int2x2 lhs, int2x2 rhs);
        public static int2x2 operator ^(int2x2 lhs, int rhs);
        public static int2x2 operator ^(int lhs, int2x2 rhs);

        public static implicit operator int2x2(int v);
        public static explicit operator int2x2(bool v);
        public static explicit operator int2x2(bool2x2 v);
        public static explicit operator int2x2(uint v);
        public static explicit operator int2x2(uint2x2 v);
        public static explicit operator int2x2(float v);
        public static explicit operator int2x2(float2x2 v);
        public static explicit operator int2x2(double v);
        public static explicit operator int2x2(double2x2 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct int2x3 : IEquatable<int2x3>, IFormattable
    {
        public int2 c0;
        public int2 c1;
        public int2 c2;
        public static readonly int2x3 zero;

        public int2x3(int2 c0, int2 c1, int2 c2);
        public int2x3(int m00, int m01, int m02, int m10, int m11, int m12);
        public int2x3(int v);
        public int2x3(bool v);
        public int2x3(bool2x3 v);
        public int2x3(uint v);
        public int2x3(uint2x3 v);
        public int2x3(float v);
        public int2x3(float2x3 v);
        public int2x3(double v);
        public int2x3(double2x3 v);

        public ref int2 this[int index] { get; }

        public bool Equals(int2x3 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static int2x3 operator *(int2x3 lhs, int2x3 rhs);
        public static int2x3 operator *(int2x3 lhs, int rhs);
        public static int2x3 operator *(int lhs, int2x3 rhs);
        public static int2x3 operator +(int2x3 lhs, int2x3 rhs);
        public static int2x3 operator +(int2x3 lhs, int rhs);
        public static int2x3 operator +(int lhs, int2x3 rhs);
        public static int2x3 operator -(int2x3 lhs, int2x3 rhs);
        public static int2x3 operator -(int2x3 lhs, int rhs);
        public static int2x3 operator -(int lhs, int2x3 rhs);
        public static int2x3 operator /(int2x3 lhs, int2x3 rhs);
        public static int2x3 operator /(int2x3 lhs, int rhs);
        public static int2x3 operator /(int lhs, int2x3 rhs);
        public static int2x3 operator %(int2x3 lhs, int2x3 rhs);
        public static int2x3 operator %(int2x3 lhs, int rhs);
        public static int2x3 operator %(int lhs, int2x3 rhs);
        public static int2x3 operator ++(int2x3 val);
        public static int2x3 operator --(int2x3 val);
        public static bool2x3 operator <(int2x3 lhs, int2x3 rhs);
        public static bool2x3 operator <(int2x3 lhs, int rhs);
        public static bool2x3 operator <(int lhs, int2x3 rhs);
        public static bool2x3 operator <=(int2x3 lhs, int2x3 rhs);
        public static bool2x3 operator <=(int2x3 lhs, int rhs);
        public static bool2x3 operator <=(int lhs, int2x3 rhs);
        public static bool2x3 operator >(int2x3 lhs, int2x3 rhs);
        public static bool2x3 operator >(int2x3 lhs, int rhs);
        public static bool2x3 operator >(int lhs, int2x3 rhs);
        public static bool2x3 operator >=(int2x3 lhs, int2x3 rhs);
        public static bool2x3 operator >=(int2x3 lhs, int rhs);
        public static bool2x3 operator >=(int lhs, int2x3 rhs);
        public static int2x3 operator -(int2x3 val);
        public static int2x3 operator +(int2x3 val);
        public static int2x3 operator <<(int2x3 x, int n);
        public static int2x3 operator >>(int2x3 x, int n);
        public static bool2x3 operator ==(int2x3 lhs, int2x3 rhs);
        public static bool2x3 operator ==(int2x3 lhs, int rhs);
        public static bool2x3 operator ==(int lhs, int2x3 rhs);
        public static bool2x3 operator !=(int2x3 lhs, int2x3 rhs);
        public static bool2x3 operator !=(int2x3 lhs, int rhs);
        public static bool2x3 operator !=(int lhs, int2x3 rhs);
        public static int2x3 operator ~(int2x3 val);
        public static int2x3 operator &(int2x3 lhs, int2x3 rhs);
        public static int2x3 operator &(int2x3 lhs, int rhs);
        public static int2x3 operator &(int lhs, int2x3 rhs);
        public static int2x3 operator |(int2x3 lhs, int2x3 rhs);
        public static int2x3 operator |(int2x3 lhs, int rhs);
        public static int2x3 operator |(int lhs, int2x3 rhs);
        public static int2x3 operator ^(int2x3 lhs, int2x3 rhs);
        public static int2x3 operator ^(int2x3 lhs, int rhs);
        public static int2x3 operator ^(int lhs, int2x3 rhs);

        public static implicit operator int2x3(int v);
        public static explicit operator int2x3(bool v);
        public static explicit operator int2x3(bool2x3 v);
        public static explicit operator int2x3(uint v);
        public static explicit operator int2x3(uint2x3 v);
        public static explicit operator int2x3(float v);
        public static explicit operator int2x3(float2x3 v);
        public static explicit operator int2x3(double v);
        public static explicit operator int2x3(double2x3 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct int2x4 : IEquatable<int2x4>, IFormattable
    {
        public int2 c0;
        public int2 c1;
        public int2 c2;
        public int2 c3;
        public static readonly int2x4 zero;

        public int2x4(int2 c0, int2 c1, int2 c2, int2 c3);
        public int2x4(int m00, int m01, int m02, int m03, int m10, int m11, int m12, int m13);
        public int2x4(int v);
        public int2x4(bool v);
        public int2x4(bool2x4 v);
        public int2x4(uint v);
        public int2x4(uint2x4 v);
        public int2x4(float v);
        public int2x4(float2x4 v);
        public int2x4(double v);
        public int2x4(double2x4 v);

        public ref int2 this[int index] { get; }

        public bool Equals(int2x4 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static int2x4 operator *(int2x4 lhs, int2x4 rhs);
        public static int2x4 operator *(int2x4 lhs, int rhs);
        public static int2x4 operator *(int lhs, int2x4 rhs);
        public static int2x4 operator +(int2x4 lhs, int2x4 rhs);
        public static int2x4 operator +(int2x4 lhs, int rhs);
        public static int2x4 operator +(int lhs, int2x4 rhs);
        public static int2x4 operator -(int2x4 lhs, int2x4 rhs);
        public static int2x4 operator -(int2x4 lhs, int rhs);
        public static int2x4 operator -(int lhs, int2x4 rhs);
        public static int2x4 operator /(int2x4 lhs, int2x4 rhs);
        public static int2x4 operator /(int2x4 lhs, int rhs);
        public static int2x4 operator /(int lhs, int2x4 rhs);
        public static int2x4 operator %(int2x4 lhs, int2x4 rhs);
        public static int2x4 operator %(int2x4 lhs, int rhs);
        public static int2x4 operator %(int lhs, int2x4 rhs);
        public static int2x4 operator ++(int2x4 val);
        public static int2x4 operator --(int2x4 val);
        public static bool2x4 operator <(int2x4 lhs, int2x4 rhs);
        public static bool2x4 operator <(int2x4 lhs, int rhs);
        public static bool2x4 operator <(int lhs, int2x4 rhs);
        public static bool2x4 operator <=(int2x4 lhs, int2x4 rhs);
        public static bool2x4 operator <=(int2x4 lhs, int rhs);
        public static bool2x4 operator <=(int lhs, int2x4 rhs);
        public static bool2x4 operator >(int2x4 lhs, int2x4 rhs);
        public static bool2x4 operator >(int2x4 lhs, int rhs);
        public static bool2x4 operator >(int lhs, int2x4 rhs);
        public static bool2x4 operator >=(int2x4 lhs, int2x4 rhs);
        public static bool2x4 operator >=(int2x4 lhs, int rhs);
        public static bool2x4 operator >=(int lhs, int2x4 rhs);
        public static int2x4 operator -(int2x4 val);
        public static int2x4 operator +(int2x4 val);
        public static int2x4 operator <<(int2x4 x, int n);
        public static int2x4 operator >>(int2x4 x, int n);
        public static bool2x4 operator ==(int2x4 lhs, int2x4 rhs);
        public static bool2x4 operator ==(int2x4 lhs, int rhs);
        public static bool2x4 operator ==(int lhs, int2x4 rhs);
        public static bool2x4 operator !=(int2x4 lhs, int2x4 rhs);
        public static bool2x4 operator !=(int2x4 lhs, int rhs);
        public static bool2x4 operator !=(int lhs, int2x4 rhs);
        public static int2x4 operator ~(int2x4 val);
        public static int2x4 operator &(int2x4 lhs, int2x4 rhs);
        public static int2x4 operator &(int2x4 lhs, int rhs);
        public static int2x4 operator &(int lhs, int2x4 rhs);
        public static int2x4 operator |(int2x4 lhs, int2x4 rhs);
        public static int2x4 operator |(int2x4 lhs, int rhs);
        public static int2x4 operator |(int lhs, int2x4 rhs);
        public static int2x4 operator ^(int2x4 lhs, int2x4 rhs);
        public static int2x4 operator ^(int2x4 lhs, int rhs);
        public static int2x4 operator ^(int lhs, int2x4 rhs);

        public static implicit operator int2x4(int v);
        public static explicit operator int2x4(bool v);
        public static explicit operator int2x4(bool2x4 v);
        public static explicit operator int2x4(uint v);
        public static explicit operator int2x4(uint2x4 v);
        public static explicit operator int2x4(float v);
        public static explicit operator int2x4(float2x4 v);
        public static explicit operator int2x4(double v);
        public static explicit operator int2x4(double2x4 v);
    }
}
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    [DebuggerTypeProxy(typeof(DebuggerProxy))]
    public struct int3 : IEquatable<int3>, IFormattable
    {
        public int x;
        public int y;
        public int z;
        public static readonly int3 zero;

        public int3(int x, int y, int z);
        public int3(int x, int2 yz);
        public int3(int2 xy, int z);
        public int3(int3 xyz);
        public int3(int v);
        public int3(bool v);
        public int3(bool3 v);
        public int3(uint v);
        public int3(uint3 v);
        public int3(float v);
        public int3(float3 v);
        public int3(double v);
        public int3(double3 v);

        public int this[int index] { get; set; }
        [EditorBrowsable(Never)]
        public int4 xxxx { get; }
        [EditorBrowsable(Never)]
        public int4 xxxy { get; }
        [EditorBrowsable(Never)]
        public int4 xxxz { get; }
        [EditorBrowsable(Never)]
        public int4 xxyx { get; }
        [EditorBrowsable(Never)]
        public int4 xxyy { get; }
        [EditorBrowsable(Never)]
        public int4 xxyz { get; }
        [EditorBrowsable(Never)]
        public int4 xxzx { get; }
        [EditorBrowsable(Never)]
        public int4 xxzy { get; }
        [EditorBrowsable(Never)]
        public int4 xxzz { get; }
        [EditorBrowsable(Never)]
        public int4 xyxx { get; }
        [EditorBrowsable(Never)]
        public int4 xyxy { get; }
        [EditorBrowsable(Never)]
        public int4 xyxz { get; }
        [EditorBrowsable(Never)]
        public int4 xyyx { get; }
        [EditorBrowsable(Never)]
        public int4 xyyy { get; }
        [EditorBrowsable(Never)]
        public int4 xyyz { get; }
        [EditorBrowsable(Never)]
        public int4 xyzx { get; }
        [EditorBrowsable(Never)]
        public int4 xyzy { get; }
        [EditorBrowsable(Never)]
        public int4 xyzz { get; }
        [EditorBrowsable(Never)]
        public int4 xzxx { get; }
        [EditorBrowsable(Never)]
        public int4 xzxy { get; }
        [EditorBrowsable(Never)]
        public int4 xzxz { get; }
        [EditorBrowsable(Never)]
        public int4 xzyx { get; }
        [EditorBrowsable(Never)]
        public int4 xzyy { get; }
        [EditorBrowsable(Never)]
        public int4 xzyz { get; }
        [EditorBrowsable(Never)]
        public int4 xzzx { get; }
        [EditorBrowsable(Never)]
        public int4 xzzy { get; }
        [EditorBrowsable(Never)]
        public int4 xzzz { get; }
        [EditorBrowsable(Never)]
        public int4 yxxx { get; }
        [EditorBrowsable(Never)]
        public int4 yxxy { get; }
        [EditorBrowsable(Never)]
        public int4 yxxz { get; }
        [EditorBrowsable(Never)]
        public int4 yxyx { get; }
        [EditorBrowsable(Never)]
        public int4 yxyy { get; }
        [EditorBrowsable(Never)]
        public int4 yxyz { get; }
        [EditorBrowsable(Never)]
        public int4 yxzx { get; }
        [EditorBrowsable(Never)]
        public int4 yxzy { get; }
        [EditorBrowsable(Never)]
        public int4 yxzz { get; }
        [EditorBrowsable(Never)]
        public int4 yyxx { get; }
        [EditorBrowsable(Never)]
        public int4 yyxy { get; }
        [EditorBrowsable(Never)]
        public int4 yyxz { get; }
        [EditorBrowsable(Never)]
        public int4 yyyx { get; }
        [EditorBrowsable(Never)]
        public int4 yyyy { get; }
        [EditorBrowsable(Never)]
        public int4 yyyz { get; }
        [EditorBrowsable(Never)]
        public int4 yyzx { get; }
        [EditorBrowsable(Never)]
        public int4 yyzy { get; }
        [EditorBrowsable(Never)]
        public int4 yyzz { get; }
        [EditorBrowsable(Never)]
        public int4 yzxx { get; }
        [EditorBrowsable(Never)]
        public int4 yzxy { get; }
        [EditorBrowsable(Never)]
        public int4 yzxz { get; }
        [EditorBrowsable(Never)]
        public int4 yzyx { get; }
        [EditorBrowsable(Never)]
        public int4 yzyy { get; }
        [EditorBrowsable(Never)]
        public int4 yzyz { get; }
        [EditorBrowsable(Never)]
        public int4 yzzx { get; }
        [EditorBrowsable(Never)]
        public int4 yzzy { get; }
        [EditorBrowsable(Never)]
        public int4 yzzz { get; }
        [EditorBrowsable(Never)]
        public int4 zxxx { get; }
        [EditorBrowsable(Never)]
        public int4 zxxy { get; }
        [EditorBrowsable(Never)]
        public int4 zxxz { get; }
        [EditorBrowsable(Never)]
        public int4 zxyx { get; }
        [EditorBrowsable(Never)]
        public int4 zxyy { get; }
        [EditorBrowsable(Never)]
        public int4 zxyz { get; }
        [EditorBrowsable(Never)]
        public int4 zxzx { get; }
        [EditorBrowsable(Never)]
        public int4 zxzy { get; }
        [EditorBrowsable(Never)]
        public int4 zxzz { get; }
        [EditorBrowsable(Never)]
        public int4 zyxx { get; }
        [EditorBrowsable(Never)]
        public int4 zyxy { get; }
        [EditorBrowsable(Never)]
        public int4 zyxz { get; }
        [EditorBrowsable(Never)]
        public int4 zyyx { get; }
        [EditorBrowsable(Never)]
        public int4 zyyy { get; }
        [EditorBrowsable(Never)]
        public int4 zyyz { get; }
        [EditorBrowsable(Never)]
        public int4 zyzx { get; }
        [EditorBrowsable(Never)]
        public int4 zyzy { get; }
        [EditorBrowsable(Never)]
        public int4 zyzz { get; }
        [EditorBrowsable(Never)]
        public int4 zzxx { get; }
        [EditorBrowsable(Never)]
        public int4 zzxy { get; }
        [EditorBrowsable(Never)]
        public int4 zzxz { get; }
        [EditorBrowsable(Never)]
        public int4 zzyx { get; }
        [EditorBrowsable(Never)]
        public int4 zzyy { get; }
        [EditorBrowsable(Never)]
        public int4 zzyz { get; }
        [EditorBrowsable(Never)]
        public int4 zzzx { get; }
        [EditorBrowsable(Never)]
        public int4 zzzy { get; }
        [EditorBrowsable(Never)]
        public int4 zzzz { get; }
        [EditorBrowsable(Never)]
        public int3 xxx { get; }
        [EditorBrowsable(Never)]
        public int3 xxy { get; }
        [EditorBrowsable(Never)]
        public int3 xxz { get; }
        [EditorBrowsable(Never)]
        public int3 xyx { get; }
        [EditorBrowsable(Never)]
        public int3 xyy { get; }
        [EditorBrowsable(Never)]
        public int3 xyz { get; set; }
        [EditorBrowsable(Never)]
        public int3 xzx { get; }
        [EditorBrowsable(Never)]
        public int3 xzy { get; set; }
        [EditorBrowsable(Never)]
        public int3 xzz { get; }
        [EditorBrowsable(Never)]
        public int3 yxx { get; }
        [EditorBrowsable(Never)]
        public int3 yxy { get; }
        [EditorBrowsable(Never)]
        public int3 yxz { get; set; }
        [EditorBrowsable(Never)]
        public int3 yyx { get; }
        [EditorBrowsable(Never)]
        public int3 yyy { get; }
        [EditorBrowsable(Never)]
        public int3 yyz { get; }
        [EditorBrowsable(Never)]
        public int3 yzx { get; set; }
        [EditorBrowsable(Never)]
        public int3 yzy { get; }
        [EditorBrowsable(Never)]
        public int3 yzz { get; }
        [EditorBrowsable(Never)]
        public int3 zxx { get; }
        [EditorBrowsable(Never)]
        public int3 zxy { get; set; }
        [EditorBrowsable(Never)]
        public int3 zxz { get; }
        [EditorBrowsable(Never)]
        public int3 zyx { get; set; }
        [EditorBrowsable(Never)]
        public int3 zyy { get; }
        [EditorBrowsable(Never)]
        public int3 zyz { get; }
        [EditorBrowsable(Never)]
        public int3 zzx { get; }
        [EditorBrowsable(Never)]
        public int3 zzy { get; }
        [EditorBrowsable(Never)]
        public int3 zzz { get; }
        [EditorBrowsable(Never)]
        public int2 xx { get; }
        [EditorBrowsable(Never)]
        public int2 xy { get; set; }
        [EditorBrowsable(Never)]
        public int2 xz { get; set; }
        [EditorBrowsable(Never)]
        public int2 yx { get; set; }
        [EditorBrowsable(Never)]
        public int2 yy { get; }
        [EditorBrowsable(Never)]
        public int2 yz { get; set; }
        [EditorBrowsable(Never)]
        public int2 zx { get; set; }
        [EditorBrowsable(Never)]
        public int2 zy { get; set; }
        [EditorBrowsable(Never)]
        public int2 zz { get; }

        public bool Equals(int3 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static int3 operator *(int3 lhs, int3 rhs);
        public static int3 operator *(int3 lhs, int rhs);
        public static int3 operator *(int lhs, int3 rhs);
        public static int3 operator +(int3 lhs, int3 rhs);
        public static int3 operator +(int3 lhs, int rhs);
        public static int3 operator +(int lhs, int3 rhs);
        public static int3 operator -(int3 lhs, int3 rhs);
        public static int3 operator -(int3 lhs, int rhs);
        public static int3 operator -(int lhs, int3 rhs);
        public static int3 operator /(int3 lhs, int3 rhs);
        public static int3 operator /(int3 lhs, int rhs);
        public static int3 operator /(int lhs, int3 rhs);
        public static int3 operator %(int3 lhs, int3 rhs);
        public static int3 operator %(int3 lhs, int rhs);
        public static int3 operator %(int lhs, int3 rhs);
        public static int3 operator ++(int3 val);
        public static int3 operator --(int3 val);
        public static bool3 operator <(int3 lhs, int3 rhs);
        public static bool3 operator <(int3 lhs, int rhs);
        public static bool3 operator <(int lhs, int3 rhs);
        public static bool3 operator <=(int3 lhs, int3 rhs);
        public static bool3 operator <=(int3 lhs, int rhs);
        public static bool3 operator <=(int lhs, int3 rhs);
        public static bool3 operator >(int3 lhs, int3 rhs);
        public static bool3 operator >(int3 lhs, int rhs);
        public static bool3 operator >(int lhs, int3 rhs);
        public static bool3 operator >=(int3 lhs, int3 rhs);
        public static bool3 operator >=(int3 lhs, int rhs);
        public static bool3 operator >=(int lhs, int3 rhs);
        public static int3 operator -(int3 val);
        public static int3 operator +(int3 val);
        public static int3 operator <<(int3 x, int n);
        public static int3 operator >>(int3 x, int n);
        public static bool3 operator ==(int3 lhs, int3 rhs);
        public static bool3 operator ==(int3 lhs, int rhs);
        public static bool3 operator ==(int lhs, int3 rhs);
        public static bool3 operator !=(int3 lhs, int3 rhs);
        public static bool3 operator !=(int3 lhs, int rhs);
        public static bool3 operator !=(int lhs, int3 rhs);
        public static int3 operator ~(int3 val);
        public static int3 operator &(int3 lhs, int3 rhs);
        public static int3 operator &(int3 lhs, int rhs);
        public static int3 operator &(int lhs, int3 rhs);
        public static int3 operator |(int3 lhs, int3 rhs);
        public static int3 operator |(int3 lhs, int rhs);
        public static int3 operator |(int lhs, int3 rhs);
        public static int3 operator ^(int3 lhs, int3 rhs);
        public static int3 operator ^(int3 lhs, int rhs);
        public static int3 operator ^(int lhs, int3 rhs);

        public static implicit operator int3(int v);
        public static explicit operator int3(bool v);
        public static explicit operator int3(bool3 v);
        public static explicit operator int3(uint v);
        public static explicit operator int3(uint3 v);
        public static explicit operator int3(float v);
        public static explicit operator int3(float3 v);
        public static explicit operator int3(double v);
        public static explicit operator int3(double3 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct int3x2 : IEquatable<int3x2>, IFormattable
    {
        public int3 c0;
        public int3 c1;
        public static readonly int3x2 zero;

        public int3x2(int3 c0, int3 c1);
        public int3x2(int m00, int m01, int m10, int m11, int m20, int m21);
        public int3x2(int v);
        public int3x2(bool v);
        public int3x2(bool3x2 v);
        public int3x2(uint v);
        public int3x2(uint3x2 v);
        public int3x2(float v);
        public int3x2(float3x2 v);
        public int3x2(double v);
        public int3x2(double3x2 v);

        public ref int3 this[int index] { get; }

        public bool Equals(int3x2 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static int3x2 operator *(int3x2 lhs, int3x2 rhs);
        public static int3x2 operator *(int3x2 lhs, int rhs);
        public static int3x2 operator *(int lhs, int3x2 rhs);
        public static int3x2 operator +(int3x2 lhs, int3x2 rhs);
        public static int3x2 operator +(int3x2 lhs, int rhs);
        public static int3x2 operator +(int lhs, int3x2 rhs);
        public static int3x2 operator -(int3x2 lhs, int3x2 rhs);
        public static int3x2 operator -(int3x2 lhs, int rhs);
        public static int3x2 operator -(int lhs, int3x2 rhs);
        public static int3x2 operator /(int3x2 lhs, int3x2 rhs);
        public static int3x2 operator /(int3x2 lhs, int rhs);
        public static int3x2 operator /(int lhs, int3x2 rhs);
        public static int3x2 operator %(int3x2 lhs, int3x2 rhs);
        public static int3x2 operator %(int3x2 lhs, int rhs);
        public static int3x2 operator %(int lhs, int3x2 rhs);
        public static int3x2 operator ++(int3x2 val);
        public static int3x2 operator --(int3x2 val);
        public static bool3x2 operator <(int3x2 lhs, int3x2 rhs);
        public static bool3x2 operator <(int3x2 lhs, int rhs);
        public static bool3x2 operator <(int lhs, int3x2 rhs);
        public static bool3x2 operator <=(int3x2 lhs, int3x2 rhs);
        public static bool3x2 operator <=(int3x2 lhs, int rhs);
        public static bool3x2 operator <=(int lhs, int3x2 rhs);
        public static bool3x2 operator >(int3x2 lhs, int3x2 rhs);
        public static bool3x2 operator >(int3x2 lhs, int rhs);
        public static bool3x2 operator >(int lhs, int3x2 rhs);
        public static bool3x2 operator >=(int3x2 lhs, int3x2 rhs);
        public static bool3x2 operator >=(int3x2 lhs, int rhs);
        public static bool3x2 operator >=(int lhs, int3x2 rhs);
        public static int3x2 operator -(int3x2 val);
        public static int3x2 operator +(int3x2 val);
        public static int3x2 operator <<(int3x2 x, int n);
        public static int3x2 operator >>(int3x2 x, int n);
        public static bool3x2 operator ==(int3x2 lhs, int3x2 rhs);
        public static bool3x2 operator ==(int3x2 lhs, int rhs);
        public static bool3x2 operator ==(int lhs, int3x2 rhs);
        public static bool3x2 operator !=(int3x2 lhs, int3x2 rhs);
        public static bool3x2 operator !=(int3x2 lhs, int rhs);
        public static bool3x2 operator !=(int lhs, int3x2 rhs);
        public static int3x2 operator ~(int3x2 val);
        public static int3x2 operator &(int3x2 lhs, int3x2 rhs);
        public static int3x2 operator &(int3x2 lhs, int rhs);
        public static int3x2 operator &(int lhs, int3x2 rhs);
        public static int3x2 operator |(int3x2 lhs, int3x2 rhs);
        public static int3x2 operator |(int3x2 lhs, int rhs);
        public static int3x2 operator |(int lhs, int3x2 rhs);
        public static int3x2 operator ^(int3x2 lhs, int3x2 rhs);
        public static int3x2 operator ^(int3x2 lhs, int rhs);
        public static int3x2 operator ^(int lhs, int3x2 rhs);

        public static implicit operator int3x2(int v);
        public static explicit operator int3x2(bool v);
        public static explicit operator int3x2(bool3x2 v);
        public static explicit operator int3x2(uint v);
        public static explicit operator int3x2(uint3x2 v);
        public static explicit operator int3x2(float v);
        public static explicit operator int3x2(float3x2 v);
        public static explicit operator int3x2(double v);
        public static explicit operator int3x2(double3x2 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct int3x3 : IEquatable<int3x3>, IFormattable
    {
        public int3 c0;
        public int3 c1;
        public int3 c2;
        public static readonly int3x3 identity;
        public static readonly int3x3 zero;

        public int3x3(int3 c0, int3 c1, int3 c2);
        public int3x3(int m00, int m01, int m02, int m10, int m11, int m12, int m20, int m21, int m22);
        public int3x3(int v);
        public int3x3(bool v);
        public int3x3(bool3x3 v);
        public int3x3(uint v);
        public int3x3(uint3x3 v);
        public int3x3(float v);
        public int3x3(float3x3 v);
        public int3x3(double v);
        public int3x3(double3x3 v);

        public ref int3 this[int index] { get; }

        public bool Equals(int3x3 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static int3x3 operator *(int3x3 lhs, int3x3 rhs);
        public static int3x3 operator *(int3x3 lhs, int rhs);
        public static int3x3 operator *(int lhs, int3x3 rhs);
        public static int3x3 operator +(int3x3 lhs, int3x3 rhs);
        public static int3x3 operator +(int3x3 lhs, int rhs);
        public static int3x3 operator +(int lhs, int3x3 rhs);
        public static int3x3 operator -(int3x3 lhs, int3x3 rhs);
        public static int3x3 operator -(int3x3 lhs, int rhs);
        public static int3x3 operator -(int lhs, int3x3 rhs);
        public static int3x3 operator /(int3x3 lhs, int3x3 rhs);
        public static int3x3 operator /(int3x3 lhs, int rhs);
        public static int3x3 operator /(int lhs, int3x3 rhs);
        public static int3x3 operator %(int3x3 lhs, int3x3 rhs);
        public static int3x3 operator %(int3x3 lhs, int rhs);
        public static int3x3 operator %(int lhs, int3x3 rhs);
        public static int3x3 operator ++(int3x3 val);
        public static int3x3 operator --(int3x3 val);
        public static bool3x3 operator <(int3x3 lhs, int3x3 rhs);
        public static bool3x3 operator <(int3x3 lhs, int rhs);
        public static bool3x3 operator <(int lhs, int3x3 rhs);
        public static bool3x3 operator <=(int3x3 lhs, int3x3 rhs);
        public static bool3x3 operator <=(int3x3 lhs, int rhs);
        public static bool3x3 operator <=(int lhs, int3x3 rhs);
        public static bool3x3 operator >(int3x3 lhs, int3x3 rhs);
        public static bool3x3 operator >(int3x3 lhs, int rhs);
        public static bool3x3 operator >(int lhs, int3x3 rhs);
        public static bool3x3 operator >=(int3x3 lhs, int3x3 rhs);
        public static bool3x3 operator >=(int3x3 lhs, int rhs);
        public static bool3x3 operator >=(int lhs, int3x3 rhs);
        public static int3x3 operator -(int3x3 val);
        public static int3x3 operator +(int3x3 val);
        public static int3x3 operator <<(int3x3 x, int n);
        public static int3x3 operator >>(int3x3 x, int n);
        public static bool3x3 operator ==(int3x3 lhs, int3x3 rhs);
        public static bool3x3 operator ==(int3x3 lhs, int rhs);
        public static bool3x3 operator ==(int lhs, int3x3 rhs);
        public static bool3x3 operator !=(int3x3 lhs, int3x3 rhs);
        public static bool3x3 operator !=(int3x3 lhs, int rhs);
        public static bool3x3 operator !=(int lhs, int3x3 rhs);
        public static int3x3 operator ~(int3x3 val);
        public static int3x3 operator &(int3x3 lhs, int3x3 rhs);
        public static int3x3 operator &(int3x3 lhs, int rhs);
        public static int3x3 operator &(int lhs, int3x3 rhs);
        public static int3x3 operator |(int3x3 lhs, int3x3 rhs);
        public static int3x3 operator |(int3x3 lhs, int rhs);
        public static int3x3 operator |(int lhs, int3x3 rhs);
        public static int3x3 operator ^(int3x3 lhs, int3x3 rhs);
        public static int3x3 operator ^(int3x3 lhs, int rhs);
        public static int3x3 operator ^(int lhs, int3x3 rhs);

        public static implicit operator int3x3(int v);
        public static explicit operator int3x3(bool v);
        public static explicit operator int3x3(bool3x3 v);
        public static explicit operator int3x3(uint v);
        public static explicit operator int3x3(uint3x3 v);
        public static explicit operator int3x3(float v);
        public static explicit operator int3x3(float3x3 v);
        public static explicit operator int3x3(double v);
        public static explicit operator int3x3(double3x3 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct int3x4 : IEquatable<int3x4>, IFormattable
    {
        public int3 c0;
        public int3 c1;
        public int3 c2;
        public int3 c3;
        public static readonly int3x4 zero;

        public int3x4(int3 c0, int3 c1, int3 c2, int3 c3);
        public int3x4(int m00, int m01, int m02, int m03, int m10, int m11, int m12, int m13, int m20, int m21, int m22, int m23);
        public int3x4(int v);
        public int3x4(bool v);
        public int3x4(bool3x4 v);
        public int3x4(uint v);
        public int3x4(uint3x4 v);
        public int3x4(float v);
        public int3x4(float3x4 v);
        public int3x4(double v);
        public int3x4(double3x4 v);

        public ref int3 this[int index] { get; }

        public bool Equals(int3x4 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static int3x4 operator *(int3x4 lhs, int3x4 rhs);
        public static int3x4 operator *(int3x4 lhs, int rhs);
        public static int3x4 operator *(int lhs, int3x4 rhs);
        public static int3x4 operator +(int3x4 lhs, int3x4 rhs);
        public static int3x4 operator +(int3x4 lhs, int rhs);
        public static int3x4 operator +(int lhs, int3x4 rhs);
        public static int3x4 operator -(int3x4 lhs, int3x4 rhs);
        public static int3x4 operator -(int3x4 lhs, int rhs);
        public static int3x4 operator -(int lhs, int3x4 rhs);
        public static int3x4 operator /(int3x4 lhs, int3x4 rhs);
        public static int3x4 operator /(int3x4 lhs, int rhs);
        public static int3x4 operator /(int lhs, int3x4 rhs);
        public static int3x4 operator %(int3x4 lhs, int3x4 rhs);
        public static int3x4 operator %(int3x4 lhs, int rhs);
        public static int3x4 operator %(int lhs, int3x4 rhs);
        public static int3x4 operator ++(int3x4 val);
        public static int3x4 operator --(int3x4 val);
        public static bool3x4 operator <(int3x4 lhs, int3x4 rhs);
        public static bool3x4 operator <(int3x4 lhs, int rhs);
        public static bool3x4 operator <(int lhs, int3x4 rhs);
        public static bool3x4 operator <=(int3x4 lhs, int3x4 rhs);
        public static bool3x4 operator <=(int3x4 lhs, int rhs);
        public static bool3x4 operator <=(int lhs, int3x4 rhs);
        public static bool3x4 operator >(int3x4 lhs, int3x4 rhs);
        public static bool3x4 operator >(int3x4 lhs, int rhs);
        public static bool3x4 operator >(int lhs, int3x4 rhs);
        public static bool3x4 operator >=(int3x4 lhs, int3x4 rhs);
        public static bool3x4 operator >=(int3x4 lhs, int rhs);
        public static bool3x4 operator >=(int lhs, int3x4 rhs);
        public static int3x4 operator -(int3x4 val);
        public static int3x4 operator +(int3x4 val);
        public static int3x4 operator <<(int3x4 x, int n);
        public static int3x4 operator >>(int3x4 x, int n);
        public static bool3x4 operator ==(int3x4 lhs, int3x4 rhs);
        public static bool3x4 operator ==(int3x4 lhs, int rhs);
        public static bool3x4 operator ==(int lhs, int3x4 rhs);
        public static bool3x4 operator !=(int3x4 lhs, int3x4 rhs);
        public static bool3x4 operator !=(int3x4 lhs, int rhs);
        public static bool3x4 operator !=(int lhs, int3x4 rhs);
        public static int3x4 operator ~(int3x4 val);
        public static int3x4 operator &(int3x4 lhs, int3x4 rhs);
        public static int3x4 operator &(int3x4 lhs, int rhs);
        public static int3x4 operator &(int lhs, int3x4 rhs);
        public static int3x4 operator |(int3x4 lhs, int3x4 rhs);
        public static int3x4 operator |(int3x4 lhs, int rhs);
        public static int3x4 operator |(int lhs, int3x4 rhs);
        public static int3x4 operator ^(int3x4 lhs, int3x4 rhs);
        public static int3x4 operator ^(int3x4 lhs, int rhs);
        public static int3x4 operator ^(int lhs, int3x4 rhs);

        public static implicit operator int3x4(int v);
        public static explicit operator int3x4(bool v);
        public static explicit operator int3x4(bool3x4 v);
        public static explicit operator int3x4(uint v);
        public static explicit operator int3x4(uint3x4 v);
        public static explicit operator int3x4(float v);
        public static explicit operator int3x4(float3x4 v);
        public static explicit operator int3x4(double v);
        public static explicit operator int3x4(double3x4 v);
    }
}
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    [DebuggerTypeProxy(typeof(DebuggerProxy))]
    public struct int4 : IEquatable<int4>, IFormattable
    {
        public int x;
        public int y;
        public int z;
        public int w;
        public static readonly int4 zero;

        public int4(int x, int y, int z, int w);
        public int4(int x, int y, int2 zw);
        public int4(int x, int2 yz, int w);
        public int4(int x, int3 yzw);
        public int4(int2 xy, int z, int w);
        public int4(int2 xy, int2 zw);
        public int4(int3 xyz, int w);
        public int4(int4 xyzw);
        public int4(int v);
        public int4(bool v);
        public int4(bool4 v);
        public int4(uint v);
        public int4(uint4 v);
        public int4(float v);
        public int4(float4 v);
        public int4(double v);
        public int4(double4 v);

        public int this[int index] { get; set; }
        [EditorBrowsable(Never)]
        public int4 xxxx { get; }
        [EditorBrowsable(Never)]
        public int4 xxxy { get; }
        [EditorBrowsable(Never)]
        public int4 xxxz { get; }
        [EditorBrowsable(Never)]
        public int4 xxxw { get; }
        [EditorBrowsable(Never)]
        public int4 xxyx { get; }
        [EditorBrowsable(Never)]
        public int4 xxyy { get; }
        [EditorBrowsable(Never)]
        public int4 xxyz { get; }
        [EditorBrowsable(Never)]
        public int4 xxyw { get; }
        [EditorBrowsable(Never)]
        public int4 xxzx { get; }
        [EditorBrowsable(Never)]
        public int4 xxzy { get; }
        [EditorBrowsable(Never)]
        public int4 xxzz { get; }
        [EditorBrowsable(Never)]
        public int4 xxzw { get; }
        [EditorBrowsable(Never)]
        public int4 xxwx { get; }
        [EditorBrowsable(Never)]
        public int4 xxwy { get; }
        [EditorBrowsable(Never)]
        public int4 xxwz { get; }
        [EditorBrowsable(Never)]
        public int4 xxww { get; }
        [EditorBrowsable(Never)]
        public int4 xyxx { get; }
        [EditorBrowsable(Never)]
        public int4 xyxy { get; }
        [EditorBrowsable(Never)]
        public int4 xyxz { get; }
        [EditorBrowsable(Never)]
        public int4 xyxw { get; }
        [EditorBrowsable(Never)]
        public int4 xyyx { get; }
        [EditorBrowsable(Never)]
        public int4 xyyy { get; }
        [EditorBrowsable(Never)]
        public int4 xyyz { get; }
        [EditorBrowsable(Never)]
        public int4 xyyw { get; }
        [EditorBrowsable(Never)]
        public int4 xyzx { get; }
        [EditorBrowsable(Never)]
        public int4 xyzy { get; }
        [EditorBrowsable(Never)]
        public int4 xyzz { get; }
        [EditorBrowsable(Never)]
        public int4 xyzw { get; set; }
        [EditorBrowsable(Never)]
        public int4 xywx { get; }
        [EditorBrowsable(Never)]
        public int4 xywy { get; }
        [EditorBrowsable(Never)]
        public int4 xywz { get; set; }
        [EditorBrowsable(Never)]
        public int4 xyww { get; }
        [EditorBrowsable(Never)]
        public int4 xzxx { get; }
        [EditorBrowsable(Never)]
        public int4 xzxy { get; }
        [EditorBrowsable(Never)]
        public int4 xzxz { get; }
        [EditorBrowsable(Never)]
        public int4 xzxw { get; }
        [EditorBrowsable(Never)]
        public int4 xzyx { get; }
        [EditorBrowsable(Never)]
        public int4 xzyy { get; }
        [EditorBrowsable(Never)]
        public int4 xzyz { get; }
        [EditorBrowsable(Never)]
        public int4 xzyw { get; set; }
        [EditorBrowsable(Never)]
        public int4 xzzx { get; }
        [EditorBrowsable(Never)]
        public int4 xzzy { get; }
        [EditorBrowsable(Never)]
        public int4 xzzz { get; }
        [EditorBrowsable(Never)]
        public int4 xzzw { get; }
        [EditorBrowsable(Never)]
        public int4 xzwx { get; }
        [EditorBrowsable(Never)]
        public int4 xzwy { get; set; }
        [EditorBrowsable(Never)]
        public int4 xzwz { get; }
        [EditorBrowsable(Never)]
        public int4 xzww { get; }
        [EditorBrowsable(Never)]
        public int4 xwxx { get; }
        [EditorBrowsable(Never)]
        public int4 xwxy { get; }
        [EditorBrowsable(Never)]
        public int4 xwxz { get; }
        [EditorBrowsable(Never)]
        public int4 xwxw { get; }
        [EditorBrowsable(Never)]
        public int4 xwyx { get; }
        [EditorBrowsable(Never)]
        public int4 xwyy { get; }
        [EditorBrowsable(Never)]
        public int4 xwyz { get; set; }
        [EditorBrowsable(Never)]
        public int4 xwyw { get; }
        [EditorBrowsable(Never)]
        public int4 xwzx { get; }
        [EditorBrowsable(Never)]
        public int4 xwzy { get; set; }
        [EditorBrowsable(Never)]
        public int4 xwzz { get; }
        [EditorBrowsable(Never)]
        public int4 xwzw { get; }
        [EditorBrowsable(Never)]
        public int4 xwwx { get; }
        [EditorBrowsable(Never)]
        public int4 xwwy { get; }
        [EditorBrowsable(Never)]
        public int4 xwwz { get; }
        [EditorBrowsable(Never)]
        public int4 xwww { get; }
        [EditorBrowsable(Never)]
        public int4 yxxx { get; }
        [EditorBrowsable(Never)]
        public int4 yxxy { get; }
        [EditorBrowsable(Never)]
        public int4 yxxz { get; }
        [EditorBrowsable(Never)]
        public int4 yxxw { get; }
        [EditorBrowsable(Never)]
        public int4 yxyx { get; }
        [EditorBrowsable(Never)]
        public int4 yxyy { get; }
        [EditorBrowsable(Never)]
        public int4 yxyz { get; }
        [EditorBrowsable(Never)]
        public int4 yxyw { get; }
        [EditorBrowsable(Never)]
        public int4 yxzx { get; }
        [EditorBrowsable(Never)]
        public int4 yxzy { get; }
        [EditorBrowsable(Never)]
        public int4 yxzz { get; }
        [EditorBrowsable(Never)]
        public int4 yxzw { get; set; }
        [EditorBrowsable(Never)]
        public int4 yxwx { get; }
        [EditorBrowsable(Never)]
        public int4 yxwy { get; }
        [EditorBrowsable(Never)]
        public int4 yxwz { get; set; }
        [EditorBrowsable(Never)]
        public int4 yxww { get; }
        [EditorBrowsable(Never)]
        public int4 yyxx { get; }
        [EditorBrowsable(Never)]
        public int4 yyxy { get; }
        [EditorBrowsable(Never)]
        public int4 yyxz { get; }
        [EditorBrowsable(Never)]
        public int4 yyxw { get; }
        [EditorBrowsable(Never)]
        public int4 yyyx { get; }
        [EditorBrowsable(Never)]
        public int4 yyyy { get; }
        [EditorBrowsable(Never)]
        public int4 yyyz { get; }
        [EditorBrowsable(Never)]
        public int4 yyyw { get; }
        [EditorBrowsable(Never)]
        public int4 yyzx { get; }
        [EditorBrowsable(Never)]
        public int4 yyzy { get; }
        [EditorBrowsable(Never)]
        public int4 yyzz { get; }
        [EditorBrowsable(Never)]
        public int4 yyzw { get; }
        [EditorBrowsable(Never)]
        public int4 yywx { get; }
        [EditorBrowsable(Never)]
        public int4 yywy { get; }
        [EditorBrowsable(Never)]
        public int4 yywz { get; }
        [EditorBrowsable(Never)]
        public int4 yyww { get; }
        [EditorBrowsable(Never)]
        public int4 yzxx { get; }
        [EditorBrowsable(Never)]
        public int4 yzxy { get; }
        [EditorBrowsable(Never)]
        public int4 yzxz { get; }
        [EditorBrowsable(Never)]
        public int4 yzxw { get; set; }
        [EditorBrowsable(Never)]
        public int4 yzyx { get; }
        [EditorBrowsable(Never)]
        public int4 yzyy { get; }
        [EditorBrowsable(Never)]
        public int4 yzyz { get; }
        [EditorBrowsable(Never)]
        public int4 yzyw { get; }
        [EditorBrowsable(Never)]
        public int4 yzzx { get; }
        [EditorBrowsable(Never)]
        public int4 yzzy { get; }
        [EditorBrowsable(Never)]
        public int4 yzzz { get; }
        [EditorBrowsable(Never)]
        public int4 yzzw { get; }
        [EditorBrowsable(Never)]
        public int4 yzwx { get; set; }
        [EditorBrowsable(Never)]
        public int4 yzwy { get; }
        [EditorBrowsable(Never)]
        public int4 yzwz { get; }
        [EditorBrowsable(Never)]
        public int4 yzww { get; }
        [EditorBrowsable(Never)]
        public int4 ywxx { get; }
        [EditorBrowsable(Never)]
        public int4 ywxy { get; }
        [EditorBrowsable(Never)]
        public int4 ywxz { get; set; }
        [EditorBrowsable(Never)]
        public int4 ywxw { get; }
        [EditorBrowsable(Never)]
        public int4 ywyx { get; }
        [EditorBrowsable(Never)]
        public int4 ywyy { get; }
        [EditorBrowsable(Never)]
        public int4 ywyz { get; }
        [EditorBrowsable(Never)]
        public int4 ywyw { get; }
        [EditorBrowsable(Never)]
        public int4 ywzx { get; set; }
        [EditorBrowsable(Never)]
        public int4 ywzy { get; }
        [EditorBrowsable(Never)]
        public int4 ywzz { get; }
        [EditorBrowsable(Never)]
        public int4 ywzw { get; }
        [EditorBrowsable(Never)]
        public int4 ywwx { get; }
        [EditorBrowsable(Never)]
        public int4 ywwy { get; }
        [EditorBrowsable(Never)]
        public int4 ywwz { get; }
        [EditorBrowsable(Never)]
        public int4 ywww { get; }
        [EditorBrowsable(Never)]
        public int4 zxxx { get; }
        [EditorBrowsable(Never)]
        public int4 zxxy { get; }
        [EditorBrowsable(Never)]
        public int4 zxxz { get; }
        [EditorBrowsable(Never)]
        public int4 zxxw { get; }
        [EditorBrowsable(Never)]
        public int4 zxyx { get; }
        [EditorBrowsable(Never)]
        public int4 zxyy { get; }
        [EditorBrowsable(Never)]
        public int4 zxyz { get; }
        [EditorBrowsable(Never)]
        public int4 zxyw { get; set; }
        [EditorBrowsable(Never)]
        public int4 zxzx { get; }
        [EditorBrowsable(Never)]
        public int4 zxzy { get; }
        [EditorBrowsable(Never)]
        public int4 zxzz { get; }
        [EditorBrowsable(Never)]
        public int4 zxzw { get; }
        [EditorBrowsable(Never)]
        public int4 zxwx { get; }
        [EditorBrowsable(Never)]
        public int4 zxwy { get; set; }
        [EditorBrowsable(Never)]
        public int4 zxwz { get; }
        [EditorBrowsable(Never)]
        public int4 zxww { get; }
        [EditorBrowsable(Never)]
        public int4 zyxx { get; }
        [EditorBrowsable(Never)]
        public int4 zyxy { get; }
        [EditorBrowsable(Never)]
        public int4 zyxz { get; }
        [EditorBrowsable(Never)]
        public int4 zyxw { get; set; }
        [EditorBrowsable(Never)]
        public int4 zyyx { get; }
        [EditorBrowsable(Never)]
        public int4 zyyy { get; }
        [EditorBrowsable(Never)]
        public int4 zyyz { get; }
        [EditorBrowsable(Never)]
        public int4 zyyw { get; }
        [EditorBrowsable(Never)]
        public int4 zyzx { get; }
        [EditorBrowsable(Never)]
        public int4 zyzy { get; }
        [EditorBrowsable(Never)]
        public int4 zyzz { get; }
        [EditorBrowsable(Never)]
        public int4 zyzw { get; }
        [EditorBrowsable(Never)]
        public int4 zywx { get; set; }
        [EditorBrowsable(Never)]
        public int4 zywy { get; }
        [EditorBrowsable(Never)]
        public int4 zywz { get; }
        [EditorBrowsable(Never)]
        public int4 zyww { get; }
        [EditorBrowsable(Never)]
        public int4 zzxx { get; }
        [EditorBrowsable(Never)]
        public int4 zzxy { get; }
        [EditorBrowsable(Never)]
        public int4 zzxz { get; }
        [EditorBrowsable(Never)]
        public int4 zzxw { get; }
        [EditorBrowsable(Never)]
        public int4 zzyx { get; }
        [EditorBrowsable(Never)]
        public int4 zzyy { get; }
        [EditorBrowsable(Never)]
        public int4 zzyz { get; }
        [EditorBrowsable(Never)]
        public int4 zzyw { get; }
        [EditorBrowsable(Never)]
        public int4 zzzx { get; }
        [EditorBrowsable(Never)]
        public int4 zzzy { get; }
        [EditorBrowsable(Never)]
        public int4 zzzz { get; }
        [EditorBrowsable(Never)]
        public int4 zzzw { get; }
        [EditorBrowsable(Never)]
        public int4 zzwx { get; }
        [EditorBrowsable(Never)]
        public int4 zzwy { get; }
        [EditorBrowsable(Never)]
        public int4 zzwz { get; }
        [EditorBrowsable(Never)]
        public int4 zzww { get; }
        [EditorBrowsable(Never)]
        public int4 zwxx { get; }
        [EditorBrowsable(Never)]
        public int4 zwxy { get; set; }
        [EditorBrowsable(Never)]
        public int4 zwxz { get; }
        [EditorBrowsable(Never)]
        public int4 zwxw { get; }
        [EditorBrowsable(Never)]
        public int4 zwyx { get; set; }
        [EditorBrowsable(Never)]
        public int4 zwyy { get; }
        [EditorBrowsable(Never)]
        public int4 zwyz { get; }
        [EditorBrowsable(Never)]
        public int4 zwyw { get; }
        [EditorBrowsable(Never)]
        public int4 zwzx { get; }
        [EditorBrowsable(Never)]
        public int4 zwzy { get; }
        [EditorBrowsable(Never)]
        public int4 zwzz { get; }
        [EditorBrowsable(Never)]
        public int4 zwzw { get; }
        [EditorBrowsable(Never)]
        public int4 zwwx { get; }
        [EditorBrowsable(Never)]
        public int4 zwwy { get; }
        [EditorBrowsable(Never)]
        public int4 zwwz { get; }
        [EditorBrowsable(Never)]
        public int4 zwww { get; }
        [EditorBrowsable(Never)]
        public int4 wxxx { get; }
        [EditorBrowsable(Never)]
        public int4 wxxy { get; }
        [EditorBrowsable(Never)]
        public int4 wxxz { get; }
        [EditorBrowsable(Never)]
        public int4 wxxw { get; }
        [EditorBrowsable(Never)]
        public int4 wxyx { get; }
        [EditorBrowsable(Never)]
        public int4 wxyy { get; }
        [EditorBrowsable(Never)]
        public int4 wxyz { get; set; }
        [EditorBrowsable(Never)]
        public int4 wxyw { get; }
        [EditorBrowsable(Never)]
        public int4 wxzx { get; }
        [EditorBrowsable(Never)]
        public int4 wxzy { get; set; }
        [EditorBrowsable(Never)]
        public int4 wxzz { get; }
        [EditorBrowsable(Never)]
        public int4 wxzw { get; }
        [EditorBrowsable(Never)]
        public int4 wxwx { get; }
        [EditorBrowsable(Never)]
        public int4 wxwy { get; }
        [EditorBrowsable(Never)]
        public int4 wxwz { get; }
        [EditorBrowsable(Never)]
        public int4 wxww { get; }
        [EditorBrowsable(Never)]
        public int4 wyxx { get; }
        [EditorBrowsable(Never)]
        public int4 wyxy { get; }
        [EditorBrowsable(Never)]
        public int4 wyxz { get; set; }
        [EditorBrowsable(Never)]
        public int4 wyxw { get; }
        [EditorBrowsable(Never)]
        public int4 wyyx { get; }
        [EditorBrowsable(Never)]
        public int4 wyyy { get; }
        [EditorBrowsable(Never)]
        public int4 wyyz { get; }
        [EditorBrowsable(Never)]
        public int4 wyyw { get; }
        [EditorBrowsable(Never)]
        public int4 wyzx { get; set; }
        [EditorBrowsable(Never)]
        public int4 wyzy { get; }
        [EditorBrowsable(Never)]
        public int4 wyzz { get; }
        [EditorBrowsable(Never)]
        public int4 wyzw { get; }
        [EditorBrowsable(Never)]
        public int4 wywx { get; }
        [EditorBrowsable(Never)]
        public int4 wywy { get; }
        [EditorBrowsable(Never)]
        public int4 wywz { get; }
        [EditorBrowsable(Never)]
        public int4 wyww { get; }
        [EditorBrowsable(Never)]
        public int4 wzxx { get; }
        [EditorBrowsable(Never)]
        public int4 wzxy { get; set; }
        [EditorBrowsable(Never)]
        public int4 wzxz { get; }
        [EditorBrowsable(Never)]
        public int4 wzxw { get; }
        [EditorBrowsable(Never)]
        public int4 wzyx { get; set; }
        [EditorBrowsable(Never)]
        public int4 wzyy { get; }
        [EditorBrowsable(Never)]
        public int4 wzyz { get; }
        [EditorBrowsable(Never)]
        public int4 wzyw { get; }
        [EditorBrowsable(Never)]
        public int4 wzzx { get; }
        [EditorBrowsable(Never)]
        public int4 wzzy { get; }
        [EditorBrowsable(Never)]
        public int4 wzzz { get; }
        [EditorBrowsable(Never)]
        public int4 wzzw { get; }
        [EditorBrowsable(Never)]
        public int4 wzwx { get; }
        [EditorBrowsable(Never)]
        public int4 wzwy { get; }
        [EditorBrowsable(Never)]
        public int4 wzwz { get; }
        [EditorBrowsable(Never)]
        public int4 wzww { get; }
        [EditorBrowsable(Never)]
        public int4 wwxx { get; }
        [EditorBrowsable(Never)]
        public int4 wwxy { get; }
        [EditorBrowsable(Never)]
        public int4 wwxz { get; }
        [EditorBrowsable(Never)]
        public int4 wwxw { get; }
        [EditorBrowsable(Never)]
        public int4 wwyx { get; }
        [EditorBrowsable(Never)]
        public int4 wwyy { get; }
        [EditorBrowsable(Never)]
        public int4 wwyz { get; }
        [EditorBrowsable(Never)]
        public int4 wwyw { get; }
        [EditorBrowsable(Never)]
        public int4 wwzx { get; }
        [EditorBrowsable(Never)]
        public int4 wwzy { get; }
        [EditorBrowsable(Never)]
        public int4 wwzz { get; }
        [EditorBrowsable(Never)]
        public int4 wwzw { get; }
        [EditorBrowsable(Never)]
        public int4 wwwx { get; }
        [EditorBrowsable(Never)]
        public int4 wwwy { get; }
        [EditorBrowsable(Never)]
        public int4 wwwz { get; }
        [EditorBrowsable(Never)]
        public int4 wwww { get; }
        [EditorBrowsable(Never)]
        public int3 xxx { get; }
        [EditorBrowsable(Never)]
        public int3 xxy { get; }
        [EditorBrowsable(Never)]
        public int3 xxz { get; }
        [EditorBrowsable(Never)]
        public int3 xxw { get; }
        [EditorBrowsable(Never)]
        public int3 xyx { get; }
        [EditorBrowsable(Never)]
        public int3 xyy { get; }
        [EditorBrowsable(Never)]
        public int3 xyz { get; set; }
        [EditorBrowsable(Never)]
        public int3 xyw { get; set; }
        [EditorBrowsable(Never)]
        public int3 xzx { get; }
        [EditorBrowsable(Never)]
        public int3 xzy { get; set; }
        [EditorBrowsable(Never)]
        public int3 xzz { get; }
        [EditorBrowsable(Never)]
        public int3 xzw { get; set; }
        [EditorBrowsable(Never)]
        public int3 xwx { get; }
        [EditorBrowsable(Never)]
        public int3 xwy { get; set; }
        [EditorBrowsable(Never)]
        public int3 xwz { get; set; }
        [EditorBrowsable(Never)]
        public int3 xww { get; }
        [EditorBrowsable(Never)]
        public int3 yxx { get; }
        [EditorBrowsable(Never)]
        public int3 yxy { get; }
        [EditorBrowsable(Never)]
        public int3 yxz { get; set; }
        [EditorBrowsable(Never)]
        public int3 yxw { get; set; }
        [EditorBrowsable(Never)]
        public int3 yyx { get; }
        [EditorBrowsable(Never)]
        public int3 yyy { get; }
        [EditorBrowsable(Never)]
        public int3 yyz { get; }
        [EditorBrowsable(Never)]
        public int3 yyw { get; }
        [EditorBrowsable(Never)]
        public int3 yzx { get; set; }
        [EditorBrowsable(Never)]
        public int3 yzy { get; }
        [EditorBrowsable(Never)]
        public int3 yzz { get; }
        [EditorBrowsable(Never)]
        public int3 yzw { get; set; }
        [EditorBrowsable(Never)]
        public int3 ywx { get; set; }
        [EditorBrowsable(Never)]
        public int3 ywy { get; }
        [EditorBrowsable(Never)]
        public int3 ywz { get; set; }
        [EditorBrowsable(Never)]
        public int3 yww { get; }
        [EditorBrowsable(Never)]
        public int3 zxx { get; }
        [EditorBrowsable(Never)]
        public int3 zxy { get; set; }
        [EditorBrowsable(Never)]
        public int3 zxz { get; }
        [EditorBrowsable(Never)]
        public int3 zxw { get; set; }
        [EditorBrowsable(Never)]
        public int3 zyx { get; set; }
        [EditorBrowsable(Never)]
        public int3 zyy { get; }
        [EditorBrowsable(Never)]
        public int3 zyz { get; }
        [EditorBrowsable(Never)]
        public int3 zyw { get; set; }
        [EditorBrowsable(Never)]
        public int3 zzx { get; }
        [EditorBrowsable(Never)]
        public int3 zzy { get; }
        [EditorBrowsable(Never)]
        public int3 zzz { get; }
        [EditorBrowsable(Never)]
        public int3 zzw { get; }
        [EditorBrowsable(Never)]
        public int3 zwx { get; set; }
        [EditorBrowsable(Never)]
        public int3 zwy { get; set; }
        [EditorBrowsable(Never)]
        public int3 zwz { get; }
        [EditorBrowsable(Never)]
        public int3 zww { get; }
        [EditorBrowsable(Never)]
        public int3 wxx { get; }
        [EditorBrowsable(Never)]
        public int3 wxy { get; set; }
        [EditorBrowsable(Never)]
        public int3 wxz { get; set; }
        [EditorBrowsable(Never)]
        public int3 wxw { get; }
        [EditorBrowsable(Never)]
        public int3 wyx { get; set; }
        [EditorBrowsable(Never)]
        public int3 wyy { get; }
        [EditorBrowsable(Never)]
        public int3 wyz { get; set; }
        [EditorBrowsable(Never)]
        public int3 wyw { get; }
        [EditorBrowsable(Never)]
        public int3 wzx { get; set; }
        [EditorBrowsable(Never)]
        public int3 wzy { get; set; }
        [EditorBrowsable(Never)]
        public int3 wzz { get; }
        [EditorBrowsable(Never)]
        public int3 wzw { get; }
        [EditorBrowsable(Never)]
        public int3 wwx { get; }
        [EditorBrowsable(Never)]
        public int3 wwy { get; }
        [EditorBrowsable(Never)]
        public int3 wwz { get; }
        [EditorBrowsable(Never)]
        public int3 www { get; }
        [EditorBrowsable(Never)]
        public int2 xx { get; }
        [EditorBrowsable(Never)]
        public int2 xy { get; set; }
        [EditorBrowsable(Never)]
        public int2 xz { get; set; }
        [EditorBrowsable(Never)]
        public int2 xw { get; set; }
        [EditorBrowsable(Never)]
        public int2 yx { get; set; }
        [EditorBrowsable(Never)]
        public int2 yy { get; }
        [EditorBrowsable(Never)]
        public int2 yz { get; set; }
        [EditorBrowsable(Never)]
        public int2 yw { get; set; }
        [EditorBrowsable(Never)]
        public int2 zx { get; set; }
        [EditorBrowsable(Never)]
        public int2 zy { get; set; }
        [EditorBrowsable(Never)]
        public int2 zz { get; }
        [EditorBrowsable(Never)]
        public int2 zw { get; set; }
        [EditorBrowsable(Never)]
        public int2 wx { get; set; }
        [EditorBrowsable(Never)]
        public int2 wy { get; set; }
        [EditorBrowsable(Never)]
        public int2 wz { get; set; }
        [EditorBrowsable(Never)]
        public int2 ww { get; }

        public bool Equals(int4 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static int4 operator *(int4 lhs, int4 rhs);
        public static int4 operator *(int4 lhs, int rhs);
        public static int4 operator *(int lhs, int4 rhs);
        public static int4 operator +(int4 lhs, int4 rhs);
        public static int4 operator +(int4 lhs, int rhs);
        public static int4 operator +(int lhs, int4 rhs);
        public static int4 operator -(int4 lhs, int4 rhs);
        public static int4 operator -(int4 lhs, int rhs);
        public static int4 operator -(int lhs, int4 rhs);
        public static int4 operator /(int4 lhs, int4 rhs);
        public static int4 operator /(int4 lhs, int rhs);
        public static int4 operator /(int lhs, int4 rhs);
        public static int4 operator %(int4 lhs, int4 rhs);
        public static int4 operator %(int4 lhs, int rhs);
        public static int4 operator %(int lhs, int4 rhs);
        public static int4 operator ++(int4 val);
        public static int4 operator --(int4 val);
        public static bool4 operator <(int4 lhs, int4 rhs);
        public static bool4 operator <(int4 lhs, int rhs);
        public static bool4 operator <(int lhs, int4 rhs);
        public static bool4 operator <=(int4 lhs, int4 rhs);
        public static bool4 operator <=(int4 lhs, int rhs);
        public static bool4 operator <=(int lhs, int4 rhs);
        public static bool4 operator >(int4 lhs, int4 rhs);
        public static bool4 operator >(int4 lhs, int rhs);
        public static bool4 operator >(int lhs, int4 rhs);
        public static bool4 operator >=(int4 lhs, int4 rhs);
        public static bool4 operator >=(int4 lhs, int rhs);
        public static bool4 operator >=(int lhs, int4 rhs);
        public static int4 operator -(int4 val);
        public static int4 operator +(int4 val);
        public static int4 operator <<(int4 x, int n);
        public static int4 operator >>(int4 x, int n);
        public static bool4 operator ==(int4 lhs, int4 rhs);
        public static bool4 operator ==(int4 lhs, int rhs);
        public static bool4 operator ==(int lhs, int4 rhs);
        public static bool4 operator !=(int4 lhs, int4 rhs);
        public static bool4 operator !=(int4 lhs, int rhs);
        public static bool4 operator !=(int lhs, int4 rhs);
        public static int4 operator ~(int4 val);
        public static int4 operator &(int4 lhs, int4 rhs);
        public static int4 operator &(int4 lhs, int rhs);
        public static int4 operator &(int lhs, int4 rhs);
        public static int4 operator |(int4 lhs, int4 rhs);
        public static int4 operator |(int4 lhs, int rhs);
        public static int4 operator |(int lhs, int4 rhs);
        public static int4 operator ^(int4 lhs, int4 rhs);
        public static int4 operator ^(int4 lhs, int rhs);
        public static int4 operator ^(int lhs, int4 rhs);

        public static implicit operator int4(int v);
        public static explicit operator int4(bool v);
        public static explicit operator int4(bool4 v);
        public static explicit operator int4(uint v);
        public static explicit operator int4(uint4 v);
        public static explicit operator int4(float v);
        public static explicit operator int4(float4 v);
        public static explicit operator int4(double v);
        public static explicit operator int4(double4 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct int4x2 : IEquatable<int4x2>, IFormattable
    {
        public int4 c0;
        public int4 c1;
        public static readonly int4x2 zero;

        public int4x2(int4 c0, int4 c1);
        public int4x2(int m00, int m01, int m10, int m11, int m20, int m21, int m30, int m31);
        public int4x2(int v);
        public int4x2(bool v);
        public int4x2(bool4x2 v);
        public int4x2(uint v);
        public int4x2(uint4x2 v);
        public int4x2(float v);
        public int4x2(float4x2 v);
        public int4x2(double v);
        public int4x2(double4x2 v);

        public ref int4 this[int index] { get; }

        public bool Equals(int4x2 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static int4x2 operator *(int4x2 lhs, int4x2 rhs);
        public static int4x2 operator *(int4x2 lhs, int rhs);
        public static int4x2 operator *(int lhs, int4x2 rhs);
        public static int4x2 operator +(int4x2 lhs, int4x2 rhs);
        public static int4x2 operator +(int4x2 lhs, int rhs);
        public static int4x2 operator +(int lhs, int4x2 rhs);
        public static int4x2 operator -(int4x2 lhs, int4x2 rhs);
        public static int4x2 operator -(int4x2 lhs, int rhs);
        public static int4x2 operator -(int lhs, int4x2 rhs);
        public static int4x2 operator /(int4x2 lhs, int4x2 rhs);
        public static int4x2 operator /(int4x2 lhs, int rhs);
        public static int4x2 operator /(int lhs, int4x2 rhs);
        public static int4x2 operator %(int4x2 lhs, int4x2 rhs);
        public static int4x2 operator %(int4x2 lhs, int rhs);
        public static int4x2 operator %(int lhs, int4x2 rhs);
        public static int4x2 operator ++(int4x2 val);
        public static int4x2 operator --(int4x2 val);
        public static bool4x2 operator <(int4x2 lhs, int4x2 rhs);
        public static bool4x2 operator <(int4x2 lhs, int rhs);
        public static bool4x2 operator <(int lhs, int4x2 rhs);
        public static bool4x2 operator <=(int4x2 lhs, int4x2 rhs);
        public static bool4x2 operator <=(int4x2 lhs, int rhs);
        public static bool4x2 operator <=(int lhs, int4x2 rhs);
        public static bool4x2 operator >(int4x2 lhs, int4x2 rhs);
        public static bool4x2 operator >(int4x2 lhs, int rhs);
        public static bool4x2 operator >(int lhs, int4x2 rhs);
        public static bool4x2 operator >=(int4x2 lhs, int4x2 rhs);
        public static bool4x2 operator >=(int4x2 lhs, int rhs);
        public static bool4x2 operator >=(int lhs, int4x2 rhs);
        public static int4x2 operator -(int4x2 val);
        public static int4x2 operator +(int4x2 val);
        public static int4x2 operator <<(int4x2 x, int n);
        public static int4x2 operator >>(int4x2 x, int n);
        public static bool4x2 operator ==(int4x2 lhs, int4x2 rhs);
        public static bool4x2 operator ==(int4x2 lhs, int rhs);
        public static bool4x2 operator ==(int lhs, int4x2 rhs);
        public static bool4x2 operator !=(int4x2 lhs, int4x2 rhs);
        public static bool4x2 operator !=(int4x2 lhs, int rhs);
        public static bool4x2 operator !=(int lhs, int4x2 rhs);
        public static int4x2 operator ~(int4x2 val);
        public static int4x2 operator &(int4x2 lhs, int4x2 rhs);
        public static int4x2 operator &(int4x2 lhs, int rhs);
        public static int4x2 operator &(int lhs, int4x2 rhs);
        public static int4x2 operator |(int4x2 lhs, int4x2 rhs);
        public static int4x2 operator |(int4x2 lhs, int rhs);
        public static int4x2 operator |(int lhs, int4x2 rhs);
        public static int4x2 operator ^(int4x2 lhs, int4x2 rhs);
        public static int4x2 operator ^(int4x2 lhs, int rhs);
        public static int4x2 operator ^(int lhs, int4x2 rhs);

        public static implicit operator int4x2(int v);
        public static explicit operator int4x2(bool v);
        public static explicit operator int4x2(bool4x2 v);
        public static explicit operator int4x2(uint v);
        public static explicit operator int4x2(uint4x2 v);
        public static explicit operator int4x2(float v);
        public static explicit operator int4x2(float4x2 v);
        public static explicit operator int4x2(double v);
        public static explicit operator int4x2(double4x2 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct int4x3 : IEquatable<int4x3>, IFormattable
    {
        public int4 c0;
        public int4 c1;
        public int4 c2;
        public static readonly int4x3 zero;

        public int4x3(int4 c0, int4 c1, int4 c2);
        public int4x3(int m00, int m01, int m02, int m10, int m11, int m12, int m20, int m21, int m22, int m30, int m31, int m32);
        public int4x3(int v);
        public int4x3(bool v);
        public int4x3(bool4x3 v);
        public int4x3(uint v);
        public int4x3(uint4x3 v);
        public int4x3(float v);
        public int4x3(float4x3 v);
        public int4x3(double v);
        public int4x3(double4x3 v);

        public ref int4 this[int index] { get; }

        public bool Equals(int4x3 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static int4x3 operator *(int4x3 lhs, int4x3 rhs);
        public static int4x3 operator *(int4x3 lhs, int rhs);
        public static int4x3 operator *(int lhs, int4x3 rhs);
        public static int4x3 operator +(int4x3 lhs, int4x3 rhs);
        public static int4x3 operator +(int4x3 lhs, int rhs);
        public static int4x3 operator +(int lhs, int4x3 rhs);
        public static int4x3 operator -(int4x3 lhs, int4x3 rhs);
        public static int4x3 operator -(int4x3 lhs, int rhs);
        public static int4x3 operator -(int lhs, int4x3 rhs);
        public static int4x3 operator /(int4x3 lhs, int4x3 rhs);
        public static int4x3 operator /(int4x3 lhs, int rhs);
        public static int4x3 operator /(int lhs, int4x3 rhs);
        public static int4x3 operator %(int4x3 lhs, int4x3 rhs);
        public static int4x3 operator %(int4x3 lhs, int rhs);
        public static int4x3 operator %(int lhs, int4x3 rhs);
        public static int4x3 operator ++(int4x3 val);
        public static int4x3 operator --(int4x3 val);
        public static bool4x3 operator <(int4x3 lhs, int4x3 rhs);
        public static bool4x3 operator <(int4x3 lhs, int rhs);
        public static bool4x3 operator <(int lhs, int4x3 rhs);
        public static bool4x3 operator <=(int4x3 lhs, int4x3 rhs);
        public static bool4x3 operator <=(int4x3 lhs, int rhs);
        public static bool4x3 operator <=(int lhs, int4x3 rhs);
        public static bool4x3 operator >(int4x3 lhs, int4x3 rhs);
        public static bool4x3 operator >(int4x3 lhs, int rhs);
        public static bool4x3 operator >(int lhs, int4x3 rhs);
        public static bool4x3 operator >=(int4x3 lhs, int4x3 rhs);
        public static bool4x3 operator >=(int4x3 lhs, int rhs);
        public static bool4x3 operator >=(int lhs, int4x3 rhs);
        public static int4x3 operator -(int4x3 val);
        public static int4x3 operator +(int4x3 val);
        public static int4x3 operator <<(int4x3 x, int n);
        public static int4x3 operator >>(int4x3 x, int n);
        public static bool4x3 operator ==(int4x3 lhs, int4x3 rhs);
        public static bool4x3 operator ==(int4x3 lhs, int rhs);
        public static bool4x3 operator ==(int lhs, int4x3 rhs);
        public static bool4x3 operator !=(int4x3 lhs, int4x3 rhs);
        public static bool4x3 operator !=(int4x3 lhs, int rhs);
        public static bool4x3 operator !=(int lhs, int4x3 rhs);
        public static int4x3 operator ~(int4x3 val);
        public static int4x3 operator &(int4x3 lhs, int4x3 rhs);
        public static int4x3 operator &(int4x3 lhs, int rhs);
        public static int4x3 operator &(int lhs, int4x3 rhs);
        public static int4x3 operator |(int4x3 lhs, int4x3 rhs);
        public static int4x3 operator |(int4x3 lhs, int rhs);
        public static int4x3 operator |(int lhs, int4x3 rhs);
        public static int4x3 operator ^(int4x3 lhs, int4x3 rhs);
        public static int4x3 operator ^(int4x3 lhs, int rhs);
        public static int4x3 operator ^(int lhs, int4x3 rhs);

        public static implicit operator int4x3(int v);
        public static explicit operator int4x3(bool v);
        public static explicit operator int4x3(bool4x3 v);
        public static explicit operator int4x3(uint v);
        public static explicit operator int4x3(uint4x3 v);
        public static explicit operator int4x3(float v);
        public static explicit operator int4x3(float4x3 v);
        public static explicit operator int4x3(double v);
        public static explicit operator int4x3(double4x3 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct int4x4 : IEquatable<int4x4>, IFormattable
    {
        public int4 c0;
        public int4 c1;
        public int4 c2;
        public int4 c3;
        public static readonly int4x4 identity;
        public static readonly int4x4 zero;

        public int4x4(int4 c0, int4 c1, int4 c2, int4 c3);
        public int4x4(int m00, int m01, int m02, int m03, int m10, int m11, int m12, int m13, int m20, int m21, int m22, int m23, int m30, int m31, int m32, int m33);
        public int4x4(int v);
        public int4x4(bool v);
        public int4x4(bool4x4 v);
        public int4x4(uint v);
        public int4x4(uint4x4 v);
        public int4x4(float v);
        public int4x4(float4x4 v);
        public int4x4(double v);
        public int4x4(double4x4 v);

        public ref int4 this[int index] { get; }

        public bool Equals(int4x4 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static int4x4 operator *(int4x4 lhs, int4x4 rhs);
        public static int4x4 operator *(int4x4 lhs, int rhs);
        public static int4x4 operator *(int lhs, int4x4 rhs);
        public static int4x4 operator +(int4x4 lhs, int4x4 rhs);
        public static int4x4 operator +(int4x4 lhs, int rhs);
        public static int4x4 operator +(int lhs, int4x4 rhs);
        public static int4x4 operator -(int4x4 lhs, int4x4 rhs);
        public static int4x4 operator -(int4x4 lhs, int rhs);
        public static int4x4 operator -(int lhs, int4x4 rhs);
        public static int4x4 operator /(int4x4 lhs, int4x4 rhs);
        public static int4x4 operator /(int4x4 lhs, int rhs);
        public static int4x4 operator /(int lhs, int4x4 rhs);
        public static int4x4 operator %(int4x4 lhs, int4x4 rhs);
        public static int4x4 operator %(int4x4 lhs, int rhs);
        public static int4x4 operator %(int lhs, int4x4 rhs);
        public static int4x4 operator ++(int4x4 val);
        public static int4x4 operator --(int4x4 val);
        public static bool4x4 operator <(int4x4 lhs, int4x4 rhs);
        public static bool4x4 operator <(int4x4 lhs, int rhs);
        public static bool4x4 operator <(int lhs, int4x4 rhs);
        public static bool4x4 operator <=(int4x4 lhs, int4x4 rhs);
        public static bool4x4 operator <=(int4x4 lhs, int rhs);
        public static bool4x4 operator <=(int lhs, int4x4 rhs);
        public static bool4x4 operator >(int4x4 lhs, int4x4 rhs);
        public static bool4x4 operator >(int4x4 lhs, int rhs);
        public static bool4x4 operator >(int lhs, int4x4 rhs);
        public static bool4x4 operator >=(int4x4 lhs, int4x4 rhs);
        public static bool4x4 operator >=(int4x4 lhs, int rhs);
        public static bool4x4 operator >=(int lhs, int4x4 rhs);
        public static int4x4 operator -(int4x4 val);
        public static int4x4 operator +(int4x4 val);
        public static int4x4 operator <<(int4x4 x, int n);
        public static int4x4 operator >>(int4x4 x, int n);
        public static bool4x4 operator ==(int4x4 lhs, int4x4 rhs);
        public static bool4x4 operator ==(int4x4 lhs, int rhs);
        public static bool4x4 operator ==(int lhs, int4x4 rhs);
        public static bool4x4 operator !=(int4x4 lhs, int4x4 rhs);
        public static bool4x4 operator !=(int4x4 lhs, int rhs);
        public static bool4x4 operator !=(int lhs, int4x4 rhs);
        public static int4x4 operator ~(int4x4 val);
        public static int4x4 operator &(int4x4 lhs, int4x4 rhs);
        public static int4x4 operator &(int4x4 lhs, int rhs);
        public static int4x4 operator &(int lhs, int4x4 rhs);
        public static int4x4 operator |(int4x4 lhs, int4x4 rhs);
        public static int4x4 operator |(int4x4 lhs, int rhs);
        public static int4x4 operator |(int lhs, int4x4 rhs);
        public static int4x4 operator ^(int4x4 lhs, int4x4 rhs);
        public static int4x4 operator ^(int4x4 lhs, int rhs);
        public static int4x4 operator ^(int lhs, int4x4 rhs);

        public static implicit operator int4x4(int v);
        public static explicit operator int4x4(bool v);
        public static explicit operator int4x4(bool4x4 v);
        public static explicit operator int4x4(uint v);
        public static explicit operator int4x4(uint4x4 v);
        public static explicit operator int4x4(float v);
        public static explicit operator int4x4(float4x4 v);
        public static explicit operator int4x4(double v);
        public static explicit operator int4x4(double4x4 v);
    }
}
using System;
using UnityEngine;

namespace Unity.Mathematics
{
    public struct quaternion : IEquatable<quaternion>, IFormattable
    {
        public float4 value;
        public static readonly quaternion identity;

        public quaternion(float x, float y, float z, float w);
        public quaternion(float4 value);
        public quaternion(float3x3 m);
        public quaternion(float4x4 m);

        public static quaternion AxisAngle(float3 axis, float angle);
        public static quaternion EulerXYZ(float3 xyz);
        public static quaternion EulerXZY(float3 xyz);
        public static quaternion EulerYXZ(float3 xyz);
        public static quaternion EulerYZX(float3 xyz);
        public static quaternion EulerZXY(float3 xyz);
        public static quaternion EulerZYX(float3 xyz);
        public static quaternion EulerXYZ(float x, float y, float z);
        public static quaternion EulerXZY(float x, float y, float z);
        public static quaternion EulerYXZ(float x, float y, float z);
        public static quaternion EulerYZX(float x, float y, float z);
        public static quaternion EulerZXY(float x, float y, float z);
        public static quaternion EulerZYX(float x, float y, float z);
        public static quaternion Euler(float3 xyz, math.RotationOrder order = Default);
        public static quaternion Euler(float x, float y, float z, math.RotationOrder order = Default);
        public static quaternion RotateX(float angle);
        public static quaternion RotateY(float angle);
        public static quaternion RotateZ(float angle);
        public static quaternion LookRotation(float3 forward, float3 up);
        public static quaternion LookRotationSafe(float3 forward, float3 up);
        public bool Equals(quaternion x);
        public override bool Equals(object x);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static implicit operator Quaternion(quaternion q);
        public static implicit operator quaternion(Quaternion q);
        public static implicit operator quaternion(float4 v);
    }
}
namespace Unity.Mathematics
{
    public struct Random
    {
        public uint state;

        public Random(uint seed);

        public void InitState(uint seed = 1851936439);
        public bool NextBool();
        public bool2 NextBool2();
        public bool3 NextBool3();
        public bool4 NextBool4();
        public int NextInt();
        public int2 NextInt2();
        public int3 NextInt3();
        public int4 NextInt4();
        public int NextInt(int max);
        public int2 NextInt2(int2 max);
        public int3 NextInt3(int3 max);
        public int4 NextInt4(int4 max);
        public int NextInt(int min, int max);
        public int2 NextInt2(int2 min, int2 max);
        public int3 NextInt3(int3 min, int3 max);
        public int4 NextInt4(int4 min, int4 max);
        public uint NextUInt();
        public uint2 NextUInt2();
        public uint3 NextUInt3();
        public uint4 NextUInt4();
        public uint NextUInt(uint max);
        public uint2 NextUInt2(uint2 max);
        public uint3 NextUInt3(uint3 max);
        public uint4 NextUInt4(uint4 max);
        public uint NextUInt(uint min, uint max);
        public uint2 NextUInt2(uint2 min, uint2 max);
        public uint3 NextUInt3(uint3 min, uint3 max);
        public uint4 NextUInt4(uint4 min, uint4 max);
        public float NextFloat();
        public float2 NextFloat2();
        public float3 NextFloat3();
        public float4 NextFloat4();
        public float NextFloat(float max);
        public float2 NextFloat2(float2 max);
        public float3 NextFloat3(float3 max);
        public float4 NextFloat4(float4 max);
        public float NextFloat(float min, float max);
        public float2 NextFloat2(float2 min, float2 max);
        public float3 NextFloat3(float3 min, float3 max);
        public float4 NextFloat4(float4 min, float4 max);
        public double NextDouble();
        public double2 NextDouble2();
        public double3 NextDouble3();
        public double4 NextDouble4();
        public double NextDouble(double max);
        public double2 NextDouble2(double2 max);
        public double3 NextDouble3(double3 max);
        public double4 NextDouble4(double4 max);
        public double NextDouble(double min, double max);
        public double2 NextDouble2(double2 min, double2 max);
        public double3 NextDouble3(double3 min, double3 max);
        public double4 NextDouble4(double4 min, double4 max);
        public float2 NextFloat2Direction();
        public double2 NextDouble2Direction();
        public float3 NextFloat3Direction();
        public double3 NextDouble3Direction();
        public quaternion NextQuaternionRotation();
    }
}
using System;

namespace Unity.Mathematics
{
    public struct RigidTransform
    {
        public quaternion rot;
        public float3 pos;
        public static readonly RigidTransform identity;

        public RigidTransform(quaternion rotation, float3 translation);
        public RigidTransform(float3x3 rotation, float3 translation);
        public RigidTransform(float4x4 transform);

        public static RigidTransform AxisAngle(float3 axis, float angle);
        public static RigidTransform EulerXYZ(float3 xyz);
        public static RigidTransform EulerXZY(float3 xyz);
        public static RigidTransform EulerYXZ(float3 xyz);
        public static RigidTransform EulerYZX(float3 xyz);
        public static RigidTransform EulerZXY(float3 xyz);
        public static RigidTransform EulerZYX(float3 xyz);
        public static RigidTransform EulerXYZ(float x, float y, float z);
        public static RigidTransform EulerXZY(float x, float y, float z);
        public static RigidTransform EulerYXZ(float x, float y, float z);
        public static RigidTransform EulerYZX(float x, float y, float z);
        public static RigidTransform EulerZXY(float x, float y, float z);
        public static RigidTransform EulerZYX(float x, float y, float z);
        public static RigidTransform Euler(float3 xyz, math.RotationOrder order = Default);
        public static RigidTransform Euler(float x, float y, float z, math.RotationOrder order = Default);
        public static RigidTransform RotateX(float angle);
        public static RigidTransform RotateY(float angle);
        public static RigidTransform RotateZ(float angle);
        public static RigidTransform Translate(float3 vector);
        public bool Equals(RigidTransform x);
        public override bool Equals(object x);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);
    }
}
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    [DebuggerTypeProxy(typeof(DebuggerProxy))]
    public struct uint2 : IEquatable<uint2>, IFormattable
    {
        public uint x;
        public uint y;
        public static readonly uint2 zero;

        public uint2(uint x, uint y);
        public uint2(uint2 xy);
        public uint2(uint v);
        public uint2(bool v);
        public uint2(bool2 v);
        public uint2(int v);
        public uint2(int2 v);
        public uint2(float v);
        public uint2(float2 v);
        public uint2(double v);
        public uint2(double2 v);

        public uint this[int index] { get; set; }
        [EditorBrowsable(Never)]
        public uint4 xxxx { get; }
        [EditorBrowsable(Never)]
        public uint4 xxxy { get; }
        [EditorBrowsable(Never)]
        public uint4 xxyx { get; }
        [EditorBrowsable(Never)]
        public uint4 xxyy { get; }
        [EditorBrowsable(Never)]
        public uint4 xyxx { get; }
        [EditorBrowsable(Never)]
        public uint4 xyxy { get; }
        [EditorBrowsable(Never)]
        public uint4 xyyx { get; }
        [EditorBrowsable(Never)]
        public uint4 xyyy { get; }
        [EditorBrowsable(Never)]
        public uint4 yxxx { get; }
        [EditorBrowsable(Never)]
        public uint4 yxxy { get; }
        [EditorBrowsable(Never)]
        public uint4 yxyx { get; }
        [EditorBrowsable(Never)]
        public uint4 yxyy { get; }
        [EditorBrowsable(Never)]
        public uint4 yyxx { get; }
        [EditorBrowsable(Never)]
        public uint4 yyxy { get; }
        [EditorBrowsable(Never)]
        public uint4 yyyx { get; }
        [EditorBrowsable(Never)]
        public uint4 yyyy { get; }
        [EditorBrowsable(Never)]
        public uint3 xxx { get; }
        [EditorBrowsable(Never)]
        public uint3 xxy { get; }
        [EditorBrowsable(Never)]
        public uint3 xyx { get; }
        [EditorBrowsable(Never)]
        public uint3 xyy { get; }
        [EditorBrowsable(Never)]
        public uint3 yxx { get; }
        [EditorBrowsable(Never)]
        public uint3 yxy { get; }
        [EditorBrowsable(Never)]
        public uint3 yyx { get; }
        [EditorBrowsable(Never)]
        public uint3 yyy { get; }
        [EditorBrowsable(Never)]
        public uint2 xx { get; }
        [EditorBrowsable(Never)]
        public uint2 xy { get; set; }
        [EditorBrowsable(Never)]
        public uint2 yx { get; set; }
        [EditorBrowsable(Never)]
        public uint2 yy { get; }

        public bool Equals(uint2 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static uint2 operator *(uint2 lhs, uint2 rhs);
        public static uint2 operator *(uint2 lhs, uint rhs);
        public static uint2 operator *(uint lhs, uint2 rhs);
        public static uint2 operator +(uint2 lhs, uint2 rhs);
        public static uint2 operator +(uint2 lhs, uint rhs);
        public static uint2 operator +(uint lhs, uint2 rhs);
        public static uint2 operator -(uint2 lhs, uint2 rhs);
        public static uint2 operator -(uint2 lhs, uint rhs);
        public static uint2 operator -(uint lhs, uint2 rhs);
        public static uint2 operator /(uint2 lhs, uint2 rhs);
        public static uint2 operator /(uint2 lhs, uint rhs);
        public static uint2 operator /(uint lhs, uint2 rhs);
        public static uint2 operator %(uint2 lhs, uint2 rhs);
        public static uint2 operator %(uint2 lhs, uint rhs);
        public static uint2 operator %(uint lhs, uint2 rhs);
        public static uint2 operator ++(uint2 val);
        public static uint2 operator --(uint2 val);
        public static bool2 operator <(uint2 lhs, uint2 rhs);
        public static bool2 operator <(uint2 lhs, uint rhs);
        public static bool2 operator <(uint lhs, uint2 rhs);
        public static bool2 operator <=(uint2 lhs, uint2 rhs);
        public static bool2 operator <=(uint2 lhs, uint rhs);
        public static bool2 operator <=(uint lhs, uint2 rhs);
        public static bool2 operator >(uint2 lhs, uint2 rhs);
        public static bool2 operator >(uint2 lhs, uint rhs);
        public static bool2 operator >(uint lhs, uint2 rhs);
        public static bool2 operator >=(uint2 lhs, uint2 rhs);
        public static bool2 operator >=(uint2 lhs, uint rhs);
        public static bool2 operator >=(uint lhs, uint2 rhs);
        public static uint2 operator -(uint2 val);
        public static uint2 operator +(uint2 val);
        public static uint2 operator <<(uint2 x, int n);
        public static uint2 operator >>(uint2 x, int n);
        public static bool2 operator ==(uint2 lhs, uint2 rhs);
        public static bool2 operator ==(uint2 lhs, uint rhs);
        public static bool2 operator ==(uint lhs, uint2 rhs);
        public static bool2 operator !=(uint2 lhs, uint2 rhs);
        public static bool2 operator !=(uint2 lhs, uint rhs);
        public static bool2 operator !=(uint lhs, uint2 rhs);
        public static uint2 operator ~(uint2 val);
        public static uint2 operator &(uint2 lhs, uint2 rhs);
        public static uint2 operator &(uint2 lhs, uint rhs);
        public static uint2 operator &(uint lhs, uint2 rhs);
        public static uint2 operator |(uint2 lhs, uint2 rhs);
        public static uint2 operator |(uint2 lhs, uint rhs);
        public static uint2 operator |(uint lhs, uint2 rhs);
        public static uint2 operator ^(uint2 lhs, uint2 rhs);
        public static uint2 operator ^(uint2 lhs, uint rhs);
        public static uint2 operator ^(uint lhs, uint2 rhs);

        public static implicit operator uint2(uint v);
        public static explicit operator uint2(bool v);
        public static explicit operator uint2(bool2 v);
        public static explicit operator uint2(int v);
        public static explicit operator uint2(int2 v);
        public static explicit operator uint2(float v);
        public static explicit operator uint2(float2 v);
        public static explicit operator uint2(double v);
        public static explicit operator uint2(double2 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct uint2x2 : IEquatable<uint2x2>, IFormattable
    {
        public uint2 c0;
        public uint2 c1;
        public static readonly uint2x2 identity;
        public static readonly uint2x2 zero;

        public uint2x2(uint2 c0, uint2 c1);
        public uint2x2(uint m00, uint m01, uint m10, uint m11);
        public uint2x2(uint v);
        public uint2x2(bool v);
        public uint2x2(bool2x2 v);
        public uint2x2(int v);
        public uint2x2(int2x2 v);
        public uint2x2(float v);
        public uint2x2(float2x2 v);
        public uint2x2(double v);
        public uint2x2(double2x2 v);

        public ref uint2 this[int index] { get; }

        public bool Equals(uint2x2 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static uint2x2 operator *(uint2x2 lhs, uint2x2 rhs);
        public static uint2x2 operator *(uint2x2 lhs, uint rhs);
        public static uint2x2 operator *(uint lhs, uint2x2 rhs);
        public static uint2x2 operator +(uint2x2 lhs, uint2x2 rhs);
        public static uint2x2 operator +(uint2x2 lhs, uint rhs);
        public static uint2x2 operator +(uint lhs, uint2x2 rhs);
        public static uint2x2 operator -(uint2x2 lhs, uint2x2 rhs);
        public static uint2x2 operator -(uint2x2 lhs, uint rhs);
        public static uint2x2 operator -(uint lhs, uint2x2 rhs);
        public static uint2x2 operator /(uint2x2 lhs, uint2x2 rhs);
        public static uint2x2 operator /(uint2x2 lhs, uint rhs);
        public static uint2x2 operator /(uint lhs, uint2x2 rhs);
        public static uint2x2 operator %(uint2x2 lhs, uint2x2 rhs);
        public static uint2x2 operator %(uint2x2 lhs, uint rhs);
        public static uint2x2 operator %(uint lhs, uint2x2 rhs);
        public static uint2x2 operator ++(uint2x2 val);
        public static uint2x2 operator --(uint2x2 val);
        public static bool2x2 operator <(uint2x2 lhs, uint2x2 rhs);
        public static bool2x2 operator <(uint2x2 lhs, uint rhs);
        public static bool2x2 operator <(uint lhs, uint2x2 rhs);
        public static bool2x2 operator <=(uint2x2 lhs, uint2x2 rhs);
        public static bool2x2 operator <=(uint2x2 lhs, uint rhs);
        public static bool2x2 operator <=(uint lhs, uint2x2 rhs);
        public static bool2x2 operator >(uint2x2 lhs, uint2x2 rhs);
        public static bool2x2 operator >(uint2x2 lhs, uint rhs);
        public static bool2x2 operator >(uint lhs, uint2x2 rhs);
        public static bool2x2 operator >=(uint2x2 lhs, uint2x2 rhs);
        public static bool2x2 operator >=(uint2x2 lhs, uint rhs);
        public static bool2x2 operator >=(uint lhs, uint2x2 rhs);
        public static uint2x2 operator -(uint2x2 val);
        public static uint2x2 operator +(uint2x2 val);
        public static uint2x2 operator <<(uint2x2 x, int n);
        public static uint2x2 operator >>(uint2x2 x, int n);
        public static bool2x2 operator ==(uint2x2 lhs, uint2x2 rhs);
        public static bool2x2 operator ==(uint2x2 lhs, uint rhs);
        public static bool2x2 operator ==(uint lhs, uint2x2 rhs);
        public static bool2x2 operator !=(uint2x2 lhs, uint2x2 rhs);
        public static bool2x2 operator !=(uint2x2 lhs, uint rhs);
        public static bool2x2 operator !=(uint lhs, uint2x2 rhs);
        public static uint2x2 operator ~(uint2x2 val);
        public static uint2x2 operator &(uint2x2 lhs, uint2x2 rhs);
        public static uint2x2 operator &(uint2x2 lhs, uint rhs);
        public static uint2x2 operator &(uint lhs, uint2x2 rhs);
        public static uint2x2 operator |(uint2x2 lhs, uint2x2 rhs);
        public static uint2x2 operator |(uint2x2 lhs, uint rhs);
        public static uint2x2 operator |(uint lhs, uint2x2 rhs);
        public static uint2x2 operator ^(uint2x2 lhs, uint2x2 rhs);
        public static uint2x2 operator ^(uint2x2 lhs, uint rhs);
        public static uint2x2 operator ^(uint lhs, uint2x2 rhs);

        public static implicit operator uint2x2(uint v);
        public static explicit operator uint2x2(bool v);
        public static explicit operator uint2x2(bool2x2 v);
        public static explicit operator uint2x2(int v);
        public static explicit operator uint2x2(int2x2 v);
        public static explicit operator uint2x2(float v);
        public static explicit operator uint2x2(float2x2 v);
        public static explicit operator uint2x2(double v);
        public static explicit operator uint2x2(double2x2 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct uint2x3 : IEquatable<uint2x3>, IFormattable
    {
        public uint2 c0;
        public uint2 c1;
        public uint2 c2;
        public static readonly uint2x3 zero;

        public uint2x3(uint2 c0, uint2 c1, uint2 c2);
        public uint2x3(uint m00, uint m01, uint m02, uint m10, uint m11, uint m12);
        public uint2x3(uint v);
        public uint2x3(bool v);
        public uint2x3(bool2x3 v);
        public uint2x3(int v);
        public uint2x3(int2x3 v);
        public uint2x3(float v);
        public uint2x3(float2x3 v);
        public uint2x3(double v);
        public uint2x3(double2x3 v);

        public ref uint2 this[int index] { get; }

        public bool Equals(uint2x3 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static uint2x3 operator *(uint2x3 lhs, uint2x3 rhs);
        public static uint2x3 operator *(uint2x3 lhs, uint rhs);
        public static uint2x3 operator *(uint lhs, uint2x3 rhs);
        public static uint2x3 operator +(uint2x3 lhs, uint2x3 rhs);
        public static uint2x3 operator +(uint2x3 lhs, uint rhs);
        public static uint2x3 operator +(uint lhs, uint2x3 rhs);
        public static uint2x3 operator -(uint2x3 lhs, uint2x3 rhs);
        public static uint2x3 operator -(uint2x3 lhs, uint rhs);
        public static uint2x3 operator -(uint lhs, uint2x3 rhs);
        public static uint2x3 operator /(uint2x3 lhs, uint2x3 rhs);
        public static uint2x3 operator /(uint2x3 lhs, uint rhs);
        public static uint2x3 operator /(uint lhs, uint2x3 rhs);
        public static uint2x3 operator %(uint2x3 lhs, uint2x3 rhs);
        public static uint2x3 operator %(uint2x3 lhs, uint rhs);
        public static uint2x3 operator %(uint lhs, uint2x3 rhs);
        public static uint2x3 operator ++(uint2x3 val);
        public static uint2x3 operator --(uint2x3 val);
        public static bool2x3 operator <(uint2x3 lhs, uint2x3 rhs);
        public static bool2x3 operator <(uint2x3 lhs, uint rhs);
        public static bool2x3 operator <(uint lhs, uint2x3 rhs);
        public static bool2x3 operator <=(uint2x3 lhs, uint2x3 rhs);
        public static bool2x3 operator <=(uint2x3 lhs, uint rhs);
        public static bool2x3 operator <=(uint lhs, uint2x3 rhs);
        public static bool2x3 operator >(uint2x3 lhs, uint2x3 rhs);
        public static bool2x3 operator >(uint2x3 lhs, uint rhs);
        public static bool2x3 operator >(uint lhs, uint2x3 rhs);
        public static bool2x3 operator >=(uint2x3 lhs, uint2x3 rhs);
        public static bool2x3 operator >=(uint2x3 lhs, uint rhs);
        public static bool2x3 operator >=(uint lhs, uint2x3 rhs);
        public static uint2x3 operator -(uint2x3 val);
        public static uint2x3 operator +(uint2x3 val);
        public static uint2x3 operator <<(uint2x3 x, int n);
        public static uint2x3 operator >>(uint2x3 x, int n);
        public static bool2x3 operator ==(uint2x3 lhs, uint2x3 rhs);
        public static bool2x3 operator ==(uint2x3 lhs, uint rhs);
        public static bool2x3 operator ==(uint lhs, uint2x3 rhs);
        public static bool2x3 operator !=(uint2x3 lhs, uint2x3 rhs);
        public static bool2x3 operator !=(uint2x3 lhs, uint rhs);
        public static bool2x3 operator !=(uint lhs, uint2x3 rhs);
        public static uint2x3 operator ~(uint2x3 val);
        public static uint2x3 operator &(uint2x3 lhs, uint2x3 rhs);
        public static uint2x3 operator &(uint2x3 lhs, uint rhs);
        public static uint2x3 operator &(uint lhs, uint2x3 rhs);
        public static uint2x3 operator |(uint2x3 lhs, uint2x3 rhs);
        public static uint2x3 operator |(uint2x3 lhs, uint rhs);
        public static uint2x3 operator |(uint lhs, uint2x3 rhs);
        public static uint2x3 operator ^(uint2x3 lhs, uint2x3 rhs);
        public static uint2x3 operator ^(uint2x3 lhs, uint rhs);
        public static uint2x3 operator ^(uint lhs, uint2x3 rhs);

        public static implicit operator uint2x3(uint v);
        public static explicit operator uint2x3(bool v);
        public static explicit operator uint2x3(bool2x3 v);
        public static explicit operator uint2x3(int v);
        public static explicit operator uint2x3(int2x3 v);
        public static explicit operator uint2x3(float v);
        public static explicit operator uint2x3(float2x3 v);
        public static explicit operator uint2x3(double v);
        public static explicit operator uint2x3(double2x3 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct uint2x4 : IEquatable<uint2x4>, IFormattable
    {
        public uint2 c0;
        public uint2 c1;
        public uint2 c2;
        public uint2 c3;
        public static readonly uint2x4 zero;

        public uint2x4(uint2 c0, uint2 c1, uint2 c2, uint2 c3);
        public uint2x4(uint m00, uint m01, uint m02, uint m03, uint m10, uint m11, uint m12, uint m13);
        public uint2x4(uint v);
        public uint2x4(bool v);
        public uint2x4(bool2x4 v);
        public uint2x4(int v);
        public uint2x4(int2x4 v);
        public uint2x4(float v);
        public uint2x4(float2x4 v);
        public uint2x4(double v);
        public uint2x4(double2x4 v);

        public ref uint2 this[int index] { get; }

        public bool Equals(uint2x4 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static uint2x4 operator *(uint2x4 lhs, uint2x4 rhs);
        public static uint2x4 operator *(uint2x4 lhs, uint rhs);
        public static uint2x4 operator *(uint lhs, uint2x4 rhs);
        public static uint2x4 operator +(uint2x4 lhs, uint2x4 rhs);
        public static uint2x4 operator +(uint2x4 lhs, uint rhs);
        public static uint2x4 operator +(uint lhs, uint2x4 rhs);
        public static uint2x4 operator -(uint2x4 lhs, uint2x4 rhs);
        public static uint2x4 operator -(uint2x4 lhs, uint rhs);
        public static uint2x4 operator -(uint lhs, uint2x4 rhs);
        public static uint2x4 operator /(uint2x4 lhs, uint2x4 rhs);
        public static uint2x4 operator /(uint2x4 lhs, uint rhs);
        public static uint2x4 operator /(uint lhs, uint2x4 rhs);
        public static uint2x4 operator %(uint2x4 lhs, uint2x4 rhs);
        public static uint2x4 operator %(uint2x4 lhs, uint rhs);
        public static uint2x4 operator %(uint lhs, uint2x4 rhs);
        public static uint2x4 operator ++(uint2x4 val);
        public static uint2x4 operator --(uint2x4 val);
        public static bool2x4 operator <(uint2x4 lhs, uint2x4 rhs);
        public static bool2x4 operator <(uint2x4 lhs, uint rhs);
        public static bool2x4 operator <(uint lhs, uint2x4 rhs);
        public static bool2x4 operator <=(uint2x4 lhs, uint2x4 rhs);
        public static bool2x4 operator <=(uint2x4 lhs, uint rhs);
        public static bool2x4 operator <=(uint lhs, uint2x4 rhs);
        public static bool2x4 operator >(uint2x4 lhs, uint2x4 rhs);
        public static bool2x4 operator >(uint2x4 lhs, uint rhs);
        public static bool2x4 operator >(uint lhs, uint2x4 rhs);
        public static bool2x4 operator >=(uint2x4 lhs, uint2x4 rhs);
        public static bool2x4 operator >=(uint2x4 lhs, uint rhs);
        public static bool2x4 operator >=(uint lhs, uint2x4 rhs);
        public static uint2x4 operator -(uint2x4 val);
        public static uint2x4 operator +(uint2x4 val);
        public static uint2x4 operator <<(uint2x4 x, int n);
        public static uint2x4 operator >>(uint2x4 x, int n);
        public static bool2x4 operator ==(uint2x4 lhs, uint2x4 rhs);
        public static bool2x4 operator ==(uint2x4 lhs, uint rhs);
        public static bool2x4 operator ==(uint lhs, uint2x4 rhs);
        public static bool2x4 operator !=(uint2x4 lhs, uint2x4 rhs);
        public static bool2x4 operator !=(uint2x4 lhs, uint rhs);
        public static bool2x4 operator !=(uint lhs, uint2x4 rhs);
        public static uint2x4 operator ~(uint2x4 val);
        public static uint2x4 operator &(uint2x4 lhs, uint2x4 rhs);
        public static uint2x4 operator &(uint2x4 lhs, uint rhs);
        public static uint2x4 operator &(uint lhs, uint2x4 rhs);
        public static uint2x4 operator |(uint2x4 lhs, uint2x4 rhs);
        public static uint2x4 operator |(uint2x4 lhs, uint rhs);
        public static uint2x4 operator |(uint lhs, uint2x4 rhs);
        public static uint2x4 operator ^(uint2x4 lhs, uint2x4 rhs);
        public static uint2x4 operator ^(uint2x4 lhs, uint rhs);
        public static uint2x4 operator ^(uint lhs, uint2x4 rhs);

        public static implicit operator uint2x4(uint v);
        public static explicit operator uint2x4(bool v);
        public static explicit operator uint2x4(bool2x4 v);
        public static explicit operator uint2x4(int v);
        public static explicit operator uint2x4(int2x4 v);
        public static explicit operator uint2x4(float v);
        public static explicit operator uint2x4(float2x4 v);
        public static explicit operator uint2x4(double v);
        public static explicit operator uint2x4(double2x4 v);
    }
}
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    [DebuggerTypeProxy(typeof(DebuggerProxy))]
    public struct uint3 : IEquatable<uint3>, IFormattable
    {
        public uint x;
        public uint y;
        public uint z;
        public static readonly uint3 zero;

        public uint3(uint x, uint y, uint z);
        public uint3(uint x, uint2 yz);
        public uint3(uint2 xy, uint z);
        public uint3(uint3 xyz);
        public uint3(uint v);
        public uint3(bool v);
        public uint3(bool3 v);
        public uint3(int v);
        public uint3(int3 v);
        public uint3(float v);
        public uint3(float3 v);
        public uint3(double v);
        public uint3(double3 v);

        public uint this[int index] { get; set; }
        [EditorBrowsable(Never)]
        public uint4 xxxx { get; }
        [EditorBrowsable(Never)]
        public uint4 xxxy { get; }
        [EditorBrowsable(Never)]
        public uint4 xxxz { get; }
        [EditorBrowsable(Never)]
        public uint4 xxyx { get; }
        [EditorBrowsable(Never)]
        public uint4 xxyy { get; }
        [EditorBrowsable(Never)]
        public uint4 xxyz { get; }
        [EditorBrowsable(Never)]
        public uint4 xxzx { get; }
        [EditorBrowsable(Never)]
        public uint4 xxzy { get; }
        [EditorBrowsable(Never)]
        public uint4 xxzz { get; }
        [EditorBrowsable(Never)]
        public uint4 xyxx { get; }
        [EditorBrowsable(Never)]
        public uint4 xyxy { get; }
        [EditorBrowsable(Never)]
        public uint4 xyxz { get; }
        [EditorBrowsable(Never)]
        public uint4 xyyx { get; }
        [EditorBrowsable(Never)]
        public uint4 xyyy { get; }
        [EditorBrowsable(Never)]
        public uint4 xyyz { get; }
        [EditorBrowsable(Never)]
        public uint4 xyzx { get; }
        [EditorBrowsable(Never)]
        public uint4 xyzy { get; }
        [EditorBrowsable(Never)]
        public uint4 xyzz { get; }
        [EditorBrowsable(Never)]
        public uint4 xzxx { get; }
        [EditorBrowsable(Never)]
        public uint4 xzxy { get; }
        [EditorBrowsable(Never)]
        public uint4 xzxz { get; }
        [EditorBrowsable(Never)]
        public uint4 xzyx { get; }
        [EditorBrowsable(Never)]
        public uint4 xzyy { get; }
        [EditorBrowsable(Never)]
        public uint4 xzyz { get; }
        [EditorBrowsable(Never)]
        public uint4 xzzx { get; }
        [EditorBrowsable(Never)]
        public uint4 xzzy { get; }
        [EditorBrowsable(Never)]
        public uint4 xzzz { get; }
        [EditorBrowsable(Never)]
        public uint4 yxxx { get; }
        [EditorBrowsable(Never)]
        public uint4 yxxy { get; }
        [EditorBrowsable(Never)]
        public uint4 yxxz { get; }
        [EditorBrowsable(Never)]
        public uint4 yxyx { get; }
        [EditorBrowsable(Never)]
        public uint4 yxyy { get; }
        [EditorBrowsable(Never)]
        public uint4 yxyz { get; }
        [EditorBrowsable(Never)]
        public uint4 yxzx { get; }
        [EditorBrowsable(Never)]
        public uint4 yxzy { get; }
        [EditorBrowsable(Never)]
        public uint4 yxzz { get; }
        [EditorBrowsable(Never)]
        public uint4 yyxx { get; }
        [EditorBrowsable(Never)]
        public uint4 yyxy { get; }
        [EditorBrowsable(Never)]
        public uint4 yyxz { get; }
        [EditorBrowsable(Never)]
        public uint4 yyyx { get; }
        [EditorBrowsable(Never)]
        public uint4 yyyy { get; }
        [EditorBrowsable(Never)]
        public uint4 yyyz { get; }
        [EditorBrowsable(Never)]
        public uint4 yyzx { get; }
        [EditorBrowsable(Never)]
        public uint4 yyzy { get; }
        [EditorBrowsable(Never)]
        public uint4 yyzz { get; }
        [EditorBrowsable(Never)]
        public uint4 yzxx { get; }
        [EditorBrowsable(Never)]
        public uint4 yzxy { get; }
        [EditorBrowsable(Never)]
        public uint4 yzxz { get; }
        [EditorBrowsable(Never)]
        public uint4 yzyx { get; }
        [EditorBrowsable(Never)]
        public uint4 yzyy { get; }
        [EditorBrowsable(Never)]
        public uint4 yzyz { get; }
        [EditorBrowsable(Never)]
        public uint4 yzzx { get; }
        [EditorBrowsable(Never)]
        public uint4 yzzy { get; }
        [EditorBrowsable(Never)]
        public uint4 yzzz { get; }
        [EditorBrowsable(Never)]
        public uint4 zxxx { get; }
        [EditorBrowsable(Never)]
        public uint4 zxxy { get; }
        [EditorBrowsable(Never)]
        public uint4 zxxz { get; }
        [EditorBrowsable(Never)]
        public uint4 zxyx { get; }
        [EditorBrowsable(Never)]
        public uint4 zxyy { get; }
        [EditorBrowsable(Never)]
        public uint4 zxyz { get; }
        [EditorBrowsable(Never)]
        public uint4 zxzx { get; }
        [EditorBrowsable(Never)]
        public uint4 zxzy { get; }
        [EditorBrowsable(Never)]
        public uint4 zxzz { get; }
        [EditorBrowsable(Never)]
        public uint4 zyxx { get; }
        [EditorBrowsable(Never)]
        public uint4 zyxy { get; }
        [EditorBrowsable(Never)]
        public uint4 zyxz { get; }
        [EditorBrowsable(Never)]
        public uint4 zyyx { get; }
        [EditorBrowsable(Never)]
        public uint4 zyyy { get; }
        [EditorBrowsable(Never)]
        public uint4 zyyz { get; }
        [EditorBrowsable(Never)]
        public uint4 zyzx { get; }
        [EditorBrowsable(Never)]
        public uint4 zyzy { get; }
        [EditorBrowsable(Never)]
        public uint4 zyzz { get; }
        [EditorBrowsable(Never)]
        public uint4 zzxx { get; }
        [EditorBrowsable(Never)]
        public uint4 zzxy { get; }
        [EditorBrowsable(Never)]
        public uint4 zzxz { get; }
        [EditorBrowsable(Never)]
        public uint4 zzyx { get; }
        [EditorBrowsable(Never)]
        public uint4 zzyy { get; }
        [EditorBrowsable(Never)]
        public uint4 zzyz { get; }
        [EditorBrowsable(Never)]
        public uint4 zzzx { get; }
        [EditorBrowsable(Never)]
        public uint4 zzzy { get; }
        [EditorBrowsable(Never)]
        public uint4 zzzz { get; }
        [EditorBrowsable(Never)]
        public uint3 xxx { get; }
        [EditorBrowsable(Never)]
        public uint3 xxy { get; }
        [EditorBrowsable(Never)]
        public uint3 xxz { get; }
        [EditorBrowsable(Never)]
        public uint3 xyx { get; }
        [EditorBrowsable(Never)]
        public uint3 xyy { get; }
        [EditorBrowsable(Never)]
        public uint3 xyz { get; set; }
        [EditorBrowsable(Never)]
        public uint3 xzx { get; }
        [EditorBrowsable(Never)]
        public uint3 xzy { get; set; }
        [EditorBrowsable(Never)]
        public uint3 xzz { get; }
        [EditorBrowsable(Never)]
        public uint3 yxx { get; }
        [EditorBrowsable(Never)]
        public uint3 yxy { get; }
        [EditorBrowsable(Never)]
        public uint3 yxz { get; set; }
        [EditorBrowsable(Never)]
        public uint3 yyx { get; }
        [EditorBrowsable(Never)]
        public uint3 yyy { get; }
        [EditorBrowsable(Never)]
        public uint3 yyz { get; }
        [EditorBrowsable(Never)]
        public uint3 yzx { get; set; }
        [EditorBrowsable(Never)]
        public uint3 yzy { get; }
        [EditorBrowsable(Never)]
        public uint3 yzz { get; }
        [EditorBrowsable(Never)]
        public uint3 zxx { get; }
        [EditorBrowsable(Never)]
        public uint3 zxy { get; set; }
        [EditorBrowsable(Never)]
        public uint3 zxz { get; }
        [EditorBrowsable(Never)]
        public uint3 zyx { get; set; }
        [EditorBrowsable(Never)]
        public uint3 zyy { get; }
        [EditorBrowsable(Never)]
        public uint3 zyz { get; }
        [EditorBrowsable(Never)]
        public uint3 zzx { get; }
        [EditorBrowsable(Never)]
        public uint3 zzy { get; }
        [EditorBrowsable(Never)]
        public uint3 zzz { get; }
        [EditorBrowsable(Never)]
        public uint2 xx { get; }
        [EditorBrowsable(Never)]
        public uint2 xy { get; set; }
        [EditorBrowsable(Never)]
        public uint2 xz { get; set; }
        [EditorBrowsable(Never)]
        public uint2 yx { get; set; }
        [EditorBrowsable(Never)]
        public uint2 yy { get; }
        [EditorBrowsable(Never)]
        public uint2 yz { get; set; }
        [EditorBrowsable(Never)]
        public uint2 zx { get; set; }
        [EditorBrowsable(Never)]
        public uint2 zy { get; set; }
        [EditorBrowsable(Never)]
        public uint2 zz { get; }

        public bool Equals(uint3 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static uint3 operator *(uint3 lhs, uint3 rhs);
        public static uint3 operator *(uint3 lhs, uint rhs);
        public static uint3 operator *(uint lhs, uint3 rhs);
        public static uint3 operator +(uint3 lhs, uint3 rhs);
        public static uint3 operator +(uint3 lhs, uint rhs);
        public static uint3 operator +(uint lhs, uint3 rhs);
        public static uint3 operator -(uint3 lhs, uint3 rhs);
        public static uint3 operator -(uint3 lhs, uint rhs);
        public static uint3 operator -(uint lhs, uint3 rhs);
        public static uint3 operator /(uint3 lhs, uint3 rhs);
        public static uint3 operator /(uint3 lhs, uint rhs);
        public static uint3 operator /(uint lhs, uint3 rhs);
        public static uint3 operator %(uint3 lhs, uint3 rhs);
        public static uint3 operator %(uint3 lhs, uint rhs);
        public static uint3 operator %(uint lhs, uint3 rhs);
        public static uint3 operator ++(uint3 val);
        public static uint3 operator --(uint3 val);
        public static bool3 operator <(uint3 lhs, uint3 rhs);
        public static bool3 operator <(uint3 lhs, uint rhs);
        public static bool3 operator <(uint lhs, uint3 rhs);
        public static bool3 operator <=(uint3 lhs, uint3 rhs);
        public static bool3 operator <=(uint3 lhs, uint rhs);
        public static bool3 operator <=(uint lhs, uint3 rhs);
        public static bool3 operator >(uint3 lhs, uint3 rhs);
        public static bool3 operator >(uint3 lhs, uint rhs);
        public static bool3 operator >(uint lhs, uint3 rhs);
        public static bool3 operator >=(uint3 lhs, uint3 rhs);
        public static bool3 operator >=(uint3 lhs, uint rhs);
        public static bool3 operator >=(uint lhs, uint3 rhs);
        public static uint3 operator -(uint3 val);
        public static uint3 operator +(uint3 val);
        public static uint3 operator <<(uint3 x, int n);
        public static uint3 operator >>(uint3 x, int n);
        public static bool3 operator ==(uint3 lhs, uint3 rhs);
        public static bool3 operator ==(uint3 lhs, uint rhs);
        public static bool3 operator ==(uint lhs, uint3 rhs);
        public static bool3 operator !=(uint3 lhs, uint3 rhs);
        public static bool3 operator !=(uint3 lhs, uint rhs);
        public static bool3 operator !=(uint lhs, uint3 rhs);
        public static uint3 operator ~(uint3 val);
        public static uint3 operator &(uint3 lhs, uint3 rhs);
        public static uint3 operator &(uint3 lhs, uint rhs);
        public static uint3 operator &(uint lhs, uint3 rhs);
        public static uint3 operator |(uint3 lhs, uint3 rhs);
        public static uint3 operator |(uint3 lhs, uint rhs);
        public static uint3 operator |(uint lhs, uint3 rhs);
        public static uint3 operator ^(uint3 lhs, uint3 rhs);
        public static uint3 operator ^(uint3 lhs, uint rhs);
        public static uint3 operator ^(uint lhs, uint3 rhs);

        public static implicit operator uint3(uint v);
        public static explicit operator uint3(bool v);
        public static explicit operator uint3(bool3 v);
        public static explicit operator uint3(int v);
        public static explicit operator uint3(int3 v);
        public static explicit operator uint3(float v);
        public static explicit operator uint3(float3 v);
        public static explicit operator uint3(double v);
        public static explicit operator uint3(double3 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct uint3x2 : IEquatable<uint3x2>, IFormattable
    {
        public uint3 c0;
        public uint3 c1;
        public static readonly uint3x2 zero;

        public uint3x2(uint3 c0, uint3 c1);
        public uint3x2(uint m00, uint m01, uint m10, uint m11, uint m20, uint m21);
        public uint3x2(uint v);
        public uint3x2(bool v);
        public uint3x2(bool3x2 v);
        public uint3x2(int v);
        public uint3x2(int3x2 v);
        public uint3x2(float v);
        public uint3x2(float3x2 v);
        public uint3x2(double v);
        public uint3x2(double3x2 v);

        public ref uint3 this[int index] { get; }

        public bool Equals(uint3x2 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static uint3x2 operator *(uint3x2 lhs, uint3x2 rhs);
        public static uint3x2 operator *(uint3x2 lhs, uint rhs);
        public static uint3x2 operator *(uint lhs, uint3x2 rhs);
        public static uint3x2 operator +(uint3x2 lhs, uint3x2 rhs);
        public static uint3x2 operator +(uint3x2 lhs, uint rhs);
        public static uint3x2 operator +(uint lhs, uint3x2 rhs);
        public static uint3x2 operator -(uint3x2 lhs, uint3x2 rhs);
        public static uint3x2 operator -(uint3x2 lhs, uint rhs);
        public static uint3x2 operator -(uint lhs, uint3x2 rhs);
        public static uint3x2 operator /(uint3x2 lhs, uint3x2 rhs);
        public static uint3x2 operator /(uint3x2 lhs, uint rhs);
        public static uint3x2 operator /(uint lhs, uint3x2 rhs);
        public static uint3x2 operator %(uint3x2 lhs, uint3x2 rhs);
        public static uint3x2 operator %(uint3x2 lhs, uint rhs);
        public static uint3x2 operator %(uint lhs, uint3x2 rhs);
        public static uint3x2 operator ++(uint3x2 val);
        public static uint3x2 operator --(uint3x2 val);
        public static bool3x2 operator <(uint3x2 lhs, uint3x2 rhs);
        public static bool3x2 operator <(uint3x2 lhs, uint rhs);
        public static bool3x2 operator <(uint lhs, uint3x2 rhs);
        public static bool3x2 operator <=(uint3x2 lhs, uint3x2 rhs);
        public static bool3x2 operator <=(uint3x2 lhs, uint rhs);
        public static bool3x2 operator <=(uint lhs, uint3x2 rhs);
        public static bool3x2 operator >(uint3x2 lhs, uint3x2 rhs);
        public static bool3x2 operator >(uint3x2 lhs, uint rhs);
        public static bool3x2 operator >(uint lhs, uint3x2 rhs);
        public static bool3x2 operator >=(uint3x2 lhs, uint3x2 rhs);
        public static bool3x2 operator >=(uint3x2 lhs, uint rhs);
        public static bool3x2 operator >=(uint lhs, uint3x2 rhs);
        public static uint3x2 operator -(uint3x2 val);
        public static uint3x2 operator +(uint3x2 val);
        public static uint3x2 operator <<(uint3x2 x, int n);
        public static uint3x2 operator >>(uint3x2 x, int n);
        public static bool3x2 operator ==(uint3x2 lhs, uint3x2 rhs);
        public static bool3x2 operator ==(uint3x2 lhs, uint rhs);
        public static bool3x2 operator ==(uint lhs, uint3x2 rhs);
        public static bool3x2 operator !=(uint3x2 lhs, uint3x2 rhs);
        public static bool3x2 operator !=(uint3x2 lhs, uint rhs);
        public static bool3x2 operator !=(uint lhs, uint3x2 rhs);
        public static uint3x2 operator ~(uint3x2 val);
        public static uint3x2 operator &(uint3x2 lhs, uint3x2 rhs);
        public static uint3x2 operator &(uint3x2 lhs, uint rhs);
        public static uint3x2 operator &(uint lhs, uint3x2 rhs);
        public static uint3x2 operator |(uint3x2 lhs, uint3x2 rhs);
        public static uint3x2 operator |(uint3x2 lhs, uint rhs);
        public static uint3x2 operator |(uint lhs, uint3x2 rhs);
        public static uint3x2 operator ^(uint3x2 lhs, uint3x2 rhs);
        public static uint3x2 operator ^(uint3x2 lhs, uint rhs);
        public static uint3x2 operator ^(uint lhs, uint3x2 rhs);

        public static implicit operator uint3x2(uint v);
        public static explicit operator uint3x2(bool v);
        public static explicit operator uint3x2(bool3x2 v);
        public static explicit operator uint3x2(int v);
        public static explicit operator uint3x2(int3x2 v);
        public static explicit operator uint3x2(float v);
        public static explicit operator uint3x2(float3x2 v);
        public static explicit operator uint3x2(double v);
        public static explicit operator uint3x2(double3x2 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct uint3x3 : IEquatable<uint3x3>, IFormattable
    {
        public uint3 c0;
        public uint3 c1;
        public uint3 c2;
        public static readonly uint3x3 identity;
        public static readonly uint3x3 zero;

        public uint3x3(uint3 c0, uint3 c1, uint3 c2);
        public uint3x3(uint m00, uint m01, uint m02, uint m10, uint m11, uint m12, uint m20, uint m21, uint m22);
        public uint3x3(uint v);
        public uint3x3(bool v);
        public uint3x3(bool3x3 v);
        public uint3x3(int v);
        public uint3x3(int3x3 v);
        public uint3x3(float v);
        public uint3x3(float3x3 v);
        public uint3x3(double v);
        public uint3x3(double3x3 v);

        public ref uint3 this[int index] { get; }

        public bool Equals(uint3x3 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static uint3x3 operator *(uint3x3 lhs, uint3x3 rhs);
        public static uint3x3 operator *(uint3x3 lhs, uint rhs);
        public static uint3x3 operator *(uint lhs, uint3x3 rhs);
        public static uint3x3 operator +(uint3x3 lhs, uint3x3 rhs);
        public static uint3x3 operator +(uint3x3 lhs, uint rhs);
        public static uint3x3 operator +(uint lhs, uint3x3 rhs);
        public static uint3x3 operator -(uint3x3 lhs, uint3x3 rhs);
        public static uint3x3 operator -(uint3x3 lhs, uint rhs);
        public static uint3x3 operator -(uint lhs, uint3x3 rhs);
        public static uint3x3 operator /(uint3x3 lhs, uint3x3 rhs);
        public static uint3x3 operator /(uint3x3 lhs, uint rhs);
        public static uint3x3 operator /(uint lhs, uint3x3 rhs);
        public static uint3x3 operator %(uint3x3 lhs, uint3x3 rhs);
        public static uint3x3 operator %(uint3x3 lhs, uint rhs);
        public static uint3x3 operator %(uint lhs, uint3x3 rhs);
        public static uint3x3 operator ++(uint3x3 val);
        public static uint3x3 operator --(uint3x3 val);
        public static bool3x3 operator <(uint3x3 lhs, uint3x3 rhs);
        public static bool3x3 operator <(uint3x3 lhs, uint rhs);
        public static bool3x3 operator <(uint lhs, uint3x3 rhs);
        public static bool3x3 operator <=(uint3x3 lhs, uint3x3 rhs);
        public static bool3x3 operator <=(uint3x3 lhs, uint rhs);
        public static bool3x3 operator <=(uint lhs, uint3x3 rhs);
        public static bool3x3 operator >(uint3x3 lhs, uint3x3 rhs);
        public static bool3x3 operator >(uint3x3 lhs, uint rhs);
        public static bool3x3 operator >(uint lhs, uint3x3 rhs);
        public static bool3x3 operator >=(uint3x3 lhs, uint3x3 rhs);
        public static bool3x3 operator >=(uint3x3 lhs, uint rhs);
        public static bool3x3 operator >=(uint lhs, uint3x3 rhs);
        public static uint3x3 operator -(uint3x3 val);
        public static uint3x3 operator +(uint3x3 val);
        public static uint3x3 operator <<(uint3x3 x, int n);
        public static uint3x3 operator >>(uint3x3 x, int n);
        public static bool3x3 operator ==(uint3x3 lhs, uint3x3 rhs);
        public static bool3x3 operator ==(uint3x3 lhs, uint rhs);
        public static bool3x3 operator ==(uint lhs, uint3x3 rhs);
        public static bool3x3 operator !=(uint3x3 lhs, uint3x3 rhs);
        public static bool3x3 operator !=(uint3x3 lhs, uint rhs);
        public static bool3x3 operator !=(uint lhs, uint3x3 rhs);
        public static uint3x3 operator ~(uint3x3 val);
        public static uint3x3 operator &(uint3x3 lhs, uint3x3 rhs);
        public static uint3x3 operator &(uint3x3 lhs, uint rhs);
        public static uint3x3 operator &(uint lhs, uint3x3 rhs);
        public static uint3x3 operator |(uint3x3 lhs, uint3x3 rhs);
        public static uint3x3 operator |(uint3x3 lhs, uint rhs);
        public static uint3x3 operator |(uint lhs, uint3x3 rhs);
        public static uint3x3 operator ^(uint3x3 lhs, uint3x3 rhs);
        public static uint3x3 operator ^(uint3x3 lhs, uint rhs);
        public static uint3x3 operator ^(uint lhs, uint3x3 rhs);

        public static implicit operator uint3x3(uint v);
        public static explicit operator uint3x3(bool v);
        public static explicit operator uint3x3(bool3x3 v);
        public static explicit operator uint3x3(int v);
        public static explicit operator uint3x3(int3x3 v);
        public static explicit operator uint3x3(float v);
        public static explicit operator uint3x3(float3x3 v);
        public static explicit operator uint3x3(double v);
        public static explicit operator uint3x3(double3x3 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct uint3x4 : IEquatable<uint3x4>, IFormattable
    {
        public uint3 c0;
        public uint3 c1;
        public uint3 c2;
        public uint3 c3;
        public static readonly uint3x4 zero;

        public uint3x4(uint3 c0, uint3 c1, uint3 c2, uint3 c3);
        public uint3x4(uint m00, uint m01, uint m02, uint m03, uint m10, uint m11, uint m12, uint m13, uint m20, uint m21, uint m22, uint m23);
        public uint3x4(uint v);
        public uint3x4(bool v);
        public uint3x4(bool3x4 v);
        public uint3x4(int v);
        public uint3x4(int3x4 v);
        public uint3x4(float v);
        public uint3x4(float3x4 v);
        public uint3x4(double v);
        public uint3x4(double3x4 v);

        public ref uint3 this[int index] { get; }

        public bool Equals(uint3x4 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static uint3x4 operator *(uint3x4 lhs, uint3x4 rhs);
        public static uint3x4 operator *(uint3x4 lhs, uint rhs);
        public static uint3x4 operator *(uint lhs, uint3x4 rhs);
        public static uint3x4 operator +(uint3x4 lhs, uint3x4 rhs);
        public static uint3x4 operator +(uint3x4 lhs, uint rhs);
        public static uint3x4 operator +(uint lhs, uint3x4 rhs);
        public static uint3x4 operator -(uint3x4 lhs, uint3x4 rhs);
        public static uint3x4 operator -(uint3x4 lhs, uint rhs);
        public static uint3x4 operator -(uint lhs, uint3x4 rhs);
        public static uint3x4 operator /(uint3x4 lhs, uint3x4 rhs);
        public static uint3x4 operator /(uint3x4 lhs, uint rhs);
        public static uint3x4 operator /(uint lhs, uint3x4 rhs);
        public static uint3x4 operator %(uint3x4 lhs, uint3x4 rhs);
        public static uint3x4 operator %(uint3x4 lhs, uint rhs);
        public static uint3x4 operator %(uint lhs, uint3x4 rhs);
        public static uint3x4 operator ++(uint3x4 val);
        public static uint3x4 operator --(uint3x4 val);
        public static bool3x4 operator <(uint3x4 lhs, uint3x4 rhs);
        public static bool3x4 operator <(uint3x4 lhs, uint rhs);
        public static bool3x4 operator <(uint lhs, uint3x4 rhs);
        public static bool3x4 operator <=(uint3x4 lhs, uint3x4 rhs);
        public static bool3x4 operator <=(uint3x4 lhs, uint rhs);
        public static bool3x4 operator <=(uint lhs, uint3x4 rhs);
        public static bool3x4 operator >(uint3x4 lhs, uint3x4 rhs);
        public static bool3x4 operator >(uint3x4 lhs, uint rhs);
        public static bool3x4 operator >(uint lhs, uint3x4 rhs);
        public static bool3x4 operator >=(uint3x4 lhs, uint3x4 rhs);
        public static bool3x4 operator >=(uint3x4 lhs, uint rhs);
        public static bool3x4 operator >=(uint lhs, uint3x4 rhs);
        public static uint3x4 operator -(uint3x4 val);
        public static uint3x4 operator +(uint3x4 val);
        public static uint3x4 operator <<(uint3x4 x, int n);
        public static uint3x4 operator >>(uint3x4 x, int n);
        public static bool3x4 operator ==(uint3x4 lhs, uint3x4 rhs);
        public static bool3x4 operator ==(uint3x4 lhs, uint rhs);
        public static bool3x4 operator ==(uint lhs, uint3x4 rhs);
        public static bool3x4 operator !=(uint3x4 lhs, uint3x4 rhs);
        public static bool3x4 operator !=(uint3x4 lhs, uint rhs);
        public static bool3x4 operator !=(uint lhs, uint3x4 rhs);
        public static uint3x4 operator ~(uint3x4 val);
        public static uint3x4 operator &(uint3x4 lhs, uint3x4 rhs);
        public static uint3x4 operator &(uint3x4 lhs, uint rhs);
        public static uint3x4 operator &(uint lhs, uint3x4 rhs);
        public static uint3x4 operator |(uint3x4 lhs, uint3x4 rhs);
        public static uint3x4 operator |(uint3x4 lhs, uint rhs);
        public static uint3x4 operator |(uint lhs, uint3x4 rhs);
        public static uint3x4 operator ^(uint3x4 lhs, uint3x4 rhs);
        public static uint3x4 operator ^(uint3x4 lhs, uint rhs);
        public static uint3x4 operator ^(uint lhs, uint3x4 rhs);

        public static implicit operator uint3x4(uint v);
        public static explicit operator uint3x4(bool v);
        public static explicit operator uint3x4(bool3x4 v);
        public static explicit operator uint3x4(int v);
        public static explicit operator uint3x4(int3x4 v);
        public static explicit operator uint3x4(float v);
        public static explicit operator uint3x4(float3x4 v);
        public static explicit operator uint3x4(double v);
        public static explicit operator uint3x4(double3x4 v);
    }
}
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    [DebuggerTypeProxy(typeof(DebuggerProxy))]
    public struct uint4 : IEquatable<uint4>, IFormattable
    {
        public uint x;
        public uint y;
        public uint z;
        public uint w;
        public static readonly uint4 zero;

        public uint4(uint x, uint y, uint z, uint w);
        public uint4(uint x, uint y, uint2 zw);
        public uint4(uint x, uint2 yz, uint w);
        public uint4(uint x, uint3 yzw);
        public uint4(uint2 xy, uint z, uint w);
        public uint4(uint2 xy, uint2 zw);
        public uint4(uint3 xyz, uint w);
        public uint4(uint4 xyzw);
        public uint4(uint v);
        public uint4(bool v);
        public uint4(bool4 v);
        public uint4(int v);
        public uint4(int4 v);
        public uint4(float v);
        public uint4(float4 v);
        public uint4(double v);
        public uint4(double4 v);

        public uint this[int index] { get; set; }
        [EditorBrowsable(Never)]
        public uint4 xxxx { get; }
        [EditorBrowsable(Never)]
        public uint4 xxxy { get; }
        [EditorBrowsable(Never)]
        public uint4 xxxz { get; }
        [EditorBrowsable(Never)]
        public uint4 xxxw { get; }
        [EditorBrowsable(Never)]
        public uint4 xxyx { get; }
        [EditorBrowsable(Never)]
        public uint4 xxyy { get; }
        [EditorBrowsable(Never)]
        public uint4 xxyz { get; }
        [EditorBrowsable(Never)]
        public uint4 xxyw { get; }
        [EditorBrowsable(Never)]
        public uint4 xxzx { get; }
        [EditorBrowsable(Never)]
        public uint4 xxzy { get; }
        [EditorBrowsable(Never)]
        public uint4 xxzz { get; }
        [EditorBrowsable(Never)]
        public uint4 xxzw { get; }
        [EditorBrowsable(Never)]
        public uint4 xxwx { get; }
        [EditorBrowsable(Never)]
        public uint4 xxwy { get; }
        [EditorBrowsable(Never)]
        public uint4 xxwz { get; }
        [EditorBrowsable(Never)]
        public uint4 xxww { get; }
        [EditorBrowsable(Never)]
        public uint4 xyxx { get; }
        [EditorBrowsable(Never)]
        public uint4 xyxy { get; }
        [EditorBrowsable(Never)]
        public uint4 xyxz { get; }
        [EditorBrowsable(Never)]
        public uint4 xyxw { get; }
        [EditorBrowsable(Never)]
        public uint4 xyyx { get; }
        [EditorBrowsable(Never)]
        public uint4 xyyy { get; }
        [EditorBrowsable(Never)]
        public uint4 xyyz { get; }
        [EditorBrowsable(Never)]
        public uint4 xyyw { get; }
        [EditorBrowsable(Never)]
        public uint4 xyzx { get; }
        [EditorBrowsable(Never)]
        public uint4 xyzy { get; }
        [EditorBrowsable(Never)]
        public uint4 xyzz { get; }
        [EditorBrowsable(Never)]
        public uint4 xyzw { get; set; }
        [EditorBrowsable(Never)]
        public uint4 xywx { get; }
        [EditorBrowsable(Never)]
        public uint4 xywy { get; }
        [EditorBrowsable(Never)]
        public uint4 xywz { get; set; }
        [EditorBrowsable(Never)]
        public uint4 xyww { get; }
        [EditorBrowsable(Never)]
        public uint4 xzxx { get; }
        [EditorBrowsable(Never)]
        public uint4 xzxy { get; }
        [EditorBrowsable(Never)]
        public uint4 xzxz { get; }
        [EditorBrowsable(Never)]
        public uint4 xzxw { get; }
        [EditorBrowsable(Never)]
        public uint4 xzyx { get; }
        [EditorBrowsable(Never)]
        public uint4 xzyy { get; }
        [EditorBrowsable(Never)]
        public uint4 xzyz { get; }
        [EditorBrowsable(Never)]
        public uint4 xzyw { get; set; }
        [EditorBrowsable(Never)]
        public uint4 xzzx { get; }
        [EditorBrowsable(Never)]
        public uint4 xzzy { get; }
        [EditorBrowsable(Never)]
        public uint4 xzzz { get; }
        [EditorBrowsable(Never)]
        public uint4 xzzw { get; }
        [EditorBrowsable(Never)]
        public uint4 xzwx { get; }
        [EditorBrowsable(Never)]
        public uint4 xzwy { get; set; }
        [EditorBrowsable(Never)]
        public uint4 xzwz { get; }
        [EditorBrowsable(Never)]
        public uint4 xzww { get; }
        [EditorBrowsable(Never)]
        public uint4 xwxx { get; }
        [EditorBrowsable(Never)]
        public uint4 xwxy { get; }
        [EditorBrowsable(Never)]
        public uint4 xwxz { get; }
        [EditorBrowsable(Never)]
        public uint4 xwxw { get; }
        [EditorBrowsable(Never)]
        public uint4 xwyx { get; }
        [EditorBrowsable(Never)]
        public uint4 xwyy { get; }
        [EditorBrowsable(Never)]
        public uint4 xwyz { get; set; }
        [EditorBrowsable(Never)]
        public uint4 xwyw { get; }
        [EditorBrowsable(Never)]
        public uint4 xwzx { get; }
        [EditorBrowsable(Never)]
        public uint4 xwzy { get; set; }
        [EditorBrowsable(Never)]
        public uint4 xwzz { get; }
        [EditorBrowsable(Never)]
        public uint4 xwzw { get; }
        [EditorBrowsable(Never)]
        public uint4 xwwx { get; }
        [EditorBrowsable(Never)]
        public uint4 xwwy { get; }
        [EditorBrowsable(Never)]
        public uint4 xwwz { get; }
        [EditorBrowsable(Never)]
        public uint4 xwww { get; }
        [EditorBrowsable(Never)]
        public uint4 yxxx { get; }
        [EditorBrowsable(Never)]
        public uint4 yxxy { get; }
        [EditorBrowsable(Never)]
        public uint4 yxxz { get; }
        [EditorBrowsable(Never)]
        public uint4 yxxw { get; }
        [EditorBrowsable(Never)]
        public uint4 yxyx { get; }
        [EditorBrowsable(Never)]
        public uint4 yxyy { get; }
        [EditorBrowsable(Never)]
        public uint4 yxyz { get; }
        [EditorBrowsable(Never)]
        public uint4 yxyw { get; }
        [EditorBrowsable(Never)]
        public uint4 yxzx { get; }
        [EditorBrowsable(Never)]
        public uint4 yxzy { get; }
        [EditorBrowsable(Never)]
        public uint4 yxzz { get; }
        [EditorBrowsable(Never)]
        public uint4 yxzw { get; set; }
        [EditorBrowsable(Never)]
        public uint4 yxwx { get; }
        [EditorBrowsable(Never)]
        public uint4 yxwy { get; }
        [EditorBrowsable(Never)]
        public uint4 yxwz { get; set; }
        [EditorBrowsable(Never)]
        public uint4 yxww { get; }
        [EditorBrowsable(Never)]
        public uint4 yyxx { get; }
        [EditorBrowsable(Never)]
        public uint4 yyxy { get; }
        [EditorBrowsable(Never)]
        public uint4 yyxz { get; }
        [EditorBrowsable(Never)]
        public uint4 yyxw { get; }
        [EditorBrowsable(Never)]
        public uint4 yyyx { get; }
        [EditorBrowsable(Never)]
        public uint4 yyyy { get; }
        [EditorBrowsable(Never)]
        public uint4 yyyz { get; }
        [EditorBrowsable(Never)]
        public uint4 yyyw { get; }
        [EditorBrowsable(Never)]
        public uint4 yyzx { get; }
        [EditorBrowsable(Never)]
        public uint4 yyzy { get; }
        [EditorBrowsable(Never)]
        public uint4 yyzz { get; }
        [EditorBrowsable(Never)]
        public uint4 yyzw { get; }
        [EditorBrowsable(Never)]
        public uint4 yywx { get; }
        [EditorBrowsable(Never)]
        public uint4 yywy { get; }
        [EditorBrowsable(Never)]
        public uint4 yywz { get; }
        [EditorBrowsable(Never)]
        public uint4 yyww { get; }
        [EditorBrowsable(Never)]
        public uint4 yzxx { get; }
        [EditorBrowsable(Never)]
        public uint4 yzxy { get; }
        [EditorBrowsable(Never)]
        public uint4 yzxz { get; }
        [EditorBrowsable(Never)]
        public uint4 yzxw { get; set; }
        [EditorBrowsable(Never)]
        public uint4 yzyx { get; }
        [EditorBrowsable(Never)]
        public uint4 yzyy { get; }
        [EditorBrowsable(Never)]
        public uint4 yzyz { get; }
        [EditorBrowsable(Never)]
        public uint4 yzyw { get; }
        [EditorBrowsable(Never)]
        public uint4 yzzx { get; }
        [EditorBrowsable(Never)]
        public uint4 yzzy { get; }
        [EditorBrowsable(Never)]
        public uint4 yzzz { get; }
        [EditorBrowsable(Never)]
        public uint4 yzzw { get; }
        [EditorBrowsable(Never)]
        public uint4 yzwx { get; set; }
        [EditorBrowsable(Never)]
        public uint4 yzwy { get; }
        [EditorBrowsable(Never)]
        public uint4 yzwz { get; }
        [EditorBrowsable(Never)]
        public uint4 yzww { get; }
        [EditorBrowsable(Never)]
        public uint4 ywxx { get; }
        [EditorBrowsable(Never)]
        public uint4 ywxy { get; }
        [EditorBrowsable(Never)]
        public uint4 ywxz { get; set; }
        [EditorBrowsable(Never)]
        public uint4 ywxw { get; }
        [EditorBrowsable(Never)]
        public uint4 ywyx { get; }
        [EditorBrowsable(Never)]
        public uint4 ywyy { get; }
        [EditorBrowsable(Never)]
        public uint4 ywyz { get; }
        [EditorBrowsable(Never)]
        public uint4 ywyw { get; }
        [EditorBrowsable(Never)]
        public uint4 ywzx { get; set; }
        [EditorBrowsable(Never)]
        public uint4 ywzy { get; }
        [EditorBrowsable(Never)]
        public uint4 ywzz { get; }
        [EditorBrowsable(Never)]
        public uint4 ywzw { get; }
        [EditorBrowsable(Never)]
        public uint4 ywwx { get; }
        [EditorBrowsable(Never)]
        public uint4 ywwy { get; }
        [EditorBrowsable(Never)]
        public uint4 ywwz { get; }
        [EditorBrowsable(Never)]
        public uint4 ywww { get; }
        [EditorBrowsable(Never)]
        public uint4 zxxx { get; }
        [EditorBrowsable(Never)]
        public uint4 zxxy { get; }
        [EditorBrowsable(Never)]
        public uint4 zxxz { get; }
        [EditorBrowsable(Never)]
        public uint4 zxxw { get; }
        [EditorBrowsable(Never)]
        public uint4 zxyx { get; }
        [EditorBrowsable(Never)]
        public uint4 zxyy { get; }
        [EditorBrowsable(Never)]
        public uint4 zxyz { get; }
        [EditorBrowsable(Never)]
        public uint4 zxyw { get; set; }
        [EditorBrowsable(Never)]
        public uint4 zxzx { get; }
        [EditorBrowsable(Never)]
        public uint4 zxzy { get; }
        [EditorBrowsable(Never)]
        public uint4 zxzz { get; }
        [EditorBrowsable(Never)]
        public uint4 zxzw { get; }
        [EditorBrowsable(Never)]
        public uint4 zxwx { get; }
        [EditorBrowsable(Never)]
        public uint4 zxwy { get; set; }
        [EditorBrowsable(Never)]
        public uint4 zxwz { get; }
        [EditorBrowsable(Never)]
        public uint4 zxww { get; }
        [EditorBrowsable(Never)]
        public uint4 zyxx { get; }
        [EditorBrowsable(Never)]
        public uint4 zyxy { get; }
        [EditorBrowsable(Never)]
        public uint4 zyxz { get; }
        [EditorBrowsable(Never)]
        public uint4 zyxw { get; set; }
        [EditorBrowsable(Never)]
        public uint4 zyyx { get; }
        [EditorBrowsable(Never)]
        public uint4 zyyy { get; }
        [EditorBrowsable(Never)]
        public uint4 zyyz { get; }
        [EditorBrowsable(Never)]
        public uint4 zyyw { get; }
        [EditorBrowsable(Never)]
        public uint4 zyzx { get; }
        [EditorBrowsable(Never)]
        public uint4 zyzy { get; }
        [EditorBrowsable(Never)]
        public uint4 zyzz { get; }
        [EditorBrowsable(Never)]
        public uint4 zyzw { get; }
        [EditorBrowsable(Never)]
        public uint4 zywx { get; set; }
        [EditorBrowsable(Never)]
        public uint4 zywy { get; }
        [EditorBrowsable(Never)]
        public uint4 zywz { get; }
        [EditorBrowsable(Never)]
        public uint4 zyww { get; }
        [EditorBrowsable(Never)]
        public uint4 zzxx { get; }
        [EditorBrowsable(Never)]
        public uint4 zzxy { get; }
        [EditorBrowsable(Never)]
        public uint4 zzxz { get; }
        [EditorBrowsable(Never)]
        public uint4 zzxw { get; }
        [EditorBrowsable(Never)]
        public uint4 zzyx { get; }
        [EditorBrowsable(Never)]
        public uint4 zzyy { get; }
        [EditorBrowsable(Never)]
        public uint4 zzyz { get; }
        [EditorBrowsable(Never)]
        public uint4 zzyw { get; }
        [EditorBrowsable(Never)]
        public uint4 zzzx { get; }
        [EditorBrowsable(Never)]
        public uint4 zzzy { get; }
        [EditorBrowsable(Never)]
        public uint4 zzzz { get; }
        [EditorBrowsable(Never)]
        public uint4 zzzw { get; }
        [EditorBrowsable(Never)]
        public uint4 zzwx { get; }
        [EditorBrowsable(Never)]
        public uint4 zzwy { get; }
        [EditorBrowsable(Never)]
        public uint4 zzwz { get; }
        [EditorBrowsable(Never)]
        public uint4 zzww { get; }
        [EditorBrowsable(Never)]
        public uint4 zwxx { get; }
        [EditorBrowsable(Never)]
        public uint4 zwxy { get; set; }
        [EditorBrowsable(Never)]
        public uint4 zwxz { get; }
        [EditorBrowsable(Never)]
        public uint4 zwxw { get; }
        [EditorBrowsable(Never)]
        public uint4 zwyx { get; set; }
        [EditorBrowsable(Never)]
        public uint4 zwyy { get; }
        [EditorBrowsable(Never)]
        public uint4 zwyz { get; }
        [EditorBrowsable(Never)]
        public uint4 zwyw { get; }
        [EditorBrowsable(Never)]
        public uint4 zwzx { get; }
        [EditorBrowsable(Never)]
        public uint4 zwzy { get; }
        [EditorBrowsable(Never)]
        public uint4 zwzz { get; }
        [EditorBrowsable(Never)]
        public uint4 zwzw { get; }
        [EditorBrowsable(Never)]
        public uint4 zwwx { get; }
        [EditorBrowsable(Never)]
        public uint4 zwwy { get; }
        [EditorBrowsable(Never)]
        public uint4 zwwz { get; }
        [EditorBrowsable(Never)]
        public uint4 zwww { get; }
        [EditorBrowsable(Never)]
        public uint4 wxxx { get; }
        [EditorBrowsable(Never)]
        public uint4 wxxy { get; }
        [EditorBrowsable(Never)]
        public uint4 wxxz { get; }
        [EditorBrowsable(Never)]
        public uint4 wxxw { get; }
        [EditorBrowsable(Never)]
        public uint4 wxyx { get; }
        [EditorBrowsable(Never)]
        public uint4 wxyy { get; }
        [EditorBrowsable(Never)]
        public uint4 wxyz { get; set; }
        [EditorBrowsable(Never)]
        public uint4 wxyw { get; }
        [EditorBrowsable(Never)]
        public uint4 wxzx { get; }
        [EditorBrowsable(Never)]
        public uint4 wxzy { get; set; }
        [EditorBrowsable(Never)]
        public uint4 wxzz { get; }
        [EditorBrowsable(Never)]
        public uint4 wxzw { get; }
        [EditorBrowsable(Never)]
        public uint4 wxwx { get; }
        [EditorBrowsable(Never)]
        public uint4 wxwy { get; }
        [EditorBrowsable(Never)]
        public uint4 wxwz { get; }
        [EditorBrowsable(Never)]
        public uint4 wxww { get; }
        [EditorBrowsable(Never)]
        public uint4 wyxx { get; }
        [EditorBrowsable(Never)]
        public uint4 wyxy { get; }
        [EditorBrowsable(Never)]
        public uint4 wyxz { get; set; }
        [EditorBrowsable(Never)]
        public uint4 wyxw { get; }
        [EditorBrowsable(Never)]
        public uint4 wyyx { get; }
        [EditorBrowsable(Never)]
        public uint4 wyyy { get; }
        [EditorBrowsable(Never)]
        public uint4 wyyz { get; }
        [EditorBrowsable(Never)]
        public uint4 wyyw { get; }
        [EditorBrowsable(Never)]
        public uint4 wyzx { get; set; }
        [EditorBrowsable(Never)]
        public uint4 wyzy { get; }
        [EditorBrowsable(Never)]
        public uint4 wyzz { get; }
        [EditorBrowsable(Never)]
        public uint4 wyzw { get; }
        [EditorBrowsable(Never)]
        public uint4 wywx { get; }
        [EditorBrowsable(Never)]
        public uint4 wywy { get; }
        [EditorBrowsable(Never)]
        public uint4 wywz { get; }
        [EditorBrowsable(Never)]
        public uint4 wyww { get; }
        [EditorBrowsable(Never)]
        public uint4 wzxx { get; }
        [EditorBrowsable(Never)]
        public uint4 wzxy { get; set; }
        [EditorBrowsable(Never)]
        public uint4 wzxz { get; }
        [EditorBrowsable(Never)]
        public uint4 wzxw { get; }
        [EditorBrowsable(Never)]
        public uint4 wzyx { get; set; }
        [EditorBrowsable(Never)]
        public uint4 wzyy { get; }
        [EditorBrowsable(Never)]
        public uint4 wzyz { get; }
        [EditorBrowsable(Never)]
        public uint4 wzyw { get; }
        [EditorBrowsable(Never)]
        public uint4 wzzx { get; }
        [EditorBrowsable(Never)]
        public uint4 wzzy { get; }
        [EditorBrowsable(Never)]
        public uint4 wzzz { get; }
        [EditorBrowsable(Never)]
        public uint4 wzzw { get; }
        [EditorBrowsable(Never)]
        public uint4 wzwx { get; }
        [EditorBrowsable(Never)]
        public uint4 wzwy { get; }
        [EditorBrowsable(Never)]
        public uint4 wzwz { get; }
        [EditorBrowsable(Never)]
        public uint4 wzww { get; }
        [EditorBrowsable(Never)]
        public uint4 wwxx { get; }
        [EditorBrowsable(Never)]
        public uint4 wwxy { get; }
        [EditorBrowsable(Never)]
        public uint4 wwxz { get; }
        [EditorBrowsable(Never)]
        public uint4 wwxw { get; }
        [EditorBrowsable(Never)]
        public uint4 wwyx { get; }
        [EditorBrowsable(Never)]
        public uint4 wwyy { get; }
        [EditorBrowsable(Never)]
        public uint4 wwyz { get; }
        [EditorBrowsable(Never)]
        public uint4 wwyw { get; }
        [EditorBrowsable(Never)]
        public uint4 wwzx { get; }
        [EditorBrowsable(Never)]
        public uint4 wwzy { get; }
        [EditorBrowsable(Never)]
        public uint4 wwzz { get; }
        [EditorBrowsable(Never)]
        public uint4 wwzw { get; }
        [EditorBrowsable(Never)]
        public uint4 wwwx { get; }
        [EditorBrowsable(Never)]
        public uint4 wwwy { get; }
        [EditorBrowsable(Never)]
        public uint4 wwwz { get; }
        [EditorBrowsable(Never)]
        public uint4 wwww { get; }
        [EditorBrowsable(Never)]
        public uint3 xxx { get; }
        [EditorBrowsable(Never)]
        public uint3 xxy { get; }
        [EditorBrowsable(Never)]
        public uint3 xxz { get; }
        [EditorBrowsable(Never)]
        public uint3 xxw { get; }
        [EditorBrowsable(Never)]
        public uint3 xyx { get; }
        [EditorBrowsable(Never)]
        public uint3 xyy { get; }
        [EditorBrowsable(Never)]
        public uint3 xyz { get; set; }
        [EditorBrowsable(Never)]
        public uint3 xyw { get; set; }
        [EditorBrowsable(Never)]
        public uint3 xzx { get; }
        [EditorBrowsable(Never)]
        public uint3 xzy { get; set; }
        [EditorBrowsable(Never)]
        public uint3 xzz { get; }
        [EditorBrowsable(Never)]
        public uint3 xzw { get; set; }
        [EditorBrowsable(Never)]
        public uint3 xwx { get; }
        [EditorBrowsable(Never)]
        public uint3 xwy { get; set; }
        [EditorBrowsable(Never)]
        public uint3 xwz { get; set; }
        [EditorBrowsable(Never)]
        public uint3 xww { get; }
        [EditorBrowsable(Never)]
        public uint3 yxx { get; }
        [EditorBrowsable(Never)]
        public uint3 yxy { get; }
        [EditorBrowsable(Never)]
        public uint3 yxz { get; set; }
        [EditorBrowsable(Never)]
        public uint3 yxw { get; set; }
        [EditorBrowsable(Never)]
        public uint3 yyx { get; }
        [EditorBrowsable(Never)]
        public uint3 yyy { get; }
        [EditorBrowsable(Never)]
        public uint3 yyz { get; }
        [EditorBrowsable(Never)]
        public uint3 yyw { get; }
        [EditorBrowsable(Never)]
        public uint3 yzx { get; set; }
        [EditorBrowsable(Never)]
        public uint3 yzy { get; }
        [EditorBrowsable(Never)]
        public uint3 yzz { get; }
        [EditorBrowsable(Never)]
        public uint3 yzw { get; set; }
        [EditorBrowsable(Never)]
        public uint3 ywx { get; set; }
        [EditorBrowsable(Never)]
        public uint3 ywy { get; }
        [EditorBrowsable(Never)]
        public uint3 ywz { get; set; }
        [EditorBrowsable(Never)]
        public uint3 yww { get; }
        [EditorBrowsable(Never)]
        public uint3 zxx { get; }
        [EditorBrowsable(Never)]
        public uint3 zxy { get; set; }
        [EditorBrowsable(Never)]
        public uint3 zxz { get; }
        [EditorBrowsable(Never)]
        public uint3 zxw { get; set; }
        [EditorBrowsable(Never)]
        public uint3 zyx { get; set; }
        [EditorBrowsable(Never)]
        public uint3 zyy { get; }
        [EditorBrowsable(Never)]
        public uint3 zyz { get; }
        [EditorBrowsable(Never)]
        public uint3 zyw { get; set; }
        [EditorBrowsable(Never)]
        public uint3 zzx { get; }
        [EditorBrowsable(Never)]
        public uint3 zzy { get; }
        [EditorBrowsable(Never)]
        public uint3 zzz { get; }
        [EditorBrowsable(Never)]
        public uint3 zzw { get; }
        [EditorBrowsable(Never)]
        public uint3 zwx { get; set; }
        [EditorBrowsable(Never)]
        public uint3 zwy { get; set; }
        [EditorBrowsable(Never)]
        public uint3 zwz { get; }
        [EditorBrowsable(Never)]
        public uint3 zww { get; }
        [EditorBrowsable(Never)]
        public uint3 wxx { get; }
        [EditorBrowsable(Never)]
        public uint3 wxy { get; set; }
        [EditorBrowsable(Never)]
        public uint3 wxz { get; set; }
        [EditorBrowsable(Never)]
        public uint3 wxw { get; }
        [EditorBrowsable(Never)]
        public uint3 wyx { get; set; }
        [EditorBrowsable(Never)]
        public uint3 wyy { get; }
        [EditorBrowsable(Never)]
        public uint3 wyz { get; set; }
        [EditorBrowsable(Never)]
        public uint3 wyw { get; }
        [EditorBrowsable(Never)]
        public uint3 wzx { get; set; }
        [EditorBrowsable(Never)]
        public uint3 wzy { get; set; }
        [EditorBrowsable(Never)]
        public uint3 wzz { get; }
        [EditorBrowsable(Never)]
        public uint3 wzw { get; }
        [EditorBrowsable(Never)]
        public uint3 wwx { get; }
        [EditorBrowsable(Never)]
        public uint3 wwy { get; }
        [EditorBrowsable(Never)]
        public uint3 wwz { get; }
        [EditorBrowsable(Never)]
        public uint3 www { get; }
        [EditorBrowsable(Never)]
        public uint2 xx { get; }
        [EditorBrowsable(Never)]
        public uint2 xy { get; set; }
        [EditorBrowsable(Never)]
        public uint2 xz { get; set; }
        [EditorBrowsable(Never)]
        public uint2 xw { get; set; }
        [EditorBrowsable(Never)]
        public uint2 yx { get; set; }
        [EditorBrowsable(Never)]
        public uint2 yy { get; }
        [EditorBrowsable(Never)]
        public uint2 yz { get; set; }
        [EditorBrowsable(Never)]
        public uint2 yw { get; set; }
        [EditorBrowsable(Never)]
        public uint2 zx { get; set; }
        [EditorBrowsable(Never)]
        public uint2 zy { get; set; }
        [EditorBrowsable(Never)]
        public uint2 zz { get; }
        [EditorBrowsable(Never)]
        public uint2 zw { get; set; }
        [EditorBrowsable(Never)]
        public uint2 wx { get; set; }
        [EditorBrowsable(Never)]
        public uint2 wy { get; set; }
        [EditorBrowsable(Never)]
        public uint2 wz { get; set; }
        [EditorBrowsable(Never)]
        public uint2 ww { get; }

        public bool Equals(uint4 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static uint4 operator *(uint4 lhs, uint4 rhs);
        public static uint4 operator *(uint4 lhs, uint rhs);
        public static uint4 operator *(uint lhs, uint4 rhs);
        public static uint4 operator +(uint4 lhs, uint4 rhs);
        public static uint4 operator +(uint4 lhs, uint rhs);
        public static uint4 operator +(uint lhs, uint4 rhs);
        public static uint4 operator -(uint4 lhs, uint4 rhs);
        public static uint4 operator -(uint4 lhs, uint rhs);
        public static uint4 operator -(uint lhs, uint4 rhs);
        public static uint4 operator /(uint4 lhs, uint4 rhs);
        public static uint4 operator /(uint4 lhs, uint rhs);
        public static uint4 operator /(uint lhs, uint4 rhs);
        public static uint4 operator %(uint4 lhs, uint4 rhs);
        public static uint4 operator %(uint4 lhs, uint rhs);
        public static uint4 operator %(uint lhs, uint4 rhs);
        public static uint4 operator ++(uint4 val);
        public static uint4 operator --(uint4 val);
        public static bool4 operator <(uint4 lhs, uint4 rhs);
        public static bool4 operator <(uint4 lhs, uint rhs);
        public static bool4 operator <(uint lhs, uint4 rhs);
        public static bool4 operator <=(uint4 lhs, uint4 rhs);
        public static bool4 operator <=(uint4 lhs, uint rhs);
        public static bool4 operator <=(uint lhs, uint4 rhs);
        public static bool4 operator >(uint4 lhs, uint4 rhs);
        public static bool4 operator >(uint4 lhs, uint rhs);
        public static bool4 operator >(uint lhs, uint4 rhs);
        public static bool4 operator >=(uint4 lhs, uint4 rhs);
        public static bool4 operator >=(uint4 lhs, uint rhs);
        public static bool4 operator >=(uint lhs, uint4 rhs);
        public static uint4 operator -(uint4 val);
        public static uint4 operator +(uint4 val);
        public static uint4 operator <<(uint4 x, int n);
        public static uint4 operator >>(uint4 x, int n);
        public static bool4 operator ==(uint4 lhs, uint4 rhs);
        public static bool4 operator ==(uint4 lhs, uint rhs);
        public static bool4 operator ==(uint lhs, uint4 rhs);
        public static bool4 operator !=(uint4 lhs, uint4 rhs);
        public static bool4 operator !=(uint4 lhs, uint rhs);
        public static bool4 operator !=(uint lhs, uint4 rhs);
        public static uint4 operator ~(uint4 val);
        public static uint4 operator &(uint4 lhs, uint4 rhs);
        public static uint4 operator &(uint4 lhs, uint rhs);
        public static uint4 operator &(uint lhs, uint4 rhs);
        public static uint4 operator |(uint4 lhs, uint4 rhs);
        public static uint4 operator |(uint4 lhs, uint rhs);
        public static uint4 operator |(uint lhs, uint4 rhs);
        public static uint4 operator ^(uint4 lhs, uint4 rhs);
        public static uint4 operator ^(uint4 lhs, uint rhs);
        public static uint4 operator ^(uint lhs, uint4 rhs);

        public static implicit operator uint4(uint v);
        public static explicit operator uint4(bool v);
        public static explicit operator uint4(bool4 v);
        public static explicit operator uint4(int v);
        public static explicit operator uint4(int4 v);
        public static explicit operator uint4(float v);
        public static explicit operator uint4(float4 v);
        public static explicit operator uint4(double v);
        public static explicit operator uint4(double4 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct uint4x2 : IEquatable<uint4x2>, IFormattable
    {
        public uint4 c0;
        public uint4 c1;
        public static readonly uint4x2 zero;

        public uint4x2(uint4 c0, uint4 c1);
        public uint4x2(uint m00, uint m01, uint m10, uint m11, uint m20, uint m21, uint m30, uint m31);
        public uint4x2(uint v);
        public uint4x2(bool v);
        public uint4x2(bool4x2 v);
        public uint4x2(int v);
        public uint4x2(int4x2 v);
        public uint4x2(float v);
        public uint4x2(float4x2 v);
        public uint4x2(double v);
        public uint4x2(double4x2 v);

        public ref uint4 this[int index] { get; }

        public bool Equals(uint4x2 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static uint4x2 operator *(uint4x2 lhs, uint4x2 rhs);
        public static uint4x2 operator *(uint4x2 lhs, uint rhs);
        public static uint4x2 operator *(uint lhs, uint4x2 rhs);
        public static uint4x2 operator +(uint4x2 lhs, uint4x2 rhs);
        public static uint4x2 operator +(uint4x2 lhs, uint rhs);
        public static uint4x2 operator +(uint lhs, uint4x2 rhs);
        public static uint4x2 operator -(uint4x2 lhs, uint4x2 rhs);
        public static uint4x2 operator -(uint4x2 lhs, uint rhs);
        public static uint4x2 operator -(uint lhs, uint4x2 rhs);
        public static uint4x2 operator /(uint4x2 lhs, uint4x2 rhs);
        public static uint4x2 operator /(uint4x2 lhs, uint rhs);
        public static uint4x2 operator /(uint lhs, uint4x2 rhs);
        public static uint4x2 operator %(uint4x2 lhs, uint4x2 rhs);
        public static uint4x2 operator %(uint4x2 lhs, uint rhs);
        public static uint4x2 operator %(uint lhs, uint4x2 rhs);
        public static uint4x2 operator ++(uint4x2 val);
        public static uint4x2 operator --(uint4x2 val);
        public static bool4x2 operator <(uint4x2 lhs, uint4x2 rhs);
        public static bool4x2 operator <(uint4x2 lhs, uint rhs);
        public static bool4x2 operator <(uint lhs, uint4x2 rhs);
        public static bool4x2 operator <=(uint4x2 lhs, uint4x2 rhs);
        public static bool4x2 operator <=(uint4x2 lhs, uint rhs);
        public static bool4x2 operator <=(uint lhs, uint4x2 rhs);
        public static bool4x2 operator >(uint4x2 lhs, uint4x2 rhs);
        public static bool4x2 operator >(uint4x2 lhs, uint rhs);
        public static bool4x2 operator >(uint lhs, uint4x2 rhs);
        public static bool4x2 operator >=(uint4x2 lhs, uint4x2 rhs);
        public static bool4x2 operator >=(uint4x2 lhs, uint rhs);
        public static bool4x2 operator >=(uint lhs, uint4x2 rhs);
        public static uint4x2 operator -(uint4x2 val);
        public static uint4x2 operator +(uint4x2 val);
        public static uint4x2 operator <<(uint4x2 x, int n);
        public static uint4x2 operator >>(uint4x2 x, int n);
        public static bool4x2 operator ==(uint4x2 lhs, uint4x2 rhs);
        public static bool4x2 operator ==(uint4x2 lhs, uint rhs);
        public static bool4x2 operator ==(uint lhs, uint4x2 rhs);
        public static bool4x2 operator !=(uint4x2 lhs, uint4x2 rhs);
        public static bool4x2 operator !=(uint4x2 lhs, uint rhs);
        public static bool4x2 operator !=(uint lhs, uint4x2 rhs);
        public static uint4x2 operator ~(uint4x2 val);
        public static uint4x2 operator &(uint4x2 lhs, uint4x2 rhs);
        public static uint4x2 operator &(uint4x2 lhs, uint rhs);
        public static uint4x2 operator &(uint lhs, uint4x2 rhs);
        public static uint4x2 operator |(uint4x2 lhs, uint4x2 rhs);
        public static uint4x2 operator |(uint4x2 lhs, uint rhs);
        public static uint4x2 operator |(uint lhs, uint4x2 rhs);
        public static uint4x2 operator ^(uint4x2 lhs, uint4x2 rhs);
        public static uint4x2 operator ^(uint4x2 lhs, uint rhs);
        public static uint4x2 operator ^(uint lhs, uint4x2 rhs);

        public static implicit operator uint4x2(uint v);
        public static explicit operator uint4x2(bool v);
        public static explicit operator uint4x2(bool4x2 v);
        public static explicit operator uint4x2(int v);
        public static explicit operator uint4x2(int4x2 v);
        public static explicit operator uint4x2(float v);
        public static explicit operator uint4x2(float4x2 v);
        public static explicit operator uint4x2(double v);
        public static explicit operator uint4x2(double4x2 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct uint4x3 : IEquatable<uint4x3>, IFormattable
    {
        public uint4 c0;
        public uint4 c1;
        public uint4 c2;
        public static readonly uint4x3 zero;

        public uint4x3(uint4 c0, uint4 c1, uint4 c2);
        public uint4x3(uint m00, uint m01, uint m02, uint m10, uint m11, uint m12, uint m20, uint m21, uint m22, uint m30, uint m31, uint m32);
        public uint4x3(uint v);
        public uint4x3(bool v);
        public uint4x3(bool4x3 v);
        public uint4x3(int v);
        public uint4x3(int4x3 v);
        public uint4x3(float v);
        public uint4x3(float4x3 v);
        public uint4x3(double v);
        public uint4x3(double4x3 v);

        public ref uint4 this[int index] { get; }

        public bool Equals(uint4x3 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static uint4x3 operator *(uint4x3 lhs, uint4x3 rhs);
        public static uint4x3 operator *(uint4x3 lhs, uint rhs);
        public static uint4x3 operator *(uint lhs, uint4x3 rhs);
        public static uint4x3 operator +(uint4x3 lhs, uint4x3 rhs);
        public static uint4x3 operator +(uint4x3 lhs, uint rhs);
        public static uint4x3 operator +(uint lhs, uint4x3 rhs);
        public static uint4x3 operator -(uint4x3 lhs, uint4x3 rhs);
        public static uint4x3 operator -(uint4x3 lhs, uint rhs);
        public static uint4x3 operator -(uint lhs, uint4x3 rhs);
        public static uint4x3 operator /(uint4x3 lhs, uint4x3 rhs);
        public static uint4x3 operator /(uint4x3 lhs, uint rhs);
        public static uint4x3 operator /(uint lhs, uint4x3 rhs);
        public static uint4x3 operator %(uint4x3 lhs, uint4x3 rhs);
        public static uint4x3 operator %(uint4x3 lhs, uint rhs);
        public static uint4x3 operator %(uint lhs, uint4x3 rhs);
        public static uint4x3 operator ++(uint4x3 val);
        public static uint4x3 operator --(uint4x3 val);
        public static bool4x3 operator <(uint4x3 lhs, uint4x3 rhs);
        public static bool4x3 operator <(uint4x3 lhs, uint rhs);
        public static bool4x3 operator <(uint lhs, uint4x3 rhs);
        public static bool4x3 operator <=(uint4x3 lhs, uint4x3 rhs);
        public static bool4x3 operator <=(uint4x3 lhs, uint rhs);
        public static bool4x3 operator <=(uint lhs, uint4x3 rhs);
        public static bool4x3 operator >(uint4x3 lhs, uint4x3 rhs);
        public static bool4x3 operator >(uint4x3 lhs, uint rhs);
        public static bool4x3 operator >(uint lhs, uint4x3 rhs);
        public static bool4x3 operator >=(uint4x3 lhs, uint4x3 rhs);
        public static bool4x3 operator >=(uint4x3 lhs, uint rhs);
        public static bool4x3 operator >=(uint lhs, uint4x3 rhs);
        public static uint4x3 operator -(uint4x3 val);
        public static uint4x3 operator +(uint4x3 val);
        public static uint4x3 operator <<(uint4x3 x, int n);
        public static uint4x3 operator >>(uint4x3 x, int n);
        public static bool4x3 operator ==(uint4x3 lhs, uint4x3 rhs);
        public static bool4x3 operator ==(uint4x3 lhs, uint rhs);
        public static bool4x3 operator ==(uint lhs, uint4x3 rhs);
        public static bool4x3 operator !=(uint4x3 lhs, uint4x3 rhs);
        public static bool4x3 operator !=(uint4x3 lhs, uint rhs);
        public static bool4x3 operator !=(uint lhs, uint4x3 rhs);
        public static uint4x3 operator ~(uint4x3 val);
        public static uint4x3 operator &(uint4x3 lhs, uint4x3 rhs);
        public static uint4x3 operator &(uint4x3 lhs, uint rhs);
        public static uint4x3 operator &(uint lhs, uint4x3 rhs);
        public static uint4x3 operator |(uint4x3 lhs, uint4x3 rhs);
        public static uint4x3 operator |(uint4x3 lhs, uint rhs);
        public static uint4x3 operator |(uint lhs, uint4x3 rhs);
        public static uint4x3 operator ^(uint4x3 lhs, uint4x3 rhs);
        public static uint4x3 operator ^(uint4x3 lhs, uint rhs);
        public static uint4x3 operator ^(uint lhs, uint4x3 rhs);

        public static implicit operator uint4x3(uint v);
        public static explicit operator uint4x3(bool v);
        public static explicit operator uint4x3(bool4x3 v);
        public static explicit operator uint4x3(int v);
        public static explicit operator uint4x3(int4x3 v);
        public static explicit operator uint4x3(float v);
        public static explicit operator uint4x3(float4x3 v);
        public static explicit operator uint4x3(double v);
        public static explicit operator uint4x3(double4x3 v);
    }
}
using System;
using System.Reflection;

namespace Unity.Mathematics
{
    [DefaultMember("Item")]
    public struct uint4x4 : IEquatable<uint4x4>, IFormattable
    {
        public uint4 c0;
        public uint4 c1;
        public uint4 c2;
        public uint4 c3;
        public static readonly uint4x4 identity;
        public static readonly uint4x4 zero;

        public uint4x4(uint4 c0, uint4 c1, uint4 c2, uint4 c3);
        public uint4x4(uint m00, uint m01, uint m02, uint m03, uint m10, uint m11, uint m12, uint m13, uint m20, uint m21, uint m22, uint m23, uint m30, uint m31, uint m32, uint m33);
        public uint4x4(uint v);
        public uint4x4(bool v);
        public uint4x4(bool4x4 v);
        public uint4x4(int v);
        public uint4x4(int4x4 v);
        public uint4x4(float v);
        public uint4x4(float4x4 v);
        public uint4x4(double v);
        public uint4x4(double4x4 v);

        public ref uint4 this[int index] { get; }

        public bool Equals(uint4x4 rhs);
        public override bool Equals(object o);
        public override int GetHashCode();
        public override string ToString();
        public string ToString(string format, IFormatProvider formatProvider);

        public static uint4x4 operator *(uint4x4 lhs, uint4x4 rhs);
        public static uint4x4 operator *(uint4x4 lhs, uint rhs);
        public static uint4x4 operator *(uint lhs, uint4x4 rhs);
        public static uint4x4 operator +(uint4x4 lhs, uint4x4 rhs);
        public static uint4x4 operator +(uint4x4 lhs, uint rhs);
        public static uint4x4 operator +(uint lhs, uint4x4 rhs);
        public static uint4x4 operator -(uint4x4 lhs, uint4x4 rhs);
        public static uint4x4 operator -(uint4x4 lhs, uint rhs);
        public static uint4x4 operator -(uint lhs, uint4x4 rhs);
        public static uint4x4 operator /(uint4x4 lhs, uint4x4 rhs);
        public static uint4x4 operator /(uint4x4 lhs, uint rhs);
        public static uint4x4 operator /(uint lhs, uint4x4 rhs);
        public static uint4x4 operator %(uint4x4 lhs, uint4x4 rhs);
        public static uint4x4 operator %(uint4x4 lhs, uint rhs);
        public static uint4x4 operator %(uint lhs, uint4x4 rhs);
        public static uint4x4 operator ++(uint4x4 val);
        public static uint4x4 operator --(uint4x4 val);
        public static bool4x4 operator <(uint4x4 lhs, uint4x4 rhs);
        public static bool4x4 operator <(uint4x4 lhs, uint rhs);
        public static bool4x4 operator <(uint lhs, uint4x4 rhs);
        public static bool4x4 operator <=(uint4x4 lhs, uint4x4 rhs);
        public static bool4x4 operator <=(uint4x4 lhs, uint rhs);
        public static bool4x4 operator <=(uint lhs, uint4x4 rhs);
        public static bool4x4 operator >(uint4x4 lhs, uint4x4 rhs);
        public static bool4x4 operator >(uint4x4 lhs, uint rhs);
        public static bool4x4 operator >(uint lhs, uint4x4 rhs);
        public static bool4x4 operator >=(uint4x4 lhs, uint4x4 rhs);
        public static bool4x4 operator >=(uint4x4 lhs, uint rhs);
        public static bool4x4 operator >=(uint lhs, uint4x4 rhs);
        public static uint4x4 operator -(uint4x4 val);
        public static uint4x4 operator +(uint4x4 val);
        public static uint4x4 operator <<(uint4x4 x, int n);
        public static uint4x4 operator >>(uint4x4 x, int n);
        public static bool4x4 operator ==(uint4x4 lhs, uint4x4 rhs);
        public static bool4x4 operator ==(uint4x4 lhs, uint rhs);
        public static bool4x4 operator ==(uint lhs, uint4x4 rhs);
        public static bool4x4 operator !=(uint4x4 lhs, uint4x4 rhs);
        public static bool4x4 operator !=(uint4x4 lhs, uint rhs);
        public static bool4x4 operator !=(uint lhs, uint4x4 rhs);
        public static uint4x4 operator ~(uint4x4 val);
        public static uint4x4 operator &(uint4x4 lhs, uint4x4 rhs);
        public static uint4x4 operator &(uint4x4 lhs, uint rhs);
        public static uint4x4 operator &(uint lhs, uint4x4 rhs);
        public static uint4x4 operator |(uint4x4 lhs, uint4x4 rhs);
        public static uint4x4 operator |(uint4x4 lhs, uint rhs);
        public static uint4x4 operator |(uint lhs, uint4x4 rhs);
        public static uint4x4 operator ^(uint4x4 lhs, uint4x4 rhs);
        public static uint4x4 operator ^(uint4x4 lhs, uint rhs);
        public static uint4x4 operator ^(uint lhs, uint4x4 rhs);

        public static implicit operator uint4x4(uint v);
        public static explicit operator uint4x4(bool v);
        public static explicit operator uint4x4(bool4x4 v);
        public static explicit operator uint4x4(int v);
        public static explicit operator uint4x4(int4x4 v);
        public static explicit operator uint4x4(float v);
        public static explicit operator uint4x4(float4x4 v);
        public static explicit operator uint4x4(double v);
        public static explicit operator uint4x4(double4x4 v);
    }
}
-------- {Unity.ShaderGraph.Editor(D:\Documents\GitHub\Rogue-like-game-i-guess\The game is liar\Library\ScriptAssemblies\Unity.ShaderGraph.Editor.dll)}: 1154 --------
using System;
using UnityEngine.UIElements;

public class TabButton : VisualElement
{
    public TabButton();
    public TabButton(string text, VisualElement target);

    public bool IsCloseable { get; set; }
    public string TargetId { get; }
    public VisualElement Target { get; set; }

    public event Action<TabButton> OnSelect;
    public event Action<TabButton> OnClose;

    public void Select();
    public void Deselect();
}
using UnityEngine.UIElements;

public class TabbedView : VisualElement
{
    public TabbedView();

    public override VisualElement contentContainer { get; }

    public void AddTab(TabButton tabButton, bool activate);
    public void RemoveTab(TabButton tabButton);
    public void Activate(TabButton button);

    public class UxmlFactory : UxmlFactory<TabbedView, VisualElement.UxmlTraits>
    {
        public UxmlFactory();
    }
}
using UnityEditor.ShaderGraph.Serialization;
using UnityEngine;

namespace UnityEditor.ShaderGraph
{
    public class GroupData : JsonObject
    {
        public GroupData();
        public GroupData(string title, Vector2 position);

        public string title { get; set; }
        public Vector2 position { get; set; }
    }
}
using UnityEditor.Experimental.GraphView;

namespace UnityEditor.ShaderGraph
{
    public class RedirectNode : Node
    {
        public RedirectNode();
    }
}
namespace UnityEditor.ShaderGraph
{
    public static class TextUtil
    {
        public static string PascalToLabel(this string pascalString);
    }
}
using UnityEditor.Searcher;

namespace UnityEditor.ShaderGraph
{
    public class SearchWindowAdapter : SearcherAdapter
    {
        public SearchWindowAdapter(string title);

        public override bool HasDetailsPanel { get; }
    }
}
using UnityEditor.ShaderGraph.Internal;

namespace UnityEditor.ShaderGraph
{
    public interface IControl
    {
        ShaderGraphRequirements GetRequirements();
    }
}
using UnityEditor.ShaderGraph.Internal;

namespace UnityEditor.ShaderGraph
{
    public class PositionControl : IControl
    {
        public PositionControl(CoordinateSpace space);

        public CoordinateSpace space { get; }

        public ShaderGraphRequirements GetRequirements();
    }
}
using UnityEditor.ShaderGraph.Internal;

namespace UnityEditor.ShaderGraph
{
    public class NormalControl : IControl
    {
        public NormalControl(CoordinateSpace space);

        public CoordinateSpace space { get; }

        public ShaderGraphRequirements GetRequirements();
    }
}
using UnityEditor.ShaderGraph.Internal;

namespace UnityEditor.ShaderGraph
{
    public class TangentControl : IControl
    {
        public TangentControl(CoordinateSpace space);

        public CoordinateSpace space { get; }

        public ShaderGraphRequirements GetRequirements();
    }
}
using UnityEditor.ShaderGraph.Internal;
using UnityEngine;

namespace UnityEditor.ShaderGraph
{
    public class ColorControl : IControl
    {
        public ColorControl(Color value, bool hdr);

        public Color value { get; }
        public bool hdr { get; }

        public ShaderGraphRequirements GetRequirements();
    }
}
using UnityEditor.ShaderGraph.Internal;
using UnityEngine;

namespace UnityEditor.ShaderGraph
{
    public class ColorRGBAControl : IControl
    {
        public ColorRGBAControl(Color value);

        public Color value { get; }

        public ShaderGraphRequirements GetRequirements();
    }
}
using UnityEditor.ShaderGraph.Internal;

namespace UnityEditor.ShaderGraph
{
    public class FloatControl : IControl
    {
        public FloatControl(float value);

        public float value { get; }

        public ShaderGraphRequirements GetRequirements();
    }
}
using UnityEditor.ShaderGraph.Internal;
using UnityEngine;

namespace UnityEditor.ShaderGraph
{
    public class Vector2Control : IControl
    {
        public Vector2Control(Vector2 value);

        public Vector2 value { get; }

        public ShaderGraphRequirements GetRequirements();
    }
}
using UnityEditor.ShaderGraph.Internal;
using UnityEngine;

namespace UnityEditor.ShaderGraph
{
    public class Vector3Control : IControl
    {
        public Vector3Control(Vector3 value);

        public Vector3 value { get; }

        public ShaderGraphRequirements GetRequirements();
    }
}
namespace UnityEditor.ShaderGraph.Serialization
{
    public class FakeJsonObject
    {
        public FakeJsonObject();

        public string id { get; set; }
        public string type { get; set; }

        public void Reset();
    }
}
using System;
using UnityEngine;

namespace UnityEditor.ShaderGraph.Serialization
{
    public class JsonObject : ISerializationCallbackReceiver
    {
        [SerializeField]
        protected int m_SGVersion;
        protected internal VersionChange onBeforeVersionChange;
        protected internal Action onAfterVersionChange;
        public static readonly string emptyObjectId;

        public JsonObject();

        public virtual int latestVersion { get; }
        public virtual int sgVersion { get; protected set; }
        public string objectId { get; }
        public bool objectIdIsEmpty { get; }

        public virtual T CastTo<T>() where T : JsonObject;
        public virtual string Serialize();
        public virtual void Deserailize(string typeInfo, string jsonData);
        public virtual void OnBeforeSerialize();
        public virtual void OnAfterDeserialize();
        public virtual void OnAfterDeserialize(string json);
        public virtual void OnAfterMultiDeserialize(string json);

        protected internal delegate void VersionChange(int newVersion);
    }
}
namespace UnityEditor.ShaderGraph.Legacy
{
    public interface IMasterNode1
    {
    }
}
namespace UnityEditor.ShaderGraph.Internal
{
    public enum ConcretePrecision
    {
        Single = 0,
        Half = 1
    }
}
using System;

namespace UnityEditor.ShaderGraph.Internal
{
    public abstract class AbstractShaderProperty : ShaderInput
    {
        protected AbstractShaderProperty();

        public abstract PropertyType propertyType { get; }
        [Obsolete("AbstractShaderProperty.gpuInstanced is no longer used")]
        public bool gpuInstanced { get; set; }
        public ConcretePrecision concretePrecision { get; }
        public bool hidden { get; set; }

        public virtual string GetPropertyTypeString();
    }
}
namespace UnityEditor.ShaderGraph.Internal
{
    public abstract class AbstractShaderProperty<T> : AbstractShaderProperty
    {
        protected AbstractShaderProperty();

        public virtual T value { get; set; }
    }
}
namespace UnityEditor.ShaderGraph.Internal
{
    public enum HLSLType
    {
        _float = 0,
        _float2 = 1,
        _float3 = 2,
        _float4 = 3,
        _matrix4x4 = 4,
        FirstObjectType = 5,
        _Texture2D = 5,
        _Texture3D = 6,
        _TextureCube = 7,
        _Texture2DArray = 8,
        _SamplerState = 9,
        _CUSTOM = 10
    }
}
namespace UnityEditor.ShaderGraph.Internal
{
    [FormerName("UnityEditor.ShaderGraph.BooleanShaderProperty")]
    [BlackboardInputInfo(20, null)]
    public sealed class BooleanShaderProperty : AbstractShaderProperty<bool>
    {
        public override PropertyType propertyType { get; }
    }
}
using UnityEngine;

namespace UnityEditor.ShaderGraph.Internal
{
    [FormerName("UnityEditor.ShaderGraph.ColorShaderProperty")]
    [BlackboardInputInfo(10, null)]
    public sealed class ColorShaderProperty : AbstractShaderProperty<Color>
    {
        public const int deprecatedVersion = 2;

        public override int latestVersion { get; }
        public override PropertyType propertyType { get; }
        public ColorMode colorMode { get; set; }

        public override string GetDefaultReferenceName();
        public override void OnAfterDeserialize(string json);
    }
}
namespace UnityEditor.ShaderGraph.Internal
{
    [FormerName("UnityEditor.ShaderGraph.CubemapShaderProperty")]
    [BlackboardInputInfo(53, null)]
    public sealed class CubemapShaderProperty : AbstractShaderProperty<SerializableCubemap>
    {
        public override PropertyType propertyType { get; }
    }
}
using UnityEngine;

namespace UnityEditor.ShaderGraph.Internal
{
    public sealed class SerializableCubemap : ISerializationCallbackReceiver
    {
        public SerializableCubemap();

        public Cubemap cubemap { get; set; }

        public void OnBeforeSerialize();
        public void OnAfterDeserialize();
    }
}
using UnityEngine;

namespace UnityEditor.ShaderGraph.Internal
{
    public sealed class SerializableTexture : ISerializationCallbackReceiver
    {
        public SerializableTexture();

        public Texture texture { get; set; }

        public void OnBeforeSerialize();
        public void OnAfterDeserialize();
    }
}
using UnityEngine;

namespace UnityEditor.ShaderGraph.Internal
{
    public sealed class SerializableTextureArray : ISerializationCallbackReceiver
    {
        public SerializableTextureArray();

        public Texture2DArray textureArray { get; set; }

        public void OnBeforeSerialize();
        public void OnAfterDeserialize();
    }
}
using System.Collections.Generic;

namespace UnityEditor.ShaderGraph.Internal
{
    public struct ShaderGraphRequirements
    {
        public NeededCoordinateSpace requiresNormal { get; }
        public NeededCoordinateSpace requiresBitangent { get; }
        public NeededCoordinateSpace requiresTangent { get; }
        public NeededCoordinateSpace requiresViewDir { get; }
        public NeededCoordinateSpace requiresPosition { get; }
        public bool requiresScreenPosition { get; }
        public bool requiresVertexColor { get; }
        public bool requiresFaceSign { get; }
        public List<UVChannel> requiresMeshUVs { get; }
        public bool requiresDepthTexture { get; }
        public bool requiresCameraOpaqueTexture { get; }
        public bool requiresTime { get; }
        public bool requiresVertexSkinning { get; }
        public bool requiresVertexID { get; }
    }
}
using UnityEditor.ShaderGraph.Serialization;

namespace UnityEditor.ShaderGraph.Internal
{
    public abstract class ShaderInput : JsonObject
    {
        protected ShaderInput();

        public string displayName { get; set; }
        public string referenceName { get; }
        public virtual string referenceNameForEditing { get; }

        public virtual string GetDefaultReferenceName();
    }
}
namespace UnityEditor.ShaderGraph.Internal
{
    [FormerName("UnityEditor.ShaderGraph.Texture2DArrayShaderProperty")]
    [BlackboardInputInfo(51, null)]
    public class Texture2DArrayShaderProperty : AbstractShaderProperty<SerializableTextureArray>
    {
        public override PropertyType propertyType { get; }
    }
}
namespace UnityEditor.ShaderGraph.Internal
{
    [FormerName("UnityEditor.ShaderGraph.TextureShaderProperty")]
    [BlackboardInputInfo(50, null)]
    public sealed class Texture2DShaderProperty : AbstractShaderProperty<SerializableTexture>
    {
        public override PropertyType propertyType { get; }
        public DefaultType defaultType { get; set; }

        public enum DefaultType
        {
            White = 0,
            Black = 1,
            Grey = 2,
            Bump = 3
        }
    }
}
namespace UnityEditor.ShaderGraph.Internal
{
    [FormerName("UnityEditor.ShaderGraph.Texture3DShaderProperty")]
    [BlackboardInputInfo(52, null)]
    public sealed class Texture3DShaderProperty : AbstractShaderProperty<SerializableTexture>
    {
        public override PropertyType propertyType { get; }
        public bool modifiable { get; set; }
    }
}
using System;
using System.Collections.Generic;
using UnityEngine;

namespace UnityEditor.ShaderGraph.Internal
{
    [FormerName("UnityEditor.ShaderGraph.FloatShaderProperty")]
    [FormerName("UnityEditor.ShaderGraph.Vector1ShaderProperty")]
    [BlackboardInputInfo(0, "Float")]
    public sealed class Vector1ShaderProperty : AbstractShaderProperty<float>
    {
        public override PropertyType propertyType { get; }
        public override float value { get; set; }
        public FloatType floatType { get; set; }
        public Vector2 rangeValues { get; set; }
        public EnumType enumType { get; set; }
        public Type cSharpEnumType { get; set; }
        public List<string> enumNames { get; set; }
        public List<int> enumValues { get; set; }
        public override int latestVersion { get; }

        public override void OnAfterDeserialize(string json);
    }
}
namespace UnityEditor.ShaderGraph.Internal
{
    public enum FloatType
    {
        Default = 0,
        Slider = 1,
        Integer = 2,
        Enum = 3
    }
}
namespace UnityEditor.ShaderGraph.Internal
{
    public enum EnumType
    {
        Enum = 0,
        CSharpEnum = 1,
        KeywordEnum = 2
    }
}
namespace UnityEditor.ShaderGraph.Internal
{
    [FormerName("UnityEditor.ShaderGraph.Vector2ShaderProperty")]
    [BlackboardInputInfo(1, null)]
    public sealed class Vector2ShaderProperty : VectorShaderProperty
    {
        public override PropertyType propertyType { get; }
        public override int latestVersion { get; }

        public override void OnAfterDeserialize(string json);
    }
}
namespace UnityEditor.ShaderGraph.Internal
{
    [FormerName("UnityEditor.ShaderGraph.Vector3ShaderProperty")]
    [BlackboardInputInfo(3, null)]
    public sealed class Vector3ShaderProperty : VectorShaderProperty
    {
        public override PropertyType propertyType { get; }
        public override int latestVersion { get; }

        public override void OnAfterDeserialize(string json);
    }
}
namespace UnityEditor.ShaderGraph.Internal
{
    [FormerName("UnityEditor.ShaderGraph.Vector4ShaderProperty")]
    [BlackboardInputInfo(4, null)]
    public sealed class Vector4ShaderProperty : VectorShaderProperty
    {
        public override PropertyType propertyType { get; }
        public override int latestVersion { get; }

        public override void OnAfterDeserialize(string json);
    }
}
using UnityEngine;

namespace UnityEditor.ShaderGraph.Internal
{
    public abstract class VectorShaderProperty : AbstractShaderProperty<Vector4>
    {
        protected VectorShaderProperty();
    }
}
using System;

namespace UnityEditor.ShaderGraph.Internal
{
    [Flags]
    public enum NeededCoordinateSpace
    {
        None = 0,
        Object = 1,
        View = 2,
        World = 4,
        Tangent = 8,
        AbsoluteWorld = 16
    }
}
namespace UnityEditor.ShaderGraph.Internal
{
    public enum CoordinateSpace
    {
        Object = 0,
        View = 1,
        World = 2,
        Tangent = 3,
        AbsoluteWorld = 4
    }
}
namespace UnityEditor.ShaderGraph.Internal
{
    public enum InterpolatorType
    {
        Normal = 0,
        BiTangent = 1,
        Tangent = 2,
        ViewDirection = 3,
        Position = 4
    }
}
namespace UnityEditor.ShaderGraph.Internal
{
    public static class CoordinateSpaceExtensions
    {
        public static string ToVariableName(this CoordinateSpace space, InterpolatorType type);
        public static NeededCoordinateSpace ToNeededCoordinateSpace(this CoordinateSpace space);
        public static CoordinateSpace ToCoordinateSpace(this NeededCoordinateSpace space);
    }
}
namespace UnityEditor.ShaderGraph.Internal
{
    public enum ColorMode
    {
        Default = 0,
        HDR = 1
    }
}
using System.Collections.Generic;

namespace UnityEditor.ShaderGraph.Internal
{
    public static class KeywordDependentCollection
    {
        public enum KeywordPermutationInstanceType
        {
            Base = 0,
            Permutation = 1
        }
        public interface ISet<IInstance>
        {
            int instanceCount { get; }
            IEnumerable<IInstance> instances { get; }
        }
        public interface IInstance
        {
            KeywordPermutationInstanceType type { get; }
            int permutationIndex { get; }
        }
    }
}
using System.Collections.Generic;
using System.Reflection;

namespace UnityEditor.ShaderGraph.Internal
{
    [DefaultMember("Item")]
    public abstract class KeywordDependentCollection<TStorage, TAll, TAllPermutations, TForPermutation, TBase, TIInstance, TISet> where TStorage : new() where TAll : TISet where TAllPermutations : TISet where TForPermutation : TISet, TIInstance where TBase : TISet, TIInstance where TIInstance : KeywordDependentCollection.IInstance where TISet : KeywordDependentCollection.ISet<TIInstance>
    {
        protected KeywordDependentCollection();

        public TForPermutation this[int index] { get; }
        public int permutationCount { get; }
        public TAll all { get; }
        public TAllPermutations allPermutations { get; }
        public TBase baseInstance { get; }
        protected TStorage baseStorage { get; set; }
        protected IEnumerable<TStorage> permutationStorages { get; }

        protected TStorage GetOrCreateForPermutationIndex(int index);
        protected void SetForPermutationIndex(int index, TStorage value);
        protected abstract TAll CreateAllSmartPointer();
        protected abstract TAllPermutations CreateAllPermutationsSmartPointer();
        protected abstract TForPermutation CreateForPermutationSmartPointer(int index);
        protected abstract TBase CreateBaseSmartPointer();
    }
}
namespace UnityEditor.ShaderGraph.Internal
{
    public enum UVChannel
    {
        UV0 = 0,
        UV1 = 1,
        UV2 = 2,
        UV3 = 3
    }
}
namespace UnityEditor.ShaderGraph.Internal
{
    [GenerationAPI]
    public enum PropertyType
    {
        Color = 0,
        Texture2D = 1,
        Texture2DArray = 2,
        Texture3D = 3,
        Cubemap = 4,
        Gradient = 5,
        Boolean = 6,
        Float = 7,
        Vector2 = 8,
        Vector3 = 9,
        Vector4 = 10,
        Matrix2 = 11,
        Matrix3 = 12,
        Matrix4 = 13,
        SamplerState = 14,
        VirtualTexture = 15
    }
}
using System.Collections.Generic;

namespace UnityEditor.ShaderGraph.Internal
{
    public struct GraphCode
    {
        public IEnumerable<AbstractShaderProperty> properties;

        public string code { get; }
        public ShaderGraphRequirements requirements { get; }
    }
}
namespace UnityEditor.ShaderGraph.Internal
{
    public struct OutputMetadata
    {
        public int index { get; }
        public int id { get; }
        public string referenceName { get; }
    }
}
using UnityEngine;
using UnityEngine.Rendering;

namespace UnityEditor.ShaderGraph.Internal
{
    public struct TextureInfo
    {
        public string name;
        public Texture texture;
        public TextureDimension dimension;

        public TextureInfo(string name, Texture texture, TextureDimension dimension);

        public int instanceID { get; }
    }
}
using System.Collections.Generic;
using UnityEngine;

namespace UnityEditor.ShaderGraph.Internal
{
    public sealed class ShaderGraphVfxAsset : ScriptableObject, ISerializationCallbackReceiver
    {
        public const int BaseColorSlotId = 1;
        public const int MetallicSlotId = 2;
        public const int SmoothnessSlotId = 3;
        public const int NormalSlotId = 8;
        public const int AlphaSlotId = 4;
        public const int EmissiveSlotId = 5;
        public const int ColorSlotId = 6;
        public const int AlphaThresholdSlotId = 7;
        [SerializeField]
        public bool lit;
        [SerializeField]
        public bool alphaClipping;

        public ShaderGraphVfxAsset();

        public IEnumerable<TextureInfo> textureInfos { get; }
        public string evaluationFunctionName { get; }
        public string inputStructName { get; }
        public string outputStructName { get; }
        public List<AbstractShaderProperty> properties { get; }

        public OutputMetadata GetOutput(int id);
        public bool HasOutput(int id);
        public GraphCode GetCode(OutputMetadata[] outputs);
    }
}
using System;

namespace UnityEditor.ShaderGraph.Drawing
{
    [AttributeUsage(Property)]
    public class InspectableAttribute : Attribute
    {
        public InspectableAttribute(string labelName, object defaultValue, string customStyleName = "");

        public string labelName { get; }
        public object defaultValue { get; }
        public string customStyleName { get; }
    }
}
using System;

namespace UnityEditor.ShaderGraph.Drawing
{
    [AttributeUsage(Class)]
    public class SGPropertyDrawerAttribute : Attribute
    {
        public SGPropertyDrawerAttribute(Type propertyType);

        public Type propertyType { get; }
    }
}
using System;
using System.Reflection;
using UnityEngine.UIElements;

namespace UnityEditor.ShaderGraph.Drawing
{
    public interface IPropertyDrawer
    {
        Action inspectorUpdateDelegate { get; set; }

        VisualElement DrawProperty(PropertyInfo propertyInfo, object actualObject, InspectableAttribute attribute);
    }
}
namespace UnityEditor.ShaderGraph.Drawing
{
    public enum HlslSourceType
    {
        File = 0,
        String = 1
    }
}
using UnityEditor.UIElements;
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.ShaderGraph.Drawing
{
    public class IdentifierField : TextValueField<string>
    {
        public static readonly string ussClassName;
        public static readonly string labelUssClassName;
        public static readonly string inputUssClassName;

        public IdentifierField();
        public IdentifierField(string label);

        protected override string ValueToString(string v);
        protected override string StringToValue(string str);
        public override void ApplyInputDeviceDelta(Vector3 delta, DeltaSpeed speed, string startValue);

        public class UxmlFactory : UxmlFactory<IdentifierField, UxmlTraits>
        {
            public UxmlFactory();
        }
        public class UxmlTraits : TextValueFieldTraits<string, UxmlStringAttributeDescription>
        {
            public UxmlTraits();
        }
    }
}
namespace UnityEditor.ShaderGraph.Drawing.Inspector
{
    public static class InspectorUtils
    {
    }
}
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.ShaderGraph.Drawing.Inspector
{
    public static class PropertyDrawerUtils
    {
        public static Label CreateLabel(string text, int indentLevel = 0, FontStyle fontStyle = Normal);
    }
}
using System;
using System.Reflection;
using UnityEngine.UIElements;

namespace UnityEditor.ShaderGraph.Drawing.Inspector.PropertyDrawers
{
    [SGPropertyDrawer(typeof(AbstractMaterialNode))]
    public class AbstractMaterialNodePropertyDrawer : IPropertyDrawer, IGetNodePropertyDrawerPropertyData
    {
        public AbstractMaterialNodePropertyDrawer();

        public Action inspectorUpdateDelegate { get; set; }

        public void GetPropertyData(Action setNodesAsDirtyCallback, Action updateNodeViewsCallback);
        public VisualElement DrawProperty(PropertyInfo propertyInfo, object actualObject, InspectableAttribute attribute);
    }
}
using System;
using System.Reflection;
using UnityEngine.UIElements;

namespace UnityEditor.ShaderGraph.Drawing.Inspector.PropertyDrawers
{
    [SGPropertyDrawer(typeof(CustomFunctionNode))]
    public class CustomFunctionNodePropertyDrawer : IPropertyDrawer, IGetNodePropertyDrawerPropertyData
    {
        public CustomFunctionNodePropertyDrawer();

        public Action inspectorUpdateDelegate { get; set; }

        public VisualElement DrawProperty(PropertyInfo propertyInfo, object actualObject, InspectableAttribute attribute);
    }
}
using System;
using System.Reflection;
using UnityEditor.ShaderGraph.Internal;
using UnityEngine.UIElements;

namespace UnityEditor.ShaderGraph.Drawing.Inspector.PropertyDrawers
{
    [SGPropertyDrawer(typeof(GraphData))]
    public class GraphDataPropertyDrawer : IPropertyDrawer
    {
        public GraphDataPropertyDrawer();

        public Action inspectorUpdateDelegate { get; set; }

        public void GetPropertyData(PostTargetSettingsChangedCallback postChangeValueCallback, ChangeConcretePrecisionCallback changeConcretePrecisionCallback);
        public VisualElement DrawProperty(PropertyInfo propertyInfo, object actualObject, InspectableAttribute attribute);

        public delegate void ChangeConcretePrecisionCallback(ConcretePrecision newValue);
        public delegate void PostTargetSettingsChangedCallback();
    }
}
using System;
using System.Reflection;
using UnityEngine.UIElements;

namespace UnityEditor.ShaderGraph.Drawing.Inspector.PropertyDrawers
{
    [SGPropertyDrawer(typeof(SampleVirtualTextureNode))]
    public class SampleVirtualTextureNodePropertyDrawer : IPropertyDrawer
    {
        public SampleVirtualTextureNodePropertyDrawer();

        public Action inspectorUpdateDelegate { get; set; }

        public VisualElement DrawProperty(PropertyInfo propertyInfo, object actualObject, InspectableAttribute attribute);
    }
}
using System;
using System.Reflection;
using UnityEngine.UIElements;

namespace UnityEditor.ShaderGraph.Drawing.Inspector.PropertyDrawers
{
    [SGPropertyDrawer(typeof(SubGraphOutputNode))]
    public class SubGraphOutputNodePropertyDrawer : IPropertyDrawer
    {
        public SubGraphOutputNodePropertyDrawer();

        public Action inspectorUpdateDelegate { get; set; }

        public VisualElement DrawProperty(PropertyInfo propertyInfo, object actualObject, InspectableAttribute attribute);
    }
}
using UnityEngine;

namespace UnityEditor.ShaderGraph.Drawing.Colors
{
    public class CustomColorData : ISerializationCallbackReceiver
    {
        public CustomColorData();

        public bool TryGetColor(string provider, out Color color);
        public void Set(string provider, Color color);
        public void Remove(string provider);
        public void OnBeforeSerialize();
        public void OnAfterDeserialize();
    }
}
using System.Collections.Generic;
using UnityEditor.Experimental.GraphView;
using UnityEngine.UIElements;

namespace UnityEditor.ShaderGraph.Drawing.Views.Blackboard
{
    public class SGBlackboardSection : GraphElement
    {
        public SGBlackboardSection();

        public CanAcceptDropDelegate canAcceptDrop { get; set; }
        public override VisualElement contentContainer { get; }
        public override string title { get; set; }
        public bool headerVisible { get; set; }

        public bool CanAcceptDrop(List<ISelectable> selection);
        public void OnDragActionCanceled();

        public delegate bool CanAcceptDropDelegate(ISelectable selected);
    }
}
-------- {Unity.RenderPipelines.Universal.Editor(D:\Documents\GitHub\Rogue-like-game-i-guess\The game is liar\Library\ScriptAssemblies\Unity.RenderPipelines.Universal.Editor.dll)}:  314 --------
using UnityEngine.Rendering.Universal;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor
{
    [LightingExplorerExtension(typeof(UniversalRenderPipelineAsset))]
    [MovedFrom("UnityEditor.Rendering.LWRP")]
    public class LightExplorer : DefaultLightingExplorerExtension
    {
        public LightExplorer();

        protected override LightingExplorerTableColumn[] GetReflectionProbeColumns();
    }
}
using System;
using UnityEngine;

namespace UnityEditor
{
    public abstract class BaseShaderGUI : ShaderGUI
    {
        public bool m_FirstTimeApply;

        protected BaseShaderGUI();

        protected MaterialEditor materialEditor { get; set; }
        protected MaterialProperty surfaceTypeProp { get; set; }
        protected MaterialProperty blendModeProp { get; set; }
        protected MaterialProperty cullingProp { get; set; }
        protected MaterialProperty alphaClipProp { get; set; }
        protected MaterialProperty alphaCutoffProp { get; set; }
        protected MaterialProperty receiveShadowsProp { get; set; }
        protected MaterialProperty baseMapProp { get; set; }
        protected MaterialProperty baseColorProp { get; set; }
        protected MaterialProperty emissionMapProp { get; set; }
        protected MaterialProperty emissionColorProp { get; set; }
        protected MaterialProperty queueOffsetProp { get; set; }
        protected string headerStateKey { get; }

        public abstract void MaterialChanged(Material material);
        public virtual void FindProperties(MaterialProperty[] properties);
        public override void OnGUI(MaterialEditor materialEditorIn, MaterialProperty[] properties);
        public virtual void OnOpenGUI(Material material, MaterialEditor materialEditor);
        public void ShaderPropertiesGUI(Material material);
        public virtual void DrawSurfaceOptions(Material material);
        public virtual void DrawSurfaceInputs(Material material);
        public virtual void DrawAdvancedOptions(Material material);
        protected void DrawQueueOffsetField();
        public virtual void DrawAdditionalFoldouts(Material material);
        public virtual void DrawBaseProperties(Material material);
        protected virtual void DrawEmissionProperties(Material material, bool keyword);
        public static void DrawNormalArea(MaterialEditor materialEditor, MaterialProperty bumpMap, MaterialProperty bumpMapScale = null);
        protected static void DrawTileOffset(MaterialEditor materialEditor, MaterialProperty textureProp);
        public static void SetMaterialKeywords(Material material, Action<Material> shadingModelFunc = null, Action<Material> shaderFunc = null);
        public static void SetupMaterialBlendMode(Material material);
        public static void TwoFloatSingleLine(GUIContent title, MaterialProperty prop1, GUIContent prop1Label, MaterialProperty prop2, GUIContent prop2Label, MaterialEditor materialEditor, float labelWidth = 30);
        public void DoPopup(GUIContent label, MaterialProperty property, string[] options);
        public static void DoPopup(GUIContent label, MaterialProperty property, string[] options, MaterialEditor materialEditor);
        public static Rect TextureColorProps(MaterialEditor materialEditor, GUIContent label, MaterialProperty textureProp, MaterialProperty colorProp, bool hdr = False);
        public static MaterialProperty FindProperty(string propertyName, MaterialProperty[] properties);
        public static MaterialProperty FindProperty(string propertyName, MaterialProperty[] properties, bool propertyIsMandatory);

        public enum SurfaceType
        {
            Opaque = 0,
            Transparent = 1
        }
        public enum BlendMode
        {
            Alpha = 0,
            Premultiply = 1,
            Additive = 2,
            Multiply = 3
        }
        public enum SmoothnessSource
        {
            BaseAlpha = 0,
            SpecularAlpha = 1
        }
        public enum RenderFace
        {
            Front = 2,
            Back = 1,
            Both = 0
        }
        protected class Styles
        {
            public static readonly GUIContent SurfaceOptions;
            public static readonly GUIContent SurfaceInputs;
            public static readonly GUIContent AdvancedLabel;
            public static readonly GUIContent surfaceType;
            public static readonly GUIContent blendingMode;
            public static readonly GUIContent cullingText;
            public static readonly GUIContent alphaClipText;
            public static readonly GUIContent alphaClipThresholdText;
            public static readonly GUIContent receiveShadowText;
            public static readonly GUIContent baseMap;
            public static readonly GUIContent emissionMap;
            public static readonly GUIContent normalMapText;
            public static readonly GUIContent bumpScaleNotSupported;
            public static readonly GUIContent fixNormalNow;
            public static readonly GUIContent queueSlider;

            public Styles();
        }
    }
}
using UnityEngine.Rendering.Universal;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.Rendering.Universal
{
    [CustomEditor(typeof(ForwardRendererData), True)]
    [MovedFrom("UnityEditor.Rendering.LWRP")]
    public class ForwardRendererDataEditor : ScriptableRendererDataEditor
    {
        public ForwardRendererDataEditor();

        public override void OnInspectorGUI();
    }
}
using UnityEngine.Rendering.Universal;

namespace UnityEditor.Rendering.Universal
{
    [CustomEditor(typeof(PostProcessData), True)]
    public class PostProcessDataEditor : Editor
    {
        public PostProcessDataEditor();

        public override void OnInspectorGUI();
    }
}
using UnityEngine.Rendering.Universal;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.Rendering.Universal
{
    [CustomEditor(typeof(ScriptableRendererData), True)]
    [MovedFrom("UnityEditor.Rendering.LWRP")]
    public class ScriptableRendererDataEditor : Editor
    {
        public ScriptableRendererDataEditor();

        public override void OnInspectorGUI();
    }
}
using UnityEngine.Rendering.Universal;

namespace UnityEditor.Rendering.Universal
{
    [CustomEditor(typeof(ScriptableRendererFeature), True)]
    public class ScriptableRendererFeatureEditor : Editor
    {
        public ScriptableRendererFeatureEditor();

        public override void OnInspectorGUI();
    }
}
using UnityEngine.Rendering.Universal;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.Rendering.Universal
{
    [CanEditMultipleObjects]
    [CustomEditor(typeof(UniversalAdditionalLightData))]
    [MovedFrom("UnityEditor.Rendering.LWRP")]
    public class UniversalAdditionLightDataEditor : Editor
    {
        public UniversalAdditionLightDataEditor();

        public override void OnInspectorGUI();
    }
}
using UnityEngine.Rendering.Universal;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.Rendering.Universal
{
    [CustomEditor(typeof(UniversalRenderPipelineAsset))]
    [MovedFrom("UnityEditor.Rendering.LWRP")]
    public class UniversalRenderPipelineAssetEditor : Editor
    {
        public UniversalRenderPipelineAssetEditor();

        public override void OnInspectorGUI();
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.Rendering.Universal
{
    [MovedFrom("UnityEditor.Rendering.LWRP")]
    public static class SupportedUpgradeParams
    {
        public static UpgradeParams diffuseOpaque;
        public static UpgradeParams specularOpaque;
        public static UpgradeParams diffuseAlpha;
        public static UpgradeParams specularAlpha;
        public static UpgradeParams diffuseAlphaCutout;
        public static UpgradeParams specularAlphaCutout;
        public static UpgradeParams diffuseCubemap;
        public static UpgradeParams specularCubemap;
        public static UpgradeParams diffuseCubemapAlpha;
        public static UpgradeParams specularCubemapAlpha;
    }
}
using UnityEngine;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.Rendering.Universal
{
    [MovedFrom("UnityEditor.Rendering.LWRP")]
    public class StandardUpgrader : MaterialUpgrader
    {
        public StandardUpgrader(string oldShaderName);

        public static void UpdateStandardMaterialKeywords(Material material);
        public static void UpdateStandardSpecularMaterialKeywords(Material material);
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.Rendering.Universal
{
    [MovedFrom("UnityEditor.Rendering.LWRP")]
    public class TerrainUpgrader : MaterialUpgrader
    {
        public TerrainUpgrader(string oldShaderName);
    }
}
using UnityEngine;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.Rendering.Universal
{
    [MovedFrom("UnityEditor.Rendering.LWRP")]
    public class ParticleUpgrader : MaterialUpgrader
    {
        public ParticleUpgrader(string oldShaderName);

        public static void UpdateStandardSurface(Material material);
        public static void UpdateUnlit(Material material);
        public static void UpdateSurfaceBlendModes(Material material);
    }
}
using UnityEngine;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.Rendering.Universal
{
    [MovedFrom("UnityEditor.Rendering.LWRP")]
    public class AutodeskInteractiveUpgrader : MaterialUpgrader
    {
        public AutodeskInteractiveUpgrader(string oldShaderName);

        public override void Convert(Material srcMaterial, Material dstMaterial);
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.Rendering.Universal
{
    [MovedFrom("UnityEditor.Rendering.LWRP")]
    public enum UpgradeSurfaceType
    {
        Opaque = 0,
        Transparent = 1
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.Rendering.Universal
{
    [MovedFrom("UnityEditor.Rendering.LWRP")]
    public enum UpgradeBlendMode
    {
        Alpha = 0,
        Premultiply = 1,
        Additive = 2,
        Multiply = 3
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.Rendering.Universal
{
    [MovedFrom("UnityEditor.Rendering.LWRP")]
    public enum SpecularSource
    {
        SpecularTextureAndColor = 0,
        NoSpecular = 1
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.Rendering.Universal
{
    [MovedFrom("UnityEditor.Rendering.LWRP")]
    public enum SmoothnessSource
    {
        BaseAlpha = 0,
        SpecularAlpha = 1
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.Rendering.Universal
{
    [MovedFrom("UnityEditor.Rendering.LWRP")]
    public enum ReflectionSource
    {
        NoReflection = 0,
        Cubemap = 1,
        ReflectionProbe = 2
    }
}
namespace UnityEditor.Rendering.Universal
{
    public struct UpgradeParams
    {
        public UpgradeSurfaceType surfaceType { get; set; }
        public UpgradeBlendMode blendMode { get; set; }
        public bool alphaClip { get; set; }
        public SpecularSource specularSource { get; set; }
        public SmoothnessSource smoothnessSource { get; set; }
    }
}
namespace UnityEditor.Rendering.Universal.ShaderGraph
{
    public enum MaterialType
    {
        Lit = 0,
        Unlit = 1,
        SpriteLit = 2,
        SpriteUnlit = 3
    }
}
namespace UnityEditor.Rendering.Universal.ShaderGraph
{
    public enum WorkflowMode
    {
        Specular = 0,
        Metallic = 1
    }
}
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.Rendering.Universal.ShaderGUI
{
    [MovedFrom("UnityEditor.Rendering.LWRP.ShaderGUI")]
    public static class ParticleGUI
    {
        public static void SetupMaterialWithColorMode(Material material);
        public static void FadingOptions(Material material, MaterialEditor materialEditor, ParticleProperties properties);
        public static void DoVertexStreamsArea(Material material, List<ParticleSystemRenderer> renderers, bool useLighting = False);
        public static void SetMaterialKeywords(Material material);

        public enum ColorMode
        {
            Multiply = 0,
            Additive = 1,
            Subtractive = 2,
            Overlay = 3,
            Color = 4,
            Difference = 5
        }
        public static class Styles
        {
            public static GUIContent colorMode;
            public static GUIContent flipbookMode;
            public static GUIContent softParticlesEnabled;
            public static GUIContent softParticlesNearFadeDistanceText;
            public static GUIContent softParticlesFarFadeDistanceText;
            public static GUIContent cameraFadingEnabled;
            public static GUIContent cameraNearFadeDistanceText;
            public static GUIContent cameraFarFadeDistanceText;
            public static GUIContent distortionEnabled;
            public static GUIContent distortionStrength;
            public static GUIContent distortionBlend;
            public static GUIContent VertexStreams;
            public static string streamPositionText;
            public static string streamNormalText;
            public static string streamColorText;
            public static string streamColorInstancedText;
            public static string streamUVText;
            public static string streamUV2Text;
            public static string streamAnimBlendText;
            public static string streamAnimFrameText;
            public static string streamTangentText;
            public static GUIContent streamApplyToAllSystemsText;
            public static string undoApplyCustomVertexStreams;
            public static GUIStyle vertexStreamIcon;
        }
        public struct ParticleProperties
        {
            public MaterialProperty colorMode;
            public MaterialProperty flipbookMode;
            public MaterialProperty softParticlesEnabled;
            public MaterialProperty cameraFadingEnabled;
            public MaterialProperty distortionEnabled;
            public MaterialProperty softParticlesNearFadeDistance;
            public MaterialProperty softParticlesFarFadeDistance;
            public MaterialProperty cameraNearFadeDistance;
            public MaterialProperty cameraFarFadeDistance;
            public MaterialProperty distortionBlend;
            public MaterialProperty distortionStrength;

            public ParticleProperties(MaterialProperty[] properties);
        }
    }
}
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.Rendering.Universal.ShaderGUI
{
    [MovedFrom("UnityEditor.Rendering.LWRP.ShaderGUI")]
    public static class BakedLitGUI
    {
        public static void Inputs(BakedLitProperties properties, MaterialEditor materialEditor);

        public struct BakedLitProperties
        {
            public MaterialProperty bumpMapProp;

            public BakedLitProperties(MaterialProperty[] properties);
        }
    }
}
using UnityEngine;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.Rendering.Universal.ShaderGUI
{
    [MovedFrom("UnityEditor.Rendering.LWRP.ShaderGUI")]
    public static class LitGUI
    {
        public static void Inputs(LitProperties properties, MaterialEditor materialEditor, Material material);
        public static void DoClearCoat(LitProperties properties, MaterialEditor materialEditor, Material material);
        public static void DoMetallicSpecularArea(LitProperties properties, MaterialEditor materialEditor, Material material);
        public static void DoSmoothness(LitProperties properties, Material material, string[] smoothnessChannelNames);
        public static SmoothnessMapChannel GetSmoothnessMapChannel(Material material);
        public static void SetMaterialKeywords(Material material);

        public enum WorkflowMode
        {
            Specular = 0,
            Metallic = 1
        }
        public enum SmoothnessMapChannel
        {
            SpecularMetallicAlpha = 0,
            AlbedoAlpha = 1
        }
        public static class Styles
        {
            public static GUIContent workflowModeText;
            public static GUIContent specularMapText;
            public static GUIContent metallicMapText;
            public static GUIContent smoothnessText;
            public static GUIContent smoothnessMapChannelText;
            public static GUIContent highlightsText;
            public static GUIContent reflectionsText;
            public static GUIContent heightMapText;
            public static GUIContent occlusionText;
            public static readonly string[] metallicSmoothnessChannelNames;
            public static readonly string[] specularSmoothnessChannelNames;
            public static GUIContent clearCoatText;
            public static GUIContent clearCoatMaskText;
            public static GUIContent clearCoatSmoothnessText;
        }
        public struct LitProperties
        {
            public MaterialProperty workflowMode;
            public MaterialProperty metallic;
            public MaterialProperty specColor;
            public MaterialProperty metallicGlossMap;
            public MaterialProperty specGlossMap;
            public MaterialProperty smoothness;
            public MaterialProperty smoothnessMapChannel;
            public MaterialProperty bumpMapProp;
            public MaterialProperty bumpScaleProp;
            public MaterialProperty parallaxMapProp;
            public MaterialProperty parallaxScaleProp;
            public MaterialProperty occlusionStrength;
            public MaterialProperty occlusionMap;
            public MaterialProperty highlights;
            public MaterialProperty reflections;
            public MaterialProperty clearCoat;
            public MaterialProperty clearCoatMap;
            public MaterialProperty clearCoatMask;
            public MaterialProperty clearCoatSmoothness;

            public LitProperties(MaterialProperty[] properties);
        }
    }
}
using UnityEngine;
using UnityEngine.Scripting.APIUpdating;

namespace UnityEditor.Rendering.Universal.ShaderGUI
{
    [MovedFrom("UnityEditor.Rendering.LWRP.ShaderGUI")]
    public static class SimpleLitGUI
    {
        public static void Inputs(SimpleLitProperties properties, MaterialEditor materialEditor, Material material);
        public static void Advanced(SimpleLitProperties properties);
        public static void DoSpecularArea(SimpleLitProperties properties, MaterialEditor materialEditor, Material material);
        public static void DoSmoothness(SimpleLitProperties properties, Material material);
        public static void SetMaterialKeywords(Material material);

        public enum SpecularSource
        {
            SpecularTextureAndColor = 0,
            NoSpecular = 1
        }
        public enum SmoothnessMapChannel
        {
            SpecularAlpha = 0,
            AlbedoAlpha = 1
        }
        public static class Styles
        {
            public static GUIContent specularMapText;
            public static GUIContent smoothnessText;
            public static GUIContent smoothnessMapChannelText;
            public static GUIContent highlightsText;
        }
        public struct SimpleLitProperties
        {
            public MaterialProperty specColor;
            public MaterialProperty specGlossMap;
            public MaterialProperty specHighlights;
            public MaterialProperty smoothnessMapChannel;
            public MaterialProperty smoothness;
            public MaterialProperty bumpMapProp;

            public SimpleLitProperties(MaterialProperty[] properties);
        }
    }
}
namespace UnityEditor.Rendering.Universal.Internal
{
    public static class ResourceGuid
    {
        public static readonly string rendererTemplate;
    }
}
-------- {Unity.RenderPipeline.Universal.ShaderLibrary(D:\Documents\GitHub\Rogue-like-game-i-guess\The game is liar\Library\ScriptAssemblies\Unity.RenderPipeline.Universal.ShaderLibrary.dll)}:    2 --------
namespace UnityEngine.Rendering.Universal
{
    public static class ShaderInput
    {
        [GenerateHLSL(Exact, False, False, False, 1, False, False, False, -1)]
        public struct LightData
        {
            public Vector4 position;
            public Vector4 color;
            public Vector4 attenuation;
            public Vector4 spotDirection;
            public Vector4 occlusionProbeChannels;
        }
        [GenerateHLSL(Exact, False, False, False, 1, False, False, False, -1)]
        public struct ShadowData
        {
            public Matrix4x4 worldToShadowMatrix;
            public Vector4 shadowParams;
        }
    }
}
-------- {Unity.RenderPipelines.ShaderGraph.ShaderGraphLibrary(D:\Documents\GitHub\Rogue-like-game-i-guess\The game is liar\Library\ScriptAssemblies\Unity.RenderPipelines.ShaderGraph.ShaderGraphLibrary.dll)}:    0 --------
-------- {Unity.Timeline.Editor(D:\Documents\GitHub\Rogue-like-game-i-guess\The game is liar\Library\ScriptAssemblies\Unity.Timeline.Editor.dll)}:  721 --------
using System;
using UnityEditor;
using UnityEditor.Timeline;
using UnityEngine;

[FilePath("TimelinePreferences.asset", PreferencesFolder)]
public class TimelinePreferences : ScriptableSingleton<TimelinePreferences>
{
    [SerializeField]
    public TimeFormat timeFormat;
    [Obsolete("timeUnitInFrame is deprecated. Use timeFormat instead", False)]
    public bool timeUnitInFrame;
    [SerializeField]
    public bool showAudioWaveform;
    [SerializeField]
    public bool snapToFrame;
    [SerializeField]
    public bool edgeSnap;
    [SerializeField]
    public PlaybackScrollMode playbackScrollMode;

    public TimelinePreferences();

    public bool audioScrubbing { get; set; }
    public bool playbackLockedToFrame { get; set; }

    public void Save();
}
using System;
using UnityEditor;
using UnityEngine;

[FilePath("ProjectSettings/TimelineSettings.asset", ProjectFolder)]
public class TimelineProjectSettings : ScriptableSingleton<TimelineProjectSettings>
{
    [HideInInspector]
    [Obsolete("assetDefaultFramerate has been deprecated. Use defaultFrameRate instead.")]
    public float assetDefaultFramerate;

    public TimelineProjectSettings();

    public double defaultFrameRate { get; set; }

    public void Save();
}
using UnityEngine;

namespace UnityEditor.Timeline
{
    public struct ClipBackgroundRegion
    {
        public ClipBackgroundRegion(Rect _position, double _startTime, double _endTime);

        public Rect position { get; }
        public double startTime { get; }
        public double endTime { get; }

        public override bool Equals(object obj);
        public bool Equals(ClipBackgroundRegion other);
        public override int GetHashCode();

        public static bool operator ==(ClipBackgroundRegion region1, ClipBackgroundRegion region2);
        public static bool operator !=(ClipBackgroundRegion region1, ClipBackgroundRegion region2);
    }
}
using System.Collections.Generic;
using UnityEngine;

namespace UnityEditor.Timeline
{
    public struct ClipDrawOptions
    {
        public string errorText { get; set; }
        public bool displayClipName { get; set; }
        public bool hideScaleIndicator { get; set; }
        public string tooltip { get; set; }
        public Color highlightColor { get; set; }
        public IEnumerable<Texture2D> icons { get; set; }

        public override bool Equals(object obj);
        public bool Equals(ClipDrawOptions other);
        public override int GetHashCode();

        public static bool operator ==(ClipDrawOptions options1, ClipDrawOptions options2);
        public static bool operator !=(ClipDrawOptions options1, ClipDrawOptions options2);
    }
}
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Playables;
using UnityEngine.Timeline;

namespace UnityEditor.Timeline
{
    public class ClipEditor
    {
        public ClipEditor();

        public virtual ClipDrawOptions GetClipOptions(TimelineClip clip);
        public virtual void DrawBackground(TimelineClip clip, ClipBackgroundRegion region);
        public virtual void OnCreate(TimelineClip clip, TrackAsset track, TimelineClip clonedFrom);
        public string GetErrorText(TimelineClip clip);
        public Color GetDefaultHighlightColor(TimelineClip clip);
        public virtual void OnClipChanged(TimelineClip clip);
        public virtual void GetSubTimelines(TimelineClip clip, PlayableDirector director, List<PlayableDirector> subTimelines);
    }
}
using System;

namespace UnityEditor.Timeline
{
    [Flags]
    public enum MarkerUIStates
    {
        None = 0,
        Selected = 1,
        Collapsed = 2
    }
}
namespace UnityEditor.Timeline
{
    public struct MarkerDrawOptions
    {
        public string tooltip { get; set; }
        public string errorText { get; set; }

        public override bool Equals(object obj);
        public bool Equals(MarkerDrawOptions other);
        public override int GetHashCode();

        public static bool operator ==(MarkerDrawOptions options1, MarkerDrawOptions options2);
        public static bool operator !=(MarkerDrawOptions options1, MarkerDrawOptions options2);
    }
}
using UnityEngine;

namespace UnityEditor.Timeline
{
    public struct MarkerOverlayRegion
    {
        public MarkerOverlayRegion(Rect _markerRegion, Rect _timelineRegion, double _startTime, double _endTime);
        public MarkerOverlayRegion(Rect _markerRegion, Rect _timelineRegion, double _startTime, double _endTime, float _trackOffset);

        public Rect markerRegion { get; }
        public Rect timelineRegion { get; }
        public Rect trackRegion { get; }
        public double startTime { get; }
        public double endTime { get; }

        public override bool Equals(object obj);
        public bool Equals(MarkerOverlayRegion other);
        public override int GetHashCode();

        public static bool operator ==(MarkerOverlayRegion region1, MarkerOverlayRegion region2);
        public static bool operator !=(MarkerOverlayRegion region1, MarkerOverlayRegion region2);
    }
}
using UnityEngine.Timeline;

namespace UnityEditor.Timeline
{
    public class MarkerEditor
    {
        public MarkerEditor();

        public virtual MarkerDrawOptions GetMarkerOptions(IMarker marker);
        public virtual void OnCreate(IMarker marker, IMarker clonedFrom);
        public virtual void DrawOverlay(IMarker marker, MarkerUIStates uiState, MarkerOverlayRegion region);
    }
}
using UnityEngine;

namespace UnityEditor.Timeline
{
    public struct TrackDrawOptions
    {
        public string errorText { get; set; }
        public Color trackColor { get; set; }
        public float minimumHeight { get; set; }
        public Texture2D icon { get; set; }

        public override bool Equals(object obj);
        public bool Equals(TrackDrawOptions other);
        public override int GetHashCode();

        public static bool operator ==(TrackDrawOptions options1, TrackDrawOptions options2);
        public static bool operator !=(TrackDrawOptions options1, TrackDrawOptions options2);
    }
}
namespace UnityEditor.Timeline
{
    public enum TrackBindingErrors
    {
        None = 0,
        BoundGameObjectDisabled = 1,
        NoValidComponent = 2,
        BehaviourIsDisabled = 4,
        InvalidBinding = 8,
        PrefabBound = 16,
        All = 2147483647
    }
}
using System;
using UnityEngine;
using UnityEngine.Timeline;

namespace UnityEditor.Timeline
{
    public class TrackEditor
    {
        public static readonly float DefaultTrackHeight;
        public static readonly float MinimumTrackHeight;
        public static readonly float MaximumTrackHeight;

        public TrackEditor();

        public virtual TrackDrawOptions GetTrackOptions(TrackAsset track, UnityEngine.Object binding);
        public string GetErrorText(TrackAsset track, UnityEngine.Object boundObject, TrackBindingErrors detectErrors);
        public Color GetTrackColor(TrackAsset track);
        public Type GetBindingType(TrackAsset track);
        public virtual void OnCreate(TrackAsset track, TrackAsset copiedFrom);
        public virtual void OnTrackChanged(TrackAsset track);
        public virtual bool IsBindingAssignableFrom(UnityEngine.Object candidate, TrackAsset track);
        public virtual UnityEngine.Object GetBindingFrom(UnityEngine.Object candidate, TrackAsset track);
    }
}
using UnityEngine.Timeline;

namespace UnityEditor.Timeline
{
    public static class AnimationTrackExtensions
    {
        public static bool CanStartRecording(this AnimationTrack track);
        public static bool IsRecording(this AnimationTrack track);
        public static bool StartRecording(this AnimationTrack track);
        public static void StopRecording(this AnimationTrack track);
    }
}
using UnityEngine.Timeline;

namespace UnityEditor.Timeline
{
    public static class TrackExtensions
    {
        public static bool IsCollapsed(this TrackAsset track);
        public static void SetCollapsed(this TrackAsset track, bool collapsed);
        public static bool IsVisibleInHierarchy(this TrackAsset track);
    }
}
using System;
using UnityEngine.Playables;
using UnityEngine.Timeline;

namespace UnityEditor.Timeline
{
    public static class TimelineEditor
    {
        public static PlayableDirector inspectedDirector { get; }
        public static PlayableDirector masterDirector { get; }
        public static TimelineAsset inspectedAsset { get; }
        public static TimelineAsset masterAsset { get; }
        [Obsolete("playableDirector is ambiguous. Please select either inspectedDirector or masterDirector instead.", False)]
        public static PlayableDirector playableDirector { get; }
        [Obsolete("timelineAsset is ambiguous. Please select either inspectedAsset or masterAsset instead.", False)]
        public static TimelineAsset timelineAsset { get; }
        public static TimelineClip[] selectedClips { get; set; }
        public static TimelineClip selectedClip { get; set; }

        public static TimelineEditorWindow GetWindow();
        public static TimelineEditorWindow GetOrCreateWindow();
        public static void Refresh(RefreshReason reason);
        public static double GetInspectedTimeFromMasterTime(double masterTime);
        public static double GetMasterTimeFromInspectedTime(double inspectedTime);
    }
}
using System;

namespace UnityEditor.Timeline
{
    [Flags]
    public enum RefreshReason
    {
        WindowNeedsRedraw = 1,
        SceneNeedsUpdate = 2,
        ContentsModified = 4,
        ContentsAddedOrRemoved = 8
    }
}
using System.Collections.Generic;
using UnityEditor.Timeline.Actions;
using UnityEngine.Playables;
using UnityEngine.Timeline;

namespace UnityEditor.Timeline
{
    public static class UndoExtensions
    {
        public static void RegisterContext(ActionContext context, string undoTitle);
        public static void RegisterTimeline(TimelineAsset asset, string undoTitle);
        public static void RegisterCompleteTimeline(TimelineAsset asset, string undoTitle);
        public static void RegisterTrack(TrackAsset asset, string undoTitle);
        public static void RegisterTracks(IEnumerable<TrackAsset> tracks, string undoTitle);
        public static void RegisterClip(TimelineClip clip, string undoTitle, bool includePlayableAsset = True);
        public static void RegisterPlayableAsset(PlayableAsset asset, string undoTitle);
        public static void RegisterClips(IEnumerable<TimelineClip> clips, string name, bool includePlayableAssets = True);
        public static void RegisterMarker(IMarker marker, string undoTitle);
        public static void RegisterMarkers(IEnumerable<IMarker> markers, string undoTitle);
    }
}
using System;

namespace UnityEditor.Timeline
{
    [AttributeUsage(Class, AllowMultiple = False, Inherited = True)]
    public sealed class CustomTimelineEditorAttribute : Attribute
    {
        public CustomTimelineEditorAttribute(Type type);

        public Type classToEdit { get; }
    }
}
namespace UnityEditor.Timeline
{
    public enum TimeFormat
    {
        Frames = 0,
        Timecode = 1,
        Seconds = 2
    }
}
using System;

namespace UnityEditor.Timeline
{
    [Flags]
    public enum TimelineModes
    {
        Active = 1,
        ReadOnly = 2,
        Inactive = 4,
        Disabled = 8,
        AssetEdition = 16,
        Default = 17
    }
}
namespace UnityEditor.Timeline
{
    public enum PlaybackScrollMode
    {
        None = 0,
        Pan = 1,
        Smooth = 2
    }
}
using System;
using UnityEngine.Playables;
using UnityEngine.Timeline;

namespace UnityEditor.Timeline
{
    public readonly struct SequenceContext : IEquatable<SequenceContext>
    {
        public SequenceContext(PlayableDirector director, TimelineClip clip);

        public PlayableDirector director { get; }
        public TimelineClip clip { get; }

        public bool IsValid();
        public bool Equals(SequenceContext other);
        public override bool Equals(object obj);
        public override int GetHashCode();

        public static bool operator ==(SequenceContext left, SequenceContext right);
        public static bool operator !=(SequenceContext left, SequenceContext right);
    }
}
using UnityEngine.Playables;
using UnityEngine.Timeline;

namespace UnityEditor.Timeline
{
    public abstract class TimelineEditorWindow : EditorWindow
    {
        protected TimelineEditorWindow();

        public abstract TimelineNavigator navigator { get; }
        public abstract bool locked { get; set; }

        public abstract void SetTimeline(TimelineAsset sequence);
        public abstract void SetTimeline(PlayableDirector director);
        public abstract void ClearTimeline();
    }
}
using System.Collections.Generic;

namespace UnityEditor.Timeline
{
    public sealed class TimelineNavigator
    {
        public SequenceContext GetCurrentContext();
        public SequenceContext GetParentContext();
        public SequenceContext GetRootContext();
        public IEnumerable<SequenceContext> GetChildContexts();
        public IEnumerable<SequenceContext> GetBreadcrumbs();
        public void NavigateTo(SequenceContext context);
    }
}
namespace UnityEditor.Timeline
{
    public interface IInspectorChangeHandler
    {
        void OnPlayableAssetChangedInInspector();
    }
}
using System.Collections.Generic;
using UnityEngine.Playables;
using UnityEngine.Timeline;

namespace UnityEditor.Timeline.Actions
{
    public struct ActionContext
    {
        public TimelineAsset timeline;
        public PlayableDirector director;
        public double? invocationTime;

        public IEnumerable<TrackAsset> tracks { get; set; }
        public IEnumerable<TimelineClip> clips { get; set; }
        public IEnumerable<IMarker> markers { get; set; }
    }
}
using System.Collections.Generic;
using UnityEngine.Timeline;

namespace UnityEditor.Timeline.Actions
{
    [ActiveInMode(Default)]
    public abstract class ClipAction : IAction
    {
        protected ClipAction();

        public abstract bool Execute(IEnumerable<TimelineClip> clips);
        public abstract ActionValidity Validate(IEnumerable<TimelineClip> clips);
    }
}
using System.Collections.Generic;
using UnityEngine.Timeline;

namespace UnityEditor.Timeline.Actions
{
    public static class Invoker
    {
        public static bool Invoke<T>(this ActionContext context) where T : TimelineAction;
        public static bool Invoke<T>(this IEnumerable<TrackAsset> tracks) where T : TrackAction;
        public static bool Invoke<T>(this IEnumerable<TimelineClip> clips) where T : ClipAction;
        public static bool Invoke<T>(this IEnumerable<IMarker> markers) where T : MarkerAction;
        public static bool InvokeWithSelected<T>() where T : TimelineAction;
        public static bool InvokeWithSelectedClips<T>() where T : ClipAction;
        public static bool InvokeWithSelectedTracks<T>() where T : TrackAction;
        public static bool InvokeWithSelectedMarkers<T>() where T : MarkerAction;
    }
}
using System.Collections.Generic;
using UnityEngine.Timeline;

namespace UnityEditor.Timeline.Actions
{
    [ActiveInMode(Default)]
    public abstract class MarkerAction : IAction
    {
        protected MarkerAction();

        public abstract bool Execute(IEnumerable<IMarker> markers);
        public abstract ActionValidity Validate(IEnumerable<IMarker> markers);
    }
}
namespace UnityEditor.Timeline.Actions
{
    public enum ActionValidity
    {
        Valid = 0,
        NotApplicable = 1,
        Invalid = 2
    }
}
namespace UnityEditor.Timeline.Actions
{
    [ActiveInMode(Default)]
    public abstract class TimelineAction : IAction
    {
        protected TimelineAction();

        public abstract bool Execute(ActionContext context);
        public abstract ActionValidity Validate(ActionContext context);
    }
}
using System.Collections.Generic;
using UnityEngine.Timeline;

namespace UnityEditor.Timeline.Actions
{
    [ActiveInMode(Default)]
    public abstract class TrackAction : IAction
    {
        protected TrackAction();

        public abstract bool Execute(IEnumerable<TrackAsset> tracks);
        public abstract ActionValidity Validate(IEnumerable<TrackAsset> tracks);
    }
}
using System;

namespace UnityEditor.Timeline.Actions
{
    [AttributeUsage(Class)]
    public class ActiveInModeAttribute : Attribute
    {
        public ActiveInModeAttribute(TimelineModes timelineModes);

        public TimelineModes modes { get; }
    }
}
using System;

namespace UnityEditor.Timeline.Actions
{
    [AttributeUsage(Class)]
    public class MenuEntryAttribute : Attribute
    {
        public MenuEntryAttribute(string path = null, int priority = 9000);
    }
}
using UnityEditor.ShortcutManagement;
using UnityEngine;

namespace UnityEditor.Timeline.Actions
{
    public class TimelineShortcutAttribute : ShortcutAttribute
    {
        public TimelineShortcutAttribute(string id, KeyCode defaultKeyCode, ShortcutModifiers defaultShortcutModifiers = None);
    }
}
namespace UnityEditor.Timeline.Actions
{
    public static class MenuPriority
    {
        public const int defaultPriority = 9000;
        public const int separatorAt = 1000;

        public static class TimelineActionSection
        {
            public const int start = 1000;
            public const int copy = 1100;
            public const int paste = 1200;
            public const int duplicate = 1300;
            public const int delete = 1400;
            public const int keyAllAnimated = 1450;
            public const int matchContent = 1500;
        }
        public static class TrackActionSection
        {
            public const int start = 2000;
            public const int lockTrack = 2100;
            public const int lockSelected = 2150;
            public const int mute = 2200;
            public const int muteSelected = 2250;
            public const int showHideMarkers = 2300;
            public const int removeInvalidMarkers = 2400;
            public const int editInAnimationWindow = 2800;
        }
        public static class AddTrackMenu
        {
            public const int start = 3000;
            public const int addLayerTrack = 3000;
        }
        public static class ClipEditActionSection
        {
            public const int start = 4000;
            public const int editInAnimationWindow = 4100;
            public const int editSubTimeline = 4200;
        }
        public static class ClipActionSection
        {
            public const int start = 5000;
            public const int trimStart = 5100;
            public const int trimEnd = 5110;
            public const int split = 5120;
            public const int completeLastLoop = 6000;
            public const int trimLastLoop = 6110;
            public const int matchDuration = 6120;
            public const int doubleSpeed = 7000;
            public const int halfSpeed = 7110;
            public const int resetDuration = 8000;
            public const int resetSpeed = 8110;
            public const int resetAll = 8120;
            public const int tile = 5300;
            public const int findSourceAsset = 5400;
        }
        public static class MarkerActionSection
        {
            public const int start = 6000;
        }
        public static class CustomTimelineActionSection
        {
            public const int start = 7000;
        }
        public static class CustomTrackActionSection
        {
            public const int start = 8000;
            public const int convertToClipMode = 8100;
            public const int convertFromClipMode = 8200;
            public const int applyTrackOffset = 8300;
            public const int applySceneOffset = 8310;
            public const int applyAutoOffset = 8320;
            public const int addOverrideTrack = 8500;
            public const int customTrackAction = 8900;
        }
        public static class CustomClipActionSection
        {
            public const int start = 9000;
            public const int matchPrevious = 9100;
            public const int matchNext = 9110;
            public const int resetOffset = 9120;
            public const int customClipAction = 9900;
        }
        public static class AddItem
        {
            public const int addGroup = 10000;
            public const int addTrack = 11000;
            public const int addCustomTrack = 12000;
            public const int addClip = 13000;
            public const int addCustomClip = 14000;
            public const int addMarker = 15000;
            public const int addCustomMarker = 16000;
        }
    }
}
using System;

namespace UnityEditor.Timeline.Actions
{
    [AttributeUsage(Class, Inherited = False, AllowMultiple = False)]
    public class ApplyDefaultUndoAttribute : Attribute
    {
        public string UndoTitle;

        public ApplyDefaultUndoAttribute(string undoTitle = null);
    }
}
-------- {Unity.Mathematics.Editor(D:\Documents\GitHub\Rogue-like-game-i-guess\The game is liar\Library\ScriptAssemblies\Unity.Mathematics.Editor.dll)}:    9 --------
-------- {Unity.MemoryProfiler.Editor.MemoryProfilerModule(D:\Documents\GitHub\Rogue-like-game-i-guess\The game is liar\Library\ScriptAssemblies\Unity.MemoryProfiler.Editor.MemoryProfilerModule.dll)}:   -1 --------
-------- {Unity.RenderPipelines.Core.Editor(D:\Documents\GitHub\Rogue-like-game-i-guess\The game is liar\Library\ScriptAssemblies\Unity.RenderPipelines.Core.Editor.dll)}:  252 --------
using UnityEditor;

public class RenderGraphViewer : EditorWindow
{
    public RenderGraphViewer();
}
using UnityEngine;

namespace UnityEditor.Rendering
{
    public static class CameraEditorUtils
    {
        public static Material GUITextureBlit2SRGBMaterial { get; }

        public static void DrawCameraSceneViewOverlay(Object target, SceneView sceneView, GetPreviewCamera previewCameraGetter);
        public static bool IsViewPortRectValidToRender(Rect normalizedViewPortRect);

        public delegate Camera GetPreviewCamera(Camera sourceCamera, Vector2 previewSize);
    }
}
using System.Collections.Generic;
using UnityEngine;

namespace UnityEditor.Rendering
{
    public interface IRemoveAdditionalDataContextualMenu<T> where T : Component
    {
        void RemoveComponent(T component, IEnumerable<Component> dependencies);
    }
}
using System;

namespace UnityEditor.Rendering
{
    [Flags]
    public enum FoldoutOption
    {
        None = 0,
        Indent = 1,
        Boxed = 4,
        SubFoldout = 8,
        NoSpaceAtEnd = 16
    }
}
using System;

namespace UnityEditor.Rendering
{
    [Flags]
    public enum GroupOption
    {
        None = 0,
        Indent = 1
    }
}
using System;
using UnityEngine;

namespace UnityEditor.Rendering
{
    public static class CoreEditorDrawer<TData>
    {
        public static readonly IDrawer space;
        public static readonly IDrawer noop;

        public static IDrawer Conditional(Enabler enabler, params IDrawer[] contentDrawers);
        public static IDrawer Conditional(Enabler enabler, params ActionDrawer[] contentDrawers);
        public static IDrawer TernaryConditional(Enabler switch, IDrawer drawIfTrue, IDrawer drawIfFalse);
        public static IDrawer TernaryConditional(Enabler switch, ActionDrawer drawIfTrue, ActionDrawer drawIfFalse);
        public static IDrawer Group(params IDrawer[] contentDrawers);
        public static IDrawer Group(params ActionDrawer[] contentDrawers);
        public static IDrawer Group(float labelWidth, params IDrawer[] contentDrawers);
        public static IDrawer Group(float labelWidth, params ActionDrawer[] contentDrawers);
        public static IDrawer Group(GroupOption options, params IDrawer[] contentDrawers);
        public static IDrawer Group(GroupOption options, params ActionDrawer[] contentDrawers);
        public static IDrawer Group(float labelWidth, GroupOption options, params IDrawer[] contentDrawers);
        public static IDrawer Group(float labelWidth, GroupOption options, params ActionDrawer[] contentDrawers);
        public static IDrawer Select<T2Data>(DataSelect<T2Data> dataSelect, params CoreEditorDrawer<T2Data>.IDrawer[] otherDrawers);
        public static IDrawer Select<T2Data>(DataSelect<T2Data> dataSelect, params CoreEditorDrawer<T2Data>.ActionDrawer[] otherDrawers);
        public static IDrawer FoldoutGroup<TEnum, TState>(string title, TEnum mask, ExpandedState<TEnum, TState> state, params IDrawer[] contentDrawers) where TEnum : IConvertible, struct;
        public static IDrawer FoldoutGroup<TEnum, TState>(string title, TEnum mask, ExpandedState<TEnum, TState> state, params ActionDrawer[] contentDrawers) where TEnum : IConvertible, struct;
        public static IDrawer FoldoutGroup<TEnum, TState>(string title, TEnum mask, ExpandedState<TEnum, TState> state, FoldoutOption options, params IDrawer[] contentDrawers) where TEnum : IConvertible, struct;
        public static IDrawer FoldoutGroup<TEnum, TState>(string title, TEnum mask, ExpandedState<TEnum, TState> state, FoldoutOption options, params ActionDrawer[] contentDrawers) where TEnum : IConvertible, struct;
        public static IDrawer FoldoutGroup<TEnum, TState>(GUIContent title, TEnum mask, ExpandedState<TEnum, TState> state, params IDrawer[] contentDrawers) where TEnum : IConvertible, struct;
        public static IDrawer FoldoutGroup<TEnum, TState>(GUIContent title, TEnum mask, ExpandedState<TEnum, TState> state, params ActionDrawer[] contentDrawers) where TEnum : IConvertible, struct;
        public static IDrawer FoldoutGroup<TEnum, TState>(GUIContent title, TEnum mask, ExpandedState<TEnum, TState> state, FoldoutOption options, params IDrawer[] contentDrawers) where TEnum : IConvertible, struct;
        public static IDrawer FoldoutGroup<TEnum, TState>(GUIContent title, TEnum mask, ExpandedState<TEnum, TState> state, FoldoutOption options, params ActionDrawer[] contentDrawers) where TEnum : IConvertible, struct;
        public static IDrawer AdvancedFoldoutGroup<TEnum, TState>(GUIContent foldoutTitle, TEnum foldoutMask, ExpandedState<TEnum, TState> foldoutState, Enabler isAdvanced, SwitchEnabler switchAdvanced, IDrawer normalContent, IDrawer advancedContent, FoldoutOption options = Indent) where TEnum : IConvertible, struct;
        public static IDrawer AdvancedFoldoutGroup<TEnum, TState>(GUIContent foldoutTitle, TEnum foldoutMask, ExpandedState<TEnum, TState> foldoutState, Enabler isAdvanced, SwitchEnabler switchAdvanced, ActionDrawer normalContent, IDrawer advancedContent, FoldoutOption options = Indent) where TEnum : IConvertible, struct;
        public static IDrawer AdvancedFoldoutGroup<TEnum, TState>(GUIContent foldoutTitle, TEnum foldoutMask, ExpandedState<TEnum, TState> foldoutState, Enabler isAdvanced, SwitchEnabler switchAdvanced, IDrawer normalContent, ActionDrawer advancedContent, FoldoutOption options = Indent) where TEnum : IConvertible, struct;
        public static IDrawer AdvancedFoldoutGroup<TEnum, TState>(GUIContent foldoutTitle, TEnum foldoutMask, ExpandedState<TEnum, TState> foldoutState, Enabler isAdvanced, SwitchEnabler switchAdvanced, ActionDrawer normalContent, ActionDrawer advancedContent, FoldoutOption options = Indent) where TEnum : IConvertible, struct;

        public interface IDrawer
        {
            void Draw(TData serializedProperty, Editor owner);
        }
        public delegate bool Enabler(TData data, Editor owner);
        public delegate void SwitchEnabler(TData data, Editor owner);
        public delegate T2Data DataSelect<T2Data>(TData data, Editor owner);
        public delegate void ActionDrawer(TData data, Editor owner);
    }
}
using System.Collections.Generic;

namespace UnityEditor.Rendering
{
    public static class CoreEditorDrawersExtensions
    {
        public static void Draw<TData>(this IEnumerable<CoreEditorDrawer<TData>.IDrawer> drawers, TData data, Editor owner);
    }
}
using UnityEngine;

namespace UnityEditor.Rendering
{
    public static class CoreEditorStyles
    {
        public static readonly GUIStyle smallTickbox;
        public static readonly GUIStyle smallMixedTickbox;
        public static readonly GUIStyle miniLabelButton;

        public static Texture2D paneOptionsIcon { get; }
    }
}
using System;
using System.Linq.Expressions;
using UnityEngine;
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    public static class CoreEditorUtils
    {
        public static GraphicsDeviceType[] buildTargets { get; }

        public static string FindProperty<T, TValue>(Expression<Func<T, TValue>> expr);
        public static void DrawFixMeBox(string text, Action action);
        public static void DrawMultipleFields(string label, SerializedProperty[] ppts, GUIContent[] lbls);
        public static void DrawMultipleFields(GUIContent label, SerializedProperty[] ppts, GUIContent[] lbls);
        public static void DrawSplitter(bool isBoxed = False);
        public static void DrawHeader(string title);
        public static void DrawHeader(GUIContent title);
        public static bool DrawHeaderFoldout(string title, bool state, bool isBoxed = False, Func<bool> hasMoreOptions = null, Action toggleMoreOption = null);
        public static bool DrawHeaderFoldout(GUIContent title, bool state, bool isBoxed = False, Func<bool> hasMoreOptions = null, Action toggleMoreOptions = null);
        public static bool DrawSubHeaderFoldout(string title, bool state, bool isBoxed = False, Func<bool> hasMoreOptions = null, Action toggleMoreOptions = null);
        public static bool DrawSubHeaderFoldout(GUIContent title, bool state, bool isBoxed = False, Func<bool> hasMoreOptions = null, Action toggleMoreOptions = null);
        public static bool DrawHeaderToggle(string title, SerializedProperty group, SerializedProperty activeField, Action<Vector2> contextAction = null, Func<bool> hasMoreOptions = null, Action toggleMoreOptions = null);
        public static bool DrawHeaderToggle(GUIContent title, SerializedProperty group, SerializedProperty activeField, Action<Vector2> contextAction = null, Func<bool> hasMoreOptions = null, Action toggleMoreOptions = null);
        public static bool DrawHeaderToggle(string title, SerializedProperty group, SerializedProperty activeField, Action<Vector2> contextAction, Func<bool> hasMoreOptions, Action toggleMoreOptions, string documentationURL);
        public static bool DrawHeaderToggle(GUIContent title, SerializedProperty group, SerializedProperty activeField, Action<Vector2> contextAction, Func<bool> hasMoreOptions, Action toggleMoreOptions, string documentationURL);
        public static void DrawVector6(GUIContent label, SerializedProperty positive, SerializedProperty negative, Vector3 min, Vector3 max, Color[] colors = null, SerializedProperty multiplicator = null, bool allowIntersection = True);
        public static void DrawPopup(GUIContent label, SerializedProperty property, string[] options);
        public static void DrawEnumPopup(SerializedProperty property, Type type, GUIContent label = null);
        public static void RemoveMaterialKeywords(Material material);
        public static T[] GetAdditionalData<T>(UnityEngine.Object[] targets, Action<T> initDefault = null) where T : Component;
        public static void AddAdditionalData<T, AdditionalT>(GameObject go, Action<AdditionalT> initDefault = null) where T : Component where AdditionalT : Component;
        public static GameObject CreateGameObject(GameObject parent, string name, params Type[] types);
        public static GameObject CreateGameObject(string name, UnityEngine.Object context);
        public static string GetCurrentProjectVersion();
        public static void CheckOutFile(bool VCSEnabled, UnityEngine.Object mat);
        public static Texture2D LoadIcon(string path, string name, string extention = ".png");
    }
}
using UnityEngine;
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    public abstract class DebugState : ScriptableObject
    {
        [SerializeField]
        protected string m_QueryPath;

        protected DebugState();

        public string queryPath { get; }

        public abstract object GetValue();
        public abstract void SetValue(object value, DebugUI.IValueField field);
        public virtual void OnEnable();
    }
}
using UnityEngine;
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    public class DebugState<T> : DebugState
    {
        [SerializeField]
        protected T m_Value;

        public DebugState();

        public virtual T value { get; set; }

        public override object GetValue();
        public override void SetValue(object value, DebugUI.IValueField field);
        public override int GetHashCode();
    }
}
using System;

namespace UnityEditor.Rendering
{
    public sealed class DebugStateAttribute : Attribute
    {
        public DebugStateAttribute(params Type[] types);
    }
}
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    [DebugState(new[] {typeof(DebugUI.BoolField), typeof(DebugUI.Foldout), typeof(DebugUI.HistoryBoolField) })]
    public sealed class DebugStateBool : DebugState<bool>
    {
        public DebugStateBool();
    }
}
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    [DebugState(new[] {typeof(DebugUI.IntField), typeof(DebugUI.EnumField), typeof(DebugUI.HistoryEnumField) })]
    public sealed class DebugStateInt : DebugState<int>
    {
        public DebugStateInt();
    }
}
using System;
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    [DebugState(new[] {typeof(DebugUI.BitField) })]
    public sealed class DebugStateFlags : DebugState<Enum>
    {
        public DebugStateFlags();
    }
}
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    [DebugState(new[] {typeof(DebugUI.UIntField) })]
    public sealed class DebugStateUInt : DebugState<uint>
    {
        public DebugStateUInt();
    }
}
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    [DebugState(new[] {typeof(DebugUI.FloatField) })]
    public sealed class DebugStateFloat : DebugState<float>
    {
        public DebugStateFloat();
    }
}
using UnityEngine;
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    [DebugState(new[] {typeof(DebugUI.ColorField) })]
    public sealed class DebugStateColor : DebugState<Color>
    {
        public DebugStateColor();
    }
}
using UnityEngine;
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    [DebugState(new[] {typeof(DebugUI.Vector2Field) })]
    public sealed class DebugStateVector2 : DebugState<Vector2>
    {
        public DebugStateVector2();
    }
}
using UnityEngine;
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    [DebugState(new[] {typeof(DebugUI.Vector3Field) })]
    public sealed class DebugStateVector3 : DebugState<Vector3>
    {
        public DebugStateVector3();
    }
}
using UnityEngine;
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    [DebugState(new[] {typeof(DebugUI.Vector4Field) })]
    public sealed class DebugStateVector4 : DebugState<Vector4>
    {
        public DebugStateVector4();
    }
}
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    [DebugUIDrawer(typeof(DebugUI.Value))]
    public sealed class DebugUIDrawerValue : DebugUIDrawer
    {
        public DebugUIDrawerValue();

        public override bool OnGUI(DebugUI.Widget widget, DebugState state);
    }
}
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    [DebugUIDrawer(typeof(DebugUI.Button))]
    public sealed class DebugUIDrawerButton : DebugUIDrawer
    {
        public DebugUIDrawerButton();

        public override bool OnGUI(DebugUI.Widget widget, DebugState state);
    }
}
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    [DebugUIDrawer(typeof(DebugUI.BoolField))]
    public sealed class DebugUIDrawerBoolField : DebugUIDrawer
    {
        public DebugUIDrawerBoolField();

        public override bool OnGUI(DebugUI.Widget widget, DebugState state);
    }
}
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    [DebugUIDrawer(typeof(DebugUI.HistoryBoolField))]
    public sealed class DebugUIDrawerHistoryBoolField : DebugUIDrawer
    {
        public DebugUIDrawerHistoryBoolField();

        public override bool OnGUI(DebugUI.Widget widget, DebugState state);
    }
}
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    [DebugUIDrawer(typeof(DebugUI.IntField))]
    public sealed class DebugUIDrawerIntField : DebugUIDrawer
    {
        public DebugUIDrawerIntField();

        public override bool OnGUI(DebugUI.Widget widget, DebugState state);
    }
}
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    [DebugUIDrawer(typeof(DebugUI.UIntField))]
    public sealed class DebugUIDrawerUIntField : DebugUIDrawer
    {
        public DebugUIDrawerUIntField();

        public override bool OnGUI(DebugUI.Widget widget, DebugState state);
    }
}
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    [DebugUIDrawer(typeof(DebugUI.FloatField))]
    public sealed class DebugUIDrawerFloatField : DebugUIDrawer
    {
        public DebugUIDrawerFloatField();

        public override bool OnGUI(DebugUI.Widget widget, DebugState state);
    }
}
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    [DebugUIDrawer(typeof(DebugUI.EnumField))]
    public sealed class DebugUIDrawerEnumField : DebugUIDrawer
    {
        public DebugUIDrawerEnumField();

        public override bool OnGUI(DebugUI.Widget widget, DebugState state);
    }
}
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    [DebugUIDrawer(typeof(DebugUI.HistoryEnumField))]
    public sealed class DebugUIDrawerHistoryEnumField : DebugUIDrawer
    {
        public DebugUIDrawerHistoryEnumField();

        public override bool OnGUI(DebugUI.Widget widget, DebugState state);
    }
}
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    [DebugUIDrawer(typeof(DebugUI.BitField))]
    public sealed class DebugUIDrawerBitField : DebugUIDrawer
    {
        public DebugUIDrawerBitField();

        public override bool OnGUI(DebugUI.Widget widget, DebugState state);
    }
}
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    [DebugUIDrawer(typeof(DebugUI.Foldout))]
    public sealed class DebugUIDrawerFoldout : DebugUIDrawer
    {
        public DebugUIDrawerFoldout();

        public override void Begin(DebugUI.Widget widget, DebugState state);
        public override bool OnGUI(DebugUI.Widget widget, DebugState state);
        public override void End(DebugUI.Widget widget, DebugState state);
    }
}
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    [DebugUIDrawer(typeof(DebugUI.ColorField))]
    public sealed class DebugUIDrawerColorField : DebugUIDrawer
    {
        public DebugUIDrawerColorField();

        public override bool OnGUI(DebugUI.Widget widget, DebugState state);
    }
}
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    [DebugUIDrawer(typeof(DebugUI.Vector2Field))]
    public sealed class DebugUIDrawerVector2Field : DebugUIDrawer
    {
        public DebugUIDrawerVector2Field();

        public override bool OnGUI(DebugUI.Widget widget, DebugState state);
    }
}
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    [DebugUIDrawer(typeof(DebugUI.Vector3Field))]
    public sealed class DebugUIDrawerVector3Field : DebugUIDrawer
    {
        public DebugUIDrawerVector3Field();

        public override bool OnGUI(DebugUI.Widget widget, DebugState state);
    }
}
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    [DebugUIDrawer(typeof(DebugUI.Vector4Field))]
    public sealed class DebugUIDrawerVector4Field : DebugUIDrawer
    {
        public DebugUIDrawerVector4Field();

        public override bool OnGUI(DebugUI.Widget widget, DebugState state);
    }
}
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    [DebugUIDrawer(typeof(DebugUI.Container))]
    public sealed class DebugUIDrawerContainer : DebugUIDrawer
    {
        public DebugUIDrawerContainer();

        public override void Begin(DebugUI.Widget widget, DebugState state);
        public override void End(DebugUI.Widget widget, DebugState state);
    }
}
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    [DebugUIDrawer(typeof(DebugUI.HBox))]
    public sealed class DebugUIDrawerHBox : DebugUIDrawer
    {
        public DebugUIDrawerHBox();

        public override void Begin(DebugUI.Widget widget, DebugState state);
        public override void End(DebugUI.Widget widget, DebugState state);
    }
}
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    [DebugUIDrawer(typeof(DebugUI.VBox))]
    public sealed class DebugUIDrawerVBox : DebugUIDrawer
    {
        public DebugUIDrawerVBox();

        public override void Begin(DebugUI.Widget widget, DebugState state);
        public override void End(DebugUI.Widget widget, DebugState state);
    }
}
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    [DebugUIDrawer(typeof(DebugUI.Table))]
    public sealed class DebugUIDrawerTable : DebugUIDrawer
    {
        public DebugUIDrawerTable();

        public override bool OnGUI(DebugUI.Widget widget, DebugState state);
    }
}
using System;

namespace UnityEditor.Rendering
{
    public class DebugUIDrawerAttribute : Attribute
    {
        public DebugUIDrawerAttribute(Type type);
    }
}
using UnityEngine;
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    public class DebugUIDrawer
    {
        public DebugUIDrawer();

        protected T Cast<T>(object o) where T : class;
        public virtual void Begin(DebugUI.Widget widget, DebugState state);
        public virtual bool OnGUI(DebugUI.Widget widget, DebugState state);
        public virtual void End(DebugUI.Widget widget, DebugState state);
        protected void Apply(DebugUI.IValueField widget, DebugState state, object value);
        protected Rect PrepareControlRect(float height = -1);
    }
}
using System;

namespace UnityEditor.Rendering
{
    public struct EditorPrefBoolFlags<T> : IEquatable<EditorPrefBoolFlags<T>>, IEquatable<T> where T : IConvertible, struct
    {
        public EditorPrefBoolFlags(string key);

        public T value { get; set; }
        public uint rawValue { get; set; }

        public bool Equals(T other);
        public bool Equals(EditorPrefBoolFlags<T> other);
        public bool HasFlag(T v);
        public void SetFlag(T f, bool v);

        public static EditorPrefBoolFlags<T> operator |(EditorPrefBoolFlags<T> l, T r);
        public static EditorPrefBoolFlags<T> operator &(EditorPrefBoolFlags<T> l, T r);
        public static EditorPrefBoolFlags<T> operator ^(EditorPrefBoolFlags<T> l, T r);

        public static explicit operator T(EditorPrefBoolFlags<T> v);
    }
}
using System;
using System.Reflection;

namespace UnityEditor.Rendering
{
    [DefaultMember("Item")]
    public struct ExpandedState<TState, TTarget> where TState : IConvertible, struct
    {
        public ExpandedState(TState defaultValue, string prefix = "CoreRP");

        public bool this[TState mask] { get; set; }

        public bool GetExpandedAreas(TState mask);
        public void SetExpandedAreas(TState mask, bool value);
        public void ExpandAll();
        public void CollapseAll();
    }
}
using System;
using System.Collections.Generic;
using UnityEngine;

namespace UnityEditor.Rendering
{
    [InitializeOnLoad]
    public class FilterWindow : EditorWindow
    {
        public static readonly float DefaultWidth;
        public static readonly float DefaultHeight;

        public FilterWindow();

        public interface IProvider
        {
            Vector2 position { get; set; }

            void CreateComponentTree(List<Element> tree);
            bool GoToChild(Element element, bool addIfComponent);
        }
        public class Element : IComparable
        {
            public int level;
            public GUIContent content;

            public Element();

            public string name { get; }

            public int CompareTo(object o);
        }
        public class GroupElement : Element
        {
            public Vector2 scroll;
            public int selectedIndex;

            public GroupElement(int level, string name);

            public bool WantsFocus { get; protected set; }
            public virtual bool ShouldDisable { get; }

            public virtual bool HandleKeyboard(Event evt, FilterWindow window, Action goToParent);
            public virtual bool OnGUI(FilterWindow sFilterWindow);
        }
    }
}
using UnityEngine;

namespace UnityEditor.Rendering
{
    public class HierarchicalBox
    {
        public HierarchicalBox(Color baseColor, Color[] polychromeHandleColors = null, HierarchicalBox parent = null);

        public bool monoHandle { get; set; }
        public Vector3 center { get; set; }
        public Vector3 size { get; set; }
        public Color baseColor { get; set; }

        public void DrawHull(bool filled);
        public void DrawHandle();
    }
}
using UnityEngine;

namespace UnityEditor.Rendering
{
    public class HierarchicalSphere
    {
        public HierarchicalSphere(Color baseColor, HierarchicalSphere parent = null);

        public Vector3 center { get; set; }
        public float radius { get; set; }
        public Color baseColor { get; set; }

        public void DrawHull(bool filled);
        public void DrawHandle();
    }
}
using UnityEngine;

namespace UnityEditor.Rendering
{
    public sealed class InspectorCurveEditor
    {
        public readonly Settings settings;

        public InspectorCurveEditor();
        public InspectorCurveEditor(Settings settings);

        public void Add(params SerializedProperty[] curves);
        public void Add(SerializedProperty curve);
        public void Add(SerializedProperty curve, CurveState state);
        public void Remove(SerializedProperty curve);
        public void RemoveAll();
        public CurveState GetCurveState(SerializedProperty curve);
        public void SetCurveState(SerializedProperty curve, CurveState state);
        public Selection GetSelection();
        public void SetKeyframe(SerializedProperty curve, int keyframeIndex, Keyframe keyframe);
        public bool OnGUI(Rect rect);

        public struct Settings
        {
            public Rect bounds;
            public RectOffset padding;
            public Color selectionColor;
            public float curvePickingDistance;
            public float keyTimeClampingDistance;

            public static Settings defaultSettings { get; }
        }
        public struct CurveState
        {
            public bool visible;
            public bool editable;
            public uint minPointCount;
            public float zeroKeyConstantValue;
            public Color color;
            public float width;
            public float handleWidth;
            public bool showNonEditableHandles;
            public bool onlyShowHandlesOnSelection;
            public bool loopInBounds;

            public static CurveState defaultState { get; }
        }
        public struct Selection
        {
            public SerializedProperty curve;
            public int keyframeIndex;
            public Keyframe? keyframe;

            public Selection(SerializedProperty curve, int keyframeIndex, Keyframe? keyframe);
        }
    }
}
using UnityEngine;

namespace UnityEditor.Rendering
{
    public static class CoreLightEditorUtilities
    {
        public static void DrawDirectionalLightGizmo(Light light);
        public static void DrawPointLightGizmo(Light light);
        public static void DrawRectangleLightGizmo(Light light);
        public static void DrawDiscLightGizmo(Light light);
        public static void DrawSpotLightGizmo(Light light);
    }
}
using UnityEngine;

namespace UnityEditor.Rendering
{
    public class IESEngine
    {
        public IESEngine();

        public TextureImporterType TextureGenerationType { set; }

        public string ReadFile(string iesFilePath);
        public string GetKeywordValue(string keyword);
        public string GetPhotometricType();
        public (float, string) GetMaximumIntensity();
        public (string, Texture) GenerateCubeCookie(TextureImporterCompression compression, int textureSize);
        public (string, Texture) Generate2DCookie(TextureImporterCompression compression, float coneAngle, int textureSize, bool applyLightAttenuation);
    }
}
using System;
using UnityEditor.AssetImporters;
using UnityEngine;

namespace UnityEditor.Rendering
{
    [ScriptedImporter(1, "ies")]
    public class IESImporter : ScriptedImporter
    {
        public IESEngine engine;
        public IESMetaData iesMetaData;

        public IESImporter();

        public static event Action<AssetImportContext, string, bool, string, float, Light, Texture> createRenderPipelinePrefabLight;

        public override void OnImportAsset(AssetImportContext ctx);
    }
}
using UnityEditor.AssetImporters;
using UnityEngine;

namespace UnityEditor.Rendering
{
    public class IESImporterEditor
    {
        protected SerializedProperty m_LightAimAxisRotationProp;
        protected PreviewRenderUtility m_PreviewRenderUtility;

        public IESImporterEditor();

        public void CommonOnEnable(SerializedProperty serializedObject);
        public void CommonOnInspectorGUI(ScriptedImporterEditor scriptedImporter);
        public void CommonApply();
        public bool CommonHasPreviewGUI(SetupRenderPipelinePreviewCamera setupRenderPipelinePreviewCamera, SetupRenderPipelinePreviewLight setupRenderPipelinePreviewLight, SetupRenderPipelinePreviewWallRenderer setupRenderPipelinePreviewWallRenderer, SetupRenderPipelinePreviewFloorRenderer setupRenderPipelinePreviewFloorRenderer);
        public GUIContent CommonGetPreviewTitle();
        public void CommonOnPreviewGUI(Rect r, GUIStyle background, ScriptedImporter target, SetupRenderPipelinePreviewLightIntensity setupRenderPipelinePreviewLightIntensity);
        public void CommonOnDisable();

        public delegate void LayoutRenderPipelineUseIesMaximumIntensity();
        public delegate void SetupRenderPipelinePreviewCamera(Camera camera);
        public delegate void SetupRenderPipelinePreviewLight(Light light);
        public delegate void SetupRenderPipelinePreviewWallRenderer(MeshRenderer wallRenderer);
        public delegate void SetupRenderPipelinePreviewFloorRenderer(MeshRenderer floorRenderer);
        public delegate void SetupRenderPipelinePreviewLightIntensity(Light light, SerializedProperty useIESMaximumIntensityProp, SerializedProperty iesMaximumIntensityUnitProp, SerializedProperty iesMaximumIntensityProp);
    }
}
namespace UnityEditor.Rendering
{
    public enum IESLightType
    {
        Point = 0,
        Spot = 1
    }
}
namespace UnityEditor.Rendering
{
    public enum IESResolution
    {
        IESResolution16 = 16,
        IESResolution32 = 32,
        IESResolution64 = 64,
        IESResolution128 = 128,
        IESResolution256 = 256,
        IESResolution512 = 512,
        IESResolution1024 = 1024,
        IESResolution2048 = 2048,
        IESResolution4096 = 4096
    }
}
using UnityEngine;

namespace UnityEditor.Rendering
{
    public class IESMetaData
    {
        public string FileFormatVersion;
        public string IESPhotometricType;
        public float IESMaximumIntensity;
        public string IESMaximumIntensityUnit;
        public string Manufacturer;
        public string LuminaireCatalogNumber;
        public string LuminaireDescription;
        public string LampCatalogNumber;
        public string LampDescription;
        public IESLightType PrefabLightType;
        [Range(1, 179)]
        public float SpotAngle;
        public IESResolution iesSize;
        public bool ApplyLightAttenuation;
        public bool UseIESMaximumIntensity;
        public TextureImporterCompression CookieCompression;
        [Range(-180, 180)]
        public float LightAimAxisRotation;

        public IESMetaData();

        public override int GetHashCode();
    }
}
using UnityEngine;

namespace UnityEditor.Rendering
{
    public class IESObject : ScriptableObject
    {
        public IESMetaData iesMetaData;

        public IESObject();
    }
}
namespace UnityEditor.Rendering
{
    public class IESReader
    {
        public IESReader();

        public string FileFormatVersion { get; }
        public float TotalLumens { get; }
        public float MaxCandelas { get; }
        public int PhotometricType { get; }

        public string ReadFile(string iesFilePath);
    }
}
namespace UnityEditor.Rendering
{
    public static class DialogText
    {
        public static readonly string title;
        public static readonly string proceed;
        public static readonly string ok;
        public static readonly string cancel;
        public static readonly string noSelectionMessage;
        public static readonly string projectBackMessage;
    }
}
using System;
using System.Collections.Generic;
using UnityEngine;

namespace UnityEditor.Rendering
{
    public class MaterialUpgrader
    {
        public MaterialUpgrader();

        public void Upgrade(Material material, UpgradeFlags flags);
        public virtual void Convert(Material srcMaterial, Material dstMaterial);
        public void RenameShader(string oldName, string newName, MaterialFinalizer finalizer = null);
        public void RenameTexture(string oldName, string newName);
        public void RenameFloat(string oldName, string newName);
        public void RenameColor(string oldName, string newName);
        public void RemoveTexture(string name);
        public void SetFloat(string propertyName, float value);
        public void SetColor(string propertyName, Color value);
        public void SetTexture(string propertyName, Texture value);
        public void RenameKeywordToFloat(string oldName, string newName, float setVal, float unsetVal);
        public static void UpgradeProjectFolder(List<MaterialUpgrader> upgraders, string progressBarName, UpgradeFlags flags = None);
        public static void UpgradeProjectFolder(List<MaterialUpgrader> upgraders, HashSet<string> shaderNamesToIgnore, string progressBarName, UpgradeFlags flags = None);
        public static void Upgrade(Material material, MaterialUpgrader upgrader, UpgradeFlags flags);
        public static void Upgrade(Material material, List<MaterialUpgrader> upgraders, UpgradeFlags flags);
        public static void UpgradeSelection(List<MaterialUpgrader> upgraders, string progressBarName, UpgradeFlags flags = None);
        public static void UpgradeSelection(List<MaterialUpgrader> upgraders, HashSet<string> shaderNamesToIgnore, string progressBarName, UpgradeFlags flags = None);

        public delegate void MaterialFinalizer(Material mat);
        [Flags]
        public enum UpgradeFlags
        {
            None = 0,
            LogErrorOnNonExistingProperty = 1,
            CleanupNonUpgradedProperties = 2,
            LogMessageWhenNoUpgraderFound = 4
        }
    }
}
using System;
using System.Linq.Expressions;

namespace UnityEditor.Rendering
{
    public sealed class PropertyFetcher<T> : IDisposable
    {
        public readonly SerializedObject obj;

        public PropertyFetcher(SerializedObject obj);

        public SerializedProperty Find(string str);
        public SerializedProperty Find<TValue>(Expression<Func<T, TValue>> expr);
        public void Dispose();
    }
}
using System;
using System.Linq.Expressions;

namespace UnityEditor.Rendering
{
    public sealed class RelativePropertyFetcher<T> : IDisposable
    {
        public readonly SerializedProperty obj;

        public RelativePropertyFetcher(SerializedProperty obj);

        public SerializedProperty Find(string str);
        public SerializedProperty Find<TValue>(Expression<Func<T, TValue>> expr);
        public void Dispose();
    }
}
using System;
using System.Linq.Expressions;

namespace UnityEditor.Rendering
{
    public static class PropertyFetcherExtensions
    {
        public static SerializedProperty Find<TSource, TValue>(this SerializedObject obj, Expression<Func<TSource, TValue>> expr);
        public static SerializedProperty Find<TSource, TValue>(this SerializedProperty obj, Expression<Func<TSource, TValue>> expr);
    }
}
using UnityEngine;

namespace UnityEditor.Rendering
{
    public class SpeedTree8MaterialUpgrader : MaterialUpgrader
    {
        public SpeedTree8MaterialUpgrader(string sourceShaderName, string destShaderName, MaterialUpgrader.MaterialFinalizer finalizer = null);

        public static void PostprocessSpeedTree8Materials(GameObject speedtree, SpeedTreeImporter stImporter, MaterialUpgrader.MaterialFinalizer finalizer = null);
        public static void SpeedTree8MaterialFinalizer(Material material);
    }
}
namespace UnityEditor.Rendering
{
    public static class SerializedBitArrayUtilities
    {
        public static SerializedBitArray8 ToSerializeBitArray8(this SerializedProperty serializedProperty);
        public static bool TryGetSerializeBitArray8(this SerializedProperty serializedProperty, out SerializedBitArray8 serializedBitArray);
        public static SerializedBitArray16 ToSerializeBitArray16(this SerializedProperty serializedProperty);
        public static bool TryGetSerializeBitArray16(this SerializedProperty serializedProperty, out SerializedBitArray16 serializedBitArray);
        public static SerializedBitArray32 ToSerializeBitArray32(this SerializedProperty serializedProperty);
        public static bool TryGetSerializeBitArray32(this SerializedProperty serializedProperty, out SerializedBitArray32 serializedBitArray);
        public static SerializedBitArray64 ToSerializeBitArray64(this SerializedProperty serializedProperty);
        public static bool TryGetSerializeBitArray64(this SerializedProperty serializedProperty, out SerializedBitArray64 serializedBitArray);
        public static SerializedBitArray128 ToSerializeBitArray128(this SerializedProperty serializedProperty);
        public static bool TryGetSerializeBitArray128(this SerializedProperty serializedProperty, out SerializedBitArray128 serializedBitArray);
        public static SerializedBitArray256 ToSerializeBitArray256(this SerializedProperty serializedProperty);
        public static bool TryGetSerializeBitArray256(this SerializedProperty serializedProperty, out SerializedBitArray256 serializedBitArray);
    }
}
namespace UnityEditor.Rendering
{
    public interface ISerializedBitArray
    {
        uint capacity { get; }

        bool GetBitAt(uint bitIndex);
        void SetBitAt(uint bitIndex, bool value);
        bool HasBitMultipleDifferentValue(uint bitIndex);
    }
}
using System;

namespace UnityEditor.Rendering
{
    public abstract class SerializedBitArray : ISerializedBitArray
    {
        protected static Action<SerializedProperty, int, bool> SetBitAtIndexForAllTargetsImmediate;
        protected static Func<SerializedProperty, int> HasMultipleDifferentValuesBitwise;
        protected SerializedProperty m_SerializedProperty;

        public uint capacity { get; }

        protected SerializedProperty[] GetOrInitializeSerializedProperties();
        public bool HasBitMultipleDifferentValue(uint bitIndex);
        protected abstract bool HasBitMultipleDifferentValue_Internal(uint bitIndex);
        protected bool HasBitMultipleDifferentValue_For64Bits(string propertyPath, SerializedProperty serializedProperty, uint bitIndex);
        public bool GetBitAt(uint bitIndex);
        protected abstract bool GetBitAt_Internal(uint bitIndex);
        public void SetBitAt(uint bitIndex, bool value);
        protected abstract void SetBitAt_Internal(uint bitIndex, bool value);
        protected void ResyncSerialization();
        public void Update();
    }
}
namespace UnityEditor.Rendering
{
    public sealed class SerializedBitArray8 : SerializedBitArray
    {
        public SerializedBitArray8(SerializedProperty serializedProperty);

        protected override bool HasBitMultipleDifferentValue_Internal(uint bitIndex);
        protected override bool GetBitAt_Internal(uint bitIndex);
        protected override void SetBitAt_Internal(uint bitIndex, bool value);
    }
}
namespace UnityEditor.Rendering
{
    public sealed class SerializedBitArray16 : SerializedBitArray
    {
        public SerializedBitArray16(SerializedProperty serializedProperty);

        protected override bool HasBitMultipleDifferentValue_Internal(uint bitIndex);
        protected override bool GetBitAt_Internal(uint bitIndex);
        protected override void SetBitAt_Internal(uint bitIndex, bool value);
    }
}
namespace UnityEditor.Rendering
{
    public sealed class SerializedBitArray32 : SerializedBitArray
    {
        public SerializedBitArray32(SerializedProperty serializedProperty);

        protected override bool HasBitMultipleDifferentValue_Internal(uint bitIndex);
        protected override bool GetBitAt_Internal(uint bitIndex);
        protected override void SetBitAt_Internal(uint bitIndex, bool value);
    }
}
namespace UnityEditor.Rendering
{
    public sealed class SerializedBitArray64 : SerializedBitArray
    {
        public SerializedBitArray64(SerializedProperty serializedProperty);

        protected override bool HasBitMultipleDifferentValue_Internal(uint bitIndex);
        protected override bool GetBitAt_Internal(uint bitIndex);
        protected override void SetBitAt_Internal(uint bitIndex, bool value);
    }
}
namespace UnityEditor.Rendering
{
    public sealed class SerializedBitArray128 : SerializedBitArray
    {
        public SerializedBitArray128(SerializedProperty serializedProperty);

        protected override bool HasBitMultipleDifferentValue_Internal(uint bitIndex);
        protected override bool GetBitAt_Internal(uint bitIndex);
        protected override void SetBitAt_Internal(uint bitIndex, bool value);
    }
}
namespace UnityEditor.Rendering
{
    public sealed class SerializedBitArray256 : SerializedBitArray
    {
        public SerializedBitArray256(SerializedProperty serializedProperty);

        protected override bool HasBitMultipleDifferentValue_Internal(uint bitIndex);
        protected override bool GetBitAt_Internal(uint bitIndex);
        protected override void SetBitAt_Internal(uint bitIndex, bool value);
    }
}
using System;

namespace UnityEditor.Rendering
{
    public sealed class SerializedDataParameter
    {
        public SerializedProperty overrideState { get; }
        public SerializedProperty value { get; }
        public Attribute[] attributes { get; }
        public Type referenceType { get; }
        public string displayName { get; }

        public T GetAttribute<T>() where T : Attribute;
        public T GetObjectRef<T>();
    }
}
using System;

namespace UnityEditor.Rendering
{
    [AttributeUsage(Class, AllowMultiple = False)]
    public sealed class VolumeComponentEditorAttribute : Attribute
    {
        public readonly Type componentType;

        public VolumeComponentEditorAttribute(Type componentType);
    }
}
using UnityEngine;
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    public class VolumeComponentEditor
    {
        protected Editor m_Inspector;

        public VolumeComponentEditor();

        public VolumeComponent target { get; }
        public SerializedObject serializedObject { get; }
        public SerializedProperty baseProperty { get; }
        public SerializedProperty activeProperty { get; }
        public virtual bool hasAdvancedMode { get; }
        public bool isInAdvancedMode { get; }

        public void Repaint();
        public virtual void OnEnable();
        public virtual void OnDisable();
        public virtual void OnInspectorGUI();
        public virtual string GetDisplayTitle();
        protected SerializedDataParameter Unpack(SerializedProperty property);
        protected void PropertyField(SerializedDataParameter property);
        protected void PropertyField(SerializedDataParameter property, GUIContent title);
        protected void DrawOverrideCheckbox(SerializedDataParameter property);
    }
}
using UnityEngine.Rendering;

namespace UnityEditor.Rendering
{
    public sealed class VolumeComponentListEditor
    {
        public VolumeComponentListEditor(Editor editor);

        public VolumeProfile asset { get; }

        public void Init(VolumeProfile asset, SerializedObject serializedObject);
        public void Clear();
        public void OnGUI();
    }
}
using System;

namespace UnityEditor.Rendering
{
    [AttributeUsage(Class, AllowMultiple = False)]
    public sealed class VolumeParameterDrawerAttribute : Attribute
    {
        public readonly Type parameterType;

        public VolumeParameterDrawerAttribute(Type parameterType);
    }
}
using UnityEngine;

namespace UnityEditor.Rendering
{
    public abstract class VolumeParameterDrawer
    {
        protected VolumeParameterDrawer();

        public virtual bool IsAutoProperty();
        public abstract bool OnGUI(SerializedDataParameter parameter, GUIContent title);
    }
}
using UnityEngine.Rendering;
using UnityEngine.SceneManagement;

namespace UnityEditor.Rendering
{
    public static class VolumeProfileFactory
    {
        public static VolumeProfile CreateVolumeProfileAtPath(string path);
        public static VolumeProfile CreateVolumeProfile(Scene scene, string targetName);
        public static T CreateVolumeComponent<T>(VolumeProfile profile, bool overrides = False, bool saveAsset = True) where T : VolumeComponent;
    }
}
using UnityEngine.Rendering;

namespace UnityEditor.Rendering.Utilities
{
    public static class EditorMaterialQualityUtilities
    {
        public static MaterialQuality GetMaterialQuality(this ShaderKeywordSet keywordSet);
    }
}
using UnityEngine;

namespace UnityEditor.Rendering.LookDev
{
    public interface ICameraUpdater
    {
        void UpdateCamera(Camera camera);
    }
}
using UnityEngine;

namespace UnityEditor.Rendering.LookDev
{
    public class CameraState : ICameraUpdater
    {
        public CameraState();

        public Vector3 pivot { get; set; }
        public Quaternion rotation { get; set; }
        public float viewSize { get; set; }
        public float distanceFromPivot { get; }
        public Vector3 position { get; }
        public float fieldOfView { get; }
        public float farClip { get; }
        public float nearClip { get; }
        public Vector3 forward { get; }
        public Vector3 up { get; }
        public Vector3 right { get; }

        public void UpdateCamera(Camera camera);
        public void Reset();
    }
}
using UnityEngine;

namespace UnityEditor.Rendering.LookDev
{
    public class ComparisonGizmoState
    {
        public ComparisonGizmoState();

        public Vector2 point1 { get; }
        public Vector2 point2 { get; }
        public Vector2 center { get; }
        public float angle { get; }
        public float length { get; }
        public float blendFactor { get; set; }

        public void Update(Vector2 point1, Vector2 point2);
        public void Update(Vector2 center, float length, float angle);
    }
}
namespace UnityEditor.Rendering.LookDev
{
    public enum ViewIndex
    {
        First = 0,
        Second = 1
    }
}
namespace UnityEditor.Rendering.LookDev
{
    public enum ViewCompositionIndex
    {
        First = 0,
        Second = 1,
        Composite = 2
    }
}
namespace UnityEditor.Rendering.LookDev
{
    public enum Layout
    {
        FullFirstView = 0,
        FullSecondView = 1,
        HorizontalSplit = 2,
        VerticalSplit = 3,
        CustomSplit = 4
    }
}
namespace UnityEditor.Rendering.LookDev
{
    public enum SidePanel
    {
        None = -1,
        Environment = 0,
        Debug = 1
    }
}
namespace UnityEditor.Rendering.LookDev
{
    public enum TargetDebugView
    {
        First = 0,
        Both = 1,
        Second = 2
    }
}
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace UnityEditor.Rendering.LookDev
{
    public class Context : ScriptableObject, IDisposable
    {
        public Context();

        public EnvironmentLibrary environmentLibrary { get; }
        public LayoutContext layout { get; }
        public bool cameraSynced { get; set; }
        public ViewIterator viewContexts { get; }

        public ViewContext GetViewContent(ViewIndex index);
        public void UpdateEnvironmentLibrary(EnvironmentLibrary library);
        public void SynchronizeCameraStates(ViewIndex baseCameraState);
        public void SetFocusedCamera(ViewIndex index);

        public struct ViewIterator : IEnumerable, IEnumerable<ViewContext>
        {
        }
    }
}
namespace UnityEditor.Rendering.LookDev
{
    public class LayoutContext
    {
        public Layout viewLayout;
        public ViewIndex lastFocusedView;
        public SidePanel showedSidePanel;
        public TargetDebugView debugPanelSource;

        public LayoutContext();
    }
}
using UnityEngine;

namespace UnityEditor.Rendering.LookDev
{
    public class ViewContext
    {
        public ViewContext();

        public CameraState camera { get; }
        public DebugContext debug { get; }
        public bool hasEnvironment { get; }
        public Environment environment { get; }
        public bool hasViewedObject { get; }
        public GameObject viewedObjectReference { get; }
        public GameObject viewedInstanceInPreview { get; }

        public void UpdateEnvironment(Object environmentOrCubemapAsset);
        public void UpdateViewedObject(GameObject viewedObject);
        public void ResetCameraState();
    }
}
namespace UnityEditor.Rendering.LookDev
{
    public class DebugContext
    {
        public bool shadow;
        public int viewMode;

        public DebugContext();
    }
}
using System;

namespace UnityEditor.Rendering.LookDev
{
    public interface IEnvironmentDisplayer
    {
        event Action<EnvironmentLibrary> OnChangingEnvironmentLibrary;

        void Repaint();
    }
}
using System;
using UnityEngine;
using UnityEngine.UIElements;

namespace UnityEditor.Rendering.LookDev
{
    public interface IViewDisplayer
    {
        event Action<Layout, SidePanel> OnLayoutChanged;
        event Action OnRenderDocAcquisitionTriggered;
        event Action<IMouseEvent> OnMouseEventInView;
        event Action<GameObject, ViewCompositionIndex, Vector2> OnChangingObjectInView;
        event Action<UnityEngine.Object, ViewCompositionIndex, Vector2> OnChangingEnvironmentInView;
        event Action OnClosed;
        event Action OnUpdateRequested;

        Rect GetRect(ViewCompositionIndex index);
        void SetTexture(ViewCompositionIndex index, Texture texture);
        void Repaint();
    }
}
using UnityEngine;
using UnityEngine.Rendering.LookDev;

namespace UnityEditor.Rendering.LookDev
{
    public class Environment : ScriptableObject
    {
        public float rotation;
        public float exposure;
        public Color shadowColor;

        public Environment();

        public Cubemap cubemap { get; set; }
        public float sunLatitude { get; set; }
        public float sunLongitude { get; set; }
        public Sky sky { get; }

        public void ResetToBrightestSpot();
    }
}
using System.Reflection;
using UnityEngine;

namespace UnityEditor.Rendering.LookDev
{
    [DefaultMember("Item")]
    [HelpURL("https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@10.10/manual/Environment-Library.html")]
    public class EnvironmentLibrary : ScriptableObject
    {
        public EnvironmentLibrary();

        public Environment this[int index] { get; }
        public int Count { get; }

        public Environment Add();
        public void Remove(int index);
        public Environment Duplicate(int fromIndex);
        public int IndexOf(Environment environment);
    }
}
namespace UnityEditor.Rendering.LookDev
{
    public static class LookDev
    {
        public static bool open { get; }
        public static bool supported { get; }

        public static void ResetConfig();
        public static void Open();
        public static void Close();
    }
}
using UnityEngine;

namespace UnityEditor.Rendering.LookDev
{
    public static class RectExtension
    {
        public static bool IsNullOrInverted(this Rect r);
    }
}
-------- {Unity.Recorder(D:\Documents\GitHub\Rogue-like-game-i-guess\The game is liar\Library\ScriptAssemblies\Unity.Recorder.dll)}:    2 --------
namespace UnityEngine.Recorder
{
    [ExecuteInEditMode]
    public class RecorderBindings : MonoBehaviour
    {
        public RecorderBindings();

        public void SetBindingValue(string id, Object value);
        public Object GetBindingValue(string id);
        public bool HasBindingValue(string id);
        public void RemoveBinding(string id);
        public bool IsEmpty();
        public void DuplicateBinding(string src, string dst);
    }
}
-------- {Unity.Cecil(D:\Programs\2020.3.38f1\Editor\Data\Managed\Unity.Cecil.dll)}:  340 --------
using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;

namespace Mono.Collections.Generic
{
    [DefaultMember("Item")]
    public class Collection<T> : IEnumerable, IList<T>, IList, ICollection<T>, ICollection, IEnumerable<T>
    {
        public Collection();
        public Collection(int capacity);
        public Collection(ICollection<T> items);

        public T this[int index] { get; set; }
        public int Count { get; }
        public int Capacity { get; set; }

        public void Add(T item);
        public bool Contains(T item);
        public int IndexOf(T item);
        public void Insert(int index, T item);
        public void RemoveAt(int index);
        public bool Remove(T item);
        public void Clear();
        public void CopyTo(T[] array, int arrayIndex);
        public T[] ToArray();
        protected virtual void OnAdd(T item, int index);
        protected virtual void OnInsert(T item, int index);
        protected virtual void OnSet(T item, int index);
        protected virtual void OnRemove(T item, int index);
        protected virtual void OnClear();
        protected void Resize(int new_size);
        public Enumerator GetEnumerator();

        public struct Enumerator : IEnumerator<T>, IEnumerator, IDisposable
        {
            public T Current { get; }

            public bool MoveNext();
            public void Reset();
            public void Dispose();
        }
    }
}
namespace Mono.Collections.Generic
{
    public sealed class ReadOnlyCollection<T> : Collection<T>
    {
        public ReadOnlyCollection(T[] array);
        public ReadOnlyCollection(Collection<T> collection);

        public static ReadOnlyCollection<T> Empty { get; }

        protected override void OnAdd(T item, int index);
        protected override void OnClear();
        protected override void OnInsert(T item, int index);
        protected override void OnRemove(T item, int index);
        protected override void OnSet(T item, int index);
    }
}
namespace Mono.Cecil
{
    public struct ArrayDimension
    {
        public ArrayDimension(int? lowerBound, int? upperBound);

        public int? LowerBound { get; set; }
        public int? UpperBound { get; set; }
        public bool IsSized { get; }

        public override string ToString();
    }
}
using Mono.Collections.Generic;

namespace Mono.Cecil
{
    public sealed class ArrayType : TypeSpecification
    {
        public ArrayType(TypeReference type);
        public ArrayType(TypeReference type, int rank);

        public Collection<ArrayDimension> Dimensions { get; }
        public int Rank { get; }
        public bool IsVector { get; }
        public override bool IsValueType { get; set; }
        public override string Name { get; }
        public override string FullName { get; }
        public override bool IsArray { get; }
    }
}
using Mono.Collections.Generic;
using System;
using System.IO;

namespace Mono.Cecil
{
    public sealed class AssemblyDefinition : IMetadataTokenProvider, ICustomAttributeProvider, IDisposable, ISecurityDeclarationProvider
    {
        public AssemblyNameDefinition Name { get; set; }
        public string FullName { get; }
        public MetadataToken MetadataToken { get; set; }
        public Collection<ModuleDefinition> Modules { get; }
        public ModuleDefinition MainModule { get; }
        public MethodDefinition EntryPoint { get; set; }
        public bool HasCustomAttributes { get; }
        public Collection<CustomAttribute> CustomAttributes { get; }
        public bool HasSecurityDeclarations { get; }
        public Collection<SecurityDeclaration> SecurityDeclarations { get; }

        public void Dispose();
        public static AssemblyDefinition CreateAssembly(AssemblyNameDefinition assemblyName, string moduleName, ModuleKind kind);
        public static AssemblyDefinition CreateAssembly(AssemblyNameDefinition assemblyName, string moduleName, ModuleParameters parameters);
        public static AssemblyDefinition ReadAssembly(string fileName);
        public static AssemblyDefinition ReadAssembly(string fileName, ReaderParameters parameters);
        public static AssemblyDefinition ReadAssembly(Stream stream);
        public static AssemblyDefinition ReadAssembly(Stream stream, ReaderParameters parameters);
        public void Write(string fileName);
        public void Write(string fileName, WriterParameters parameters);
        public void Write();
        public void Write(WriterParameters parameters);
        public void Write(Stream stream);
        public void Write(Stream stream, WriterParameters parameters);
        public override string ToString();
    }
}
using System;

namespace Mono.Cecil
{
    [Flags]
    public enum AssemblyAttributes
    {
        PublicKey = 1,
        SideBySideCompatible = 0,
        Retargetable = 256,
        WindowsRuntime = 512,
        DisableJITCompileOptimizer = 16384,
        EnableJITCompileTracking = 32768
    }
}
namespace Mono.Cecil
{
    public enum AssemblyHashAlgorithm
    {
        None = 0,
        Reserved = 32771,
        SHA1 = 32772
    }
}
namespace Mono.Cecil
{
    public sealed class AssemblyLinkedResource : Resource
    {
        public AssemblyLinkedResource(string name, ManifestResourceAttributes flags);
        public AssemblyLinkedResource(string name, ManifestResourceAttributes flags, AssemblyNameReference reference);

        public AssemblyNameReference Assembly { get; set; }
        public override ResourceType ResourceType { get; }
    }
}
using System;

namespace Mono.Cecil
{
    public sealed class AssemblyNameDefinition : AssemblyNameReference
    {
        public AssemblyNameDefinition(string name, Version version);

        public override byte[] Hash { get; }
    }
}
using System;

namespace Mono.Cecil
{
    public class AssemblyNameReference : IMetadataScope, IMetadataTokenProvider
    {
        public AssemblyNameReference(string name, Version version);

        public string Name { get; set; }
        public string Culture { get; set; }
        public Version Version { get; set; }
        public AssemblyAttributes Attributes { get; set; }
        public bool HasPublicKey { get; set; }
        public bool IsSideBySideCompatible { get; set; }
        public bool IsRetargetable { get; set; }
        public bool IsWindowsRuntime { get; set; }
        public byte[] PublicKey { get; set; }
        public byte[] PublicKeyToken { get; set; }
        public virtual MetadataScopeType MetadataScopeType { get; }
        public string FullName { get; }
        public AssemblyHashAlgorithm HashAlgorithm { get; set; }
        public virtual byte[] Hash { get; set; }
        public MetadataToken MetadataToken { get; set; }

        public static AssemblyNameReference Parse(string fullName);
        public override string ToString();
    }
}
namespace Mono.Cecil
{
    public delegate AssemblyDefinition AssemblyResolveEventHandler(object sender, AssemblyNameReference reference);
}
using System;

namespace Mono.Cecil
{
    public sealed class AssemblyResolveEventArgs : EventArgs
    {
        public AssemblyResolveEventArgs(AssemblyNameReference reference);

        public AssemblyNameReference AssemblyReference { get; }
    }
}
using System;
using System.IO;

namespace Mono.Cecil
{
    public sealed class AssemblyResolutionException : FileNotFoundException
    {
        public AssemblyResolutionException(AssemblyNameReference reference);
        public AssemblyResolutionException(AssemblyNameReference reference, Exception innerException);

        public AssemblyNameReference AssemblyReference { get; }
    }
}
using System;

namespace Mono.Cecil
{
    public abstract class BaseAssemblyResolver : IDisposable, IAssemblyResolver
    {
        protected BaseAssemblyResolver();

        public event AssemblyResolveEventHandler ResolveFailure;

        public void AddSearchDirectory(string directory);
        public void RemoveSearchDirectory(string directory);
        public string[] GetSearchDirectories();
        public virtual AssemblyDefinition Resolve(AssemblyNameReference name);
        public virtual AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters);
        public void Dispose();
        protected virtual void Dispose(bool disposing);
    }
}
using Mono.Collections.Generic;

namespace Mono.Cecil
{
    public sealed class CallSite : IMetadataTokenProvider, IMethodSignature
    {
        public CallSite(TypeReference returnType);

        public bool HasThis { get; set; }
        public bool ExplicitThis { get; set; }
        public MethodCallingConvention CallingConvention { get; set; }
        public bool HasParameters { get; }
        public Collection<ParameterDefinition> Parameters { get; }
        public TypeReference ReturnType { get; set; }
        public MethodReturnType MethodReturnType { get; }
        public string Name { get; set; }
        public string Namespace { get; set; }
        public ModuleDefinition Module { get; }
        public IMetadataScope Scope { get; }
        public MetadataToken MetadataToken { get; set; }
        public string FullName { get; }

        public override string ToString();
    }
}
namespace Mono.Cecil
{
    public struct CustomAttributeArgument
    {
        public CustomAttributeArgument(TypeReference type, object value);

        public TypeReference Type { get; }
        public object Value { get; }
    }
}
namespace Mono.Cecil
{
    public struct CustomAttributeNamedArgument
    {
        public CustomAttributeNamedArgument(string name, CustomAttributeArgument argument);

        public string Name { get; }
        public CustomAttributeArgument Argument { get; }
    }
}
using Mono.Collections.Generic;

namespace Mono.Cecil
{
    public interface ICustomAttribute
    {
        TypeReference AttributeType { get; }
        bool HasFields { get; }
        bool HasProperties { get; }
        Collection<CustomAttributeNamedArgument> Fields { get; }
        Collection<CustomAttributeNamedArgument> Properties { get; }
    }
}
using Mono.Collections.Generic;
using System.Diagnostics;

namespace Mono.Cecil
{
    [DebuggerDisplay("{AttributeType}")]
    public sealed class CustomAttribute : ICustomAttribute
    {
        public CustomAttribute(MethodReference constructor);
        public CustomAttribute(MethodReference constructor, byte[] blob);

        public MethodReference Constructor { get; set; }
        public TypeReference AttributeType { get; }
        public bool IsResolved { get; }
        public bool HasConstructorArguments { get; }
        public Collection<CustomAttributeArgument> ConstructorArguments { get; }
        public bool HasFields { get; }
        public Collection<CustomAttributeNamedArgument> Fields { get; }
        public bool HasProperties { get; }
        public Collection<CustomAttributeNamedArgument> Properties { get; }

        public byte[] GetBlob();
    }
}
namespace Mono.Cecil
{
    public class DefaultAssemblyResolver : BaseAssemblyResolver
    {
        public DefaultAssemblyResolver();

        public override AssemblyDefinition Resolve(AssemblyNameReference name);
        protected void RegisterAssembly(AssemblyDefinition assembly);
        protected override void Dispose(bool disposing);
    }
}
using System.IO;

namespace Mono.Cecil
{
    public sealed class EmbeddedResource : Resource
    {
        public EmbeddedResource(string name, ManifestResourceAttributes attributes, byte[] data);
        public EmbeddedResource(string name, ManifestResourceAttributes attributes, Stream stream);

        public override ResourceType ResourceType { get; }

        public Stream GetResourceStream();
        public byte[] GetResourceData();
    }
}
using System;

namespace Mono.Cecil
{
    [Flags]
    public enum EventAttributes
    {
        None = 0,
        SpecialName = 512,
        RTSpecialName = 1024
    }
}
using Mono.Collections.Generic;

namespace Mono.Cecil
{
    public sealed class EventDefinition : EventReference, ICustomAttributeProvider, IMemberDefinition
    {
        public EventDefinition(string name, EventAttributes attributes, TypeReference eventType);

        public EventAttributes Attributes { get; set; }
        public MethodDefinition AddMethod { get; set; }
        public MethodDefinition InvokeMethod { get; set; }
        public MethodDefinition RemoveMethod { get; set; }
        public bool HasOtherMethods { get; }
        public Collection<MethodDefinition> OtherMethods { get; }
        public bool HasCustomAttributes { get; }
        public Collection<CustomAttribute> CustomAttributes { get; }
        public bool IsSpecialName { get; set; }
        public bool IsRuntimeSpecialName { get; set; }
        public TypeDefinition DeclaringType { get; set; }
        public override bool IsDefinition { get; }

        public override EventDefinition Resolve();
    }
}
namespace Mono.Cecil
{
    public abstract class EventReference : MemberReference
    {
        protected EventReference(string name, TypeReference eventType);

        public TypeReference EventType { get; set; }
        public override string FullName { get; }

        protected override IMemberDefinition ResolveDefinition();
        public abstract EventDefinition Resolve();
    }
}
namespace Mono.Cecil
{
    public sealed class ExportedType : IMetadataTokenProvider
    {
        public ExportedType(string namespace, string name, ModuleDefinition module, IMetadataScope scope);

        public string Namespace { get; set; }
        public string Name { get; set; }
        public TypeAttributes Attributes { get; set; }
        public IMetadataScope Scope { get; set; }
        public ExportedType DeclaringType { get; set; }
        public MetadataToken MetadataToken { get; set; }
        public int Identifier { get; set; }
        public bool IsNotPublic { get; set; }
        public bool IsPublic { get; set; }
        public bool IsNestedPublic { get; set; }
        public bool IsNestedPrivate { get; set; }
        public bool IsNestedFamily { get; set; }
        public bool IsNestedAssembly { get; set; }
        public bool IsNestedFamilyAndAssembly { get; set; }
        public bool IsNestedFamilyOrAssembly { get; set; }
        public bool IsAutoLayout { get; set; }
        public bool IsSequentialLayout { get; set; }
        public bool IsExplicitLayout { get; set; }
        public bool IsClass { get; set; }
        public bool IsInterface { get; set; }
        public bool IsAbstract { get; set; }
        public bool IsSealed { get; set; }
        public bool IsSpecialName { get; set; }
        public bool IsImport { get; set; }
        public bool IsSerializable { get; set; }
        public bool IsAnsiClass { get; set; }
        public bool IsUnicodeClass { get; set; }
        public bool IsAutoClass { get; set; }
        public bool IsBeforeFieldInit { get; set; }
        public bool IsRuntimeSpecialName { get; set; }
        public bool HasSecurity { get; set; }
        public bool IsForwarder { get; set; }
        public string FullName { get; }

        public override string ToString();
        public TypeDefinition Resolve();
    }
}
using System;

namespace Mono.Cecil
{
    [Flags]
    public enum FieldAttributes
    {
        FieldAccessMask = 7,
        CompilerControlled = 0,
        Private = 1,
        FamANDAssem = 2,
        Assembly = 3,
        Family = 4,
        FamORAssem = 5,
        Public = 6,
        Static = 16,
        InitOnly = 32,
        Literal = 64,
        NotSerialized = 128,
        SpecialName = 512,
        PInvokeImpl = 8192,
        RTSpecialName = 1024,
        HasFieldMarshal = 4096,
        HasDefault = 32768,
        HasFieldRVA = 256
    }
}
using Mono.Collections.Generic;

namespace Mono.Cecil
{
    public sealed class FieldDefinition : FieldReference, IConstantProvider, ICustomAttributeProvider, IMarshalInfoProvider, IMemberDefinition
    {
        public FieldDefinition(string name, FieldAttributes attributes, TypeReference fieldType);

        public bool HasLayoutInfo { get; }
        public int Offset { get; set; }
        public int RVA { get; }
        public byte[] InitialValue { get; set; }
        public FieldAttributes Attributes { get; set; }
        public bool HasConstant { get; set; }
        public object Constant { get; set; }
        public bool HasCustomAttributes { get; }
        public Collection<CustomAttribute> CustomAttributes { get; }
        public bool HasMarshalInfo { get; }
        public MarshalInfo MarshalInfo { get; set; }
        public bool IsCompilerControlled { get; set; }
        public bool IsPrivate { get; set; }
        public bool IsFamilyAndAssembly { get; set; }
        public bool IsAssembly { get; set; }
        public bool IsFamily { get; set; }
        public bool IsFamilyOrAssembly { get; set; }
        public bool IsPublic { get; set; }
        public bool IsStatic { get; set; }
        public bool IsInitOnly { get; set; }
        public bool IsLiteral { get; set; }
        public bool IsNotSerialized { get; set; }
        public bool IsSpecialName { get; set; }
        public bool IsPInvokeImpl { get; set; }
        public bool IsRuntimeSpecialName { get; set; }
        public bool HasDefault { get; set; }
        public override bool IsDefinition { get; }
        public TypeDefinition DeclaringType { get; set; }

        public override FieldDefinition Resolve();
    }
}
namespace Mono.Cecil
{
    public class FieldReference : MemberReference
    {
        public FieldReference(string name, TypeReference fieldType);
        public FieldReference(string name, TypeReference fieldType, TypeReference declaringType);

        public TypeReference FieldType { get; set; }
        public override string FullName { get; }
        public override bool ContainsGenericParameter { get; }

        protected override IMemberDefinition ResolveDefinition();
        public virtual FieldDefinition Resolve();
    }
}
using Mono.Collections.Generic;

namespace Mono.Cecil
{
    public sealed class FunctionPointerType : TypeSpecification, IMethodSignature
    {
        public FunctionPointerType();

        public bool HasThis { get; set; }
        public bool ExplicitThis { get; set; }
        public MethodCallingConvention CallingConvention { get; set; }
        public bool HasParameters { get; }
        public Collection<ParameterDefinition> Parameters { get; }
        public TypeReference ReturnType { get; set; }
        public MethodReturnType MethodReturnType { get; }
        public override string Name { get; set; }
        public override string Namespace { get; set; }
        public override ModuleDefinition Module { get; }
        public override IMetadataScope Scope { get; set; }
        public override bool IsFunctionPointer { get; }
        public override bool ContainsGenericParameter { get; }
        public override string FullName { get; }

        public override TypeDefinition Resolve();
        public override TypeReference GetElementType();
    }
}
using Mono.Collections.Generic;

namespace Mono.Cecil
{
    public sealed class GenericInstanceMethod : MethodSpecification, IGenericInstance
    {
        public GenericInstanceMethod(MethodReference method);

        public bool HasGenericArguments { get; }
        public Collection<TypeReference> GenericArguments { get; }
        public override bool IsGenericInstance { get; }
        public override bool ContainsGenericParameter { get; }
        public override string FullName { get; }
    }
}
using Mono.Collections.Generic;

namespace Mono.Cecil
{
    public sealed class GenericInstanceType : TypeSpecification, IGenericInstance
    {
        public GenericInstanceType(TypeReference type);

        public bool HasGenericArguments { get; }
        public Collection<TypeReference> GenericArguments { get; }
        public override TypeReference DeclaringType { get; set; }
        public override string FullName { get; }
        public override bool IsGenericInstance { get; }
        public override bool ContainsGenericParameter { get; }
    }
}
using Mono.Collections.Generic;

namespace Mono.Cecil
{
    public sealed class GenericParameter : TypeReference, ICustomAttributeProvider
    {
        public GenericParameter(IGenericParameterProvider owner);
        public GenericParameter(string name, IGenericParameterProvider owner);

        public GenericParameterAttributes Attributes { get; set; }
        public int Position { get; }
        public GenericParameterType Type { get; }
        public IGenericParameterProvider Owner { get; }
        public bool HasConstraints { get; }
        public Collection<GenericParameterConstraint> Constraints { get; }
        public bool HasCustomAttributes { get; }
        public Collection<CustomAttribute> CustomAttributes { get; }
        public override IMetadataScope Scope { get; set; }
        public override TypeReference DeclaringType { get; set; }
        public MethodReference DeclaringMethod { get; }
        public override ModuleDefinition Module { get; }
        public override string Name { get; }
        public override string Namespace { get; set; }
        public override string FullName { get; }
        public override bool IsGenericParameter { get; }
        public override bool ContainsGenericParameter { get; }
        public override MetadataType MetadataType { get; }
        public bool IsNonVariant { get; set; }
        public bool IsCovariant { get; set; }
        public bool IsContravariant { get; set; }
        public bool HasReferenceTypeConstraint { get; set; }
        public bool HasNotNullableValueTypeConstraint { get; set; }
        public bool HasDefaultConstructorConstraint { get; set; }

        public override TypeDefinition Resolve();
    }
}
using Mono.Collections.Generic;

namespace Mono.Cecil
{
    public sealed class GenericParameterConstraint : IMetadataTokenProvider, ICustomAttributeProvider
    {
        public GenericParameterConstraint(TypeReference constraintType);

        public TypeReference ConstraintType { get; set; }
        public bool HasCustomAttributes { get; }
        public Collection<CustomAttribute> CustomAttributes { get; }
        public MetadataToken MetadataToken { get; set; }
    }
}
using System;

namespace Mono.Cecil
{
    [Flags]
    public enum GenericParameterAttributes
    {
        VarianceMask = 3,
        NonVariant = 0,
        Covariant = 1,
        Contravariant = 2,
        SpecialConstraintMask = 28,
        ReferenceTypeConstraint = 4,
        NotNullableValueTypeConstraint = 8,
        DefaultConstructorConstraint = 16
    }
}
namespace Mono.Cecil
{
    public interface IConstantProvider : IMetadataTokenProvider
    {
        bool HasConstant { get; set; }
        object Constant { get; set; }
    }
}
using Mono.Collections.Generic;

namespace Mono.Cecil
{
    public interface ICustomAttributeProvider : IMetadataTokenProvider
    {
        Collection<CustomAttribute> CustomAttributes { get; }
        bool HasCustomAttributes { get; }
    }
}
using Mono.Collections.Generic;

namespace Mono.Cecil
{
    public interface IGenericInstance : IMetadataTokenProvider
    {
        bool HasGenericArguments { get; }
        Collection<TypeReference> GenericArguments { get; }
    }
}
using Mono.Collections.Generic;

namespace Mono.Cecil
{
    public interface IGenericParameterProvider : IMetadataTokenProvider
    {
        bool HasGenericParameters { get; }
        bool IsDefinition { get; }
        ModuleDefinition Module { get; }
        Collection<GenericParameter> GenericParameters { get; }
        GenericParameterType GenericParameterType { get; }
    }
}
namespace Mono.Cecil
{
    public enum GenericParameterType
    {
        Type = 0,
        Method = 1
    }
}
namespace Mono.Cecil
{
    public interface IMarshalInfoProvider : IMetadataTokenProvider
    {
        bool HasMarshalInfo { get; }
        MarshalInfo MarshalInfo { get; set; }
    }
}
namespace Mono.Cecil
{
    public interface IMemberDefinition : IMetadataTokenProvider, ICustomAttributeProvider
    {
        string Name { get; set; }
        string FullName { get; }
        bool IsSpecialName { get; set; }
        bool IsRuntimeSpecialName { get; set; }
        TypeDefinition DeclaringType { get; set; }
    }
}
namespace Mono.Cecil
{
    public enum MetadataScopeType
    {
        AssemblyNameReference = 0,
        ModuleReference = 1,
        ModuleDefinition = 2
    }
}
namespace Mono.Cecil
{
    public interface IMetadataScope : IMetadataTokenProvider
    {
        MetadataScopeType MetadataScopeType { get; }
        string Name { get; set; }
    }
}
namespace Mono.Cecil
{
    public interface IMetadataTokenProvider
    {
        MetadataToken MetadataToken { get; set; }
    }
}
using Mono.Collections.Generic;

namespace Mono.Cecil
{
    public interface IMethodSignature : IMetadataTokenProvider
    {
        bool HasThis { get; set; }
        bool ExplicitThis { get; set; }
        MethodCallingConvention CallingConvention { get; set; }
        bool HasParameters { get; }
        Collection<ParameterDefinition> Parameters { get; }
        TypeReference ReturnType { get; set; }
        MethodReturnType MethodReturnType { get; }
    }
}
namespace Mono.Cecil
{
    public interface IMetadataImporterProvider
    {
        IMetadataImporter GetMetadataImporter(ModuleDefinition module);
    }
}
namespace Mono.Cecil
{
    public interface IMetadataImporter
    {
        TypeReference ImportReference(TypeReference type, IGenericParameterProvider context);
        FieldReference ImportReference(FieldReference field, IGenericParameterProvider context);
        MethodReference ImportReference(MethodReference method, IGenericParameterProvider context);
    }
}
namespace Mono.Cecil
{
    public interface IReflectionImporterProvider
    {
        IReflectionImporter GetReflectionImporter(ModuleDefinition module);
    }
}
using System;
using System.Reflection;

namespace Mono.Cecil
{
    public interface IReflectionImporter
    {
        TypeReference ImportReference(Type type, IGenericParameterProvider context);
        FieldReference ImportReference(FieldInfo field, IGenericParameterProvider context);
        MethodReference ImportReference(MethodBase method, IGenericParameterProvider context);
    }
}
using System;
using System.Reflection;

namespace Mono.Cecil
{
    public class ReflectionImporter : IReflectionImporter
    {
        public ReflectionImporter(ModuleDefinition module);

        public virtual TypeReference ImportReference(Type type, IGenericParameterProvider context);
        public virtual FieldReference ImportReference(FieldInfo field, IGenericParameterProvider context);
        public virtual MethodReference ImportReference(MethodBase method, IGenericParameterProvider context);
    }
}
namespace Mono.Cecil
{
    public class MetadataImporter : IMetadataImporter
    {
        public MetadataImporter(ModuleDefinition module);

        public virtual TypeReference ImportReference(TypeReference type, IGenericParameterProvider context);
        public virtual FieldReference ImportReference(FieldReference field, IGenericParameterProvider context);
        public virtual MethodReference ImportReference(MethodReference method, IGenericParameterProvider context);
    }
}
namespace Mono.Cecil
{
    public sealed class LinkedResource : Resource
    {
        public LinkedResource(string name, ManifestResourceAttributes flags);
        public LinkedResource(string name, ManifestResourceAttributes flags, string file);

        public byte[] Hash { get; }
        public string File { get; set; }
        public override ResourceType ResourceType { get; }
    }
}
using System;

namespace Mono.Cecil
{
    [Flags]
    public enum ManifestResourceAttributes
    {
        VisibilityMask = 7,
        Public = 1,
        Private = 2
    }
}
namespace Mono.Cecil
{
    public class MarshalInfo
    {
        public MarshalInfo(NativeType native);

        public NativeType NativeType { get; set; }
    }
}
namespace Mono.Cecil
{
    public sealed class ArrayMarshalInfo : MarshalInfo
    {
        public ArrayMarshalInfo();

        public NativeType ElementType { get; set; }
        public int SizeParameterIndex { get; set; }
        public int Size { get; set; }
        public int SizeParameterMultiplier { get; set; }
    }
}
using System;

namespace Mono.Cecil
{
    public sealed class CustomMarshalInfo : MarshalInfo
    {
        public CustomMarshalInfo();

        public Guid Guid { get; set; }
        public string UnmanagedType { get; set; }
        public TypeReference ManagedType { get; set; }
        public string Cookie { get; set; }
    }
}
namespace Mono.Cecil
{
    public sealed class SafeArrayMarshalInfo : MarshalInfo
    {
        public SafeArrayMarshalInfo();

        public VariantType ElementType { get; set; }
    }
}
namespace Mono.Cecil
{
    public sealed class FixedArrayMarshalInfo : MarshalInfo
    {
        public FixedArrayMarshalInfo();

        public NativeType ElementType { get; set; }
        public int Size { get; set; }
    }
}
namespace Mono.Cecil
{
    public sealed class FixedSysStringMarshalInfo : MarshalInfo
    {
        public FixedSysStringMarshalInfo();

        public int Size { get; set; }
    }
}
namespace Mono.Cecil
{
    public abstract class MemberReference : IMetadataTokenProvider
    {
        public virtual string Name { get; set; }
        public abstract string FullName { get; }
        public virtual TypeReference DeclaringType { get; set; }
        public MetadataToken MetadataToken { get; set; }
        public bool IsWindowsRuntimeProjection { get; }
        public virtual ModuleDefinition Module { get; }
        public virtual bool IsDefinition { get; }
        public virtual bool ContainsGenericParameter { get; }

        public IMemberDefinition Resolve();
        protected abstract IMemberDefinition ResolveDefinition();
        public override string ToString();
    }
}
using System;

namespace Mono.Cecil
{
    public interface IAssemblyResolver : IDisposable
    {
        AssemblyDefinition Resolve(AssemblyNameReference name);
        AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters);
    }
}
namespace Mono.Cecil
{
    public interface IMetadataResolver
    {
        TypeDefinition Resolve(TypeReference type);
        FieldDefinition Resolve(FieldReference field);
        MethodDefinition Resolve(MethodReference method);
    }
}
using System;

namespace Mono.Cecil
{
    public sealed class ResolutionException : Exception
    {
        public ResolutionException(MemberReference member);

        public MemberReference Member { get; }
        public IMetadataScope Scope { get; }
    }
}
using Mono.Collections.Generic;

namespace Mono.Cecil
{
    public class MetadataResolver : IMetadataResolver
    {
        public MetadataResolver(IAssemblyResolver assemblyResolver);

        public IAssemblyResolver AssemblyResolver { get; }

        public virtual TypeDefinition Resolve(TypeReference type);
        public virtual FieldDefinition Resolve(FieldReference field);
        public virtual MethodDefinition Resolve(MethodReference method);
        public static MethodDefinition GetMethod(Collection<MethodDefinition> methods, MethodReference reference);
    }
}
using System;

namespace Mono.Cecil
{
    [Flags]
    public enum MethodAttributes
    {
        MemberAccessMask = 7,
        CompilerControlled = 0,
        Private = 1,
        FamANDAssem = 2,
        Assembly = 3,
        Family = 4,
        FamORAssem = 5,
        Public = 6,
        Static = 16,
        Final = 32,
        Virtual = 64,
        HideBySig = 128,
        VtableLayoutMask = 256,
        ReuseSlot = 0,
        NewSlot = 256,
        CheckAccessOnOverride = 512,
        Abstract = 1024,
        SpecialName = 2048,
        PInvokeImpl = 8192,
        UnmanagedExport = 8,
        RTSpecialName = 4096,
        HasSecurity = 16384,
        RequireSecObject = 32768
    }
}
namespace Mono.Cecil
{
    public enum MethodCallingConvention
    {
        Default = 0,
        C = 1,
        StdCall = 2,
        ThisCall = 3,
        FastCall = 4,
        VarArg = 5,
        Generic = 16
    }
}
using Mono.Cecil.Cil;
using Mono.Collections.Generic;

namespace Mono.Cecil
{
    public sealed class MethodDefinition : MethodReference, ICustomAttributeProvider, ICustomDebugInformationProvider, IMemberDefinition, ISecurityDeclarationProvider
    {
        public MethodDefinition(string name, MethodAttributes attributes, TypeReference returnType);

        public override string Name { get; set; }
        public MethodAttributes Attributes { get; set; }
        public MethodImplAttributes ImplAttributes { get; set; }
        public MethodSemanticsAttributes SemanticsAttributes { get; set; }
        public bool HasSecurityDeclarations { get; }
        public Collection<SecurityDeclaration> SecurityDeclarations { get; }
        public bool HasCustomAttributes { get; }
        public Collection<CustomAttribute> CustomAttributes { get; }
        public int RVA { get; }
        public bool HasBody { get; }
        public MethodBody Body { get; set; }
        public MethodDebugInformation DebugInformation { get; }
        public bool HasPInvokeInfo { get; }
        public PInvokeInfo PInvokeInfo { get; set; }
        public bool HasOverrides { get; }
        public Collection<MethodReference> Overrides { get; }
        public override bool HasGenericParameters { get; }
        public override Collection<GenericParameter> GenericParameters { get; }
        public bool HasCustomDebugInformations { get; }
        public Collection<CustomDebugInformation> CustomDebugInformations { get; }
        public bool IsCompilerControlled { get; set; }
        public bool IsPrivate { get; set; }
        public bool IsFamilyAndAssembly { get; set; }
        public bool IsAssembly { get; set; }
        public bool IsFamily { get; set; }
        public bool IsFamilyOrAssembly { get; set; }
        public bool IsPublic { get; set; }
        public bool IsStatic { get; set; }
        public bool IsFinal { get; set; }
        public bool IsVirtual { get; set; }
        public bool IsHideBySig { get; set; }
        public bool IsReuseSlot { get; set; }
        public bool IsNewSlot { get; set; }
        public bool IsCheckAccessOnOverride { get; set; }
        public bool IsAbstract { get; set; }
        public bool IsSpecialName { get; set; }
        public bool IsPInvokeImpl { get; set; }
        public bool IsUnmanagedExport { get; set; }
        public bool IsRuntimeSpecialName { get; set; }
        public bool HasSecurity { get; set; }
        public bool IsIL { get; set; }
        public bool IsNative { get; set; }
        public bool IsRuntime { get; set; }
        public bool IsUnmanaged { get; set; }
        public bool IsManaged { get; set; }
        public bool IsForwardRef { get; set; }
        public bool IsPreserveSig { get; set; }
        public bool IsInternalCall { get; set; }
        public bool IsSynchronized { get; set; }
        public bool NoInlining { get; set; }
        public bool NoOptimization { get; set; }
        public bool AggressiveInlining { get; set; }
        public bool IsSetter { get; set; }
        public bool IsGetter { get; set; }
        public bool IsOther { get; set; }
        public bool IsAddOn { get; set; }
        public bool IsRemoveOn { get; set; }
        public bool IsFire { get; set; }
        public TypeDefinition DeclaringType { get; set; }
        public bool IsConstructor { get; }
        public override bool IsDefinition { get; }

        public override MethodDefinition Resolve();
    }
}
using System;

namespace Mono.Cecil
{
    [Flags]
    public enum MethodImplAttributes
    {
        CodeTypeMask = 3,
        IL = 0,
        Native = 1,
        OPTIL = 2,
        Runtime = 3,
        ManagedMask = 4,
        Unmanaged = 4,
        Managed = 0,
        ForwardRef = 16,
        PreserveSig = 128,
        InternalCall = 4096,
        Synchronized = 32,
        NoOptimization = 64,
        NoInlining = 8,
        AggressiveInlining = 256
    }
}
using Mono.Collections.Generic;

namespace Mono.Cecil
{
    public class MethodReference : MemberReference, IMethodSignature, IGenericParameterProvider, IGenericContext
    {
        public MethodReference(string name, TypeReference returnType);
        public MethodReference(string name, TypeReference returnType, TypeReference declaringType);

        public virtual bool HasThis { get; set; }
        public virtual bool ExplicitThis { get; set; }
        public virtual MethodCallingConvention CallingConvention { get; set; }
        public virtual bool HasParameters { get; }
        public virtual Collection<ParameterDefinition> Parameters { get; }
        public virtual bool HasGenericParameters { get; }
        public virtual Collection<GenericParameter> GenericParameters { get; }
        public TypeReference ReturnType { get; set; }
        public virtual MethodReturnType MethodReturnType { get; set; }
        public override string FullName { get; }
        public virtual bool IsGenericInstance { get; }
        public override bool ContainsGenericParameter { get; }

        public virtual MethodReference GetElementMethod();
        protected override IMemberDefinition ResolveDefinition();
        public virtual MethodDefinition Resolve();
    }
}
using Mono.Collections.Generic;

namespace Mono.Cecil
{
    public sealed class MethodReturnType : IMetadataTokenProvider, IConstantProvider, ICustomAttributeProvider, IMarshalInfoProvider
    {
        public MethodReturnType(IMethodSignature method);

        public IMethodSignature Method { get; }
        public TypeReference ReturnType { get; set; }
        public MetadataToken MetadataToken { get; set; }
        public ParameterAttributes Attributes { get; set; }
        public string Name { get; set; }
        public bool HasCustomAttributes { get; }
        public Collection<CustomAttribute> CustomAttributes { get; }
        public bool HasDefault { get; set; }
        public bool HasConstant { get; set; }
        public object Constant { get; set; }
        public bool HasFieldMarshal { get; set; }
        public bool HasMarshalInfo { get; }
        public MarshalInfo MarshalInfo { get; set; }
    }
}
using System;

namespace Mono.Cecil
{
    [Flags]
    public enum MethodSemanticsAttributes
    {
        None = 0,
        Setter = 1,
        Getter = 2,
        Other = 4,
        AddOn = 8,
        RemoveOn = 16,
        Fire = 32
    }
}
using Mono.Collections.Generic;

namespace Mono.Cecil
{
    public abstract class MethodSpecification : MethodReference
    {
        public MethodReference ElementMethod { get; }
        public override string Name { get; set; }
        public override MethodCallingConvention CallingConvention { get; set; }
        public override bool HasThis { get; set; }
        public override bool ExplicitThis { get; set; }
        public override MethodReturnType MethodReturnType { get; set; }
        public override TypeReference DeclaringType { get; set; }
        public override ModuleDefinition Module { get; }
        public override bool HasParameters { get; }
        public override Collection<ParameterDefinition> Parameters { get; }
        public override bool ContainsGenericParameter { get; }

        public sealed override MethodReference GetElementMethod();
    }
}
namespace Mono.Cecil
{
    public interface IModifierType
    {
        TypeReference ModifierType { get; }
        TypeReference ElementType { get; }
    }
}
namespace Mono.Cecil
{
    public sealed class OptionalModifierType : TypeSpecification, IModifierType
    {
        public OptionalModifierType(TypeReference modifierType, TypeReference type);

        public TypeReference ModifierType { get; set; }
        public override string Name { get; }
        public override string FullName { get; }
        public override bool IsValueType { get; set; }
        public override bool IsOptionalModifier { get; }
        public override bool ContainsGenericParameter { get; }
    }
}
namespace Mono.Cecil
{
    public sealed class RequiredModifierType : TypeSpecification, IModifierType
    {
        public RequiredModifierType(TypeReference modifierType, TypeReference type);

        public TypeReference ModifierType { get; set; }
        public override string Name { get; }
        public override string FullName { get; }
        public override bool IsValueType { get; set; }
        public override bool IsRequiredModifier { get; }
        public override bool ContainsGenericParameter { get; }
    }
}
namespace Mono.Cecil
{
    public enum ReadingMode
    {
        Immediate = 1,
        Deferred = 2
    }
}
using Mono.Cecil.Cil;
using System.IO;

namespace Mono.Cecil
{
    public sealed class ReaderParameters
    {
        public ReaderParameters();
        public ReaderParameters(ReadingMode readingMode);

        public ReadingMode ReadingMode { get; set; }
        public bool InMemory { get; set; }
        public IAssemblyResolver AssemblyResolver { get; set; }
        public IMetadataResolver MetadataResolver { get; set; }
        public IMetadataImporterProvider MetadataImporterProvider { get; set; }
        public IReflectionImporterProvider ReflectionImporterProvider { get; set; }
        public Stream SymbolStream { get; set; }
        public ISymbolReaderProvider SymbolReaderProvider { get; set; }
        public bool ReadSymbols { get; set; }
        public bool ReadWrite { get; set; }
        public bool ApplyWindowsRuntimeProjections { get; set; }
    }
}
namespace Mono.Cecil
{
    public sealed class ModuleParameters
    {
        public ModuleParameters();

        public ModuleKind Kind { get; set; }
        public TargetRuntime Runtime { get; set; }
        public uint? Timestamp { get; set; }
        public TargetArchitecture Architecture { get; set; }
        public IAssemblyResolver AssemblyResolver { get; set; }
        public IMetadataResolver MetadataResolver { get; set; }
        public IMetadataImporterProvider MetadataImporterProvider { get; set; }
        public IReflectionImporterProvider ReflectionImporterProvider { get; set; }
    }
}
using Mono.Cecil.Cil;
using System.IO;
using System.Reflection;

namespace Mono.Cecil
{
    public sealed class WriterParameters
    {
        public WriterParameters();

        public uint? Timestamp { get; set; }
        public Stream SymbolStream { get; set; }
        public ISymbolWriterProvider SymbolWriterProvider { get; set; }
        public bool WriteSymbols { get; set; }
        public StrongNameKeyPair StrongNameKeyPair { get; set; }
        public bool DeterministicMvid { get; set; }
    }
}
using Mono.Cecil.Cil;
using Mono.Collections.Generic;
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;

namespace Mono.Cecil
{
    public sealed class ModuleDefinition : ModuleReference, ICustomAttributeProvider, IDisposable, ICustomDebugInformationProvider
    {
        public bool IsMain { get; }
        public ModuleKind Kind { get; set; }
        public MetadataKind MetadataKind { get; set; }
        public TargetRuntime Runtime { get; set; }
        public string RuntimeVersion { get; set; }
        public TargetArchitecture Architecture { get; set; }
        public ModuleAttributes Attributes { get; set; }
        public ModuleCharacteristics Characteristics { get; set; }
        [Obsolete("Use FileName")]
        public string FullyQualifiedName { get; }
        public string FileName { get; }
        public Guid Mvid { get; set; }
        public bool HasSymbols { get; }
        public ISymbolReader SymbolReader { get; }
        public override MetadataScopeType MetadataScopeType { get; }
        public AssemblyDefinition Assembly { get; }
        public IAssemblyResolver AssemblyResolver { get; }
        public IMetadataResolver MetadataResolver { get; }
        public TypeSystem TypeSystem { get; }
        public bool HasAssemblyReferences { get; }
        public Collection<AssemblyNameReference> AssemblyReferences { get; }
        public bool HasModuleReferences { get; }
        public Collection<ModuleReference> ModuleReferences { get; }
        public bool HasResources { get; }
        public Collection<Resource> Resources { get; }
        public bool HasCustomAttributes { get; }
        public Collection<CustomAttribute> CustomAttributes { get; }
        public bool HasTypes { get; }
        public Collection<TypeDefinition> Types { get; }
        public bool HasExportedTypes { get; }
        public Collection<ExportedType> ExportedTypes { get; }
        public MethodDefinition EntryPoint { get; set; }
        public bool HasCustomDebugInformations { get; }
        public Collection<CustomDebugInformation> CustomDebugInformations { get; }
        public bool HasDebugHeader { get; }

        public void Dispose();
        public bool HasTypeReference(string fullName);
        public bool HasTypeReference(string scope, string fullName);
        public bool TryGetTypeReference(string fullName, out TypeReference type);
        public bool TryGetTypeReference(string scope, string fullName, out TypeReference type);
        public IEnumerable<TypeReference> GetTypeReferences();
        public IEnumerable<MemberReference> GetMemberReferences();
        public IEnumerable<CustomAttribute> GetCustomAttributes();
        public TypeReference GetType(string fullName, bool runtimeName);
        public TypeDefinition GetType(string fullName);
        public TypeDefinition GetType(string namespace, string name);
        public IEnumerable<TypeDefinition> GetTypes();
        [Obsolete("Use ImportReference", False)]
        public TypeReference Import(Type type);
        public TypeReference ImportReference(Type type);
        [Obsolete("Use ImportReference", False)]
        public TypeReference Import(Type type, IGenericParameterProvider context);
        public TypeReference ImportReference(Type type, IGenericParameterProvider context);
        [Obsolete("Use ImportReference", False)]
        public FieldReference Import(FieldInfo field);
        [Obsolete("Use ImportReference", False)]
        public FieldReference Import(FieldInfo field, IGenericParameterProvider context);
        public FieldReference ImportReference(FieldInfo field);
        public FieldReference ImportReference(FieldInfo field, IGenericParameterProvider context);
        [Obsolete("Use ImportReference", False)]
        public MethodReference Import(MethodBase method);
        [Obsolete("Use ImportReference", False)]
        public MethodReference Import(MethodBase method, IGenericParameterProvider context);
        public MethodReference ImportReference(MethodBase method);
        public MethodReference ImportReference(MethodBase method, IGenericParameterProvider context);
        [Obsolete("Use ImportReference", False)]
        public TypeReference Import(TypeReference type);
        [Obsolete("Use ImportReference", False)]
        public TypeReference Import(TypeReference type, IGenericParameterProvider context);
        public TypeReference ImportReference(TypeReference type);
        public TypeReference ImportReference(TypeReference type, IGenericParameterProvider context);
        [Obsolete("Use ImportReference", False)]
        public FieldReference Import(FieldReference field);
        [Obsolete("Use ImportReference", False)]
        public FieldReference Import(FieldReference field, IGenericParameterProvider context);
        public FieldReference ImportReference(FieldReference field);
        public FieldReference ImportReference(FieldReference field, IGenericParameterProvider context);
        [Obsolete("Use ImportReference", False)]
        public MethodReference Import(MethodReference method);
        [Obsolete("Use ImportReference", False)]
        public MethodReference Import(MethodReference method, IGenericParameterProvider context);
        public MethodReference ImportReference(MethodReference method);
        public MethodReference ImportReference(MethodReference method, IGenericParameterProvider context);
        public IMetadataTokenProvider LookupToken(int token);
        public IMetadataTokenProvider LookupToken(MetadataToken token);
        public ImageDebugHeader GetDebugHeader();
        public static ModuleDefinition CreateModule(string name, ModuleKind kind);
        public static ModuleDefinition CreateModule(string name, ModuleParameters parameters);
        public void ReadSymbols();
        public void ReadSymbols(ISymbolReader reader);
        public static ModuleDefinition ReadModule(string fileName);
        public static ModuleDefinition ReadModule(string fileName, ReaderParameters parameters);
        public static ModuleDefinition ReadModule(Stream stream);
        public static ModuleDefinition ReadModule(Stream stream, ReaderParameters parameters);
        public void Write(string fileName);
        public void Write(string fileName, WriterParameters parameters);
        public void Write();
        public void Write(WriterParameters parameters);
        public void Write(Stream stream);
        public void Write(Stream stream, WriterParameters parameters);
    }
}
namespace Mono.Cecil
{
    public enum ModuleKind
    {
        Dll = 0,
        Console = 1,
        Windows = 2,
        NetModule = 3
    }
}
namespace Mono.Cecil
{
    public enum MetadataKind
    {
        Ecma335 = 0,
        WindowsMetadata = 1,
        ManagedWindowsMetadata = 2
    }
}
namespace Mono.Cecil
{
    public enum TargetArchitecture
    {
        I386 = 332,
        AMD64 = 34404,
        IA64 = 512,
        ARM = 448,
        ARMv7 = 452,
        ARM64 = 43620
    }
}
using System;

namespace Mono.Cecil
{
    [Flags]
    public enum ModuleAttributes
    {
        ILOnly = 1,
        Required32Bit = 2,
        ILLibrary = 4,
        StrongNameSigned = 8,
        Preferred32Bit = 131072
    }
}
using System;

namespace Mono.Cecil
{
    [Flags]
    public enum ModuleCharacteristics
    {
        HighEntropyVA = 32,
        DynamicBase = 64,
        NoSEH = 1024,
        NXCompat = 256,
        AppContainer = 4096,
        TerminalServerAware = 32768
    }
}
namespace Mono.Cecil
{
    public class ModuleReference : IMetadataScope, IMetadataTokenProvider
    {
        public ModuleReference(string name);

        public string Name { get; set; }
        public virtual MetadataScopeType MetadataScopeType { get; }
        public MetadataToken MetadataToken { get; set; }

        public override string ToString();
    }
}
namespace Mono.Cecil
{
    public enum NativeType
    {
        None = 102,
        Boolean = 2,
        I1 = 3,
        U1 = 4,
        I2 = 5,
        U2 = 6,
        I4 = 7,
        U4 = 8,
        I8 = 9,
        U8 = 10,
        R4 = 11,
        R8 = 12,
        LPStr = 20,
        Int = 31,
        UInt = 32,
        Func = 38,
        Array = 42,
        Currency = 15,
        BStr = 19,
        LPWStr = 21,
        LPTStr = 22,
        FixedSysString = 23,
        IUnknown = 25,
        IDispatch = 26,
        Struct = 27,
        IntF = 28,
        SafeArray = 29,
        FixedArray = 30,
        ByValStr = 34,
        ANSIBStr = 35,
        TBStr = 36,
        VariantBool = 37,
        ASAny = 40,
        LPStruct = 43,
        CustomMarshaler = 44,
        Error = 45,
        Max = 80
    }
}
using System;

namespace Mono.Cecil
{
    [Flags]
    public enum ParameterAttributes
    {
        None = 0,
        In = 1,
        Out = 2,
        Lcid = 4,
        Retval = 8,
        Optional = 16,
        HasDefault = 4096,
        HasFieldMarshal = 8192,
        Unused = 53216
    }
}
using Mono.Collections.Generic;

namespace Mono.Cecil
{
    public sealed class ParameterDefinition : ParameterReference, IConstantProvider, ICustomAttributeProvider, IMarshalInfoProvider
    {
        public ParameterDefinition(TypeReference parameterType);
        public ParameterDefinition(string name, ParameterAttributes attributes, TypeReference parameterType);

        public ParameterAttributes Attributes { get; set; }
        public IMethodSignature Method { get; }
        public int Sequence { get; }
        public bool HasConstant { get; set; }
        public object Constant { get; set; }
        public bool HasCustomAttributes { get; }
        public Collection<CustomAttribute> CustomAttributes { get; }
        public bool HasMarshalInfo { get; }
        public MarshalInfo MarshalInfo { get; set; }
        public bool IsIn { get; set; }
        public bool IsOut { get; set; }
        public bool IsLcid { get; set; }
        public bool IsReturnValue { get; set; }
        public bool IsOptional { get; set; }
        public bool HasDefault { get; set; }
        public bool HasFieldMarshal { get; set; }

        public override ParameterDefinition Resolve();
    }
}
namespace Mono.Cecil
{
    public abstract class ParameterReference : IMetadataTokenProvider
    {
        protected TypeReference parameter_type;

        public string Name { get; set; }
        public int Index { get; }
        public TypeReference ParameterType { get; set; }
        public MetadataToken MetadataToken { get; set; }

        public override string ToString();
        public abstract ParameterDefinition Resolve();
    }
}
namespace Mono.Cecil
{
    public sealed class PinnedType : TypeSpecification
    {
        public PinnedType(TypeReference type);

        public override bool IsValueType { get; set; }
        public override bool IsPinned { get; }
    }
}
using System;

namespace Mono.Cecil
{
    [Flags]
    public enum PInvokeAttributes
    {
        NoMangle = 1,
        CharSetMask = 6,
        CharSetNotSpec = 0,
        CharSetAnsi = 2,
        CharSetUnicode = 4,
        CharSetAuto = 6,
        SupportsLastError = 64,
        CallConvMask = 1792,
        CallConvWinapi = 256,
        CallConvCdecl = 512,
        CallConvStdCall = 768,
        CallConvThiscall = 1024,
        CallConvFastcall = 1280,
        BestFitMask = 48,
        BestFitEnabled = 16,
        BestFitDisabled = 32,
        ThrowOnUnmappableCharMask = 12288,
        ThrowOnUnmappableCharEnabled = 4096,
        ThrowOnUnmappableCharDisabled = 8192
    }
}
namespace Mono.Cecil
{
    public sealed class PInvokeInfo
    {
        public PInvokeInfo(PInvokeAttributes attributes, string entryPoint, ModuleReference module);

        public PInvokeAttributes Attributes { get; set; }
        public string EntryPoint { get; set; }
        public ModuleReference Module { get; set; }
        public bool IsNoMangle { get; set; }
        public bool IsCharSetNotSpec { get; set; }
        public bool IsCharSetAnsi { get; set; }
        public bool IsCharSetUnicode { get; set; }
        public bool IsCharSetAuto { get; set; }
        public bool SupportsLastError { get; set; }
        public bool IsCallConvWinapi { get; set; }
        public bool IsCallConvCdecl { get; set; }
        public bool IsCallConvStdCall { get; set; }
        public bool IsCallConvThiscall { get; set; }
        public bool IsCallConvFastcall { get; set; }
        public bool IsBestFitEnabled { get; set; }
        public bool IsBestFitDisabled { get; set; }
        public bool IsThrowOnUnmappableCharEnabled { get; set; }
        public bool IsThrowOnUnmappableCharDisabled { get; set; }
    }
}
namespace Mono.Cecil
{
    public sealed class PointerType : TypeSpecification
    {
        public PointerType(TypeReference type);

        public override string Name { get; }
        public override string FullName { get; }
        public override bool IsValueType { get; set; }
        public override bool IsPointer { get; }
    }
}
using System;

namespace Mono.Cecil
{
    [Flags]
    public enum PropertyAttributes
    {
        None = 0,
        SpecialName = 512,
        RTSpecialName = 1024,
        HasDefault = 4096,
        Unused = 59903
    }
}
using Mono.Collections.Generic;

namespace Mono.Cecil
{
    public sealed class PropertyDefinition : PropertyReference, IConstantProvider, ICustomAttributeProvider, IMemberDefinition
    {
        public PropertyDefinition(string name, PropertyAttributes attributes, TypeReference propertyType);

        public PropertyAttributes Attributes { get; set; }
        public bool HasThis { get; set; }
        public bool HasCustomAttributes { get; }
        public Collection<CustomAttribute> CustomAttributes { get; }
        public MethodDefinition GetMethod { get; set; }
        public MethodDefinition SetMethod { get; set; }
        public bool HasOtherMethods { get; }
        public Collection<MethodDefinition> OtherMethods { get; }
        public bool HasParameters { get; }
        public override Collection<ParameterDefinition> Parameters { get; }
        public bool HasConstant { get; set; }
        public object Constant { get; set; }
        public bool IsSpecialName { get; set; }
        public bool IsRuntimeSpecialName { get; set; }
        public bool HasDefault { get; set; }
        public TypeDefinition DeclaringType { get; set; }
        public override bool IsDefinition { get; }
        public override string FullName { get; }

        public override PropertyDefinition Resolve();
    }
}
using Mono.Collections.Generic;

namespace Mono.Cecil
{
    public abstract class PropertyReference : MemberReference
    {
        public TypeReference PropertyType { get; set; }
        public abstract Collection<ParameterDefinition> Parameters { get; }

        protected override IMemberDefinition ResolveDefinition();
        public abstract PropertyDefinition Resolve();
    }
}
namespace Mono.Cecil
{
    public sealed class ByReferenceType : TypeSpecification
    {
        public ByReferenceType(TypeReference type);

        public override string Name { get; }
        public override string FullName { get; }
        public override bool IsValueType { get; set; }
        public override bool IsByReference { get; }
    }
}
namespace Mono.Cecil
{
    public enum ResourceType
    {
        Linked = 0,
        Embedded = 1,
        AssemblyLinked = 2
    }
}
namespace Mono.Cecil
{
    public abstract class Resource
    {
        public string Name { get; set; }
        public ManifestResourceAttributes Attributes { get; set; }
        public abstract ResourceType ResourceType { get; }
        public bool IsPublic { get; set; }
        public bool IsPrivate { get; set; }
    }
}
namespace Mono.Cecil
{
    public enum SecurityAction
    {
        Request = 1,
        Demand = 2,
        Assert = 3,
        Deny = 4,
        PermitOnly = 5,
        LinkDemand = 6,
        InheritDemand = 7,
        RequestMinimum = 8,
        RequestOptional = 9,
        RequestRefuse = 10,
        PreJitGrant = 11,
        PreJitDeny = 12,
        NonCasDemand = 13,
        NonCasLinkDemand = 14,
        NonCasInheritance = 15
    }
}
using Mono.Collections.Generic;

namespace Mono.Cecil
{
    public interface ISecurityDeclarationProvider : IMetadataTokenProvider
    {
        bool HasSecurityDeclarations { get; }
        Collection<SecurityDeclaration> SecurityDeclarations { get; }
    }
}
using Mono.Collections.Generic;
using System.Diagnostics;

namespace Mono.Cecil
{
    [DebuggerDisplay("{AttributeType}")]
    public sealed class SecurityAttribute : ICustomAttribute
    {
        public SecurityAttribute(TypeReference attributeType);

        public TypeReference AttributeType { get; set; }
        public bool HasFields { get; }
        public Collection<CustomAttributeNamedArgument> Fields { get; }
        public bool HasProperties { get; }
        public Collection<CustomAttributeNamedArgument> Properties { get; }
    }
}
using Mono.Collections.Generic;

namespace Mono.Cecil
{
    public sealed class SecurityDeclaration
    {
        public SecurityDeclaration(SecurityAction action);
        public SecurityDeclaration(SecurityAction action, byte[] blob);

        public SecurityAction Action { get; set; }
        public bool HasSecurityAttributes { get; }
        public Collection<SecurityAttribute> SecurityAttributes { get; }

        public byte[] GetBlob();
    }
}
namespace Mono.Cecil
{
    public sealed class SentinelType : TypeSpecification
    {
        public SentinelType(TypeReference type);

        public override bool IsValueType { get; set; }
        public override bool IsSentinel { get; }
    }
}
namespace Mono.Cecil
{
    public enum TargetRuntime
    {
        Net_1_0 = 0,
        Net_1_1 = 1,
        Net_2_0 = 2,
        Net_4_0 = 3
    }
}
using System;

namespace Mono.Cecil
{
    [Flags]
    public enum TypeAttributes
    {
        VisibilityMask = 7,
        NotPublic = 0,
        Public = 1,
        NestedPublic = 2,
        NestedPrivate = 3,
        NestedFamily = 4,
        NestedAssembly = 5,
        NestedFamANDAssem = 6,
        NestedFamORAssem = 7,
        LayoutMask = 24,
        AutoLayout = 0,
        SequentialLayout = 8,
        ExplicitLayout = 16,
        ClassSemanticMask = 32,
        Class = 0,
        Interface = 32,
        Abstract = 128,
        Sealed = 256,
        SpecialName = 1024,
        Import = 4096,
        Serializable = 8192,
        WindowsRuntime = 16384,
        StringFormatMask = 196608,
        AnsiClass = 0,
        UnicodeClass = 65536,
        AutoClass = 131072,
        BeforeFieldInit = 1048576,
        RTSpecialName = 2048,
        HasSecurity = 262144,
        Forwarder = 2097152
    }
}
using Mono.Collections.Generic;

namespace Mono.Cecil
{
    public sealed class TypeDefinition : TypeReference, ICustomAttributeProvider, IMemberDefinition, ISecurityDeclarationProvider
    {
        public TypeDefinition(string namespace, string name, TypeAttributes attributes);
        public TypeDefinition(string namespace, string name, TypeAttributes attributes, TypeReference baseType);

        public TypeAttributes Attributes { get; set; }
        public TypeReference BaseType { get; set; }
        public override string Name { get; set; }
        public bool HasLayoutInfo { get; }
        public short PackingSize { get; set; }
        public int ClassSize { get; set; }
        public bool HasInterfaces { get; }
        public Collection<InterfaceImplementation> Interfaces { get; }
        public bool HasNestedTypes { get; }
        public Collection<TypeDefinition> NestedTypes { get; }
        public bool HasMethods { get; }
        public Collection<MethodDefinition> Methods { get; }
        public bool HasFields { get; }
        public Collection<FieldDefinition> Fields { get; }
        public bool HasEvents { get; }
        public Collection<EventDefinition> Events { get; }
        public bool HasProperties { get; }
        public Collection<PropertyDefinition> Properties { get; }
        public bool HasSecurityDeclarations { get; }
        public Collection<SecurityDeclaration> SecurityDeclarations { get; }
        public bool HasCustomAttributes { get; }
        public Collection<CustomAttribute> CustomAttributes { get; }
        public override bool HasGenericParameters { get; }
        public override Collection<GenericParameter> GenericParameters { get; }
        public bool IsNotPublic { get; set; }
        public bool IsPublic { get; set; }
        public bool IsNestedPublic { get; set; }
        public bool IsNestedPrivate { get; set; }
        public bool IsNestedFamily { get; set; }
        public bool IsNestedAssembly { get; set; }
        public bool IsNestedFamilyAndAssembly { get; set; }
        public bool IsNestedFamilyOrAssembly { get; set; }
        public bool IsAutoLayout { get; set; }
        public bool IsSequentialLayout { get; set; }
        public bool IsExplicitLayout { get; set; }
        public bool IsClass { get; set; }
        public bool IsInterface { get; set; }
        public bool IsAbstract { get; set; }
        public bool IsSealed { get; set; }
        public bool IsSpecialName { get; set; }
        public bool IsImport { get; set; }
        public bool IsSerializable { get; set; }
        public bool IsWindowsRuntime { get; set; }
        public bool IsAnsiClass { get; set; }
        public bool IsUnicodeClass { get; set; }
        public bool IsAutoClass { get; set; }
        public bool IsBeforeFieldInit { get; set; }
        public bool IsRuntimeSpecialName { get; set; }
        public bool HasSecurity { get; set; }
        public bool IsEnum { get; }
        public override bool IsValueType { get; }
        public override bool IsPrimitive { get; }
        public override MetadataType MetadataType { get; }
        public override bool IsDefinition { get; }
        public TypeDefinition DeclaringType { get; set; }

        protected override void ClearFullName();
        public override TypeDefinition Resolve();
    }
}
using Mono.Collections.Generic;

namespace Mono.Cecil
{
    public sealed class InterfaceImplementation : IMetadataTokenProvider, ICustomAttributeProvider
    {
        public InterfaceImplementation(TypeReference interfaceType);

        public TypeReference InterfaceType { get; set; }
        public bool HasCustomAttributes { get; }
        public Collection<CustomAttribute> CustomAttributes { get; }
        public MetadataToken MetadataToken { get; set; }
    }
}
namespace Mono.Cecil
{
    public enum MetadataType
    {
        Void = 1,
        Boolean = 2,
        Char = 3,
        SByte = 4,
        Byte = 5,
        Int16 = 6,
        UInt16 = 7,
        Int32 = 8,
        UInt32 = 9,
        Int64 = 10,
        UInt64 = 11,
        Single = 12,
        Double = 13,
        String = 14,
        Pointer = 15,
        ByReference = 16,
        ValueType = 17,
        Class = 18,
        Var = 19,
        Array = 20,
        GenericInstance = 21,
        TypedByReference = 22,
        IntPtr = 24,
        UIntPtr = 25,
        FunctionPointer = 27,
        Object = 28,
        MVar = 30,
        RequiredModifier = 31,
        OptionalModifier = 32,
        Sentinel = 65,
        Pinned = 69
    }
}
using Mono.Collections.Generic;

namespace Mono.Cecil
{
    public class TypeReference : MemberReference, IGenericParameterProvider, IGenericContext
    {
        protected Collection<GenericParameter> generic_parameters;

        protected TypeReference(string namespace, string name);
        public TypeReference(string namespace, string name, ModuleDefinition module, IMetadataScope scope);
        public TypeReference(string namespace, string name, ModuleDefinition module, IMetadataScope scope, bool valueType);

        public override string Name { get; set; }
        public virtual string Namespace { get; set; }
        public virtual bool IsValueType { get; set; }
        public override ModuleDefinition Module { get; }
        public virtual bool HasGenericParameters { get; }
        public virtual Collection<GenericParameter> GenericParameters { get; }
        public virtual IMetadataScope Scope { get; set; }
        public bool IsNested { get; }
        public override TypeReference DeclaringType { get; set; }
        public override string FullName { get; }
        public virtual bool IsByReference { get; }
        public virtual bool IsPointer { get; }
        public virtual bool IsSentinel { get; }
        public virtual bool IsArray { get; }
        public virtual bool IsGenericParameter { get; }
        public virtual bool IsGenericInstance { get; }
        public virtual bool IsRequiredModifier { get; }
        public virtual bool IsOptionalModifier { get; }
        public virtual bool IsPinned { get; }
        public virtual bool IsFunctionPointer { get; }
        public virtual bool IsPrimitive { get; }
        public virtual MetadataType MetadataType { get; }

        protected virtual void ClearFullName();
        public virtual TypeReference GetElementType();
        protected override IMemberDefinition ResolveDefinition();
        public virtual TypeDefinition Resolve();
    }
}
namespace Mono.Cecil
{
    public abstract class TypeSpecification : TypeReference
    {
        public TypeReference ElementType { get; }
        public override string Name { get; set; }
        public override string Namespace { get; set; }
        public override IMetadataScope Scope { get; set; }
        public override ModuleDefinition Module { get; }
        public override string FullName { get; }
        public override bool ContainsGenericParameter { get; }
        public override MetadataType MetadataType { get; }

        public override TypeReference GetElementType();
    }
}
using System;

namespace Mono.Cecil
{
    public abstract class TypeSystem
    {
        [Obsolete("Use CoreLibrary")]
        public IMetadataScope Corlib { get; }
        public IMetadataScope CoreLibrary { get; }
        public TypeReference Object { get; }
        public TypeReference Void { get; }
        public TypeReference Boolean { get; }
        public TypeReference Char { get; }
        public TypeReference SByte { get; }
        public TypeReference Byte { get; }
        public TypeReference Int16 { get; }
        public TypeReference UInt16 { get; }
        public TypeReference Int32 { get; }
        public TypeReference UInt32 { get; }
        public TypeReference Int64 { get; }
        public TypeReference UInt64 { get; }
        public TypeReference Single { get; }
        public TypeReference Double { get; }
        public TypeReference IntPtr { get; }
        public TypeReference UIntPtr { get; }
        public TypeReference String { get; }
        public TypeReference TypedReference { get; }
    }
}
namespace Mono.Cecil
{
    public enum VariantType
    {
        None = 0,
        I2 = 2,
        I4 = 3,
        R4 = 4,
        R8 = 5,
        CY = 6,
        Date = 7,
        BStr = 8,
        Dispatch = 9,
        Error = 10,
        Bool = 11,
        Variant = 12,
        Unknown = 13,
        Decimal = 14,
        I1 = 16,
        UI1 = 17,
        UI2 = 18,
        UI4 = 19,
        Int = 22,
        UInt = 23
    }
}
using System;

namespace Mono.Cecil
{
    public struct MetadataToken : IEquatable<MetadataToken>
    {
        public static readonly MetadataToken Zero;

        public MetadataToken(uint token);
        public MetadataToken(TokenType type);
        public MetadataToken(TokenType type, uint rid);
        public MetadataToken(TokenType type, int rid);

        public uint RID { get; }
        public TokenType TokenType { get; }

        public int ToInt32();
        public uint ToUInt32();
        public override int GetHashCode();
        public bool Equals(MetadataToken other);
        public override bool Equals(object obj);
        public override string ToString();

        public static bool operator ==(MetadataToken one, MetadataToken other);
        public static bool operator !=(MetadataToken one, MetadataToken other);
    }
}
namespace Mono.Cecil
{
    public enum TokenType
    {
        Module = 0,
        TypeRef = 16777216,
        TypeDef = 33554432,
        Field = 67108864,
        Method = 100663296,
        Param = 134217728,
        InterfaceImpl = 150994944,
        MemberRef = 167772160,
        CustomAttribute = 201326592,
        Permission = 234881024,
        Signature = 285212672,
        Event = 335544320,
        Property = 385875968,
        ModuleRef = 436207616,
        TypeSpec = 452984832,
        Assembly = 536870912,
        AssemblyRef = 587202560,
        File = 637534208,
        ExportedType = 654311424,
        ManifestResource = 671088640,
        GenericParam = 704643072,
        MethodSpec = 721420288,
        GenericParamConstraint = 738197504,
        Document = 805306368,
        MethodDebugInformation = 822083584,
        LocalScope = 838860800,
        LocalVariable = 855638016,
        LocalConstant = 872415232,
        ImportScope = 889192448,
        StateMachineMethod = 905969664,
        CustomDebugInformation = 922746880,
        String = 1879048192
    }
}
namespace Mono.Cecil.Cil
{
    public enum Code
    {
        Nop = 0,
        Break = 1,
        Ldarg_0 = 2,
        Ldarg_1 = 3,
        Ldarg_2 = 4,
        Ldarg_3 = 5,
        Ldloc_0 = 6,
        Ldloc_1 = 7,
        Ldloc_2 = 8,
        Ldloc_3 = 9,
        Stloc_0 = 10,
        Stloc_1 = 11,
        Stloc_2 = 12,
        Stloc_3 = 13,
        Ldarg_S = 14,
        Ldarga_S = 15,
        Starg_S = 16,
        Ldloc_S = 17,
        Ldloca_S = 18,
        Stloc_S = 19,
        Ldnull = 20,
        Ldc_I4_M1 = 21,
        Ldc_I4_0 = 22,
        Ldc_I4_1 = 23,
        Ldc_I4_2 = 24,
        Ldc_I4_3 = 25,
        Ldc_I4_4 = 26,
        Ldc_I4_5 = 27,
        Ldc_I4_6 = 28,
        Ldc_I4_7 = 29,
        Ldc_I4_8 = 30,
        Ldc_I4_S = 31,
        Ldc_I4 = 32,
        Ldc_I8 = 33,
        Ldc_R4 = 34,
        Ldc_R8 = 35,
        Dup = 36,
        Pop = 37,
        Jmp = 38,
        Call = 39,
        Calli = 40,
        Ret = 41,
        Br_S = 42,
        Brfalse_S = 43,
        Brtrue_S = 44,
        Beq_S = 45,
        Bge_S = 46,
        Bgt_S = 47,
        Ble_S = 48,
        Blt_S = 49,
        Bne_Un_S = 50,
        Bge_Un_S = 51,
        Bgt_Un_S = 52,
        Ble_Un_S = 53,
        Blt_Un_S = 54,
        Br = 55,
        Brfalse = 56,
        Brtrue = 57,
        Beq = 58,
        Bge = 59,
        Bgt = 60,
        Ble = 61,
        Blt = 62,
        Bne_Un = 63,
        Bge_Un = 64,
        Bgt_Un = 65,
        Ble_Un = 66,
        Blt_Un = 67,
        Switch = 68,
        Ldind_I1 = 69,
        Ldind_U1 = 70,
        Ldind_I2 = 71,
        Ldind_U2 = 72,
        Ldind_I4 = 73,
        Ldind_U4 = 74,
        Ldind_I8 = 75,
        Ldind_I = 76,
        Ldind_R4 = 77,
        Ldind_R8 = 78,
        Ldind_Ref = 79,
        Stind_Ref = 80,
        Stind_I1 = 81,
        Stind_I2 = 82,
        Stind_I4 = 83,
        Stind_I8 = 84,
        Stind_R4 = 85,
        Stind_R8 = 86,
        Add = 87,
        Sub = 88,
        Mul = 89,
        Div = 90,
        Div_Un = 91,
        Rem = 92,
        Rem_Un = 93,
        And = 94,
        Or = 95,
        Xor = 96,
        Shl = 97,
        Shr = 98,
        Shr_Un = 99,
        Neg = 100,
        Not = 101,
        Conv_I1 = 102,
        Conv_I2 = 103,
        Conv_I4 = 104,
        Conv_I8 = 105,
        Conv_R4 = 106,
        Conv_R8 = 107,
        Conv_U4 = 108,
        Conv_U8 = 109,
        Callvirt = 110,
        Cpobj = 111,
        Ldobj = 112,
        Ldstr = 113,
        Newobj = 114,
        Castclass = 115,
        Isinst = 116,
        Conv_R_Un = 117,
        Unbox = 118,
        Throw = 119,
        Ldfld = 120,
        Ldflda = 121,
        Stfld = 122,
        Ldsfld = 123,
        Ldsflda = 124,
        Stsfld = 125,
        Stobj = 126,
        Conv_Ovf_I1_Un = 127,
        Conv_Ovf_I2_Un = 128,
        Conv_Ovf_I4_Un = 129,
        Conv_Ovf_I8_Un = 130,
        Conv_Ovf_U1_Un = 131,
        Conv_Ovf_U2_Un = 132,
        Conv_Ovf_U4_Un = 133,
        Conv_Ovf_U8_Un = 134,
        Conv_Ovf_I_Un = 135,
        Conv_Ovf_U_Un = 136,
        Box = 137,
        Newarr = 138,
        Ldlen = 139,
        Ldelema = 140,
        Ldelem_I1 = 141,
        Ldelem_U1 = 142,
        Ldelem_I2 = 143,
        Ldelem_U2 = 144,
        Ldelem_I4 = 145,
        Ldelem_U4 = 146,
        Ldelem_I8 = 147,
        Ldelem_I = 148,
        Ldelem_R4 = 149,
        Ldelem_R8 = 150,
        Ldelem_Ref = 151,
        Stelem_I = 152,
        Stelem_I1 = 153,
        Stelem_I2 = 154,
        Stelem_I4 = 155,
        Stelem_I8 = 156,
        Stelem_R4 = 157,
        Stelem_R8 = 158,
        Stelem_Ref = 159,
        Ldelem_Any = 160,
        Stelem_Any = 161,
        Unbox_Any = 162,
        Conv_Ovf_I1 = 163,
        Conv_Ovf_U1 = 164,
        Conv_Ovf_I2 = 165,
        Conv_Ovf_U2 = 166,
        Conv_Ovf_I4 = 167,
        Conv_Ovf_U4 = 168,
        Conv_Ovf_I8 = 169,
        Conv_Ovf_U8 = 170,
        Refanyval = 171,
        Ckfinite = 172,
        Mkrefany = 173,
        Ldtoken = 174,
        Conv_U2 = 175,
        Conv_U1 = 176,
        Conv_I = 177,
        Conv_Ovf_I = 178,
        Conv_Ovf_U = 179,
        Add_Ovf = 180,
        Add_Ovf_Un = 181,
        Mul_Ovf = 182,
        Mul_Ovf_Un = 183,
        Sub_Ovf = 184,
        Sub_Ovf_Un = 185,
        Endfinally = 186,
        Leave = 187,
        Leave_S = 188,
        Stind_I = 189,
        Conv_U = 190,
        Arglist = 191,
        Ceq = 192,
        Cgt = 193,
        Cgt_Un = 194,
        Clt = 195,
        Clt_Un = 196,
        Ldftn = 197,
        Ldvirtftn = 198,
        Ldarg = 199,
        Ldarga = 200,
        Starg = 201,
        Ldloc = 202,
        Ldloca = 203,
        Stloc = 204,
        Localloc = 205,
        Endfilter = 206,
        Unaligned = 207,
        Volatile = 208,
        Tail = 209,
        Initobj = 210,
        Constrained = 211,
        Cpblk = 212,
        Initblk = 213,
        No = 214,
        Rethrow = 215,
        Sizeof = 216,
        Refanytype = 217,
        Readonly = 218
    }
}
namespace Mono.Cecil.Cil
{
    public enum DocumentType
    {
        Other = 0,
        Text = 1
    }
}
namespace Mono.Cecil.Cil
{
    public enum DocumentHashAlgorithm
    {
        None = 0,
        MD5 = 1,
        SHA1 = 2,
        SHA256 = 3
    }
}
namespace Mono.Cecil.Cil
{
    public enum DocumentLanguage
    {
        Other = 0,
        C = 1,
        Cpp = 2,
        CSharp = 3,
        Basic = 4,
        Java = 5,
        Cobol = 6,
        Pascal = 7,
        Cil = 8,
        JScript = 9,
        Smc = 10,
        MCpp = 11,
        FSharp = 12
    }
}
namespace Mono.Cecil.Cil
{
    public enum DocumentLanguageVendor
    {
        Other = 0,
        Microsoft = 1
    }
}
namespace Mono.Cecil.Cil
{
    public sealed class Document : DebugInformation
    {
        public Document(string url);

        public string Url { get; set; }
        public DocumentType Type { get; set; }
        public DocumentHashAlgorithm HashAlgorithm { get; set; }
        public DocumentLanguage Language { get; set; }
        public DocumentLanguageVendor LanguageVendor { get; set; }
        public byte[] Hash { get; set; }
    }
}
namespace Mono.Cecil.Cil
{
    public enum ExceptionHandlerType
    {
        Catch = 0,
        Filter = 1,
        Finally = 2,
        Fault = 4
    }
}
namespace Mono.Cecil.Cil
{
    public sealed class ExceptionHandler
    {
        public ExceptionHandler(ExceptionHandlerType handlerType);

        public Instruction TryStart { get; set; }
        public Instruction TryEnd { get; set; }
        public Instruction FilterStart { get; set; }
        public Instruction HandlerStart { get; set; }
        public Instruction HandlerEnd { get; set; }
        public TypeReference CatchType { get; set; }
        public ExceptionHandlerType HandlerType { get; set; }
    }
}
namespace Mono.Cecil.Cil
{
    public sealed class ILProcessor
    {
        public MethodBody Body { get; }

        public Instruction Create(OpCode opcode);
        public Instruction Create(OpCode opcode, TypeReference type);
        public Instruction Create(OpCode opcode, CallSite site);
        public Instruction Create(OpCode opcode, MethodReference method);
        public Instruction Create(OpCode opcode, FieldReference field);
        public Instruction Create(OpCode opcode, string value);
        public Instruction Create(OpCode opcode, sbyte value);
        public Instruction Create(OpCode opcode, byte value);
        public Instruction Create(OpCode opcode, int value);
        public Instruction Create(OpCode opcode, long value);
        public Instruction Create(OpCode opcode, float value);
        public Instruction Create(OpCode opcode, double value);
        public Instruction Create(OpCode opcode, Instruction target);
        public Instruction Create(OpCode opcode, Instruction[] targets);
        public Instruction Create(OpCode opcode, VariableDefinition variable);
        public Instruction Create(OpCode opcode, ParameterDefinition parameter);
        public void Emit(OpCode opcode);
        public void Emit(OpCode opcode, TypeReference type);
        public void Emit(OpCode opcode, MethodReference method);
        public void Emit(OpCode opcode, CallSite site);
        public void Emit(OpCode opcode, FieldReference field);
        public void Emit(OpCode opcode, string value);
        public void Emit(OpCode opcode, byte value);
        public void Emit(OpCode opcode, sbyte value);
        public void Emit(OpCode opcode, int value);
        public void Emit(OpCode opcode, long value);
        public void Emit(OpCode opcode, float value);
        public void Emit(OpCode opcode, double value);
        public void Emit(OpCode opcode, Instruction target);
        public void Emit(OpCode opcode, Instruction[] targets);
        public void Emit(OpCode opcode, VariableDefinition variable);
        public void Emit(OpCode opcode, ParameterDefinition parameter);
        public void InsertBefore(Instruction target, Instruction instruction);
        public void InsertAfter(Instruction target, Instruction instruction);
        public void InsertAfter(int index, Instruction instruction);
        public void Append(Instruction instruction);
        public void Replace(Instruction target, Instruction instruction);
        public void Replace(int index, Instruction instruction);
        public void Remove(Instruction instruction);
        public void RemoveAt(int index);
    }
}
namespace Mono.Cecil.Cil
{
    public sealed class Instruction
    {
        public int Offset { get; set; }
        public OpCode OpCode { get; set; }
        public object Operand { get; set; }
        public Instruction Previous { get; set; }
        public Instruction Next { get; set; }

        public int GetSize();
        public override string ToString();
        public static Instruction Create(OpCode opcode);
        public static Instruction Create(OpCode opcode, TypeReference type);
        public static Instruction Create(OpCode opcode, CallSite site);
        public static Instruction Create(OpCode opcode, MethodReference method);
        public static Instruction Create(OpCode opcode, FieldReference field);
        public static Instruction Create(OpCode opcode, string value);
        public static Instruction Create(OpCode opcode, sbyte value);
        public static Instruction Create(OpCode opcode, byte value);
        public static Instruction Create(OpCode opcode, int value);
        public static Instruction Create(OpCode opcode, long value);
        public static Instruction Create(OpCode opcode, float value);
        public static Instruction Create(OpCode opcode, double value);
        public static Instruction Create(OpCode opcode, Instruction target);
        public static Instruction Create(OpCode opcode, Instruction[] targets);
        public static Instruction Create(OpCode opcode, VariableDefinition variable);
        public static Instruction Create(OpCode opcode, ParameterDefinition parameter);
    }
}
using Mono.Collections.Generic;

namespace Mono.Cecil.Cil
{
    public sealed class MethodBody
    {
        public MethodBody(MethodDefinition method);

        public MethodDefinition Method { get; }
        public int MaxStackSize { get; set; }
        public int CodeSize { get; }
        public bool InitLocals { get; set; }
        public MetadataToken LocalVarToken { get; set; }
        public Collection<Instruction> Instructions { get; }
        public bool HasExceptionHandlers { get; }
        public Collection<ExceptionHandler> ExceptionHandlers { get; }
        public bool HasVariables { get; }
        public Collection<VariableDefinition> Variables { get; }
        public ScopeDebugInformation Scope { get; set; }
        public ParameterDefinition ThisParameter { get; }

        public ILProcessor GetILProcessor();
        public bool GetInstructionToken(Instruction instruction, out MetadataToken token);
    }
}
namespace Mono.Cecil.Cil
{
    public enum FlowControl
    {
        Branch = 0,
        Break = 1,
        Call = 2,
        Cond_Branch = 3,
        Meta = 4,
        Next = 5,
        Phi = 6,
        Return = 7,
        Throw = 8
    }
}
namespace Mono.Cecil.Cil
{
    public enum OpCodeType
    {
        Annotation = 0,
        Macro = 1,
        Nternal = 2,
        Objmodel = 3,
        Prefix = 4,
        Primitive = 5
    }
}
namespace Mono.Cecil.Cil
{
    public enum OperandType
    {
        InlineBrTarget = 0,
        InlineField = 1,
        InlineI = 2,
        InlineI8 = 3,
        InlineMethod = 4,
        InlineNone = 5,
        InlinePhi = 6,
        InlineR = 7,
        InlineSig = 8,
        InlineString = 9,
        InlineSwitch = 10,
        InlineTok = 11,
        InlineType = 12,
        InlineVar = 13,
        InlineArg = 14,
        ShortInlineBrTarget = 15,
        ShortInlineI = 16,
        ShortInlineR = 17,
        ShortInlineVar = 18,
        ShortInlineArg = 19
    }
}
namespace Mono.Cecil.Cil
{
    public enum StackBehaviour
    {
        Pop0 = 0,
        Pop1 = 1,
        Pop1_pop1 = 2,
        Popi = 3,
        Popi_pop1 = 4,
        Popi_popi = 5,
        Popi_popi8 = 6,
        Popi_popi_popi = 7,
        Popi_popr4 = 8,
        Popi_popr8 = 9,
        Popref = 10,
        Popref_pop1 = 11,
        Popref_popi = 12,
        Popref_popi_popi = 13,
        Popref_popi_popi8 = 14,
        Popref_popi_popr4 = 15,
        Popref_popi_popr8 = 16,
        Popref_popi_popref = 17,
        PopAll = 18,
        Push0 = 19,
        Push1 = 20,
        Push1_push1 = 21,
        Pushi = 22,
        Pushi8 = 23,
        Pushr4 = 24,
        Pushr8 = 25,
        Pushref = 26,
        Varpop = 27,
        Varpush = 28
    }
}
using System;

namespace Mono.Cecil.Cil
{
    public struct OpCode : IEquatable<OpCode>
    {
        public string Name { get; }
        public int Size { get; }
        public byte Op1 { get; }
        public byte Op2 { get; }
        public short Value { get; }
        public Code Code { get; }
        public FlowControl FlowControl { get; }
        public OpCodeType OpCodeType { get; }
        public OperandType OperandType { get; }
        public StackBehaviour StackBehaviourPop { get; }
        public StackBehaviour StackBehaviourPush { get; }

        public override int GetHashCode();
        public override bool Equals(object obj);
        public bool Equals(OpCode opcode);
        public override string ToString();

        public static bool operator ==(OpCode one, OpCode other);
        public static bool operator !=(OpCode one, OpCode other);
    }
}
namespace Mono.Cecil.Cil
{
    public static class OpCodes
    {
        public static readonly OpCode Nop;
        public static readonly OpCode Break;
        public static readonly OpCode Ldarg_0;
        public static readonly OpCode Ldarg_1;
        public static readonly OpCode Ldarg_2;
        public static readonly OpCode Ldarg_3;
        public static readonly OpCode Ldloc_0;
        public static readonly OpCode Ldloc_1;
        public static readonly OpCode Ldloc_2;
        public static readonly OpCode Ldloc_3;
        public static readonly OpCode Stloc_0;
        public static readonly OpCode Stloc_1;
        public static readonly OpCode Stloc_2;
        public static readonly OpCode Stloc_3;
        public static readonly OpCode Ldarg_S;
        public static readonly OpCode Ldarga_S;
        public static readonly OpCode Starg_S;
        public static readonly OpCode Ldloc_S;
        public static readonly OpCode Ldloca_S;
        public static readonly OpCode Stloc_S;
        public static readonly OpCode Ldnull;
        public static readonly OpCode Ldc_I4_M1;
        public static readonly OpCode Ldc_I4_0;
        public static readonly OpCode Ldc_I4_1;
        public static readonly OpCode Ldc_I4_2;
        public static readonly OpCode Ldc_I4_3;
        public static readonly OpCode Ldc_I4_4;
        public static readonly OpCode Ldc_I4_5;
        public static readonly OpCode Ldc_I4_6;
        public static readonly OpCode Ldc_I4_7;
        public static readonly OpCode Ldc_I4_8;
        public static readonly OpCode Ldc_I4_S;
        public static readonly OpCode Ldc_I4;
        public static readonly OpCode Ldc_I8;
        public static readonly OpCode Ldc_R4;
        public static readonly OpCode Ldc_R8;
        public static readonly OpCode Dup;
        public static readonly OpCode Pop;
        public static readonly OpCode Jmp;
        public static readonly OpCode Call;
        public static readonly OpCode Calli;
        public static readonly OpCode Ret;
        public static readonly OpCode Br_S;
        public static readonly OpCode Brfalse_S;
        public static readonly OpCode Brtrue_S;
        public static readonly OpCode Beq_S;
        public static readonly OpCode Bge_S;
        public static readonly OpCode Bgt_S;
        public static readonly OpCode Ble_S;
        public static readonly OpCode Blt_S;
        public static readonly OpCode Bne_Un_S;
        public static readonly OpCode Bge_Un_S;
        public static readonly OpCode Bgt_Un_S;
        public static readonly OpCode Ble_Un_S;
        public static readonly OpCode Blt_Un_S;
        public static readonly OpCode Br;
        public static readonly OpCode Brfalse;
        public static readonly OpCode Brtrue;
        public static readonly OpCode Beq;
        public static readonly OpCode Bge;
        public static readonly OpCode Bgt;
        public static readonly OpCode Ble;
        public static readonly OpCode Blt;
        public static readonly OpCode Bne_Un;
        public static readonly OpCode Bge_Un;
        public static readonly OpCode Bgt_Un;
        public static readonly OpCode Ble_Un;
        public static readonly OpCode Blt_Un;
        public static readonly OpCode Switch;
        public static readonly OpCode Ldind_I1;
        public static readonly OpCode Ldind_U1;
        public static readonly OpCode Ldind_I2;
        public static readonly OpCode Ldind_U2;
        public static readonly OpCode Ldind_I4;
        public static readonly OpCode Ldind_U4;
        public static readonly OpCode Ldind_I8;
        public static readonly OpCode Ldind_I;
        public static readonly OpCode Ldind_R4;
        public static readonly OpCode Ldind_R8;
        public static readonly OpCode Ldind_Ref;
        public static readonly OpCode Stind_Ref;
        public static readonly OpCode Stind_I1;
        public static readonly OpCode Stind_I2;
        public static readonly OpCode Stind_I4;
        public static readonly OpCode Stind_I8;
        public static readonly OpCode Stind_R4;
        public static readonly OpCode Stind_R8;
        public static readonly OpCode Add;
        public static readonly OpCode Sub;
        public static readonly OpCode Mul;
        public static readonly OpCode Div;
        public static readonly OpCode Div_Un;
        public static readonly OpCode Rem;
        public static readonly OpCode Rem_Un;
        public static readonly OpCode And;
        public static readonly OpCode Or;
        public static readonly OpCode Xor;
        public static readonly OpCode Shl;
        public static readonly OpCode Shr;
        public static readonly OpCode Shr_Un;
        public static readonly OpCode Neg;
        public static readonly OpCode Not;
        public static readonly OpCode Conv_I1;
        public static readonly OpCode Conv_I2;
        public static readonly OpCode Conv_I4;
        public static readonly OpCode Conv_I8;
        public static readonly OpCode Conv_R4;
        public static readonly OpCode Conv_R8;
        public static readonly OpCode Conv_U4;
        public static readonly OpCode Conv_U8;
        public static readonly OpCode Callvirt;
        public static readonly OpCode Cpobj;
        public static readonly OpCode Ldobj;
        public static readonly OpCode Ldstr;
        public static readonly OpCode Newobj;
        public static readonly OpCode Castclass;
        public static readonly OpCode Isinst;
        public static readonly OpCode Conv_R_Un;
        public static readonly OpCode Unbox;
        public static readonly OpCode Throw;
        public static readonly OpCode Ldfld;
        public static readonly OpCode Ldflda;
        public static readonly OpCode Stfld;
        public static readonly OpCode Ldsfld;
        public static readonly OpCode Ldsflda;
        public static readonly OpCode Stsfld;
        public static readonly OpCode Stobj;
        public static readonly OpCode Conv_Ovf_I1_Un;
        public static readonly OpCode Conv_Ovf_I2_Un;
        public static readonly OpCode Conv_Ovf_I4_Un;
        public static readonly OpCode Conv_Ovf_I8_Un;
        public static readonly OpCode Conv_Ovf_U1_Un;
        public static readonly OpCode Conv_Ovf_U2_Un;
        public static readonly OpCode Conv_Ovf_U4_Un;
        public static readonly OpCode Conv_Ovf_U8_Un;
        public static readonly OpCode Conv_Ovf_I_Un;
        public static readonly OpCode Conv_Ovf_U_Un;
        public static readonly OpCode Box;
        public static readonly OpCode Newarr;
        public static readonly OpCode Ldlen;
        public static readonly OpCode Ldelema;
        public static readonly OpCode Ldelem_I1;
        public static readonly OpCode Ldelem_U1;
        public static readonly OpCode Ldelem_I2;
        public static readonly OpCode Ldelem_U2;
        public static readonly OpCode Ldelem_I4;
        public static readonly OpCode Ldelem_U4;
        public static readonly OpCode Ldelem_I8;
        public static readonly OpCode Ldelem_I;
        public static readonly OpCode Ldelem_R4;
        public static readonly OpCode Ldelem_R8;
        public static readonly OpCode Ldelem_Ref;
        public static readonly OpCode Stelem_I;
        public static readonly OpCode Stelem_I1;
        public static readonly OpCode Stelem_I2;
        public static readonly OpCode Stelem_I4;
        public static readonly OpCode Stelem_I8;
        public static readonly OpCode Stelem_R4;
        public static readonly OpCode Stelem_R8;
        public static readonly OpCode Stelem_Ref;
        public static readonly OpCode Ldelem_Any;
        public static readonly OpCode Stelem_Any;
        public static readonly OpCode Unbox_Any;
        public static readonly OpCode Conv_Ovf_I1;
        public static readonly OpCode Conv_Ovf_U1;
        public static readonly OpCode Conv_Ovf_I2;
        public static readonly OpCode Conv_Ovf_U2;
        public static readonly OpCode Conv_Ovf_I4;
        public static readonly OpCode Conv_Ovf_U4;
        public static readonly OpCode Conv_Ovf_I8;
        public static readonly OpCode Conv_Ovf_U8;
        public static readonly OpCode Refanyval;
        public static readonly OpCode Ckfinite;
        public static readonly OpCode Mkrefany;
        public static readonly OpCode Ldtoken;
        public static readonly OpCode Conv_U2;
        public static readonly OpCode Conv_U1;
        public static readonly OpCode Conv_I;
        public static readonly OpCode Conv_Ovf_I;
        public static readonly OpCode Conv_Ovf_U;
        public static readonly OpCode Add_Ovf;
        public static readonly OpCode Add_Ovf_Un;
        public static readonly OpCode Mul_Ovf;
        public static readonly OpCode Mul_Ovf_Un;
        public static readonly OpCode Sub_Ovf;
        public static readonly OpCode Sub_Ovf_Un;
        public static readonly OpCode Endfinally;
        public static readonly OpCode Leave;
        public static readonly OpCode Leave_S;
        public static readonly OpCode Stind_I;
        public static readonly OpCode Conv_U;
        public static readonly OpCode Arglist;
        public static readonly OpCode Ceq;
        public static readonly OpCode Cgt;
        public static readonly OpCode Cgt_Un;
        public static readonly OpCode Clt;
        public static readonly OpCode Clt_Un;
        public static readonly OpCode Ldftn;
        public static readonly OpCode Ldvirtftn;
        public static readonly OpCode Ldarg;
        public static readonly OpCode Ldarga;
        public static readonly OpCode Starg;
        public static readonly OpCode Ldloc;
        public static readonly OpCode Ldloca;
        public static readonly OpCode Stloc;
        public static readonly OpCode Localloc;
        public static readonly OpCode Endfilter;
        public static readonly OpCode Unaligned;
        public static readonly OpCode Volatile;
        public static readonly OpCode Tail;
        public static readonly OpCode Initobj;
        public static readonly OpCode Constrained;
        public static readonly OpCode Cpblk;
        public static readonly OpCode Initblk;
        public static readonly OpCode No;
        public static readonly OpCode Rethrow;
        public static readonly OpCode Sizeof;
        public static readonly OpCode Refanytype;
        public static readonly OpCode Readonly;
    }
}
using System.IO;

namespace Mono.Cecil.Cil
{
    public sealed class PortablePdbReaderProvider : ISymbolReaderProvider
    {
        public PortablePdbReaderProvider();

        public ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName);
        public ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream);
    }
}
using System;

namespace Mono.Cecil.Cil
{
    public sealed class PortablePdbReader : ISymbolReader, IDisposable
    {
        public ISymbolWriterProvider GetWriterProvider();
        public bool ProcessDebugHeader(ImageDebugHeader header);
        public MethodDebugInformation Read(MethodDefinition method);
        public void Dispose();
    }
}
using System.IO;

namespace Mono.Cecil.Cil
{
    public sealed class EmbeddedPortablePdbReaderProvider : ISymbolReaderProvider
    {
        public EmbeddedPortablePdbReaderProvider();

        public ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName);
        public ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream);
    }
}
using System;

namespace Mono.Cecil.Cil
{
    public sealed class EmbeddedPortablePdbReader : ISymbolReader, IDisposable
    {
        public ISymbolWriterProvider GetWriterProvider();
        public bool ProcessDebugHeader(ImageDebugHeader header);
        public MethodDebugInformation Read(MethodDefinition method);
        public void Dispose();
    }
}
using System.IO;

namespace Mono.Cecil.Cil
{
    public sealed class PortablePdbWriterProvider : ISymbolWriterProvider
    {
        public PortablePdbWriterProvider();

        public ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName);
        public ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream);
    }
}
using System;

namespace Mono.Cecil.Cil
{
    public sealed class PortablePdbWriter : IDisposable, IMetadataSymbolWriter, ISymbolWriter
    {
        public ISymbolReaderProvider GetReaderProvider();
        public ImageDebugHeader GetDebugHeader();
        public void Write(MethodDebugInformation info);
        public void Dispose();
    }
}
using System.IO;

namespace Mono.Cecil.Cil
{
    public sealed class EmbeddedPortablePdbWriterProvider : ISymbolWriterProvider
    {
        public EmbeddedPortablePdbWriterProvider();

        public ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName);
        public ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream);
    }
}
using System;

namespace Mono.Cecil.Cil
{
    public sealed class EmbeddedPortablePdbWriter : IDisposable, IMetadataSymbolWriter, ISymbolWriter
    {
        public ISymbolReaderProvider GetReaderProvider();
        public ImageDebugHeader GetDebugHeader();
        public void Write(MethodDebugInformation info);
        public void Dispose();
    }
}
namespace Mono.Cecil.Cil
{
    public sealed class SequencePoint
    {
        public SequencePoint(Instruction instruction, Document document);

        public int Offset { get; }
        public int StartLine { get; set; }
        public int StartColumn { get; set; }
        public int EndLine { get; set; }
        public int EndColumn { get; set; }
        public bool IsHidden { get; }
        public Document Document { get; set; }
    }
}
namespace Mono.Cecil.Cil
{
    public struct ImageDebugDirectory
    {
        public const int Size = 28;
        public int Characteristics;
        public int TimeDateStamp;
        public short MajorVersion;
        public short MinorVersion;
        public ImageDebugType Type;
        public int SizeOfData;
        public int AddressOfRawData;
        public int PointerToRawData;
    }
}
namespace Mono.Cecil.Cil
{
    public enum ImageDebugType
    {
        CodeView = 2,
        Deterministic = 16,
        EmbeddedPortablePdb = 17
    }
}
namespace Mono.Cecil.Cil
{
    public sealed class ImageDebugHeader
    {
        public ImageDebugHeader(ImageDebugHeaderEntry[] entries);
        public ImageDebugHeader();
        public ImageDebugHeader(ImageDebugHeaderEntry entry);

        public bool HasEntries { get; }
        public ImageDebugHeaderEntry[] Entries { get; }
    }
}
namespace Mono.Cecil.Cil
{
    public sealed class ImageDebugHeaderEntry
    {
        public ImageDebugHeaderEntry(ImageDebugDirectory directory, byte[] data);

        public ImageDebugDirectory Directory { get; }
        public byte[] Data { get; }
    }
}
using Mono.Collections.Generic;

namespace Mono.Cecil.Cil
{
    public sealed class ScopeDebugInformation : DebugInformation
    {
        public ScopeDebugInformation(Instruction start, Instruction end);

        public InstructionOffset Start { get; set; }
        public InstructionOffset End { get; set; }
        public ImportDebugInformation Import { get; set; }
        public bool HasScopes { get; }
        public Collection<ScopeDebugInformation> Scopes { get; }
        public bool HasVariables { get; }
        public Collection<VariableDebugInformation> Variables { get; }
        public bool HasConstants { get; }
        public Collection<ConstantDebugInformation> Constants { get; }

        public bool TryGetName(VariableDefinition variable, out string name);
    }
}
namespace Mono.Cecil.Cil
{
    public struct InstructionOffset
    {
        public InstructionOffset(Instruction instruction);
        public InstructionOffset(int offset);

        public int Offset { get; }
        public bool IsEndOfMethod { get; }
    }
}
using System;

namespace Mono.Cecil.Cil
{
    [Flags]
    public enum VariableAttributes
    {
        None = 0,
        DebuggerHidden = 1
    }
}
namespace Mono.Cecil.Cil
{
    public struct VariableIndex
    {
        public VariableIndex(VariableDefinition variable);
        public VariableIndex(int index);

        public int Index { get; }
    }
}
using Mono.Collections.Generic;

namespace Mono.Cecil.Cil
{
    public abstract class DebugInformation : IMetadataTokenProvider, ICustomDebugInformationProvider
    {
        public MetadataToken MetadataToken { get; set; }
        public bool HasCustomDebugInformations { get; }
        public Collection<CustomDebugInformation> CustomDebugInformations { get; }
    }
}
namespace Mono.Cecil.Cil
{
    public sealed class VariableDebugInformation : DebugInformation
    {
        public VariableDebugInformation(VariableDefinition variable, string name);

        public int Index { get; }
        public string Name { get; set; }
        public VariableAttributes Attributes { get; set; }
        public bool IsDebuggerHidden { get; set; }
    }
}
namespace Mono.Cecil.Cil
{
    public sealed class ConstantDebugInformation : DebugInformation
    {
        public ConstantDebugInformation(string name, TypeReference constant_type, object value);

        public string Name { get; set; }
        public TypeReference ConstantType { get; set; }
        public object Value { get; set; }
    }
}
namespace Mono.Cecil.Cil
{
    public enum ImportTargetKind
    {
        ImportNamespace = 1,
        ImportNamespaceInAssembly = 2,
        ImportType = 3,
        ImportXmlNamespaceWithAlias = 4,
        ImportAlias = 5,
        DefineAssemblyAlias = 6,
        DefineNamespaceAlias = 7,
        DefineNamespaceInAssemblyAlias = 8,
        DefineTypeAlias = 9
    }
}
namespace Mono.Cecil.Cil
{
    public sealed class ImportTarget
    {
        public ImportTarget(ImportTargetKind kind);

        public string Namespace { get; set; }
        public TypeReference Type { get; set; }
        public AssemblyNameReference AssemblyReference { get; set; }
        public string Alias { get; set; }
        public ImportTargetKind Kind { get; set; }
    }
}
using Mono.Collections.Generic;

namespace Mono.Cecil.Cil
{
    public sealed class ImportDebugInformation : DebugInformation
    {
        public ImportDebugInformation();

        public bool HasTargets { get; }
        public Collection<ImportTarget> Targets { get; }
        public ImportDebugInformation Parent { get; set; }
    }
}
using Mono.Collections.Generic;

namespace Mono.Cecil.Cil
{
    public interface ICustomDebugInformationProvider : IMetadataTokenProvider
    {
        bool HasCustomDebugInformations { get; }
        Collection<CustomDebugInformation> CustomDebugInformations { get; }
    }
}
namespace Mono.Cecil.Cil
{
    public enum CustomDebugInformationKind
    {
        Binary = 0,
        StateMachineScope = 1,
        DynamicVariable = 2,
        DefaultNamespace = 3,
        AsyncMethodBody = 4,
        EmbeddedSource = 5,
        SourceLink = 6
    }
}
using System;

namespace Mono.Cecil.Cil
{
    public abstract class CustomDebugInformation : DebugInformation
    {
        public Guid Identifier { get; }
        public abstract CustomDebugInformationKind Kind { get; }
    }
}
using System;

namespace Mono.Cecil.Cil
{
    public sealed class BinaryCustomDebugInformation : CustomDebugInformation
    {
        public BinaryCustomDebugInformation(Guid identifier, byte[] data);

        public byte[] Data { get; set; }
        public override CustomDebugInformationKind Kind { get; }
    }
}
using Mono.Collections.Generic;
using System;

namespace Mono.Cecil.Cil
{
    public sealed class AsyncMethodBodyDebugInformation : CustomDebugInformation
    {
        public static Guid KindIdentifier;

        public AsyncMethodBodyDebugInformation(Instruction catchHandler);
        public AsyncMethodBodyDebugInformation();

        public InstructionOffset CatchHandler { get; set; }
        public Collection<InstructionOffset> Yields { get; }
        public Collection<InstructionOffset> Resumes { get; }
        public MethodDefinition MoveNextMethod { get; set; }
        public override CustomDebugInformationKind Kind { get; }
    }
}
using System;

namespace Mono.Cecil.Cil
{
    public sealed class StateMachineScopeDebugInformation : CustomDebugInformation
    {
        public static Guid KindIdentifier;

        public StateMachineScopeDebugInformation(Instruction start, Instruction end);

        public InstructionOffset Start { get; set; }
        public InstructionOffset End { get; set; }
        public override CustomDebugInformationKind Kind { get; }
    }
}
using System;

namespace Mono.Cecil.Cil
{
    public sealed class EmbeddedSourceDebugInformation : CustomDebugInformation
    {
        public static Guid KindIdentifier;

        public EmbeddedSourceDebugInformation(byte[] content, bool compress);

        public byte[] Content { get; set; }
        public bool Compress { get; set; }
        public override CustomDebugInformationKind Kind { get; }
    }
}
using System;

namespace Mono.Cecil.Cil
{
    public sealed class SourceLinkDebugInformation : CustomDebugInformation
    {
        public static Guid KindIdentifier;

        public SourceLinkDebugInformation(string content);

        public string Content { get; set; }
        public override CustomDebugInformationKind Kind { get; }
    }
}
using Mono.Collections.Generic;
using System.Collections.Generic;

namespace Mono.Cecil.Cil
{
    public sealed class MethodDebugInformation : DebugInformation
    {
        public MethodDefinition Method { get; }
        public bool HasSequencePoints { get; }
        public Collection<SequencePoint> SequencePoints { get; }
        public ScopeDebugInformation Scope { get; set; }
        public MethodDefinition StateMachineKickOffMethod { get; set; }

        public SequencePoint GetSequencePoint(Instruction instruction);
        public IDictionary<Instruction, SequencePoint> GetSequencePointMapping();
        public IEnumerable<ScopeDebugInformation> GetScopes();
        public bool TryGetName(VariableDefinition variable, out string name);
    }
}
using System;

namespace Mono.Cecil.Cil
{
    public interface ISymbolReader : IDisposable
    {
        ISymbolWriterProvider GetWriterProvider();
        bool ProcessDebugHeader(ImageDebugHeader header);
        MethodDebugInformation Read(MethodDefinition method);
    }
}
using System.IO;

namespace Mono.Cecil.Cil
{
    public interface ISymbolReaderProvider
    {
        ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName);
        ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream);
    }
}
namespace Mono.Cecil.Cil
{
    public enum SymbolReaderKind
    {
        NativePdb = 0,
        PortablePdb = 1,
        Mdb = 2,
        None = 3
    }
}
using System.IO;

namespace Mono.Cecil.Cil
{
    public class DefaultSymbolReaderProvider : ISymbolReaderProvider
    {
        public DefaultSymbolReaderProvider();
        public DefaultSymbolReaderProvider(bool throwIfNoSymbol);

        public ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName);
        public static SymbolReaderKind GetSymbolReaderKind(string fileName);
        public SymbolReaderKind GetSymbolReaderKind(ModuleDefinition module, string fileName);
        public ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream);
    }
}
using System;

namespace Mono.Cecil.Cil
{
    public interface ISymbolWriter : IDisposable
    {
        ISymbolReaderProvider GetReaderProvider();
        ImageDebugHeader GetDebugHeader();
        void Write(MethodDebugInformation info);
    }
}
using System.IO;

namespace Mono.Cecil.Cil
{
    public interface ISymbolWriterProvider
    {
        ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName);
        ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream);
    }
}
using System.IO;

namespace Mono.Cecil.Cil
{
    public class DefaultSymbolWriterProvider : ISymbolWriterProvider
    {
        public DefaultSymbolWriterProvider();

        public ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName);
        public ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream);
    }
}
namespace Mono.Cecil.Cil
{
    public sealed class VariableDefinition : VariableReference
    {
        public VariableDefinition(TypeReference variableType);

        public bool IsPinned { get; }

        public override VariableDefinition Resolve();
    }
}
namespace Mono.Cecil.Cil
{
    public abstract class VariableReference
    {
        protected TypeReference variable_type;

        public TypeReference VariableType { get; set; }
        public int Index { get; }

        public abstract VariableDefinition Resolve();
        public override string ToString();
    }
}
-------- {Unity.CompilationPipeline.Common(D:\Programs\2020.3.38f1\Editor\Data\Managed\Unity.CompilationPipeline.Common.dll)}:    7 --------
namespace Unity.CompilationPipeline.Common
{
    public enum CodeOptimization
    {
        None = 0,
        Debug = 1,
        Release = 2
    }
}
namespace Unity.CompilationPipeline.Common
{
    public class AssemblyInfo
    {
        public AssemblyInfo();

        public string Name { get; set; }
        public string OutputDirectory { get; set; }
        public string[] References { get; set; }
        public string[] Defines { get; set; }
        public string[] Files { get; set; }
        public bool AllowUnsafeCode { get; set; }
        public CodeOptimization CodeOptimization { get; set; }
    }
}
namespace Unity.CompilationPipeline.Common.Diagnostics
{
    public class DiagnosticMessage
    {
        public DiagnosticMessage();

        public string File { get; set; }
        public DiagnosticType DiagnosticType { get; set; }
        public string MessageData { get; set; }
        public int Line { get; set; }
        public int Column { get; set; }
    }
}
namespace Unity.CompilationPipeline.Common.Diagnostics
{
    public enum DiagnosticType
    {
        Error = 1,
        Warning = 2
    }
}
namespace Unity.CompilationPipeline.Common.ILPostProcessing
{
    public class InMemoryAssembly
    {
        public InMemoryAssembly(byte[] peData, byte[] pdbData);

        public byte[] PeData { get; set; }
        public byte[] PdbData { get; set; }
    }
}
namespace Unity.CompilationPipeline.Common.ILPostProcessing
{
    public interface ICompiledAssembly
    {
        InMemoryAssembly InMemoryAssembly { get; }
        string Name { get; }
        string[] References { get; }
        string[] Defines { get; }
    }
}
using System.Collections.Generic;
using Unity.CompilationPipeline.Common.Diagnostics;

namespace Unity.CompilationPipeline.Common.ILPostProcessing
{
    public class ILPostProcessResult
    {
        public ILPostProcessResult(InMemoryAssembly inMemoryAssembly);
        public ILPostProcessResult(InMemoryAssembly inMemoryAssembly, List<DiagnosticMessage> diagnostics);

        public InMemoryAssembly InMemoryAssembly { get; set; }
        public List<DiagnosticMessage> Diagnostics { get; set; }
    }
}
namespace Unity.CompilationPipeline.Common.ILPostProcessing
{
    public abstract class ILPostProcessor
    {
        protected ILPostProcessor();

        public abstract ILPostProcessor GetInstance();
        public abstract bool WillProcess(ICompiledAssembly compiledAssembly);
        public abstract ILPostProcessResult Process(ICompiledAssembly compiledAssembly);
    }
}
-------- {DLL()}:  134 --------
using System.Reflection;

[DefaultMember("Item")]
public class Test
{
    public float field1;
    public readonly float field2;
    public readonly int field3;
    public static int field4;
    public static readonly bool field5;
    public const string field6 = "Const";
    public char field7;

    public Test(int test);

    ~Test();

    public int this[float other] { get; }
    public int this[int index] { get; }
    public int myProperty { get; }
    public static float staticProp { get; set; }
    public bool sad { get; }

    public event Delegate doInner;
    public static event Delegate del;

    public int DoStuff();
    public static void DoOtherStuff();
    public int DoThing(ref int a);
    public void Do(float a);
    public void Do(ref int a, params int[] b);
    public static int Static();

    public static int operator +(Test a, Test b);
    public static float operator *(Test a, float c);
    public static bool operator -(Test t, bool b);

    public static implicit operator int(Test t);
    public static explicit operator bool(Test t);

    public class Inner
    {
        public Test test;

        public Inner();

        public delegate void DoShit(int a);
    }
    public delegate Inner Delegate(Inner2 inner);
    public class Inner2
    {
        public Inner inner;

        public Inner2();

        public delegate int Do(int i);
    }
}
namespace A2
{
    public class A
    {
        public A();
    }
}
namespace A2
{
    public class C
    {
        public C();
    }
}
using A1;
using A1.B;

namespace A2.B
{
    public class A
    {
        public A();

        public A DoA(A1.A a1, A2.A a2, A1.B.B.A a3);
        public B DoB(A1.B.B b1, A2.B.B b2, A1.B.B.A.B b3);

        public class B
        {
            public B();

            public A DoA(A1.A a1, A2.A a2, A1.B.B.A a3);
            public B DoB(A1.B.B b1, A2.B.B b2, A1.B.B.A.B b3);
        }
    }
}
using A1;
using A1.B;

namespace A2.B
{
    public class B
    {
        public B();

        public A DoA(A1.A a1, A2.A a2, A1.B.B.A a3);
        public B DoB(A1.B.B b1, A.B b2, A1.B.B.A.B b3);
    }
}
namespace A1
{
    public class A
    {
        public A();
    }
}
namespace A1
{
    public class C
    {
        public C();
    }
}
namespace A1.B
{
    public class A
    {
        public A();
    }
}
using A2;

namespace A1.B
{
    public class B
    {
        public D.E e;

        public B();

        public A DoA(A1.A a1, A2.A a2);
        public B DoB(A.B b);
        public C DoC(A.B.C c);

        public class A
        {
            public A();

            public A DoB(B b1, A1.B.B b2);

            public class B
            {
                public B();

                public A DoA(A2.A a);
                public B DoB(A1.B.B b);

                public class C
                {
                    public D d;
                    public D.E e;

                    public C();
                }
            }
        }
        public class D
        {
            public D();

            public class E
            {
                public E();
            }
        }
    }
}
namespace A1.B.B1
{
    public class B
    {
        public A a1;
        public A1.A a2;

        public B();
    }
}
using DLL;

namespace A
{
    public class A
    {
        public A();

        public class B
        {
            public B();

            public class A
            {
                public A();

                [Tested(new[] {typeof(A), typeof(A.A), typeof(B.A) })]
                public class C : A
                {
                    public C();

                    public class A : B.A
                    {
                        public A();

                        public class B : A.A.B.A
                        {
                            public B();

                            public class A
                            {
                                public A();
                            }
                        }
                    }
                }
            }
        }
    }
}
namespace DLL
{
    public enum TestEnum
    {
        A = 100,
        B = 10,
        C = -5,
        D = 0,
        E = 23,
        F = 24,
        G = 25,
        H = 26,
        I = 300
    }
}
namespace DLL
{
    public interface A<T>
    {
    }
}
namespace DLL
{
    public interface B
    {
    }
}
namespace DLL
{
    public class A1<T> : A<T>, B
    {
        public A1();

        public void DoA();
        public virtual void DoCrap<T1, T2>();
    }
}
namespace DLL
{
    public class B1<T> : A1<T> where T : class
    {
        public B1(int a);

        public event DoStuff stuff;

        public void DoB<U>(T stuff, U otherStuff) where U : class;

        public delegate void DoStuff(T stuff);
        public delegate void DoStuff<U>(T stuff, U otherStuff) where U : struct;
    }
}
using System.Collections.Generic;

namespace DLL
{
    public class C<T> : A1<T>, A<int>
    {
        public int[][][] array;
        public List<int[][]> list1;
        public List<int> list2;
        public List<int[][]>[][][] list3;

        public C();

        public List<int[][]>[][][] values { get; }
        public int c { get; set; }

        public override void DoCrap<T1, T2>();
        public bool[][][] IsCorrect(string[][][] str);
        public T[][][][][] Shit(T[] t);
        public U[][][] Stuff<U>(U[] u) where U : struct;
        public B1<object> DoB();
        public B1<int[][]> DoB1();
        public A1<T>[][] DoA1();

        public delegate int[][] DoArray(float[] array, char[][] str);
        public delegate T[][] DoT(T[][] array);
        public delegate List<int> DoList1(C<int>[] c);
        public delegate List<float[][][]> DoList2(C<int[][]> c);
        public delegate List<float[][][]>[][] DoList3(C<int[][]>[][] c);
    }
}
namespace DLL
{
    public class C1<T> : C<int>, A<T>
    {
        public C1();
    }
}
namespace DLL
{
    public delegate C<int[]>[][] DoCraft(B1<float[][][]> b);
}
namespace DLL
{
    public delegate C<int>[][] Do(B1<float[][][]> b);
}
namespace DLL
{
    public delegate T[][] DoShit<T>(T t);
}
namespace DLL
{
    public struct SomeStruct
    {
        public int a;
        public int b;
    }
}
namespace DLL
{
    public struct SomeOtherStruct
    {
        public SomeOtherStruct(int a);
    }
}
namespace DLL
{
    public static class StaticClass
    {
        public static int a;
    }
}
namespace DLL
{
    public static class OtherStaticClass
    {
    }
}
namespace DLL
{
    public interface I1
    {
        void Do1();
    }
}
namespace DLL
{
    public interface I2 : I1
    {
        void Do2();
    }
}
namespace DLL
{
    public interface I3 : I2, I1
    {
        void Do3();
    }
}
using System;

namespace DLL
{
    public class PublicAttribute : Attribute
    {
        public PublicAttribute();
    }
}
namespace DLL
{
    public static class ExtensionClass
    {
        public static void DoTest1(this SomeStruct a);
        public static void DoTest2(ref this SomeStruct a);
        public static void DoTest3(in this SomeStruct a);
    }
}
using System;

namespace DLL
{
    public class TestedAttribute : Attribute
    {
        public string str;
        public char[] charArray;
        public float[] floatArray;
        public double[] doubleArray;

        public TestedAttribute(string[] strArray);
        public TestedAttribute(params Type[] types);
        public TestedAttribute();
    }
}
using System.Diagnostics;

namespace DLL
{
    public class A
    {
        public char***[][][] pointer;

        public A();

        public int a { get; set; }

        [DebuggerTypeProxy(typeof(Generic<A>))]
        [DebuggerTypeProxy(typeof(A))]
        public class B : A
        {
            public B();

            public class A
            {
                public A();
            }
        }
        [Tested(new[] {typeof(A) })]
        public delegate void DoA([Tested] int a);
    }
}
using System;
using System.Runtime.CompilerServices;

namespace DLL
{
    [Tested(new[] {"SomeString", "SomeOther\tString" }, charArray = new[] {'a', 'b', 'c', '\0', '\n', '\'', '"' }, str = "C:\\Users\\scoleridge\\Documents\\")]
    [Internal]
    [Public]
    [NestedPrivate]
    [NestedPrivateProtected]
    [NestedProtectedInternal]
    [NestedInternal]
    public class TestInterface : I2, I3, InternalInterface, I4, I5, I6, I7, I1
    {
        public int? defaultInt;
        public TestInterface test;
        public SomeStruct someStruct;
        public const string esacpeString = "Tab\tNewline\nR\rSlash\\Null\0Alert\aBackspace\bFormFeed\fSingle'Double\"@, , , , , ";
        public const string filePath = "C:\\Users\\scoleridge\\Documents\\";
        public const string text = "My pensive SARA ! thy soft cheek reclined\r\n    Thus on mine arm, most soothing sweet it is\r\n    To sit beside our Cot,...";
        public const string quote = "Her name was \"Sara.\"My pensive SARA ! thy soft cheek reclined\r\n    Thus on mine arm, most soothing sweet it is\r\n    To sit beside our Cot,...";
        public const float kEpsilon = 1E-05F;
        public const float kEpsilonNormalSqrt = 1E-15F;
        public const double d1 = 0.3567;
        public const double d2 = 4;
        public const double d3 = 3.934001;
        public const float f1 = 3000.5F;
        public const float f2 = 5.4F;
        public const float f3 = 0;
        public const float f4 = 1;
        public const decimal de1 = 3000.5M;
        public const decimal de2 = 400.75M;
        public const decimal de3 = 10;
        public const int decimalLiteral = 42;
        public const int hexLiteral = 42;
        public const int binaryLiteral = 42;
        public const long maxInt = 2147483647;
        public static readonly int s_origin;
        public int stuff;

        public TestInterface();

        [Tested]
        public int a { get; protected internal set; }
        public int b { protected get; set; }
        public static ref readonly int Origin { get; }
        public ref int Stuff { get; }

        public void Do1();
        public void Do2();
        public void Do3();
        public void Do4();
        public void Do5();
        public void Do6();
        public void Do7();
        [Tested]
        [return: Tested]
        [return: Public]
        public void NoReturn([Tested] int a);
        [Tested]
        [return: Tested]
        [return: Internal]
        public int HasReturn([Tested(floatArray = new[] {1, 0, 3.5F, 1E-05F, 3000.5F, 5.960464E-08F }, doubleArray = new[] {4.94065645841247E-324, 1.40129846432482E-45, 1.11022302462516E-16 })][Internal] int a, [Public] decimal b = 100, decimal c = 0.56M);
        [Tested(new[] {typeof(Generic<>), typeof(Generic<int>), typeof(Generic<>.Nested), typeof(Generic<int>.Nested), typeof(Generic<>.NestedGeneric<, >), typeof(Generic<int>.NestedGeneric<string, float>) })]
        public void TestEscape(char a = '\n', char b = '\t', string c = "\"null\" and 'null', abc, and def fgh");
        [return: TupleElementNames(new[] {"myInt", "myString" })]
        public (int myInt, string myString) TestTuple();
        public ref int DoStuff();
        public ref readonly int DoOther();

        protected internal interface I7
        {
            void Do7();
        }
        protected internal class NestedProtectedInternal : Attribute
        {
            public NestedProtectedInternal();
        }
        protected class NestedProtectedType
        {
            public NestedProtectedType();
        }
        public class NestedTuple
        {
            public NestedTuple();

            [return: TupleElementNames(new[] {"myInt", "myString" })]
            public (int myInt, string myString) TestTuple();
        }
        public readonly struct ReadonlyStruct
        {
        }
        [Obsolete("Types with embedded references are not supported in this version of your compiler.", True)]
        public ref struct RefStruct
        {
        }
        [Obsolete("Types with embedded references are not supported in this version of your compiler.", True)]
        public readonly ref struct ReadonlyRefStruct
        {
        }
    }
}
using System.Runtime.CompilerServices;

namespace DLL
{
    public class Generic<[Tested] T>
    {
        [TupleElementNames(new[] {"c", "array", "i", "f", null })]
        public Generic<(char c, char***[] array)>.NestedGeneric<(int i, float f, bool), string> genericTupleField;
        [TupleElementNames(new[] {"a1", "a2", "b1", "b2", "b3", "b4", "c1", "c2", "d1", "d2", "e1", "e2" })]
        public Generic<(char a1, char a2)>.NestedGeneric<(char b1, char b2), (char b3, char b4)>.Nested1<(char c1, char c2)>.Nested2<(char d1, char d2)>.Nested3<(char e1, char e2)> nestedGenericField;
        [TupleElementNames(new[] {"a1", "a2", "b1", "b2", "b3", "b4", "c1", "c2", "ca1", "ca2", "cb1", "cb2", "d1", "d2", "e1", "e2" })]
        public Generic<(char a1, char a2)>.NestedGeneric<(char b1, char b2), (char b3, char b4)>.Nested1<(char c1, Generic<(char ca1, char ca2)>.NestedGeneric<(char cb1, char cb2), T> c2)>.Nested2<(char d1, char d2)>.Nested3<(char e1, char e2)> nestedGenericField2;

        public Generic();

        public Generic<T> DoStuff0<[Tested(new[] {typeof((int, string)), typeof(int?) })] U>(Nested p1, NestedGeneric<T, int> p2, NestedGeneric<T, U> p3);
        public Generic<U> DoStuff1<U>();
        public Generic<U>.Nested DoStuff2<U>(Generic<U>.NestedGeneric<T, int> parameter1, NestedGeneric<int, T> parameter2);
        public Generic<int>.Nested DoStuff3<U>(NestedGeneric<int, string> parameter1, Generic<int>.Nested parameter2);
        public (Generic<U>.Nested, Nested) DoStuffTuple<U>([TupleElementNames(new[] {null, "str" })][Tested] Generic<U>.NestedGeneric<T, (int, string str)> parameter1, [TupleElementNames(new[] {"myFloat", null, null, "c", null, "o" })] (float myFloat, bool, int, char c, string, object o) parameter2);
        public (int?, string) TestTuple();

        public class StructConstraint<U> where U : struct
        {
            public StructConstraint();

            public void Method<V>() where V : struct;
        }
        public class ClassConstraint<U> where U : class, new()
        {
            public ClassConstraint();

            public void Method<V>() where V : class;
        }
        public class NullClassConstraint<U> where U : class, new()
        {
            public NullClassConstraint();

            public void Method<V>() where V : class;
        }
        public class NotNullConstraint<U>
        {
            public NotNullConstraint();

            public void Method<V>();
        }
        public class NotNullMethod<U>
        {
            public NotNullMethod();

            public void Method<V>();
        }
        public class NotNullClass<U>
        {
            public NotNullClass();

            public void Method<V>();
        }
        public class UnmanagedConstraint<U> where U : unmanaged
        {
            public UnmanagedConstraint();

            public void Method<V>() where V : unmanaged;
        }
        public class ParameterConstraint<U> where U : T
        {
            public ParameterConstraint();

            public void Method<V>() where V : T;
        }
        public class Nested
        {
            public NestedGeneric<int, string> field;

            public Nested();

            public Generic<U>.Nested DoStuff<U>();

            public class NestedClass1 : Generic<int>
            {
                public NestedClass1();
            }
            public class NestedClass2 : Generic<T>
            {
                public NestedClass2();
            }
            public class NestedClass3<U> : Generic<U>
            {
                public NestedClass3();

                public class NestedClass : Generic<U>
                {
                    public NestedClass();
                }
            }
            public class NestedClass4<T> : Generic<T>
            {
                public NestedClass4();
            }
        }
        public class NestedClass : NestedGeneric<int, T>
        {
            public NestedClass();
        }
        public class NestedGeneric<U, [Tested] V>
        {
            public Generic<V>.NestedGeneric<T, U> field1;
            public NestedGeneric<int, T> field2;

            public NestedGeneric();

            public class Nested1<X>
            {
                public Nested1();

                public class Nested2<Y>
                {
                    public Nested2();

                    public class Nested3<Z>
                    {
                        public Nested3();
                    }
                }
            }
            public class NestedClass1 : NestedGeneric<string, T>
            {
                public NestedClass1();
            }
            public class NestedClass2 : NestedGeneric<string, bool>
            {
                public NestedClass2();
            }
            public class NestedClass3 : Generic<U>.NestedGeneric<float, T>
            {
                public NestedClass3();
            }
            public class NestedClass4<T> : Generic<T>.NestedGeneric<object, T>
            {
                public NestedClass4();

                public class NestedNested1 : Nested
                {
                    public NestedNested1();
                }
                public class NestedNested2 : NestedGeneric<U, V>
                {
                    public NestedNested2();
                }
                public class NestedNested3 : NestedGeneric<V, U>
                {
                    public NestedNested3();
                }
                public class NestedNested4 : NestedGeneric<float, float>
                {
                    public NestedNested4();
                }
                public class NestedNested5 : Generic<T>.NestedGeneric<float, float>
                {
                    public NestedNested5();
                }
                public class NestedNested6<T> : Generic<T>.NestedGeneric<T, char>
                {
                    public NestedNested6();
                }
                public class NestedNested7 : Generic<T>.NestedGeneric<T, bool>
                {
                    public NestedNested7();
                }
            }
            public class NestedClass5<J> : Generic<J>.NestedGeneric<string, bool>
            {
                public NestedClass5();

                public class NestedNested1 : Nested
                {
                    public NestedNested1();
                }
                public class NestedNested2 : NestedGeneric<U, V>
                {
                    public NestedNested2();
                }
                public class NestedNested3 : NestedGeneric<V, U>
                {
                    public NestedNested3();
                }
                public class NestedNested4 : NestedGeneric<float, float>
                {
                    public NestedNested4();
                }
                public class NestedNested5<T> : Generic<T>.NestedGeneric<T, char>
                {
                    public NestedNested5();
                }
                public class NestedNested6 : NestedGeneric<T, bool>
                {
                    public NestedNested6();
                }
                public class NestedNested7 : Generic<J>.NestedGeneric<T, string>
                {
                    public NestedNested7();
                }
                public class NestedNested8 : Generic<J>.NestedGeneric<T, string>.Nested1<char[]>
                {
                    public NestedNested8();
                }
            }
        }
        [TupleElementNames(new[] {"myStr", "myBool" })]
        public class GenericTuple : NestedGeneric<(string myStr, bool myBool), T>, Generic<(TestInterface, object)>.IGeneric<(int, float, Generic<int>)>
        {
            public GenericTuple();
        }
        [TupleElementNames(new[] {"nesteds", "generics", "array", "genericArray", "tuple1", "tuple2", "flags", null, "numbers", "other", "genericInt", null, null, "tuple", "myFloat", "myBool" })]
        public class GenericTuple2 : Generic<(Nested[] nesteds, NestedGeneric<(char[] array, Generic<((bool[] flags, string) tuple1, (int[] numbers, float[] other) tuple2)>[] genericArray), Generic<(int genericInt, Generic<(float, GenericTuple tuple)>)>> generics)>.NestedGeneric<(float myFloat, bool myBool), T>
        {
            public GenericTuple2();
        }
        public interface IGeneric<U>
        {
        }
    }
}
namespace DLL
{
    public interface IPublic
    {
        void M();
    }
}
namespace DLL
{
    public abstract class Bravo : IInternal
    {
        protected Bravo();
    }
}
namespace DLL
{
    public abstract class Charlie : Bravo, IPublic
    {
        protected Charlie();

        public void M();
    }
}
namespace DLL
{
    public sealed class Delta : Charlie
    {
        public Delta();
    }
}
namespace DLL
{
    public interface Interface
    {
        void DoInterface();
    }
}
using System.Runtime.CompilerServices;

namespace DLL
{
    public abstract class Base
    {
        protected Base();

        [return: TupleElementNames(new[] {"a", "b" })]
        public abstract (int a, int b) Foo();
    }
}
using System.Runtime.CompilerServices;

namespace DLL
{
    public class Derived : Base
    {
        public Derived();

        [return: TupleElementNames(new[] {"a", "b" })]
        public override (int a, int b) Foo();
    }
}
